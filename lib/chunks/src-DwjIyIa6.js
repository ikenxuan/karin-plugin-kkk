import { __commonJS, __require, __toESM, require_react } from "./react-tSI5bnDQ.js";
import { require_react_dom } from "./react-dom-DjLB5oxT.js";
import path from "node:path";
import process$1 from "node:process";
import os from "node:os";
import tty from "node:tty";
import fs, { existsSync, mkdirSync, writeFileSync } from "node:fs";

//#region ../../node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/vendor/ansi-styles/index.js
const ANSI_BACKGROUND_OFFSET = 10;
const wrapAnsi16 = (offset = 0) => (code) => `\u001B[${code + offset}m`;
const wrapAnsi256 = (offset = 0) => (code) => `\u001B[${38 + offset};5;${code}m`;
const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;
const styles$1 = {
	modifier: {
		reset: [0, 0],
		bold: [1, 22],
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		overline: [53, 55],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29]
	},
	color: {
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],
		blackBright: [90, 39],
		gray: [90, 39],
		grey: [90, 39],
		redBright: [91, 39],
		greenBright: [92, 39],
		yellowBright: [93, 39],
		blueBright: [94, 39],
		magentaBright: [95, 39],
		cyanBright: [96, 39],
		whiteBright: [97, 39]
	},
	bgColor: {
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49],
		bgBlackBright: [100, 49],
		bgGray: [100, 49],
		bgGrey: [100, 49],
		bgRedBright: [101, 49],
		bgGreenBright: [102, 49],
		bgYellowBright: [103, 49],
		bgBlueBright: [104, 49],
		bgMagentaBright: [105, 49],
		bgCyanBright: [106, 49],
		bgWhiteBright: [107, 49]
	}
};
const modifierNames = Object.keys(styles$1.modifier);
const foregroundColorNames = Object.keys(styles$1.color);
const backgroundColorNames = Object.keys(styles$1.bgColor);
const colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
	const codes = /* @__PURE__ */ new Map();
	for (const [groupName, group] of Object.entries(styles$1)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles$1[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};
			group[styleName] = styles$1[styleName];
			codes.set(style[0], style[1]);
		}
		Object.defineProperty(styles$1, groupName, {
			value: group,
			enumerable: false
		});
	}
	Object.defineProperty(styles$1, "codes", {
		value: codes,
		enumerable: false
	});
	styles$1.color.close = "\x1B[39m";
	styles$1.bgColor.close = "\x1B[49m";
	styles$1.color.ansi = wrapAnsi16();
	styles$1.color.ansi256 = wrapAnsi256();
	styles$1.color.ansi16m = wrapAnsi16m();
	styles$1.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
	styles$1.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
	styles$1.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
	Object.defineProperties(styles$1, {
		rgbToAnsi256: {
			value(red, green, blue) {
				if (red === green && green === blue) {
					if (red < 8) return 16;
					if (red > 248) return 231;
					return Math.round((red - 8) / 247 * 24) + 232;
				}
				return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
			},
			enumerable: false
		},
		hexToRgb: {
			value(hex) {
				const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
				if (!matches) return [
					0,
					0,
					0
				];
				let [colorString] = matches;
				if (colorString.length === 3) colorString = [...colorString].map((character) => character + character).join("");
				const integer = Number.parseInt(colorString, 16);
				return [
					integer >> 16 & 255,
					integer >> 8 & 255,
					integer & 255
				];
			},
			enumerable: false
		},
		hexToAnsi256: {
			value: (hex) => styles$1.rgbToAnsi256(...styles$1.hexToRgb(hex)),
			enumerable: false
		},
		ansi256ToAnsi: {
			value(code) {
				if (code < 8) return 30 + code;
				if (code < 16) return 90 + (code - 8);
				let red;
				let green;
				let blue;
				if (code >= 232) {
					red = ((code - 232) * 10 + 8) / 255;
					green = red;
					blue = red;
				} else {
					code -= 16;
					const remainder = code % 36;
					red = Math.floor(code / 36) / 5;
					green = Math.floor(remainder / 6) / 5;
					blue = remainder % 6 / 5;
				}
				const value = Math.max(red, green, blue) * 2;
				if (value === 0) return 30;
				let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
				if (value === 2) result += 60;
				return result;
			},
			enumerable: false
		},
		rgbToAnsi: {
			value: (red, green, blue) => styles$1.ansi256ToAnsi(styles$1.rgbToAnsi256(red, green, blue)),
			enumerable: false
		},
		hexToAnsi: {
			value: (hex) => styles$1.ansi256ToAnsi(styles$1.hexToAnsi256(hex)),
			enumerable: false
		}
	});
	return styles$1;
}
const ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

//#endregion
//#region ../../node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/vendor/supports-color/index.js
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : process$1.argv) {
	const prefix$2 = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
	const position = argv.indexOf(prefix$2 + flag);
	const terminatorPosition = argv.indexOf("--");
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
const { env } = process$1;
let flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) flagForceColor = 0;
else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) flagForceColor = 1;
function envForceColor() {
	if ("FORCE_COLOR" in env) {
		if (env.FORCE_COLOR === "true") return 1;
		if (env.FORCE_COLOR === "false") return 0;
		return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
	}
}
function translateLevel(level) {
	if (level === 0) return false;
	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
	const noFlagForceColor = envForceColor();
	if (noFlagForceColor !== void 0) flagForceColor = noFlagForceColor;
	const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
	if (forceColor === 0) return 0;
	if (sniffFlags) {
		if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) return 3;
		if (hasFlag("color=256")) return 2;
	}
	if ("TF_BUILD" in env && "AGENT_NAME" in env) return 1;
	if (haveStream && !streamIsTTY && forceColor === void 0) return 0;
	const min = forceColor || 0;
	if (env.TERM === "dumb") return min;
	if (process$1.platform === "win32") {
		const osRelease = os.release().split(".");
		if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) return Number(osRelease[2]) >= 14931 ? 3 : 2;
		return 1;
	}
	if ("CI" in env) {
		if ([
			"GITHUB_ACTIONS",
			"GITEA_ACTIONS",
			"CIRCLECI"
		].some((key) => key in env)) return 3;
		if ([
			"TRAVIS",
			"APPVEYOR",
			"GITLAB_CI",
			"BUILDKITE",
			"DRONE"
		].some((sign) => sign in env) || env.CI_NAME === "codeship") return 1;
		return min;
	}
	if ("TEAMCITY_VERSION" in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	if (env.COLORTERM === "truecolor") return 3;
	if (env.TERM === "xterm-kitty") return 3;
	if (env.TERM === "xterm-ghostty") return 3;
	if (env.TERM === "wezterm") return 3;
	if ("TERM_PROGRAM" in env) {
		const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
		switch (env.TERM_PROGRAM) {
			case "iTerm.app": return version >= 3 ? 3 : 2;
			case "Apple_Terminal": return 2;
		}
	}
	if (/-256(color)?$/i.test(env.TERM)) return 2;
	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) return 1;
	if ("COLORTERM" in env) return 1;
	return min;
}
function createSupportsColor(stream$1, options = {}) {
	return translateLevel(_supportsColor(stream$1, {
		streamIsTTY: stream$1 && stream$1.isTTY,
		...options
	}));
}
const supportsColor = {
	stdout: createSupportsColor({ isTTY: tty.isatty(1) }),
	stderr: createSupportsColor({ isTTY: tty.isatty(2) })
};
var supports_color_default = supportsColor;

//#endregion
//#region ../../node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
	let index = string.indexOf(substring);
	if (index === -1) return string;
	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = "";
	do {
		returnValue += string.slice(endIndex, index) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);
	returnValue += string.slice(endIndex);
	return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix$2, postfix, index) {
	let endIndex = 0;
	let returnValue = "";
	do {
		const gotCR = string[index - 1] === "\r";
		returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix$2 + (gotCR ? "\r\n" : "\n") + postfix;
		endIndex = index + 1;
		index = string.indexOf("\n", endIndex);
	} while (index !== -1);
	returnValue += string.slice(endIndex);
	return returnValue;
}

//#endregion
//#region ../../node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/index.js
const { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
const GENERATOR = Symbol("GENERATOR");
const STYLER = Symbol("STYLER");
const IS_EMPTY = Symbol("IS_EMPTY");
const levelMapping = [
	"ansi",
	"ansi",
	"ansi256",
	"ansi16m"
];
const styles = Object.create(null);
const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) throw new Error("The `level` option should be an integer from 0 to 3");
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === void 0 ? colorLevel : options.level;
};
var Chalk = class {
	constructor(options) {
		return chalkFactory(options);
	}
};
const chalkFactory = (options) => {
	const chalk$1 = (...strings) => strings.join(" ");
	applyOptions(chalk$1, options);
	Object.setPrototypeOf(chalk$1, createChalk.prototype);
	return chalk$1;
};
function createChalk(options) {
	return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) styles[styleName] = { get() {
	const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
	Object.defineProperty(this, styleName, { value: builder });
	return builder;
} };
styles.visible = { get() {
	const builder = createBuilder(this, this[STYLER], true);
	Object.defineProperty(this, "visible", { value: builder });
	return builder;
} };
const getModelAnsi = (model, level, type, ...arguments_) => {
	if (model === "rgb") {
		if (level === "ansi16m") return ansi_styles_default[type].ansi16m(...arguments_);
		if (level === "ansi256") return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
		return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
	}
	if (model === "hex") return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
	return ansi_styles_default[type][model](...arguments_);
};
for (const model of [
	"rgb",
	"hex",
	"ansi256"
]) {
	styles[model] = { get() {
		const { level } = this;
		return function(...arguments_) {
			const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
			return createBuilder(this, styler, this[IS_EMPTY]);
		};
	} };
	const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = { get() {
		const { level } = this;
		return function(...arguments_) {
			const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
			return createBuilder(this, styler, this[IS_EMPTY]);
		};
	} };
}
const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this[GENERATOR].level;
		},
		set(level) {
			this[GENERATOR].level = level;
		}
	}
});
const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === void 0) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}
	return {
		open,
		close,
		openAll,
		closeAll,
		parent
	};
};
const createBuilder = (self, _styler, _isEmpty) => {
	const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
	Object.setPrototypeOf(builder, proto);
	builder[GENERATOR] = self;
	builder[STYLER] = _styler;
	builder[IS_EMPTY] = _isEmpty;
	return builder;
};
const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) return self[IS_EMPTY] ? "" : string;
	let styler = self[STYLER];
	if (styler === void 0) return string;
	const { openAll, closeAll } = styler;
	if (string.includes("\x1B")) while (styler !== void 0) {
		string = stringReplaceAll(string, styler.close, styler.open);
		styler = styler.parent;
	}
	const lfIndex = string.indexOf("\n");
	if (lfIndex !== -1) string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles);
const chalk = createChalk();
const chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/can-promise.js
var require_can_promise = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/can-promise.js": ((exports, module) => {
	module.exports = function() {
		return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/utils.js
var require_utils$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/utils.js": ((exports) => {
	let toSJISFunction;
	const CODEWORDS_COUNT = [
		0,
		26,
		44,
		70,
		100,
		134,
		172,
		196,
		242,
		292,
		346,
		404,
		466,
		532,
		581,
		655,
		733,
		815,
		901,
		991,
		1085,
		1156,
		1258,
		1364,
		1474,
		1588,
		1706,
		1828,
		1921,
		2051,
		2185,
		2323,
		2465,
		2611,
		2761,
		2876,
		3034,
		3196,
		3362,
		3532,
		3706
	];
	/**
	* Returns the QR Code size for the specified version
	*
	* @param  {Number} version QR Code version
	* @return {Number}         size of QR code
	*/
	exports.getSymbolSize = function getSymbolSize$2(version) {
		if (!version) throw new Error("\"version\" cannot be null or undefined");
		if (version < 1 || version > 40) throw new Error("\"version\" should be in range from 1 to 40");
		return version * 4 + 17;
	};
	/**
	* Returns the total number of codewords used to store data and EC information.
	*
	* @param  {Number} version QR Code version
	* @return {Number}         Data length in bits
	*/
	exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {
		return CODEWORDS_COUNT[version];
	};
	/**
	* Encode data with Bose-Chaudhuri-Hocquenghem
	*
	* @param  {Number} data Value to encode
	* @return {Number}      Encoded value
	*/
	exports.getBCHDigit = function(data) {
		let digit = 0;
		while (data !== 0) {
			digit++;
			data >>>= 1;
		}
		return digit;
	};
	exports.setToSJISFunction = function setToSJISFunction(f) {
		if (typeof f !== "function") throw new Error("\"toSJISFunc\" is not a valid function.");
		toSJISFunction = f;
	};
	exports.isKanjiModeEnabled = function() {
		return typeof toSJISFunction !== "undefined";
	};
	exports.toSJIS = function toSJIS(kanji$1) {
		return toSJISFunction(kanji$1);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/error-correction-level.js": ((exports) => {
	exports.L = { bit: 1 };
	exports.M = { bit: 0 };
	exports.Q = { bit: 3 };
	exports.H = { bit: 2 };
	function fromString$1(string) {
		if (typeof string !== "string") throw new Error("Param is not a string");
		switch (string.toLowerCase()) {
			case "l":
			case "low": return exports.L;
			case "m":
			case "medium": return exports.M;
			case "q":
			case "quartile": return exports.Q;
			case "h":
			case "high": return exports.H;
			default: throw new Error("Unknown EC Level: " + string);
		}
	}
	exports.isValid = function isValid(level) {
		return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
	};
	exports.from = function from(value, defaultValue) {
		if (exports.isValid(value)) return value;
		try {
			return fromString$1(value);
		} catch (e) {
			return defaultValue;
		}
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/bit-buffer.js": ((exports, module) => {
	function BitBuffer$1() {
		this.buffer = [];
		this.length = 0;
	}
	BitBuffer$1.prototype = {
		get: function(index) {
			const bufIndex = Math.floor(index / 8);
			return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
		},
		put: function(num, length) {
			for (let i = 0; i < length; i++) this.putBit((num >>> length - i - 1 & 1) === 1);
		},
		getLengthInBits: function() {
			return this.length;
		},
		putBit: function(bit) {
			const bufIndex = Math.floor(this.length / 8);
			if (this.buffer.length <= bufIndex) this.buffer.push(0);
			if (bit) this.buffer[bufIndex] |= 128 >>> this.length % 8;
			this.length++;
		}
	};
	module.exports = BitBuffer$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/bit-matrix.js": ((exports, module) => {
	/**
	* Helper class to handle QR Code symbol modules
	*
	* @param {Number} size Symbol size
	*/
	function BitMatrix$1(size) {
		if (!size || size < 1) throw new Error("BitMatrix size must be defined and greater than 0");
		this.size = size;
		this.data = new Uint8Array(size * size);
		this.reservedBit = new Uint8Array(size * size);
	}
	/**
	* Set bit value at specified location
	* If reserved flag is set, this bit will be ignored during masking process
	*
	* @param {Number}  row
	* @param {Number}  col
	* @param {Boolean} value
	* @param {Boolean} reserved
	*/
	BitMatrix$1.prototype.set = function(row, col, value, reserved) {
		const index = row * this.size + col;
		this.data[index] = value;
		if (reserved) this.reservedBit[index] = true;
	};
	/**
	* Returns bit value at specified location
	*
	* @param  {Number}  row
	* @param  {Number}  col
	* @return {Boolean}
	*/
	BitMatrix$1.prototype.get = function(row, col) {
		return this.data[row * this.size + col];
	};
	/**
	* Applies xor operator at specified location
	* (used during masking process)
	*
	* @param {Number}  row
	* @param {Number}  col
	* @param {Boolean} value
	*/
	BitMatrix$1.prototype.xor = function(row, col, value) {
		this.data[row * this.size + col] ^= value;
	};
	/**
	* Check if bit at specified location is reserved
	*
	* @param {Number}   row
	* @param {Number}   col
	* @return {Boolean}
	*/
	BitMatrix$1.prototype.isReserved = function(row, col) {
		return this.reservedBit[row * this.size + col];
	};
	module.exports = BitMatrix$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/alignment-pattern.js": ((exports) => {
	/**
	* Alignment pattern are fixed reference pattern in defined positions
	* in a matrix symbology, which enables the decode software to re-synchronise
	* the coordinate mapping of the image modules in the event of moderate amounts
	* of distortion of the image.
	*
	* Alignment patterns are present only in QR Code symbols of version 2 or larger
	* and their number depends on the symbol version.
	*/
	const getSymbolSize$1 = require_utils$1().getSymbolSize;
	/**
	* Calculate the row/column coordinates of the center module of each alignment pattern
	* for the specified QR Code version.
	*
	* The alignment patterns are positioned symmetrically on either side of the diagonal
	* running from the top left corner of the symbol to the bottom right corner.
	*
	* Since positions are simmetrical only half of the coordinates are returned.
	* Each item of the array will represent in turn the x and y coordinate.
	* @see {@link getPositions}
	*
	* @param  {Number} version QR Code version
	* @return {Array}          Array of coordinate
	*/
	exports.getRowColCoords = function getRowColCoords(version) {
		if (version === 1) return [];
		const posCount = Math.floor(version / 7) + 2;
		const size = getSymbolSize$1(version);
		const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
		const positions = [size - 7];
		for (let i = 1; i < posCount - 1; i++) positions[i] = positions[i - 1] - intervals;
		positions.push(6);
		return positions.reverse();
	};
	/**
	* Returns an array containing the positions of each alignment pattern.
	* Each array's element represent the center point of the pattern as (x, y) coordinates
	*
	* Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}
	* and filtering out the items that overlaps with finder pattern
	*
	* @example
	* For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.
	* The alignment patterns, therefore, are to be centered on (row, column)
	* positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).
	* Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns
	* and are not therefore used for alignment patterns.
	*
	* let pos = getPositions(7)
	* // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]
	*
	* @param  {Number} version QR Code version
	* @return {Array}          Array of coordinates
	*/
	exports.getPositions = function getPositions(version) {
		const coords = [];
		const pos = exports.getRowColCoords(version);
		const posLength = pos.length;
		for (let i = 0; i < posLength; i++) for (let j = 0; j < posLength; j++) {
			if (i === 0 && j === 0 || i === 0 && j === posLength - 1 || i === posLength - 1 && j === 0) continue;
			coords.push([pos[i], pos[j]]);
		}
		return coords;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/finder-pattern.js": ((exports) => {
	const getSymbolSize = require_utils$1().getSymbolSize;
	const FINDER_PATTERN_SIZE = 7;
	/**
	* Returns an array containing the positions of each finder pattern.
	* Each array's element represent the top-left point of the pattern as (x, y) coordinates
	*
	* @param  {Number} version QR Code version
	* @return {Array}          Array of coordinates
	*/
	exports.getPositions = function getPositions(version) {
		const size = getSymbolSize(version);
		return [
			[0, 0],
			[size - FINDER_PATTERN_SIZE, 0],
			[0, size - FINDER_PATTERN_SIZE]
		];
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/mask-pattern.js": ((exports) => {
	/**
	* Data mask pattern reference
	* @type {Object}
	*/
	exports.Patterns = {
		PATTERN000: 0,
		PATTERN001: 1,
		PATTERN010: 2,
		PATTERN011: 3,
		PATTERN100: 4,
		PATTERN101: 5,
		PATTERN110: 6,
		PATTERN111: 7
	};
	/**
	* Weighted penalty scores for the undesirable features
	* @type {Object}
	*/
	const PenaltyScores = {
		N1: 3,
		N2: 3,
		N3: 40,
		N4: 10
	};
	/**
	* Check if mask pattern value is valid
	*
	* @param  {Number}  mask    Mask pattern
	* @return {Boolean}         true if valid, false otherwise
	*/
	exports.isValid = function isValid(mask) {
		return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
	};
	/**
	* Returns mask pattern from a value.
	* If value is not valid, returns undefined
	*
	* @param  {Number|String} value        Mask pattern value
	* @return {Number}                     Valid mask pattern or undefined
	*/
	exports.from = function from(value) {
		return exports.isValid(value) ? parseInt(value, 10) : void 0;
	};
	/**
	* Find adjacent modules in row/column with the same color
	* and assign a penalty value.
	*
	* Points: N1 + i
	* i is the amount by which the number of adjacent modules of the same color exceeds 5
	*/
	exports.getPenaltyN1 = function getPenaltyN1(data) {
		const size = data.size;
		let points = 0;
		let sameCountCol = 0;
		let sameCountRow = 0;
		let lastCol = null;
		let lastRow = null;
		for (let row = 0; row < size; row++) {
			sameCountCol = sameCountRow = 0;
			lastCol = lastRow = null;
			for (let col = 0; col < size; col++) {
				let module$1 = data.get(row, col);
				if (module$1 === lastCol) sameCountCol++;
				else {
					if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
					lastCol = module$1;
					sameCountCol = 1;
				}
				module$1 = data.get(col, row);
				if (module$1 === lastRow) sameCountRow++;
				else {
					if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
					lastRow = module$1;
					sameCountRow = 1;
				}
			}
			if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
			if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
		}
		return points;
	};
	/**
	* Find 2x2 blocks with the same color and assign a penalty value
	*
	* Points: N2 * (m - 1) * (n - 1)
	*/
	exports.getPenaltyN2 = function getPenaltyN2(data) {
		const size = data.size;
		let points = 0;
		for (let row = 0; row < size - 1; row++) for (let col = 0; col < size - 1; col++) {
			const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
			if (last === 4 || last === 0) points++;
		}
		return points * PenaltyScores.N2;
	};
	/**
	* Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,
	* preceded or followed by light area 4 modules wide
	*
	* Points: N3 * number of pattern found
	*/
	exports.getPenaltyN3 = function getPenaltyN3(data) {
		const size = data.size;
		let points = 0;
		let bitsCol = 0;
		let bitsRow = 0;
		for (let row = 0; row < size; row++) {
			bitsCol = bitsRow = 0;
			for (let col = 0; col < size; col++) {
				bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
				if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;
				bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
				if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;
			}
		}
		return points * PenaltyScores.N3;
	};
	/**
	* Calculate proportion of dark modules in entire symbol
	*
	* Points: N4 * k
	*
	* k is the rating of the deviation of the proportion of dark modules
	* in the symbol from 50% in steps of 5%
	*/
	exports.getPenaltyN4 = function getPenaltyN4(data) {
		let darkCount = 0;
		const modulesCount = data.data.length;
		for (let i = 0; i < modulesCount; i++) darkCount += data.data[i];
		return Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10) * PenaltyScores.N4;
	};
	/**
	* Return mask value at given position
	*
	* @param  {Number} maskPattern Pattern reference value
	* @param  {Number} i           Row
	* @param  {Number} j           Column
	* @return {Boolean}            Mask value
	*/
	function getMaskAt(maskPattern, i, j) {
		switch (maskPattern) {
			case exports.Patterns.PATTERN000: return (i + j) % 2 === 0;
			case exports.Patterns.PATTERN001: return i % 2 === 0;
			case exports.Patterns.PATTERN010: return j % 3 === 0;
			case exports.Patterns.PATTERN011: return (i + j) % 3 === 0;
			case exports.Patterns.PATTERN100: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
			case exports.Patterns.PATTERN101: return i * j % 2 + i * j % 3 === 0;
			case exports.Patterns.PATTERN110: return (i * j % 2 + i * j % 3) % 2 === 0;
			case exports.Patterns.PATTERN111: return (i * j % 3 + (i + j) % 2) % 2 === 0;
			default: throw new Error("bad maskPattern:" + maskPattern);
		}
	}
	/**
	* Apply a mask pattern to a BitMatrix
	*
	* @param  {Number}    pattern Pattern reference number
	* @param  {BitMatrix} data    BitMatrix data
	*/
	exports.applyMask = function applyMask(pattern, data) {
		const size = data.size;
		for (let col = 0; col < size; col++) for (let row = 0; row < size; row++) {
			if (data.isReserved(row, col)) continue;
			data.xor(row, col, getMaskAt(pattern, row, col));
		}
	};
	/**
	* Returns the best mask pattern for data
	*
	* @param  {BitMatrix} data
	* @return {Number} Mask pattern reference number
	*/
	exports.getBestMask = function getBestMask(data, setupFormatFunc) {
		const numPatterns = Object.keys(exports.Patterns).length;
		let bestPattern = 0;
		let lowerPenalty = Infinity;
		for (let p = 0; p < numPatterns; p++) {
			setupFormatFunc(p);
			exports.applyMask(p, data);
			const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
			exports.applyMask(p, data);
			if (penalty < lowerPenalty) {
				lowerPenalty = penalty;
				bestPattern = p;
			}
		}
		return bestPattern;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/error-correction-code.js": ((exports) => {
	const ECLevel$2 = require_error_correction_level();
	const EC_BLOCKS_TABLE = [
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		2,
		2,
		1,
		2,
		2,
		4,
		1,
		2,
		4,
		4,
		2,
		4,
		4,
		4,
		2,
		4,
		6,
		5,
		2,
		4,
		6,
		6,
		2,
		5,
		8,
		8,
		4,
		5,
		8,
		8,
		4,
		5,
		8,
		11,
		4,
		8,
		10,
		11,
		4,
		9,
		12,
		16,
		4,
		9,
		16,
		16,
		6,
		10,
		12,
		18,
		6,
		10,
		17,
		16,
		6,
		11,
		16,
		19,
		6,
		13,
		18,
		21,
		7,
		14,
		21,
		25,
		8,
		16,
		20,
		25,
		8,
		17,
		23,
		25,
		9,
		17,
		23,
		34,
		9,
		18,
		25,
		30,
		10,
		20,
		27,
		32,
		12,
		21,
		29,
		35,
		12,
		23,
		34,
		37,
		12,
		25,
		34,
		40,
		13,
		26,
		35,
		42,
		14,
		28,
		38,
		45,
		15,
		29,
		40,
		48,
		16,
		31,
		43,
		51,
		17,
		33,
		45,
		54,
		18,
		35,
		48,
		57,
		19,
		37,
		51,
		60,
		19,
		38,
		53,
		63,
		20,
		40,
		56,
		66,
		21,
		43,
		59,
		70,
		22,
		45,
		62,
		74,
		24,
		47,
		65,
		77,
		25,
		49,
		68,
		81
	];
	const EC_CODEWORDS_TABLE = [
		7,
		10,
		13,
		17,
		10,
		16,
		22,
		28,
		15,
		26,
		36,
		44,
		20,
		36,
		52,
		64,
		26,
		48,
		72,
		88,
		36,
		64,
		96,
		112,
		40,
		72,
		108,
		130,
		48,
		88,
		132,
		156,
		60,
		110,
		160,
		192,
		72,
		130,
		192,
		224,
		80,
		150,
		224,
		264,
		96,
		176,
		260,
		308,
		104,
		198,
		288,
		352,
		120,
		216,
		320,
		384,
		132,
		240,
		360,
		432,
		144,
		280,
		408,
		480,
		168,
		308,
		448,
		532,
		180,
		338,
		504,
		588,
		196,
		364,
		546,
		650,
		224,
		416,
		600,
		700,
		224,
		442,
		644,
		750,
		252,
		476,
		690,
		816,
		270,
		504,
		750,
		900,
		300,
		560,
		810,
		960,
		312,
		588,
		870,
		1050,
		336,
		644,
		952,
		1110,
		360,
		700,
		1020,
		1200,
		390,
		728,
		1050,
		1260,
		420,
		784,
		1140,
		1350,
		450,
		812,
		1200,
		1440,
		480,
		868,
		1290,
		1530,
		510,
		924,
		1350,
		1620,
		540,
		980,
		1440,
		1710,
		570,
		1036,
		1530,
		1800,
		570,
		1064,
		1590,
		1890,
		600,
		1120,
		1680,
		1980,
		630,
		1204,
		1770,
		2100,
		660,
		1260,
		1860,
		2220,
		720,
		1316,
		1950,
		2310,
		750,
		1372,
		2040,
		2430
	];
	/**
	* Returns the number of error correction block that the QR Code should contain
	* for the specified version and error correction level.
	*
	* @param  {Number} version              QR Code version
	* @param  {Number} errorCorrectionLevel Error correction level
	* @return {Number}                      Number of error correction blocks
	*/
	exports.getBlocksCount = function getBlocksCount(version, errorCorrectionLevel) {
		switch (errorCorrectionLevel) {
			case ECLevel$2.L: return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];
			case ECLevel$2.M: return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];
			case ECLevel$2.Q: return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];
			case ECLevel$2.H: return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];
			default: return;
		}
	};
	/**
	* Returns the number of error correction codewords to use for the specified
	* version and error correction level.
	*
	* @param  {Number} version              QR Code version
	* @param  {Number} errorCorrectionLevel Error correction level
	* @return {Number}                      Number of error correction codewords
	*/
	exports.getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel) {
		switch (errorCorrectionLevel) {
			case ECLevel$2.L: return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];
			case ECLevel$2.M: return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];
			case ECLevel$2.Q: return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];
			case ECLevel$2.H: return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];
			default: return;
		}
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/galois-field.js": ((exports) => {
	const EXP_TABLE = new Uint8Array(512);
	const LOG_TABLE = new Uint8Array(256);
	(function initTables() {
		let x = 1;
		for (let i = 0; i < 255; i++) {
			EXP_TABLE[i] = x;
			LOG_TABLE[x] = i;
			x <<= 1;
			if (x & 256) x ^= 285;
		}
		for (let i = 255; i < 512; i++) EXP_TABLE[i] = EXP_TABLE[i - 255];
	})();
	/**
	* Returns log value of n inside Galois Field
	*
	* @param  {Number} n
	* @return {Number}
	*/
	exports.log = function log$2(n) {
		if (n < 1) throw new Error("log(" + n + ")");
		return LOG_TABLE[n];
	};
	/**
	* Returns anti-log value of n inside Galois Field
	*
	* @param  {Number} n
	* @return {Number}
	*/
	exports.exp = function exp(n) {
		return EXP_TABLE[n];
	};
	/**
	* Multiplies two number inside Galois Field
	*
	* @param  {Number} x
	* @param  {Number} y
	* @return {Number}
	*/
	exports.mul = function mul(x, y) {
		if (x === 0 || y === 0) return 0;
		return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/polynomial.js": ((exports) => {
	const GF = require_galois_field();
	/**
	* Multiplies two polynomials inside Galois Field
	*
	* @param  {Uint8Array} p1 Polynomial
	* @param  {Uint8Array} p2 Polynomial
	* @return {Uint8Array}    Product of p1 and p2
	*/
	exports.mul = function mul(p1, p2) {
		const coeff = new Uint8Array(p1.length + p2.length - 1);
		for (let i = 0; i < p1.length; i++) for (let j = 0; j < p2.length; j++) coeff[i + j] ^= GF.mul(p1[i], p2[j]);
		return coeff;
	};
	/**
	* Calculate the remainder of polynomials division
	*
	* @param  {Uint8Array} divident Polynomial
	* @param  {Uint8Array} divisor  Polynomial
	* @return {Uint8Array}          Remainder
	*/
	exports.mod = function mod(divident, divisor) {
		let result = new Uint8Array(divident);
		while (result.length - divisor.length >= 0) {
			const coeff = result[0];
			for (let i = 0; i < divisor.length; i++) result[i] ^= GF.mul(divisor[i], coeff);
			let offset = 0;
			while (offset < result.length && result[offset] === 0) offset++;
			result = result.slice(offset);
		}
		return result;
	};
	/**
	* Generate an irreducible generator polynomial of specified degree
	* (used by Reed-Solomon encoder)
	*
	* @param  {Number} degree Degree of the generator polynomial
	* @return {Uint8Array}    Buffer containing polynomial coefficients
	*/
	exports.generateECPolynomial = function generateECPolynomial(degree) {
		let poly = new Uint8Array([1]);
		for (let i = 0; i < degree; i++) poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]));
		return poly;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/reed-solomon-encoder.js": ((exports, module) => {
	const Polynomial = require_polynomial();
	function ReedSolomonEncoder$1(degree) {
		this.genPoly = void 0;
		this.degree = degree;
		if (this.degree) this.initialize(this.degree);
	}
	/**
	* Initialize the encoder.
	* The input param should correspond to the number of error correction codewords.
	*
	* @param  {Number} degree
	*/
	ReedSolomonEncoder$1.prototype.initialize = function initialize(degree) {
		this.degree = degree;
		this.genPoly = Polynomial.generateECPolynomial(this.degree);
	};
	/**
	* Encodes a chunk of data
	*
	* @param  {Uint8Array} data Buffer containing input data
	* @return {Uint8Array}      Buffer containing encoded data
	*/
	ReedSolomonEncoder$1.prototype.encode = function encode(data) {
		if (!this.genPoly) throw new Error("Encoder not initialized");
		const paddedData = new Uint8Array(data.length + this.degree);
		paddedData.set(data);
		const remainder = Polynomial.mod(paddedData, this.genPoly);
		const start = this.degree - remainder.length;
		if (start > 0) {
			const buff = new Uint8Array(this.degree);
			buff.set(remainder, start);
			return buff;
		}
		return remainder;
	};
	module.exports = ReedSolomonEncoder$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/version-check.js
var require_version_check = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/version-check.js": ((exports) => {
	/**
	* Check if QR Code version is valid
	*
	* @param  {Number}  version QR Code version
	* @return {Boolean}         true if valid version, false otherwise
	*/
	exports.isValid = function isValid(version) {
		return !isNaN(version) && version >= 1 && version <= 40;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/regex.js
var require_regex = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/regex.js": ((exports) => {
	const numeric = "[0-9]+";
	const alphanumeric = "[A-Z $%*+\\-./:]+";
	let kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
	kanji = kanji.replace(/u/g, "\\u");
	const byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
	exports.KANJI = new RegExp(kanji, "g");
	exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
	exports.BYTE = new RegExp(byte, "g");
	exports.NUMERIC = new RegExp(numeric, "g");
	exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
	const TEST_KANJI = /* @__PURE__ */ new RegExp("^" + kanji + "$");
	const TEST_NUMERIC = /* @__PURE__ */ new RegExp("^" + numeric + "$");
	const TEST_ALPHANUMERIC = /* @__PURE__ */ new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
	exports.testKanji = function testKanji(str) {
		return TEST_KANJI.test(str);
	};
	exports.testNumeric = function testNumeric(str) {
		return TEST_NUMERIC.test(str);
	};
	exports.testAlphanumeric = function testAlphanumeric(str) {
		return TEST_ALPHANUMERIC.test(str);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/mode.js
var require_mode = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/mode.js": ((exports) => {
	const VersionCheck$1 = require_version_check();
	const Regex$1 = require_regex();
	/**
	* Numeric mode encodes data from the decimal digit set (0 - 9)
	* (byte values 30HEX to 39HEX).
	* Normally, 3 data characters are represented by 10 bits.
	*
	* @type {Object}
	*/
	exports.NUMERIC = {
		id: "Numeric",
		bit: 1,
		ccBits: [
			10,
			12,
			14
		]
	};
	/**
	* Alphanumeric mode encodes data from a set of 45 characters,
	* i.e. 10 numeric digits (0 - 9),
	*      26 alphabetic characters (A - Z),
	*   and 9 symbols (SP, $, %, *, +, -, ., /, :).
	* Normally, two input characters are represented by 11 bits.
	*
	* @type {Object}
	*/
	exports.ALPHANUMERIC = {
		id: "Alphanumeric",
		bit: 2,
		ccBits: [
			9,
			11,
			13
		]
	};
	/**
	* In byte mode, data is encoded at 8 bits per character.
	*
	* @type {Object}
	*/
	exports.BYTE = {
		id: "Byte",
		bit: 4,
		ccBits: [
			8,
			16,
			16
		]
	};
	/**
	* The Kanji mode efficiently encodes Kanji characters in accordance with
	* the Shift JIS system based on JIS X 0208.
	* The Shift JIS values are shifted from the JIS X 0208 values.
	* JIS X 0208 gives details of the shift coded representation.
	* Each two-byte character value is compacted to a 13-bit binary codeword.
	*
	* @type {Object}
	*/
	exports.KANJI = {
		id: "Kanji",
		bit: 8,
		ccBits: [
			8,
			10,
			12
		]
	};
	/**
	* Mixed mode will contain a sequences of data in a combination of any of
	* the modes described above
	*
	* @type {Object}
	*/
	exports.MIXED = { bit: -1 };
	/**
	* Returns the number of bits needed to store the data length
	* according to QR Code specifications.
	*
	* @param  {Mode}   mode    Data mode
	* @param  {Number} version QR Code version
	* @return {Number}         Number of bits
	*/
	exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {
		if (!mode.ccBits) throw new Error("Invalid mode: " + mode);
		if (!VersionCheck$1.isValid(version)) throw new Error("Invalid version: " + version);
		if (version >= 1 && version < 10) return mode.ccBits[0];
		else if (version < 27) return mode.ccBits[1];
		return mode.ccBits[2];
	};
	/**
	* Returns the most efficient mode to store the specified data
	*
	* @param  {String} dataStr Input data string
	* @return {Mode}           Best mode
	*/
	exports.getBestModeForData = function getBestModeForData(dataStr) {
		if (Regex$1.testNumeric(dataStr)) return exports.NUMERIC;
		else if (Regex$1.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;
		else if (Regex$1.testKanji(dataStr)) return exports.KANJI;
		else return exports.BYTE;
	};
	/**
	* Return mode name as string
	*
	* @param {Mode} mode Mode object
	* @returns {String}  Mode name
	*/
	exports.toString = function toString(mode) {
		if (mode && mode.id) return mode.id;
		throw new Error("Invalid mode");
	};
	/**
	* Check if input param is a valid mode object
	*
	* @param   {Mode}    mode Mode object
	* @returns {Boolean} True if valid mode, false otherwise
	*/
	exports.isValid = function isValid(mode) {
		return mode && mode.bit && mode.ccBits;
	};
	/**
	* Get mode object from its name
	*
	* @param   {String} string Mode name
	* @returns {Mode}          Mode object
	*/
	function fromString(string) {
		if (typeof string !== "string") throw new Error("Param is not a string");
		switch (string.toLowerCase()) {
			case "numeric": return exports.NUMERIC;
			case "alphanumeric": return exports.ALPHANUMERIC;
			case "kanji": return exports.KANJI;
			case "byte": return exports.BYTE;
			default: throw new Error("Unknown mode: " + string);
		}
	}
	/**
	* Returns mode from a value.
	* If value is not a valid mode, returns defaultValue
	*
	* @param  {Mode|String} value        Encoding mode
	* @param  {Mode}        defaultValue Fallback value
	* @return {Mode}                     Encoding mode
	*/
	exports.from = function from(value, defaultValue) {
		if (exports.isValid(value)) return value;
		try {
			return fromString(value);
		} catch (e) {
			return defaultValue;
		}
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/version.js
var require_version = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/version.js": ((exports) => {
	const Utils$8 = require_utils$1();
	const ECCode$1 = require_error_correction_code();
	const ECLevel$1 = require_error_correction_level();
	const Mode$6 = require_mode();
	const VersionCheck = require_version_check();
	const G18 = 7973;
	const G18_BCH = Utils$8.getBCHDigit(G18);
	function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
		for (let currentVersion = 1; currentVersion <= 40; currentVersion++) if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) return currentVersion;
	}
	function getReservedBitsCount(mode, version) {
		return Mode$6.getCharCountIndicator(mode, version) + 4;
	}
	function getTotalBitsFromDataArray(segments, version) {
		let totalBits = 0;
		segments.forEach(function(data) {
			const reservedBits = getReservedBitsCount(data.mode, version);
			totalBits += reservedBits + data.getBitsLength();
		});
		return totalBits;
	}
	function getBestVersionForMixedData(segments, errorCorrectionLevel) {
		for (let currentVersion = 1; currentVersion <= 40; currentVersion++) if (getTotalBitsFromDataArray(segments, currentVersion) <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode$6.MIXED)) return currentVersion;
	}
	/**
	* Returns version number from a value.
	* If value is not a valid version, returns defaultValue
	*
	* @param  {Number|String} value        QR Code version
	* @param  {Number}        defaultValue Fallback value
	* @return {Number}                     QR Code version number
	*/
	exports.from = function from(value, defaultValue) {
		if (VersionCheck.isValid(value)) return parseInt(value, 10);
		return defaultValue;
	};
	/**
	* Returns how much data can be stored with the specified QR code version
	* and error correction level
	*
	* @param  {Number} version              QR Code version (1-40)
	* @param  {Number} errorCorrectionLevel Error correction level
	* @param  {Mode}   mode                 Data mode
	* @return {Number}                      Quantity of storable data
	*/
	exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode) {
		if (!VersionCheck.isValid(version)) throw new Error("Invalid QR Code version");
		if (typeof mode === "undefined") mode = Mode$6.BYTE;
		const dataTotalCodewordsBits = (Utils$8.getSymbolTotalCodewords(version) - ECCode$1.getTotalCodewordsCount(version, errorCorrectionLevel)) * 8;
		if (mode === Mode$6.MIXED) return dataTotalCodewordsBits;
		const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);
		switch (mode) {
			case Mode$6.NUMERIC: return Math.floor(usableBits / 10 * 3);
			case Mode$6.ALPHANUMERIC: return Math.floor(usableBits / 11 * 2);
			case Mode$6.KANJI: return Math.floor(usableBits / 13);
			case Mode$6.BYTE:
			default: return Math.floor(usableBits / 8);
		}
	};
	/**
	* Returns the minimum version needed to contain the amount of data
	*
	* @param  {Segment} data                    Segment of data
	* @param  {Number} [errorCorrectionLevel=H] Error correction level
	* @param  {Mode} mode                       Data mode
	* @return {Number}                          QR Code version
	*/
	exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
		let seg;
		const ecl = ECLevel$1.from(errorCorrectionLevel, ECLevel$1.M);
		if (Array.isArray(data)) {
			if (data.length > 1) return getBestVersionForMixedData(data, ecl);
			if (data.length === 0) return 1;
			seg = data[0];
		} else seg = data;
		return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
	};
	/**
	* Returns version information with relative error correction bits
	*
	* The version information is included in QR Code symbols of version 7 or larger.
	* It consists of an 18-bit sequence containing 6 data bits,
	* with 12 error correction bits calculated using the (18, 6) Golay code.
	*
	* @param  {Number} version QR Code version
	* @return {Number}         Encoded version info bits
	*/
	exports.getEncodedBits = function getEncodedBits(version) {
		if (!VersionCheck.isValid(version) || version < 7) throw new Error("Invalid QR Code version");
		let d = version << 12;
		while (Utils$8.getBCHDigit(d) - G18_BCH >= 0) d ^= G18 << Utils$8.getBCHDigit(d) - G18_BCH;
		return version << 12 | d;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/format-info.js
var require_format_info = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/format-info.js": ((exports) => {
	const Utils$7 = require_utils$1();
	const G15 = 1335;
	const G15_MASK = 21522;
	const G15_BCH = Utils$7.getBCHDigit(G15);
	/**
	* Returns format information with relative error correction bits
	*
	* The format information is a 15-bit sequence containing 5 data bits,
	* with 10 error correction bits calculated using the (15, 5) BCH code.
	*
	* @param  {Number} errorCorrectionLevel Error correction level
	* @param  {Number} mask                 Mask pattern
	* @return {Number}                      Encoded format information bits
	*/
	exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
		const data = errorCorrectionLevel.bit << 3 | mask;
		let d = data << 10;
		while (Utils$7.getBCHDigit(d) - G15_BCH >= 0) d ^= G15 << Utils$7.getBCHDigit(d) - G15_BCH;
		return (data << 10 | d) ^ G15_MASK;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/numeric-data.js": ((exports, module) => {
	const Mode$5 = require_mode();
	function NumericData$1(data) {
		this.mode = Mode$5.NUMERIC;
		this.data = data.toString();
	}
	NumericData$1.getBitsLength = function getBitsLength(length) {
		return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
	};
	NumericData$1.prototype.getLength = function getLength() {
		return this.data.length;
	};
	NumericData$1.prototype.getBitsLength = function getBitsLength() {
		return NumericData$1.getBitsLength(this.data.length);
	};
	NumericData$1.prototype.write = function write(bitBuffer) {
		let i, group, value;
		for (i = 0; i + 3 <= this.data.length; i += 3) {
			group = this.data.substr(i, 3);
			value = parseInt(group, 10);
			bitBuffer.put(value, 10);
		}
		const remainingNum = this.data.length - i;
		if (remainingNum > 0) {
			group = this.data.substr(i);
			value = parseInt(group, 10);
			bitBuffer.put(value, remainingNum * 3 + 1);
		}
	};
	module.exports = NumericData$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/alphanumeric-data.js": ((exports, module) => {
	const Mode$4 = require_mode();
	/**
	* Array of characters available in alphanumeric mode
	*
	* As per QR Code specification, to each character
	* is assigned a value from 0 to 44 which in this case coincides
	* with the array index
	*
	* @type {Array}
	*/
	const ALPHA_NUM_CHARS = [
		"0",
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7",
		"8",
		"9",
		"A",
		"B",
		"C",
		"D",
		"E",
		"F",
		"G",
		"H",
		"I",
		"J",
		"K",
		"L",
		"M",
		"N",
		"O",
		"P",
		"Q",
		"R",
		"S",
		"T",
		"U",
		"V",
		"W",
		"X",
		"Y",
		"Z",
		" ",
		"$",
		"%",
		"*",
		"+",
		"-",
		".",
		"/",
		":"
	];
	function AlphanumericData$1(data) {
		this.mode = Mode$4.ALPHANUMERIC;
		this.data = data;
	}
	AlphanumericData$1.getBitsLength = function getBitsLength(length) {
		return 11 * Math.floor(length / 2) + 6 * (length % 2);
	};
	AlphanumericData$1.prototype.getLength = function getLength() {
		return this.data.length;
	};
	AlphanumericData$1.prototype.getBitsLength = function getBitsLength() {
		return AlphanumericData$1.getBitsLength(this.data.length);
	};
	AlphanumericData$1.prototype.write = function write(bitBuffer) {
		let i;
		for (i = 0; i + 2 <= this.data.length; i += 2) {
			let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;
			value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);
			bitBuffer.put(value, 11);
		}
		if (this.data.length % 2) bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
	};
	module.exports = AlphanumericData$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/byte-data.js": ((exports, module) => {
	const Mode$3 = require_mode();
	function ByteData$1(data) {
		this.mode = Mode$3.BYTE;
		if (typeof data === "string") this.data = new TextEncoder().encode(data);
		else this.data = new Uint8Array(data);
	}
	ByteData$1.getBitsLength = function getBitsLength(length) {
		return length * 8;
	};
	ByteData$1.prototype.getLength = function getLength() {
		return this.data.length;
	};
	ByteData$1.prototype.getBitsLength = function getBitsLength() {
		return ByteData$1.getBitsLength(this.data.length);
	};
	ByteData$1.prototype.write = function(bitBuffer) {
		for (let i = 0, l$1 = this.data.length; i < l$1; i++) bitBuffer.put(this.data[i], 8);
	};
	module.exports = ByteData$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/kanji-data.js": ((exports, module) => {
	const Mode$2 = require_mode();
	const Utils$6 = require_utils$1();
	function KanjiData$1(data) {
		this.mode = Mode$2.KANJI;
		this.data = data;
	}
	KanjiData$1.getBitsLength = function getBitsLength(length) {
		return length * 13;
	};
	KanjiData$1.prototype.getLength = function getLength() {
		return this.data.length;
	};
	KanjiData$1.prototype.getBitsLength = function getBitsLength() {
		return KanjiData$1.getBitsLength(this.data.length);
	};
	KanjiData$1.prototype.write = function(bitBuffer) {
		let i;
		for (i = 0; i < this.data.length; i++) {
			let value = Utils$6.toSJIS(this.data[i]);
			if (value >= 33088 && value <= 40956) value -= 33088;
			else if (value >= 57408 && value <= 60351) value -= 49472;
			else throw new Error("Invalid SJIS character: " + this.data[i] + "\nMake sure your charset is UTF-8");
			value = (value >>> 8 & 255) * 192 + (value & 255);
			bitBuffer.put(value, 13);
		}
	};
	module.exports = KanjiData$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/dijkstrajs@1.0.3/node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/dijkstrajs@1.0.3/node_modules/dijkstrajs/dijkstra.js": ((exports, module) => {
	/******************************************************************************
	* Created 2008-08-19.
	*
	* Dijkstra path-finding functions. Adapted from the Dijkstar Python project.
	*
	* Copyright (C) 2008
	*   Wyatt Baldwin <self@wyattbaldwin.com>
	*   All rights reserved
	*
	* Licensed under the MIT license.
	*
	*   http://www.opensource.org/licenses/mit-license.php
	*
	* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	* THE SOFTWARE.
	*****************************************************************************/
	var dijkstra$1 = {
		single_source_shortest_paths: function(graph, s$1, d) {
			var predecessors = {};
			var costs = {};
			costs[s$1] = 0;
			var open = dijkstra$1.PriorityQueue.make();
			open.push(s$1, 0);
			var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
			while (!open.empty()) {
				closest = open.pop();
				u = closest.value;
				cost_of_s_to_u = closest.cost;
				adjacent_nodes = graph[u] || {};
				for (v in adjacent_nodes) if (adjacent_nodes.hasOwnProperty(v)) {
					cost_of_e = adjacent_nodes[v];
					cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
					cost_of_s_to_v = costs[v];
					first_visit = typeof costs[v] === "undefined";
					if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
						costs[v] = cost_of_s_to_u_plus_cost_of_e;
						open.push(v, cost_of_s_to_u_plus_cost_of_e);
						predecessors[v] = u;
					}
				}
			}
			if (typeof d !== "undefined" && typeof costs[d] === "undefined") {
				var msg = [
					"Could not find a path from ",
					s$1,
					" to ",
					d,
					"."
				].join("");
				throw new Error(msg);
			}
			return predecessors;
		},
		extract_shortest_path_from_predecessor_list: function(predecessors, d) {
			var nodes = [];
			var u = d;
			while (u) {
				nodes.push(u);
				predecessors[u];
				u = predecessors[u];
			}
			nodes.reverse();
			return nodes;
		},
		find_path: function(graph, s$1, d) {
			var predecessors = dijkstra$1.single_source_shortest_paths(graph, s$1, d);
			return dijkstra$1.extract_shortest_path_from_predecessor_list(predecessors, d);
		},
		PriorityQueue: {
			make: function(opts) {
				var T = dijkstra$1.PriorityQueue, t = {}, key;
				opts = opts || {};
				for (key in T) if (T.hasOwnProperty(key)) t[key] = T[key];
				t.queue = [];
				t.sorter = opts.sorter || T.default_sorter;
				return t;
			},
			default_sorter: function(a, b) {
				return a.cost - b.cost;
			},
			push: function(value, cost) {
				var item = {
					value,
					cost
				};
				this.queue.push(item);
				this.queue.sort(this.sorter);
			},
			pop: function() {
				return this.queue.shift();
			},
			empty: function() {
				return this.queue.length === 0;
			}
		}
	};
	if (typeof module !== "undefined") module.exports = dijkstra$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/segments.js
var require_segments = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/segments.js": ((exports) => {
	const Mode$1 = require_mode();
	const NumericData = require_numeric_data();
	const AlphanumericData = require_alphanumeric_data();
	const ByteData = require_byte_data();
	const KanjiData = require_kanji_data();
	const Regex = require_regex();
	const Utils$5 = require_utils$1();
	const dijkstra = require_dijkstra();
	/**
	* Returns UTF8 byte length
	*
	* @param  {String} str Input string
	* @return {Number}     Number of byte
	*/
	function getStringByteLength(str) {
		return unescape(encodeURIComponent(str)).length;
	}
	/**
	* Get a list of segments of the specified mode
	* from a string
	*
	* @param  {Mode}   mode Segment mode
	* @param  {String} str  String to process
	* @return {Array}       Array of object with segments data
	*/
	function getSegments(regex, mode, str) {
		const segments = [];
		let result;
		while ((result = regex.exec(str)) !== null) segments.push({
			data: result[0],
			index: result.index,
			mode,
			length: result[0].length
		});
		return segments;
	}
	/**
	* Extracts a series of segments with the appropriate
	* modes from a string
	*
	* @param  {String} dataStr Input string
	* @return {Array}          Array of object with segments data
	*/
	function getSegmentsFromString(dataStr) {
		const numSegs = getSegments(Regex.NUMERIC, Mode$1.NUMERIC, dataStr);
		const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode$1.ALPHANUMERIC, dataStr);
		let byteSegs;
		let kanjiSegs;
		if (Utils$5.isKanjiModeEnabled()) {
			byteSegs = getSegments(Regex.BYTE, Mode$1.BYTE, dataStr);
			kanjiSegs = getSegments(Regex.KANJI, Mode$1.KANJI, dataStr);
		} else {
			byteSegs = getSegments(Regex.BYTE_KANJI, Mode$1.BYTE, dataStr);
			kanjiSegs = [];
		}
		return numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs).sort(function(s1, s2) {
			return s1.index - s2.index;
		}).map(function(obj) {
			return {
				data: obj.data,
				mode: obj.mode,
				length: obj.length
			};
		});
	}
	/**
	* Returns how many bits are needed to encode a string of
	* specified length with the specified mode
	*
	* @param  {Number} length String length
	* @param  {Mode} mode     Segment mode
	* @return {Number}        Bit length
	*/
	function getSegmentBitsLength(length, mode) {
		switch (mode) {
			case Mode$1.NUMERIC: return NumericData.getBitsLength(length);
			case Mode$1.ALPHANUMERIC: return AlphanumericData.getBitsLength(length);
			case Mode$1.KANJI: return KanjiData.getBitsLength(length);
			case Mode$1.BYTE: return ByteData.getBitsLength(length);
		}
	}
	/**
	* Merges adjacent segments which have the same mode
	*
	* @param  {Array} segs Array of object with segments data
	* @return {Array}      Array of object with segments data
	*/
	function mergeSegments(segs) {
		return segs.reduce(function(acc, curr) {
			const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
			if (prevSeg && prevSeg.mode === curr.mode) {
				acc[acc.length - 1].data += curr.data;
				return acc;
			}
			acc.push(curr);
			return acc;
		}, []);
	}
	/**
	* Generates a list of all possible nodes combination which
	* will be used to build a segments graph.
	*
	* Nodes are divided by groups. Each group will contain a list of all the modes
	* in which is possible to encode the given text.
	*
	* For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.
	* The group for '12345' will contain then 3 objects, one for each
	* possible encoding mode.
	*
	* Each node represents a possible segment.
	*
	* @param  {Array} segs Array of object with segments data
	* @return {Array}      Array of object with segments data
	*/
	function buildNodes(segs) {
		const nodes = [];
		for (let i = 0; i < segs.length; i++) {
			const seg = segs[i];
			switch (seg.mode) {
				case Mode$1.NUMERIC:
					nodes.push([
						seg,
						{
							data: seg.data,
							mode: Mode$1.ALPHANUMERIC,
							length: seg.length
						},
						{
							data: seg.data,
							mode: Mode$1.BYTE,
							length: seg.length
						}
					]);
					break;
				case Mode$1.ALPHANUMERIC:
					nodes.push([seg, {
						data: seg.data,
						mode: Mode$1.BYTE,
						length: seg.length
					}]);
					break;
				case Mode$1.KANJI:
					nodes.push([seg, {
						data: seg.data,
						mode: Mode$1.BYTE,
						length: getStringByteLength(seg.data)
					}]);
					break;
				case Mode$1.BYTE: nodes.push([{
					data: seg.data,
					mode: Mode$1.BYTE,
					length: getStringByteLength(seg.data)
				}]);
			}
		}
		return nodes;
	}
	/**
	* Builds a graph from a list of nodes.
	* All segments in each node group will be connected with all the segments of
	* the next group and so on.
	*
	* At each connection will be assigned a weight depending on the
	* segment's byte length.
	*
	* @param  {Array} nodes    Array of object with segments data
	* @param  {Number} version QR Code version
	* @return {Object}         Graph of all possible segments
	*/
	function buildGraph(nodes, version) {
		const table = {};
		const graph = { start: {} };
		let prevNodeIds = ["start"];
		for (let i = 0; i < nodes.length; i++) {
			const nodeGroup = nodes[i];
			const currentNodeIds = [];
			for (let j = 0; j < nodeGroup.length; j++) {
				const node = nodeGroup[j];
				const key = "" + i + j;
				currentNodeIds.push(key);
				table[key] = {
					node,
					lastCount: 0
				};
				graph[key] = {};
				for (let n = 0; n < prevNodeIds.length; n++) {
					const prevNodeId = prevNodeIds[n];
					if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
						graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
						table[prevNodeId].lastCount += node.length;
					} else {
						if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;
						graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode$1.getCharCountIndicator(node.mode, version);
					}
				}
			}
			prevNodeIds = currentNodeIds;
		}
		for (let n = 0; n < prevNodeIds.length; n++) graph[prevNodeIds[n]].end = 0;
		return {
			map: graph,
			table
		};
	}
	/**
	* Builds a segment from a specified data and mode.
	* If a mode is not specified, the more suitable will be used.
	*
	* @param  {String} data             Input data
	* @param  {Mode | String} modesHint Data mode
	* @return {Segment}                 Segment
	*/
	function buildSingleSegment(data, modesHint) {
		let mode;
		const bestMode = Mode$1.getBestModeForData(data);
		mode = Mode$1.from(modesHint, bestMode);
		if (mode !== Mode$1.BYTE && mode.bit < bestMode.bit) throw new Error("\"" + data + "\" cannot be encoded with mode " + Mode$1.toString(mode) + ".\n Suggested mode is: " + Mode$1.toString(bestMode));
		if (mode === Mode$1.KANJI && !Utils$5.isKanjiModeEnabled()) mode = Mode$1.BYTE;
		switch (mode) {
			case Mode$1.NUMERIC: return new NumericData(data);
			case Mode$1.ALPHANUMERIC: return new AlphanumericData(data);
			case Mode$1.KANJI: return new KanjiData(data);
			case Mode$1.BYTE: return new ByteData(data);
		}
	}
	/**
	* Builds a list of segments from an array.
	* Array can contain Strings or Objects with segment's info.
	*
	* For each item which is a string, will be generated a segment with the given
	* string and the more appropriate encoding mode.
	*
	* For each item which is an object, will be generated a segment with the given
	* data and mode.
	* Objects must contain at least the property "data".
	* If property "mode" is not present, the more suitable mode will be used.
	*
	* @param  {Array} array Array of objects with segments data
	* @return {Array}       Array of Segments
	*/
	exports.fromArray = function fromArray(array) {
		return array.reduce(function(acc, seg) {
			if (typeof seg === "string") acc.push(buildSingleSegment(seg, null));
			else if (seg.data) acc.push(buildSingleSegment(seg.data, seg.mode));
			return acc;
		}, []);
	};
	/**
	* Builds an optimized sequence of segments from a string,
	* which will produce the shortest possible bitstream.
	*
	* @param  {String} data    Input string
	* @param  {Number} version QR Code version
	* @return {Array}          Array of segments
	*/
	exports.fromString = function fromString$2(data, version) {
		const graph = buildGraph(buildNodes(getSegmentsFromString(data, Utils$5.isKanjiModeEnabled())), version);
		const path$1 = dijkstra.find_path(graph.map, "start", "end");
		const optimizedSegs = [];
		for (let i = 1; i < path$1.length - 1; i++) optimizedSegs.push(graph.table[path$1[i]].node);
		return exports.fromArray(mergeSegments(optimizedSegs));
	};
	/**
	* Splits a string in various segments with the modes which
	* best represent their content.
	* The produced segments are far from being optimized.
	* The output of this function is only used to estimate a QR Code version
	* which may contain the data.
	*
	* @param  {string} data Input string
	* @return {Array}       Array of segments
	*/
	exports.rawSplit = function rawSplit(data) {
		return exports.fromArray(getSegmentsFromString(data, Utils$5.isKanjiModeEnabled()));
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/qrcode.js": ((exports) => {
	const Utils$4 = require_utils$1();
	const ECLevel = require_error_correction_level();
	const BitBuffer = require_bit_buffer();
	const BitMatrix = require_bit_matrix();
	const AlignmentPattern = require_alignment_pattern();
	const FinderPattern = require_finder_pattern();
	const MaskPattern = require_mask_pattern();
	const ECCode = require_error_correction_code();
	const ReedSolomonEncoder = require_reed_solomon_encoder();
	const Version = require_version();
	const FormatInfo = require_format_info();
	const Mode = require_mode();
	const Segments = require_segments();
	/**
	* QRCode for JavaScript
	*
	* modified by Ryan Day for nodejs support
	* Copyright (c) 2011 Ryan Day
	*
	* Licensed under the MIT license:
	*   http://www.opensource.org/licenses/mit-license.php
	*
	//---------------------------------------------------------------------
	// QRCode for JavaScript
	//
	// Copyright (c) 2009 Kazuhiko Arase
	//
	// URL: http://www.d-project.com/
	//
	// Licensed under the MIT license:
	//   http://www.opensource.org/licenses/mit-license.php
	//
	// The word "QR Code" is registered trademark of
	// DENSO WAVE INCORPORATED
	//   http://www.denso-wave.com/qrcode/faqpatent-e.html
	//
	//---------------------------------------------------------------------
	*/
	/**
	* Add finder patterns bits to matrix
	*
	* @param  {BitMatrix} matrix  Modules matrix
	* @param  {Number}    version QR Code version
	*/
	function setupFinderPattern(matrix, version) {
		const size = matrix.size;
		const pos = FinderPattern.getPositions(version);
		for (let i = 0; i < pos.length; i++) {
			const row = pos[i][0];
			const col = pos[i][1];
			for (let r = -1; r <= 7; r++) {
				if (row + r <= -1 || size <= row + r) continue;
				for (let c = -1; c <= 7; c++) {
					if (col + c <= -1 || size <= col + c) continue;
					if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) matrix.set(row + r, col + c, true, true);
					else matrix.set(row + r, col + c, false, true);
				}
			}
		}
	}
	/**
	* Add timing pattern bits to matrix
	*
	* Note: this function must be called before {@link setupAlignmentPattern}
	*
	* @param  {BitMatrix} matrix Modules matrix
	*/
	function setupTimingPattern(matrix) {
		const size = matrix.size;
		for (let r = 8; r < size - 8; r++) {
			const value = r % 2 === 0;
			matrix.set(r, 6, value, true);
			matrix.set(6, r, value, true);
		}
	}
	/**
	* Add alignment patterns bits to matrix
	*
	* Note: this function must be called after {@link setupTimingPattern}
	*
	* @param  {BitMatrix} matrix  Modules matrix
	* @param  {Number}    version QR Code version
	*/
	function setupAlignmentPattern(matrix, version) {
		const pos = AlignmentPattern.getPositions(version);
		for (let i = 0; i < pos.length; i++) {
			const row = pos[i][0];
			const col = pos[i][1];
			for (let r = -2; r <= 2; r++) for (let c = -2; c <= 2; c++) if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) matrix.set(row + r, col + c, true, true);
			else matrix.set(row + r, col + c, false, true);
		}
	}
	/**
	* Add version info bits to matrix
	*
	* @param  {BitMatrix} matrix  Modules matrix
	* @param  {Number}    version QR Code version
	*/
	function setupVersionInfo(matrix, version) {
		const size = matrix.size;
		const bits = Version.getEncodedBits(version);
		let row, col, mod;
		for (let i = 0; i < 18; i++) {
			row = Math.floor(i / 3);
			col = i % 3 + size - 8 - 3;
			mod = (bits >> i & 1) === 1;
			matrix.set(row, col, mod, true);
			matrix.set(col, row, mod, true);
		}
	}
	/**
	* Add format info bits to matrix
	*
	* @param  {BitMatrix} matrix               Modules matrix
	* @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level
	* @param  {Number}    maskPattern          Mask pattern reference value
	*/
	function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
		const size = matrix.size;
		const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
		let i, mod;
		for (i = 0; i < 15; i++) {
			mod = (bits >> i & 1) === 1;
			if (i < 6) matrix.set(i, 8, mod, true);
			else if (i < 8) matrix.set(i + 1, 8, mod, true);
			else matrix.set(size - 15 + i, 8, mod, true);
			if (i < 8) matrix.set(8, size - i - 1, mod, true);
			else if (i < 9) matrix.set(8, 15 - i - 1 + 1, mod, true);
			else matrix.set(8, 15 - i - 1, mod, true);
		}
		matrix.set(size - 8, 8, 1, true);
	}
	/**
	* Add encoded data bits to matrix
	*
	* @param  {BitMatrix}  matrix Modules matrix
	* @param  {Uint8Array} data   Data codewords
	*/
	function setupData(matrix, data) {
		const size = matrix.size;
		let inc = -1;
		let row = size - 1;
		let bitIndex = 7;
		let byteIndex = 0;
		for (let col = size - 1; col > 0; col -= 2) {
			if (col === 6) col--;
			while (true) {
				for (let c = 0; c < 2; c++) if (!matrix.isReserved(row, col - c)) {
					let dark = false;
					if (byteIndex < data.length) dark = (data[byteIndex] >>> bitIndex & 1) === 1;
					matrix.set(row, col - c, dark);
					bitIndex--;
					if (bitIndex === -1) {
						byteIndex++;
						bitIndex = 7;
					}
				}
				row += inc;
				if (row < 0 || size <= row) {
					row -= inc;
					inc = -inc;
					break;
				}
			}
		}
	}
	/**
	* Create encoded codewords from data input
	*
	* @param  {Number}   version              QR Code version
	* @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level
	* @param  {ByteData} data                 Data input
	* @return {Uint8Array}                    Buffer containing encoded codewords
	*/
	function createData(version, errorCorrectionLevel, segments) {
		const buffer = new BitBuffer();
		segments.forEach(function(data) {
			buffer.put(data.mode.bit, 4);
			buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));
			data.write(buffer);
		});
		const dataTotalCodewordsBits = (Utils$4.getSymbolTotalCodewords(version) - ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)) * 8;
		if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) buffer.put(0, 4);
		while (buffer.getLengthInBits() % 8 !== 0) buffer.putBit(0);
		const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
		for (let i = 0; i < remainingByte; i++) buffer.put(i % 2 ? 17 : 236, 8);
		return createCodewords(buffer, version, errorCorrectionLevel);
	}
	/**
	* Encode input data with Reed-Solomon and return codewords with
	* relative error correction bits
	*
	* @param  {BitBuffer} bitBuffer            Data to encode
	* @param  {Number}    version              QR Code version
	* @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level
	* @return {Uint8Array}                     Buffer containing encoded codewords
	*/
	function createCodewords(bitBuffer, version, errorCorrectionLevel) {
		const totalCodewords = Utils$4.getSymbolTotalCodewords(version);
		const dataTotalCodewords = totalCodewords - ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
		const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);
		const blocksInGroup1 = ecTotalBlocks - totalCodewords % ecTotalBlocks;
		const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
		const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
		const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
		const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
		const rs = new ReedSolomonEncoder(ecCount);
		let offset = 0;
		const dcData = new Array(ecTotalBlocks);
		const ecData = new Array(ecTotalBlocks);
		let maxDataSize = 0;
		const buffer = new Uint8Array(bitBuffer.buffer);
		for (let b = 0; b < ecTotalBlocks; b++) {
			const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
			dcData[b] = buffer.slice(offset, offset + dataSize);
			ecData[b] = rs.encode(dcData[b]);
			offset += dataSize;
			maxDataSize = Math.max(maxDataSize, dataSize);
		}
		const data = new Uint8Array(totalCodewords);
		let index = 0;
		let i, r;
		for (i = 0; i < maxDataSize; i++) for (r = 0; r < ecTotalBlocks; r++) if (i < dcData[r].length) data[index++] = dcData[r][i];
		for (i = 0; i < ecCount; i++) for (r = 0; r < ecTotalBlocks; r++) data[index++] = ecData[r][i];
		return data;
	}
	/**
	* Build QR Code symbol
	*
	* @param  {String} data                 Input string
	* @param  {Number} version              QR Code version
	* @param  {ErrorCorretionLevel} errorCorrectionLevel Error level
	* @param  {MaskPattern} maskPattern     Mask pattern
	* @return {Object}                      Object containing symbol data
	*/
	function createSymbol(data, version, errorCorrectionLevel, maskPattern) {
		let segments;
		if (Array.isArray(data)) segments = Segments.fromArray(data);
		else if (typeof data === "string") {
			let estimatedVersion = version;
			if (!estimatedVersion) {
				const rawSegments = Segments.rawSplit(data);
				estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
			}
			segments = Segments.fromString(data, estimatedVersion || 40);
		} else throw new Error("Invalid data");
		const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
		if (!bestVersion) throw new Error("The amount of data is too big to be stored in a QR Code");
		if (!version) version = bestVersion;
		else if (version < bestVersion) throw new Error("\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n");
		const dataBits = createData(version, errorCorrectionLevel, segments);
		const modules = new BitMatrix(Utils$4.getSymbolSize(version));
		setupFinderPattern(modules, version);
		setupTimingPattern(modules);
		setupAlignmentPattern(modules, version);
		setupFormatInfo(modules, errorCorrectionLevel, 0);
		if (version >= 7) setupVersionInfo(modules, version);
		setupData(modules, dataBits);
		if (isNaN(maskPattern)) maskPattern = MaskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));
		MaskPattern.applyMask(maskPattern, modules);
		setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
		return {
			modules,
			version,
			errorCorrectionLevel,
			maskPattern,
			segments
		};
	}
	/**
	* QR Code
	*
	* @param {String | Array} data                 Input data
	* @param {Object} options                      Optional configurations
	* @param {Number} options.version              QR Code version
	* @param {String} options.errorCorrectionLevel Error correction level
	* @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis
	*/
	exports.create = function create(data, options) {
		if (typeof data === "undefined" || data === "") throw new Error("No input text");
		let errorCorrectionLevel = ECLevel.M;
		let version;
		let mask;
		if (typeof options !== "undefined") {
			errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
			version = Version.from(options.version);
			mask = MaskPattern.from(options.maskPattern);
			if (options.toSJISFunc) Utils$4.setToSJISFunction(options.toSJISFunc);
		}
		return createSymbol(data, version, errorCorrectionLevel, mask);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/chunkstream.js
var require_chunkstream = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/chunkstream.js": ((exports, module) => {
	let util$6 = __require("util");
	let Stream$2 = __require("stream");
	let ChunkStream$2 = module.exports = function() {
		Stream$2.call(this);
		this._buffers = [];
		this._buffered = 0;
		this._reads = [];
		this._paused = false;
		this._encoding = "utf8";
		this.writable = true;
	};
	util$6.inherits(ChunkStream$2, Stream$2);
	ChunkStream$2.prototype.read = function(length, callback) {
		this._reads.push({
			length: Math.abs(length),
			allowLess: length < 0,
			func: callback
		});
		process.nextTick(function() {
			this._process();
			if (this._paused && this._reads && this._reads.length > 0) {
				this._paused = false;
				this.emit("drain");
			}
		}.bind(this));
	};
	ChunkStream$2.prototype.write = function(data, encoding) {
		if (!this.writable) {
			this.emit("error", /* @__PURE__ */ new Error("Stream not writable"));
			return false;
		}
		let dataBuffer;
		if (Buffer.isBuffer(data)) dataBuffer = data;
		else dataBuffer = Buffer.from(data, encoding || this._encoding);
		this._buffers.push(dataBuffer);
		this._buffered += dataBuffer.length;
		this._process();
		if (this._reads && this._reads.length === 0) this._paused = true;
		return this.writable && !this._paused;
	};
	ChunkStream$2.prototype.end = function(data, encoding) {
		if (data) this.write(data, encoding);
		this.writable = false;
		if (!this._buffers) return;
		if (this._buffers.length === 0) this._end();
		else {
			this._buffers.push(null);
			this._process();
		}
	};
	ChunkStream$2.prototype.destroySoon = ChunkStream$2.prototype.end;
	ChunkStream$2.prototype._end = function() {
		if (this._reads.length > 0) this.emit("error", /* @__PURE__ */ new Error("Unexpected end of input"));
		this.destroy();
	};
	ChunkStream$2.prototype.destroy = function() {
		if (!this._buffers) return;
		this.writable = false;
		this._reads = null;
		this._buffers = null;
		this.emit("close");
	};
	ChunkStream$2.prototype._processReadAllowingLess = function(read) {
		this._reads.shift();
		let smallerBuf = this._buffers[0];
		if (smallerBuf.length > read.length) {
			this._buffered -= read.length;
			this._buffers[0] = smallerBuf.slice(read.length);
			read.func.call(this, smallerBuf.slice(0, read.length));
		} else {
			this._buffered -= smallerBuf.length;
			this._buffers.shift();
			read.func.call(this, smallerBuf);
		}
	};
	ChunkStream$2.prototype._processRead = function(read) {
		this._reads.shift();
		let pos = 0;
		let count = 0;
		let data = Buffer.alloc(read.length);
		while (pos < read.length) {
			let buf = this._buffers[count++];
			let len = Math.min(buf.length, read.length - pos);
			buf.copy(data, pos, 0, len);
			pos += len;
			if (len !== buf.length) this._buffers[--count] = buf.slice(len);
		}
		if (count > 0) this._buffers.splice(0, count);
		this._buffered -= read.length;
		read.func.call(this, data);
	};
	ChunkStream$2.prototype._process = function() {
		try {
			while (this._buffered > 0 && this._reads && this._reads.length > 0) {
				let read = this._reads[0];
				if (read.allowLess) this._processReadAllowingLess(read);
				else if (this._buffered >= read.length) this._processRead(read);
				else break;
			}
			if (this._buffers && !this.writable) this._end();
		} catch (ex) {
			this.emit("error", ex);
		}
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/interlace.js
var require_interlace = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/interlace.js": ((exports) => {
	let imagePasses = [
		{
			x: [0],
			y: [0]
		},
		{
			x: [4],
			y: [0]
		},
		{
			x: [0, 4],
			y: [4]
		},
		{
			x: [2, 6],
			y: [0, 4]
		},
		{
			x: [
				0,
				2,
				4,
				6
			],
			y: [2, 6]
		},
		{
			x: [
				1,
				3,
				5,
				7
			],
			y: [
				0,
				2,
				4,
				6
			]
		},
		{
			x: [
				0,
				1,
				2,
				3,
				4,
				5,
				6,
				7
			],
			y: [
				1,
				3,
				5,
				7
			]
		}
	];
	exports.getImagePasses = function(width, height) {
		let images = [];
		let xLeftOver = width % 8;
		let yLeftOver = height % 8;
		let xRepeats = (width - xLeftOver) / 8;
		let yRepeats = (height - yLeftOver) / 8;
		for (let i = 0; i < imagePasses.length; i++) {
			let pass = imagePasses[i];
			let passWidth = xRepeats * pass.x.length;
			let passHeight = yRepeats * pass.y.length;
			for (let j = 0; j < pass.x.length; j++) if (pass.x[j] < xLeftOver) passWidth++;
			else break;
			for (let j = 0; j < pass.y.length; j++) if (pass.y[j] < yLeftOver) passHeight++;
			else break;
			if (passWidth > 0 && passHeight > 0) images.push({
				width: passWidth,
				height: passHeight,
				index: i
			});
		}
		return images;
	};
	exports.getInterlaceIterator = function(width) {
		return function(x, y, pass) {
			let outerXLeftOver = x % imagePasses[pass].x.length;
			let outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
			let outerYLeftOver = y % imagePasses[pass].y.length;
			let outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
			return outerX * 4 + outerY * width * 4;
		};
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/paeth-predictor.js
var require_paeth_predictor = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/paeth-predictor.js": ((exports, module) => {
	module.exports = function paethPredictor$2(left, above, upLeft) {
		let paeth = left + above - upLeft;
		let pLeft = Math.abs(paeth - left);
		let pAbove = Math.abs(paeth - above);
		let pUpLeft = Math.abs(paeth - upLeft);
		if (pLeft <= pAbove && pLeft <= pUpLeft) return left;
		if (pAbove <= pUpLeft) return above;
		return upLeft;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/filter-parse.js
var require_filter_parse = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/filter-parse.js": ((exports, module) => {
	let interlaceUtils$1 = require_interlace();
	let paethPredictor$1 = require_paeth_predictor();
	function getByteWidth(width, bpp, depth) {
		let byteWidth = width * bpp;
		if (depth !== 8) byteWidth = Math.ceil(byteWidth / (8 / depth));
		return byteWidth;
	}
	let Filter$2 = module.exports = function(bitmapInfo, dependencies) {
		let width = bitmapInfo.width;
		let height = bitmapInfo.height;
		let interlace = bitmapInfo.interlace;
		let bpp = bitmapInfo.bpp;
		let depth = bitmapInfo.depth;
		this.read = dependencies.read;
		this.write = dependencies.write;
		this.complete = dependencies.complete;
		this._imageIndex = 0;
		this._images = [];
		if (interlace) {
			let passes = interlaceUtils$1.getImagePasses(width, height);
			for (let i = 0; i < passes.length; i++) this._images.push({
				byteWidth: getByteWidth(passes[i].width, bpp, depth),
				height: passes[i].height,
				lineIndex: 0
			});
		} else this._images.push({
			byteWidth: getByteWidth(width, bpp, depth),
			height,
			lineIndex: 0
		});
		if (depth === 8) this._xComparison = bpp;
		else if (depth === 16) this._xComparison = bpp * 2;
		else this._xComparison = 1;
	};
	Filter$2.prototype.start = function() {
		this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
	};
	Filter$2.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
		let xComparison = this._xComparison;
		let xBiggerThan = xComparison - 1;
		for (let x = 0; x < byteWidth; x++) unfilteredLine[x] = rawData[1 + x] + (x > xBiggerThan ? unfilteredLine[x - xComparison] : 0);
	};
	Filter$2.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
		let lastLine = this._lastLine;
		for (let x = 0; x < byteWidth; x++) unfilteredLine[x] = rawData[1 + x] + (lastLine ? lastLine[x] : 0);
	};
	Filter$2.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
		let xComparison = this._xComparison;
		let xBiggerThan = xComparison - 1;
		let lastLine = this._lastLine;
		for (let x = 0; x < byteWidth; x++) {
			let rawByte = rawData[1 + x];
			let f3Up = lastLine ? lastLine[x] : 0;
			let f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
			unfilteredLine[x] = rawByte + Math.floor((f3Left + f3Up) / 2);
		}
	};
	Filter$2.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
		let xComparison = this._xComparison;
		let xBiggerThan = xComparison - 1;
		let lastLine = this._lastLine;
		for (let x = 0; x < byteWidth; x++) {
			let rawByte = rawData[1 + x];
			let f4Up = lastLine ? lastLine[x] : 0;
			unfilteredLine[x] = rawByte + paethPredictor$1(x > xBiggerThan ? unfilteredLine[x - xComparison] : 0, f4Up, x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0);
		}
	};
	Filter$2.prototype._reverseFilterLine = function(rawData) {
		let filter$1 = rawData[0];
		let unfilteredLine;
		let currentImage = this._images[this._imageIndex];
		let byteWidth = currentImage.byteWidth;
		if (filter$1 === 0) unfilteredLine = rawData.slice(1, byteWidth + 1);
		else {
			unfilteredLine = Buffer.alloc(byteWidth);
			switch (filter$1) {
				case 1:
					this._unFilterType1(rawData, unfilteredLine, byteWidth);
					break;
				case 2:
					this._unFilterType2(rawData, unfilteredLine, byteWidth);
					break;
				case 3:
					this._unFilterType3(rawData, unfilteredLine, byteWidth);
					break;
				case 4:
					this._unFilterType4(rawData, unfilteredLine, byteWidth);
					break;
				default: throw new Error("Unrecognised filter type - " + filter$1);
			}
		}
		this.write(unfilteredLine);
		currentImage.lineIndex++;
		if (currentImage.lineIndex >= currentImage.height) {
			this._lastLine = null;
			this._imageIndex++;
			currentImage = this._images[this._imageIndex];
		} else this._lastLine = unfilteredLine;
		if (currentImage) this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
		else {
			this._lastLine = null;
			this.complete();
		}
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/filter-parse-async.js
var require_filter_parse_async = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/filter-parse-async.js": ((exports, module) => {
	let util$5 = __require("util");
	let ChunkStream$1 = require_chunkstream();
	let Filter$1 = require_filter_parse();
	let FilterAsync$1 = module.exports = function(bitmapInfo) {
		ChunkStream$1.call(this);
		let buffers = [];
		let that = this;
		this._filter = new Filter$1(bitmapInfo, {
			read: this.read.bind(this),
			write: function(buffer) {
				buffers.push(buffer);
			},
			complete: function() {
				that.emit("complete", Buffer.concat(buffers));
			}
		});
		this._filter.start();
	};
	util$5.inherits(FilterAsync$1, ChunkStream$1);
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/constants.js
var require_constants = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/constants.js": ((exports, module) => {
	module.exports = {
		PNG_SIGNATURE: [
			137,
			80,
			78,
			71,
			13,
			10,
			26,
			10
		],
		TYPE_IHDR: 1229472850,
		TYPE_IEND: 1229278788,
		TYPE_IDAT: 1229209940,
		TYPE_PLTE: 1347179589,
		TYPE_tRNS: 1951551059,
		TYPE_gAMA: 1732332865,
		COLORTYPE_GRAYSCALE: 0,
		COLORTYPE_PALETTE: 1,
		COLORTYPE_COLOR: 2,
		COLORTYPE_ALPHA: 4,
		COLORTYPE_PALETTE_COLOR: 3,
		COLORTYPE_COLOR_ALPHA: 6,
		COLORTYPE_TO_BPP_MAP: {
			0: 1,
			2: 3,
			3: 1,
			4: 2,
			6: 4
		},
		GAMMA_DIVISION: 1e5
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/crc.js
var require_crc = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/crc.js": ((exports, module) => {
	let crcTable = [];
	(function() {
		for (let i = 0; i < 256; i++) {
			let currentCrc = i;
			for (let j = 0; j < 8; j++) if (currentCrc & 1) currentCrc = 3988292384 ^ currentCrc >>> 1;
			else currentCrc = currentCrc >>> 1;
			crcTable[i] = currentCrc;
		}
	})();
	let CrcCalculator$1 = module.exports = function() {
		this._crc = -1;
	};
	CrcCalculator$1.prototype.write = function(data) {
		for (let i = 0; i < data.length; i++) this._crc = crcTable[(this._crc ^ data[i]) & 255] ^ this._crc >>> 8;
		return true;
	};
	CrcCalculator$1.prototype.crc32 = function() {
		return this._crc ^ -1;
	};
	CrcCalculator$1.crc32 = function(buf) {
		let crc = -1;
		for (let i = 0; i < buf.length; i++) crc = crcTable[(crc ^ buf[i]) & 255] ^ crc >>> 8;
		return crc ^ -1;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/parser.js
var require_parser = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/parser.js": ((exports, module) => {
	let constants$4 = require_constants();
	let CrcCalculator = require_crc();
	let Parser$3 = module.exports = function(options, dependencies) {
		this._options = options;
		options.checkCRC = options.checkCRC !== false;
		this._hasIHDR = false;
		this._hasIEND = false;
		this._emittedHeadersFinished = false;
		this._palette = [];
		this._colorType = 0;
		this._chunks = {};
		this._chunks[constants$4.TYPE_IHDR] = this._handleIHDR.bind(this);
		this._chunks[constants$4.TYPE_IEND] = this._handleIEND.bind(this);
		this._chunks[constants$4.TYPE_IDAT] = this._handleIDAT.bind(this);
		this._chunks[constants$4.TYPE_PLTE] = this._handlePLTE.bind(this);
		this._chunks[constants$4.TYPE_tRNS] = this._handleTRNS.bind(this);
		this._chunks[constants$4.TYPE_gAMA] = this._handleGAMA.bind(this);
		this.read = dependencies.read;
		this.error = dependencies.error;
		this.metadata = dependencies.metadata;
		this.gamma = dependencies.gamma;
		this.transColor = dependencies.transColor;
		this.palette = dependencies.palette;
		this.parsed = dependencies.parsed;
		this.inflateData = dependencies.inflateData;
		this.finished = dependencies.finished;
		this.simpleTransparency = dependencies.simpleTransparency;
		this.headersFinished = dependencies.headersFinished || function() {};
	};
	Parser$3.prototype.start = function() {
		this.read(constants$4.PNG_SIGNATURE.length, this._parseSignature.bind(this));
	};
	Parser$3.prototype._parseSignature = function(data) {
		let signature = constants$4.PNG_SIGNATURE;
		for (let i = 0; i < signature.length; i++) if (data[i] !== signature[i]) {
			this.error(/* @__PURE__ */ new Error("Invalid file signature"));
			return;
		}
		this.read(8, this._parseChunkBegin.bind(this));
	};
	Parser$3.prototype._parseChunkBegin = function(data) {
		let length = data.readUInt32BE(0);
		let type = data.readUInt32BE(4);
		let name = "";
		for (let i = 4; i < 8; i++) name += String.fromCharCode(data[i]);
		let ancillary = Boolean(data[4] & 32);
		if (!this._hasIHDR && type !== constants$4.TYPE_IHDR) {
			this.error(/* @__PURE__ */ new Error("Expected IHDR on beggining"));
			return;
		}
		this._crc = new CrcCalculator();
		this._crc.write(Buffer.from(name));
		if (this._chunks[type]) return this._chunks[type](length);
		if (!ancillary) {
			this.error(/* @__PURE__ */ new Error("Unsupported critical chunk type " + name));
			return;
		}
		this.read(length + 4, this._skipChunk.bind(this));
	};
	Parser$3.prototype._skipChunk = function() {
		this.read(8, this._parseChunkBegin.bind(this));
	};
	Parser$3.prototype._handleChunkEnd = function() {
		this.read(4, this._parseChunkEnd.bind(this));
	};
	Parser$3.prototype._parseChunkEnd = function(data) {
		let fileCrc = data.readInt32BE(0);
		let calcCrc = this._crc.crc32();
		if (this._options.checkCRC && calcCrc !== fileCrc) {
			this.error(/* @__PURE__ */ new Error("Crc error - " + fileCrc + " - " + calcCrc));
			return;
		}
		if (!this._hasIEND) this.read(8, this._parseChunkBegin.bind(this));
	};
	Parser$3.prototype._handleIHDR = function(length) {
		this.read(length, this._parseIHDR.bind(this));
	};
	Parser$3.prototype._parseIHDR = function(data) {
		this._crc.write(data);
		let width = data.readUInt32BE(0);
		let height = data.readUInt32BE(4);
		let depth = data[8];
		let colorType = data[9];
		let compr = data[10];
		let filter$1 = data[11];
		let interlace = data[12];
		if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
			this.error(/* @__PURE__ */ new Error("Unsupported bit depth " + depth));
			return;
		}
		if (!(colorType in constants$4.COLORTYPE_TO_BPP_MAP)) {
			this.error(/* @__PURE__ */ new Error("Unsupported color type"));
			return;
		}
		if (compr !== 0) {
			this.error(/* @__PURE__ */ new Error("Unsupported compression method"));
			return;
		}
		if (filter$1 !== 0) {
			this.error(/* @__PURE__ */ new Error("Unsupported filter method"));
			return;
		}
		if (interlace !== 0 && interlace !== 1) {
			this.error(/* @__PURE__ */ new Error("Unsupported interlace method"));
			return;
		}
		this._colorType = colorType;
		let bpp = constants$4.COLORTYPE_TO_BPP_MAP[this._colorType];
		this._hasIHDR = true;
		this.metadata({
			width,
			height,
			depth,
			interlace: Boolean(interlace),
			palette: Boolean(colorType & constants$4.COLORTYPE_PALETTE),
			color: Boolean(colorType & constants$4.COLORTYPE_COLOR),
			alpha: Boolean(colorType & constants$4.COLORTYPE_ALPHA),
			bpp,
			colorType
		});
		this._handleChunkEnd();
	};
	Parser$3.prototype._handlePLTE = function(length) {
		this.read(length, this._parsePLTE.bind(this));
	};
	Parser$3.prototype._parsePLTE = function(data) {
		this._crc.write(data);
		let entries = Math.floor(data.length / 3);
		for (let i = 0; i < entries; i++) this._palette.push([
			data[i * 3],
			data[i * 3 + 1],
			data[i * 3 + 2],
			255
		]);
		this.palette(this._palette);
		this._handleChunkEnd();
	};
	Parser$3.prototype._handleTRNS = function(length) {
		this.simpleTransparency();
		this.read(length, this._parseTRNS.bind(this));
	};
	Parser$3.prototype._parseTRNS = function(data) {
		this._crc.write(data);
		if (this._colorType === constants$4.COLORTYPE_PALETTE_COLOR) {
			if (this._palette.length === 0) {
				this.error(/* @__PURE__ */ new Error("Transparency chunk must be after palette"));
				return;
			}
			if (data.length > this._palette.length) {
				this.error(/* @__PURE__ */ new Error("More transparent colors than palette size"));
				return;
			}
			for (let i = 0; i < data.length; i++) this._palette[i][3] = data[i];
			this.palette(this._palette);
		}
		if (this._colorType === constants$4.COLORTYPE_GRAYSCALE) this.transColor([data.readUInt16BE(0)]);
		if (this._colorType === constants$4.COLORTYPE_COLOR) this.transColor([
			data.readUInt16BE(0),
			data.readUInt16BE(2),
			data.readUInt16BE(4)
		]);
		this._handleChunkEnd();
	};
	Parser$3.prototype._handleGAMA = function(length) {
		this.read(length, this._parseGAMA.bind(this));
	};
	Parser$3.prototype._parseGAMA = function(data) {
		this._crc.write(data);
		this.gamma(data.readUInt32BE(0) / constants$4.GAMMA_DIVISION);
		this._handleChunkEnd();
	};
	Parser$3.prototype._handleIDAT = function(length) {
		if (!this._emittedHeadersFinished) {
			this._emittedHeadersFinished = true;
			this.headersFinished();
		}
		this.read(-length, this._parseIDAT.bind(this, length));
	};
	Parser$3.prototype._parseIDAT = function(length, data) {
		this._crc.write(data);
		if (this._colorType === constants$4.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) throw new Error("Expected palette not found");
		this.inflateData(data);
		let leftOverLength = length - data.length;
		if (leftOverLength > 0) this._handleIDAT(leftOverLength);
		else this._handleChunkEnd();
	};
	Parser$3.prototype._handleIEND = function(length) {
		this.read(length, this._parseIEND.bind(this));
	};
	Parser$3.prototype._parseIEND = function(data) {
		this._crc.write(data);
		this._hasIEND = true;
		this._handleChunkEnd();
		if (this.finished) this.finished();
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/bitmapper.js
var require_bitmapper = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/bitmapper.js": ((exports) => {
	let interlaceUtils = require_interlace();
	let pixelBppMapper = [
		function() {},
		function(pxData, data, pxPos, rawPos) {
			if (rawPos === data.length) throw new Error("Ran out of data");
			let pixel = data[rawPos];
			pxData[pxPos] = pixel;
			pxData[pxPos + 1] = pixel;
			pxData[pxPos + 2] = pixel;
			pxData[pxPos + 3] = 255;
		},
		function(pxData, data, pxPos, rawPos) {
			if (rawPos + 1 >= data.length) throw new Error("Ran out of data");
			let pixel = data[rawPos];
			pxData[pxPos] = pixel;
			pxData[pxPos + 1] = pixel;
			pxData[pxPos + 2] = pixel;
			pxData[pxPos + 3] = data[rawPos + 1];
		},
		function(pxData, data, pxPos, rawPos) {
			if (rawPos + 2 >= data.length) throw new Error("Ran out of data");
			pxData[pxPos] = data[rawPos];
			pxData[pxPos + 1] = data[rawPos + 1];
			pxData[pxPos + 2] = data[rawPos + 2];
			pxData[pxPos + 3] = 255;
		},
		function(pxData, data, pxPos, rawPos) {
			if (rawPos + 3 >= data.length) throw new Error("Ran out of data");
			pxData[pxPos] = data[rawPos];
			pxData[pxPos + 1] = data[rawPos + 1];
			pxData[pxPos + 2] = data[rawPos + 2];
			pxData[pxPos + 3] = data[rawPos + 3];
		}
	];
	let pixelBppCustomMapper = [
		function() {},
		function(pxData, pixelData, pxPos, maxBit) {
			let pixel = pixelData[0];
			pxData[pxPos] = pixel;
			pxData[pxPos + 1] = pixel;
			pxData[pxPos + 2] = pixel;
			pxData[pxPos + 3] = maxBit;
		},
		function(pxData, pixelData, pxPos) {
			let pixel = pixelData[0];
			pxData[pxPos] = pixel;
			pxData[pxPos + 1] = pixel;
			pxData[pxPos + 2] = pixel;
			pxData[pxPos + 3] = pixelData[1];
		},
		function(pxData, pixelData, pxPos, maxBit) {
			pxData[pxPos] = pixelData[0];
			pxData[pxPos + 1] = pixelData[1];
			pxData[pxPos + 2] = pixelData[2];
			pxData[pxPos + 3] = maxBit;
		},
		function(pxData, pixelData, pxPos) {
			pxData[pxPos] = pixelData[0];
			pxData[pxPos + 1] = pixelData[1];
			pxData[pxPos + 2] = pixelData[2];
			pxData[pxPos + 3] = pixelData[3];
		}
	];
	function bitRetriever(data, depth) {
		let leftOver = [];
		let i = 0;
		function split() {
			if (i === data.length) throw new Error("Ran out of data");
			let byte$1 = data[i];
			i++;
			let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
			switch (depth) {
				default: throw new Error("unrecognised depth");
				case 16:
					byte2 = data[i];
					i++;
					leftOver.push((byte$1 << 8) + byte2);
					break;
				case 4:
					byte2 = byte$1 & 15;
					byte1 = byte$1 >> 4;
					leftOver.push(byte1, byte2);
					break;
				case 2:
					byte4 = byte$1 & 3;
					byte3 = byte$1 >> 2 & 3;
					byte2 = byte$1 >> 4 & 3;
					byte1 = byte$1 >> 6 & 3;
					leftOver.push(byte1, byte2, byte3, byte4);
					break;
				case 1:
					byte8 = byte$1 & 1;
					byte7 = byte$1 >> 1 & 1;
					byte6 = byte$1 >> 2 & 1;
					byte5 = byte$1 >> 3 & 1;
					byte4 = byte$1 >> 4 & 1;
					byte3 = byte$1 >> 5 & 1;
					byte2 = byte$1 >> 6 & 1;
					byte1 = byte$1 >> 7 & 1;
					leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
					break;
			}
		}
		return {
			get: function(count) {
				while (leftOver.length < count) split();
				let returner = leftOver.slice(0, count);
				leftOver = leftOver.slice(count);
				return returner;
			},
			resetAfterLine: function() {
				leftOver.length = 0;
			},
			end: function() {
				if (i !== data.length) throw new Error("extra data found");
			}
		};
	}
	function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
		let imageWidth = image.width;
		let imageHeight = image.height;
		let imagePass = image.index;
		for (let y = 0; y < imageHeight; y++) for (let x = 0; x < imageWidth; x++) {
			let pxPos = getPxPos(x, y, imagePass);
			pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
			rawPos += bpp;
		}
		return rawPos;
	}
	function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
		let imageWidth = image.width;
		let imageHeight = image.height;
		let imagePass = image.index;
		for (let y = 0; y < imageHeight; y++) {
			for (let x = 0; x < imageWidth; x++) {
				let pixelData = bits.get(bpp);
				let pxPos = getPxPos(x, y, imagePass);
				pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
			}
			bits.resetAfterLine();
		}
	}
	exports.dataToBitMap = function(data, bitmapInfo) {
		let width = bitmapInfo.width;
		let height = bitmapInfo.height;
		let depth = bitmapInfo.depth;
		let bpp = bitmapInfo.bpp;
		let interlace = bitmapInfo.interlace;
		let bits;
		if (depth !== 8) bits = bitRetriever(data, depth);
		let pxData;
		if (depth <= 8) pxData = Buffer.alloc(width * height * 4);
		else pxData = new Uint16Array(width * height * 4);
		let maxBit = Math.pow(2, depth) - 1;
		let rawPos = 0;
		let images;
		let getPxPos;
		if (interlace) {
			images = interlaceUtils.getImagePasses(width, height);
			getPxPos = interlaceUtils.getInterlaceIterator(width, height);
		} else {
			let nonInterlacedPxPos = 0;
			getPxPos = function() {
				let returner = nonInterlacedPxPos;
				nonInterlacedPxPos += 4;
				return returner;
			};
			images = [{
				width,
				height
			}];
		}
		for (let imageIndex = 0; imageIndex < images.length; imageIndex++) if (depth === 8) rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);
		else mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
		if (depth === 8) {
			if (rawPos !== data.length) throw new Error("extra data found");
		} else bits.end();
		return pxData;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/format-normaliser.js
var require_format_normaliser = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/format-normaliser.js": ((exports, module) => {
	function dePalette(indata, outdata, width, height, palette) {
		let pxPos = 0;
		for (let y = 0; y < height; y++) for (let x = 0; x < width; x++) {
			let color = palette[indata[pxPos]];
			if (!color) throw new Error("index " + indata[pxPos] + " not in palette");
			for (let i = 0; i < 4; i++) outdata[pxPos + i] = color[i];
			pxPos += 4;
		}
	}
	function replaceTransparentColor(indata, outdata, width, height, transColor) {
		let pxPos = 0;
		for (let y = 0; y < height; y++) for (let x = 0; x < width; x++) {
			let makeTrans = false;
			if (transColor.length === 1) {
				if (transColor[0] === indata[pxPos]) makeTrans = true;
			} else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) makeTrans = true;
			if (makeTrans) for (let i = 0; i < 4; i++) outdata[pxPos + i] = 0;
			pxPos += 4;
		}
	}
	function scaleDepth(indata, outdata, width, height, depth) {
		let maxOutSample = 255;
		let maxInSample = Math.pow(2, depth) - 1;
		let pxPos = 0;
		for (let y = 0; y < height; y++) for (let x = 0; x < width; x++) {
			for (let i = 0; i < 4; i++) outdata[pxPos + i] = Math.floor(indata[pxPos + i] * maxOutSample / maxInSample + .5);
			pxPos += 4;
		}
	}
	module.exports = function(indata, imageData) {
		let depth = imageData.depth;
		let width = imageData.width;
		let height = imageData.height;
		let colorType = imageData.colorType;
		let transColor = imageData.transColor;
		let palette = imageData.palette;
		let outdata = indata;
		if (colorType === 3) dePalette(indata, outdata, width, height, palette);
		else {
			if (transColor) replaceTransparentColor(indata, outdata, width, height, transColor);
			if (depth !== 8) {
				if (depth === 16) outdata = Buffer.alloc(width * height * 4);
				scaleDepth(indata, outdata, width, height, depth);
			}
		}
		return outdata;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/parser-async.js
var require_parser_async = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/parser-async.js": ((exports, module) => {
	let util$4 = __require("util");
	let zlib$4 = __require("zlib");
	let ChunkStream = require_chunkstream();
	let FilterAsync = require_filter_parse_async();
	let Parser$2 = require_parser();
	let bitmapper$1 = require_bitmapper();
	let formatNormaliser$1 = require_format_normaliser();
	let ParserAsync = module.exports = function(options) {
		ChunkStream.call(this);
		this._parser = new Parser$2(options, {
			read: this.read.bind(this),
			error: this._handleError.bind(this),
			metadata: this._handleMetaData.bind(this),
			gamma: this.emit.bind(this, "gamma"),
			palette: this._handlePalette.bind(this),
			transColor: this._handleTransColor.bind(this),
			finished: this._finished.bind(this),
			inflateData: this._inflateData.bind(this),
			simpleTransparency: this._simpleTransparency.bind(this),
			headersFinished: this._headersFinished.bind(this)
		});
		this._options = options;
		this.writable = true;
		this._parser.start();
	};
	util$4.inherits(ParserAsync, ChunkStream);
	ParserAsync.prototype._handleError = function(err) {
		this.emit("error", err);
		this.writable = false;
		this.destroy();
		if (this._inflate && this._inflate.destroy) this._inflate.destroy();
		if (this._filter) {
			this._filter.destroy();
			this._filter.on("error", function() {});
		}
		this.errord = true;
	};
	ParserAsync.prototype._inflateData = function(data) {
		if (!this._inflate) if (this._bitmapInfo.interlace) {
			this._inflate = zlib$4.createInflate();
			this._inflate.on("error", this.emit.bind(this, "error"));
			this._filter.on("complete", this._complete.bind(this));
			this._inflate.pipe(this._filter);
		} else {
			let imageSize = ((this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1) * this._bitmapInfo.height;
			let chunkSize = Math.max(imageSize, zlib$4.Z_MIN_CHUNK);
			this._inflate = zlib$4.createInflate({ chunkSize });
			let leftToInflate = imageSize;
			let emitError = this.emit.bind(this, "error");
			this._inflate.on("error", function(err) {
				if (!leftToInflate) return;
				emitError(err);
			});
			this._filter.on("complete", this._complete.bind(this));
			let filterWrite = this._filter.write.bind(this._filter);
			this._inflate.on("data", function(chunk) {
				if (!leftToInflate) return;
				if (chunk.length > leftToInflate) chunk = chunk.slice(0, leftToInflate);
				leftToInflate -= chunk.length;
				filterWrite(chunk);
			});
			this._inflate.on("end", this._filter.end.bind(this._filter));
		}
		this._inflate.write(data);
	};
	ParserAsync.prototype._handleMetaData = function(metaData) {
		this._metaData = metaData;
		this._bitmapInfo = Object.create(metaData);
		this._filter = new FilterAsync(this._bitmapInfo);
	};
	ParserAsync.prototype._handleTransColor = function(transColor) {
		this._bitmapInfo.transColor = transColor;
	};
	ParserAsync.prototype._handlePalette = function(palette) {
		this._bitmapInfo.palette = palette;
	};
	ParserAsync.prototype._simpleTransparency = function() {
		this._metaData.alpha = true;
	};
	ParserAsync.prototype._headersFinished = function() {
		this.emit("metadata", this._metaData);
	};
	ParserAsync.prototype._finished = function() {
		if (this.errord) return;
		if (!this._inflate) this.emit("error", "No Inflate block");
		else this._inflate.end();
	};
	ParserAsync.prototype._complete = function(filteredData) {
		if (this.errord) return;
		let normalisedBitmapData;
		try {
			let bitmapData = bitmapper$1.dataToBitMap(filteredData, this._bitmapInfo);
			normalisedBitmapData = formatNormaliser$1(bitmapData, this._bitmapInfo);
			bitmapData = null;
		} catch (ex) {
			this._handleError(ex);
			return;
		}
		this.emit("parsed", normalisedBitmapData);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/bitpacker.js
var require_bitpacker = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/bitpacker.js": ((exports, module) => {
	let constants$3 = require_constants();
	module.exports = function(dataIn, width, height, options) {
		let outHasAlpha = [constants$3.COLORTYPE_COLOR_ALPHA, constants$3.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;
		if (options.colorType === options.inputColorType) {
			let bigEndian = (function() {
				let buffer = /* @__PURE__ */ new ArrayBuffer(2);
				new DataView(buffer).setInt16(0, 256, true);
				return new Int16Array(buffer)[0] !== 256;
			})();
			if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) return dataIn;
		}
		let data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
		let maxValue = 255;
		let inBpp = constants$3.COLORTYPE_TO_BPP_MAP[options.inputColorType];
		if (inBpp === 4 && !options.inputHasAlpha) inBpp = 3;
		let outBpp = constants$3.COLORTYPE_TO_BPP_MAP[options.colorType];
		if (options.bitDepth === 16) {
			maxValue = 65535;
			outBpp *= 2;
		}
		let outData = Buffer.alloc(width * height * outBpp);
		let inIndex = 0;
		let outIndex = 0;
		let bgColor = options.bgColor || {};
		if (bgColor.red === void 0) bgColor.red = maxValue;
		if (bgColor.green === void 0) bgColor.green = maxValue;
		if (bgColor.blue === void 0) bgColor.blue = maxValue;
		function getRGBA() {
			let red;
			let green;
			let blue;
			let alpha = maxValue;
			switch (options.inputColorType) {
				case constants$3.COLORTYPE_COLOR_ALPHA:
					alpha = data[inIndex + 3];
					red = data[inIndex];
					green = data[inIndex + 1];
					blue = data[inIndex + 2];
					break;
				case constants$3.COLORTYPE_COLOR:
					red = data[inIndex];
					green = data[inIndex + 1];
					blue = data[inIndex + 2];
					break;
				case constants$3.COLORTYPE_ALPHA:
					alpha = data[inIndex + 1];
					red = data[inIndex];
					green = red;
					blue = red;
					break;
				case constants$3.COLORTYPE_GRAYSCALE:
					red = data[inIndex];
					green = red;
					blue = red;
					break;
				default: throw new Error("input color type:" + options.inputColorType + " is not supported at present");
			}
			if (options.inputHasAlpha) {
				if (!outHasAlpha) {
					alpha /= maxValue;
					red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);
					green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);
					blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);
				}
			}
			return {
				red,
				green,
				blue,
				alpha
			};
		}
		for (let y = 0; y < height; y++) for (let x = 0; x < width; x++) {
			let rgba = getRGBA(data, inIndex);
			switch (options.colorType) {
				case constants$3.COLORTYPE_COLOR_ALPHA:
				case constants$3.COLORTYPE_COLOR:
					if (options.bitDepth === 8) {
						outData[outIndex] = rgba.red;
						outData[outIndex + 1] = rgba.green;
						outData[outIndex + 2] = rgba.blue;
						if (outHasAlpha) outData[outIndex + 3] = rgba.alpha;
					} else {
						outData.writeUInt16BE(rgba.red, outIndex);
						outData.writeUInt16BE(rgba.green, outIndex + 2);
						outData.writeUInt16BE(rgba.blue, outIndex + 4);
						if (outHasAlpha) outData.writeUInt16BE(rgba.alpha, outIndex + 6);
					}
					break;
				case constants$3.COLORTYPE_ALPHA:
				case constants$3.COLORTYPE_GRAYSCALE: {
					let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
					if (options.bitDepth === 8) {
						outData[outIndex] = grayscale;
						if (outHasAlpha) outData[outIndex + 1] = rgba.alpha;
					} else {
						outData.writeUInt16BE(grayscale, outIndex);
						if (outHasAlpha) outData.writeUInt16BE(rgba.alpha, outIndex + 2);
					}
					break;
				}
				default: throw new Error("unrecognised color Type " + options.colorType);
			}
			inIndex += inBpp;
			outIndex += outBpp;
		}
		return outData;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/filter-pack.js
var require_filter_pack = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/filter-pack.js": ((exports, module) => {
	let paethPredictor = require_paeth_predictor();
	function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
		for (let x = 0; x < byteWidth; x++) rawData[rawPos + x] = pxData[pxPos + x];
	}
	function filterSumNone(pxData, pxPos, byteWidth) {
		let sum = 0;
		let length = pxPos + byteWidth;
		for (let i = pxPos; i < length; i++) sum += Math.abs(pxData[i]);
		return sum;
	}
	function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
		for (let x = 0; x < byteWidth; x++) {
			let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
			let val = pxData[pxPos + x] - left;
			rawData[rawPos + x] = val;
		}
	}
	function filterSumSub(pxData, pxPos, byteWidth, bpp) {
		let sum = 0;
		for (let x = 0; x < byteWidth; x++) {
			let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
			let val = pxData[pxPos + x] - left;
			sum += Math.abs(val);
		}
		return sum;
	}
	function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
		for (let x = 0; x < byteWidth; x++) {
			let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
			let val = pxData[pxPos + x] - up;
			rawData[rawPos + x] = val;
		}
	}
	function filterSumUp(pxData, pxPos, byteWidth) {
		let sum = 0;
		let length = pxPos + byteWidth;
		for (let x = pxPos; x < length; x++) {
			let up = pxPos > 0 ? pxData[x - byteWidth] : 0;
			let val = pxData[x] - up;
			sum += Math.abs(val);
		}
		return sum;
	}
	function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
		for (let x = 0; x < byteWidth; x++) {
			let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
			let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
			let val = pxData[pxPos + x] - (left + up >> 1);
			rawData[rawPos + x] = val;
		}
	}
	function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
		let sum = 0;
		for (let x = 0; x < byteWidth; x++) {
			let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
			let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
			let val = pxData[pxPos + x] - (left + up >> 1);
			sum += Math.abs(val);
		}
		return sum;
	}
	function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
		for (let x = 0; x < byteWidth; x++) {
			let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
			let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
			let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
			let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
			rawData[rawPos + x] = val;
		}
	}
	function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
		let sum = 0;
		for (let x = 0; x < byteWidth; x++) {
			let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
			let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
			let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
			let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
			sum += Math.abs(val);
		}
		return sum;
	}
	let filters = {
		0: filterNone,
		1: filterSub,
		2: filterUp,
		3: filterAvg,
		4: filterPaeth
	};
	let filterSums = {
		0: filterSumNone,
		1: filterSumSub,
		2: filterSumUp,
		3: filterSumAvg,
		4: filterSumPaeth
	};
	module.exports = function(pxData, width, height, options, bpp) {
		let filterTypes;
		if (!("filterType" in options) || options.filterType === -1) filterTypes = [
			0,
			1,
			2,
			3,
			4
		];
		else if (typeof options.filterType === "number") filterTypes = [options.filterType];
		else throw new Error("unrecognised filter types");
		if (options.bitDepth === 16) bpp *= 2;
		let byteWidth = width * bpp;
		let rawPos = 0;
		let pxPos = 0;
		let rawData = Buffer.alloc((byteWidth + 1) * height);
		let sel = filterTypes[0];
		for (let y = 0; y < height; y++) {
			if (filterTypes.length > 1) {
				let min = Infinity;
				for (let i = 0; i < filterTypes.length; i++) {
					let sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
					if (sum < min) {
						sel = filterTypes[i];
						min = sum;
					}
				}
			}
			rawData[rawPos] = sel;
			rawPos++;
			filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
			rawPos += byteWidth;
			pxPos += byteWidth;
		}
		return rawData;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/packer.js
var require_packer = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/packer.js": ((exports, module) => {
	let constants$2 = require_constants();
	let CrcStream = require_crc();
	let bitPacker = require_bitpacker();
	let filter = require_filter_pack();
	let zlib$3 = __require("zlib");
	let Packer$3 = module.exports = function(options) {
		this._options = options;
		options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
		options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
		options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
		options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
		options.deflateFactory = options.deflateFactory || zlib$3.createDeflate;
		options.bitDepth = options.bitDepth || 8;
		options.colorType = typeof options.colorType === "number" ? options.colorType : constants$2.COLORTYPE_COLOR_ALPHA;
		options.inputColorType = typeof options.inputColorType === "number" ? options.inputColorType : constants$2.COLORTYPE_COLOR_ALPHA;
		if ([
			constants$2.COLORTYPE_GRAYSCALE,
			constants$2.COLORTYPE_COLOR,
			constants$2.COLORTYPE_COLOR_ALPHA,
			constants$2.COLORTYPE_ALPHA
		].indexOf(options.colorType) === -1) throw new Error("option color type:" + options.colorType + " is not supported at present");
		if ([
			constants$2.COLORTYPE_GRAYSCALE,
			constants$2.COLORTYPE_COLOR,
			constants$2.COLORTYPE_COLOR_ALPHA,
			constants$2.COLORTYPE_ALPHA
		].indexOf(options.inputColorType) === -1) throw new Error("option input color type:" + options.inputColorType + " is not supported at present");
		if (options.bitDepth !== 8 && options.bitDepth !== 16) throw new Error("option bit depth:" + options.bitDepth + " is not supported at present");
	};
	Packer$3.prototype.getDeflateOptions = function() {
		return {
			chunkSize: this._options.deflateChunkSize,
			level: this._options.deflateLevel,
			strategy: this._options.deflateStrategy
		};
	};
	Packer$3.prototype.createDeflate = function() {
		return this._options.deflateFactory(this.getDeflateOptions());
	};
	Packer$3.prototype.filterData = function(data, width, height) {
		let packedData = bitPacker(data, width, height, this._options);
		let bpp = constants$2.COLORTYPE_TO_BPP_MAP[this._options.colorType];
		return filter(packedData, width, height, this._options, bpp);
	};
	Packer$3.prototype._packChunk = function(type, data) {
		let len = data ? data.length : 0;
		let buf = Buffer.alloc(len + 12);
		buf.writeUInt32BE(len, 0);
		buf.writeUInt32BE(type, 4);
		if (data) data.copy(buf, 8);
		buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
		return buf;
	};
	Packer$3.prototype.packGAMA = function(gamma) {
		let buf = Buffer.alloc(4);
		buf.writeUInt32BE(Math.floor(gamma * constants$2.GAMMA_DIVISION), 0);
		return this._packChunk(constants$2.TYPE_gAMA, buf);
	};
	Packer$3.prototype.packIHDR = function(width, height) {
		let buf = Buffer.alloc(13);
		buf.writeUInt32BE(width, 0);
		buf.writeUInt32BE(height, 4);
		buf[8] = this._options.bitDepth;
		buf[9] = this._options.colorType;
		buf[10] = 0;
		buf[11] = 0;
		buf[12] = 0;
		return this._packChunk(constants$2.TYPE_IHDR, buf);
	};
	Packer$3.prototype.packIDAT = function(data) {
		return this._packChunk(constants$2.TYPE_IDAT, data);
	};
	Packer$3.prototype.packIEND = function() {
		return this._packChunk(constants$2.TYPE_IEND, null);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/packer-async.js
var require_packer_async = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/packer-async.js": ((exports, module) => {
	let util$3 = __require("util");
	let Stream$1 = __require("stream");
	let constants$1 = require_constants();
	let Packer$2 = require_packer();
	let PackerAsync = module.exports = function(opt) {
		Stream$1.call(this);
		this._packer = new Packer$2(opt || {});
		this._deflate = this._packer.createDeflate();
		this.readable = true;
	};
	util$3.inherits(PackerAsync, Stream$1);
	PackerAsync.prototype.pack = function(data, width, height, gamma) {
		this.emit("data", Buffer.from(constants$1.PNG_SIGNATURE));
		this.emit("data", this._packer.packIHDR(width, height));
		if (gamma) this.emit("data", this._packer.packGAMA(gamma));
		let filteredData = this._packer.filterData(data, width, height);
		this._deflate.on("error", this.emit.bind(this, "error"));
		this._deflate.on("data", function(compressedData) {
			this.emit("data", this._packer.packIDAT(compressedData));
		}.bind(this));
		this._deflate.on("end", function() {
			this.emit("data", this._packer.packIEND());
			this.emit("end");
		}.bind(this));
		this._deflate.end(filteredData);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/sync-inflate.js
var require_sync_inflate = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/sync-inflate.js": ((exports, module) => {
	let assert = __require("assert").ok;
	let zlib$2 = __require("zlib");
	let util$2 = __require("util");
	let kMaxLength = __require("buffer").kMaxLength;
	function Inflate(opts) {
		if (!(this instanceof Inflate)) return new Inflate(opts);
		if (opts && opts.chunkSize < zlib$2.Z_MIN_CHUNK) opts.chunkSize = zlib$2.Z_MIN_CHUNK;
		zlib$2.Inflate.call(this, opts);
		this._offset = this._offset === void 0 ? this._outOffset : this._offset;
		this._buffer = this._buffer || this._outBuffer;
		if (opts && opts.maxLength != null) this._maxLength = opts.maxLength;
	}
	function createInflate(opts) {
		return new Inflate(opts);
	}
	function _close(engine, callback) {
		if (callback) process.nextTick(callback);
		if (!engine._handle) return;
		engine._handle.close();
		engine._handle = null;
	}
	Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
		if (typeof asyncCb === "function") return zlib$2.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
		let self = this;
		let availInBefore = chunk && chunk.length;
		let availOutBefore = this._chunkSize - this._offset;
		let leftToInflate = this._maxLength;
		let inOff = 0;
		let buffers = [];
		let nread = 0;
		let error;
		this.on("error", function(err) {
			error = err;
		});
		function handleChunk(availInAfter, availOutAfter) {
			if (self._hadError) return;
			let have = availOutBefore - availOutAfter;
			assert(have >= 0, "have should not go down");
			if (have > 0) {
				let out = self._buffer.slice(self._offset, self._offset + have);
				self._offset += have;
				if (out.length > leftToInflate) out = out.slice(0, leftToInflate);
				buffers.push(out);
				nread += out.length;
				leftToInflate -= out.length;
				if (leftToInflate === 0) return false;
			}
			if (availOutAfter === 0 || self._offset >= self._chunkSize) {
				availOutBefore = self._chunkSize;
				self._offset = 0;
				self._buffer = Buffer.allocUnsafe(self._chunkSize);
			}
			if (availOutAfter === 0) {
				inOff += availInBefore - availInAfter;
				availInBefore = availInAfter;
				return true;
			}
			return false;
		}
		assert(this._handle, "zlib binding closed");
		let res;
		do {
			res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
			res = res || this._writeState;
		} while (!this._hadError && handleChunk(res[0], res[1]));
		if (this._hadError) throw error;
		if (nread >= kMaxLength) {
			_close(this);
			throw new RangeError("Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes");
		}
		let buf = Buffer.concat(buffers, nread);
		_close(this);
		return buf;
	};
	util$2.inherits(Inflate, zlib$2.Inflate);
	function zlibBufferSync(engine, buffer) {
		if (typeof buffer === "string") buffer = Buffer.from(buffer);
		if (!(buffer instanceof Buffer)) throw new TypeError("Not a string or buffer");
		let flushFlag = engine._finishFlushFlag;
		if (flushFlag == null) flushFlag = zlib$2.Z_FINISH;
		return engine._processChunk(buffer, flushFlag);
	}
	function inflateSync$1(buffer, opts) {
		return zlibBufferSync(new Inflate(opts), buffer);
	}
	module.exports = exports = inflateSync$1;
	exports.Inflate = Inflate;
	exports.createInflate = createInflate;
	exports.inflateSync = inflateSync$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/sync-reader.js
var require_sync_reader = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/sync-reader.js": ((exports, module) => {
	let SyncReader$2 = module.exports = function(buffer) {
		this._buffer = buffer;
		this._reads = [];
	};
	SyncReader$2.prototype.read = function(length, callback) {
		this._reads.push({
			length: Math.abs(length),
			allowLess: length < 0,
			func: callback
		});
	};
	SyncReader$2.prototype.process = function() {
		while (this._reads.length > 0 && this._buffer.length) {
			let read = this._reads[0];
			if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {
				this._reads.shift();
				let buf = this._buffer;
				this._buffer = buf.slice(read.length);
				read.func.call(this, buf.slice(0, read.length));
			} else break;
		}
		if (this._reads.length > 0) return /* @__PURE__ */ new Error("There are some read requests waitng on finished stream");
		if (this._buffer.length > 0) return /* @__PURE__ */ new Error("unrecognised content at end of stream");
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/filter-parse-sync.js
var require_filter_parse_sync = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/filter-parse-sync.js": ((exports) => {
	let SyncReader$1 = require_sync_reader();
	let Filter = require_filter_parse();
	exports.process = function(inBuffer, bitmapInfo) {
		let outBuffers = [];
		let reader = new SyncReader$1(inBuffer);
		new Filter(bitmapInfo, {
			read: reader.read.bind(reader),
			write: function(bufferPart) {
				outBuffers.push(bufferPart);
			},
			complete: function() {}
		}).start();
		reader.process();
		return Buffer.concat(outBuffers);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/parser-sync.js
var require_parser_sync = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/parser-sync.js": ((exports, module) => {
	let hasSyncZlib$1 = true;
	let zlib$1 = __require("zlib");
	let inflateSync = require_sync_inflate();
	if (!zlib$1.deflateSync) hasSyncZlib$1 = false;
	let SyncReader = require_sync_reader();
	let FilterSync = require_filter_parse_sync();
	let Parser$1 = require_parser();
	let bitmapper = require_bitmapper();
	let formatNormaliser = require_format_normaliser();
	module.exports = function(buffer, options) {
		if (!hasSyncZlib$1) throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
		let err;
		function handleError(_err_) {
			err = _err_;
		}
		let metaData;
		function handleMetaData(_metaData_) {
			metaData = _metaData_;
		}
		function handleTransColor(transColor) {
			metaData.transColor = transColor;
		}
		function handlePalette(palette) {
			metaData.palette = palette;
		}
		function handleSimpleTransparency() {
			metaData.alpha = true;
		}
		let gamma;
		function handleGamma(_gamma_) {
			gamma = _gamma_;
		}
		let inflateDataList = [];
		function handleInflateData(inflatedData$1) {
			inflateDataList.push(inflatedData$1);
		}
		let reader = new SyncReader(buffer);
		new Parser$1(options, {
			read: reader.read.bind(reader),
			error: handleError,
			metadata: handleMetaData,
			gamma: handleGamma,
			palette: handlePalette,
			transColor: handleTransColor,
			inflateData: handleInflateData,
			simpleTransparency: handleSimpleTransparency
		}).start();
		reader.process();
		if (err) throw err;
		let inflateData = Buffer.concat(inflateDataList);
		inflateDataList.length = 0;
		let inflatedData;
		if (metaData.interlace) inflatedData = zlib$1.inflateSync(inflateData);
		else {
			let imageSize = ((metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1) * metaData.height;
			inflatedData = inflateSync(inflateData, {
				chunkSize: imageSize,
				maxLength: imageSize
			});
		}
		inflateData = null;
		if (!inflatedData || !inflatedData.length) throw new Error("bad png - invalid inflate data response");
		let unfilteredData = FilterSync.process(inflatedData, metaData);
		inflateData = null;
		let bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
		unfilteredData = null;
		metaData.data = formatNormaliser(bitmapData, metaData);
		metaData.gamma = gamma || 0;
		return metaData;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/packer-sync.js
var require_packer_sync = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/packer-sync.js": ((exports, module) => {
	let hasSyncZlib = true;
	let zlib = __require("zlib");
	if (!zlib.deflateSync) hasSyncZlib = false;
	let constants = require_constants();
	let Packer$1 = require_packer();
	module.exports = function(metaData, opt) {
		if (!hasSyncZlib) throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
		let packer = new Packer$1(opt || {});
		let chunks = [];
		chunks.push(Buffer.from(constants.PNG_SIGNATURE));
		chunks.push(packer.packIHDR(metaData.width, metaData.height));
		if (metaData.gamma) chunks.push(packer.packGAMA(metaData.gamma));
		let filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);
		let compressedData = zlib.deflateSync(filteredData, packer.getDeflateOptions());
		filteredData = null;
		if (!compressedData || !compressedData.length) throw new Error("bad png - invalid compressed data response");
		chunks.push(packer.packIDAT(compressedData));
		chunks.push(packer.packIEND());
		return Buffer.concat(chunks);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/png-sync.js
var require_png_sync = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/png-sync.js": ((exports) => {
	let parse = require_parser_sync();
	let pack = require_packer_sync();
	exports.read = function(buffer, options) {
		return parse(buffer, options || {});
	};
	exports.write = function(png, options) {
		return pack(png, options);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/png.js
var require_png$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pngjs@5.0.0/node_modules/pngjs/lib/png.js": ((exports) => {
	let util$1 = __require("util");
	let Stream = __require("stream");
	let Parser = require_parser_async();
	let Packer = require_packer_async();
	let PNGSync = require_png_sync();
	let PNG$1 = exports.PNG = function(options) {
		Stream.call(this);
		options = options || {};
		this.width = options.width | 0;
		this.height = options.height | 0;
		this.data = this.width > 0 && this.height > 0 ? Buffer.alloc(4 * this.width * this.height) : null;
		if (options.fill && this.data) this.data.fill(0);
		this.gamma = 0;
		this.readable = this.writable = true;
		this._parser = new Parser(options);
		this._parser.on("error", this.emit.bind(this, "error"));
		this._parser.on("close", this._handleClose.bind(this));
		this._parser.on("metadata", this._metadata.bind(this));
		this._parser.on("gamma", this._gamma.bind(this));
		this._parser.on("parsed", function(data) {
			this.data = data;
			this.emit("parsed", data);
		}.bind(this));
		this._packer = new Packer(options);
		this._packer.on("data", this.emit.bind(this, "data"));
		this._packer.on("end", this.emit.bind(this, "end"));
		this._parser.on("close", this._handleClose.bind(this));
		this._packer.on("error", this.emit.bind(this, "error"));
	};
	util$1.inherits(PNG$1, Stream);
	PNG$1.sync = PNGSync;
	PNG$1.prototype.pack = function() {
		if (!this.data || !this.data.length) {
			this.emit("error", "No data provided");
			return this;
		}
		process.nextTick(function() {
			this._packer.pack(this.data, this.width, this.height, this.gamma);
		}.bind(this));
		return this;
	};
	PNG$1.prototype.parse = function(data, callback) {
		if (callback) {
			let onParsed, onError$1;
			onParsed = function(parsedData) {
				this.removeListener("error", onError$1);
				this.data = parsedData;
				callback(null, this);
			}.bind(this);
			onError$1 = function(err) {
				this.removeListener("parsed", onParsed);
				callback(err, null);
			}.bind(this);
			this.once("parsed", onParsed);
			this.once("error", onError$1);
		}
		this.end(data);
		return this;
	};
	PNG$1.prototype.write = function(data) {
		this._parser.write(data);
		return true;
	};
	PNG$1.prototype.end = function(data) {
		this._parser.end(data);
	};
	PNG$1.prototype._metadata = function(metadata) {
		this.width = metadata.width;
		this.height = metadata.height;
		this.emit("metadata", metadata);
	};
	PNG$1.prototype._gamma = function(gamma) {
		this.gamma = gamma;
	};
	PNG$1.prototype._handleClose = function() {
		if (!this._parser.writable && !this._packer.readable) this.emit("close");
	};
	PNG$1.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
		srcX |= 0;
		srcY |= 0;
		width |= 0;
		height |= 0;
		deltaX |= 0;
		deltaY |= 0;
		if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) throw new Error("bitblt reading outside image");
		if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) throw new Error("bitblt writing outside image");
		for (let y = 0; y < height; y++) src.data.copy(dst.data, (deltaY + y) * dst.width + deltaX << 2, (srcY + y) * src.width + srcX << 2, (srcY + y) * src.width + srcX + width << 2);
	};
	PNG$1.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
		PNG$1.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
		return this;
	};
	PNG$1.adjustGamma = function(src) {
		if (src.gamma) {
			for (let y = 0; y < src.height; y++) for (let x = 0; x < src.width; x++) {
				let idx = src.width * y + x << 2;
				for (let i = 0; i < 3; i++) {
					let sample = src.data[idx + i] / 255;
					sample = Math.pow(sample, 1 / 2.2 / src.gamma);
					src.data[idx + i] = Math.round(sample * 255);
				}
			}
			src.gamma = 0;
		}
	};
	PNG$1.prototype.adjustGamma = function() {
		PNG$1.adjustGamma(this);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/utils.js
var require_utils = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/utils.js": ((exports) => {
	function hex2rgba(hex) {
		if (typeof hex === "number") hex = hex.toString();
		if (typeof hex !== "string") throw new Error("Color should be defined as hex string");
		let hexCode = hex.slice().replace("#", "").split("");
		if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) throw new Error("Invalid hex color: " + hex);
		if (hexCode.length === 3 || hexCode.length === 4) hexCode = Array.prototype.concat.apply([], hexCode.map(function(c) {
			return [c, c];
		}));
		if (hexCode.length === 6) hexCode.push("F", "F");
		const hexValue = parseInt(hexCode.join(""), 16);
		return {
			r: hexValue >> 24 & 255,
			g: hexValue >> 16 & 255,
			b: hexValue >> 8 & 255,
			a: hexValue & 255,
			hex: "#" + hexCode.slice(0, 6).join("")
		};
	}
	exports.getOptions = function getOptions(options) {
		if (!options) options = {};
		if (!options.color) options.color = {};
		const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
		const width = options.width && options.width >= 21 ? options.width : void 0;
		const scale = options.scale || 4;
		return {
			width,
			scale: width ? 4 : scale,
			margin,
			color: {
				dark: hex2rgba(options.color.dark || "#000000ff"),
				light: hex2rgba(options.color.light || "#ffffffff")
			},
			type: options.type,
			rendererOpts: options.rendererOpts || {}
		};
	};
	exports.getScale = function getScale(qrSize, opts) {
		return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
	};
	exports.getImageWidth = function getImageWidth(qrSize, opts) {
		const scale = exports.getScale(qrSize, opts);
		return Math.floor((qrSize + opts.margin * 2) * scale);
	};
	exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
		const size = qr.modules.size;
		const data = qr.modules.data;
		const scale = exports.getScale(size, opts);
		const symbolSize = Math.floor((size + opts.margin * 2) * scale);
		const scaledMargin = opts.margin * scale;
		const palette = [opts.color.light, opts.color.dark];
		for (let i = 0; i < symbolSize; i++) for (let j = 0; j < symbolSize; j++) {
			let posDst = (i * symbolSize + j) * 4;
			let pxColor = opts.color.light;
			if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
				const iSrc = Math.floor((i - scaledMargin) / scale);
				const jSrc = Math.floor((j - scaledMargin) / scale);
				pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
			}
			imgData[posDst++] = pxColor.r;
			imgData[posDst++] = pxColor.g;
			imgData[posDst++] = pxColor.b;
			imgData[posDst] = pxColor.a;
		}
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/png.js
var require_png = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/png.js": ((exports) => {
	const fs$1 = __require("fs");
	const PNG = require_png$1().PNG;
	const Utils$3 = require_utils();
	exports.render = function render$1(qrData, options) {
		const opts = Utils$3.getOptions(options);
		const pngOpts = opts.rendererOpts;
		const size = Utils$3.getImageWidth(qrData.modules.size, opts);
		pngOpts.width = size;
		pngOpts.height = size;
		const pngImage = new PNG(pngOpts);
		Utils$3.qrToImageData(pngImage.data, qrData, opts);
		return pngImage;
	};
	exports.renderToDataURL = function renderToDataURL(qrData, options, cb) {
		if (typeof cb === "undefined") {
			cb = options;
			options = void 0;
		}
		exports.renderToBuffer(qrData, options, function(err, output) {
			if (err) cb(err);
			let url = "data:image/png;base64,";
			url += output.toString("base64");
			cb(null, url);
		});
	};
	exports.renderToBuffer = function renderToBuffer(qrData, options, cb) {
		if (typeof cb === "undefined") {
			cb = options;
			options = void 0;
		}
		const png = exports.render(qrData, options);
		const buffer = [];
		png.on("error", cb);
		png.on("data", function(data) {
			buffer.push(data);
		});
		png.on("end", function() {
			cb(null, Buffer.concat(buffer));
		});
		png.pack();
	};
	exports.renderToFile = function renderToFile(path$1, qrData, options, cb) {
		if (typeof cb === "undefined") {
			cb = options;
			options = void 0;
		}
		let called = false;
		const done = (...args) => {
			if (called) return;
			called = true;
			cb.apply(null, args);
		};
		const stream$1 = fs$1.createWriteStream(path$1);
		stream$1.on("error", done);
		stream$1.on("close", done);
		exports.renderToFileStream(stream$1, qrData, options);
	};
	exports.renderToFileStream = function renderToFileStream(stream$1, qrData, options) {
		exports.render(qrData, options).pack().pipe(stream$1);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/utf8.js
var require_utf8 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/utf8.js": ((exports) => {
	const Utils$2 = require_utils();
	const BLOCK_CHAR = {
		WW: " ",
		WB: "▄",
		BB: "█",
		BW: "▀"
	};
	const INVERTED_BLOCK_CHAR = {
		BB: " ",
		BW: "▄",
		WW: "█",
		WB: "▀"
	};
	function getBlockChar(top, bottom, blocks) {
		if (top && bottom) return blocks.BB;
		if (top && !bottom) return blocks.BW;
		if (!top && bottom) return blocks.WB;
		return blocks.WW;
	}
	exports.render = function(qrData, options, cb) {
		const opts = Utils$2.getOptions(options);
		let blocks = BLOCK_CHAR;
		if (opts.color.dark.hex === "#ffffff" || opts.color.light.hex === "#000000") blocks = INVERTED_BLOCK_CHAR;
		const size = qrData.modules.size;
		const data = qrData.modules.data;
		let output = "";
		let hMargin = Array(size + opts.margin * 2 + 1).join(blocks.WW);
		hMargin = Array(opts.margin / 2 + 1).join(hMargin + "\n");
		const vMargin = Array(opts.margin + 1).join(blocks.WW);
		output += hMargin;
		for (let i = 0; i < size; i += 2) {
			output += vMargin;
			for (let j = 0; j < size; j++) {
				const topModule = data[i * size + j];
				const bottomModule = data[(i + 1) * size + j];
				output += getBlockChar(topModule, bottomModule, blocks);
			}
			output += vMargin + "\n";
		}
		output += hMargin.slice(0, -1);
		if (typeof cb === "function") cb(null, output);
		return output;
	};
	exports.renderToFile = function renderToFile(path$1, qrData, options, cb) {
		if (typeof cb === "undefined") {
			cb = options;
			options = void 0;
		}
		const fs$2 = __require("fs");
		const utf8 = exports.render(qrData, options);
		fs$2.writeFile(path$1, utf8, cb);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/terminal/terminal.js
var require_terminal$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/terminal/terminal.js": ((exports) => {
	exports.render = function(qrData, options, cb) {
		const size = qrData.modules.size;
		const data = qrData.modules.data;
		const black = "\x1B[40m  \x1B[0m";
		const white = "\x1B[47m  \x1B[0m";
		let output = "";
		const hMargin = Array(size + 3).join(white);
		const vMargin = Array(2).join(white);
		output += hMargin + "\n";
		for (let i = 0; i < size; ++i) {
			output += white;
			for (let j = 0; j < size; j++) output += data[i * size + j] ? black : white;
			output += vMargin + "\n";
		}
		output += hMargin + "\n";
		if (typeof cb === "function") cb(null, output);
		return output;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/terminal/terminal-small.js
var require_terminal_small = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/terminal/terminal-small.js": ((exports) => {
	const backgroundWhite = "\x1B[47m";
	const backgroundBlack = "\x1B[40m";
	const foregroundWhite = "\x1B[37m";
	const foregroundBlack = "\x1B[30m";
	const reset = "\x1B[0m";
	const lineSetupNormal = backgroundWhite + foregroundBlack;
	const lineSetupInverse = backgroundBlack + foregroundWhite;
	const createPalette = function(lineSetup, foregroundWhite$1, foregroundBlack$1) {
		return {
			"00": reset + " " + lineSetup,
			"01": reset + foregroundWhite$1 + "▄" + lineSetup,
			"02": reset + foregroundBlack$1 + "▄" + lineSetup,
			10: reset + foregroundWhite$1 + "▀" + lineSetup,
			11: " ",
			12: "▄",
			20: reset + foregroundBlack$1 + "▀" + lineSetup,
			21: "▀",
			22: "█"
		};
	};
	/**
	* Returns code for QR pixel
	* @param {boolean[][]} modules
	* @param {number} size
	* @param {number} x
	* @param {number} y
	* @return {'0' | '1' | '2'}
	*/
	const mkCodePixel = function(modules, size, x, y) {
		const sizePlus = size + 1;
		if (x >= sizePlus || y >= sizePlus || y < -1 || x < -1) return "0";
		if (x >= size || y >= size || y < 0 || x < 0) return "1";
		return modules[y * size + x] ? "2" : "1";
	};
	/**
	* Returns code for four QR pixels. Suitable as key in palette.
	* @param {boolean[][]} modules
	* @param {number} size
	* @param {number} x
	* @param {number} y
	* @return {keyof palette}
	*/
	const mkCode = function(modules, size, x, y) {
		return mkCodePixel(modules, size, x, y) + mkCodePixel(modules, size, x, y + 1);
	};
	exports.render = function(qrData, options, cb) {
		const size = qrData.modules.size;
		const data = qrData.modules.data;
		const inverse = !!(options && options.inverse);
		const lineSetup = options && options.inverse ? lineSetupInverse : lineSetupNormal;
		const palette = createPalette(lineSetup, inverse ? foregroundBlack : foregroundWhite, inverse ? foregroundWhite : foregroundBlack);
		const newLine = reset + "\n" + lineSetup;
		let output = lineSetup;
		for (let y = -1; y < size + 1; y += 2) {
			for (let x = -1; x < size; x++) output += palette[mkCode(data, size, x, y)];
			output += palette[mkCode(data, size, size, y)] + newLine;
		}
		output += reset;
		if (typeof cb === "function") cb(null, output);
		return output;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/terminal.js
var require_terminal = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/terminal.js": ((exports) => {
	const big = require_terminal$1();
	const small = require_terminal_small();
	exports.render = function(qrData, options, cb) {
		if (options && options.small) return small.render(qrData, options, cb);
		return big.render(qrData, options, cb);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/svg-tag.js": ((exports) => {
	const Utils$1 = require_utils();
	function getColorAttrib(color, attrib) {
		const alpha = color.a / 255;
		const str = attrib + "=\"" + color.hex + "\"";
		return alpha < 1 ? str + " " + attrib + "-opacity=\"" + alpha.toFixed(2).slice(1) + "\"" : str;
	}
	function svgCmd(cmd, x, y) {
		let str = cmd + x;
		if (typeof y !== "undefined") str += " " + y;
		return str;
	}
	function qrToPath(data, size, margin) {
		let path$1 = "";
		let moveBy = 0;
		let newRow = false;
		let lineLength = 0;
		for (let i = 0; i < data.length; i++) {
			const col = Math.floor(i % size);
			const row = Math.floor(i / size);
			if (!col && !newRow) newRow = true;
			if (data[i]) {
				lineLength++;
				if (!(i > 0 && col > 0 && data[i - 1])) {
					path$1 += newRow ? svgCmd("M", col + margin, .5 + row + margin) : svgCmd("m", moveBy, 0);
					moveBy = 0;
					newRow = false;
				}
				if (!(col + 1 < size && data[i + 1])) {
					path$1 += svgCmd("h", lineLength);
					lineLength = 0;
				}
			} else moveBy++;
		}
		return path$1;
	}
	exports.render = function render$1(qrData, options, cb) {
		const opts = Utils$1.getOptions(options);
		const size = qrData.modules.size;
		const data = qrData.modules.data;
		const qrcodesize = size + opts.margin * 2;
		const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + " d=\"M0 0h" + qrcodesize + "v" + qrcodesize + "H0z\"/>";
		const path$1 = "<path " + getColorAttrib(opts.color.dark, "stroke") + " d=\"" + qrToPath(data, size, opts.margin) + "\"/>";
		const viewBox = "viewBox=\"0 0 " + qrcodesize + " " + qrcodesize + "\"";
		const svgTag = "<svg xmlns=\"http://www.w3.org/2000/svg\" " + (!opts.width ? "" : "width=\"" + opts.width + "\" height=\"" + opts.width + "\" ") + viewBox + " shape-rendering=\"crispEdges\">" + bg + path$1 + "</svg>\n";
		if (typeof cb === "function") cb(null, svgTag);
		return svgTag;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/svg.js
var require_svg = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/svg.js": ((exports) => {
	const svgTagRenderer = require_svg_tag();
	exports.render = svgTagRenderer.render;
	exports.renderToFile = function renderToFile(path$1, qrData, options, cb) {
		if (typeof cb === "undefined") {
			cb = options;
			options = void 0;
		}
		const fs$2 = __require("fs");
		const xmlStr = "<?xml version=\"1.0\" encoding=\"utf-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">" + exports.render(qrData, options);
		fs$2.writeFile(path$1, xmlStr, cb);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/canvas.js": ((exports) => {
	const Utils = require_utils();
	function clearCanvas(ctx, canvas, size) {
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		if (!canvas.style) canvas.style = {};
		canvas.height = size;
		canvas.width = size;
		canvas.style.height = size + "px";
		canvas.style.width = size + "px";
	}
	function getCanvasElement() {
		try {
			return document.createElement("canvas");
		} catch (e) {
			throw new Error("You need to specify a canvas element");
		}
	}
	exports.render = function render$1(qrData, canvas, options) {
		let opts = options;
		let canvasEl = canvas;
		if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
			opts = canvas;
			canvas = void 0;
		}
		if (!canvas) canvasEl = getCanvasElement();
		opts = Utils.getOptions(opts);
		const size = Utils.getImageWidth(qrData.modules.size, opts);
		const ctx = canvasEl.getContext("2d");
		const image = ctx.createImageData(size, size);
		Utils.qrToImageData(image.data, qrData, opts);
		clearCanvas(ctx, canvasEl, size);
		ctx.putImageData(image, 0, 0);
		return canvasEl;
	};
	exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
		let opts = options;
		if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
			opts = canvas;
			canvas = void 0;
		}
		if (!opts) opts = {};
		const canvasEl = exports.render(qrData, canvas, opts);
		const type = opts.type || "image/png";
		const rendererOpts = opts.rendererOpts || {};
		return canvasEl.toDataURL(type, rendererOpts.quality);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/browser.js
var require_browser = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/browser.js": ((exports) => {
	const canPromise$1 = require_can_promise();
	const QRCode$2 = require_qrcode();
	const CanvasRenderer = require_canvas();
	const SvgRenderer$1 = require_svg_tag();
	function renderCanvas(renderFunc, canvas, text, opts, cb) {
		const args = [].slice.call(arguments, 1);
		const argsNum = args.length;
		const isLastArgCb = typeof args[argsNum - 1] === "function";
		if (!isLastArgCb && !canPromise$1()) throw new Error("Callback required as last argument");
		if (isLastArgCb) {
			if (argsNum < 2) throw new Error("Too few arguments provided");
			if (argsNum === 2) {
				cb = text;
				text = canvas;
				canvas = opts = void 0;
			} else if (argsNum === 3) if (canvas.getContext && typeof cb === "undefined") {
				cb = opts;
				opts = void 0;
			} else {
				cb = opts;
				opts = text;
				text = canvas;
				canvas = void 0;
			}
		} else {
			if (argsNum < 1) throw new Error("Too few arguments provided");
			if (argsNum === 1) {
				text = canvas;
				canvas = opts = void 0;
			} else if (argsNum === 2 && !canvas.getContext) {
				opts = text;
				text = canvas;
				canvas = void 0;
			}
			return new Promise(function(resolve, reject) {
				try {
					resolve(renderFunc(QRCode$2.create(text, opts), canvas, opts));
				} catch (e) {
					reject(e);
				}
			});
		}
		try {
			const data = QRCode$2.create(text, opts);
			cb(null, renderFunc(data, canvas, opts));
		} catch (e) {
			cb(e);
		}
	}
	exports.create = QRCode$2.create;
	exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
	exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
	exports.toString = renderCanvas.bind(null, function(data, _, opts) {
		return SvgRenderer$1.render(data, opts);
	});
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/server.js
var require_server = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/server.js": ((exports) => {
	const canPromise = require_can_promise();
	const QRCode$1 = require_qrcode();
	const PngRenderer = require_png();
	const Utf8Renderer = require_utf8();
	const TerminalRenderer = require_terminal();
	const SvgRenderer = require_svg();
	function checkParams(text, opts, cb) {
		if (typeof text === "undefined") throw new Error("String required as first argument");
		if (typeof cb === "undefined") {
			cb = opts;
			opts = {};
		}
		if (typeof cb !== "function") if (!canPromise()) throw new Error("Callback required as last argument");
		else {
			opts = cb || {};
			cb = null;
		}
		return {
			opts,
			cb
		};
	}
	function getStringRendererFromType(type) {
		switch (type) {
			case "svg": return SvgRenderer;
			case "terminal": return TerminalRenderer;
			case "utf8":
			default: return Utf8Renderer;
		}
	}
	function render(renderFunc, text, params) {
		if (!params.cb) return new Promise(function(resolve, reject) {
			try {
				return renderFunc(QRCode$1.create(text, params.opts), params.opts, function(err, data) {
					return err ? reject(err) : resolve(data);
				});
			} catch (e) {
				reject(e);
			}
		});
		try {
			return renderFunc(QRCode$1.create(text, params.opts), params.opts, params.cb);
		} catch (e) {
			params.cb(e);
		}
	}
	exports.create = QRCode$1.create;
	exports.toCanvas = require_browser().toCanvas;
	exports.toString = function toString(text, opts, cb) {
		const params = checkParams(text, opts, cb);
		return render(getStringRendererFromType(params.opts ? params.opts.type : void 0).render, text, params);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/index.js
var require_lib = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/index.js": ((exports, module) => {
	module.exports = require_server();
}) });

//#endregion
//#region ../../node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom-server-legacy.node.production.js
var require_react_dom_server_legacy_node_production = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom-server-legacy.node.production.js": ((exports) => {
	var React$2 = require_react(), ReactDOM$1 = require_react_dom(), REACT_ELEMENT_TYPE$1 = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE$1 = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE$1 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE$1 = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE$1 = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE$1 = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE$1 = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE$1 = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE$1 = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE$1 = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE$1 = Symbol.for("react.memo"), REACT_LAZY_TYPE$1 = Symbol.for("react.lazy"), REACT_SCOPE_TYPE$1 = Symbol.for("react.scope"), REACT_ACTIVITY_TYPE$1 = Symbol.for("react.activity"), REACT_LEGACY_HIDDEN_TYPE$1 = Symbol.for("react.legacy_hidden"), REACT_MEMO_CACHE_SENTINEL$1 = Symbol.for("react.memo_cache_sentinel"), REACT_VIEW_TRANSITION_TYPE$1 = Symbol.for("react.view_transition"), MAYBE_ITERATOR_SYMBOL$1 = Symbol.iterator;
	function getIteratorFn$1(maybeIterable) {
		if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
		maybeIterable = MAYBE_ITERATOR_SYMBOL$1 && maybeIterable[MAYBE_ITERATOR_SYMBOL$1] || maybeIterable["@@iterator"];
		return "function" === typeof maybeIterable ? maybeIterable : null;
	}
	var isArrayImpl$1 = Array.isArray;
	function murmurhash3_32_gc(key, seed) {
		var remainder = key.length & 3;
		var bytes = key.length - remainder;
		var h1 = seed;
		for (seed = 0; seed < bytes;) {
			var k1 = key.charCodeAt(seed) & 255 | (key.charCodeAt(++seed) & 255) << 8 | (key.charCodeAt(++seed) & 255) << 16 | (key.charCodeAt(++seed) & 255) << 24;
			++seed;
			k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295;
			k1 = k1 << 15 | k1 >>> 17;
			k1 = 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
			h1 ^= k1;
			h1 = h1 << 13 | h1 >>> 19;
			h1 = 5 * (h1 & 65535) + ((5 * (h1 >>> 16) & 65535) << 16) & 4294967295;
			h1 = (h1 & 65535) + 27492 + (((h1 >>> 16) + 58964 & 65535) << 16);
		}
		k1 = 0;
		switch (remainder) {
			case 3: k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;
			case 2: k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;
			case 1: k1 ^= key.charCodeAt(seed) & 255, k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295, k1 = k1 << 15 | k1 >>> 17, h1 ^= 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
		}
		h1 ^= key.length;
		h1 ^= h1 >>> 16;
		h1 = 2246822507 * (h1 & 65535) + ((2246822507 * (h1 >>> 16) & 65535) << 16) & 4294967295;
		h1 ^= h1 >>> 13;
		h1 = 3266489909 * (h1 & 65535) + ((3266489909 * (h1 >>> 16) & 65535) << 16) & 4294967295;
		return (h1 ^ h1 >>> 16) >>> 0;
	}
	var assign$1 = Object.assign, hasOwnProperty$1 = Object.prototype.hasOwnProperty, VALID_ATTRIBUTE_NAME_REGEX$1 = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), illegalAttributeNameCache$1 = {}, validatedAttributeNameCache$1 = {};
	function isAttributeNameSafe$1(attributeName) {
		if (hasOwnProperty$1.call(validatedAttributeNameCache$1, attributeName)) return !0;
		if (hasOwnProperty$1.call(illegalAttributeNameCache$1, attributeName)) return !1;
		if (VALID_ATTRIBUTE_NAME_REGEX$1.test(attributeName)) return validatedAttributeNameCache$1[attributeName] = !0;
		illegalAttributeNameCache$1[attributeName] = !0;
		return !1;
	}
	var unitlessNumbers$1 = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")), aliases$1 = new Map([
		["acceptCharset", "accept-charset"],
		["htmlFor", "for"],
		["httpEquiv", "http-equiv"],
		["crossOrigin", "crossorigin"],
		["accentHeight", "accent-height"],
		["alignmentBaseline", "alignment-baseline"],
		["arabicForm", "arabic-form"],
		["baselineShift", "baseline-shift"],
		["capHeight", "cap-height"],
		["clipPath", "clip-path"],
		["clipRule", "clip-rule"],
		["colorInterpolation", "color-interpolation"],
		["colorInterpolationFilters", "color-interpolation-filters"],
		["colorProfile", "color-profile"],
		["colorRendering", "color-rendering"],
		["dominantBaseline", "dominant-baseline"],
		["enableBackground", "enable-background"],
		["fillOpacity", "fill-opacity"],
		["fillRule", "fill-rule"],
		["floodColor", "flood-color"],
		["floodOpacity", "flood-opacity"],
		["fontFamily", "font-family"],
		["fontSize", "font-size"],
		["fontSizeAdjust", "font-size-adjust"],
		["fontStretch", "font-stretch"],
		["fontStyle", "font-style"],
		["fontVariant", "font-variant"],
		["fontWeight", "font-weight"],
		["glyphName", "glyph-name"],
		["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
		["glyphOrientationVertical", "glyph-orientation-vertical"],
		["horizAdvX", "horiz-adv-x"],
		["horizOriginX", "horiz-origin-x"],
		["imageRendering", "image-rendering"],
		["letterSpacing", "letter-spacing"],
		["lightingColor", "lighting-color"],
		["markerEnd", "marker-end"],
		["markerMid", "marker-mid"],
		["markerStart", "marker-start"],
		["overlinePosition", "overline-position"],
		["overlineThickness", "overline-thickness"],
		["paintOrder", "paint-order"],
		["panose-1", "panose-1"],
		["pointerEvents", "pointer-events"],
		["renderingIntent", "rendering-intent"],
		["shapeRendering", "shape-rendering"],
		["stopColor", "stop-color"],
		["stopOpacity", "stop-opacity"],
		["strikethroughPosition", "strikethrough-position"],
		["strikethroughThickness", "strikethrough-thickness"],
		["strokeDasharray", "stroke-dasharray"],
		["strokeDashoffset", "stroke-dashoffset"],
		["strokeLinecap", "stroke-linecap"],
		["strokeLinejoin", "stroke-linejoin"],
		["strokeMiterlimit", "stroke-miterlimit"],
		["strokeOpacity", "stroke-opacity"],
		["strokeWidth", "stroke-width"],
		["textAnchor", "text-anchor"],
		["textDecoration", "text-decoration"],
		["textRendering", "text-rendering"],
		["transformOrigin", "transform-origin"],
		["underlinePosition", "underline-position"],
		["underlineThickness", "underline-thickness"],
		["unicodeBidi", "unicode-bidi"],
		["unicodeRange", "unicode-range"],
		["unitsPerEm", "units-per-em"],
		["vAlphabetic", "v-alphabetic"],
		["vHanging", "v-hanging"],
		["vIdeographic", "v-ideographic"],
		["vMathematical", "v-mathematical"],
		["vectorEffect", "vector-effect"],
		["vertAdvY", "vert-adv-y"],
		["vertOriginX", "vert-origin-x"],
		["vertOriginY", "vert-origin-y"],
		["wordSpacing", "word-spacing"],
		["writingMode", "writing-mode"],
		["xmlnsXlink", "xmlns:xlink"],
		["xHeight", "x-height"]
	]), matchHtmlRegExp$1 = /["'&<>]/;
	function escapeTextForBrowser$1(text) {
		if ("boolean" === typeof text || "number" === typeof text || "bigint" === typeof text) return "" + text;
		text = "" + text;
		var match = matchHtmlRegExp$1.exec(text);
		if (match) {
			var html = "", index, lastIndex = 0;
			for (index = match.index; index < text.length; index++) {
				switch (text.charCodeAt(index)) {
					case 34:
						match = "&quot;";
						break;
					case 38:
						match = "&amp;";
						break;
					case 39:
						match = "&#x27;";
						break;
					case 60:
						match = "&lt;";
						break;
					case 62:
						match = "&gt;";
						break;
					default: continue;
				}
				lastIndex !== index && (html += text.slice(lastIndex, index));
				lastIndex = index + 1;
				html += match;
			}
			text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;
		}
		return text;
	}
	var uppercasePattern$1 = /([A-Z])/g, msPattern$1 = /^ms-/, isJavaScriptProtocol$1 = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
	function sanitizeURL$1(url) {
		return isJavaScriptProtocol$1.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
	}
	var ReactSharedInternals$1 = React$2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals$1 = ReactDOM$1.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject$1 = {
		pending: !1,
		data: null,
		method: null,
		action: null
	}, previousDispatcher$1 = ReactDOMSharedInternals$1.d;
	ReactDOMSharedInternals$1.d = {
		f: previousDispatcher$1.f,
		r: previousDispatcher$1.r,
		D: prefetchDNS$1,
		C: preconnect$1,
		L: preload$1,
		m: preloadModule$1,
		X: preinitScript$1,
		S: preinitStyle$1,
		M: preinitModuleScript$1
	};
	var PRELOAD_NO_CREDS$1 = [], currentlyFlushingRenderState$1 = null, scriptRegex$1 = /(<\/|<)(s)(cript)/gi;
	function scriptReplacer$1(match, prefix$2, s$1, suffix$2) {
		return "" + prefix$2 + ("s" === s$1 ? "\\u0073" : "\\u0053") + suffix$2;
	}
	function createResumableState$1(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
		return {
			idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
			nextFormID: 0,
			streamingFormat: 0,
			bootstrapScriptContent,
			bootstrapScripts,
			bootstrapModules,
			instructions: 0,
			hasBody: !1,
			hasHtml: !1,
			unknownResources: {},
			dnsResources: {},
			connectResources: {
				default: {},
				anonymous: {},
				credentials: {}
			},
			imageResources: {},
			styleResources: {},
			scriptResources: {},
			moduleUnknownResources: {},
			moduleScriptResources: {}
		};
	}
	function createFormatContext$1(insertionMode, selectedValue, tagScope, viewTransition) {
		return {
			insertionMode,
			selectedValue,
			tagScope,
			viewTransition
		};
	}
	function getChildFormatContext$1(parentContext, type, props) {
		var subtreeScope = parentContext.tagScope & -25;
		switch (type) {
			case "noscript": return createFormatContext$1(2, null, subtreeScope | 1, null);
			case "select": return createFormatContext$1(2, null != props.value ? props.value : props.defaultValue, subtreeScope, null);
			case "svg": return createFormatContext$1(4, null, subtreeScope, null);
			case "picture": return createFormatContext$1(2, null, subtreeScope | 2, null);
			case "math": return createFormatContext$1(5, null, subtreeScope, null);
			case "foreignObject": return createFormatContext$1(2, null, subtreeScope, null);
			case "table": return createFormatContext$1(6, null, subtreeScope, null);
			case "thead":
			case "tbody":
			case "tfoot": return createFormatContext$1(7, null, subtreeScope, null);
			case "colgroup": return createFormatContext$1(9, null, subtreeScope, null);
			case "tr": return createFormatContext$1(8, null, subtreeScope, null);
			case "head":
				if (2 > parentContext.insertionMode) return createFormatContext$1(3, null, subtreeScope, null);
				break;
			case "html": if (0 === parentContext.insertionMode) return createFormatContext$1(1, null, subtreeScope, null);
		}
		return 6 <= parentContext.insertionMode || 2 > parentContext.insertionMode ? createFormatContext$1(2, null, subtreeScope, null) : parentContext.tagScope !== subtreeScope ? createFormatContext$1(parentContext.insertionMode, parentContext.selectedValue, subtreeScope, null) : parentContext;
	}
	function getSuspenseViewTransition$1(parentViewTransition) {
		return null === parentViewTransition ? null : {
			update: parentViewTransition.update,
			enter: "none",
			exit: "none",
			share: parentViewTransition.update,
			name: parentViewTransition.autoName,
			autoName: parentViewTransition.autoName,
			nameIdx: 0
		};
	}
	function getSuspenseFallbackFormatContext$1(resumableState, parentContext) {
		parentContext.tagScope & 32 && (resumableState.instructions |= 128);
		return createFormatContext$1(parentContext.insertionMode, parentContext.selectedValue, parentContext.tagScope | 12, getSuspenseViewTransition$1(parentContext.viewTransition));
	}
	function getSuspenseContentFormatContext$1(resumableState, parentContext) {
		resumableState = getSuspenseViewTransition$1(parentContext.viewTransition);
		var subtreeScope = parentContext.tagScope | 16;
		null !== resumableState && "none" !== resumableState.share && (subtreeScope |= 64);
		return createFormatContext$1(parentContext.insertionMode, parentContext.selectedValue, subtreeScope, resumableState);
	}
	var styleNameCache$1 = /* @__PURE__ */ new Map();
	function pushStyleAttribute$1(target, style) {
		if ("object" !== typeof style) throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
		var isFirst = !0, styleName;
		for (styleName in style) if (hasOwnProperty$1.call(style, styleName)) {
			var styleValue = style[styleName];
			if (null != styleValue && "boolean" !== typeof styleValue && "" !== styleValue) {
				if (0 === styleName.indexOf("--")) {
					var nameChunk = escapeTextForBrowser$1(styleName);
					styleValue = escapeTextForBrowser$1(("" + styleValue).trim());
				} else nameChunk = styleNameCache$1.get(styleName), void 0 === nameChunk && (nameChunk = escapeTextForBrowser$1(styleName.replace(uppercasePattern$1, "-$1").toLowerCase().replace(msPattern$1, "-ms-")), styleNameCache$1.set(styleName, nameChunk)), styleValue = "number" === typeof styleValue ? 0 === styleValue || unitlessNumbers$1.has(styleName) ? "" + styleValue : styleValue + "px" : escapeTextForBrowser$1(("" + styleValue).trim());
				isFirst ? (isFirst = !1, target.push(" style=\"", nameChunk, ":", styleValue)) : target.push(";", nameChunk, ":", styleValue);
			}
		}
		isFirst || target.push("\"");
	}
	function pushBooleanAttribute$1(target, name, value) {
		value && "function" !== typeof value && "symbol" !== typeof value && target.push(" ", name, "=\"\"");
	}
	function pushStringAttribute$1(target, name, value) {
		"function" !== typeof value && "symbol" !== typeof value && "boolean" !== typeof value && target.push(" ", name, "=\"", escapeTextForBrowser$1(value), "\"");
	}
	var actionJavaScriptURL$1 = escapeTextForBrowser$1("javascript:throw new Error('React form unexpectedly submitted.')");
	function pushAdditionalFormField$1(value, key) {
		this.push("<input type=\"hidden\"");
		validateAdditionalFormField$1(value);
		pushStringAttribute$1(this, "name", key);
		pushStringAttribute$1(this, "value", value);
		this.push("/>");
	}
	function validateAdditionalFormField$1(value) {
		if ("string" !== typeof value) throw Error("File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration.");
	}
	function getCustomFormFields$1(resumableState, formAction) {
		if ("function" === typeof formAction.$$FORM_ACTION) {
			var id = resumableState.nextFormID++;
			resumableState = resumableState.idPrefix + id;
			try {
				var customFields = formAction.$$FORM_ACTION(resumableState);
				if (customFields) customFields.data?.forEach(validateAdditionalFormField$1);
				return customFields;
			} catch (x) {
				if ("object" === typeof x && null !== x && "function" === typeof x.then) throw x;
			}
		}
		return null;
	}
	function pushFormActionAttribute$1(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name) {
		var formData = null;
		if ("function" === typeof formAction) {
			var customFields = getCustomFormFields$1(resumableState, formAction);
			null !== customFields ? (name = customFields.name, formAction = customFields.action || "", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(" ", "formAction", "=\"", actionJavaScriptURL$1, "\""), formTarget = formMethod = formEncType = formAction = name = null, injectFormReplayingRuntime$1(resumableState, renderState));
		}
		null != name && pushAttribute$1(target, "name", name);
		null != formAction && pushAttribute$1(target, "formAction", formAction);
		null != formEncType && pushAttribute$1(target, "formEncType", formEncType);
		null != formMethod && pushAttribute$1(target, "formMethod", formMethod);
		null != formTarget && pushAttribute$1(target, "formTarget", formTarget);
		return formData;
	}
	function pushAttribute$1(target, name, value) {
		switch (name) {
			case "className":
				pushStringAttribute$1(target, "class", value);
				break;
			case "tabIndex":
				pushStringAttribute$1(target, "tabindex", value);
				break;
			case "dir":
			case "role":
			case "viewBox":
			case "width":
			case "height":
				pushStringAttribute$1(target, name, value);
				break;
			case "style":
				pushStyleAttribute$1(target, value);
				break;
			case "src":
			case "href": if ("" === value) break;
			case "action":
			case "formAction":
				if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) break;
				value = sanitizeURL$1("" + value);
				target.push(" ", name, "=\"", escapeTextForBrowser$1(value), "\"");
				break;
			case "defaultValue":
			case "defaultChecked":
			case "innerHTML":
			case "suppressContentEditableWarning":
			case "suppressHydrationWarning":
			case "ref": break;
			case "autoFocus":
			case "multiple":
			case "muted":
				pushBooleanAttribute$1(target, name.toLowerCase(), value);
				break;
			case "xlinkHref":
				if ("function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) break;
				value = sanitizeURL$1("" + value);
				target.push(" ", "xlink:href", "=\"", escapeTextForBrowser$1(value), "\"");
				break;
			case "contentEditable":
			case "spellCheck":
			case "draggable":
			case "value":
			case "autoReverse":
			case "externalResourcesRequired":
			case "focusable":
			case "preserveAlpha":
				"function" !== typeof value && "symbol" !== typeof value && target.push(" ", name, "=\"", escapeTextForBrowser$1(value), "\"");
				break;
			case "inert":
			case "allowFullScreen":
			case "async":
			case "autoPlay":
			case "controls":
			case "default":
			case "defer":
			case "disabled":
			case "disablePictureInPicture":
			case "disableRemotePlayback":
			case "formNoValidate":
			case "hidden":
			case "loop":
			case "noModule":
			case "noValidate":
			case "open":
			case "playsInline":
			case "readOnly":
			case "required":
			case "reversed":
			case "scoped":
			case "seamless":
			case "itemScope":
				value && "function" !== typeof value && "symbol" !== typeof value && target.push(" ", name, "=\"\"");
				break;
			case "capture":
			case "download":
				!0 === value ? target.push(" ", name, "=\"\"") : !1 !== value && "function" !== typeof value && "symbol" !== typeof value && target.push(" ", name, "=\"", escapeTextForBrowser$1(value), "\"");
				break;
			case "cols":
			case "rows":
			case "size":
			case "span":
				"function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value && target.push(" ", name, "=\"", escapeTextForBrowser$1(value), "\"");
				break;
			case "rowSpan":
			case "start":
				"function" === typeof value || "symbol" === typeof value || isNaN(value) || target.push(" ", name, "=\"", escapeTextForBrowser$1(value), "\"");
				break;
			case "xlinkActuate":
				pushStringAttribute$1(target, "xlink:actuate", value);
				break;
			case "xlinkArcrole":
				pushStringAttribute$1(target, "xlink:arcrole", value);
				break;
			case "xlinkRole":
				pushStringAttribute$1(target, "xlink:role", value);
				break;
			case "xlinkShow":
				pushStringAttribute$1(target, "xlink:show", value);
				break;
			case "xlinkTitle":
				pushStringAttribute$1(target, "xlink:title", value);
				break;
			case "xlinkType":
				pushStringAttribute$1(target, "xlink:type", value);
				break;
			case "xmlBase":
				pushStringAttribute$1(target, "xml:base", value);
				break;
			case "xmlLang":
				pushStringAttribute$1(target, "xml:lang", value);
				break;
			case "xmlSpace":
				pushStringAttribute$1(target, "xml:space", value);
				break;
			default: if (!(2 < name.length) || "o" !== name[0] && "O" !== name[0] || "n" !== name[1] && "N" !== name[1]) {
				if (name = aliases$1.get(name) || name, isAttributeNameSafe$1(name)) {
					switch (typeof value) {
						case "function":
						case "symbol": return;
						case "boolean":
							var prefix$8 = name.toLowerCase().slice(0, 5);
							if ("data-" !== prefix$8 && "aria-" !== prefix$8) return;
					}
					target.push(" ", name, "=\"", escapeTextForBrowser$1(value), "\"");
				}
			}
		}
	}
	function pushInnerHTML$1(target, innerHTML, children) {
		if (null != innerHTML) {
			if (null != children) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
			if ("object" !== typeof innerHTML || !("__html" in innerHTML)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
			innerHTML = innerHTML.__html;
			null !== innerHTML && void 0 !== innerHTML && target.push("" + innerHTML);
		}
	}
	function flattenOptionChildren$1(children) {
		var content = "";
		React$2.Children.forEach(children, function(child) {
			null != child && (content += child);
		});
		return content;
	}
	function injectFormReplayingRuntime$1(resumableState, renderState) {
		if (0 === (resumableState.instructions & 16)) {
			resumableState.instructions |= 16;
			var preamble = renderState.preamble, bootstrapChunks = renderState.bootstrapChunks;
			(preamble.htmlChunks || preamble.headChunks) && 0 === bootstrapChunks.length ? (bootstrapChunks.push(renderState.startInlineScript), pushCompletedShellIdAttribute$1(bootstrapChunks, resumableState), bootstrapChunks.push(">", "addEventListener(\"submit\",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute(\"formAction\");null!=f&&(e=f,b=null)}\"javascript:throw new Error('React form unexpectedly submitted.')\"===e&&(a.preventDefault(),b?(a=document.createElement(\"input\"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});", "<\/script>")) : bootstrapChunks.unshift(renderState.startInlineScript, ">", "addEventListener(\"submit\",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute(\"formAction\");null!=f&&(e=f,b=null)}\"javascript:throw new Error('React form unexpectedly submitted.')\"===e&&(a.preventDefault(),b?(a=document.createElement(\"input\"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});", "<\/script>");
		}
	}
	function pushLinkImpl$1(target, props) {
		target.push(startChunkForTag$1("link"));
		for (var propKey in props) if (hasOwnProperty$1.call(props, propKey)) {
			var propValue = props[propKey];
			if (null != propValue) switch (propKey) {
				case "children":
				case "dangerouslySetInnerHTML": throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
				default: pushAttribute$1(target, propKey, propValue);
			}
		}
		target.push("/>");
		return null;
	}
	var styleRegex$1 = /(<\/|<)(s)(tyle)/gi;
	function styleReplacer$1(match, prefix$2, s$1, suffix$2) {
		return "" + prefix$2 + ("s" === s$1 ? "\\73 " : "\\53 ") + suffix$2;
	}
	function pushSelfClosing$1(target, props, tag) {
		target.push(startChunkForTag$1(tag));
		for (var propKey in props) if (hasOwnProperty$1.call(props, propKey)) {
			var propValue = props[propKey];
			if (null != propValue) switch (propKey) {
				case "children":
				case "dangerouslySetInnerHTML": throw Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
				default: pushAttribute$1(target, propKey, propValue);
			}
		}
		target.push("/>");
		return null;
	}
	function pushTitleImpl$1(target, props) {
		target.push(startChunkForTag$1("title"));
		var children = null, innerHTML = null, propKey;
		for (propKey in props) if (hasOwnProperty$1.call(props, propKey)) {
			var propValue = props[propKey];
			if (null != propValue) switch (propKey) {
				case "children":
					children = propValue;
					break;
				case "dangerouslySetInnerHTML":
					innerHTML = propValue;
					break;
				default: pushAttribute$1(target, propKey, propValue);
			}
		}
		target.push(">");
		props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;
		"function" !== typeof props && "symbol" !== typeof props && null !== props && void 0 !== props && target.push(escapeTextForBrowser$1("" + props));
		pushInnerHTML$1(target, innerHTML, children);
		target.push(endChunkForTag$1("title"));
		return null;
	}
	function pushScriptImpl$1(target, props) {
		target.push(startChunkForTag$1("script"));
		var children = null, innerHTML = null, propKey;
		for (propKey in props) if (hasOwnProperty$1.call(props, propKey)) {
			var propValue = props[propKey];
			if (null != propValue) switch (propKey) {
				case "children":
					children = propValue;
					break;
				case "dangerouslySetInnerHTML":
					innerHTML = propValue;
					break;
				default: pushAttribute$1(target, propKey, propValue);
			}
		}
		target.push(">");
		pushInnerHTML$1(target, innerHTML, children);
		"string" === typeof children && target.push(("" + children).replace(scriptRegex$1, scriptReplacer$1));
		target.push(endChunkForTag$1("script"));
		return null;
	}
	function pushStartSingletonElement$1(target, props, tag) {
		target.push(startChunkForTag$1(tag));
		var innerHTML = tag = null, propKey;
		for (propKey in props) if (hasOwnProperty$1.call(props, propKey)) {
			var propValue = props[propKey];
			if (null != propValue) switch (propKey) {
				case "children":
					tag = propValue;
					break;
				case "dangerouslySetInnerHTML":
					innerHTML = propValue;
					break;
				default: pushAttribute$1(target, propKey, propValue);
			}
		}
		target.push(">");
		pushInnerHTML$1(target, innerHTML, tag);
		return tag;
	}
	function pushStartGenericElement$1(target, props, tag) {
		target.push(startChunkForTag$1(tag));
		var innerHTML = tag = null, propKey;
		for (propKey in props) if (hasOwnProperty$1.call(props, propKey)) {
			var propValue = props[propKey];
			if (null != propValue) switch (propKey) {
				case "children":
					tag = propValue;
					break;
				case "dangerouslySetInnerHTML":
					innerHTML = propValue;
					break;
				default: pushAttribute$1(target, propKey, propValue);
			}
		}
		target.push(">");
		pushInnerHTML$1(target, innerHTML, tag);
		return "string" === typeof tag ? (target.push(escapeTextForBrowser$1(tag)), null) : tag;
	}
	var VALID_TAG_REGEX$1 = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache$1 = /* @__PURE__ */ new Map();
	function startChunkForTag$1(tag) {
		var tagStartChunk = validatedTagCache$1.get(tag);
		if (void 0 === tagStartChunk) {
			if (!VALID_TAG_REGEX$1.test(tag)) throw Error("Invalid tag: " + tag);
			tagStartChunk = "<" + tag;
			validatedTagCache$1.set(tag, tagStartChunk);
		}
		return tagStartChunk;
	}
	function pushStartInstance$1(target$jscomp$0, type, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded) {
		switch (type) {
			case "div":
			case "span":
			case "svg":
			case "path": break;
			case "a":
				target$jscomp$0.push(startChunkForTag$1("a"));
				var children = null, innerHTML = null, propKey;
				for (propKey in props) if (hasOwnProperty$1.call(props, propKey)) {
					var propValue = props[propKey];
					if (null != propValue) switch (propKey) {
						case "children":
							children = propValue;
							break;
						case "dangerouslySetInnerHTML":
							innerHTML = propValue;
							break;
						case "href":
							"" === propValue ? pushStringAttribute$1(target$jscomp$0, "href", "") : pushAttribute$1(target$jscomp$0, propKey, propValue);
							break;
						default: pushAttribute$1(target$jscomp$0, propKey, propValue);
					}
				}
				target$jscomp$0.push(">");
				pushInnerHTML$1(target$jscomp$0, innerHTML, children);
				if ("string" === typeof children) {
					target$jscomp$0.push(escapeTextForBrowser$1(children));
					var JSCompiler_inline_result = null;
				} else JSCompiler_inline_result = children;
				return JSCompiler_inline_result;
			case "g":
			case "p":
			case "li": break;
			case "select":
				target$jscomp$0.push(startChunkForTag$1("select"));
				var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;
				for (propKey$jscomp$0 in props) if (hasOwnProperty$1.call(props, propKey$jscomp$0)) {
					var propValue$jscomp$0 = props[propKey$jscomp$0];
					if (null != propValue$jscomp$0) switch (propKey$jscomp$0) {
						case "children":
							children$jscomp$0 = propValue$jscomp$0;
							break;
						case "dangerouslySetInnerHTML":
							innerHTML$jscomp$0 = propValue$jscomp$0;
							break;
						case "defaultValue":
						case "value": break;
						default: pushAttribute$1(target$jscomp$0, propKey$jscomp$0, propValue$jscomp$0);
					}
				}
				target$jscomp$0.push(">");
				pushInnerHTML$1(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);
				return children$jscomp$0;
			case "option":
				var selectedValue = formatContext.selectedValue;
				target$jscomp$0.push(startChunkForTag$1("option"));
				var children$jscomp$1 = null, value = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;
				for (propKey$jscomp$1 in props) if (hasOwnProperty$1.call(props, propKey$jscomp$1)) {
					var propValue$jscomp$1 = props[propKey$jscomp$1];
					if (null != propValue$jscomp$1) switch (propKey$jscomp$1) {
						case "children":
							children$jscomp$1 = propValue$jscomp$1;
							break;
						case "selected":
							selected = propValue$jscomp$1;
							break;
						case "dangerouslySetInnerHTML":
							innerHTML$jscomp$1 = propValue$jscomp$1;
							break;
						case "value": value = propValue$jscomp$1;
						default: pushAttribute$1(target$jscomp$0, propKey$jscomp$1, propValue$jscomp$1);
					}
				}
				if (null != selectedValue) {
					var stringValue = null !== value ? "" + value : flattenOptionChildren$1(children$jscomp$1);
					if (isArrayImpl$1(selectedValue)) {
						for (var i = 0; i < selectedValue.length; i++) if ("" + selectedValue[i] === stringValue) {
							target$jscomp$0.push(" selected=\"\"");
							break;
						}
					} else "" + selectedValue === stringValue && target$jscomp$0.push(" selected=\"\"");
				} else selected && target$jscomp$0.push(" selected=\"\"");
				target$jscomp$0.push(">");
				pushInnerHTML$1(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);
				return children$jscomp$1;
			case "textarea":
				target$jscomp$0.push(startChunkForTag$1("textarea"));
				var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;
				for (propKey$jscomp$2 in props) if (hasOwnProperty$1.call(props, propKey$jscomp$2)) {
					var propValue$jscomp$2 = props[propKey$jscomp$2];
					if (null != propValue$jscomp$2) switch (propKey$jscomp$2) {
						case "children":
							children$jscomp$2 = propValue$jscomp$2;
							break;
						case "value":
							value$jscomp$0 = propValue$jscomp$2;
							break;
						case "defaultValue":
							defaultValue = propValue$jscomp$2;
							break;
						case "dangerouslySetInnerHTML": throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
						default: pushAttribute$1(target$jscomp$0, propKey$jscomp$2, propValue$jscomp$2);
					}
				}
				null === value$jscomp$0 && null !== defaultValue && (value$jscomp$0 = defaultValue);
				target$jscomp$0.push(">");
				if (null != children$jscomp$2) {
					if (null != value$jscomp$0) throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
					if (isArrayImpl$1(children$jscomp$2)) {
						if (1 < children$jscomp$2.length) throw Error("<textarea> can only have at most one child.");
						value$jscomp$0 = "" + children$jscomp$2[0];
					}
					value$jscomp$0 = "" + children$jscomp$2;
				}
				"string" === typeof value$jscomp$0 && "\n" === value$jscomp$0[0] && target$jscomp$0.push("\n");
				null !== value$jscomp$0 && target$jscomp$0.push(escapeTextForBrowser$1("" + value$jscomp$0));
				return null;
			case "input":
				target$jscomp$0.push(startChunkForTag$1("input"));
				var name = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;
				for (propKey$jscomp$3 in props) if (hasOwnProperty$1.call(props, propKey$jscomp$3)) {
					var propValue$jscomp$3 = props[propKey$jscomp$3];
					if (null != propValue$jscomp$3) switch (propKey$jscomp$3) {
						case "children":
						case "dangerouslySetInnerHTML": throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
						case "name":
							name = propValue$jscomp$3;
							break;
						case "formAction":
							formAction = propValue$jscomp$3;
							break;
						case "formEncType":
							formEncType = propValue$jscomp$3;
							break;
						case "formMethod":
							formMethod = propValue$jscomp$3;
							break;
						case "formTarget":
							formTarget = propValue$jscomp$3;
							break;
						case "defaultChecked":
							defaultChecked = propValue$jscomp$3;
							break;
						case "defaultValue":
							defaultValue$jscomp$0 = propValue$jscomp$3;
							break;
						case "checked":
							checked = propValue$jscomp$3;
							break;
						case "value":
							value$jscomp$1 = propValue$jscomp$3;
							break;
						default: pushAttribute$1(target$jscomp$0, propKey$jscomp$3, propValue$jscomp$3);
					}
				}
				var formData = pushFormActionAttribute$1(target$jscomp$0, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name);
				null !== checked ? pushBooleanAttribute$1(target$jscomp$0, "checked", checked) : null !== defaultChecked && pushBooleanAttribute$1(target$jscomp$0, "checked", defaultChecked);
				null !== value$jscomp$1 ? pushAttribute$1(target$jscomp$0, "value", value$jscomp$1) : null !== defaultValue$jscomp$0 && pushAttribute$1(target$jscomp$0, "value", defaultValue$jscomp$0);
				target$jscomp$0.push("/>");
				formData?.forEach(pushAdditionalFormField$1, target$jscomp$0);
				return null;
			case "button":
				target$jscomp$0.push(startChunkForTag$1("button"));
				var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;
				for (propKey$jscomp$4 in props) if (hasOwnProperty$1.call(props, propKey$jscomp$4)) {
					var propValue$jscomp$4 = props[propKey$jscomp$4];
					if (null != propValue$jscomp$4) switch (propKey$jscomp$4) {
						case "children":
							children$jscomp$3 = propValue$jscomp$4;
							break;
						case "dangerouslySetInnerHTML":
							innerHTML$jscomp$2 = propValue$jscomp$4;
							break;
						case "name":
							name$jscomp$0 = propValue$jscomp$4;
							break;
						case "formAction":
							formAction$jscomp$0 = propValue$jscomp$4;
							break;
						case "formEncType":
							formEncType$jscomp$0 = propValue$jscomp$4;
							break;
						case "formMethod":
							formMethod$jscomp$0 = propValue$jscomp$4;
							break;
						case "formTarget":
							formTarget$jscomp$0 = propValue$jscomp$4;
							break;
						default: pushAttribute$1(target$jscomp$0, propKey$jscomp$4, propValue$jscomp$4);
					}
				}
				var formData$jscomp$0 = pushFormActionAttribute$1(target$jscomp$0, resumableState, renderState, formAction$jscomp$0, formEncType$jscomp$0, formMethod$jscomp$0, formTarget$jscomp$0, name$jscomp$0);
				target$jscomp$0.push(">");
				formData$jscomp$0?.forEach(pushAdditionalFormField$1, target$jscomp$0);
				pushInnerHTML$1(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);
				if ("string" === typeof children$jscomp$3) {
					target$jscomp$0.push(escapeTextForBrowser$1(children$jscomp$3));
					var JSCompiler_inline_result$jscomp$0 = null;
				} else JSCompiler_inline_result$jscomp$0 = children$jscomp$3;
				return JSCompiler_inline_result$jscomp$0;
			case "form":
				target$jscomp$0.push(startChunkForTag$1("form"));
				var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;
				for (propKey$jscomp$5 in props) if (hasOwnProperty$1.call(props, propKey$jscomp$5)) {
					var propValue$jscomp$5 = props[propKey$jscomp$5];
					if (null != propValue$jscomp$5) switch (propKey$jscomp$5) {
						case "children":
							children$jscomp$4 = propValue$jscomp$5;
							break;
						case "dangerouslySetInnerHTML":
							innerHTML$jscomp$3 = propValue$jscomp$5;
							break;
						case "action":
							formAction$jscomp$1 = propValue$jscomp$5;
							break;
						case "encType":
							formEncType$jscomp$1 = propValue$jscomp$5;
							break;
						case "method":
							formMethod$jscomp$1 = propValue$jscomp$5;
							break;
						case "target":
							formTarget$jscomp$1 = propValue$jscomp$5;
							break;
						default: pushAttribute$1(target$jscomp$0, propKey$jscomp$5, propValue$jscomp$5);
					}
				}
				var formData$jscomp$1 = null, formActionName = null;
				if ("function" === typeof formAction$jscomp$1) {
					var customFields = getCustomFormFields$1(resumableState, formAction$jscomp$1);
					null !== customFields ? (formAction$jscomp$1 = customFields.action || "", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(" ", "action", "=\"", actionJavaScriptURL$1, "\""), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime$1(resumableState, renderState));
				}
				null != formAction$jscomp$1 && pushAttribute$1(target$jscomp$0, "action", formAction$jscomp$1);
				null != formEncType$jscomp$1 && pushAttribute$1(target$jscomp$0, "encType", formEncType$jscomp$1);
				null != formMethod$jscomp$1 && pushAttribute$1(target$jscomp$0, "method", formMethod$jscomp$1);
				null != formTarget$jscomp$1 && pushAttribute$1(target$jscomp$0, "target", formTarget$jscomp$1);
				target$jscomp$0.push(">");
				null !== formActionName && (target$jscomp$0.push("<input type=\"hidden\""), pushStringAttribute$1(target$jscomp$0, "name", formActionName), target$jscomp$0.push("/>"), formData$jscomp$1?.forEach(pushAdditionalFormField$1, target$jscomp$0));
				pushInnerHTML$1(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);
				if ("string" === typeof children$jscomp$4) {
					target$jscomp$0.push(escapeTextForBrowser$1(children$jscomp$4));
					var JSCompiler_inline_result$jscomp$1 = null;
				} else JSCompiler_inline_result$jscomp$1 = children$jscomp$4;
				return JSCompiler_inline_result$jscomp$1;
			case "menuitem":
				target$jscomp$0.push(startChunkForTag$1("menuitem"));
				for (var propKey$jscomp$6 in props) if (hasOwnProperty$1.call(props, propKey$jscomp$6)) {
					var propValue$jscomp$6 = props[propKey$jscomp$6];
					if (null != propValue$jscomp$6) switch (propKey$jscomp$6) {
						case "children":
						case "dangerouslySetInnerHTML": throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
						default: pushAttribute$1(target$jscomp$0, propKey$jscomp$6, propValue$jscomp$6);
					}
				}
				target$jscomp$0.push(">");
				return null;
			case "object":
				target$jscomp$0.push(startChunkForTag$1("object"));
				var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;
				for (propKey$jscomp$7 in props) if (hasOwnProperty$1.call(props, propKey$jscomp$7)) {
					var propValue$jscomp$7 = props[propKey$jscomp$7];
					if (null != propValue$jscomp$7) switch (propKey$jscomp$7) {
						case "children":
							children$jscomp$5 = propValue$jscomp$7;
							break;
						case "dangerouslySetInnerHTML":
							innerHTML$jscomp$4 = propValue$jscomp$7;
							break;
						case "data":
							var sanitizedValue = sanitizeURL$1("" + propValue$jscomp$7);
							if ("" === sanitizedValue) break;
							target$jscomp$0.push(" ", "data", "=\"", escapeTextForBrowser$1(sanitizedValue), "\"");
							break;
						default: pushAttribute$1(target$jscomp$0, propKey$jscomp$7, propValue$jscomp$7);
					}
				}
				target$jscomp$0.push(">");
				pushInnerHTML$1(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);
				if ("string" === typeof children$jscomp$5) {
					target$jscomp$0.push(escapeTextForBrowser$1(children$jscomp$5));
					var JSCompiler_inline_result$jscomp$2 = null;
				} else JSCompiler_inline_result$jscomp$2 = children$jscomp$5;
				return JSCompiler_inline_result$jscomp$2;
			case "title":
				var noscriptTagInScope = formatContext.tagScope & 1, isFallback = formatContext.tagScope & 4;
				if (4 === formatContext.insertionMode || noscriptTagInScope || null != props.itemProp) var JSCompiler_inline_result$jscomp$3 = pushTitleImpl$1(target$jscomp$0, props);
				else isFallback ? JSCompiler_inline_result$jscomp$3 = null : (pushTitleImpl$1(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$3 = void 0);
				return JSCompiler_inline_result$jscomp$3;
			case "link":
				var noscriptTagInScope$jscomp$0 = formatContext.tagScope & 1, isFallback$jscomp$0 = formatContext.tagScope & 4, rel = props.rel, href = props.href, precedence = props.precedence;
				if (4 === formatContext.insertionMode || noscriptTagInScope$jscomp$0 || null != props.itemProp || "string" !== typeof rel || "string" !== typeof href || "" === href) {
					pushLinkImpl$1(target$jscomp$0, props);
					var JSCompiler_inline_result$jscomp$4 = null;
				} else if ("stylesheet" === props.rel) if ("string" !== typeof precedence || null != props.disabled || props.onLoad || props.onError) JSCompiler_inline_result$jscomp$4 = pushLinkImpl$1(target$jscomp$0, props);
				else {
					var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
					if (null !== resourceState) {
						resumableState.styleResources[href] = null;
						styleQueue || (styleQueue = {
							precedence: escapeTextForBrowser$1(precedence),
							rules: [],
							hrefs: [],
							sheets: /* @__PURE__ */ new Map()
						}, renderState.styles.set(precedence, styleQueue));
						var resource = {
							state: 0,
							props: assign$1({}, props, {
								"data-precedence": props.precedence,
								precedence: null
							})
						};
						if (resourceState) {
							2 === resourceState.length && adoptPreloadCredentials$1(resource.props, resourceState);
							var preloadResource = renderState.preloads.stylesheets.get(href);
							preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = 1;
						}
						styleQueue.sheets.set(href, resource);
						hoistableState && hoistableState.stylesheets.add(resource);
					} else if (styleQueue) {
						var resource$9 = styleQueue.sheets.get(href);
						resource$9 && hoistableState && hoistableState.stylesheets.add(resource$9);
					}
					textEmbedded && target$jscomp$0.push("<!-- -->");
					JSCompiler_inline_result$jscomp$4 = null;
				}
				else props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$4 = pushLinkImpl$1(target$jscomp$0, props) : (textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$4 = isFallback$jscomp$0 ? null : pushLinkImpl$1(renderState.hoistableChunks, props));
				return JSCompiler_inline_result$jscomp$4;
			case "script":
				var noscriptTagInScope$jscomp$1 = formatContext.tagScope & 1, asyncProp = props.async;
				if ("string" !== typeof props.src || !props.src || !asyncProp || "function" === typeof asyncProp || "symbol" === typeof asyncProp || props.onLoad || props.onError || 4 === formatContext.insertionMode || noscriptTagInScope$jscomp$1 || null != props.itemProp) var JSCompiler_inline_result$jscomp$5 = pushScriptImpl$1(target$jscomp$0, props);
				else {
					var key = props.src;
					if ("module" === props.type) {
						var resources = resumableState.moduleScriptResources;
						var preloads = renderState.preloads.moduleScripts;
					} else resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;
					var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : void 0;
					if (null !== resourceState$jscomp$0) {
						resources[key] = null;
						var scriptProps = props;
						if (resourceState$jscomp$0) {
							2 === resourceState$jscomp$0.length && (scriptProps = assign$1({}, props), adoptPreloadCredentials$1(scriptProps, resourceState$jscomp$0));
							var preloadResource$jscomp$0 = preloads.get(key);
							preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);
						}
						var resource$jscomp$0 = [];
						renderState.scripts.add(resource$jscomp$0);
						pushScriptImpl$1(resource$jscomp$0, scriptProps);
					}
					textEmbedded && target$jscomp$0.push("<!-- -->");
					JSCompiler_inline_result$jscomp$5 = null;
				}
				return JSCompiler_inline_result$jscomp$5;
			case "style":
				var noscriptTagInScope$jscomp$2 = formatContext.tagScope & 1, precedence$jscomp$0 = props.precedence, href$jscomp$0 = props.href, nonce = props.nonce;
				if (4 === formatContext.insertionMode || noscriptTagInScope$jscomp$2 || null != props.itemProp || "string" !== typeof precedence$jscomp$0 || "string" !== typeof href$jscomp$0 || "" === href$jscomp$0) {
					target$jscomp$0.push(startChunkForTag$1("style"));
					var children$jscomp$6 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;
					for (propKey$jscomp$8 in props) if (hasOwnProperty$1.call(props, propKey$jscomp$8)) {
						var propValue$jscomp$8 = props[propKey$jscomp$8];
						if (null != propValue$jscomp$8) switch (propKey$jscomp$8) {
							case "children":
								children$jscomp$6 = propValue$jscomp$8;
								break;
							case "dangerouslySetInnerHTML":
								innerHTML$jscomp$5 = propValue$jscomp$8;
								break;
							default: pushAttribute$1(target$jscomp$0, propKey$jscomp$8, propValue$jscomp$8);
						}
					}
					target$jscomp$0.push(">");
					var child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;
					"function" !== typeof child && "symbol" !== typeof child && null !== child && void 0 !== child && target$jscomp$0.push(("" + child).replace(styleRegex$1, styleReplacer$1));
					pushInnerHTML$1(target$jscomp$0, innerHTML$jscomp$5, children$jscomp$6);
					target$jscomp$0.push(endChunkForTag$1("style"));
					var JSCompiler_inline_result$jscomp$6 = null;
				} else {
					var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0);
					if (null !== (resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : void 0)) {
						resumableState.styleResources[href$jscomp$0] = null;
						styleQueue$jscomp$0 || (styleQueue$jscomp$0 = {
							precedence: escapeTextForBrowser$1(precedence$jscomp$0),
							rules: [],
							hrefs: [],
							sheets: /* @__PURE__ */ new Map()
						}, renderState.styles.set(precedence$jscomp$0, styleQueue$jscomp$0));
						var nonceStyle = renderState.nonce.style;
						if (!nonceStyle || nonceStyle === nonce) {
							styleQueue$jscomp$0.hrefs.push(escapeTextForBrowser$1(href$jscomp$0));
							var target = styleQueue$jscomp$0.rules, children$jscomp$7 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;
							for (propKey$jscomp$9 in props) if (hasOwnProperty$1.call(props, propKey$jscomp$9)) {
								var propValue$jscomp$9 = props[propKey$jscomp$9];
								if (null != propValue$jscomp$9) switch (propKey$jscomp$9) {
									case "children":
										children$jscomp$7 = propValue$jscomp$9;
										break;
									case "dangerouslySetInnerHTML": innerHTML$jscomp$6 = propValue$jscomp$9;
								}
							}
							var child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;
							"function" !== typeof child$jscomp$0 && "symbol" !== typeof child$jscomp$0 && null !== child$jscomp$0 && void 0 !== child$jscomp$0 && target.push(("" + child$jscomp$0).replace(styleRegex$1, styleReplacer$1));
							pushInnerHTML$1(target, innerHTML$jscomp$6, children$jscomp$7);
						}
					}
					styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);
					textEmbedded && target$jscomp$0.push("<!-- -->");
					JSCompiler_inline_result$jscomp$6 = void 0;
				}
				return JSCompiler_inline_result$jscomp$6;
			case "meta":
				var noscriptTagInScope$jscomp$3 = formatContext.tagScope & 1, isFallback$jscomp$1 = formatContext.tagScope & 4;
				if (4 === formatContext.insertionMode || noscriptTagInScope$jscomp$3 || null != props.itemProp) var JSCompiler_inline_result$jscomp$7 = pushSelfClosing$1(target$jscomp$0, props, "meta");
				else textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$7 = isFallback$jscomp$1 ? null : "string" === typeof props.charSet ? pushSelfClosing$1(renderState.charsetChunks, props, "meta") : "viewport" === props.name ? pushSelfClosing$1(renderState.viewportChunks, props, "meta") : pushSelfClosing$1(renderState.hoistableChunks, props, "meta");
				return JSCompiler_inline_result$jscomp$7;
			case "listing":
			case "pre":
				target$jscomp$0.push(startChunkForTag$1(type));
				var children$jscomp$8 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;
				for (propKey$jscomp$10 in props) if (hasOwnProperty$1.call(props, propKey$jscomp$10)) {
					var propValue$jscomp$10 = props[propKey$jscomp$10];
					if (null != propValue$jscomp$10) switch (propKey$jscomp$10) {
						case "children":
							children$jscomp$8 = propValue$jscomp$10;
							break;
						case "dangerouslySetInnerHTML":
							innerHTML$jscomp$7 = propValue$jscomp$10;
							break;
						default: pushAttribute$1(target$jscomp$0, propKey$jscomp$10, propValue$jscomp$10);
					}
				}
				target$jscomp$0.push(">");
				if (null != innerHTML$jscomp$7) {
					if (null != children$jscomp$8) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
					if ("object" !== typeof innerHTML$jscomp$7 || !("__html" in innerHTML$jscomp$7)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
					var html = innerHTML$jscomp$7.__html;
					null !== html && void 0 !== html && ("string" === typeof html && 0 < html.length && "\n" === html[0] ? target$jscomp$0.push("\n", html) : target$jscomp$0.push("" + html));
				}
				"string" === typeof children$jscomp$8 && "\n" === children$jscomp$8[0] && target$jscomp$0.push("\n");
				return children$jscomp$8;
			case "img":
				var pictureOrNoScriptTagInScope = formatContext.tagScope & 3, src = props.src, srcSet = props.srcSet;
				if (!("lazy" === props.loading || !src && !srcSet || "string" !== typeof src && null != src || "string" !== typeof srcSet && null != srcSet || "low" === props.fetchPriority || pictureOrNoScriptTagInScope) && ("string" !== typeof src || ":" !== src[4] || "d" !== src[0] && "D" !== src[0] || "a" !== src[1] && "A" !== src[1] || "t" !== src[2] && "T" !== src[2] || "a" !== src[3] && "A" !== src[3]) && ("string" !== typeof srcSet || ":" !== srcSet[4] || "d" !== srcSet[0] && "D" !== srcSet[0] || "a" !== srcSet[1] && "A" !== srcSet[1] || "t" !== srcSet[2] && "T" !== srcSet[2] || "a" !== srcSet[3] && "A" !== srcSet[3])) {
					null !== hoistableState && formatContext.tagScope & 64 && (hoistableState.suspenseyImages = !0);
					var sizes = "string" === typeof props.sizes ? props.sizes : void 0, key$jscomp$0 = srcSet ? srcSet + "\n" + (sizes || "") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);
					if (resource$jscomp$1) {
						if ("high" === props.fetchPriority || 10 > renderState.highImagePreloads.size) promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);
					} else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {
						resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS$1;
						var input = props.crossOrigin;
						var JSCompiler_inline_result$jscomp$8 = "string" === typeof input ? "use-credentials" === input ? input : "" : void 0;
						var headers = renderState.headers, header;
						headers && 0 < headers.remainingCapacity && "string" !== typeof props.srcSet && ("high" === props.fetchPriority || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader$1(src, "image", {
							imageSrcSet: props.srcSet,
							imageSizes: props.sizes,
							crossOrigin: JSCompiler_inline_result$jscomp$8,
							integrity: props.integrity,
							nonce: props.nonce,
							type: props.type,
							fetchPriority: props.fetchPriority,
							referrerPolicy: props.refererPolicy
						}), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS$1, headers.highImagePreloads && (headers.highImagePreloads += ", "), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl$1(resource$jscomp$1, {
							rel: "preload",
							as: "image",
							href: srcSet ? void 0 : src,
							imageSrcSet: srcSet,
							imageSizes: sizes,
							crossOrigin: JSCompiler_inline_result$jscomp$8,
							integrity: props.integrity,
							type: props.type,
							fetchPriority: props.fetchPriority,
							referrerPolicy: props.referrerPolicy
						}), "high" === props.fetchPriority || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));
					}
				}
				return pushSelfClosing$1(target$jscomp$0, props, "img");
			case "base":
			case "area":
			case "br":
			case "col":
			case "embed":
			case "hr":
			case "keygen":
			case "param":
			case "source":
			case "track":
			case "wbr": return pushSelfClosing$1(target$jscomp$0, props, type);
			case "annotation-xml":
			case "color-profile":
			case "font-face":
			case "font-face-src":
			case "font-face-uri":
			case "font-face-format":
			case "font-face-name":
			case "missing-glyph": break;
			case "head":
				if (2 > formatContext.insertionMode) {
					var preamble = preambleState || renderState.preamble;
					if (preamble.headChunks) throw Error("The `<head>` tag may only be rendered once.");
					null !== preambleState && target$jscomp$0.push("<!--head-->");
					preamble.headChunks = [];
					var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement$1(preamble.headChunks, props, "head");
				} else JSCompiler_inline_result$jscomp$9 = pushStartGenericElement$1(target$jscomp$0, props, "head");
				return JSCompiler_inline_result$jscomp$9;
			case "body":
				if (2 > formatContext.insertionMode) {
					var preamble$jscomp$0 = preambleState || renderState.preamble;
					if (preamble$jscomp$0.bodyChunks) throw Error("The `<body>` tag may only be rendered once.");
					null !== preambleState && target$jscomp$0.push("<!--body-->");
					preamble$jscomp$0.bodyChunks = [];
					var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement$1(preamble$jscomp$0.bodyChunks, props, "body");
				} else JSCompiler_inline_result$jscomp$10 = pushStartGenericElement$1(target$jscomp$0, props, "body");
				return JSCompiler_inline_result$jscomp$10;
			case "html":
				if (0 === formatContext.insertionMode) {
					var preamble$jscomp$1 = preambleState || renderState.preamble;
					if (preamble$jscomp$1.htmlChunks) throw Error("The `<html>` tag may only be rendered once.");
					null !== preambleState && target$jscomp$0.push("<!--html-->");
					preamble$jscomp$1.htmlChunks = [""];
					var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement$1(preamble$jscomp$1.htmlChunks, props, "html");
				} else JSCompiler_inline_result$jscomp$11 = pushStartGenericElement$1(target$jscomp$0, props, "html");
				return JSCompiler_inline_result$jscomp$11;
			default: if (-1 !== type.indexOf("-")) {
				target$jscomp$0.push(startChunkForTag$1(type));
				var children$jscomp$9 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;
				for (propKey$jscomp$11 in props) if (hasOwnProperty$1.call(props, propKey$jscomp$11)) {
					var propValue$jscomp$11 = props[propKey$jscomp$11];
					if (null != propValue$jscomp$11) {
						var attributeName = propKey$jscomp$11;
						switch (propKey$jscomp$11) {
							case "children":
								children$jscomp$9 = propValue$jscomp$11;
								break;
							case "dangerouslySetInnerHTML":
								innerHTML$jscomp$8 = propValue$jscomp$11;
								break;
							case "style":
								pushStyleAttribute$1(target$jscomp$0, propValue$jscomp$11);
								break;
							case "suppressContentEditableWarning":
							case "suppressHydrationWarning":
							case "ref": break;
							case "className": attributeName = "class";
							default: if (isAttributeNameSafe$1(propKey$jscomp$11) && "function" !== typeof propValue$jscomp$11 && "symbol" !== typeof propValue$jscomp$11 && !1 !== propValue$jscomp$11) {
								if (!0 === propValue$jscomp$11) propValue$jscomp$11 = "";
								else if ("object" === typeof propValue$jscomp$11) continue;
								target$jscomp$0.push(" ", attributeName, "=\"", escapeTextForBrowser$1(propValue$jscomp$11), "\"");
							}
						}
					}
				}
				target$jscomp$0.push(">");
				pushInnerHTML$1(target$jscomp$0, innerHTML$jscomp$8, children$jscomp$9);
				return children$jscomp$9;
			}
		}
		return pushStartGenericElement$1(target$jscomp$0, props, type);
	}
	var endTagCache$1 = /* @__PURE__ */ new Map();
	function endChunkForTag$1(tag) {
		var chunk = endTagCache$1.get(tag);
		void 0 === chunk && (chunk = "</" + tag + ">", endTagCache$1.set(tag, chunk));
		return chunk;
	}
	function hoistPreambleState$1(renderState, preambleState) {
		renderState = renderState.preamble;
		null === renderState.htmlChunks && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks);
		null === renderState.headChunks && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks);
		null === renderState.bodyChunks && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks);
	}
	function writeBootstrap$1(destination, renderState) {
		renderState = renderState.bootstrapChunks;
		for (var i = 0; i < renderState.length - 1; i++) destination.push(renderState[i]);
		return i < renderState.length ? (i = renderState[i], renderState.length = 0, destination.push(i)) : !0;
	}
	function writeStartPendingSuspenseBoundary$1(destination, renderState, id) {
		destination.push("<!--$?--><template id=\"");
		if (null === id) throw Error("An ID must have been assigned before we can complete the boundary.");
		destination.push(renderState.boundaryPrefix);
		renderState = id.toString(16);
		destination.push(renderState);
		return destination.push("\"></template>");
	}
	function writeStartSegment$1(destination, renderState, formatContext, id) {
		switch (formatContext.insertionMode) {
			case 0:
			case 1:
			case 3:
			case 2: return destination.push("<div hidden id=\""), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push("\">");
			case 4: return destination.push("<svg aria-hidden=\"true\" style=\"display:none\" id=\""), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push("\">");
			case 5: return destination.push("<math aria-hidden=\"true\" style=\"display:none\" id=\""), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push("\">");
			case 6: return destination.push("<table hidden id=\""), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push("\">");
			case 7: return destination.push("<table hidden><tbody id=\""), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push("\">");
			case 8: return destination.push("<table hidden><tr id=\""), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push("\">");
			case 9: return destination.push("<table hidden><colgroup id=\""), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push("\">");
			default: throw Error("Unknown insertion mode. This is a bug in React.");
		}
	}
	function writeEndSegment$1(destination, formatContext) {
		switch (formatContext.insertionMode) {
			case 0:
			case 1:
			case 3:
			case 2: return destination.push("</div>");
			case 4: return destination.push("</svg>");
			case 5: return destination.push("</math>");
			case 6: return destination.push("</table>");
			case 7: return destination.push("</tbody></table>");
			case 8: return destination.push("</tr></table>");
			case 9: return destination.push("</colgroup></table>");
			default: throw Error("Unknown insertion mode. This is a bug in React.");
		}
	}
	var regexForJSStringsInInstructionScripts$1 = /[<\u2028\u2029]/g;
	function escapeJSStringsForInstructionScripts$1(input) {
		return JSON.stringify(input).replace(regexForJSStringsInInstructionScripts$1, function(match) {
			switch (match) {
				case "<": return "\\u003c";
				case "\u2028": return "\\u2028";
				case "\u2029": return "\\u2029";
				default: throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
			}
		});
	}
	var regexForJSStringsInScripts$1 = /[&><\u2028\u2029]/g;
	function escapeJSObjectForInstructionScripts$1(input) {
		return JSON.stringify(input).replace(regexForJSStringsInScripts$1, function(match) {
			switch (match) {
				case "&": return "\\u0026";
				case ">": return "\\u003e";
				case "<": return "\\u003c";
				case "\u2028": return "\\u2028";
				case "\u2029": return "\\u2029";
				default: throw Error("escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
			}
		});
	}
	var currentlyRenderingBoundaryHasStylesToHoist$1 = !1, destinationHasCapacity$2 = !0;
	function flushStyleTagsLateForBoundary$1(styleQueue) {
		var rules = styleQueue.rules, hrefs = styleQueue.hrefs, i = 0;
		if (hrefs.length) {
			this.push(currentlyFlushingRenderState$1.startInlineStyle);
			this.push(" media=\"not all\" data-precedence=\"");
			this.push(styleQueue.precedence);
			for (this.push("\" data-href=\""); i < hrefs.length - 1; i++) this.push(hrefs[i]), this.push(" ");
			this.push(hrefs[i]);
			this.push("\">");
			for (i = 0; i < rules.length; i++) this.push(rules[i]);
			destinationHasCapacity$2 = this.push("</style>");
			currentlyRenderingBoundaryHasStylesToHoist$1 = !0;
			rules.length = 0;
			hrefs.length = 0;
		}
	}
	function hasStylesToHoist$1(stylesheet) {
		return 2 !== stylesheet.state ? currentlyRenderingBoundaryHasStylesToHoist$1 = !0 : !1;
	}
	function writeHoistablesForBoundary$1(destination, hoistableState, renderState) {
		currentlyRenderingBoundaryHasStylesToHoist$1 = !1;
		destinationHasCapacity$2 = !0;
		currentlyFlushingRenderState$1 = renderState;
		hoistableState.styles.forEach(flushStyleTagsLateForBoundary$1, destination);
		currentlyFlushingRenderState$1 = null;
		hoistableState.stylesheets.forEach(hasStylesToHoist$1);
		currentlyRenderingBoundaryHasStylesToHoist$1 && (renderState.stylesToHoist = !0);
		return destinationHasCapacity$2;
	}
	function flushResource$1(resource) {
		for (var i = 0; i < resource.length; i++) this.push(resource[i]);
		resource.length = 0;
	}
	var stylesheetFlushingQueue$1 = [];
	function flushStyleInPreamble$1(stylesheet) {
		pushLinkImpl$1(stylesheetFlushingQueue$1, stylesheet.props);
		for (var i = 0; i < stylesheetFlushingQueue$1.length; i++) this.push(stylesheetFlushingQueue$1[i]);
		stylesheetFlushingQueue$1.length = 0;
		stylesheet.state = 2;
	}
	function flushStylesInPreamble$1(styleQueue) {
		var hasStylesheets = 0 < styleQueue.sheets.size;
		styleQueue.sheets.forEach(flushStyleInPreamble$1, this);
		styleQueue.sheets.clear();
		var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
		if (!hasStylesheets || hrefs.length) {
			this.push(currentlyFlushingRenderState$1.startInlineStyle);
			this.push(" data-precedence=\"");
			this.push(styleQueue.precedence);
			styleQueue = 0;
			if (hrefs.length) {
				for (this.push("\" data-href=\""); styleQueue < hrefs.length - 1; styleQueue++) this.push(hrefs[styleQueue]), this.push(" ");
				this.push(hrefs[styleQueue]);
			}
			this.push("\">");
			for (styleQueue = 0; styleQueue < rules.length; styleQueue++) this.push(rules[styleQueue]);
			this.push("</style>");
			rules.length = 0;
			hrefs.length = 0;
		}
	}
	function preloadLateStyle$1(stylesheet) {
		if (0 === stylesheet.state) {
			stylesheet.state = 1;
			var props = stylesheet.props;
			pushLinkImpl$1(stylesheetFlushingQueue$1, {
				rel: "preload",
				as: "style",
				href: stylesheet.props.href,
				crossOrigin: props.crossOrigin,
				fetchPriority: props.fetchPriority,
				integrity: props.integrity,
				media: props.media,
				hrefLang: props.hrefLang,
				referrerPolicy: props.referrerPolicy
			});
			for (stylesheet = 0; stylesheet < stylesheetFlushingQueue$1.length; stylesheet++) this.push(stylesheetFlushingQueue$1[stylesheet]);
			stylesheetFlushingQueue$1.length = 0;
		}
	}
	function preloadLateStyles$1(styleQueue) {
		styleQueue.sheets.forEach(preloadLateStyle$1, this);
		styleQueue.sheets.clear();
	}
	function pushCompletedShellIdAttribute$1(target, resumableState) {
		0 === (resumableState.instructions & 32) && (resumableState.instructions |= 32, target.push(" id=\"", escapeTextForBrowser$1("_" + resumableState.idPrefix + "R_"), "\""));
	}
	function writeStyleResourceDependenciesInJS$1(destination, hoistableState) {
		destination.push("[");
		var nextArrayOpenBrackChunk = "[";
		hoistableState.stylesheets.forEach(function(resource) {
			if (2 !== resource.state) if (3 === resource.state) destination.push(nextArrayOpenBrackChunk), resource = escapeJSObjectForInstructionScripts$1("" + resource.props.href), destination.push(resource), destination.push("]"), nextArrayOpenBrackChunk = ",[";
			else {
				destination.push(nextArrayOpenBrackChunk);
				var precedence = resource.props["data-precedence"], props = resource.props, coercedHref = sanitizeURL$1("" + resource.props.href);
				coercedHref = escapeJSObjectForInstructionScripts$1(coercedHref);
				destination.push(coercedHref);
				precedence = "" + precedence;
				destination.push(",");
				precedence = escapeJSObjectForInstructionScripts$1(precedence);
				destination.push(precedence);
				for (var propKey in props) if (hasOwnProperty$1.call(props, propKey) && (precedence = props[propKey], null != precedence)) switch (propKey) {
					case "href":
					case "rel":
					case "precedence":
					case "data-precedence": break;
					case "children":
					case "dangerouslySetInnerHTML": throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
					default: writeStyleResourceAttributeInJS$1(destination, propKey, precedence);
				}
				destination.push("]");
				nextArrayOpenBrackChunk = ",[";
				resource.state = 3;
			}
		});
		destination.push("]");
	}
	function writeStyleResourceAttributeInJS$1(destination, name, value) {
		var attributeName = name.toLowerCase();
		switch (typeof value) {
			case "function":
			case "symbol": return;
		}
		switch (name) {
			case "innerHTML":
			case "dangerouslySetInnerHTML":
			case "suppressContentEditableWarning":
			case "suppressHydrationWarning":
			case "style":
			case "ref": return;
			case "className":
				attributeName = "class";
				name = "" + value;
				break;
			case "hidden":
				if (!1 === value) return;
				name = "";
				break;
			case "src":
			case "href":
				value = sanitizeURL$1(value);
				name = "" + value;
				break;
			default:
				if (2 < name.length && ("o" === name[0] || "O" === name[0]) && ("n" === name[1] || "N" === name[1]) || !isAttributeNameSafe$1(name)) return;
				name = "" + value;
		}
		destination.push(",");
		attributeName = escapeJSObjectForInstructionScripts$1(attributeName);
		destination.push(attributeName);
		destination.push(",");
		attributeName = escapeJSObjectForInstructionScripts$1(name);
		destination.push(attributeName);
	}
	function createHoistableState$1() {
		return {
			styles: /* @__PURE__ */ new Set(),
			stylesheets: /* @__PURE__ */ new Set(),
			suspenseyImages: !1
		};
	}
	function prefetchDNS$1(href) {
		var request = currentRequest$1 ? currentRequest$1 : null;
		if (request) {
			var resumableState = request.resumableState, renderState = request.renderState;
			if ("string" === typeof href && href) {
				if (!resumableState.dnsResources.hasOwnProperty(href)) {
					resumableState.dnsResources[href] = null;
					resumableState = renderState.headers;
					var header, JSCompiler_temp;
					if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) JSCompiler_temp = (header = "<" + ("" + href).replace(regexForHrefInLinkHeaderURLContext$1, escapeHrefForLinkHeaderURLContextReplacer$1) + ">; rel=dns-prefetch", 0 <= (resumableState.remainingCapacity -= header.length + 2));
					JSCompiler_temp ? (renderState.resets.dns[href] = null, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (header = [], pushLinkImpl$1(header, {
						href,
						rel: "dns-prefetch"
					}), renderState.preconnects.add(header));
				}
				enqueueFlush$1(request);
			}
		} else previousDispatcher$1.D(href);
	}
	function preconnect$1(href, crossOrigin) {
		var request = currentRequest$1 ? currentRequest$1 : null;
		if (request) {
			var resumableState = request.resumableState, renderState = request.renderState;
			if ("string" === typeof href && href) {
				var bucket = "use-credentials" === crossOrigin ? "credentials" : "string" === typeof crossOrigin ? "anonymous" : "default";
				if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {
					resumableState.connectResources[bucket][href] = null;
					resumableState = renderState.headers;
					var header, JSCompiler_temp;
					if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {
						JSCompiler_temp = "<" + ("" + href).replace(regexForHrefInLinkHeaderURLContext$1, escapeHrefForLinkHeaderURLContextReplacer$1) + ">; rel=preconnect";
						if ("string" === typeof crossOrigin) {
							var escapedCrossOrigin = ("" + crossOrigin).replace(regexForLinkHeaderQuotedParamValueContext$1, escapeStringForLinkHeaderQuotedParamValueContextReplacer$1);
							JSCompiler_temp += "; crossorigin=\"" + escapedCrossOrigin + "\"";
						}
						JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));
					}
					JSCompiler_temp ? (renderState.resets.connect[bucket][href] = null, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (bucket = [], pushLinkImpl$1(bucket, {
						rel: "preconnect",
						href,
						crossOrigin
					}), renderState.preconnects.add(bucket));
				}
				enqueueFlush$1(request);
			}
		} else previousDispatcher$1.C(href, crossOrigin);
	}
	function preload$1(href, as, options) {
		var request = currentRequest$1 ? currentRequest$1 : null;
		if (request) {
			var resumableState = request.resumableState, renderState = request.renderState;
			if (as && href) {
				switch (as) {
					case "image":
						if (options) {
							var imageSrcSet = options.imageSrcSet;
							var imageSizes = options.imageSizes;
							var fetchPriority = options.fetchPriority;
						}
						var key = imageSrcSet ? imageSrcSet + "\n" + (imageSizes || "") : href;
						if (resumableState.imageResources.hasOwnProperty(key)) return;
						resumableState.imageResources[key] = PRELOAD_NO_CREDS$1;
						resumableState = renderState.headers;
						var header;
						resumableState && 0 < resumableState.remainingCapacity && "string" !== typeof imageSrcSet && "high" === fetchPriority && (header = getPreloadAsHeader$1(href, as, options), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS$1, resumableState.highImagePreloads && (resumableState.highImagePreloads += ", "), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl$1(resumableState, assign$1({
							rel: "preload",
							href: imageSrcSet ? void 0 : href,
							as
						}, options)), "high" === fetchPriority ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));
						break;
					case "style":
						if (resumableState.styleResources.hasOwnProperty(href)) return;
						imageSrcSet = [];
						pushLinkImpl$1(imageSrcSet, assign$1({
							rel: "preload",
							href,
							as
						}, options));
						resumableState.styleResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS$1 : [options.crossOrigin, options.integrity];
						renderState.preloads.stylesheets.set(href, imageSrcSet);
						renderState.bulkPreloads.add(imageSrcSet);
						break;
					case "script":
						if (resumableState.scriptResources.hasOwnProperty(href)) return;
						imageSrcSet = [];
						renderState.preloads.scripts.set(href, imageSrcSet);
						renderState.bulkPreloads.add(imageSrcSet);
						pushLinkImpl$1(imageSrcSet, assign$1({
							rel: "preload",
							href,
							as
						}, options));
						resumableState.scriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS$1 : [options.crossOrigin, options.integrity];
						break;
					default:
						if (resumableState.unknownResources.hasOwnProperty(as)) {
							if (imageSrcSet = resumableState.unknownResources[as], imageSrcSet.hasOwnProperty(href)) return;
						} else imageSrcSet = {}, resumableState.unknownResources[as] = imageSrcSet;
						imageSrcSet[href] = PRELOAD_NO_CREDS$1;
						if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && "font" === as && (key = getPreloadAsHeader$1(href, as, options), 0 <= (resumableState.remainingCapacity -= key.length + 2))) renderState.resets.font[href] = PRELOAD_NO_CREDS$1, resumableState.fontPreloads && (resumableState.fontPreloads += ", "), resumableState.fontPreloads += key;
						else switch (resumableState = [], href = assign$1({
							rel: "preload",
							href,
							as
						}, options), pushLinkImpl$1(resumableState, href), as) {
							case "font":
								renderState.fontPreloads.add(resumableState);
								break;
							default: renderState.bulkPreloads.add(resumableState);
						}
				}
				enqueueFlush$1(request);
			}
		} else previousDispatcher$1.L(href, as, options);
	}
	function preloadModule$1(href, options) {
		var request = currentRequest$1 ? currentRequest$1 : null;
		if (request) {
			var resumableState = request.resumableState, renderState = request.renderState;
			if (href) {
				var as = options && "string" === typeof options.as ? options.as : "script";
				switch (as) {
					case "script":
						if (resumableState.moduleScriptResources.hasOwnProperty(href)) return;
						as = [];
						resumableState.moduleScriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS$1 : [options.crossOrigin, options.integrity];
						renderState.preloads.moduleScripts.set(href, as);
						break;
					default:
						if (resumableState.moduleUnknownResources.hasOwnProperty(as)) {
							var resources = resumableState.unknownResources[as];
							if (resources.hasOwnProperty(href)) return;
						} else resources = {}, resumableState.moduleUnknownResources[as] = resources;
						as = [];
						resources[href] = PRELOAD_NO_CREDS$1;
				}
				pushLinkImpl$1(as, assign$1({
					rel: "modulepreload",
					href
				}, options));
				renderState.bulkPreloads.add(as);
				enqueueFlush$1(request);
			}
		} else previousDispatcher$1.m(href, options);
	}
	function preinitStyle$1(href, precedence, options) {
		var request = currentRequest$1 ? currentRequest$1 : null;
		if (request) {
			var resumableState = request.resumableState, renderState = request.renderState;
			if (href) {
				precedence = precedence || "default";
				var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
				null !== resourceState && (resumableState.styleResources[href] = null, styleQueue || (styleQueue = {
					precedence: escapeTextForBrowser$1(precedence),
					rules: [],
					hrefs: [],
					sheets: /* @__PURE__ */ new Map()
				}, renderState.styles.set(precedence, styleQueue)), precedence = {
					state: 0,
					props: assign$1({
						rel: "stylesheet",
						href,
						"data-precedence": precedence
					}, options)
				}, resourceState && (2 === resourceState.length && adoptPreloadCredentials$1(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = 1), styleQueue.sheets.set(href, precedence), enqueueFlush$1(request));
			}
		} else previousDispatcher$1.S(href, precedence, options);
	}
	function preinitScript$1(src, options) {
		var request = currentRequest$1 ? currentRequest$1 : null;
		if (request) {
			var resumableState = request.resumableState, renderState = request.renderState;
			if (src) {
				var resourceState = resumableState.scriptResources.hasOwnProperty(src) ? resumableState.scriptResources[src] : void 0;
				null !== resourceState && (resumableState.scriptResources[src] = null, options = assign$1({
					src,
					async: !0
				}, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials$1(options, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl$1(src, options), enqueueFlush$1(request));
			}
		} else previousDispatcher$1.X(src, options);
	}
	function preinitModuleScript$1(src, options) {
		var request = currentRequest$1 ? currentRequest$1 : null;
		if (request) {
			var resumableState = request.resumableState, renderState = request.renderState;
			if (src) {
				var resourceState = resumableState.moduleScriptResources.hasOwnProperty(src) ? resumableState.moduleScriptResources[src] : void 0;
				null !== resourceState && (resumableState.moduleScriptResources[src] = null, options = assign$1({
					src,
					type: "module",
					async: !0
				}, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials$1(options, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl$1(src, options), enqueueFlush$1(request));
			}
		} else previousDispatcher$1.M(src, options);
	}
	function adoptPreloadCredentials$1(target, preloadState) {
		target.crossOrigin ??= preloadState[0];
		target.integrity ??= preloadState[1];
	}
	function getPreloadAsHeader$1(href, as, params) {
		href = ("" + href).replace(regexForHrefInLinkHeaderURLContext$1, escapeHrefForLinkHeaderURLContextReplacer$1);
		as = ("" + as).replace(regexForLinkHeaderQuotedParamValueContext$1, escapeStringForLinkHeaderQuotedParamValueContextReplacer$1);
		as = "<" + href + ">; rel=preload; as=\"" + as + "\"";
		for (var paramName in params) hasOwnProperty$1.call(params, paramName) && (href = params[paramName], "string" === typeof href && (as += "; " + paramName.toLowerCase() + "=\"" + ("" + href).replace(regexForLinkHeaderQuotedParamValueContext$1, escapeStringForLinkHeaderQuotedParamValueContextReplacer$1) + "\""));
		return as;
	}
	var regexForHrefInLinkHeaderURLContext$1 = /[<>\r\n]/g;
	function escapeHrefForLinkHeaderURLContextReplacer$1(match) {
		switch (match) {
			case "<": return "%3C";
			case ">": return "%3E";
			case "\n": return "%0A";
			case "\r": return "%0D";
			default: throw Error("escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
		}
	}
	var regexForLinkHeaderQuotedParamValueContext$1 = /["';,\r\n]/g;
	function escapeStringForLinkHeaderQuotedParamValueContextReplacer$1(match) {
		switch (match) {
			case "\"": return "%22";
			case "'": return "%27";
			case ";": return "%3B";
			case ",": return "%2C";
			case "\n": return "%0A";
			case "\r": return "%0D";
			default: throw Error("escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
		}
	}
	function hoistStyleQueueDependency$1(styleQueue) {
		this.styles.add(styleQueue);
	}
	function hoistStylesheetDependency$1(stylesheet) {
		this.stylesheets.add(stylesheet);
	}
	function hoistHoistables$1(parentState, childState) {
		childState.styles.forEach(hoistStyleQueueDependency$1, parentState);
		childState.stylesheets.forEach(hoistStylesheetDependency$1, parentState);
		childState.suspenseyImages && (parentState.suspenseyImages = !0);
	}
	function createRenderState$1(resumableState, generateStaticMarkup) {
		var idPrefix = resumableState.idPrefix, bootstrapChunks = [], bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;
		void 0 !== bootstrapScriptContent && (bootstrapChunks.push("<script"), pushCompletedShellIdAttribute$1(bootstrapChunks, resumableState), bootstrapChunks.push(">", ("" + bootstrapScriptContent).replace(scriptRegex$1, scriptReplacer$1), "<\/script>"));
		bootstrapScriptContent = idPrefix + "P:";
		var JSCompiler_object_inline_segmentPrefix_1673 = idPrefix + "S:";
		idPrefix += "B:";
		var JSCompiler_object_inline_preconnects_1687 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_fontPreloads_1688 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_highImagePreloads_1689 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_styles_1690 = /* @__PURE__ */ new Map(), JSCompiler_object_inline_bootstrapScripts_1691 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_scripts_1692 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_bulkPreloads_1693 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_preloads_1694 = {
			images: /* @__PURE__ */ new Map(),
			stylesheets: /* @__PURE__ */ new Map(),
			scripts: /* @__PURE__ */ new Map(),
			moduleScripts: /* @__PURE__ */ new Map()
		};
		if (void 0 !== bootstrapScripts) for (var i = 0; i < bootstrapScripts.length; i++) {
			var scriptConfig = bootstrapScripts[i], src, crossOrigin = void 0, integrity = void 0, props = {
				rel: "preload",
				as: "script",
				fetchPriority: "low",
				nonce: void 0
			};
			"string" === typeof scriptConfig ? props.href = src = scriptConfig : (props.href = src = scriptConfig.src, props.integrity = integrity = "string" === typeof scriptConfig.integrity ? scriptConfig.integrity : void 0, props.crossOrigin = crossOrigin = "string" === typeof scriptConfig || null == scriptConfig.crossOrigin ? void 0 : "use-credentials" === scriptConfig.crossOrigin ? "use-credentials" : "");
			scriptConfig = resumableState;
			var href = src;
			scriptConfig.scriptResources[href] = null;
			scriptConfig.moduleScriptResources[href] = null;
			scriptConfig = [];
			pushLinkImpl$1(scriptConfig, props);
			JSCompiler_object_inline_bootstrapScripts_1691.add(scriptConfig);
			bootstrapChunks.push("<script src=\"", escapeTextForBrowser$1(src), "\"");
			"string" === typeof integrity && bootstrapChunks.push(" integrity=\"", escapeTextForBrowser$1(integrity), "\"");
			"string" === typeof crossOrigin && bootstrapChunks.push(" crossorigin=\"", escapeTextForBrowser$1(crossOrigin), "\"");
			pushCompletedShellIdAttribute$1(bootstrapChunks, resumableState);
			bootstrapChunks.push(" async=\"\"><\/script>");
		}
		if (void 0 !== bootstrapModules) for (bootstrapScripts = 0; bootstrapScripts < bootstrapModules.length; bootstrapScripts++) props = bootstrapModules[bootstrapScripts], crossOrigin = src = void 0, integrity = {
			rel: "modulepreload",
			fetchPriority: "low",
			nonce: void 0
		}, "string" === typeof props ? integrity.href = i = props : (integrity.href = i = props.src, integrity.integrity = crossOrigin = "string" === typeof props.integrity ? props.integrity : void 0, integrity.crossOrigin = src = "string" === typeof props || null == props.crossOrigin ? void 0 : "use-credentials" === props.crossOrigin ? "use-credentials" : ""), props = resumableState, scriptConfig = i, props.scriptResources[scriptConfig] = null, props.moduleScriptResources[scriptConfig] = null, props = [], pushLinkImpl$1(props, integrity), JSCompiler_object_inline_bootstrapScripts_1691.add(props), bootstrapChunks.push("<script type=\"module\" src=\"", escapeTextForBrowser$1(i), "\""), "string" === typeof crossOrigin && bootstrapChunks.push(" integrity=\"", escapeTextForBrowser$1(crossOrigin), "\""), "string" === typeof src && bootstrapChunks.push(" crossorigin=\"", escapeTextForBrowser$1(src), "\""), pushCompletedShellIdAttribute$1(bootstrapChunks, resumableState), bootstrapChunks.push(" async=\"\"><\/script>");
		return {
			placeholderPrefix: bootstrapScriptContent,
			segmentPrefix: JSCompiler_object_inline_segmentPrefix_1673,
			boundaryPrefix: idPrefix,
			startInlineScript: "<script",
			startInlineStyle: "<style",
			preamble: {
				htmlChunks: null,
				headChunks: null,
				bodyChunks: null
			},
			externalRuntimeScript: null,
			bootstrapChunks,
			importMapChunks: [],
			onHeaders: void 0,
			headers: null,
			resets: {
				font: {},
				dns: {},
				connect: {
					default: {},
					anonymous: {},
					credentials: {}
				},
				image: {},
				style: {}
			},
			charsetChunks: [],
			viewportChunks: [],
			hoistableChunks: [],
			preconnects: JSCompiler_object_inline_preconnects_1687,
			fontPreloads: JSCompiler_object_inline_fontPreloads_1688,
			highImagePreloads: JSCompiler_object_inline_highImagePreloads_1689,
			styles: JSCompiler_object_inline_styles_1690,
			bootstrapScripts: JSCompiler_object_inline_bootstrapScripts_1691,
			scripts: JSCompiler_object_inline_scripts_1692,
			bulkPreloads: JSCompiler_object_inline_bulkPreloads_1693,
			preloads: JSCompiler_object_inline_preloads_1694,
			nonce: {
				script: void 0,
				style: void 0
			},
			stylesToHoist: !1,
			generateStaticMarkup
		};
	}
	function pushTextInstance$1(target, text, renderState, textEmbedded) {
		if (renderState.generateStaticMarkup) return target.push(escapeTextForBrowser$1(text)), !1;
		"" === text ? target = textEmbedded : (textEmbedded && target.push("<!-- -->"), target.push(escapeTextForBrowser$1(text)), target = !0);
		return target;
	}
	function pushSegmentFinale(target, renderState, lastPushedText, textEmbedded) {
		renderState.generateStaticMarkup || lastPushedText && textEmbedded && target.push("<!-- -->");
	}
	var bind$1 = Function.prototype.bind, REACT_CLIENT_REFERENCE$1 = Symbol.for("react.client.reference");
	function getComponentNameFromType$1(type) {
		if (null == type) return null;
		if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE$1 ? null : type.displayName || type.name || null;
		if ("string" === typeof type) return type;
		switch (type) {
			case REACT_FRAGMENT_TYPE$1: return "Fragment";
			case REACT_PROFILER_TYPE$1: return "Profiler";
			case REACT_STRICT_MODE_TYPE$1: return "StrictMode";
			case REACT_SUSPENSE_TYPE$1: return "Suspense";
			case REACT_SUSPENSE_LIST_TYPE$1: return "SuspenseList";
			case REACT_ACTIVITY_TYPE$1: return "Activity";
		}
		if ("object" === typeof type) switch (type.$$typeof) {
			case REACT_PORTAL_TYPE$1: return "Portal";
			case REACT_CONTEXT_TYPE$1: return type.displayName || "Context";
			case REACT_CONSUMER_TYPE$1: return (type._context.displayName || "Context") + ".Consumer";
			case REACT_FORWARD_REF_TYPE$1:
				var innerType = type.render;
				type = type.displayName;
				type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
				return type;
			case REACT_MEMO_TYPE$1: return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType$1(type.type) || "Memo";
			case REACT_LAZY_TYPE$1:
				innerType = type._payload;
				type = type._init;
				try {
					return getComponentNameFromType$1(type(innerType));
				} catch (x) {}
		}
		return null;
	}
	var emptyContextObject$1 = {}, currentActiveSnapshot$1 = null;
	function popToNearestCommonAncestor$1(prev, next) {
		if (prev !== next) {
			prev.context._currentValue2 = prev.parentValue;
			prev = prev.parent;
			var parentNext = next.parent;
			if (null === prev) {
				if (null !== parentNext) throw Error("The stacks must reach the root at the same time. This is a bug in React.");
			} else {
				if (null === parentNext) throw Error("The stacks must reach the root at the same time. This is a bug in React.");
				popToNearestCommonAncestor$1(prev, parentNext);
			}
			next.context._currentValue2 = next.value;
		}
	}
	function popAllPrevious$1(prev) {
		prev.context._currentValue2 = prev.parentValue;
		prev = prev.parent;
		null !== prev && popAllPrevious$1(prev);
	}
	function pushAllNext$1(next) {
		var parentNext = next.parent;
		null !== parentNext && pushAllNext$1(parentNext);
		next.context._currentValue2 = next.value;
	}
	function popPreviousToCommonLevel$1(prev, next) {
		prev.context._currentValue2 = prev.parentValue;
		prev = prev.parent;
		if (null === prev) throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
		prev.depth === next.depth ? popToNearestCommonAncestor$1(prev, next) : popPreviousToCommonLevel$1(prev, next);
	}
	function popNextToCommonLevel$1(prev, next) {
		var parentNext = next.parent;
		if (null === parentNext) throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
		prev.depth === parentNext.depth ? popToNearestCommonAncestor$1(prev, parentNext) : popNextToCommonLevel$1(prev, parentNext);
		next.context._currentValue2 = next.value;
	}
	function switchContext$1(newSnapshot) {
		var prev = currentActiveSnapshot$1;
		prev !== newSnapshot && (null === prev ? pushAllNext$1(newSnapshot) : null === newSnapshot ? popAllPrevious$1(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor$1(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel$1(prev, newSnapshot) : popNextToCommonLevel$1(prev, newSnapshot), currentActiveSnapshot$1 = newSnapshot);
	}
	var classComponentUpdater$1 = {
		enqueueSetState: function(inst, payload) {
			inst = inst._reactInternals;
			null !== inst.queue && inst.queue.push(payload);
		},
		enqueueReplaceState: function(inst, payload) {
			inst = inst._reactInternals;
			inst.replace = !0;
			inst.queue = [payload];
		},
		enqueueForceUpdate: function() {}
	}, emptyTreeContext$1 = {
		id: 1,
		overflow: ""
	};
	function pushTreeContext$1(baseContext, totalChildren, index) {
		var baseIdWithLeadingBit = baseContext.id;
		baseContext = baseContext.overflow;
		var baseLength = 32 - clz32$1(baseIdWithLeadingBit) - 1;
		baseIdWithLeadingBit &= ~(1 << baseLength);
		index += 1;
		var length = 32 - clz32$1(totalChildren) + baseLength;
		if (30 < length) {
			var numberOfOverflowBits = baseLength - baseLength % 5;
			length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
			baseIdWithLeadingBit >>= numberOfOverflowBits;
			baseLength -= numberOfOverflowBits;
			return {
				id: 1 << 32 - clz32$1(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit,
				overflow: length + baseContext
			};
		}
		return {
			id: 1 << length | index << baseLength | baseIdWithLeadingBit,
			overflow: baseContext
		};
	}
	var clz32$1 = Math.clz32 ? Math.clz32 : clz32Fallback$1, log$1 = Math.log, LN2$1 = Math.LN2;
	function clz32Fallback$1(x) {
		x >>>= 0;
		return 0 === x ? 32 : 31 - (log$1(x) / LN2$1 | 0) | 0;
	}
	function noop$1() {}
	var SuspenseException$1 = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.");
	function trackUsedThenable$1(thenableState$2, thenable, index) {
		index = thenableState$2[index];
		void 0 === index ? thenableState$2.push(thenable) : index !== thenable && (thenable.then(noop$1, noop$1), thenable = index);
		switch (thenable.status) {
			case "fulfilled": return thenable.value;
			case "rejected": throw thenable.reason;
			default:
				"string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenableState$2 = thenable, thenableState$2.status = "pending", thenableState$2.then(function(fulfilledValue) {
					if ("pending" === thenable.status) {
						var fulfilledThenable = thenable;
						fulfilledThenable.status = "fulfilled";
						fulfilledThenable.value = fulfilledValue;
					}
				}, function(error) {
					if ("pending" === thenable.status) {
						var rejectedThenable = thenable;
						rejectedThenable.status = "rejected";
						rejectedThenable.reason = error;
					}
				}));
				switch (thenable.status) {
					case "fulfilled": return thenable.value;
					case "rejected": throw thenable.reason;
				}
				suspendedThenable$1 = thenable;
				throw SuspenseException$1;
		}
	}
	var suspendedThenable$1 = null;
	function getSuspendedThenable$1() {
		if (null === suspendedThenable$1) throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
		var thenable = suspendedThenable$1;
		suspendedThenable$1 = null;
		return thenable;
	}
	function is$1(x, y) {
		return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
	}
	var objectIs$1 = "function" === typeof Object.is ? Object.is : is$1, currentlyRenderingComponent$1 = null, currentlyRenderingTask$1 = null, currentlyRenderingRequest$1 = null, currentlyRenderingKeyPath$1 = null, firstWorkInProgressHook$1 = null, workInProgressHook$1 = null, isReRender$1 = !1, didScheduleRenderPhaseUpdate$1 = !1, localIdCounter$1 = 0, actionStateCounter$1 = 0, actionStateMatchingIndex$1 = -1, thenableIndexCounter$1 = 0, thenableState$1 = null, renderPhaseUpdates$1 = null, numberOfReRenders$1 = 0;
	function resolveCurrentlyRenderingComponent$1() {
		if (null === currentlyRenderingComponent$1) throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
		return currentlyRenderingComponent$1;
	}
	function createHook$1() {
		if (0 < numberOfReRenders$1) throw Error("Rendered more hooks than during the previous render");
		return {
			memoizedState: null,
			queue: null,
			next: null
		};
	}
	function createWorkInProgressHook$1() {
		null === workInProgressHook$1 ? null === firstWorkInProgressHook$1 ? (isReRender$1 = !1, firstWorkInProgressHook$1 = workInProgressHook$1 = createHook$1()) : (isReRender$1 = !0, workInProgressHook$1 = firstWorkInProgressHook$1) : null === workInProgressHook$1.next ? (isReRender$1 = !1, workInProgressHook$1 = workInProgressHook$1.next = createHook$1()) : (isReRender$1 = !0, workInProgressHook$1 = workInProgressHook$1.next);
		return workInProgressHook$1;
	}
	function getThenableStateAfterSuspending$1() {
		var state = thenableState$1;
		thenableState$1 = null;
		return state;
	}
	function resetHooksState$1() {
		currentlyRenderingKeyPath$1 = currentlyRenderingRequest$1 = currentlyRenderingTask$1 = currentlyRenderingComponent$1 = null;
		didScheduleRenderPhaseUpdate$1 = !1;
		firstWorkInProgressHook$1 = null;
		numberOfReRenders$1 = 0;
		workInProgressHook$1 = renderPhaseUpdates$1 = null;
	}
	function basicStateReducer$1(state, action) {
		return "function" === typeof action ? action(state) : action;
	}
	function useReducer$1(reducer, initialArg, init) {
		currentlyRenderingComponent$1 = resolveCurrentlyRenderingComponent$1();
		workInProgressHook$1 = createWorkInProgressHook$1();
		if (isReRender$1) {
			var queue = workInProgressHook$1.queue;
			initialArg = queue.dispatch;
			if (null !== renderPhaseUpdates$1 && (init = renderPhaseUpdates$1.get(queue), void 0 !== init)) {
				renderPhaseUpdates$1.delete(queue);
				queue = workInProgressHook$1.memoizedState;
				do
					queue = reducer(queue, init.action), init = init.next;
				while (null !== init);
				workInProgressHook$1.memoizedState = queue;
				return [queue, initialArg];
			}
			return [workInProgressHook$1.memoizedState, initialArg];
		}
		reducer = reducer === basicStateReducer$1 ? "function" === typeof initialArg ? initialArg() : initialArg : void 0 !== init ? init(initialArg) : initialArg;
		workInProgressHook$1.memoizedState = reducer;
		reducer = workInProgressHook$1.queue = {
			last: null,
			dispatch: null
		};
		reducer = reducer.dispatch = dispatchAction$1.bind(null, currentlyRenderingComponent$1, reducer);
		return [workInProgressHook$1.memoizedState, reducer];
	}
	function useMemo$1(nextCreate, deps) {
		currentlyRenderingComponent$1 = resolveCurrentlyRenderingComponent$1();
		workInProgressHook$1 = createWorkInProgressHook$1();
		deps = void 0 === deps ? null : deps;
		if (null !== workInProgressHook$1) {
			var prevState = workInProgressHook$1.memoizedState;
			if (null !== prevState && null !== deps) {
				var prevDeps = prevState[1];
				a: if (null === prevDeps) prevDeps = !1;
				else {
					for (var i = 0; i < prevDeps.length && i < deps.length; i++) if (!objectIs$1(deps[i], prevDeps[i])) {
						prevDeps = !1;
						break a;
					}
					prevDeps = !0;
				}
				if (prevDeps) return prevState[0];
			}
		}
		nextCreate = nextCreate();
		workInProgressHook$1.memoizedState = [nextCreate, deps];
		return nextCreate;
	}
	function dispatchAction$1(componentIdentity, queue, action) {
		if (25 <= numberOfReRenders$1) throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
		if (componentIdentity === currentlyRenderingComponent$1) if (didScheduleRenderPhaseUpdate$1 = !0, componentIdentity = {
			action,
			next: null
		}, null === renderPhaseUpdates$1 && (renderPhaseUpdates$1 = /* @__PURE__ */ new Map()), action = renderPhaseUpdates$1.get(queue), void 0 === action) renderPhaseUpdates$1.set(queue, componentIdentity);
		else {
			for (queue = action; null !== queue.next;) queue = queue.next;
			queue.next = componentIdentity;
		}
	}
	function throwOnUseEffectEventCall$1() {
		throw Error("A function wrapped in useEffectEvent can't be called during rendering.");
	}
	function unsupportedStartTransition$1() {
		throw Error("startTransition cannot be called during server rendering.");
	}
	function unsupportedSetOptimisticState$1() {
		throw Error("Cannot update optimistic state while rendering.");
	}
	function useActionState$1(action, initialState, permalink) {
		resolveCurrentlyRenderingComponent$1();
		var actionStateHookIndex = actionStateCounter$1++, request = currentlyRenderingRequest$1;
		if ("function" === typeof action.$$FORM_ACTION) {
			var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath$1;
			request = request.formState;
			var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;
			if (null !== request && "function" === typeof isSignatureEqual) {
				var postbackKey = request[1];
				isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(JSON.stringify([
					componentKeyPath,
					null,
					actionStateHookIndex
				]), 0), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex$1 = actionStateHookIndex, initialState = request[0]));
			}
			var boundAction = action.bind(null, initialState);
			action = function(payload) {
				boundAction(payload);
			};
			"function" === typeof boundAction.$$FORM_ACTION && (action.$$FORM_ACTION = function(prefix$2) {
				prefix$2 = boundAction.$$FORM_ACTION(prefix$2);
				void 0 !== permalink && (permalink += "", prefix$2.action = permalink);
				var formData = prefix$2.data;
				formData && (null === nextPostbackStateKey && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(JSON.stringify([
					componentKeyPath,
					null,
					actionStateHookIndex
				]), 0)), formData.append("$ACTION_KEY", nextPostbackStateKey));
				return prefix$2;
			});
			return [
				initialState,
				action,
				!1
			];
		}
		var boundAction$22 = action.bind(null, initialState);
		return [
			initialState,
			function(payload) {
				boundAction$22(payload);
			},
			!1
		];
	}
	function unwrapThenable$1(thenable) {
		var index = thenableIndexCounter$1;
		thenableIndexCounter$1 += 1;
		null === thenableState$1 && (thenableState$1 = []);
		return trackUsedThenable$1(thenableState$1, thenable, index);
	}
	function unsupportedRefresh$1() {
		throw Error("Cache cannot be refreshed during server rendering.");
	}
	var HooksDispatcher$1 = {
		readContext: function(context) {
			return context._currentValue2;
		},
		use: function(usable) {
			if (null !== usable && "object" === typeof usable) {
				if ("function" === typeof usable.then) return unwrapThenable$1(usable);
				if (usable.$$typeof === REACT_CONTEXT_TYPE$1) return usable._currentValue2;
			}
			throw Error("An unsupported type was passed to use(): " + String(usable));
		},
		useContext: function(context) {
			resolveCurrentlyRenderingComponent$1();
			return context._currentValue2;
		},
		useMemo: useMemo$1,
		useReducer: useReducer$1,
		useRef: function(initialValue) {
			currentlyRenderingComponent$1 = resolveCurrentlyRenderingComponent$1();
			workInProgressHook$1 = createWorkInProgressHook$1();
			var previousRef = workInProgressHook$1.memoizedState;
			return null === previousRef ? (initialValue = { current: initialValue }, workInProgressHook$1.memoizedState = initialValue) : previousRef;
		},
		useState: function(initialState) {
			return useReducer$1(basicStateReducer$1, initialState);
		},
		useInsertionEffect: noop$1,
		useLayoutEffect: noop$1,
		useCallback: function(callback, deps) {
			return useMemo$1(function() {
				return callback;
			}, deps);
		},
		useImperativeHandle: noop$1,
		useEffect: noop$1,
		useDebugValue: noop$1,
		useDeferredValue: function(value, initialValue) {
			resolveCurrentlyRenderingComponent$1();
			return void 0 !== initialValue ? initialValue : value;
		},
		useTransition: function() {
			resolveCurrentlyRenderingComponent$1();
			return [!1, unsupportedStartTransition$1];
		},
		useId: function() {
			var JSCompiler_inline_result = currentlyRenderingTask$1.treeContext;
			var overflow = JSCompiler_inline_result.overflow;
			JSCompiler_inline_result = JSCompiler_inline_result.id;
			JSCompiler_inline_result = (JSCompiler_inline_result & ~(1 << 32 - clz32$1(JSCompiler_inline_result) - 1)).toString(32) + overflow;
			var resumableState = currentResumableState$1;
			if (null === resumableState) throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
			overflow = localIdCounter$1++;
			JSCompiler_inline_result = "_" + resumableState.idPrefix + "R_" + JSCompiler_inline_result;
			0 < overflow && (JSCompiler_inline_result += "H" + overflow.toString(32));
			return JSCompiler_inline_result + "_";
		},
		useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
			if (void 0 === getServerSnapshot) throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
			return getServerSnapshot();
		},
		useOptimistic: function(passthrough) {
			resolveCurrentlyRenderingComponent$1();
			return [passthrough, unsupportedSetOptimisticState$1];
		},
		useActionState: useActionState$1,
		useFormState: useActionState$1,
		useHostTransitionStatus: function() {
			resolveCurrentlyRenderingComponent$1();
			return sharedNotPendingObject$1;
		},
		useMemoCache: function(size) {
			for (var data = Array(size), i = 0; i < size; i++) data[i] = REACT_MEMO_CACHE_SENTINEL$1;
			return data;
		},
		useCacheRefresh: function() {
			return unsupportedRefresh$1;
		},
		useEffectEvent: function() {
			return throwOnUseEffectEventCall$1;
		}
	}, currentResumableState$1 = null, DefaultAsyncDispatcher$1 = {
		getCacheForType: function() {
			throw Error("Not implemented.");
		},
		cacheSignal: function() {
			throw Error("Not implemented.");
		}
	}, prefix$1, suffix$1;
	function describeBuiltInComponentFrame$1(name) {
		if (void 0 === prefix$1) try {
			throw Error();
		} catch (x) {
			var match = x.stack.trim().match(/\n( *(at )?)/);
			prefix$1 = match && match[1] || "";
			suffix$1 = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
		}
		return "\n" + prefix$1 + name + suffix$1;
	}
	var reentry$1 = !1;
	function describeNativeComponentFrame$1(fn, construct) {
		if (!fn || reentry$1) return "";
		reentry$1 = !0;
		var previousPrepareStackTrace = Error.prepareStackTrace;
		Error.prepareStackTrace = void 0;
		try {
			var RunInRootFrame = { DetermineComponentFrameRoot: function() {
				try {
					if (construct) {
						var Fake = function() {
							throw Error();
						};
						Object.defineProperty(Fake.prototype, "props", { set: function() {
							throw Error();
						} });
						if ("object" === typeof Reflect && Reflect.construct) {
							try {
								Reflect.construct(Fake, []);
							} catch (x) {
								var control = x;
							}
							Reflect.construct(fn, [], Fake);
						} else {
							try {
								Fake.call();
							} catch (x$24) {
								control = x$24;
							}
							fn.call(Fake.prototype);
						}
					} else {
						try {
							throw Error();
						} catch (x$25) {
							control = x$25;
						}
						(Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {});
					}
				} catch (sample) {
					if (sample && control && "string" === typeof sample.stack) return [sample.stack, control.stack];
				}
				return [null, null];
			} };
			RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
			var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
			namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
			var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
			if (sampleStack && controlStack) {
				var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
				for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot");) RunInRootFrame++;
				for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes("DetermineComponentFrameRoot");) namePropDescriptor++;
				if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length) for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];) namePropDescriptor--;
				for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--) if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
					if (1 !== RunInRootFrame || 1 !== namePropDescriptor) do
						if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
							var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
							fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
							return frame;
						}
					while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
					break;
				}
			}
		} finally {
			reentry$1 = !1, Error.prepareStackTrace = previousPrepareStackTrace;
		}
		return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame$1(previousPrepareStackTrace) : "";
	}
	function describeComponentStackByType$1(type) {
		if ("string" === typeof type) return describeBuiltInComponentFrame$1(type);
		if ("function" === typeof type) return type.prototype && type.prototype.isReactComponent ? describeNativeComponentFrame$1(type, !0) : describeNativeComponentFrame$1(type, !1);
		if ("object" === typeof type && null !== type) {
			switch (type.$$typeof) {
				case REACT_FORWARD_REF_TYPE$1: return describeNativeComponentFrame$1(type.render, !1);
				case REACT_MEMO_TYPE$1: return describeNativeComponentFrame$1(type.type, !1);
				case REACT_LAZY_TYPE$1:
					var lazyComponent = type, payload = lazyComponent._payload;
					lazyComponent = lazyComponent._init;
					try {
						type = lazyComponent(payload);
					} catch (x) {
						return describeBuiltInComponentFrame$1("Lazy");
					}
					return describeComponentStackByType$1(type);
			}
			if ("string" === typeof type.name) {
				a: {
					payload = type.name;
					lazyComponent = type.env;
					var location = type.debugLocation;
					if (null != location && (type = Error.prepareStackTrace, Error.prepareStackTrace = void 0, location = location.stack, Error.prepareStackTrace = type, location.startsWith("Error: react-stack-top-frame\n") && (location = location.slice(29)), type = location.indexOf("\n"), -1 !== type && (location = location.slice(type + 1)), type = location.indexOf("react_stack_bottom_frame"), -1 !== type && (type = location.lastIndexOf("\n", type)), type = -1 !== type ? location = location.slice(0, type) : "", location = type.lastIndexOf("\n"), type = -1 === location ? type : type.slice(location + 1), -1 !== type.indexOf(payload))) {
						payload = "\n" + type;
						break a;
					}
					payload = describeBuiltInComponentFrame$1(payload + (lazyComponent ? " [" + lazyComponent + "]" : ""));
				}
				return payload;
			}
		}
		switch (type) {
			case REACT_SUSPENSE_LIST_TYPE$1: return describeBuiltInComponentFrame$1("SuspenseList");
			case REACT_SUSPENSE_TYPE$1: return describeBuiltInComponentFrame$1("Suspense");
		}
		return "";
	}
	function isEligibleForOutlining$1(request, boundary) {
		return (500 < boundary.byteSize || !1) && null === boundary.contentPreamble;
	}
	function defaultErrorHandler$1(error) {
		if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
			var JSCompiler_inline_result = error.environmentName;
			error = [error].slice(0);
			"string" === typeof error[0] ? error.splice(0, 1, "[%s] " + error[0], " " + JSCompiler_inline_result + " ") : error.splice(0, 0, "[%s]", " " + JSCompiler_inline_result + " ");
			error.unshift(console);
			JSCompiler_inline_result = bind$1.apply(console.error, error);
			JSCompiler_inline_result();
		} else console.error(error);
		return null;
	}
	function RequestInstance$1(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError$1, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
		var abortSet = /* @__PURE__ */ new Set();
		this.destination = null;
		this.flushScheduled = !1;
		this.resumableState = resumableState;
		this.renderState = renderState;
		this.rootFormatContext = rootFormatContext;
		this.progressiveChunkSize = void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;
		this.status = 10;
		this.fatalError = null;
		this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
		this.completedPreambleSegments = this.completedRootSegment = null;
		this.byteSize = 0;
		this.abortableTasks = abortSet;
		this.pingedTasks = [];
		this.clientRenderedBoundaries = [];
		this.completedBoundaries = [];
		this.partialBoundaries = [];
		this.trackedPostpones = null;
		this.onError = void 0 === onError$1 ? defaultErrorHandler$1 : onError$1;
		this.onPostpone = void 0 === onPostpone ? noop$1 : onPostpone;
		this.onAllReady = void 0 === onAllReady ? noop$1 : onAllReady;
		this.onShellReady = void 0 === onShellReady ? noop$1 : onShellReady;
		this.onShellError = void 0 === onShellError ? noop$1 : onShellError;
		this.onFatalError = void 0 === onFatalError ? noop$1 : onFatalError;
		this.formState = void 0 === formState ? null : formState;
	}
	function createRequest$1(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError$1, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
		resumableState = new RequestInstance$1(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError$1, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState);
		renderState = createPendingSegment$1(resumableState, 0, null, rootFormatContext, !1, !1);
		renderState.parentFlushed = !0;
		children = createRenderTask$1(resumableState, null, children, -1, null, renderState, null, null, resumableState.abortableTasks, null, rootFormatContext, null, emptyTreeContext$1, null, null);
		pushComponentStack$1(children);
		resumableState.pingedTasks.push(children);
		return resumableState;
	}
	var currentRequest$1 = null;
	function pingTask$1(request, task) {
		request.pingedTasks.push(task);
		1 === request.pingedTasks.length && (request.flushScheduled = null !== request.destination, performWork$1(request));
	}
	function createSuspenseBoundary$1(request, row, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {
		fallbackAbortableTasks = {
			status: 0,
			rootSegmentID: -1,
			parentFlushed: !1,
			pendingTasks: 0,
			row,
			completedSegments: [],
			byteSize: 0,
			fallbackAbortableTasks,
			errorDigest: null,
			contentState: createHoistableState$1(),
			fallbackState: createHoistableState$1(),
			contentPreamble,
			fallbackPreamble,
			trackedContentKeyPath: null,
			trackedFallbackNode: null
		};
		null !== row && (row.pendingTasks++, contentPreamble = row.boundaries, null !== contentPreamble && (request.allPendingTasks++, fallbackAbortableTasks.pendingTasks++, contentPreamble.push(fallbackAbortableTasks)), request = row.inheritedHoistables, null !== request && hoistHoistables$1(fallbackAbortableTasks.contentState, request));
		return fallbackAbortableTasks;
	}
	function createRenderTask$1(request, thenableState$2, node, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context, treeContext, row, componentStack) {
		request.allPendingTasks++;
		null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
		null !== row && row.pendingTasks++;
		var task = {
			replay: null,
			node,
			childIndex,
			ping: function() {
				return pingTask$1(request, task);
			},
			blockedBoundary,
			blockedSegment,
			blockedPreamble,
			hoistableState,
			abortSet,
			keyPath,
			formatContext,
			context,
			treeContext,
			row,
			componentStack,
			thenableState: thenableState$2
		};
		abortSet.add(task);
		return task;
	}
	function createReplayTask$1(request, thenableState$2, replay, node, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context, treeContext, row, componentStack) {
		request.allPendingTasks++;
		null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
		null !== row && row.pendingTasks++;
		replay.pendingTasks++;
		var task = {
			replay,
			node,
			childIndex,
			ping: function() {
				return pingTask$1(request, task);
			},
			blockedBoundary,
			blockedSegment: null,
			blockedPreamble: null,
			hoistableState,
			abortSet,
			keyPath,
			formatContext,
			context,
			treeContext,
			row,
			componentStack,
			thenableState: thenableState$2
		};
		abortSet.add(task);
		return task;
	}
	function createPendingSegment$1(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {
		return {
			status: 0,
			parentFlushed: !1,
			id: -1,
			index,
			chunks: [],
			children: [],
			preambleChildren: [],
			parentFormatContext,
			boundary,
			lastPushedText,
			textEmbedded
		};
	}
	function pushComponentStack$1(task) {
		var node = task.node;
		if ("object" === typeof node && null !== node) switch (node.$$typeof) {
			case REACT_ELEMENT_TYPE$1: task.componentStack = {
				parent: task.componentStack,
				type: node.type
			};
		}
	}
	function replaceSuspenseComponentStackWithSuspenseFallbackStack$1(componentStack) {
		return null === componentStack ? null : {
			parent: componentStack.parent,
			type: "Suspense Fallback"
		};
	}
	function getThrownInfo$1(node$jscomp$0) {
		var errorInfo = {};
		node$jscomp$0 && Object.defineProperty(errorInfo, "componentStack", {
			configurable: !0,
			enumerable: !0,
			get: function() {
				try {
					var info = "", node = node$jscomp$0;
					do
						info += describeComponentStackByType$1(node.type), node = node.parent;
					while (node);
					var JSCompiler_inline_result = info;
				} catch (x) {
					JSCompiler_inline_result = "\nError generating stack: " + x.message + "\n" + x.stack;
				}
				Object.defineProperty(errorInfo, "componentStack", { value: JSCompiler_inline_result });
				return JSCompiler_inline_result;
			}
		});
		return errorInfo;
	}
	function logRecoverableError$1(request, error, errorInfo) {
		request = request.onError;
		error = request(error, errorInfo);
		if (null == error || "string" === typeof error) return error;
	}
	function fatalError$1(request, error) {
		var onShellError = request.onShellError, onFatalError = request.onFatalError;
		onShellError(error);
		onFatalError(error);
		null !== request.destination ? (request.status = 14, request.destination.destroy(error)) : (request.status = 13, request.fatalError = error);
	}
	function finishSuspenseListRow$1(request, row) {
		unblockSuspenseListRow$1(request, row.next, row.hoistables);
	}
	function unblockSuspenseListRow$1(request, unblockedRow, inheritedHoistables) {
		for (; null !== unblockedRow;) {
			null !== inheritedHoistables && (hoistHoistables$1(unblockedRow.hoistables, inheritedHoistables), unblockedRow.inheritedHoistables = inheritedHoistables);
			var unblockedBoundaries = unblockedRow.boundaries;
			if (null !== unblockedBoundaries) {
				unblockedRow.boundaries = null;
				for (var i = 0; i < unblockedBoundaries.length; i++) {
					var unblockedBoundary = unblockedBoundaries[i];
					null !== inheritedHoistables && hoistHoistables$1(unblockedBoundary.contentState, inheritedHoistables);
					finishedTask$1(request, unblockedBoundary, null, null);
				}
			}
			unblockedRow.pendingTasks--;
			if (0 < unblockedRow.pendingTasks) break;
			inheritedHoistables = unblockedRow.hoistables;
			unblockedRow = unblockedRow.next;
		}
	}
	function tryToResolveTogetherRow$1(request, togetherRow) {
		var boundaries = togetherRow.boundaries;
		if (null !== boundaries && togetherRow.pendingTasks === boundaries.length) {
			for (var allCompleteAndInlinable = !0, i = 0; i < boundaries.length; i++) {
				var rowBoundary = boundaries[i];
				if (1 !== rowBoundary.pendingTasks || rowBoundary.parentFlushed || isEligibleForOutlining$1(request, rowBoundary)) {
					allCompleteAndInlinable = !1;
					break;
				}
			}
			allCompleteAndInlinable && unblockSuspenseListRow$1(request, togetherRow, togetherRow.hoistables);
		}
	}
	function createSuspenseListRow$1(previousRow) {
		var newRow = {
			pendingTasks: 1,
			boundaries: null,
			hoistables: createHoistableState$1(),
			inheritedHoistables: null,
			together: !1,
			next: null
		};
		null !== previousRow && 0 < previousRow.pendingTasks && (newRow.pendingTasks++, newRow.boundaries = [], previousRow.next = newRow);
		return newRow;
	}
	function renderSuspenseListRows$1(request, task, keyPath, rows, revealOrder) {
		var prevKeyPath = task.keyPath, prevTreeContext = task.treeContext, prevRow = task.row;
		task.keyPath = keyPath;
		keyPath = rows.length;
		var previousSuspenseListRow = null;
		if (null !== task.replay) {
			var resumeSlots = task.replay.slots;
			if (null !== resumeSlots && "object" === typeof resumeSlots) for (var n = 0; n < keyPath; n++) {
				var i = "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder ? n : keyPath - 1 - n, node = rows[i];
				task.row = previousSuspenseListRow = createSuspenseListRow$1(previousSuspenseListRow);
				task.treeContext = pushTreeContext$1(prevTreeContext, keyPath, i);
				var resumeSegmentID = resumeSlots[i];
				"number" === typeof resumeSegmentID ? (resumeNode$1(request, task, resumeSegmentID, node, i), delete resumeSlots[i]) : renderNode$1(request, task, node, i);
				0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow$1(request, previousSuspenseListRow);
			}
			else for (resumeSlots = 0; resumeSlots < keyPath; resumeSlots++) n = "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder ? resumeSlots : keyPath - 1 - resumeSlots, i = rows[n], task.row = previousSuspenseListRow = createSuspenseListRow$1(previousSuspenseListRow), task.treeContext = pushTreeContext$1(prevTreeContext, keyPath, n), renderNode$1(request, task, i, n), 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow$1(request, previousSuspenseListRow);
		} else if ("backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder) for (revealOrder = 0; revealOrder < keyPath; revealOrder++) resumeSlots = rows[revealOrder], task.row = previousSuspenseListRow = createSuspenseListRow$1(previousSuspenseListRow), task.treeContext = pushTreeContext$1(prevTreeContext, keyPath, revealOrder), renderNode$1(request, task, resumeSlots, revealOrder), 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow$1(request, previousSuspenseListRow);
		else {
			revealOrder = task.blockedSegment;
			resumeSlots = revealOrder.children.length;
			n = revealOrder.chunks.length;
			for (i = keyPath - 1; 0 <= i; i--) {
				node = rows[i];
				task.row = previousSuspenseListRow = createSuspenseListRow$1(previousSuspenseListRow);
				task.treeContext = pushTreeContext$1(prevTreeContext, keyPath, i);
				resumeSegmentID = createPendingSegment$1(request, n, null, task.formatContext, 0 === i ? revealOrder.lastPushedText : !0, !0);
				revealOrder.children.splice(resumeSlots, 0, resumeSegmentID);
				task.blockedSegment = resumeSegmentID;
				try {
					renderNode$1(request, task, node, i), pushSegmentFinale(resumeSegmentID.chunks, request.renderState, resumeSegmentID.lastPushedText, resumeSegmentID.textEmbedded), resumeSegmentID.status = 1, 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow$1(request, previousSuspenseListRow);
				} catch (thrownValue) {
					throw resumeSegmentID.status = 12 === request.status ? 3 : 4, thrownValue;
				}
			}
			task.blockedSegment = revealOrder;
			revealOrder.lastPushedText = !1;
		}
		null !== prevRow && null !== previousSuspenseListRow && 0 < previousSuspenseListRow.pendingTasks && (prevRow.pendingTasks++, previousSuspenseListRow.next = prevRow);
		task.treeContext = prevTreeContext;
		task.row = prevRow;
		task.keyPath = prevKeyPath;
	}
	function renderWithHooks$1(request, task, keyPath, Component, props, secondArg) {
		var prevThenableState = task.thenableState;
		task.thenableState = null;
		currentlyRenderingComponent$1 = {};
		currentlyRenderingTask$1 = task;
		currentlyRenderingRequest$1 = request;
		currentlyRenderingKeyPath$1 = keyPath;
		actionStateCounter$1 = localIdCounter$1 = 0;
		actionStateMatchingIndex$1 = -1;
		thenableIndexCounter$1 = 0;
		thenableState$1 = prevThenableState;
		for (request = Component(props, secondArg); didScheduleRenderPhaseUpdate$1;) didScheduleRenderPhaseUpdate$1 = !1, actionStateCounter$1 = localIdCounter$1 = 0, actionStateMatchingIndex$1 = -1, thenableIndexCounter$1 = 0, numberOfReRenders$1 += 1, workInProgressHook$1 = null, request = Component(props, secondArg);
		resetHooksState$1();
		return request;
	}
	function finishFunctionComponent$1(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex$2) {
		var didEmitActionStateMarkers = !1;
		if (0 !== actionStateCount && null !== request.formState) {
			var segment = task.blockedSegment;
			if (null !== segment) {
				didEmitActionStateMarkers = !0;
				segment = segment.chunks;
				for (var i = 0; i < actionStateCount; i++) i === actionStateMatchingIndex$2 ? segment.push("<!--F!-->") : segment.push("<!--F-->");
			}
		}
		actionStateCount = task.keyPath;
		task.keyPath = keyPath;
		hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext$1(keyPath, 1, 0), renderNode$1(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode$1(request, task, children, -1) : renderNodeDestructive$1(request, task, children, -1);
		task.keyPath = actionStateCount;
	}
	function renderElement$1(request, task, keyPath, type, props, ref) {
		if ("function" === typeof type) if (type.prototype && type.prototype.isReactComponent) {
			var newProps = props;
			if ("ref" in props) {
				newProps = {};
				for (var propName in props) "ref" !== propName && (newProps[propName] = props[propName]);
			}
			var defaultProps = type.defaultProps;
			if (defaultProps) {
				newProps === props && (newProps = assign$1({}, newProps, props));
				for (var propName$43 in defaultProps) void 0 === newProps[propName$43] && (newProps[propName$43] = defaultProps[propName$43]);
			}
			props = newProps;
			newProps = emptyContextObject$1;
			defaultProps = type.contextType;
			"object" === typeof defaultProps && null !== defaultProps && (newProps = defaultProps._currentValue2);
			newProps = new type(props, newProps);
			var initialState = void 0 !== newProps.state ? newProps.state : null;
			newProps.updater = classComponentUpdater$1;
			newProps.props = props;
			newProps.state = initialState;
			defaultProps = {
				queue: [],
				replace: !1
			};
			newProps._reactInternals = defaultProps;
			ref = type.contextType;
			newProps.context = "object" === typeof ref && null !== ref ? ref._currentValue2 : emptyContextObject$1;
			ref = type.getDerivedStateFromProps;
			"function" === typeof ref && (ref = ref(props, initialState), initialState = null === ref || void 0 === ref ? initialState : assign$1({}, initialState, ref), newProps.state = initialState);
			if ("function" !== typeof type.getDerivedStateFromProps && "function" !== typeof newProps.getSnapshotBeforeUpdate && ("function" === typeof newProps.UNSAFE_componentWillMount || "function" === typeof newProps.componentWillMount)) if (type = newProps.state, "function" === typeof newProps.componentWillMount && newProps.componentWillMount(), "function" === typeof newProps.UNSAFE_componentWillMount && newProps.UNSAFE_componentWillMount(), type !== newProps.state && classComponentUpdater$1.enqueueReplaceState(newProps, newProps.state, null), null !== defaultProps.queue && 0 < defaultProps.queue.length) if (type = defaultProps.queue, ref = defaultProps.replace, defaultProps.queue = null, defaultProps.replace = !1, ref && 1 === type.length) newProps.state = type[0];
			else {
				defaultProps = ref ? type[0] : newProps.state;
				initialState = !0;
				for (ref = ref ? 1 : 0; ref < type.length; ref++) propName$43 = type[ref], propName$43 = "function" === typeof propName$43 ? propName$43.call(newProps, defaultProps, props, void 0) : propName$43, null != propName$43 && (initialState ? (initialState = !1, defaultProps = assign$1({}, defaultProps, propName$43)) : assign$1(defaultProps, propName$43));
				newProps.state = defaultProps;
			}
			else defaultProps.queue = null;
			type = newProps.render();
			if (12 === request.status) throw null;
			props = task.keyPath;
			task.keyPath = keyPath;
			renderNodeDestructive$1(request, task, type, -1);
			task.keyPath = props;
		} else {
			type = renderWithHooks$1(request, task, keyPath, type, props, void 0);
			if (12 === request.status) throw null;
			finishFunctionComponent$1(request, task, keyPath, type, 0 !== localIdCounter$1, actionStateCounter$1, actionStateMatchingIndex$1);
		}
		else if ("string" === typeof type) if (newProps = task.blockedSegment, null === newProps) newProps = props.children, defaultProps = task.formatContext, initialState = task.keyPath, task.formatContext = getChildFormatContext$1(defaultProps, type, props), task.keyPath = keyPath, renderNode$1(request, task, newProps, -1), task.formatContext = defaultProps, task.keyPath = initialState;
		else {
			initialState = pushStartInstance$1(newProps.chunks, type, props, request.resumableState, request.renderState, task.blockedPreamble, task.hoistableState, task.formatContext, newProps.lastPushedText);
			newProps.lastPushedText = !1;
			defaultProps = task.formatContext;
			ref = task.keyPath;
			task.keyPath = keyPath;
			if (3 === (task.formatContext = getChildFormatContext$1(defaultProps, type, props)).insertionMode) {
				keyPath = createPendingSegment$1(request, 0, null, task.formatContext, !1, !1);
				newProps.preambleChildren.push(keyPath);
				task.blockedSegment = keyPath;
				try {
					keyPath.status = 6, renderNode$1(request, task, initialState, -1), pushSegmentFinale(keyPath.chunks, request.renderState, keyPath.lastPushedText, keyPath.textEmbedded), keyPath.status = 1;
				} finally {
					task.blockedSegment = newProps;
				}
			} else renderNode$1(request, task, initialState, -1);
			task.formatContext = defaultProps;
			task.keyPath = ref;
			a: {
				task = newProps.chunks;
				request = request.resumableState;
				switch (type) {
					case "title":
					case "style":
					case "script":
					case "area":
					case "base":
					case "br":
					case "col":
					case "embed":
					case "hr":
					case "img":
					case "input":
					case "keygen":
					case "link":
					case "meta":
					case "param":
					case "source":
					case "track":
					case "wbr": break a;
					case "body":
						if (1 >= defaultProps.insertionMode) {
							request.hasBody = !0;
							break a;
						}
						break;
					case "html":
						if (0 === defaultProps.insertionMode) {
							request.hasHtml = !0;
							break a;
						}
						break;
					case "head": if (1 >= defaultProps.insertionMode) break a;
				}
				task.push(endChunkForTag$1(type));
			}
			newProps.lastPushedText = !1;
		}
		else {
			switch (type) {
				case REACT_LEGACY_HIDDEN_TYPE$1:
				case REACT_STRICT_MODE_TYPE$1:
				case REACT_PROFILER_TYPE$1:
				case REACT_FRAGMENT_TYPE$1:
					type = task.keyPath;
					task.keyPath = keyPath;
					renderNodeDestructive$1(request, task, props.children, -1);
					task.keyPath = type;
					return;
				case REACT_ACTIVITY_TYPE$1:
					type = task.blockedSegment;
					null === type ? "hidden" !== props.mode && (type = task.keyPath, task.keyPath = keyPath, renderNode$1(request, task, props.children, -1), task.keyPath = type) : "hidden" !== props.mode && (request.renderState.generateStaticMarkup || type.chunks.push("<!--&-->"), type.lastPushedText = !1, newProps = task.keyPath, task.keyPath = keyPath, renderNode$1(request, task, props.children, -1), task.keyPath = newProps, request.renderState.generateStaticMarkup || type.chunks.push("<!--/&-->"), type.lastPushedText = !1);
					return;
				case REACT_SUSPENSE_LIST_TYPE$1:
					a: {
						type = props.children;
						props = props.revealOrder;
						if ("forwards" === props || "backwards" === props || "unstable_legacy-backwards" === props) {
							if (isArrayImpl$1(type)) {
								renderSuspenseListRows$1(request, task, keyPath, type, props);
								break a;
							}
							if (newProps = getIteratorFn$1(type)) {
								if (newProps = newProps.call(type)) {
									defaultProps = newProps.next();
									if (!defaultProps.done) {
										do
											defaultProps = newProps.next();
										while (!defaultProps.done);
										renderSuspenseListRows$1(request, task, keyPath, type, props);
									}
									break a;
								}
							}
						}
						"together" === props ? (props = task.keyPath, newProps = task.row, defaultProps = task.row = createSuspenseListRow$1(null), defaultProps.boundaries = [], defaultProps.together = !0, task.keyPath = keyPath, renderNodeDestructive$1(request, task, type, -1), 0 === --defaultProps.pendingTasks && finishSuspenseListRow$1(request, defaultProps), task.keyPath = props, task.row = newProps, null !== newProps && 0 < defaultProps.pendingTasks && (newProps.pendingTasks++, defaultProps.next = newProps)) : (props = task.keyPath, task.keyPath = keyPath, renderNodeDestructive$1(request, task, type, -1), task.keyPath = props);
					}
					return;
				case REACT_VIEW_TRANSITION_TYPE$1:
				case REACT_SCOPE_TYPE$1: throw Error("ReactDOMServer does not yet support scope components.");
				case REACT_SUSPENSE_TYPE$1:
					a: if (null !== task.replay) {
						type = task.keyPath;
						newProps = task.formatContext;
						defaultProps = task.row;
						task.keyPath = keyPath;
						task.formatContext = getSuspenseContentFormatContext$1(request.resumableState, newProps);
						task.row = null;
						keyPath = props.children;
						try {
							renderNode$1(request, task, keyPath, -1);
						} finally {
							task.keyPath = type, task.formatContext = newProps, task.row = defaultProps;
						}
					} else {
						type = task.keyPath;
						ref = task.formatContext;
						var prevRow = task.row, parentBoundary = task.blockedBoundary;
						propName$43 = task.blockedPreamble;
						var parentHoistableState = task.hoistableState;
						propName = task.blockedSegment;
						var fallback = props.fallback;
						props = props.children;
						var fallbackAbortSet = /* @__PURE__ */ new Set();
						var newBoundary = createSuspenseBoundary$1(request, task.row, fallbackAbortSet, null, null);
						null !== request.trackedPostpones && (newBoundary.trackedContentKeyPath = keyPath);
						var boundarySegment = createPendingSegment$1(request, propName.chunks.length, newBoundary, task.formatContext, !1, !1);
						propName.children.push(boundarySegment);
						propName.lastPushedText = !1;
						var contentRootSegment = createPendingSegment$1(request, 0, null, task.formatContext, !1, !1);
						contentRootSegment.parentFlushed = !0;
						if (null !== request.trackedPostpones) {
							newProps = task.componentStack;
							defaultProps = [
								keyPath[0],
								"Suspense Fallback",
								keyPath[2]
							];
							initialState = [
								defaultProps[1],
								defaultProps[2],
								[],
								null
							];
							request.trackedPostpones.workingMap.set(defaultProps, initialState);
							newBoundary.trackedFallbackNode = initialState;
							task.blockedSegment = boundarySegment;
							task.blockedPreamble = newBoundary.fallbackPreamble;
							task.keyPath = defaultProps;
							task.formatContext = getSuspenseFallbackFormatContext$1(request.resumableState, ref);
							task.componentStack = replaceSuspenseComponentStackWithSuspenseFallbackStack$1(newProps);
							boundarySegment.status = 6;
							try {
								renderNode$1(request, task, fallback, -1), pushSegmentFinale(boundarySegment.chunks, request.renderState, boundarySegment.lastPushedText, boundarySegment.textEmbedded), boundarySegment.status = 1;
							} catch (thrownValue) {
								throw boundarySegment.status = 12 === request.status ? 3 : 4, thrownValue;
							} finally {
								task.blockedSegment = propName, task.blockedPreamble = propName$43, task.keyPath = type, task.formatContext = ref;
							}
							task = createRenderTask$1(request, null, props, -1, newBoundary, contentRootSegment, newBoundary.contentPreamble, newBoundary.contentState, task.abortSet, keyPath, getSuspenseContentFormatContext$1(request.resumableState, task.formatContext), task.context, task.treeContext, null, newProps);
							pushComponentStack$1(task);
							request.pingedTasks.push(task);
						} else {
							task.blockedBoundary = newBoundary;
							task.blockedPreamble = newBoundary.contentPreamble;
							task.hoistableState = newBoundary.contentState;
							task.blockedSegment = contentRootSegment;
							task.keyPath = keyPath;
							task.formatContext = getSuspenseContentFormatContext$1(request.resumableState, ref);
							task.row = null;
							contentRootSegment.status = 6;
							try {
								if (renderNode$1(request, task, props, -1), pushSegmentFinale(contentRootSegment.chunks, request.renderState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded), contentRootSegment.status = 1, queueCompletedSegment$1(newBoundary, contentRootSegment), 0 === newBoundary.pendingTasks && 0 === newBoundary.status) {
									if (newBoundary.status = 1, !isEligibleForOutlining$1(request, newBoundary)) {
										null !== prevRow && 0 === --prevRow.pendingTasks && finishSuspenseListRow$1(request, prevRow);
										0 === request.pendingRootTasks && task.blockedPreamble && preparePreamble$1(request);
										break a;
									}
								} else null !== prevRow && prevRow.together && tryToResolveTogetherRow$1(request, prevRow);
							} catch (thrownValue$30) {
								newBoundary.status = 4, 12 === request.status ? (contentRootSegment.status = 3, newProps = request.fatalError) : (contentRootSegment.status = 4, newProps = thrownValue$30), defaultProps = getThrownInfo$1(task.componentStack), initialState = logRecoverableError$1(request, newProps, defaultProps), newBoundary.errorDigest = initialState, untrackBoundary$1(request, newBoundary);
							} finally {
								task.blockedBoundary = parentBoundary, task.blockedPreamble = propName$43, task.hoistableState = parentHoistableState, task.blockedSegment = propName, task.keyPath = type, task.formatContext = ref, task.row = prevRow;
							}
							task = createRenderTask$1(request, null, fallback, -1, parentBoundary, boundarySegment, newBoundary.fallbackPreamble, newBoundary.fallbackState, fallbackAbortSet, [
								keyPath[0],
								"Suspense Fallback",
								keyPath[2]
							], getSuspenseFallbackFormatContext$1(request.resumableState, task.formatContext), task.context, task.treeContext, task.row, replaceSuspenseComponentStackWithSuspenseFallbackStack$1(task.componentStack));
							pushComponentStack$1(task);
							request.pingedTasks.push(task);
						}
					}
					return;
			}
			if ("object" === typeof type && null !== type) switch (type.$$typeof) {
				case REACT_FORWARD_REF_TYPE$1:
					if ("ref" in props) for (fallback in newProps = {}, props) "ref" !== fallback && (newProps[fallback] = props[fallback]);
					else newProps = props;
					type = renderWithHooks$1(request, task, keyPath, type.render, newProps, ref);
					finishFunctionComponent$1(request, task, keyPath, type, 0 !== localIdCounter$1, actionStateCounter$1, actionStateMatchingIndex$1);
					return;
				case REACT_MEMO_TYPE$1:
					renderElement$1(request, task, keyPath, type.type, props, ref);
					return;
				case REACT_CONTEXT_TYPE$1:
					defaultProps = props.children;
					newProps = task.keyPath;
					props = props.value;
					initialState = type._currentValue2;
					type._currentValue2 = props;
					ref = currentActiveSnapshot$1;
					currentActiveSnapshot$1 = type = {
						parent: ref,
						depth: null === ref ? 0 : ref.depth + 1,
						context: type,
						parentValue: initialState,
						value: props
					};
					task.context = type;
					task.keyPath = keyPath;
					renderNodeDestructive$1(request, task, defaultProps, -1);
					request = currentActiveSnapshot$1;
					if (null === request) throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
					request.context._currentValue2 = request.parentValue;
					request = currentActiveSnapshot$1 = request.parent;
					task.context = request;
					task.keyPath = newProps;
					return;
				case REACT_CONSUMER_TYPE$1:
					props = props.children;
					type = props(type._context._currentValue2);
					props = task.keyPath;
					task.keyPath = keyPath;
					renderNodeDestructive$1(request, task, type, -1);
					task.keyPath = props;
					return;
				case REACT_LAZY_TYPE$1:
					newProps = type._init;
					type = newProps(type._payload);
					if (12 === request.status) throw null;
					renderElement$1(request, task, keyPath, type, props, ref);
					return;
			}
			throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((null == type ? type : typeof type) + "."));
		}
	}
	function resumeNode$1(request, task, segmentId, node, childIndex) {
		var prevReplay = task.replay, blockedBoundary = task.blockedBoundary, resumedSegment = createPendingSegment$1(request, 0, null, task.formatContext, !1, !1);
		resumedSegment.id = segmentId;
		resumedSegment.parentFlushed = !0;
		try {
			task.replay = null, task.blockedSegment = resumedSegment, renderNode$1(request, task, node, childIndex), resumedSegment.status = 1, null === blockedBoundary ? request.completedRootSegment = resumedSegment : (queueCompletedSegment$1(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));
		} finally {
			task.replay = prevReplay, task.blockedSegment = null;
		}
	}
	function renderNodeDestructive$1(request, task, node, childIndex) {
		null !== task.replay && "number" === typeof task.replay.slots ? resumeNode$1(request, task, task.replay.slots, node, childIndex) : (task.node = node, task.childIndex = childIndex, node = task.componentStack, pushComponentStack$1(task), retryNode$1(request, task), task.componentStack = node);
	}
	function retryNode$1(request, task) {
		var node = task.node, childIndex = task.childIndex;
		if (null !== node) {
			if ("object" === typeof node) {
				switch (node.$$typeof) {
					case REACT_ELEMENT_TYPE$1:
						var type = node.type, key = node.key, props = node.props;
						node = props.ref;
						var ref = void 0 !== node ? node : null, name = getComponentNameFromType$1(type), keyOrIndex = null == key ? -1 === childIndex ? 0 : childIndex : key;
						key = [
							task.keyPath,
							name,
							keyOrIndex
						];
						if (null !== task.replay) a: {
							var replay = task.replay;
							childIndex = replay.nodes;
							for (node = 0; node < childIndex.length; node++) {
								var node$jscomp$0 = childIndex[node];
								if (keyOrIndex === node$jscomp$0[1]) {
									if (4 === node$jscomp$0.length) {
										if (null !== name && name !== node$jscomp$0[0]) throw Error("Expected the resume to render <" + node$jscomp$0[0] + "> in this slot but instead it rendered <" + name + ">. The tree doesn't match so React will fallback to client rendering.");
										var childNodes = node$jscomp$0[2];
										name = node$jscomp$0[3];
										keyOrIndex = task.node;
										task.replay = {
											nodes: childNodes,
											slots: name,
											pendingTasks: 1
										};
										try {
											renderElement$1(request, task, key, type, props, ref);
											if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length) throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
											task.replay.pendingTasks--;
										} catch (x) {
											if ("object" === typeof x && null !== x && (x === SuspenseException$1 || "function" === typeof x.then)) throw task.node === keyOrIndex ? task.replay = replay : childIndex.splice(node, 1), x;
											task.replay.pendingTasks--;
											props = getThrownInfo$1(task.componentStack);
											key = request;
											request = task.blockedBoundary;
											type = x;
											props = logRecoverableError$1(key, type, props);
											abortRemainingReplayNodes$1(key, request, childNodes, name, type, props);
										}
										task.replay = replay;
									} else {
										if (type !== REACT_SUSPENSE_TYPE$1) throw Error("Expected the resume to render <Suspense> in this slot but instead it rendered <" + (getComponentNameFromType$1(type) || "Unknown") + ">. The tree doesn't match so React will fallback to client rendering.");
										b: {
											replay = void 0;
											type = node$jscomp$0[5];
											ref = node$jscomp$0[2];
											name = node$jscomp$0[3];
											keyOrIndex = null === node$jscomp$0[4] ? [] : node$jscomp$0[4][2];
											node$jscomp$0 = null === node$jscomp$0[4] ? null : node$jscomp$0[4][3];
											var prevKeyPath = task.keyPath, prevContext = task.formatContext, prevRow = task.row, previousReplaySet = task.replay, parentBoundary = task.blockedBoundary, parentHoistableState = task.hoistableState, content = props.children, fallback = props.fallback, fallbackAbortSet = /* @__PURE__ */ new Set();
											props = createSuspenseBoundary$1(request, task.row, fallbackAbortSet, null, null);
											props.parentFlushed = !0;
											props.rootSegmentID = type;
											task.blockedBoundary = props;
											task.hoistableState = props.contentState;
											task.keyPath = key;
											task.formatContext = getSuspenseContentFormatContext$1(request.resumableState, prevContext);
											task.row = null;
											task.replay = {
												nodes: ref,
												slots: name,
												pendingTasks: 1
											};
											try {
												renderNode$1(request, task, content, -1);
												if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length) throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
												task.replay.pendingTasks--;
												if (0 === props.pendingTasks && 0 === props.status) {
													props.status = 1;
													request.completedBoundaries.push(props);
													break b;
												}
											} catch (error) {
												props.status = 4, childNodes = getThrownInfo$1(task.componentStack), replay = logRecoverableError$1(request, error, childNodes), props.errorDigest = replay, task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);
											} finally {
												task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath, task.formatContext = prevContext, task.row = prevRow;
											}
											childNodes = createReplayTask$1(request, null, {
												nodes: keyOrIndex,
												slots: node$jscomp$0,
												pendingTasks: 0
											}, fallback, -1, parentBoundary, props.fallbackState, fallbackAbortSet, [
												key[0],
												"Suspense Fallback",
												key[2]
											], getSuspenseFallbackFormatContext$1(request.resumableState, task.formatContext), task.context, task.treeContext, task.row, replaceSuspenseComponentStackWithSuspenseFallbackStack$1(task.componentStack));
											pushComponentStack$1(childNodes);
											request.pingedTasks.push(childNodes);
										}
									}
									childIndex.splice(node, 1);
									break a;
								}
							}
						}
						else renderElement$1(request, task, key, type, props, ref);
						return;
					case REACT_PORTAL_TYPE$1: throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
					case REACT_LAZY_TYPE$1:
						childNodes = node._init;
						node = childNodes(node._payload);
						if (12 === request.status) throw null;
						renderNodeDestructive$1(request, task, node, childIndex);
						return;
				}
				if (isArrayImpl$1(node)) {
					renderChildrenArray$1(request, task, node, childIndex);
					return;
				}
				if (childNodes = getIteratorFn$1(node)) {
					if (childNodes = childNodes.call(node)) {
						node = childNodes.next();
						if (!node.done) {
							props = [];
							do
								props.push(node.value), node = childNodes.next();
							while (!node.done);
							renderChildrenArray$1(request, task, props, childIndex);
						}
						return;
					}
				}
				if ("function" === typeof node.then) return task.thenableState = null, renderNodeDestructive$1(request, task, unwrapThenable$1(node), childIndex);
				if (node.$$typeof === REACT_CONTEXT_TYPE$1) return renderNodeDestructive$1(request, task, node._currentValue2, childIndex);
				childIndex = Object.prototype.toString.call(node);
				throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === childIndex ? "object with keys {" + Object.keys(node).join(", ") + "}" : childIndex) + "). If you meant to render a collection of children, use an array instead.");
			}
			if ("string" === typeof node) childIndex = task.blockedSegment, null !== childIndex && (childIndex.lastPushedText = pushTextInstance$1(childIndex.chunks, node, request.renderState, childIndex.lastPushedText));
			else if ("number" === typeof node || "bigint" === typeof node) childIndex = task.blockedSegment, null !== childIndex && (childIndex.lastPushedText = pushTextInstance$1(childIndex.chunks, "" + node, request.renderState, childIndex.lastPushedText));
		}
	}
	function renderChildrenArray$1(request, task, children, childIndex) {
		var prevKeyPath = task.keyPath;
		if (-1 !== childIndex && (task.keyPath = [
			task.keyPath,
			"Fragment",
			childIndex
		], null !== task.replay)) {
			for (var replay = task.replay, replayNodes = replay.nodes, j = 0; j < replayNodes.length; j++) {
				var node = replayNodes[j];
				if (node[1] === childIndex) {
					childIndex = node[2];
					node = node[3];
					task.replay = {
						nodes: childIndex,
						slots: node,
						pendingTasks: 1
					};
					try {
						renderChildrenArray$1(request, task, children, -1);
						if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length) throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
						task.replay.pendingTasks--;
					} catch (x) {
						if ("object" === typeof x && null !== x && (x === SuspenseException$1 || "function" === typeof x.then)) throw x;
						task.replay.pendingTasks--;
						children = getThrownInfo$1(task.componentStack);
						var boundary = task.blockedBoundary, error = x;
						children = logRecoverableError$1(request, error, children);
						abortRemainingReplayNodes$1(request, boundary, childIndex, node, error, children);
					}
					task.replay = replay;
					replayNodes.splice(j, 1);
					break;
				}
			}
			task.keyPath = prevKeyPath;
			return;
		}
		replay = task.treeContext;
		replayNodes = children.length;
		if (null !== task.replay && (j = task.replay.slots, null !== j && "object" === typeof j)) {
			for (childIndex = 0; childIndex < replayNodes; childIndex++) node = children[childIndex], task.treeContext = pushTreeContext$1(replay, replayNodes, childIndex), boundary = j[childIndex], "number" === typeof boundary ? (resumeNode$1(request, task, boundary, node, childIndex), delete j[childIndex]) : renderNode$1(request, task, node, childIndex);
			task.treeContext = replay;
			task.keyPath = prevKeyPath;
			return;
		}
		for (j = 0; j < replayNodes; j++) childIndex = children[j], task.treeContext = pushTreeContext$1(replay, replayNodes, j), renderNode$1(request, task, childIndex, j);
		task.treeContext = replay;
		task.keyPath = prevKeyPath;
	}
	function trackPostponedBoundary$1(request, trackedPostpones, boundary) {
		boundary.status = 5;
		boundary.rootSegmentID = request.nextSegmentId++;
		request = boundary.trackedContentKeyPath;
		if (null === request) throw Error("It should not be possible to postpone at the root. This is a bug in React.");
		var fallbackReplayNode = boundary.trackedFallbackNode, children = [], boundaryNode = trackedPostpones.workingMap.get(request);
		if (void 0 === boundaryNode) return boundary = [
			request[1],
			request[2],
			children,
			null,
			fallbackReplayNode,
			boundary.rootSegmentID
		], trackedPostpones.workingMap.set(request, boundary), addToReplayParent$1(boundary, request[0], trackedPostpones), boundary;
		boundaryNode[4] = fallbackReplayNode;
		boundaryNode[5] = boundary.rootSegmentID;
		return boundaryNode;
	}
	function trackPostpone$1(request, trackedPostpones, task, segment) {
		segment.status = 5;
		var keyPath = task.keyPath, boundary = task.blockedBoundary;
		if (null === boundary) segment.id = request.nextSegmentId++, trackedPostpones.rootSlots = segment.id, null !== request.completedRootSegment && (request.completedRootSegment.status = 5);
		else {
			if (null !== boundary && 0 === boundary.status) {
				var boundaryNode = trackPostponedBoundary$1(request, trackedPostpones, boundary);
				if (boundary.trackedContentKeyPath === keyPath && -1 === task.childIndex) {
					-1 === segment.id && (segment.id = segment.parentFlushed ? boundary.rootSegmentID : request.nextSegmentId++);
					boundaryNode[3] = segment.id;
					return;
				}
			}
			-1 === segment.id && (segment.id = segment.parentFlushed && null !== boundary ? boundary.rootSegmentID : request.nextSegmentId++);
			if (-1 === task.childIndex) null === keyPath ? trackedPostpones.rootSlots = segment.id : (task = trackedPostpones.workingMap.get(keyPath), void 0 === task ? (task = [
				keyPath[1],
				keyPath[2],
				[],
				segment.id
			], addToReplayParent$1(task, keyPath[0], trackedPostpones)) : task[3] = segment.id);
			else {
				if (null === keyPath) {
					if (request = trackedPostpones.rootSlots, null === request) request = trackedPostpones.rootSlots = {};
					else if ("number" === typeof request) throw Error("It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.");
				} else if (boundary = trackedPostpones.workingMap, boundaryNode = boundary.get(keyPath), void 0 === boundaryNode) request = {}, boundaryNode = [
					keyPath[1],
					keyPath[2],
					[],
					request
				], boundary.set(keyPath, boundaryNode), addToReplayParent$1(boundaryNode, keyPath[0], trackedPostpones);
				else if (request = boundaryNode[3], null === request) request = boundaryNode[3] = {};
				else if ("number" === typeof request) throw Error("It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.");
				request[task.childIndex] = segment.id;
			}
		}
	}
	function untrackBoundary$1(request, boundary) {
		request = request.trackedPostpones;
		null !== request && (boundary = boundary.trackedContentKeyPath, null !== boundary && (boundary = request.workingMap.get(boundary), void 0 !== boundary && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));
	}
	function spawnNewSuspendedReplayTask$1(request, task, thenableState$2) {
		return createReplayTask$1(request, thenableState$2, task.replay, task.node, task.childIndex, task.blockedBoundary, task.hoistableState, task.abortSet, task.keyPath, task.formatContext, task.context, task.treeContext, task.row, task.componentStack);
	}
	function spawnNewSuspendedRenderTask$1(request, task, thenableState$2) {
		var segment = task.blockedSegment, newSegment = createPendingSegment$1(request, segment.chunks.length, null, task.formatContext, segment.lastPushedText, !0);
		segment.children.push(newSegment);
		segment.lastPushedText = !1;
		return createRenderTask$1(request, thenableState$2, task.node, task.childIndex, task.blockedBoundary, newSegment, task.blockedPreamble, task.hoistableState, task.abortSet, task.keyPath, task.formatContext, task.context, task.treeContext, task.row, task.componentStack);
	}
	function renderNode$1(request, task, node, childIndex) {
		var previousFormatContext = task.formatContext, previousContext = task.context, previousKeyPath = task.keyPath, previousTreeContext = task.treeContext, previousComponentStack = task.componentStack, segment = task.blockedSegment;
		if (null === segment) {
			segment = task.replay;
			try {
				return renderNodeDestructive$1(request, task, node, childIndex);
			} catch (thrownValue) {
				if (resetHooksState$1(), node = thrownValue === SuspenseException$1 ? getSuspendedThenable$1() : thrownValue, 12 !== request.status && "object" === typeof node && null !== node) {
					if ("function" === typeof node.then) {
						childIndex = thrownValue === SuspenseException$1 ? getThenableStateAfterSuspending$1() : null;
						request = spawnNewSuspendedReplayTask$1(request, task, childIndex).ping;
						node.then(request, request);
						task.formatContext = previousFormatContext;
						task.context = previousContext;
						task.keyPath = previousKeyPath;
						task.treeContext = previousTreeContext;
						task.componentStack = previousComponentStack;
						task.replay = segment;
						switchContext$1(previousContext);
						return;
					}
					if ("Maximum call stack size exceeded" === node.message) {
						node = thrownValue === SuspenseException$1 ? getThenableStateAfterSuspending$1() : null;
						node = spawnNewSuspendedReplayTask$1(request, task, node);
						request.pingedTasks.push(node);
						task.formatContext = previousFormatContext;
						task.context = previousContext;
						task.keyPath = previousKeyPath;
						task.treeContext = previousTreeContext;
						task.componentStack = previousComponentStack;
						task.replay = segment;
						switchContext$1(previousContext);
						return;
					}
				}
			}
		} else {
			var childrenLength = segment.children.length, chunkLength = segment.chunks.length;
			try {
				return renderNodeDestructive$1(request, task, node, childIndex);
			} catch (thrownValue$62) {
				if (resetHooksState$1(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node = thrownValue$62 === SuspenseException$1 ? getSuspendedThenable$1() : thrownValue$62, 12 !== request.status && "object" === typeof node && null !== node) {
					if ("function" === typeof node.then) {
						segment = node;
						node = thrownValue$62 === SuspenseException$1 ? getThenableStateAfterSuspending$1() : null;
						request = spawnNewSuspendedRenderTask$1(request, task, node).ping;
						segment.then(request, request);
						task.formatContext = previousFormatContext;
						task.context = previousContext;
						task.keyPath = previousKeyPath;
						task.treeContext = previousTreeContext;
						task.componentStack = previousComponentStack;
						switchContext$1(previousContext);
						return;
					}
					if ("Maximum call stack size exceeded" === node.message) {
						segment = thrownValue$62 === SuspenseException$1 ? getThenableStateAfterSuspending$1() : null;
						segment = spawnNewSuspendedRenderTask$1(request, task, segment);
						request.pingedTasks.push(segment);
						task.formatContext = previousFormatContext;
						task.context = previousContext;
						task.keyPath = previousKeyPath;
						task.treeContext = previousTreeContext;
						task.componentStack = previousComponentStack;
						switchContext$1(previousContext);
						return;
					}
				}
			}
		}
		task.formatContext = previousFormatContext;
		task.context = previousContext;
		task.keyPath = previousKeyPath;
		task.treeContext = previousTreeContext;
		switchContext$1(previousContext);
		throw node;
	}
	function abortTaskSoft$1(task) {
		var boundary = task.blockedBoundary, segment = task.blockedSegment;
		null !== segment && (segment.status = 3, finishedTask$1(this, boundary, task.row, segment));
	}
	function abortRemainingReplayNodes$1(request$jscomp$0, boundary, nodes, slots, error, errorDigest$jscomp$0) {
		for (var i = 0; i < nodes.length; i++) {
			var node = nodes[i];
			if (4 === node.length) abortRemainingReplayNodes$1(request$jscomp$0, boundary, node[2], node[3], error, errorDigest$jscomp$0);
			else {
				node = node[5];
				var request = request$jscomp$0, errorDigest = errorDigest$jscomp$0, resumedBoundary = createSuspenseBoundary$1(request, null, /* @__PURE__ */ new Set(), null, null);
				resumedBoundary.parentFlushed = !0;
				resumedBoundary.rootSegmentID = node;
				resumedBoundary.status = 4;
				resumedBoundary.errorDigest = errorDigest;
				resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);
			}
		}
		nodes.length = 0;
		if (null !== slots) {
			if (null === boundary) throw Error("We should not have any resumable nodes in the shell. This is a bug in React.");
			4 !== boundary.status && (boundary.status = 4, boundary.errorDigest = errorDigest$jscomp$0, boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));
			if ("object" === typeof slots) for (var index in slots) delete slots[index];
		}
	}
	function abortTask$1(task, request, error) {
		var boundary = task.blockedBoundary, segment = task.blockedSegment;
		if (null !== segment) {
			if (6 === segment.status) return;
			segment.status = 3;
		}
		var errorInfo = getThrownInfo$1(task.componentStack);
		if (null === boundary) {
			if (13 !== request.status && 14 !== request.status) {
				boundary = task.replay;
				if (null === boundary) {
					null !== request.trackedPostpones && null !== segment ? (boundary = request.trackedPostpones, logRecoverableError$1(request, error, errorInfo), trackPostpone$1(request, boundary, task, segment), finishedTask$1(request, null, task.row, segment)) : (logRecoverableError$1(request, error, errorInfo), fatalError$1(request, error));
					return;
				}
				boundary.pendingTasks--;
				0 === boundary.pendingTasks && 0 < boundary.nodes.length && (segment = logRecoverableError$1(request, error, errorInfo), abortRemainingReplayNodes$1(request, null, boundary.nodes, boundary.slots, error, segment));
				request.pendingRootTasks--;
				0 === request.pendingRootTasks && completeShell$1(request);
			}
		} else {
			var trackedPostpones$63 = request.trackedPostpones;
			if (4 !== boundary.status) {
				if (null !== trackedPostpones$63 && null !== segment) return logRecoverableError$1(request, error, errorInfo), trackPostpone$1(request, trackedPostpones$63, task, segment), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
					return abortTask$1(fallbackTask, request, error);
				}), boundary.fallbackAbortableTasks.clear(), finishedTask$1(request, boundary, task.row, segment);
				boundary.status = 4;
				segment = logRecoverableError$1(request, error, errorInfo);
				boundary.status = 4;
				boundary.errorDigest = segment;
				untrackBoundary$1(request, boundary);
				boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);
			}
			boundary.pendingTasks--;
			segment = boundary.row;
			null !== segment && 0 === --segment.pendingTasks && finishSuspenseListRow$1(request, segment);
			boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
				return abortTask$1(fallbackTask, request, error);
			});
			boundary.fallbackAbortableTasks.clear();
		}
		task = task.row;
		null !== task && 0 === --task.pendingTasks && finishSuspenseListRow$1(request, task);
		request.allPendingTasks--;
		0 === request.allPendingTasks && completeAll$1(request);
	}
	function safelyEmitEarlyPreloads$1(request, shellComplete) {
		try {
			var renderState = request.renderState, onHeaders = renderState.onHeaders;
			if (onHeaders) {
				var headers = renderState.headers;
				if (headers) {
					renderState.headers = null;
					var linkHeader = headers.preconnects;
					headers.fontPreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.fontPreloads);
					headers.highImagePreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.highImagePreloads);
					if (!shellComplete) {
						var queueIter = renderState.styles.values(), queueStep = queueIter.next();
						b: for (; 0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next()) for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next(); 0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {
							var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props, header = getPreloadAsHeader$1(props$jscomp$0.href, "style", {
								crossOrigin: props$jscomp$0.crossOrigin,
								integrity: props$jscomp$0.integrity,
								nonce: props$jscomp$0.nonce,
								type: props$jscomp$0.type,
								fetchPriority: props$jscomp$0.fetchPriority,
								referrerPolicy: props$jscomp$0.referrerPolicy,
								media: props$jscomp$0.media
							});
							if (0 <= (headers.remainingCapacity -= header.length + 2)) renderState.resets.style[key] = PRELOAD_NO_CREDS$1, linkHeader && (linkHeader += ", "), linkHeader += header, renderState.resets.style[key] = "string" === typeof props.crossOrigin || "string" === typeof props.integrity ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS$1;
							else break b;
						}
					}
					linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});
				}
			}
		} catch (error) {
			logRecoverableError$1(request, error, {});
		}
	}
	function completeShell$1(request) {
		null === request.trackedPostpones && safelyEmitEarlyPreloads$1(request, !0);
		null === request.trackedPostpones && preparePreamble$1(request);
		request.onShellError = noop$1;
		request = request.onShellReady;
		request();
	}
	function completeAll$1(request) {
		safelyEmitEarlyPreloads$1(request, null === request.trackedPostpones ? !0 : null === request.completedRootSegment || 5 !== request.completedRootSegment.status);
		preparePreamble$1(request);
		request = request.onAllReady;
		request();
	}
	function queueCompletedSegment$1(boundary, segment) {
		if (0 === segment.chunks.length && 1 === segment.children.length && null === segment.children[0].boundary && -1 === segment.children[0].id) {
			var childSegment = segment.children[0];
			childSegment.id = segment.id;
			childSegment.parentFlushed = !0;
			1 !== childSegment.status && 3 !== childSegment.status && 4 !== childSegment.status || queueCompletedSegment$1(boundary, childSegment);
		} else boundary.completedSegments.push(segment);
	}
	function finishedTask$1(request, boundary, row, segment) {
		null !== row && (0 === --row.pendingTasks ? finishSuspenseListRow$1(request, row) : row.together && tryToResolveTogetherRow$1(request, row));
		request.allPendingTasks--;
		if (null === boundary) {
			if (null !== segment && segment.parentFlushed) {
				if (null !== request.completedRootSegment) throw Error("There can only be one root segment. This is a bug in React.");
				request.completedRootSegment = segment;
			}
			request.pendingRootTasks--;
			0 === request.pendingRootTasks && completeShell$1(request);
		} else if (boundary.pendingTasks--, 4 !== boundary.status) if (0 === boundary.pendingTasks) {
			if (0 === boundary.status && (boundary.status = 1), null !== segment && segment.parentFlushed && (1 === segment.status || 3 === segment.status) && queueCompletedSegment$1(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), 1 === boundary.status) row = boundary.row, null !== row && hoistHoistables$1(row.hoistables, boundary.contentState), isEligibleForOutlining$1(request, boundary) || (boundary.fallbackAbortableTasks.forEach(abortTaskSoft$1, request), boundary.fallbackAbortableTasks.clear(), null !== row && 0 === --row.pendingTasks && finishSuspenseListRow$1(request, row)), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary.contentPreamble && preparePreamble$1(request);
			else if (5 === boundary.status && (boundary = boundary.row, null !== boundary)) {
				if (null !== request.trackedPostpones) {
					row = request.trackedPostpones;
					var postponedRow = boundary.next;
					if (null !== postponedRow && (segment = postponedRow.boundaries, null !== segment)) for (postponedRow.boundaries = null, postponedRow = 0; postponedRow < segment.length; postponedRow++) {
						var postponedBoundary = segment[postponedRow];
						trackPostponedBoundary$1(request, row, postponedBoundary);
						finishedTask$1(request, postponedBoundary, null, null);
					}
				}
				0 === --boundary.pendingTasks && finishSuspenseListRow$1(request, boundary);
			}
		} else null === segment || !segment.parentFlushed || 1 !== segment.status && 3 !== segment.status || (queueCompletedSegment$1(boundary, segment), 1 === boundary.completedSegments.length && boundary.parentFlushed && request.partialBoundaries.push(boundary)), boundary = boundary.row, null !== boundary && boundary.together && tryToResolveTogetherRow$1(request, boundary);
		0 === request.allPendingTasks && completeAll$1(request);
	}
	function performWork$1(request$jscomp$2) {
		if (14 !== request$jscomp$2.status && 13 !== request$jscomp$2.status) {
			var prevContext = currentActiveSnapshot$1, prevDispatcher = ReactSharedInternals$1.H;
			ReactSharedInternals$1.H = HooksDispatcher$1;
			var prevAsyncDispatcher = ReactSharedInternals$1.A;
			ReactSharedInternals$1.A = DefaultAsyncDispatcher$1;
			var prevRequest = currentRequest$1;
			currentRequest$1 = request$jscomp$2;
			var prevResumableState = currentResumableState$1;
			currentResumableState$1 = request$jscomp$2.resumableState;
			try {
				var pingedTasks = request$jscomp$2.pingedTasks, i;
				for (i = 0; i < pingedTasks.length; i++) {
					var task = pingedTasks[i], request = request$jscomp$2, segment = task.blockedSegment;
					if (null === segment) {
						var request$jscomp$0 = request;
						if (0 !== task.replay.pendingTasks) {
							switchContext$1(task.context);
							try {
								"number" === typeof task.replay.slots ? resumeNode$1(request$jscomp$0, task, task.replay.slots, task.node, task.childIndex) : retryNode$1(request$jscomp$0, task);
								if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length) throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
								task.replay.pendingTasks--;
								task.abortSet.delete(task);
								finishedTask$1(request$jscomp$0, task.blockedBoundary, task.row, null);
							} catch (thrownValue) {
								resetHooksState$1();
								var x = thrownValue === SuspenseException$1 ? getSuspendedThenable$1() : thrownValue;
								if ("object" === typeof x && null !== x && "function" === typeof x.then) {
									var ping = task.ping;
									x.then(ping, ping);
									task.thenableState = thrownValue === SuspenseException$1 ? getThenableStateAfterSuspending$1() : null;
								} else {
									task.replay.pendingTasks--;
									task.abortSet.delete(task);
									var errorInfo = getThrownInfo$1(task.componentStack);
									request = void 0;
									var request$jscomp$1 = request$jscomp$0, boundary = task.blockedBoundary, error$jscomp$0 = 12 === request$jscomp$0.status ? request$jscomp$0.fatalError : x, replayNodes = task.replay.nodes, resumeSlots = task.replay.slots;
									request = logRecoverableError$1(request$jscomp$1, error$jscomp$0, errorInfo);
									abortRemainingReplayNodes$1(request$jscomp$1, boundary, replayNodes, resumeSlots, error$jscomp$0, request);
									request$jscomp$0.pendingRootTasks--;
									0 === request$jscomp$0.pendingRootTasks && completeShell$1(request$jscomp$0);
									request$jscomp$0.allPendingTasks--;
									0 === request$jscomp$0.allPendingTasks && completeAll$1(request$jscomp$0);
								}
							}
						}
					} else if (request$jscomp$0 = void 0, request$jscomp$1 = segment, 0 === request$jscomp$1.status) {
						request$jscomp$1.status = 6;
						switchContext$1(task.context);
						var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;
						try {
							retryNode$1(request, task), pushSegmentFinale(request$jscomp$1.chunks, request.renderState, request$jscomp$1.lastPushedText, request$jscomp$1.textEmbedded), task.abortSet.delete(task), request$jscomp$1.status = 1, finishedTask$1(request, task.blockedBoundary, task.row, request$jscomp$1);
						} catch (thrownValue) {
							resetHooksState$1();
							request$jscomp$1.children.length = childrenLength;
							request$jscomp$1.chunks.length = chunkLength;
							var x$jscomp$0 = thrownValue === SuspenseException$1 ? getSuspendedThenable$1() : 12 === request.status ? request.fatalError : thrownValue;
							if (12 === request.status && null !== request.trackedPostpones) {
								var trackedPostpones = request.trackedPostpones, thrownInfo = getThrownInfo$1(task.componentStack);
								task.abortSet.delete(task);
								logRecoverableError$1(request, x$jscomp$0, thrownInfo);
								trackPostpone$1(request, trackedPostpones, task, request$jscomp$1);
								finishedTask$1(request, task.blockedBoundary, task.row, request$jscomp$1);
							} else if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0 && "function" === typeof x$jscomp$0.then) {
								request$jscomp$1.status = 0;
								task.thenableState = thrownValue === SuspenseException$1 ? getThenableStateAfterSuspending$1() : null;
								var ping$jscomp$0 = task.ping;
								x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
							} else {
								var errorInfo$jscomp$0 = getThrownInfo$1(task.componentStack);
								task.abortSet.delete(task);
								request$jscomp$1.status = 4;
								var boundary$jscomp$0 = task.blockedBoundary, row = task.row;
								null !== row && 0 === --row.pendingTasks && finishSuspenseListRow$1(request, row);
								request.allPendingTasks--;
								request$jscomp$0 = logRecoverableError$1(request, x$jscomp$0, errorInfo$jscomp$0);
								if (null === boundary$jscomp$0) fatalError$1(request, x$jscomp$0);
								else if (boundary$jscomp$0.pendingTasks--, 4 !== boundary$jscomp$0.status) {
									boundary$jscomp$0.status = 4;
									boundary$jscomp$0.errorDigest = request$jscomp$0;
									untrackBoundary$1(request, boundary$jscomp$0);
									var boundaryRow = boundary$jscomp$0.row;
									null !== boundaryRow && 0 === --boundaryRow.pendingTasks && finishSuspenseListRow$1(request, boundaryRow);
									boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(boundary$jscomp$0);
									0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary$jscomp$0.contentPreamble && preparePreamble$1(request);
								}
								0 === request.allPendingTasks && completeAll$1(request);
							}
						}
					}
				}
				pingedTasks.splice(0, i);
				null !== request$jscomp$2.destination && flushCompletedQueues$1(request$jscomp$2, request$jscomp$2.destination);
			} catch (error) {
				logRecoverableError$1(request$jscomp$2, error, {}), fatalError$1(request$jscomp$2, error);
			} finally {
				currentResumableState$1 = prevResumableState, ReactSharedInternals$1.H = prevDispatcher, ReactSharedInternals$1.A = prevAsyncDispatcher, prevDispatcher === HooksDispatcher$1 && switchContext$1(prevContext), currentRequest$1 = prevRequest;
			}
		}
	}
	function preparePreambleFromSubtree$1(request, segment, collectedPreambleSegments) {
		segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);
		for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++) pendingPreambles = preparePreambleFromSegment$1(request, segment.children[i], collectedPreambleSegments) || pendingPreambles;
		return pendingPreambles;
	}
	function preparePreambleFromSegment$1(request, segment, collectedPreambleSegments) {
		var boundary = segment.boundary;
		if (null === boundary) return preparePreambleFromSubtree$1(request, segment, collectedPreambleSegments);
		var preamble = boundary.contentPreamble, fallbackPreamble = boundary.fallbackPreamble;
		if (null === preamble || null === fallbackPreamble) return !1;
		switch (boundary.status) {
			case 1:
				hoistPreambleState$1(request.renderState, preamble);
				request.byteSize += boundary.byteSize;
				segment = boundary.completedSegments[0];
				if (!segment) throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
				return preparePreambleFromSubtree$1(request, segment, collectedPreambleSegments);
			case 5: if (null !== request.trackedPostpones) return !0;
			case 4: if (1 === segment.status) return hoistPreambleState$1(request.renderState, fallbackPreamble), preparePreambleFromSubtree$1(request, segment, collectedPreambleSegments);
			default: return !0;
		}
	}
	function preparePreamble$1(request) {
		if (request.completedRootSegment && null === request.completedPreambleSegments) {
			var collectedPreambleSegments = [], originalRequestByteSize = request.byteSize, hasPendingPreambles = preparePreambleFromSegment$1(request, request.completedRootSegment, collectedPreambleSegments), preamble = request.renderState.preamble;
			!1 === hasPendingPreambles || preamble.headChunks && preamble.bodyChunks ? request.completedPreambleSegments = collectedPreambleSegments : request.byteSize = originalRequestByteSize;
		}
	}
	function flushSubtree$1(request, destination, segment, hoistableState) {
		segment.parentFlushed = !0;
		switch (segment.status) {
			case 0: segment.id = request.nextSegmentId++;
			case 5: return hoistableState = segment.id, segment.lastPushedText = !1, segment.textEmbedded = !1, request = request.renderState, destination.push("<template id=\""), destination.push(request.placeholderPrefix), request = hoistableState.toString(16), destination.push(request), destination.push("\"></template>");
			case 1:
				segment.status = 2;
				var r = !0, chunks = segment.chunks, chunkIdx = 0;
				segment = segment.children;
				for (var childIdx = 0; childIdx < segment.length; childIdx++) {
					for (r = segment[childIdx]; chunkIdx < r.index; chunkIdx++) destination.push(chunks[chunkIdx]);
					r = flushSegment$1(request, destination, r, hoistableState);
				}
				for (; chunkIdx < chunks.length - 1; chunkIdx++) destination.push(chunks[chunkIdx]);
				chunkIdx < chunks.length && (r = destination.push(chunks[chunkIdx]));
				return r;
			case 3: return !0;
			default: throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
		}
	}
	var flushedByteSize$1 = 0;
	function flushSegment$1(request, destination, segment, hoistableState) {
		var boundary = segment.boundary;
		if (null === boundary) return flushSubtree$1(request, destination, segment, hoistableState);
		boundary.parentFlushed = !0;
		if (4 === boundary.status) {
			var row = boundary.row;
			null !== row && 0 === --row.pendingTasks && finishSuspenseListRow$1(request, row);
			request.renderState.generateStaticMarkup || (boundary = boundary.errorDigest, destination.push("<!--$!-->"), destination.push("<template"), boundary && (destination.push(" data-dgst=\""), boundary = escapeTextForBrowser$1(boundary), destination.push(boundary), destination.push("\"")), destination.push("></template>"));
			flushSubtree$1(request, destination, segment, hoistableState);
			request = request.renderState.generateStaticMarkup ? !0 : destination.push("<!--/$-->");
			return request;
		}
		if (1 !== boundary.status) return 0 === boundary.status && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary$1(destination, request.renderState, boundary.rootSegmentID), hoistableState && hoistHoistables$1(hoistableState, boundary.fallbackState), flushSubtree$1(request, destination, segment, hoistableState), destination.push("<!--/$-->");
		if (!flushingPartialBoundaries$1 && isEligibleForOutlining$1(request, boundary) && flushedByteSize$1 + boundary.byteSize > request.progressiveChunkSize) return boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary$1(destination, request.renderState, boundary.rootSegmentID), flushSubtree$1(request, destination, segment, hoistableState), destination.push("<!--/$-->");
		flushedByteSize$1 += boundary.byteSize;
		hoistableState && hoistHoistables$1(hoistableState, boundary.contentState);
		segment = boundary.row;
		null !== segment && isEligibleForOutlining$1(request, boundary) && 0 === --segment.pendingTasks && finishSuspenseListRow$1(request, segment);
		request.renderState.generateStaticMarkup || destination.push("<!--$-->");
		segment = boundary.completedSegments;
		if (1 !== segment.length) throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
		flushSegment$1(request, destination, segment[0], hoistableState);
		request = request.renderState.generateStaticMarkup ? !0 : destination.push("<!--/$-->");
		return request;
	}
	function flushSegmentContainer$1(request, destination, segment, hoistableState) {
		writeStartSegment$1(destination, request.renderState, segment.parentFormatContext, segment.id);
		flushSegment$1(request, destination, segment, hoistableState);
		return writeEndSegment$1(destination, segment.parentFormatContext);
	}
	function flushCompletedBoundary$1(request, destination, boundary) {
		flushedByteSize$1 = boundary.byteSize;
		for (var completedSegments = boundary.completedSegments, i = 0; i < completedSegments.length; i++) flushPartiallyCompletedSegment$1(request, destination, boundary, completedSegments[i]);
		completedSegments.length = 0;
		completedSegments = boundary.row;
		null !== completedSegments && isEligibleForOutlining$1(request, boundary) && 0 === --completedSegments.pendingTasks && finishSuspenseListRow$1(request, completedSegments);
		writeHoistablesForBoundary$1(destination, boundary.contentState, request.renderState);
		completedSegments = request.resumableState;
		request = request.renderState;
		i = boundary.rootSegmentID;
		boundary = boundary.contentState;
		var requiresStyleInsertion = request.stylesToHoist;
		request.stylesToHoist = !1;
		destination.push(request.startInlineScript);
		destination.push(">");
		requiresStyleInsertion ? (0 === (completedSegments.instructions & 4) && (completedSegments.instructions |= 4, destination.push("$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};")), 0 === (completedSegments.instructions & 2) && (completedSegments.instructions |= 2, destination.push("$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if(\"/$\"===d||\"/&\"===d)if(0===h)break;else h--;else\"$\"!==d&&\"$?\"!==d&&\"$~\"!==d&&\"$!\"!==d&&\"&\"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data=\"$\";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};\n$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data=\"$~\",$RB.push(a,b),2===$RB.length&&(\"number\"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};")), 0 === (completedSegments.instructions & 8) ? (completedSegments.instructions |= 8, destination.push("$RM=new Map;$RR=function(n,w,p){function u(q){this._p=null;q()}for(var r=new Map,t=document,h,b,e=t.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),v=[],k=0;b=e[k++];)\"not all\"===b.getAttribute(\"media\")?v.push(b):(\"LINK\"===b.tagName&&$RM.set(b.getAttribute(\"href\"),b),r.set(b.dataset.precedence,h=b));e=0;b=[];var l,a;for(k=!0;;){if(k){var f=p[e++];if(!f){k=!1;e=0;continue}var c=!1,m=0;var d=f[m++];if(a=$RM.get(d)){var g=a._p;c=!0}else{a=t.createElement(\"link\");a.href=d;a.rel=\n\"stylesheet\";for(a.dataset.precedence=l=f[m++];g=f[m++];)a.setAttribute(g,f[m++]);g=a._p=new Promise(function(q,x){a.onload=u.bind(a,q);a.onerror=u.bind(a,x)});$RM.set(d,a)}d=a.getAttribute(\"media\");!g||d&&!matchMedia(d).matches||b.push(g);if(c)continue}else{a=v[e++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=r.get(l)||h;c===h&&(h=a);r.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=t.head,c.insertBefore(a,c.firstChild))}if(p=document.getElementById(n))p.previousSibling.data=\n\"$~\";Promise.all(b).then($RC.bind(null,n,w),$RX.bind(null,n,\"CSS failed to load\"))};$RR(\"")) : destination.push("$RR(\"")) : (0 === (completedSegments.instructions & 2) && (completedSegments.instructions |= 2, destination.push("$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if(\"/$\"===d||\"/&\"===d)if(0===h)break;else h--;else\"$\"!==d&&\"$?\"!==d&&\"$~\"!==d&&\"$!\"!==d&&\"&\"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data=\"$\";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};\n$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data=\"$~\",$RB.push(a,b),2===$RB.length&&(\"number\"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};")), destination.push("$RC(\""));
		completedSegments = i.toString(16);
		destination.push(request.boundaryPrefix);
		destination.push(completedSegments);
		destination.push("\",\"");
		destination.push(request.segmentPrefix);
		destination.push(completedSegments);
		requiresStyleInsertion ? (destination.push("\","), writeStyleResourceDependenciesInJS$1(destination, boundary)) : destination.push("\"");
		boundary = destination.push(")<\/script>");
		return writeBootstrap$1(destination, request) && boundary;
	}
	function flushPartiallyCompletedSegment$1(request, destination, boundary, segment) {
		if (2 === segment.status) return !0;
		var hoistableState = boundary.contentState, segmentID = segment.id;
		if (-1 === segmentID) {
			if (-1 === (segment.id = boundary.rootSegmentID)) throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
			return flushSegmentContainer$1(request, destination, segment, hoistableState);
		}
		if (segmentID === boundary.rootSegmentID) return flushSegmentContainer$1(request, destination, segment, hoistableState);
		flushSegmentContainer$1(request, destination, segment, hoistableState);
		boundary = request.resumableState;
		request = request.renderState;
		destination.push(request.startInlineScript);
		destination.push(">");
		0 === (boundary.instructions & 1) ? (boundary.instructions |= 1, destination.push("$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(\"")) : destination.push("$RS(\"");
		destination.push(request.segmentPrefix);
		segmentID = segmentID.toString(16);
		destination.push(segmentID);
		destination.push("\",\"");
		destination.push(request.placeholderPrefix);
		destination.push(segmentID);
		destination = destination.push("\")<\/script>");
		return destination;
	}
	var flushingPartialBoundaries$1 = !1;
	function flushCompletedQueues$1(request, destination) {
		try {
			if (!(0 < request.pendingRootTasks)) {
				var i, completedRootSegment = request.completedRootSegment;
				if (null !== completedRootSegment) {
					if (5 === completedRootSegment.status) return;
					var completedPreambleSegments = request.completedPreambleSegments;
					if (null === completedPreambleSegments) return;
					flushedByteSize$1 = request.byteSize;
					var resumableState = request.resumableState, renderState = request.renderState, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;
					if (htmlChunks) {
						for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++) destination.push(htmlChunks[i$jscomp$0]);
						if (headChunks) for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++) destination.push(headChunks[i$jscomp$0]);
						else {
							var chunk = startChunkForTag$1("head");
							destination.push(chunk);
							destination.push(">");
						}
					} else if (headChunks) for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++) destination.push(headChunks[i$jscomp$0]);
					var charsetChunks = renderState.charsetChunks;
					for (i$jscomp$0 = 0; i$jscomp$0 < charsetChunks.length; i$jscomp$0++) destination.push(charsetChunks[i$jscomp$0]);
					charsetChunks.length = 0;
					renderState.preconnects.forEach(flushResource$1, destination);
					renderState.preconnects.clear();
					var viewportChunks = renderState.viewportChunks;
					for (i$jscomp$0 = 0; i$jscomp$0 < viewportChunks.length; i$jscomp$0++) destination.push(viewportChunks[i$jscomp$0]);
					viewportChunks.length = 0;
					renderState.fontPreloads.forEach(flushResource$1, destination);
					renderState.fontPreloads.clear();
					renderState.highImagePreloads.forEach(flushResource$1, destination);
					renderState.highImagePreloads.clear();
					currentlyFlushingRenderState$1 = renderState;
					renderState.styles.forEach(flushStylesInPreamble$1, destination);
					currentlyFlushingRenderState$1 = null;
					var importMapChunks = renderState.importMapChunks;
					for (i$jscomp$0 = 0; i$jscomp$0 < importMapChunks.length; i$jscomp$0++) destination.push(importMapChunks[i$jscomp$0]);
					importMapChunks.length = 0;
					renderState.bootstrapScripts.forEach(flushResource$1, destination);
					renderState.scripts.forEach(flushResource$1, destination);
					renderState.scripts.clear();
					renderState.bulkPreloads.forEach(flushResource$1, destination);
					renderState.bulkPreloads.clear();
					resumableState.instructions |= 32;
					var hoistableChunks = renderState.hoistableChunks;
					for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++) destination.push(hoistableChunks[i$jscomp$0]);
					for (resumableState = hoistableChunks.length = 0; resumableState < completedPreambleSegments.length; resumableState++) {
						var segments = completedPreambleSegments[resumableState];
						for (renderState = 0; renderState < segments.length; renderState++) flushSegment$1(request, destination, segments[renderState], null);
					}
					var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
					if (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) {
						var chunk$jscomp$0 = endChunkForTag$1("head");
						destination.push(chunk$jscomp$0);
					}
					var bodyChunks = preamble$jscomp$0.bodyChunks;
					if (bodyChunks) for (completedPreambleSegments = 0; completedPreambleSegments < bodyChunks.length; completedPreambleSegments++) destination.push(bodyChunks[completedPreambleSegments]);
					flushSegment$1(request, destination, completedRootSegment, null);
					request.completedRootSegment = null;
					var renderState$jscomp$0 = request.renderState;
					if (0 !== request.allPendingTasks || 0 !== request.clientRenderedBoundaries.length || 0 !== request.completedBoundaries.length || null !== request.trackedPostpones && (0 !== request.trackedPostpones.rootNodes.length || null !== request.trackedPostpones.rootSlots)) {
						var resumableState$jscomp$0 = request.resumableState;
						if (0 === (resumableState$jscomp$0.instructions & 64)) {
							resumableState$jscomp$0.instructions |= 64;
							destination.push(renderState$jscomp$0.startInlineScript);
							if (0 === (resumableState$jscomp$0.instructions & 32)) {
								resumableState$jscomp$0.instructions |= 32;
								var shellId = "_" + resumableState$jscomp$0.idPrefix + "R_";
								destination.push(" id=\"");
								var chunk$jscomp$1 = escapeTextForBrowser$1(shellId);
								destination.push(chunk$jscomp$1);
								destination.push("\"");
							}
							destination.push(">");
							destination.push("requestAnimationFrame(function(){$RT=performance.now()});");
							destination.push("<\/script>");
						}
					}
					writeBootstrap$1(destination, renderState$jscomp$0);
				}
				var renderState$jscomp$1 = request.renderState;
				completedRootSegment = 0;
				var viewportChunks$jscomp$0 = renderState$jscomp$1.viewportChunks;
				for (completedRootSegment = 0; completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++) destination.push(viewportChunks$jscomp$0[completedRootSegment]);
				viewportChunks$jscomp$0.length = 0;
				renderState$jscomp$1.preconnects.forEach(flushResource$1, destination);
				renderState$jscomp$1.preconnects.clear();
				renderState$jscomp$1.fontPreloads.forEach(flushResource$1, destination);
				renderState$jscomp$1.fontPreloads.clear();
				renderState$jscomp$1.highImagePreloads.forEach(flushResource$1, destination);
				renderState$jscomp$1.highImagePreloads.clear();
				renderState$jscomp$1.styles.forEach(preloadLateStyles$1, destination);
				renderState$jscomp$1.scripts.forEach(flushResource$1, destination);
				renderState$jscomp$1.scripts.clear();
				renderState$jscomp$1.bulkPreloads.forEach(flushResource$1, destination);
				renderState$jscomp$1.bulkPreloads.clear();
				var hoistableChunks$jscomp$0 = renderState$jscomp$1.hoistableChunks;
				for (completedRootSegment = 0; completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++) destination.push(hoistableChunks$jscomp$0[completedRootSegment]);
				hoistableChunks$jscomp$0.length = 0;
				var clientRenderedBoundaries = request.clientRenderedBoundaries;
				for (i = 0; i < clientRenderedBoundaries.length; i++) {
					var boundary = clientRenderedBoundaries[i];
					renderState$jscomp$1 = destination;
					var resumableState$jscomp$1 = request.resumableState, renderState$jscomp$2 = request.renderState, id = boundary.rootSegmentID, errorDigest = boundary.errorDigest;
					renderState$jscomp$1.push(renderState$jscomp$2.startInlineScript);
					renderState$jscomp$1.push(">");
					0 === (resumableState$jscomp$1.instructions & 4) ? (resumableState$jscomp$1.instructions |= 4, renderState$jscomp$1.push("$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX(\"")) : renderState$jscomp$1.push("$RX(\"");
					renderState$jscomp$1.push(renderState$jscomp$2.boundaryPrefix);
					var chunk$jscomp$2 = id.toString(16);
					renderState$jscomp$1.push(chunk$jscomp$2);
					renderState$jscomp$1.push("\"");
					if (errorDigest) {
						renderState$jscomp$1.push(",");
						var chunk$jscomp$3 = escapeJSStringsForInstructionScripts$1(errorDigest || "");
						renderState$jscomp$1.push(chunk$jscomp$3);
					}
					var JSCompiler_inline_result = renderState$jscomp$1.push(")<\/script>");
					if (!JSCompiler_inline_result) {
						request.destination = null;
						i++;
						clientRenderedBoundaries.splice(0, i);
						return;
					}
				}
				clientRenderedBoundaries.splice(0, i);
				var completedBoundaries = request.completedBoundaries;
				for (i = 0; i < completedBoundaries.length; i++) if (!flushCompletedBoundary$1(request, destination, completedBoundaries[i])) {
					request.destination = null;
					i++;
					completedBoundaries.splice(0, i);
					return;
				}
				completedBoundaries.splice(0, i);
				flushingPartialBoundaries$1 = !0;
				var partialBoundaries = request.partialBoundaries;
				for (i = 0; i < partialBoundaries.length; i++) {
					var boundary$69 = partialBoundaries[i];
					a: {
						clientRenderedBoundaries = request;
						boundary = destination;
						flushedByteSize$1 = boundary$69.byteSize;
						var completedSegments = boundary$69.completedSegments;
						for (JSCompiler_inline_result = 0; JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++) if (!flushPartiallyCompletedSegment$1(clientRenderedBoundaries, boundary, boundary$69, completedSegments[JSCompiler_inline_result])) {
							JSCompiler_inline_result++;
							completedSegments.splice(0, JSCompiler_inline_result);
							var JSCompiler_inline_result$jscomp$0 = !1;
							break a;
						}
						completedSegments.splice(0, JSCompiler_inline_result);
						var row = boundary$69.row;
						null !== row && row.together && 1 === boundary$69.pendingTasks && (1 === row.pendingTasks ? unblockSuspenseListRow$1(clientRenderedBoundaries, row, row.hoistables) : row.pendingTasks--);
						JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary$1(boundary, boundary$69.contentState, clientRenderedBoundaries.renderState);
					}
					if (!JSCompiler_inline_result$jscomp$0) {
						request.destination = null;
						i++;
						partialBoundaries.splice(0, i);
						return;
					}
				}
				partialBoundaries.splice(0, i);
				flushingPartialBoundaries$1 = !1;
				var largeBoundaries = request.completedBoundaries;
				for (i = 0; i < largeBoundaries.length; i++) if (!flushCompletedBoundary$1(request, destination, largeBoundaries[i])) {
					request.destination = null;
					i++;
					largeBoundaries.splice(0, i);
					return;
				}
				largeBoundaries.splice(0, i);
			}
		} finally {
			flushingPartialBoundaries$1 = !1, 0 === request.allPendingTasks && 0 === request.clientRenderedBoundaries.length && 0 === request.completedBoundaries.length && (request.flushScheduled = !1, i = request.resumableState, i.hasBody && (partialBoundaries = endChunkForTag$1("body"), destination.push(partialBoundaries)), i.hasHtml && (i = endChunkForTag$1("html"), destination.push(i)), request.status = 14, destination.push(null), request.destination = null);
		}
	}
	function enqueueFlush$1(request) {
		if (!1 === request.flushScheduled && 0 === request.pingedTasks.length && null !== request.destination) {
			request.flushScheduled = !0;
			var destination = request.destination;
			destination ? flushCompletedQueues$1(request, destination) : request.flushScheduled = !1;
		}
	}
	function startFlowing$1(request, destination) {
		if (13 === request.status) request.status = 14, destination.destroy(request.fatalError);
		else if (14 !== request.status && null === request.destination) {
			request.destination = destination;
			try {
				flushCompletedQueues$1(request, destination);
			} catch (error) {
				logRecoverableError$1(request, error, {}), fatalError$1(request, error);
			}
		}
	}
	function abort$1(request, reason) {
		if (11 === request.status || 10 === request.status) request.status = 12;
		try {
			var abortableTasks = request.abortableTasks;
			if (0 < abortableTasks.size) {
				var error = void 0 === reason ? Error("The render was aborted by the server without a reason.") : "object" === typeof reason && null !== reason && "function" === typeof reason.then ? Error("The render was aborted by the server with a promise.") : reason;
				request.fatalError = error;
				abortableTasks.forEach(function(task) {
					return abortTask$1(task, request, error);
				});
				abortableTasks.clear();
			}
			null !== request.destination && flushCompletedQueues$1(request, request.destination);
		} catch (error$71) {
			logRecoverableError$1(request, error$71, {}), fatalError$1(request, error$71);
		}
	}
	function addToReplayParent$1(node, parentKeyPath, trackedPostpones) {
		if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);
		else {
			var workingMap = trackedPostpones.workingMap, parentNode = workingMap.get(parentKeyPath);
			void 0 === parentNode && (parentNode = [
				parentKeyPath[1],
				parentKeyPath[2],
				[],
				null
			], workingMap.set(parentKeyPath, parentNode), addToReplayParent$1(parentNode, parentKeyPath[0], trackedPostpones));
			parentNode[2].push(node);
		}
	}
	function onError() {}
	function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {
		var didFatal = !1, fatalError$2 = null, result = "", readyToStream = !1;
		options = createResumableState$1(options ? options.identifierPrefix : void 0);
		children = createRequest$1(children, options, createRenderState$1(options, generateStaticMarkup), createFormatContext$1(0, null, 0, null), Infinity, onError, void 0, function() {
			readyToStream = !0;
		}, void 0, void 0, void 0);
		children.flushScheduled = null !== children.destination;
		performWork$1(children);
		10 === children.status && (children.status = 11);
		null === children.trackedPostpones && safelyEmitEarlyPreloads$1(children, 0 === children.pendingRootTasks);
		abort$1(children, abortReason);
		startFlowing$1(children, {
			push: function(chunk) {
				null !== chunk && (result += chunk);
				return !0;
			},
			destroy: function(error) {
				didFatal = !0;
				fatalError$2 = error;
			}
		});
		if (didFatal && fatalError$2 !== abortReason) throw fatalError$2;
		if (!readyToStream) throw Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
		return result;
	}
	exports.renderToStaticMarkup = function(children, options) {
		return renderToStringImpl(children, options, !0, "The server used \"renderToStaticMarkup\" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to \"renderToPipeableStream\" which supports Suspense on the server");
	};
	exports.renderToString = function(children, options) {
		return renderToStringImpl(children, options, !1, "The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToPipeableStream\" which supports Suspense on the server");
	};
	exports.version = "19.2.0";
}) });

//#endregion
//#region ../../node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom-server.node.production.js
var require_react_dom_server_node_production = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom-server.node.production.js": ((exports) => {
	var util = __require("util"), crypto = __require("crypto"), async_hooks = __require("async_hooks"), React$1 = require_react(), ReactDOM = require_react_dom(), stream = __require("stream"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_SCOPE_TYPE = Symbol.for("react.scope"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"), REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
	function getIteratorFn(maybeIterable) {
		if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
		maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
		return "function" === typeof maybeIterable ? maybeIterable : null;
	}
	var isArrayImpl = Array.isArray, scheduleMicrotask = queueMicrotask;
	function flushBuffered(destination) {
		"function" === typeof destination.flush && destination.flush();
	}
	var currentView = null, writtenBytes = 0, destinationHasCapacity$1 = !0;
	function writeChunk(destination, chunk) {
		if ("string" === typeof chunk) {
			if (0 !== chunk.length) if (2048 < 3 * chunk.length) 0 < writtenBytes && (writeToDestination(destination, currentView.subarray(0, writtenBytes)), currentView = new Uint8Array(2048), writtenBytes = 0), writeToDestination(destination, chunk);
			else {
				var target = currentView;
				0 < writtenBytes && (target = currentView.subarray(writtenBytes));
				target = textEncoder.encodeInto(chunk, target);
				var read = target.read;
				writtenBytes += target.written;
				read < chunk.length && (writeToDestination(destination, currentView.subarray(0, writtenBytes)), currentView = new Uint8Array(2048), writtenBytes = textEncoder.encodeInto(chunk.slice(read), currentView).written);
				2048 === writtenBytes && (writeToDestination(destination, currentView), currentView = new Uint8Array(2048), writtenBytes = 0);
			}
		} else 0 !== chunk.byteLength && (2048 < chunk.byteLength ? (0 < writtenBytes && (writeToDestination(destination, currentView.subarray(0, writtenBytes)), currentView = new Uint8Array(2048), writtenBytes = 0), writeToDestination(destination, chunk)) : (target = currentView.length - writtenBytes, target < chunk.byteLength && (0 === target ? writeToDestination(destination, currentView) : (currentView.set(chunk.subarray(0, target), writtenBytes), writtenBytes += target, writeToDestination(destination, currentView), chunk = chunk.subarray(target)), currentView = new Uint8Array(2048), writtenBytes = 0), currentView.set(chunk, writtenBytes), writtenBytes += chunk.byteLength, 2048 === writtenBytes && (writeToDestination(destination, currentView), currentView = new Uint8Array(2048), writtenBytes = 0)));
	}
	function writeToDestination(destination, view) {
		destination = destination.write(view);
		destinationHasCapacity$1 = destinationHasCapacity$1 && destination;
	}
	function writeChunkAndReturn(destination, chunk) {
		writeChunk(destination, chunk);
		return destinationHasCapacity$1;
	}
	function completeWriting(destination) {
		currentView && 0 < writtenBytes && destination.write(currentView.subarray(0, writtenBytes));
		currentView = null;
		writtenBytes = 0;
		destinationHasCapacity$1 = !0;
	}
	var textEncoder = new util.TextEncoder();
	function stringToPrecomputedChunk(content) {
		return textEncoder.encode(content);
	}
	function byteLengthOfChunk(chunk) {
		return "string" === typeof chunk ? Buffer.byteLength(chunk, "utf8") : chunk.byteLength;
	}
	var assign = Object.assign, hasOwnProperty = Object.prototype.hasOwnProperty, VALID_ATTRIBUTE_NAME_REGEX = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
	function isAttributeNameSafe(attributeName) {
		if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) return !0;
		if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return !1;
		if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) return validatedAttributeNameCache[attributeName] = !0;
		illegalAttributeNameCache[attributeName] = !0;
		return !1;
	}
	var unitlessNumbers = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")), aliases = new Map([
		["acceptCharset", "accept-charset"],
		["htmlFor", "for"],
		["httpEquiv", "http-equiv"],
		["crossOrigin", "crossorigin"],
		["accentHeight", "accent-height"],
		["alignmentBaseline", "alignment-baseline"],
		["arabicForm", "arabic-form"],
		["baselineShift", "baseline-shift"],
		["capHeight", "cap-height"],
		["clipPath", "clip-path"],
		["clipRule", "clip-rule"],
		["colorInterpolation", "color-interpolation"],
		["colorInterpolationFilters", "color-interpolation-filters"],
		["colorProfile", "color-profile"],
		["colorRendering", "color-rendering"],
		["dominantBaseline", "dominant-baseline"],
		["enableBackground", "enable-background"],
		["fillOpacity", "fill-opacity"],
		["fillRule", "fill-rule"],
		["floodColor", "flood-color"],
		["floodOpacity", "flood-opacity"],
		["fontFamily", "font-family"],
		["fontSize", "font-size"],
		["fontSizeAdjust", "font-size-adjust"],
		["fontStretch", "font-stretch"],
		["fontStyle", "font-style"],
		["fontVariant", "font-variant"],
		["fontWeight", "font-weight"],
		["glyphName", "glyph-name"],
		["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
		["glyphOrientationVertical", "glyph-orientation-vertical"],
		["horizAdvX", "horiz-adv-x"],
		["horizOriginX", "horiz-origin-x"],
		["imageRendering", "image-rendering"],
		["letterSpacing", "letter-spacing"],
		["lightingColor", "lighting-color"],
		["markerEnd", "marker-end"],
		["markerMid", "marker-mid"],
		["markerStart", "marker-start"],
		["overlinePosition", "overline-position"],
		["overlineThickness", "overline-thickness"],
		["paintOrder", "paint-order"],
		["panose-1", "panose-1"],
		["pointerEvents", "pointer-events"],
		["renderingIntent", "rendering-intent"],
		["shapeRendering", "shape-rendering"],
		["stopColor", "stop-color"],
		["stopOpacity", "stop-opacity"],
		["strikethroughPosition", "strikethrough-position"],
		["strikethroughThickness", "strikethrough-thickness"],
		["strokeDasharray", "stroke-dasharray"],
		["strokeDashoffset", "stroke-dashoffset"],
		["strokeLinecap", "stroke-linecap"],
		["strokeLinejoin", "stroke-linejoin"],
		["strokeMiterlimit", "stroke-miterlimit"],
		["strokeOpacity", "stroke-opacity"],
		["strokeWidth", "stroke-width"],
		["textAnchor", "text-anchor"],
		["textDecoration", "text-decoration"],
		["textRendering", "text-rendering"],
		["transformOrigin", "transform-origin"],
		["underlinePosition", "underline-position"],
		["underlineThickness", "underline-thickness"],
		["unicodeBidi", "unicode-bidi"],
		["unicodeRange", "unicode-range"],
		["unitsPerEm", "units-per-em"],
		["vAlphabetic", "v-alphabetic"],
		["vHanging", "v-hanging"],
		["vIdeographic", "v-ideographic"],
		["vMathematical", "v-mathematical"],
		["vectorEffect", "vector-effect"],
		["vertAdvY", "vert-adv-y"],
		["vertOriginX", "vert-origin-x"],
		["vertOriginY", "vert-origin-y"],
		["wordSpacing", "word-spacing"],
		["writingMode", "writing-mode"],
		["xmlnsXlink", "xmlns:xlink"],
		["xHeight", "x-height"]
	]), matchHtmlRegExp = /["'&<>]/;
	function escapeTextForBrowser(text) {
		if ("boolean" === typeof text || "number" === typeof text || "bigint" === typeof text) return "" + text;
		text = "" + text;
		var match = matchHtmlRegExp.exec(text);
		if (match) {
			var html = "", index, lastIndex = 0;
			for (index = match.index; index < text.length; index++) {
				switch (text.charCodeAt(index)) {
					case 34:
						match = "&quot;";
						break;
					case 38:
						match = "&amp;";
						break;
					case 39:
						match = "&#x27;";
						break;
					case 60:
						match = "&lt;";
						break;
					case 62:
						match = "&gt;";
						break;
					default: continue;
				}
				lastIndex !== index && (html += text.slice(lastIndex, index));
				lastIndex = index + 1;
				html += match;
			}
			text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;
		}
		return text;
	}
	var uppercasePattern = /([A-Z])/g, msPattern = /^ms-/, isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
	function sanitizeURL(url) {
		return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
	}
	var ReactSharedInternals = React$1.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {
		pending: !1,
		data: null,
		method: null,
		action: null
	}, previousDispatcher = ReactDOMSharedInternals.d;
	ReactDOMSharedInternals.d = {
		f: previousDispatcher.f,
		r: previousDispatcher.r,
		D: prefetchDNS,
		C: preconnect,
		L: preload,
		m: preloadModule,
		X: preinitScript,
		S: preinitStyle,
		M: preinitModuleScript
	};
	var PRELOAD_NO_CREDS = [], currentlyFlushingRenderState = null;
	stringToPrecomputedChunk("\"></template>");
	var startInlineScript = stringToPrecomputedChunk("<script"), endInlineScript = stringToPrecomputedChunk("<\/script>"), startScriptSrc = stringToPrecomputedChunk("<script src=\""), startModuleSrc = stringToPrecomputedChunk("<script type=\"module\" src=\""), scriptNonce = stringToPrecomputedChunk(" nonce=\""), scriptIntegirty = stringToPrecomputedChunk(" integrity=\""), scriptCrossOrigin = stringToPrecomputedChunk(" crossorigin=\""), endAsyncScript = stringToPrecomputedChunk(" async=\"\"><\/script>"), startInlineStyle = stringToPrecomputedChunk("<style"), scriptRegex = /(<\/|<)(s)(cript)/gi;
	function scriptReplacer(match, prefix$2, s$1, suffix$2) {
		return "" + prefix$2 + ("s" === s$1 ? "\\u0073" : "\\u0053") + suffix$2;
	}
	var importMapScriptStart = stringToPrecomputedChunk("<script type=\"importmap\">"), importMapScriptEnd = stringToPrecomputedChunk("<\/script>");
	function createRenderState(resumableState, nonce, externalRuntimeConfig, importMap, onHeaders, maxHeadersLength) {
		externalRuntimeConfig = "string" === typeof nonce ? nonce : nonce && nonce.script;
		var inlineScriptWithNonce = void 0 === externalRuntimeConfig ? startInlineScript : stringToPrecomputedChunk("<script nonce=\"" + escapeTextForBrowser(externalRuntimeConfig) + "\""), nonceStyle = "string" === typeof nonce ? void 0 : nonce && nonce.style, inlineStyleWithNonce = void 0 === nonceStyle ? startInlineStyle : stringToPrecomputedChunk("<style nonce=\"" + escapeTextForBrowser(nonceStyle) + "\""), idPrefix = resumableState.idPrefix, bootstrapChunks = [], bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;
		void 0 !== bootstrapScriptContent && (bootstrapChunks.push(inlineScriptWithNonce), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(endOfStartTag, ("" + bootstrapScriptContent).replace(scriptRegex, scriptReplacer), endInlineScript));
		bootstrapScriptContent = [];
		void 0 !== importMap && (bootstrapScriptContent.push(importMapScriptStart), bootstrapScriptContent.push(("" + JSON.stringify(importMap)).replace(scriptRegex, scriptReplacer)), bootstrapScriptContent.push(importMapScriptEnd));
		importMap = onHeaders ? {
			preconnects: "",
			fontPreloads: "",
			highImagePreloads: "",
			remainingCapacity: 2 + ("number" === typeof maxHeadersLength ? maxHeadersLength : 2e3)
		} : null;
		onHeaders = {
			placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
			segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
			boundaryPrefix: stringToPrecomputedChunk(idPrefix + "B:"),
			startInlineScript: inlineScriptWithNonce,
			startInlineStyle: inlineStyleWithNonce,
			preamble: createPreambleState(),
			externalRuntimeScript: null,
			bootstrapChunks,
			importMapChunks: bootstrapScriptContent,
			onHeaders,
			headers: importMap,
			resets: {
				font: {},
				dns: {},
				connect: {
					default: {},
					anonymous: {},
					credentials: {}
				},
				image: {},
				style: {}
			},
			charsetChunks: [],
			viewportChunks: [],
			hoistableChunks: [],
			preconnects: /* @__PURE__ */ new Set(),
			fontPreloads: /* @__PURE__ */ new Set(),
			highImagePreloads: /* @__PURE__ */ new Set(),
			styles: /* @__PURE__ */ new Map(),
			bootstrapScripts: /* @__PURE__ */ new Set(),
			scripts: /* @__PURE__ */ new Set(),
			bulkPreloads: /* @__PURE__ */ new Set(),
			preloads: {
				images: /* @__PURE__ */ new Map(),
				stylesheets: /* @__PURE__ */ new Map(),
				scripts: /* @__PURE__ */ new Map(),
				moduleScripts: /* @__PURE__ */ new Map()
			},
			nonce: {
				script: externalRuntimeConfig,
				style: nonceStyle
			},
			hoistableState: null,
			stylesToHoist: !1
		};
		if (void 0 !== bootstrapScripts) for (importMap = 0; importMap < bootstrapScripts.length; importMap++) idPrefix = bootstrapScripts[importMap], nonceStyle = inlineScriptWithNonce = void 0, inlineStyleWithNonce = {
			rel: "preload",
			as: "script",
			fetchPriority: "low",
			nonce
		}, "string" === typeof idPrefix ? inlineStyleWithNonce.href = maxHeadersLength = idPrefix : (inlineStyleWithNonce.href = maxHeadersLength = idPrefix.src, inlineStyleWithNonce.integrity = nonceStyle = "string" === typeof idPrefix.integrity ? idPrefix.integrity : void 0, inlineStyleWithNonce.crossOrigin = inlineScriptWithNonce = "string" === typeof idPrefix || null == idPrefix.crossOrigin ? void 0 : "use-credentials" === idPrefix.crossOrigin ? "use-credentials" : ""), idPrefix = resumableState, bootstrapScriptContent = maxHeadersLength, idPrefix.scriptResources[bootstrapScriptContent] = null, idPrefix.moduleScriptResources[bootstrapScriptContent] = null, idPrefix = [], pushLinkImpl(idPrefix, inlineStyleWithNonce), onHeaders.bootstrapScripts.add(idPrefix), bootstrapChunks.push(startScriptSrc, escapeTextForBrowser(maxHeadersLength), attributeEnd), externalRuntimeConfig && bootstrapChunks.push(scriptNonce, escapeTextForBrowser(externalRuntimeConfig), attributeEnd), "string" === typeof nonceStyle && bootstrapChunks.push(scriptIntegirty, escapeTextForBrowser(nonceStyle), attributeEnd), "string" === typeof inlineScriptWithNonce && bootstrapChunks.push(scriptCrossOrigin, escapeTextForBrowser(inlineScriptWithNonce), attributeEnd), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(endAsyncScript);
		if (void 0 !== bootstrapModules) for (nonce = 0; nonce < bootstrapModules.length; nonce++) nonceStyle = bootstrapModules[nonce], maxHeadersLength = importMap = void 0, inlineScriptWithNonce = {
			rel: "modulepreload",
			fetchPriority: "low",
			nonce: externalRuntimeConfig
		}, "string" === typeof nonceStyle ? inlineScriptWithNonce.href = bootstrapScripts = nonceStyle : (inlineScriptWithNonce.href = bootstrapScripts = nonceStyle.src, inlineScriptWithNonce.integrity = maxHeadersLength = "string" === typeof nonceStyle.integrity ? nonceStyle.integrity : void 0, inlineScriptWithNonce.crossOrigin = importMap = "string" === typeof nonceStyle || null == nonceStyle.crossOrigin ? void 0 : "use-credentials" === nonceStyle.crossOrigin ? "use-credentials" : ""), nonceStyle = resumableState, inlineStyleWithNonce = bootstrapScripts, nonceStyle.scriptResources[inlineStyleWithNonce] = null, nonceStyle.moduleScriptResources[inlineStyleWithNonce] = null, nonceStyle = [], pushLinkImpl(nonceStyle, inlineScriptWithNonce), onHeaders.bootstrapScripts.add(nonceStyle), bootstrapChunks.push(startModuleSrc, escapeTextForBrowser(bootstrapScripts), attributeEnd), externalRuntimeConfig && bootstrapChunks.push(scriptNonce, escapeTextForBrowser(externalRuntimeConfig), attributeEnd), "string" === typeof maxHeadersLength && bootstrapChunks.push(scriptIntegirty, escapeTextForBrowser(maxHeadersLength), attributeEnd), "string" === typeof importMap && bootstrapChunks.push(scriptCrossOrigin, escapeTextForBrowser(importMap), attributeEnd), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(endAsyncScript);
		return onHeaders;
	}
	function createResumableState(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
		return {
			idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
			nextFormID: 0,
			streamingFormat: 0,
			bootstrapScriptContent,
			bootstrapScripts,
			bootstrapModules,
			instructions: 0,
			hasBody: !1,
			hasHtml: !1,
			unknownResources: {},
			dnsResources: {},
			connectResources: {
				default: {},
				anonymous: {},
				credentials: {}
			},
			imageResources: {},
			styleResources: {},
			scriptResources: {},
			moduleUnknownResources: {},
			moduleScriptResources: {}
		};
	}
	function createPreambleState() {
		return {
			htmlChunks: null,
			headChunks: null,
			bodyChunks: null
		};
	}
	function createFormatContext(insertionMode, selectedValue, tagScope, viewTransition) {
		return {
			insertionMode,
			selectedValue,
			tagScope,
			viewTransition
		};
	}
	function createRootFormatContext(namespaceURI) {
		return createFormatContext("http://www.w3.org/2000/svg" === namespaceURI ? 4 : "http://www.w3.org/1998/Math/MathML" === namespaceURI ? 5 : 0, null, 0, null);
	}
	function getChildFormatContext(parentContext, type, props) {
		var subtreeScope = parentContext.tagScope & -25;
		switch (type) {
			case "noscript": return createFormatContext(2, null, subtreeScope | 1, null);
			case "select": return createFormatContext(2, null != props.value ? props.value : props.defaultValue, subtreeScope, null);
			case "svg": return createFormatContext(4, null, subtreeScope, null);
			case "picture": return createFormatContext(2, null, subtreeScope | 2, null);
			case "math": return createFormatContext(5, null, subtreeScope, null);
			case "foreignObject": return createFormatContext(2, null, subtreeScope, null);
			case "table": return createFormatContext(6, null, subtreeScope, null);
			case "thead":
			case "tbody":
			case "tfoot": return createFormatContext(7, null, subtreeScope, null);
			case "colgroup": return createFormatContext(9, null, subtreeScope, null);
			case "tr": return createFormatContext(8, null, subtreeScope, null);
			case "head":
				if (2 > parentContext.insertionMode) return createFormatContext(3, null, subtreeScope, null);
				break;
			case "html": if (0 === parentContext.insertionMode) return createFormatContext(1, null, subtreeScope, null);
		}
		return 6 <= parentContext.insertionMode || 2 > parentContext.insertionMode ? createFormatContext(2, null, subtreeScope, null) : parentContext.tagScope !== subtreeScope ? createFormatContext(parentContext.insertionMode, parentContext.selectedValue, subtreeScope, null) : parentContext;
	}
	function getSuspenseViewTransition(parentViewTransition) {
		return null === parentViewTransition ? null : {
			update: parentViewTransition.update,
			enter: "none",
			exit: "none",
			share: parentViewTransition.update,
			name: parentViewTransition.autoName,
			autoName: parentViewTransition.autoName,
			nameIdx: 0
		};
	}
	function getSuspenseFallbackFormatContext(resumableState, parentContext) {
		parentContext.tagScope & 32 && (resumableState.instructions |= 128);
		return createFormatContext(parentContext.insertionMode, parentContext.selectedValue, parentContext.tagScope | 12, getSuspenseViewTransition(parentContext.viewTransition));
	}
	function getSuspenseContentFormatContext(resumableState, parentContext) {
		resumableState = getSuspenseViewTransition(parentContext.viewTransition);
		var subtreeScope = parentContext.tagScope | 16;
		null !== resumableState && "none" !== resumableState.share && (subtreeScope |= 64);
		return createFormatContext(parentContext.insertionMode, parentContext.selectedValue, subtreeScope, resumableState);
	}
	var textSeparator = stringToPrecomputedChunk("<!-- -->");
	function pushTextInstance(target, text, renderState, textEmbedded) {
		if ("" === text) return textEmbedded;
		textEmbedded && target.push(textSeparator);
		target.push(escapeTextForBrowser(text));
		return !0;
	}
	var styleNameCache = /* @__PURE__ */ new Map(), styleAttributeStart = stringToPrecomputedChunk(" style=\""), styleAssign = stringToPrecomputedChunk(":"), styleSeparator = stringToPrecomputedChunk(";");
	function pushStyleAttribute(target, style) {
		if ("object" !== typeof style) throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
		var isFirst = !0, styleName;
		for (styleName in style) if (hasOwnProperty.call(style, styleName)) {
			var styleValue = style[styleName];
			if (null != styleValue && "boolean" !== typeof styleValue && "" !== styleValue) {
				if (0 === styleName.indexOf("--")) {
					var nameChunk = escapeTextForBrowser(styleName);
					styleValue = escapeTextForBrowser(("" + styleValue).trim());
				} else nameChunk = styleNameCache.get(styleName), void 0 === nameChunk && (nameChunk = stringToPrecomputedChunk(escapeTextForBrowser(styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-"))), styleNameCache.set(styleName, nameChunk)), styleValue = "number" === typeof styleValue ? 0 === styleValue || unitlessNumbers.has(styleName) ? "" + styleValue : styleValue + "px" : escapeTextForBrowser(("" + styleValue).trim());
				isFirst ? (isFirst = !1, target.push(styleAttributeStart, nameChunk, styleAssign, styleValue)) : target.push(styleSeparator, nameChunk, styleAssign, styleValue);
			}
		}
		isFirst || target.push(attributeEnd);
	}
	var attributeSeparator = stringToPrecomputedChunk(" "), attributeAssign = stringToPrecomputedChunk("=\""), attributeEnd = stringToPrecomputedChunk("\""), attributeEmptyString = stringToPrecomputedChunk("=\"\"");
	function pushBooleanAttribute(target, name, value) {
		value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator, name, attributeEmptyString);
	}
	function pushStringAttribute(target, name, value) {
		"function" !== typeof value && "symbol" !== typeof value && "boolean" !== typeof value && target.push(attributeSeparator, name, attributeAssign, escapeTextForBrowser(value), attributeEnd);
	}
	var actionJavaScriptURL = stringToPrecomputedChunk(escapeTextForBrowser("javascript:throw new Error('React form unexpectedly submitted.')")), startHiddenInputChunk = stringToPrecomputedChunk("<input type=\"hidden\"");
	function pushAdditionalFormField(value, key) {
		this.push(startHiddenInputChunk);
		validateAdditionalFormField(value);
		pushStringAttribute(this, "name", key);
		pushStringAttribute(this, "value", value);
		this.push(endOfStartTagSelfClosing);
	}
	function validateAdditionalFormField(value) {
		if ("string" !== typeof value) throw Error("File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration.");
	}
	function getCustomFormFields(resumableState, formAction) {
		if ("function" === typeof formAction.$$FORM_ACTION) {
			var id = resumableState.nextFormID++;
			resumableState = resumableState.idPrefix + id;
			try {
				var customFields = formAction.$$FORM_ACTION(resumableState);
				if (customFields) customFields.data?.forEach(validateAdditionalFormField);
				return customFields;
			} catch (x) {
				if ("object" === typeof x && null !== x && "function" === typeof x.then) throw x;
			}
		}
		return null;
	}
	function pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name) {
		var formData = null;
		if ("function" === typeof formAction) {
			var customFields = getCustomFormFields(resumableState, formAction);
			null !== customFields ? (name = customFields.name, formAction = customFields.action || "", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(attributeSeparator, "formAction", attributeAssign, actionJavaScriptURL, attributeEnd), formTarget = formMethod = formEncType = formAction = name = null, injectFormReplayingRuntime(resumableState, renderState));
		}
		null != name && pushAttribute(target, "name", name);
		null != formAction && pushAttribute(target, "formAction", formAction);
		null != formEncType && pushAttribute(target, "formEncType", formEncType);
		null != formMethod && pushAttribute(target, "formMethod", formMethod);
		null != formTarget && pushAttribute(target, "formTarget", formTarget);
		return formData;
	}
	function pushAttribute(target, name, value) {
		switch (name) {
			case "className":
				pushStringAttribute(target, "class", value);
				break;
			case "tabIndex":
				pushStringAttribute(target, "tabindex", value);
				break;
			case "dir":
			case "role":
			case "viewBox":
			case "width":
			case "height":
				pushStringAttribute(target, name, value);
				break;
			case "style":
				pushStyleAttribute(target, value);
				break;
			case "src":
			case "href": if ("" === value) break;
			case "action":
			case "formAction":
				if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) break;
				value = sanitizeURL("" + value);
				target.push(attributeSeparator, name, attributeAssign, escapeTextForBrowser(value), attributeEnd);
				break;
			case "defaultValue":
			case "defaultChecked":
			case "innerHTML":
			case "suppressContentEditableWarning":
			case "suppressHydrationWarning":
			case "ref": break;
			case "autoFocus":
			case "multiple":
			case "muted":
				pushBooleanAttribute(target, name.toLowerCase(), value);
				break;
			case "xlinkHref":
				if ("function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) break;
				value = sanitizeURL("" + value);
				target.push(attributeSeparator, "xlink:href", attributeAssign, escapeTextForBrowser(value), attributeEnd);
				break;
			case "contentEditable":
			case "spellCheck":
			case "draggable":
			case "value":
			case "autoReverse":
			case "externalResourcesRequired":
			case "focusable":
			case "preserveAlpha":
				"function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator, name, attributeAssign, escapeTextForBrowser(value), attributeEnd);
				break;
			case "inert":
			case "allowFullScreen":
			case "async":
			case "autoPlay":
			case "controls":
			case "default":
			case "defer":
			case "disabled":
			case "disablePictureInPicture":
			case "disableRemotePlayback":
			case "formNoValidate":
			case "hidden":
			case "loop":
			case "noModule":
			case "noValidate":
			case "open":
			case "playsInline":
			case "readOnly":
			case "required":
			case "reversed":
			case "scoped":
			case "seamless":
			case "itemScope":
				value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator, name, attributeEmptyString);
				break;
			case "capture":
			case "download":
				!0 === value ? target.push(attributeSeparator, name, attributeEmptyString) : !1 !== value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator, name, attributeAssign, escapeTextForBrowser(value), attributeEnd);
				break;
			case "cols":
			case "rows":
			case "size":
			case "span":
				"function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value && target.push(attributeSeparator, name, attributeAssign, escapeTextForBrowser(value), attributeEnd);
				break;
			case "rowSpan":
			case "start":
				"function" === typeof value || "symbol" === typeof value || isNaN(value) || target.push(attributeSeparator, name, attributeAssign, escapeTextForBrowser(value), attributeEnd);
				break;
			case "xlinkActuate":
				pushStringAttribute(target, "xlink:actuate", value);
				break;
			case "xlinkArcrole":
				pushStringAttribute(target, "xlink:arcrole", value);
				break;
			case "xlinkRole":
				pushStringAttribute(target, "xlink:role", value);
				break;
			case "xlinkShow":
				pushStringAttribute(target, "xlink:show", value);
				break;
			case "xlinkTitle":
				pushStringAttribute(target, "xlink:title", value);
				break;
			case "xlinkType":
				pushStringAttribute(target, "xlink:type", value);
				break;
			case "xmlBase":
				pushStringAttribute(target, "xml:base", value);
				break;
			case "xmlLang":
				pushStringAttribute(target, "xml:lang", value);
				break;
			case "xmlSpace":
				pushStringAttribute(target, "xml:space", value);
				break;
			default: if (!(2 < name.length) || "o" !== name[0] && "O" !== name[0] || "n" !== name[1] && "N" !== name[1]) {
				if (name = aliases.get(name) || name, isAttributeNameSafe(name)) {
					switch (typeof value) {
						case "function":
						case "symbol": return;
						case "boolean":
							var prefix$8 = name.toLowerCase().slice(0, 5);
							if ("data-" !== prefix$8 && "aria-" !== prefix$8) return;
					}
					target.push(attributeSeparator, name, attributeAssign, escapeTextForBrowser(value), attributeEnd);
				}
			}
		}
	}
	var endOfStartTag = stringToPrecomputedChunk(">"), endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
	function pushInnerHTML(target, innerHTML, children) {
		if (null != innerHTML) {
			if (null != children) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
			if ("object" !== typeof innerHTML || !("__html" in innerHTML)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
			innerHTML = innerHTML.__html;
			null !== innerHTML && void 0 !== innerHTML && target.push("" + innerHTML);
		}
	}
	function flattenOptionChildren(children) {
		var content = "";
		React$1.Children.forEach(children, function(child) {
			null != child && (content += child);
		});
		return content;
	}
	var selectedMarkerAttribute = stringToPrecomputedChunk(" selected=\"\""), formReplayingRuntimeScript = stringToPrecomputedChunk("addEventListener(\"submit\",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute(\"formAction\");null!=f&&(e=f,b=null)}\"javascript:throw new Error('React form unexpectedly submitted.')\"===e&&(a.preventDefault(),b?(a=document.createElement(\"input\"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});");
	function injectFormReplayingRuntime(resumableState, renderState) {
		if (0 === (resumableState.instructions & 16)) {
			resumableState.instructions |= 16;
			var preamble = renderState.preamble, bootstrapChunks = renderState.bootstrapChunks;
			(preamble.htmlChunks || preamble.headChunks) && 0 === bootstrapChunks.length ? (bootstrapChunks.push(renderState.startInlineScript), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(endOfStartTag, formReplayingRuntimeScript, endInlineScript)) : bootstrapChunks.unshift(renderState.startInlineScript, endOfStartTag, formReplayingRuntimeScript, endInlineScript);
		}
	}
	var formStateMarkerIsMatching = stringToPrecomputedChunk("<!--F!-->"), formStateMarkerIsNotMatching = stringToPrecomputedChunk("<!--F-->");
	function pushLinkImpl(target, props) {
		target.push(startChunkForTag("link"));
		for (var propKey in props) if (hasOwnProperty.call(props, propKey)) {
			var propValue = props[propKey];
			if (null != propValue) switch (propKey) {
				case "children":
				case "dangerouslySetInnerHTML": throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
				default: pushAttribute(target, propKey, propValue);
			}
		}
		target.push(endOfStartTagSelfClosing);
		return null;
	}
	var styleRegex = /(<\/|<)(s)(tyle)/gi;
	function styleReplacer(match, prefix$2, s$1, suffix$2) {
		return "" + prefix$2 + ("s" === s$1 ? "\\73 " : "\\53 ") + suffix$2;
	}
	function pushSelfClosing(target, props, tag) {
		target.push(startChunkForTag(tag));
		for (var propKey in props) if (hasOwnProperty.call(props, propKey)) {
			var propValue = props[propKey];
			if (null != propValue) switch (propKey) {
				case "children":
				case "dangerouslySetInnerHTML": throw Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
				default: pushAttribute(target, propKey, propValue);
			}
		}
		target.push(endOfStartTagSelfClosing);
		return null;
	}
	function pushTitleImpl(target, props) {
		target.push(startChunkForTag("title"));
		var children = null, innerHTML = null, propKey;
		for (propKey in props) if (hasOwnProperty.call(props, propKey)) {
			var propValue = props[propKey];
			if (null != propValue) switch (propKey) {
				case "children":
					children = propValue;
					break;
				case "dangerouslySetInnerHTML":
					innerHTML = propValue;
					break;
				default: pushAttribute(target, propKey, propValue);
			}
		}
		target.push(endOfStartTag);
		props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;
		"function" !== typeof props && "symbol" !== typeof props && null !== props && void 0 !== props && target.push(escapeTextForBrowser("" + props));
		pushInnerHTML(target, innerHTML, children);
		target.push(endChunkForTag("title"));
		return null;
	}
	var headPreambleContributionChunk = stringToPrecomputedChunk("<!--head-->"), bodyPreambleContributionChunk = stringToPrecomputedChunk("<!--body-->"), htmlPreambleContributionChunk = stringToPrecomputedChunk("<!--html-->");
	function pushScriptImpl(target, props) {
		target.push(startChunkForTag("script"));
		var children = null, innerHTML = null, propKey;
		for (propKey in props) if (hasOwnProperty.call(props, propKey)) {
			var propValue = props[propKey];
			if (null != propValue) switch (propKey) {
				case "children":
					children = propValue;
					break;
				case "dangerouslySetInnerHTML":
					innerHTML = propValue;
					break;
				default: pushAttribute(target, propKey, propValue);
			}
		}
		target.push(endOfStartTag);
		pushInnerHTML(target, innerHTML, children);
		"string" === typeof children && target.push(("" + children).replace(scriptRegex, scriptReplacer));
		target.push(endChunkForTag("script"));
		return null;
	}
	function pushStartSingletonElement(target, props, tag) {
		target.push(startChunkForTag(tag));
		var innerHTML = tag = null, propKey;
		for (propKey in props) if (hasOwnProperty.call(props, propKey)) {
			var propValue = props[propKey];
			if (null != propValue) switch (propKey) {
				case "children":
					tag = propValue;
					break;
				case "dangerouslySetInnerHTML":
					innerHTML = propValue;
					break;
				default: pushAttribute(target, propKey, propValue);
			}
		}
		target.push(endOfStartTag);
		pushInnerHTML(target, innerHTML, tag);
		return tag;
	}
	function pushStartGenericElement(target, props, tag) {
		target.push(startChunkForTag(tag));
		var innerHTML = tag = null, propKey;
		for (propKey in props) if (hasOwnProperty.call(props, propKey)) {
			var propValue = props[propKey];
			if (null != propValue) switch (propKey) {
				case "children":
					tag = propValue;
					break;
				case "dangerouslySetInnerHTML":
					innerHTML = propValue;
					break;
				default: pushAttribute(target, propKey, propValue);
			}
		}
		target.push(endOfStartTag);
		pushInnerHTML(target, innerHTML, tag);
		return "string" === typeof tag ? (target.push(escapeTextForBrowser(tag)), null) : tag;
	}
	var leadingNewline = stringToPrecomputedChunk("\n"), VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache = /* @__PURE__ */ new Map();
	function startChunkForTag(tag) {
		var tagStartChunk = validatedTagCache.get(tag);
		if (void 0 === tagStartChunk) {
			if (!VALID_TAG_REGEX.test(tag)) throw Error("Invalid tag: " + tag);
			tagStartChunk = stringToPrecomputedChunk("<" + tag);
			validatedTagCache.set(tag, tagStartChunk);
		}
		return tagStartChunk;
	}
	var doctypeChunk = stringToPrecomputedChunk("<!DOCTYPE html>");
	function pushStartInstance(target$jscomp$0, type, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded) {
		switch (type) {
			case "div":
			case "span":
			case "svg":
			case "path": break;
			case "a":
				target$jscomp$0.push(startChunkForTag("a"));
				var children = null, innerHTML = null, propKey;
				for (propKey in props) if (hasOwnProperty.call(props, propKey)) {
					var propValue = props[propKey];
					if (null != propValue) switch (propKey) {
						case "children":
							children = propValue;
							break;
						case "dangerouslySetInnerHTML":
							innerHTML = propValue;
							break;
						case "href":
							"" === propValue ? pushStringAttribute(target$jscomp$0, "href", "") : pushAttribute(target$jscomp$0, propKey, propValue);
							break;
						default: pushAttribute(target$jscomp$0, propKey, propValue);
					}
				}
				target$jscomp$0.push(endOfStartTag);
				pushInnerHTML(target$jscomp$0, innerHTML, children);
				if ("string" === typeof children) {
					target$jscomp$0.push(escapeTextForBrowser(children));
					var JSCompiler_inline_result = null;
				} else JSCompiler_inline_result = children;
				return JSCompiler_inline_result;
			case "g":
			case "p":
			case "li": break;
			case "select":
				target$jscomp$0.push(startChunkForTag("select"));
				var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;
				for (propKey$jscomp$0 in props) if (hasOwnProperty.call(props, propKey$jscomp$0)) {
					var propValue$jscomp$0 = props[propKey$jscomp$0];
					if (null != propValue$jscomp$0) switch (propKey$jscomp$0) {
						case "children":
							children$jscomp$0 = propValue$jscomp$0;
							break;
						case "dangerouslySetInnerHTML":
							innerHTML$jscomp$0 = propValue$jscomp$0;
							break;
						case "defaultValue":
						case "value": break;
						default: pushAttribute(target$jscomp$0, propKey$jscomp$0, propValue$jscomp$0);
					}
				}
				target$jscomp$0.push(endOfStartTag);
				pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);
				return children$jscomp$0;
			case "option":
				var selectedValue = formatContext.selectedValue;
				target$jscomp$0.push(startChunkForTag("option"));
				var children$jscomp$1 = null, value = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;
				for (propKey$jscomp$1 in props) if (hasOwnProperty.call(props, propKey$jscomp$1)) {
					var propValue$jscomp$1 = props[propKey$jscomp$1];
					if (null != propValue$jscomp$1) switch (propKey$jscomp$1) {
						case "children":
							children$jscomp$1 = propValue$jscomp$1;
							break;
						case "selected":
							selected = propValue$jscomp$1;
							break;
						case "dangerouslySetInnerHTML":
							innerHTML$jscomp$1 = propValue$jscomp$1;
							break;
						case "value": value = propValue$jscomp$1;
						default: pushAttribute(target$jscomp$0, propKey$jscomp$1, propValue$jscomp$1);
					}
				}
				if (null != selectedValue) {
					var stringValue = null !== value ? "" + value : flattenOptionChildren(children$jscomp$1);
					if (isArrayImpl(selectedValue)) {
						for (var i = 0; i < selectedValue.length; i++) if ("" + selectedValue[i] === stringValue) {
							target$jscomp$0.push(selectedMarkerAttribute);
							break;
						}
					} else "" + selectedValue === stringValue && target$jscomp$0.push(selectedMarkerAttribute);
				} else selected && target$jscomp$0.push(selectedMarkerAttribute);
				target$jscomp$0.push(endOfStartTag);
				pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);
				return children$jscomp$1;
			case "textarea":
				target$jscomp$0.push(startChunkForTag("textarea"));
				var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;
				for (propKey$jscomp$2 in props) if (hasOwnProperty.call(props, propKey$jscomp$2)) {
					var propValue$jscomp$2 = props[propKey$jscomp$2];
					if (null != propValue$jscomp$2) switch (propKey$jscomp$2) {
						case "children":
							children$jscomp$2 = propValue$jscomp$2;
							break;
						case "value":
							value$jscomp$0 = propValue$jscomp$2;
							break;
						case "defaultValue":
							defaultValue = propValue$jscomp$2;
							break;
						case "dangerouslySetInnerHTML": throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
						default: pushAttribute(target$jscomp$0, propKey$jscomp$2, propValue$jscomp$2);
					}
				}
				null === value$jscomp$0 && null !== defaultValue && (value$jscomp$0 = defaultValue);
				target$jscomp$0.push(endOfStartTag);
				if (null != children$jscomp$2) {
					if (null != value$jscomp$0) throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
					if (isArrayImpl(children$jscomp$2)) {
						if (1 < children$jscomp$2.length) throw Error("<textarea> can only have at most one child.");
						value$jscomp$0 = "" + children$jscomp$2[0];
					}
					value$jscomp$0 = "" + children$jscomp$2;
				}
				"string" === typeof value$jscomp$0 && "\n" === value$jscomp$0[0] && target$jscomp$0.push(leadingNewline);
				null !== value$jscomp$0 && target$jscomp$0.push(escapeTextForBrowser("" + value$jscomp$0));
				return null;
			case "input":
				target$jscomp$0.push(startChunkForTag("input"));
				var name = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;
				for (propKey$jscomp$3 in props) if (hasOwnProperty.call(props, propKey$jscomp$3)) {
					var propValue$jscomp$3 = props[propKey$jscomp$3];
					if (null != propValue$jscomp$3) switch (propKey$jscomp$3) {
						case "children":
						case "dangerouslySetInnerHTML": throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
						case "name":
							name = propValue$jscomp$3;
							break;
						case "formAction":
							formAction = propValue$jscomp$3;
							break;
						case "formEncType":
							formEncType = propValue$jscomp$3;
							break;
						case "formMethod":
							formMethod = propValue$jscomp$3;
							break;
						case "formTarget":
							formTarget = propValue$jscomp$3;
							break;
						case "defaultChecked":
							defaultChecked = propValue$jscomp$3;
							break;
						case "defaultValue":
							defaultValue$jscomp$0 = propValue$jscomp$3;
							break;
						case "checked":
							checked = propValue$jscomp$3;
							break;
						case "value":
							value$jscomp$1 = propValue$jscomp$3;
							break;
						default: pushAttribute(target$jscomp$0, propKey$jscomp$3, propValue$jscomp$3);
					}
				}
				var formData = pushFormActionAttribute(target$jscomp$0, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name);
				null !== checked ? pushBooleanAttribute(target$jscomp$0, "checked", checked) : null !== defaultChecked && pushBooleanAttribute(target$jscomp$0, "checked", defaultChecked);
				null !== value$jscomp$1 ? pushAttribute(target$jscomp$0, "value", value$jscomp$1) : null !== defaultValue$jscomp$0 && pushAttribute(target$jscomp$0, "value", defaultValue$jscomp$0);
				target$jscomp$0.push(endOfStartTagSelfClosing);
				formData?.forEach(pushAdditionalFormField, target$jscomp$0);
				return null;
			case "button":
				target$jscomp$0.push(startChunkForTag("button"));
				var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;
				for (propKey$jscomp$4 in props) if (hasOwnProperty.call(props, propKey$jscomp$4)) {
					var propValue$jscomp$4 = props[propKey$jscomp$4];
					if (null != propValue$jscomp$4) switch (propKey$jscomp$4) {
						case "children":
							children$jscomp$3 = propValue$jscomp$4;
							break;
						case "dangerouslySetInnerHTML":
							innerHTML$jscomp$2 = propValue$jscomp$4;
							break;
						case "name":
							name$jscomp$0 = propValue$jscomp$4;
							break;
						case "formAction":
							formAction$jscomp$0 = propValue$jscomp$4;
							break;
						case "formEncType":
							formEncType$jscomp$0 = propValue$jscomp$4;
							break;
						case "formMethod":
							formMethod$jscomp$0 = propValue$jscomp$4;
							break;
						case "formTarget":
							formTarget$jscomp$0 = propValue$jscomp$4;
							break;
						default: pushAttribute(target$jscomp$0, propKey$jscomp$4, propValue$jscomp$4);
					}
				}
				var formData$jscomp$0 = pushFormActionAttribute(target$jscomp$0, resumableState, renderState, formAction$jscomp$0, formEncType$jscomp$0, formMethod$jscomp$0, formTarget$jscomp$0, name$jscomp$0);
				target$jscomp$0.push(endOfStartTag);
				formData$jscomp$0?.forEach(pushAdditionalFormField, target$jscomp$0);
				pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);
				if ("string" === typeof children$jscomp$3) {
					target$jscomp$0.push(escapeTextForBrowser(children$jscomp$3));
					var JSCompiler_inline_result$jscomp$0 = null;
				} else JSCompiler_inline_result$jscomp$0 = children$jscomp$3;
				return JSCompiler_inline_result$jscomp$0;
			case "form":
				target$jscomp$0.push(startChunkForTag("form"));
				var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;
				for (propKey$jscomp$5 in props) if (hasOwnProperty.call(props, propKey$jscomp$5)) {
					var propValue$jscomp$5 = props[propKey$jscomp$5];
					if (null != propValue$jscomp$5) switch (propKey$jscomp$5) {
						case "children":
							children$jscomp$4 = propValue$jscomp$5;
							break;
						case "dangerouslySetInnerHTML":
							innerHTML$jscomp$3 = propValue$jscomp$5;
							break;
						case "action":
							formAction$jscomp$1 = propValue$jscomp$5;
							break;
						case "encType":
							formEncType$jscomp$1 = propValue$jscomp$5;
							break;
						case "method":
							formMethod$jscomp$1 = propValue$jscomp$5;
							break;
						case "target":
							formTarget$jscomp$1 = propValue$jscomp$5;
							break;
						default: pushAttribute(target$jscomp$0, propKey$jscomp$5, propValue$jscomp$5);
					}
				}
				var formData$jscomp$1 = null, formActionName = null;
				if ("function" === typeof formAction$jscomp$1) {
					var customFields = getCustomFormFields(resumableState, formAction$jscomp$1);
					null !== customFields ? (formAction$jscomp$1 = customFields.action || "", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(attributeSeparator, "action", attributeAssign, actionJavaScriptURL, attributeEnd), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime(resumableState, renderState));
				}
				null != formAction$jscomp$1 && pushAttribute(target$jscomp$0, "action", formAction$jscomp$1);
				null != formEncType$jscomp$1 && pushAttribute(target$jscomp$0, "encType", formEncType$jscomp$1);
				null != formMethod$jscomp$1 && pushAttribute(target$jscomp$0, "method", formMethod$jscomp$1);
				null != formTarget$jscomp$1 && pushAttribute(target$jscomp$0, "target", formTarget$jscomp$1);
				target$jscomp$0.push(endOfStartTag);
				null !== formActionName && (target$jscomp$0.push(startHiddenInputChunk), pushStringAttribute(target$jscomp$0, "name", formActionName), target$jscomp$0.push(endOfStartTagSelfClosing), formData$jscomp$1?.forEach(pushAdditionalFormField, target$jscomp$0));
				pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);
				if ("string" === typeof children$jscomp$4) {
					target$jscomp$0.push(escapeTextForBrowser(children$jscomp$4));
					var JSCompiler_inline_result$jscomp$1 = null;
				} else JSCompiler_inline_result$jscomp$1 = children$jscomp$4;
				return JSCompiler_inline_result$jscomp$1;
			case "menuitem":
				target$jscomp$0.push(startChunkForTag("menuitem"));
				for (var propKey$jscomp$6 in props) if (hasOwnProperty.call(props, propKey$jscomp$6)) {
					var propValue$jscomp$6 = props[propKey$jscomp$6];
					if (null != propValue$jscomp$6) switch (propKey$jscomp$6) {
						case "children":
						case "dangerouslySetInnerHTML": throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
						default: pushAttribute(target$jscomp$0, propKey$jscomp$6, propValue$jscomp$6);
					}
				}
				target$jscomp$0.push(endOfStartTag);
				return null;
			case "object":
				target$jscomp$0.push(startChunkForTag("object"));
				var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;
				for (propKey$jscomp$7 in props) if (hasOwnProperty.call(props, propKey$jscomp$7)) {
					var propValue$jscomp$7 = props[propKey$jscomp$7];
					if (null != propValue$jscomp$7) switch (propKey$jscomp$7) {
						case "children":
							children$jscomp$5 = propValue$jscomp$7;
							break;
						case "dangerouslySetInnerHTML":
							innerHTML$jscomp$4 = propValue$jscomp$7;
							break;
						case "data":
							var sanitizedValue = sanitizeURL("" + propValue$jscomp$7);
							if ("" === sanitizedValue) break;
							target$jscomp$0.push(attributeSeparator, "data", attributeAssign, escapeTextForBrowser(sanitizedValue), attributeEnd);
							break;
						default: pushAttribute(target$jscomp$0, propKey$jscomp$7, propValue$jscomp$7);
					}
				}
				target$jscomp$0.push(endOfStartTag);
				pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);
				if ("string" === typeof children$jscomp$5) {
					target$jscomp$0.push(escapeTextForBrowser(children$jscomp$5));
					var JSCompiler_inline_result$jscomp$2 = null;
				} else JSCompiler_inline_result$jscomp$2 = children$jscomp$5;
				return JSCompiler_inline_result$jscomp$2;
			case "title":
				var noscriptTagInScope = formatContext.tagScope & 1, isFallback = formatContext.tagScope & 4;
				if (4 === formatContext.insertionMode || noscriptTagInScope || null != props.itemProp) var JSCompiler_inline_result$jscomp$3 = pushTitleImpl(target$jscomp$0, props);
				else isFallback ? JSCompiler_inline_result$jscomp$3 = null : (pushTitleImpl(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$3 = void 0);
				return JSCompiler_inline_result$jscomp$3;
			case "link":
				var noscriptTagInScope$jscomp$0 = formatContext.tagScope & 1, isFallback$jscomp$0 = formatContext.tagScope & 4, rel = props.rel, href = props.href, precedence = props.precedence;
				if (4 === formatContext.insertionMode || noscriptTagInScope$jscomp$0 || null != props.itemProp || "string" !== typeof rel || "string" !== typeof href || "" === href) {
					pushLinkImpl(target$jscomp$0, props);
					var JSCompiler_inline_result$jscomp$4 = null;
				} else if ("stylesheet" === props.rel) if ("string" !== typeof precedence || null != props.disabled || props.onLoad || props.onError) JSCompiler_inline_result$jscomp$4 = pushLinkImpl(target$jscomp$0, props);
				else {
					var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
					if (null !== resourceState) {
						resumableState.styleResources[href] = null;
						styleQueue || (styleQueue = {
							precedence: escapeTextForBrowser(precedence),
							rules: [],
							hrefs: [],
							sheets: /* @__PURE__ */ new Map()
						}, renderState.styles.set(precedence, styleQueue));
						var resource = {
							state: 0,
							props: assign({}, props, {
								"data-precedence": props.precedence,
								precedence: null
							})
						};
						if (resourceState) {
							2 === resourceState.length && adoptPreloadCredentials(resource.props, resourceState);
							var preloadResource = renderState.preloads.stylesheets.get(href);
							preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = 1;
						}
						styleQueue.sheets.set(href, resource);
						hoistableState && hoistableState.stylesheets.add(resource);
					} else if (styleQueue) {
						var resource$9 = styleQueue.sheets.get(href);
						resource$9 && hoistableState && hoistableState.stylesheets.add(resource$9);
					}
					textEmbedded && target$jscomp$0.push(textSeparator);
					JSCompiler_inline_result$jscomp$4 = null;
				}
				else props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$4 = pushLinkImpl(target$jscomp$0, props) : (textEmbedded && target$jscomp$0.push(textSeparator), JSCompiler_inline_result$jscomp$4 = isFallback$jscomp$0 ? null : pushLinkImpl(renderState.hoistableChunks, props));
				return JSCompiler_inline_result$jscomp$4;
			case "script":
				var noscriptTagInScope$jscomp$1 = formatContext.tagScope & 1, asyncProp = props.async;
				if ("string" !== typeof props.src || !props.src || !asyncProp || "function" === typeof asyncProp || "symbol" === typeof asyncProp || props.onLoad || props.onError || 4 === formatContext.insertionMode || noscriptTagInScope$jscomp$1 || null != props.itemProp) var JSCompiler_inline_result$jscomp$5 = pushScriptImpl(target$jscomp$0, props);
				else {
					var key = props.src;
					if ("module" === props.type) {
						var resources = resumableState.moduleScriptResources;
						var preloads = renderState.preloads.moduleScripts;
					} else resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;
					var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : void 0;
					if (null !== resourceState$jscomp$0) {
						resources[key] = null;
						var scriptProps = props;
						if (resourceState$jscomp$0) {
							2 === resourceState$jscomp$0.length && (scriptProps = assign({}, props), adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));
							var preloadResource$jscomp$0 = preloads.get(key);
							preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);
						}
						var resource$jscomp$0 = [];
						renderState.scripts.add(resource$jscomp$0);
						pushScriptImpl(resource$jscomp$0, scriptProps);
					}
					textEmbedded && target$jscomp$0.push(textSeparator);
					JSCompiler_inline_result$jscomp$5 = null;
				}
				return JSCompiler_inline_result$jscomp$5;
			case "style":
				var noscriptTagInScope$jscomp$2 = formatContext.tagScope & 1, precedence$jscomp$0 = props.precedence, href$jscomp$0 = props.href, nonce = props.nonce;
				if (4 === formatContext.insertionMode || noscriptTagInScope$jscomp$2 || null != props.itemProp || "string" !== typeof precedence$jscomp$0 || "string" !== typeof href$jscomp$0 || "" === href$jscomp$0) {
					target$jscomp$0.push(startChunkForTag("style"));
					var children$jscomp$6 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;
					for (propKey$jscomp$8 in props) if (hasOwnProperty.call(props, propKey$jscomp$8)) {
						var propValue$jscomp$8 = props[propKey$jscomp$8];
						if (null != propValue$jscomp$8) switch (propKey$jscomp$8) {
							case "children":
								children$jscomp$6 = propValue$jscomp$8;
								break;
							case "dangerouslySetInnerHTML":
								innerHTML$jscomp$5 = propValue$jscomp$8;
								break;
							default: pushAttribute(target$jscomp$0, propKey$jscomp$8, propValue$jscomp$8);
						}
					}
					target$jscomp$0.push(endOfStartTag);
					var child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;
					"function" !== typeof child && "symbol" !== typeof child && null !== child && void 0 !== child && target$jscomp$0.push(("" + child).replace(styleRegex, styleReplacer));
					pushInnerHTML(target$jscomp$0, innerHTML$jscomp$5, children$jscomp$6);
					target$jscomp$0.push(endChunkForTag("style"));
					var JSCompiler_inline_result$jscomp$6 = null;
				} else {
					var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0);
					if (null !== (resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : void 0)) {
						resumableState.styleResources[href$jscomp$0] = null;
						styleQueue$jscomp$0 || (styleQueue$jscomp$0 = {
							precedence: escapeTextForBrowser(precedence$jscomp$0),
							rules: [],
							hrefs: [],
							sheets: /* @__PURE__ */ new Map()
						}, renderState.styles.set(precedence$jscomp$0, styleQueue$jscomp$0));
						var nonceStyle = renderState.nonce.style;
						if (!nonceStyle || nonceStyle === nonce) {
							styleQueue$jscomp$0.hrefs.push(escapeTextForBrowser(href$jscomp$0));
							var target = styleQueue$jscomp$0.rules, children$jscomp$7 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;
							for (propKey$jscomp$9 in props) if (hasOwnProperty.call(props, propKey$jscomp$9)) {
								var propValue$jscomp$9 = props[propKey$jscomp$9];
								if (null != propValue$jscomp$9) switch (propKey$jscomp$9) {
									case "children":
										children$jscomp$7 = propValue$jscomp$9;
										break;
									case "dangerouslySetInnerHTML": innerHTML$jscomp$6 = propValue$jscomp$9;
								}
							}
							var child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;
							"function" !== typeof child$jscomp$0 && "symbol" !== typeof child$jscomp$0 && null !== child$jscomp$0 && void 0 !== child$jscomp$0 && target.push(("" + child$jscomp$0).replace(styleRegex, styleReplacer));
							pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$7);
						}
					}
					styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);
					textEmbedded && target$jscomp$0.push(textSeparator);
					JSCompiler_inline_result$jscomp$6 = void 0;
				}
				return JSCompiler_inline_result$jscomp$6;
			case "meta":
				var noscriptTagInScope$jscomp$3 = formatContext.tagScope & 1, isFallback$jscomp$1 = formatContext.tagScope & 4;
				if (4 === formatContext.insertionMode || noscriptTagInScope$jscomp$3 || null != props.itemProp) var JSCompiler_inline_result$jscomp$7 = pushSelfClosing(target$jscomp$0, props, "meta");
				else textEmbedded && target$jscomp$0.push(textSeparator), JSCompiler_inline_result$jscomp$7 = isFallback$jscomp$1 ? null : "string" === typeof props.charSet ? pushSelfClosing(renderState.charsetChunks, props, "meta") : "viewport" === props.name ? pushSelfClosing(renderState.viewportChunks, props, "meta") : pushSelfClosing(renderState.hoistableChunks, props, "meta");
				return JSCompiler_inline_result$jscomp$7;
			case "listing":
			case "pre":
				target$jscomp$0.push(startChunkForTag(type));
				var children$jscomp$8 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;
				for (propKey$jscomp$10 in props) if (hasOwnProperty.call(props, propKey$jscomp$10)) {
					var propValue$jscomp$10 = props[propKey$jscomp$10];
					if (null != propValue$jscomp$10) switch (propKey$jscomp$10) {
						case "children":
							children$jscomp$8 = propValue$jscomp$10;
							break;
						case "dangerouslySetInnerHTML":
							innerHTML$jscomp$7 = propValue$jscomp$10;
							break;
						default: pushAttribute(target$jscomp$0, propKey$jscomp$10, propValue$jscomp$10);
					}
				}
				target$jscomp$0.push(endOfStartTag);
				if (null != innerHTML$jscomp$7) {
					if (null != children$jscomp$8) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
					if ("object" !== typeof innerHTML$jscomp$7 || !("__html" in innerHTML$jscomp$7)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
					var html = innerHTML$jscomp$7.__html;
					null !== html && void 0 !== html && ("string" === typeof html && 0 < html.length && "\n" === html[0] ? target$jscomp$0.push(leadingNewline, html) : target$jscomp$0.push("" + html));
				}
				"string" === typeof children$jscomp$8 && "\n" === children$jscomp$8[0] && target$jscomp$0.push(leadingNewline);
				return children$jscomp$8;
			case "img":
				var pictureOrNoScriptTagInScope = formatContext.tagScope & 3, src = props.src, srcSet = props.srcSet;
				if (!("lazy" === props.loading || !src && !srcSet || "string" !== typeof src && null != src || "string" !== typeof srcSet && null != srcSet || "low" === props.fetchPriority || pictureOrNoScriptTagInScope) && ("string" !== typeof src || ":" !== src[4] || "d" !== src[0] && "D" !== src[0] || "a" !== src[1] && "A" !== src[1] || "t" !== src[2] && "T" !== src[2] || "a" !== src[3] && "A" !== src[3]) && ("string" !== typeof srcSet || ":" !== srcSet[4] || "d" !== srcSet[0] && "D" !== srcSet[0] || "a" !== srcSet[1] && "A" !== srcSet[1] || "t" !== srcSet[2] && "T" !== srcSet[2] || "a" !== srcSet[3] && "A" !== srcSet[3])) {
					null !== hoistableState && formatContext.tagScope & 64 && (hoistableState.suspenseyImages = !0);
					var sizes = "string" === typeof props.sizes ? props.sizes : void 0, key$jscomp$0 = srcSet ? srcSet + "\n" + (sizes || "") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);
					if (resource$jscomp$1) {
						if ("high" === props.fetchPriority || 10 > renderState.highImagePreloads.size) promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);
					} else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {
						resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;
						var input = props.crossOrigin;
						var JSCompiler_inline_result$jscomp$8 = "string" === typeof input ? "use-credentials" === input ? input : "" : void 0;
						var headers = renderState.headers, header;
						headers && 0 < headers.remainingCapacity && "string" !== typeof props.srcSet && ("high" === props.fetchPriority || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader(src, "image", {
							imageSrcSet: props.srcSet,
							imageSizes: props.sizes,
							crossOrigin: JSCompiler_inline_result$jscomp$8,
							integrity: props.integrity,
							nonce: props.nonce,
							type: props.type,
							fetchPriority: props.fetchPriority,
							referrerPolicy: props.refererPolicy
						}), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS, headers.highImagePreloads && (headers.highImagePreloads += ", "), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl(resource$jscomp$1, {
							rel: "preload",
							as: "image",
							href: srcSet ? void 0 : src,
							imageSrcSet: srcSet,
							imageSizes: sizes,
							crossOrigin: JSCompiler_inline_result$jscomp$8,
							integrity: props.integrity,
							type: props.type,
							fetchPriority: props.fetchPriority,
							referrerPolicy: props.referrerPolicy
						}), "high" === props.fetchPriority || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));
					}
				}
				return pushSelfClosing(target$jscomp$0, props, "img");
			case "base":
			case "area":
			case "br":
			case "col":
			case "embed":
			case "hr":
			case "keygen":
			case "param":
			case "source":
			case "track":
			case "wbr": return pushSelfClosing(target$jscomp$0, props, type);
			case "annotation-xml":
			case "color-profile":
			case "font-face":
			case "font-face-src":
			case "font-face-uri":
			case "font-face-format":
			case "font-face-name":
			case "missing-glyph": break;
			case "head":
				if (2 > formatContext.insertionMode) {
					var preamble = preambleState || renderState.preamble;
					if (preamble.headChunks) throw Error("The `<head>` tag may only be rendered once.");
					null !== preambleState && target$jscomp$0.push(headPreambleContributionChunk);
					preamble.headChunks = [];
					var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(preamble.headChunks, props, "head");
				} else JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(target$jscomp$0, props, "head");
				return JSCompiler_inline_result$jscomp$9;
			case "body":
				if (2 > formatContext.insertionMode) {
					var preamble$jscomp$0 = preambleState || renderState.preamble;
					if (preamble$jscomp$0.bodyChunks) throw Error("The `<body>` tag may only be rendered once.");
					null !== preambleState && target$jscomp$0.push(bodyPreambleContributionChunk);
					preamble$jscomp$0.bodyChunks = [];
					var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(preamble$jscomp$0.bodyChunks, props, "body");
				} else JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(target$jscomp$0, props, "body");
				return JSCompiler_inline_result$jscomp$10;
			case "html":
				if (0 === formatContext.insertionMode) {
					var preamble$jscomp$1 = preambleState || renderState.preamble;
					if (preamble$jscomp$1.htmlChunks) throw Error("The `<html>` tag may only be rendered once.");
					null !== preambleState && target$jscomp$0.push(htmlPreambleContributionChunk);
					preamble$jscomp$1.htmlChunks = [doctypeChunk];
					var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(preamble$jscomp$1.htmlChunks, props, "html");
				} else JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(target$jscomp$0, props, "html");
				return JSCompiler_inline_result$jscomp$11;
			default: if (-1 !== type.indexOf("-")) {
				target$jscomp$0.push(startChunkForTag(type));
				var children$jscomp$9 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;
				for (propKey$jscomp$11 in props) if (hasOwnProperty.call(props, propKey$jscomp$11)) {
					var propValue$jscomp$11 = props[propKey$jscomp$11];
					if (null != propValue$jscomp$11) {
						var attributeName = propKey$jscomp$11;
						switch (propKey$jscomp$11) {
							case "children":
								children$jscomp$9 = propValue$jscomp$11;
								break;
							case "dangerouslySetInnerHTML":
								innerHTML$jscomp$8 = propValue$jscomp$11;
								break;
							case "style":
								pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);
								break;
							case "suppressContentEditableWarning":
							case "suppressHydrationWarning":
							case "ref": break;
							case "className": attributeName = "class";
							default: if (isAttributeNameSafe(propKey$jscomp$11) && "function" !== typeof propValue$jscomp$11 && "symbol" !== typeof propValue$jscomp$11 && !1 !== propValue$jscomp$11) {
								if (!0 === propValue$jscomp$11) propValue$jscomp$11 = "";
								else if ("object" === typeof propValue$jscomp$11) continue;
								target$jscomp$0.push(attributeSeparator, attributeName, attributeAssign, escapeTextForBrowser(propValue$jscomp$11), attributeEnd);
							}
						}
					}
				}
				target$jscomp$0.push(endOfStartTag);
				pushInnerHTML(target$jscomp$0, innerHTML$jscomp$8, children$jscomp$9);
				return children$jscomp$9;
			}
		}
		return pushStartGenericElement(target$jscomp$0, props, type);
	}
	var endTagCache = /* @__PURE__ */ new Map();
	function endChunkForTag(tag) {
		var chunk = endTagCache.get(tag);
		void 0 === chunk && (chunk = stringToPrecomputedChunk("</" + tag + ">"), endTagCache.set(tag, chunk));
		return chunk;
	}
	function hoistPreambleState(renderState, preambleState) {
		renderState = renderState.preamble;
		null === renderState.htmlChunks && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks);
		null === renderState.headChunks && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks);
		null === renderState.bodyChunks && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks);
	}
	function writeBootstrap(destination, renderState) {
		renderState = renderState.bootstrapChunks;
		for (var i = 0; i < renderState.length - 1; i++) writeChunk(destination, renderState[i]);
		return i < renderState.length ? (i = renderState[i], renderState.length = 0, writeChunkAndReturn(destination, i)) : !0;
	}
	var shellTimeRuntimeScript = stringToPrecomputedChunk("requestAnimationFrame(function(){$RT=performance.now()});"), placeholder1 = stringToPrecomputedChunk("<template id=\""), placeholder2 = stringToPrecomputedChunk("\"></template>"), startActivityBoundary = stringToPrecomputedChunk("<!--&-->"), endActivityBoundary = stringToPrecomputedChunk("<!--/&-->"), startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->"), startPendingSuspenseBoundary1 = stringToPrecomputedChunk("<!--$?--><template id=\""), startPendingSuspenseBoundary2 = stringToPrecomputedChunk("\"></template>"), startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->"), endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->"), clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template"), clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk("\""), clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(" data-dgst=\"");
	stringToPrecomputedChunk(" data-msg=\"");
	stringToPrecomputedChunk(" data-stck=\"");
	stringToPrecomputedChunk(" data-cstck=\"");
	var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
	function writeStartPendingSuspenseBoundary(destination, renderState, id) {
		writeChunk(destination, startPendingSuspenseBoundary1);
		if (null === id) throw Error("An ID must have been assigned before we can complete the boundary.");
		writeChunk(destination, renderState.boundaryPrefix);
		writeChunk(destination, id.toString(16));
		return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
	}
	var startSegmentHTML = stringToPrecomputedChunk("<div hidden id=\""), startSegmentHTML2 = stringToPrecomputedChunk("\">"), endSegmentHTML = stringToPrecomputedChunk("</div>"), startSegmentSVG = stringToPrecomputedChunk("<svg aria-hidden=\"true\" style=\"display:none\" id=\""), startSegmentSVG2 = stringToPrecomputedChunk("\">"), endSegmentSVG = stringToPrecomputedChunk("</svg>"), startSegmentMathML = stringToPrecomputedChunk("<math aria-hidden=\"true\" style=\"display:none\" id=\""), startSegmentMathML2 = stringToPrecomputedChunk("\">"), endSegmentMathML = stringToPrecomputedChunk("</math>"), startSegmentTable = stringToPrecomputedChunk("<table hidden id=\""), startSegmentTable2 = stringToPrecomputedChunk("\">"), endSegmentTable = stringToPrecomputedChunk("</table>"), startSegmentTableBody = stringToPrecomputedChunk("<table hidden><tbody id=\""), startSegmentTableBody2 = stringToPrecomputedChunk("\">"), endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>"), startSegmentTableRow = stringToPrecomputedChunk("<table hidden><tr id=\""), startSegmentTableRow2 = stringToPrecomputedChunk("\">"), endSegmentTableRow = stringToPrecomputedChunk("</tr></table>"), startSegmentColGroup = stringToPrecomputedChunk("<table hidden><colgroup id=\""), startSegmentColGroup2 = stringToPrecomputedChunk("\">"), endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
	function writeStartSegment(destination, renderState, formatContext, id) {
		switch (formatContext.insertionMode) {
			case 0:
			case 1:
			case 3:
			case 2: return writeChunk(destination, startSegmentHTML), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentHTML2);
			case 4: return writeChunk(destination, startSegmentSVG), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentSVG2);
			case 5: return writeChunk(destination, startSegmentMathML), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentMathML2);
			case 6: return writeChunk(destination, startSegmentTable), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentTable2);
			case 7: return writeChunk(destination, startSegmentTableBody), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentTableBody2);
			case 8: return writeChunk(destination, startSegmentTableRow), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentTableRow2);
			case 9: return writeChunk(destination, startSegmentColGroup), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentColGroup2);
			default: throw Error("Unknown insertion mode. This is a bug in React.");
		}
	}
	function writeEndSegment(destination, formatContext) {
		switch (formatContext.insertionMode) {
			case 0:
			case 1:
			case 3:
			case 2: return writeChunkAndReturn(destination, endSegmentHTML);
			case 4: return writeChunkAndReturn(destination, endSegmentSVG);
			case 5: return writeChunkAndReturn(destination, endSegmentMathML);
			case 6: return writeChunkAndReturn(destination, endSegmentTable);
			case 7: return writeChunkAndReturn(destination, endSegmentTableBody);
			case 8: return writeChunkAndReturn(destination, endSegmentTableRow);
			case 9: return writeChunkAndReturn(destination, endSegmentColGroup);
			default: throw Error("Unknown insertion mode. This is a bug in React.");
		}
	}
	var completeSegmentScript1Full = stringToPrecomputedChunk("$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(\""), completeSegmentScript1Partial = stringToPrecomputedChunk("$RS(\""), completeSegmentScript2 = stringToPrecomputedChunk("\",\""), completeSegmentScriptEnd = stringToPrecomputedChunk("\")<\/script>");
	stringToPrecomputedChunk("<template data-rsi=\"\" data-sid=\"");
	stringToPrecomputedChunk("\" data-pid=\"");
	var completeBoundaryScriptFunctionOnly = stringToPrecomputedChunk("$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if(\"/$\"===d||\"/&\"===d)if(0===h)break;else h--;else\"$\"!==d&&\"$?\"!==d&&\"$~\"!==d&&\"$!\"!==d&&\"&\"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data=\"$\";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};\n$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data=\"$~\",$RB.push(a,b),2===$RB.length&&(\"number\"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};"), completeBoundaryScript1Partial = stringToPrecomputedChunk("$RC(\""), completeBoundaryWithStylesScript1FullPartial = stringToPrecomputedChunk("$RM=new Map;$RR=function(n,w,p){function u(q){this._p=null;q()}for(var r=new Map,t=document,h,b,e=t.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),v=[],k=0;b=e[k++];)\"not all\"===b.getAttribute(\"media\")?v.push(b):(\"LINK\"===b.tagName&&$RM.set(b.getAttribute(\"href\"),b),r.set(b.dataset.precedence,h=b));e=0;b=[];var l,a;for(k=!0;;){if(k){var f=p[e++];if(!f){k=!1;e=0;continue}var c=!1,m=0;var d=f[m++];if(a=$RM.get(d)){var g=a._p;c=!0}else{a=t.createElement(\"link\");a.href=d;a.rel=\n\"stylesheet\";for(a.dataset.precedence=l=f[m++];g=f[m++];)a.setAttribute(g,f[m++]);g=a._p=new Promise(function(q,x){a.onload=u.bind(a,q);a.onerror=u.bind(a,x)});$RM.set(d,a)}d=a.getAttribute(\"media\");!g||d&&!matchMedia(d).matches||b.push(g);if(c)continue}else{a=v[e++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=r.get(l)||h;c===h&&(h=a);r.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=t.head,c.insertBefore(a,c.firstChild))}if(p=document.getElementById(n))p.previousSibling.data=\n\"$~\";Promise.all(b).then($RC.bind(null,n,w),$RX.bind(null,n,\"CSS failed to load\"))};$RR(\""), completeBoundaryWithStylesScript1Partial = stringToPrecomputedChunk("$RR(\""), completeBoundaryScript2 = stringToPrecomputedChunk("\",\""), completeBoundaryScript3a = stringToPrecomputedChunk("\","), completeBoundaryScript3b = stringToPrecomputedChunk("\""), completeBoundaryScriptEnd = stringToPrecomputedChunk(")<\/script>");
	stringToPrecomputedChunk("<template data-rci=\"\" data-bid=\"");
	stringToPrecomputedChunk("<template data-rri=\"\" data-bid=\"");
	stringToPrecomputedChunk("\" data-sid=\"");
	stringToPrecomputedChunk("\" data-sty=\"");
	var clientRenderScriptFunctionOnly = stringToPrecomputedChunk("$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};"), clientRenderScript1Full = stringToPrecomputedChunk("$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX(\""), clientRenderScript1Partial = stringToPrecomputedChunk("$RX(\""), clientRenderScript1A = stringToPrecomputedChunk("\""), clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(","), clientRenderScriptEnd = stringToPrecomputedChunk(")<\/script>");
	stringToPrecomputedChunk("<template data-rxi=\"\" data-bid=\"");
	stringToPrecomputedChunk("\" data-dgst=\"");
	stringToPrecomputedChunk("\" data-msg=\"");
	stringToPrecomputedChunk("\" data-stck=\"");
	stringToPrecomputedChunk("\" data-cstck=\"");
	var regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g;
	function escapeJSStringsForInstructionScripts(input) {
		return JSON.stringify(input).replace(regexForJSStringsInInstructionScripts, function(match) {
			switch (match) {
				case "<": return "\\u003c";
				case "\u2028": return "\\u2028";
				case "\u2029": return "\\u2029";
				default: throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
			}
		});
	}
	var regexForJSStringsInScripts = /[&><\u2028\u2029]/g;
	function escapeJSObjectForInstructionScripts(input) {
		return JSON.stringify(input).replace(regexForJSStringsInScripts, function(match) {
			switch (match) {
				case "&": return "\\u0026";
				case ">": return "\\u003e";
				case "<": return "\\u003c";
				case "\u2028": return "\\u2028";
				case "\u2029": return "\\u2029";
				default: throw Error("escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
			}
		});
	}
	var lateStyleTagResourceOpen1 = stringToPrecomputedChunk(" media=\"not all\" data-precedence=\""), lateStyleTagResourceOpen2 = stringToPrecomputedChunk("\" data-href=\""), lateStyleTagResourceOpen3 = stringToPrecomputedChunk("\">"), lateStyleTagTemplateClose = stringToPrecomputedChunk("</style>"), currentlyRenderingBoundaryHasStylesToHoist = !1, destinationHasCapacity = !0;
	function flushStyleTagsLateForBoundary(styleQueue) {
		var rules = styleQueue.rules, hrefs = styleQueue.hrefs, i = 0;
		if (hrefs.length) {
			writeChunk(this, currentlyFlushingRenderState.startInlineStyle);
			writeChunk(this, lateStyleTagResourceOpen1);
			writeChunk(this, styleQueue.precedence);
			for (writeChunk(this, lateStyleTagResourceOpen2); i < hrefs.length - 1; i++) writeChunk(this, hrefs[i]), writeChunk(this, spaceSeparator);
			writeChunk(this, hrefs[i]);
			writeChunk(this, lateStyleTagResourceOpen3);
			for (i = 0; i < rules.length; i++) writeChunk(this, rules[i]);
			destinationHasCapacity = writeChunkAndReturn(this, lateStyleTagTemplateClose);
			currentlyRenderingBoundaryHasStylesToHoist = !0;
			rules.length = 0;
			hrefs.length = 0;
		}
	}
	function hasStylesToHoist(stylesheet) {
		return 2 !== stylesheet.state ? currentlyRenderingBoundaryHasStylesToHoist = !0 : !1;
	}
	function writeHoistablesForBoundary(destination, hoistableState, renderState) {
		currentlyRenderingBoundaryHasStylesToHoist = !1;
		destinationHasCapacity = !0;
		currentlyFlushingRenderState = renderState;
		hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);
		currentlyFlushingRenderState = null;
		hoistableState.stylesheets.forEach(hasStylesToHoist);
		currentlyRenderingBoundaryHasStylesToHoist && (renderState.stylesToHoist = !0);
		return destinationHasCapacity;
	}
	function flushResource(resource) {
		for (var i = 0; i < resource.length; i++) writeChunk(this, resource[i]);
		resource.length = 0;
	}
	var stylesheetFlushingQueue = [];
	function flushStyleInPreamble(stylesheet) {
		pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);
		for (var i = 0; i < stylesheetFlushingQueue.length; i++) writeChunk(this, stylesheetFlushingQueue[i]);
		stylesheetFlushingQueue.length = 0;
		stylesheet.state = 2;
	}
	var styleTagResourceOpen1 = stringToPrecomputedChunk(" data-precedence=\""), styleTagResourceOpen2 = stringToPrecomputedChunk("\" data-href=\""), spaceSeparator = stringToPrecomputedChunk(" "), styleTagResourceOpen3 = stringToPrecomputedChunk("\">"), styleTagResourceClose = stringToPrecomputedChunk("</style>");
	function flushStylesInPreamble(styleQueue) {
		var hasStylesheets = 0 < styleQueue.sheets.size;
		styleQueue.sheets.forEach(flushStyleInPreamble, this);
		styleQueue.sheets.clear();
		var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
		if (!hasStylesheets || hrefs.length) {
			writeChunk(this, currentlyFlushingRenderState.startInlineStyle);
			writeChunk(this, styleTagResourceOpen1);
			writeChunk(this, styleQueue.precedence);
			styleQueue = 0;
			if (hrefs.length) {
				for (writeChunk(this, styleTagResourceOpen2); styleQueue < hrefs.length - 1; styleQueue++) writeChunk(this, hrefs[styleQueue]), writeChunk(this, spaceSeparator);
				writeChunk(this, hrefs[styleQueue]);
			}
			writeChunk(this, styleTagResourceOpen3);
			for (styleQueue = 0; styleQueue < rules.length; styleQueue++) writeChunk(this, rules[styleQueue]);
			writeChunk(this, styleTagResourceClose);
			rules.length = 0;
			hrefs.length = 0;
		}
	}
	function preloadLateStyle(stylesheet) {
		if (0 === stylesheet.state) {
			stylesheet.state = 1;
			var props = stylesheet.props;
			pushLinkImpl(stylesheetFlushingQueue, {
				rel: "preload",
				as: "style",
				href: stylesheet.props.href,
				crossOrigin: props.crossOrigin,
				fetchPriority: props.fetchPriority,
				integrity: props.integrity,
				media: props.media,
				hrefLang: props.hrefLang,
				referrerPolicy: props.referrerPolicy
			});
			for (stylesheet = 0; stylesheet < stylesheetFlushingQueue.length; stylesheet++) writeChunk(this, stylesheetFlushingQueue[stylesheet]);
			stylesheetFlushingQueue.length = 0;
		}
	}
	function preloadLateStyles(styleQueue) {
		styleQueue.sheets.forEach(preloadLateStyle, this);
		styleQueue.sheets.clear();
	}
	stringToPrecomputedChunk("<link rel=\"expect\" href=\"#");
	stringToPrecomputedChunk("\" blocking=\"render\"/>");
	var completedShellIdAttributeStart = stringToPrecomputedChunk(" id=\"");
	function pushCompletedShellIdAttribute(target, resumableState) {
		0 === (resumableState.instructions & 32) && (resumableState.instructions |= 32, target.push(completedShellIdAttributeStart, escapeTextForBrowser("_" + resumableState.idPrefix + "R_"), attributeEnd));
	}
	var arrayFirstOpenBracket = stringToPrecomputedChunk("["), arraySubsequentOpenBracket = stringToPrecomputedChunk(",["), arrayInterstitial = stringToPrecomputedChunk(","), arrayCloseBracket = stringToPrecomputedChunk("]");
	function writeStyleResourceDependenciesInJS(destination, hoistableState) {
		writeChunk(destination, arrayFirstOpenBracket);
		var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
		hoistableState.stylesheets.forEach(function(resource) {
			if (2 !== resource.state) if (3 === resource.state) writeChunk(destination, nextArrayOpenBrackChunk), writeChunk(destination, escapeJSObjectForInstructionScripts("" + resource.props.href)), writeChunk(destination, arrayCloseBracket), nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
			else {
				writeChunk(destination, nextArrayOpenBrackChunk);
				var precedence = resource.props["data-precedence"], props = resource.props;
				writeChunk(destination, escapeJSObjectForInstructionScripts(sanitizeURL("" + resource.props.href)));
				precedence = "" + precedence;
				writeChunk(destination, arrayInterstitial);
				writeChunk(destination, escapeJSObjectForInstructionScripts(precedence));
				for (var propKey in props) if (hasOwnProperty.call(props, propKey) && (precedence = props[propKey], null != precedence)) switch (propKey) {
					case "href":
					case "rel":
					case "precedence":
					case "data-precedence": break;
					case "children":
					case "dangerouslySetInnerHTML": throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
					default: writeStyleResourceAttributeInJS(destination, propKey, precedence);
				}
				writeChunk(destination, arrayCloseBracket);
				nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
				resource.state = 3;
			}
		});
		writeChunk(destination, arrayCloseBracket);
	}
	function writeStyleResourceAttributeInJS(destination, name, value) {
		var attributeName = name.toLowerCase();
		switch (typeof value) {
			case "function":
			case "symbol": return;
		}
		switch (name) {
			case "innerHTML":
			case "dangerouslySetInnerHTML":
			case "suppressContentEditableWarning":
			case "suppressHydrationWarning":
			case "style":
			case "ref": return;
			case "className":
				attributeName = "class";
				name = "" + value;
				break;
			case "hidden":
				if (!1 === value) return;
				name = "";
				break;
			case "src":
			case "href":
				value = sanitizeURL(value);
				name = "" + value;
				break;
			default:
				if (2 < name.length && ("o" === name[0] || "O" === name[0]) && ("n" === name[1] || "N" === name[1]) || !isAttributeNameSafe(name)) return;
				name = "" + value;
		}
		writeChunk(destination, arrayInterstitial);
		writeChunk(destination, escapeJSObjectForInstructionScripts(attributeName));
		writeChunk(destination, arrayInterstitial);
		writeChunk(destination, escapeJSObjectForInstructionScripts(name));
	}
	function createHoistableState() {
		return {
			styles: /* @__PURE__ */ new Set(),
			stylesheets: /* @__PURE__ */ new Set(),
			suspenseyImages: !1
		};
	}
	function prefetchDNS(href) {
		var request = resolveRequest();
		if (request) {
			var resumableState = request.resumableState, renderState = request.renderState;
			if ("string" === typeof href && href) {
				if (!resumableState.dnsResources.hasOwnProperty(href)) {
					resumableState.dnsResources[href] = null;
					resumableState = renderState.headers;
					var header, JSCompiler_temp;
					if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) JSCompiler_temp = (header = "<" + ("" + href).replace(regexForHrefInLinkHeaderURLContext, escapeHrefForLinkHeaderURLContextReplacer) + ">; rel=dns-prefetch", 0 <= (resumableState.remainingCapacity -= header.length + 2));
					JSCompiler_temp ? (renderState.resets.dns[href] = null, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (header = [], pushLinkImpl(header, {
						href,
						rel: "dns-prefetch"
					}), renderState.preconnects.add(header));
				}
				enqueueFlush(request);
			}
		} else previousDispatcher.D(href);
	}
	function preconnect(href, crossOrigin) {
		var request = resolveRequest();
		if (request) {
			var resumableState = request.resumableState, renderState = request.renderState;
			if ("string" === typeof href && href) {
				var bucket = "use-credentials" === crossOrigin ? "credentials" : "string" === typeof crossOrigin ? "anonymous" : "default";
				if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {
					resumableState.connectResources[bucket][href] = null;
					resumableState = renderState.headers;
					var header, JSCompiler_temp;
					if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {
						JSCompiler_temp = "<" + ("" + href).replace(regexForHrefInLinkHeaderURLContext, escapeHrefForLinkHeaderURLContextReplacer) + ">; rel=preconnect";
						if ("string" === typeof crossOrigin) {
							var escapedCrossOrigin = ("" + crossOrigin).replace(regexForLinkHeaderQuotedParamValueContext, escapeStringForLinkHeaderQuotedParamValueContextReplacer);
							JSCompiler_temp += "; crossorigin=\"" + escapedCrossOrigin + "\"";
						}
						JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));
					}
					JSCompiler_temp ? (renderState.resets.connect[bucket][href] = null, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (bucket = [], pushLinkImpl(bucket, {
						rel: "preconnect",
						href,
						crossOrigin
					}), renderState.preconnects.add(bucket));
				}
				enqueueFlush(request);
			}
		} else previousDispatcher.C(href, crossOrigin);
	}
	function preload(href, as, options) {
		var request = resolveRequest();
		if (request) {
			var resumableState = request.resumableState, renderState = request.renderState;
			if (as && href) {
				switch (as) {
					case "image":
						if (options) {
							var imageSrcSet = options.imageSrcSet;
							var imageSizes = options.imageSizes;
							var fetchPriority = options.fetchPriority;
						}
						var key = imageSrcSet ? imageSrcSet + "\n" + (imageSizes || "") : href;
						if (resumableState.imageResources.hasOwnProperty(key)) return;
						resumableState.imageResources[key] = PRELOAD_NO_CREDS;
						resumableState = renderState.headers;
						var header;
						resumableState && 0 < resumableState.remainingCapacity && "string" !== typeof imageSrcSet && "high" === fetchPriority && (header = getPreloadAsHeader(href, as, options), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS, resumableState.highImagePreloads && (resumableState.highImagePreloads += ", "), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl(resumableState, assign({
							rel: "preload",
							href: imageSrcSet ? void 0 : href,
							as
						}, options)), "high" === fetchPriority ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));
						break;
					case "style":
						if (resumableState.styleResources.hasOwnProperty(href)) return;
						imageSrcSet = [];
						pushLinkImpl(imageSrcSet, assign({
							rel: "preload",
							href,
							as
						}, options));
						resumableState.styleResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
						renderState.preloads.stylesheets.set(href, imageSrcSet);
						renderState.bulkPreloads.add(imageSrcSet);
						break;
					case "script":
						if (resumableState.scriptResources.hasOwnProperty(href)) return;
						imageSrcSet = [];
						renderState.preloads.scripts.set(href, imageSrcSet);
						renderState.bulkPreloads.add(imageSrcSet);
						pushLinkImpl(imageSrcSet, assign({
							rel: "preload",
							href,
							as
						}, options));
						resumableState.scriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
						break;
					default:
						if (resumableState.unknownResources.hasOwnProperty(as)) {
							if (imageSrcSet = resumableState.unknownResources[as], imageSrcSet.hasOwnProperty(href)) return;
						} else imageSrcSet = {}, resumableState.unknownResources[as] = imageSrcSet;
						imageSrcSet[href] = PRELOAD_NO_CREDS;
						if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && "font" === as && (key = getPreloadAsHeader(href, as, options), 0 <= (resumableState.remainingCapacity -= key.length + 2))) renderState.resets.font[href] = PRELOAD_NO_CREDS, resumableState.fontPreloads && (resumableState.fontPreloads += ", "), resumableState.fontPreloads += key;
						else switch (resumableState = [], href = assign({
							rel: "preload",
							href,
							as
						}, options), pushLinkImpl(resumableState, href), as) {
							case "font":
								renderState.fontPreloads.add(resumableState);
								break;
							default: renderState.bulkPreloads.add(resumableState);
						}
				}
				enqueueFlush(request);
			}
		} else previousDispatcher.L(href, as, options);
	}
	function preloadModule(href, options) {
		var request = resolveRequest();
		if (request) {
			var resumableState = request.resumableState, renderState = request.renderState;
			if (href) {
				var as = options && "string" === typeof options.as ? options.as : "script";
				switch (as) {
					case "script":
						if (resumableState.moduleScriptResources.hasOwnProperty(href)) return;
						as = [];
						resumableState.moduleScriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
						renderState.preloads.moduleScripts.set(href, as);
						break;
					default:
						if (resumableState.moduleUnknownResources.hasOwnProperty(as)) {
							var resources = resumableState.unknownResources[as];
							if (resources.hasOwnProperty(href)) return;
						} else resources = {}, resumableState.moduleUnknownResources[as] = resources;
						as = [];
						resources[href] = PRELOAD_NO_CREDS;
				}
				pushLinkImpl(as, assign({
					rel: "modulepreload",
					href
				}, options));
				renderState.bulkPreloads.add(as);
				enqueueFlush(request);
			}
		} else previousDispatcher.m(href, options);
	}
	function preinitStyle(href, precedence, options) {
		var request = resolveRequest();
		if (request) {
			var resumableState = request.resumableState, renderState = request.renderState;
			if (href) {
				precedence = precedence || "default";
				var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
				null !== resourceState && (resumableState.styleResources[href] = null, styleQueue || (styleQueue = {
					precedence: escapeTextForBrowser(precedence),
					rules: [],
					hrefs: [],
					sheets: /* @__PURE__ */ new Map()
				}, renderState.styles.set(precedence, styleQueue)), precedence = {
					state: 0,
					props: assign({
						rel: "stylesheet",
						href,
						"data-precedence": precedence
					}, options)
				}, resourceState && (2 === resourceState.length && adoptPreloadCredentials(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = 1), styleQueue.sheets.set(href, precedence), enqueueFlush(request));
			}
		} else previousDispatcher.S(href, precedence, options);
	}
	function preinitScript(src, options) {
		var request = resolveRequest();
		if (request) {
			var resumableState = request.resumableState, renderState = request.renderState;
			if (src) {
				var resourceState = resumableState.scriptResources.hasOwnProperty(src) ? resumableState.scriptResources[src] : void 0;
				null !== resourceState && (resumableState.scriptResources[src] = null, options = assign({
					src,
					async: !0
				}, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
			}
		} else previousDispatcher.X(src, options);
	}
	function preinitModuleScript(src, options) {
		var request = resolveRequest();
		if (request) {
			var resumableState = request.resumableState, renderState = request.renderState;
			if (src) {
				var resourceState = resumableState.moduleScriptResources.hasOwnProperty(src) ? resumableState.moduleScriptResources[src] : void 0;
				null !== resourceState && (resumableState.moduleScriptResources[src] = null, options = assign({
					src,
					type: "module",
					async: !0
				}, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
			}
		} else previousDispatcher.M(src, options);
	}
	function adoptPreloadCredentials(target, preloadState) {
		target.crossOrigin ??= preloadState[0];
		target.integrity ??= preloadState[1];
	}
	function getPreloadAsHeader(href, as, params) {
		href = ("" + href).replace(regexForHrefInLinkHeaderURLContext, escapeHrefForLinkHeaderURLContextReplacer);
		as = ("" + as).replace(regexForLinkHeaderQuotedParamValueContext, escapeStringForLinkHeaderQuotedParamValueContextReplacer);
		as = "<" + href + ">; rel=preload; as=\"" + as + "\"";
		for (var paramName in params) hasOwnProperty.call(params, paramName) && (href = params[paramName], "string" === typeof href && (as += "; " + paramName.toLowerCase() + "=\"" + ("" + href).replace(regexForLinkHeaderQuotedParamValueContext, escapeStringForLinkHeaderQuotedParamValueContextReplacer) + "\""));
		return as;
	}
	var regexForHrefInLinkHeaderURLContext = /[<>\r\n]/g;
	function escapeHrefForLinkHeaderURLContextReplacer(match) {
		switch (match) {
			case "<": return "%3C";
			case ">": return "%3E";
			case "\n": return "%0A";
			case "\r": return "%0D";
			default: throw Error("escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
		}
	}
	var regexForLinkHeaderQuotedParamValueContext = /["';,\r\n]/g;
	function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {
		switch (match) {
			case "\"": return "%22";
			case "'": return "%27";
			case ";": return "%3B";
			case ",": return "%2C";
			case "\n": return "%0A";
			case "\r": return "%0D";
			default: throw Error("escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
		}
	}
	function hoistStyleQueueDependency(styleQueue) {
		this.styles.add(styleQueue);
	}
	function hoistStylesheetDependency(stylesheet) {
		this.stylesheets.add(stylesheet);
	}
	function hoistHoistables(parentState, childState) {
		childState.styles.forEach(hoistStyleQueueDependency, parentState);
		childState.stylesheets.forEach(hoistStylesheetDependency, parentState);
		childState.suspenseyImages && (parentState.suspenseyImages = !0);
	}
	function hasSuspenseyContent(hoistableState) {
		return 0 < hoistableState.stylesheets.size || hoistableState.suspenseyImages;
	}
	var bind = Function.prototype.bind, requestStorage = new async_hooks.AsyncLocalStorage(), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
	function getComponentNameFromType(type) {
		if (null == type) return null;
		if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
		if ("string" === typeof type) return type;
		switch (type) {
			case REACT_FRAGMENT_TYPE: return "Fragment";
			case REACT_PROFILER_TYPE: return "Profiler";
			case REACT_STRICT_MODE_TYPE: return "StrictMode";
			case REACT_SUSPENSE_TYPE: return "Suspense";
			case REACT_SUSPENSE_LIST_TYPE: return "SuspenseList";
			case REACT_ACTIVITY_TYPE: return "Activity";
		}
		if ("object" === typeof type) switch (type.$$typeof) {
			case REACT_PORTAL_TYPE: return "Portal";
			case REACT_CONTEXT_TYPE: return type.displayName || "Context";
			case REACT_CONSUMER_TYPE: return (type._context.displayName || "Context") + ".Consumer";
			case REACT_FORWARD_REF_TYPE:
				var innerType = type.render;
				type = type.displayName;
				type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
				return type;
			case REACT_MEMO_TYPE: return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
			case REACT_LAZY_TYPE:
				innerType = type._payload;
				type = type._init;
				try {
					return getComponentNameFromType(type(innerType));
				} catch (x) {}
		}
		return null;
	}
	var emptyContextObject = {}, currentActiveSnapshot = null;
	function popToNearestCommonAncestor(prev, next) {
		if (prev !== next) {
			prev.context._currentValue = prev.parentValue;
			prev = prev.parent;
			var parentNext = next.parent;
			if (null === prev) {
				if (null !== parentNext) throw Error("The stacks must reach the root at the same time. This is a bug in React.");
			} else {
				if (null === parentNext) throw Error("The stacks must reach the root at the same time. This is a bug in React.");
				popToNearestCommonAncestor(prev, parentNext);
			}
			next.context._currentValue = next.value;
		}
	}
	function popAllPrevious(prev) {
		prev.context._currentValue = prev.parentValue;
		prev = prev.parent;
		null !== prev && popAllPrevious(prev);
	}
	function pushAllNext(next) {
		var parentNext = next.parent;
		null !== parentNext && pushAllNext(parentNext);
		next.context._currentValue = next.value;
	}
	function popPreviousToCommonLevel(prev, next) {
		prev.context._currentValue = prev.parentValue;
		prev = prev.parent;
		if (null === prev) throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
		prev.depth === next.depth ? popToNearestCommonAncestor(prev, next) : popPreviousToCommonLevel(prev, next);
	}
	function popNextToCommonLevel(prev, next) {
		var parentNext = next.parent;
		if (null === parentNext) throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
		prev.depth === parentNext.depth ? popToNearestCommonAncestor(prev, parentNext) : popNextToCommonLevel(prev, parentNext);
		next.context._currentValue = next.value;
	}
	function switchContext(newSnapshot) {
		var prev = currentActiveSnapshot;
		prev !== newSnapshot && (null === prev ? pushAllNext(newSnapshot) : null === newSnapshot ? popAllPrevious(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel(prev, newSnapshot) : popNextToCommonLevel(prev, newSnapshot), currentActiveSnapshot = newSnapshot);
	}
	var classComponentUpdater = {
		enqueueSetState: function(inst, payload) {
			inst = inst._reactInternals;
			null !== inst.queue && inst.queue.push(payload);
		},
		enqueueReplaceState: function(inst, payload) {
			inst = inst._reactInternals;
			inst.replace = !0;
			inst.queue = [payload];
		},
		enqueueForceUpdate: function() {}
	}, emptyTreeContext = {
		id: 1,
		overflow: ""
	};
	function pushTreeContext(baseContext, totalChildren, index) {
		var baseIdWithLeadingBit = baseContext.id;
		baseContext = baseContext.overflow;
		var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
		baseIdWithLeadingBit &= ~(1 << baseLength);
		index += 1;
		var length = 32 - clz32(totalChildren) + baseLength;
		if (30 < length) {
			var numberOfOverflowBits = baseLength - baseLength % 5;
			length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
			baseIdWithLeadingBit >>= numberOfOverflowBits;
			baseLength -= numberOfOverflowBits;
			return {
				id: 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit,
				overflow: length + baseContext
			};
		}
		return {
			id: 1 << length | index << baseLength | baseIdWithLeadingBit,
			overflow: baseContext
		};
	}
	var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2;
	function clz32Fallback(x) {
		x >>>= 0;
		return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
	}
	function noop() {}
	var SuspenseException = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.");
	function trackUsedThenable(thenableState$2, thenable, index) {
		index = thenableState$2[index];
		void 0 === index ? thenableState$2.push(thenable) : index !== thenable && (thenable.then(noop, noop), thenable = index);
		switch (thenable.status) {
			case "fulfilled": return thenable.value;
			case "rejected": throw thenable.reason;
			default:
				"string" === typeof thenable.status ? thenable.then(noop, noop) : (thenableState$2 = thenable, thenableState$2.status = "pending", thenableState$2.then(function(fulfilledValue) {
					if ("pending" === thenable.status) {
						var fulfilledThenable = thenable;
						fulfilledThenable.status = "fulfilled";
						fulfilledThenable.value = fulfilledValue;
					}
				}, function(error) {
					if ("pending" === thenable.status) {
						var rejectedThenable = thenable;
						rejectedThenable.status = "rejected";
						rejectedThenable.reason = error;
					}
				}));
				switch (thenable.status) {
					case "fulfilled": return thenable.value;
					case "rejected": throw thenable.reason;
				}
				suspendedThenable = thenable;
				throw SuspenseException;
		}
	}
	var suspendedThenable = null;
	function getSuspendedThenable() {
		if (null === suspendedThenable) throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
		var thenable = suspendedThenable;
		suspendedThenable = null;
		return thenable;
	}
	function is(x, y) {
		return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
	}
	var objectIs = "function" === typeof Object.is ? Object.is : is, currentlyRenderingComponent = null, currentlyRenderingTask = null, currentlyRenderingRequest = null, currentlyRenderingKeyPath = null, firstWorkInProgressHook = null, workInProgressHook = null, isReRender = !1, didScheduleRenderPhaseUpdate = !1, localIdCounter = 0, actionStateCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, thenableState = null, renderPhaseUpdates = null, numberOfReRenders = 0;
	function resolveCurrentlyRenderingComponent() {
		if (null === currentlyRenderingComponent) throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
		return currentlyRenderingComponent;
	}
	function createHook() {
		if (0 < numberOfReRenders) throw Error("Rendered more hooks than during the previous render");
		return {
			memoizedState: null,
			queue: null,
			next: null
		};
	}
	function createWorkInProgressHook() {
		null === workInProgressHook ? null === firstWorkInProgressHook ? (isReRender = !1, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = !0, workInProgressHook = firstWorkInProgressHook) : null === workInProgressHook.next ? (isReRender = !1, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = !0, workInProgressHook = workInProgressHook.next);
		return workInProgressHook;
	}
	function getThenableStateAfterSuspending() {
		var state = thenableState;
		thenableState = null;
		return state;
	}
	function resetHooksState() {
		currentlyRenderingKeyPath = currentlyRenderingRequest = currentlyRenderingTask = currentlyRenderingComponent = null;
		didScheduleRenderPhaseUpdate = !1;
		firstWorkInProgressHook = null;
		numberOfReRenders = 0;
		workInProgressHook = renderPhaseUpdates = null;
	}
	function basicStateReducer(state, action) {
		return "function" === typeof action ? action(state) : action;
	}
	function useReducer(reducer, initialArg, init) {
		currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
		workInProgressHook = createWorkInProgressHook();
		if (isReRender) {
			var queue = workInProgressHook.queue;
			initialArg = queue.dispatch;
			if (null !== renderPhaseUpdates && (init = renderPhaseUpdates.get(queue), void 0 !== init)) {
				renderPhaseUpdates.delete(queue);
				queue = workInProgressHook.memoizedState;
				do
					queue = reducer(queue, init.action), init = init.next;
				while (null !== init);
				workInProgressHook.memoizedState = queue;
				return [queue, initialArg];
			}
			return [workInProgressHook.memoizedState, initialArg];
		}
		reducer = reducer === basicStateReducer ? "function" === typeof initialArg ? initialArg() : initialArg : void 0 !== init ? init(initialArg) : initialArg;
		workInProgressHook.memoizedState = reducer;
		reducer = workInProgressHook.queue = {
			last: null,
			dispatch: null
		};
		reducer = reducer.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, reducer);
		return [workInProgressHook.memoizedState, reducer];
	}
	function useMemo(nextCreate, deps) {
		currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
		workInProgressHook = createWorkInProgressHook();
		deps = void 0 === deps ? null : deps;
		if (null !== workInProgressHook) {
			var prevState = workInProgressHook.memoizedState;
			if (null !== prevState && null !== deps) {
				var prevDeps = prevState[1];
				a: if (null === prevDeps) prevDeps = !1;
				else {
					for (var i = 0; i < prevDeps.length && i < deps.length; i++) if (!objectIs(deps[i], prevDeps[i])) {
						prevDeps = !1;
						break a;
					}
					prevDeps = !0;
				}
				if (prevDeps) return prevState[0];
			}
		}
		nextCreate = nextCreate();
		workInProgressHook.memoizedState = [nextCreate, deps];
		return nextCreate;
	}
	function dispatchAction(componentIdentity, queue, action) {
		if (25 <= numberOfReRenders) throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
		if (componentIdentity === currentlyRenderingComponent) if (didScheduleRenderPhaseUpdate = !0, componentIdentity = {
			action,
			next: null
		}, null === renderPhaseUpdates && (renderPhaseUpdates = /* @__PURE__ */ new Map()), action = renderPhaseUpdates.get(queue), void 0 === action) renderPhaseUpdates.set(queue, componentIdentity);
		else {
			for (queue = action; null !== queue.next;) queue = queue.next;
			queue.next = componentIdentity;
		}
	}
	function throwOnUseEffectEventCall() {
		throw Error("A function wrapped in useEffectEvent can't be called during rendering.");
	}
	function unsupportedStartTransition() {
		throw Error("startTransition cannot be called during server rendering.");
	}
	function unsupportedSetOptimisticState() {
		throw Error("Cannot update optimistic state while rendering.");
	}
	function createPostbackActionStateKey(permalink, componentKeyPath, hookIndex) {
		if (void 0 !== permalink) return "p" + permalink;
		permalink = JSON.stringify([
			componentKeyPath,
			null,
			hookIndex
		]);
		componentKeyPath = crypto.createHash("md5");
		componentKeyPath.update(permalink);
		return "k" + componentKeyPath.digest("hex");
	}
	function useActionState(action, initialState, permalink) {
		resolveCurrentlyRenderingComponent();
		var actionStateHookIndex = actionStateCounter++, request = currentlyRenderingRequest;
		if ("function" === typeof action.$$FORM_ACTION) {
			var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath;
			request = request.formState;
			var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;
			if (null !== request && "function" === typeof isSignatureEqual) {
				var postbackKey = request[1];
				isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = createPostbackActionStateKey(permalink, componentKeyPath, actionStateHookIndex), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex = actionStateHookIndex, initialState = request[0]));
			}
			var boundAction = action.bind(null, initialState);
			action = function(payload) {
				boundAction(payload);
			};
			"function" === typeof boundAction.$$FORM_ACTION && (action.$$FORM_ACTION = function(prefix$2) {
				prefix$2 = boundAction.$$FORM_ACTION(prefix$2);
				void 0 !== permalink && (permalink += "", prefix$2.action = permalink);
				var formData = prefix$2.data;
				formData && (null === nextPostbackStateKey && (nextPostbackStateKey = createPostbackActionStateKey(permalink, componentKeyPath, actionStateHookIndex)), formData.append("$ACTION_KEY", nextPostbackStateKey));
				return prefix$2;
			});
			return [
				initialState,
				action,
				!1
			];
		}
		var boundAction$22 = action.bind(null, initialState);
		return [
			initialState,
			function(payload) {
				boundAction$22(payload);
			},
			!1
		];
	}
	function unwrapThenable(thenable) {
		var index = thenableIndexCounter;
		thenableIndexCounter += 1;
		null === thenableState && (thenableState = []);
		return trackUsedThenable(thenableState, thenable, index);
	}
	function unsupportedRefresh() {
		throw Error("Cache cannot be refreshed during server rendering.");
	}
	var HooksDispatcher = {
		readContext: function(context) {
			return context._currentValue;
		},
		use: function(usable) {
			if (null !== usable && "object" === typeof usable) {
				if ("function" === typeof usable.then) return unwrapThenable(usable);
				if (usable.$$typeof === REACT_CONTEXT_TYPE) return usable._currentValue;
			}
			throw Error("An unsupported type was passed to use(): " + String(usable));
		},
		useContext: function(context) {
			resolveCurrentlyRenderingComponent();
			return context._currentValue;
		},
		useMemo,
		useReducer,
		useRef: function(initialValue) {
			currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
			workInProgressHook = createWorkInProgressHook();
			var previousRef = workInProgressHook.memoizedState;
			return null === previousRef ? (initialValue = { current: initialValue }, workInProgressHook.memoizedState = initialValue) : previousRef;
		},
		useState: function(initialState) {
			return useReducer(basicStateReducer, initialState);
		},
		useInsertionEffect: noop,
		useLayoutEffect: noop,
		useCallback: function(callback, deps) {
			return useMemo(function() {
				return callback;
			}, deps);
		},
		useImperativeHandle: noop,
		useEffect: noop,
		useDebugValue: noop,
		useDeferredValue: function(value, initialValue) {
			resolveCurrentlyRenderingComponent();
			return void 0 !== initialValue ? initialValue : value;
		},
		useTransition: function() {
			resolveCurrentlyRenderingComponent();
			return [!1, unsupportedStartTransition];
		},
		useId: function() {
			var JSCompiler_inline_result = currentlyRenderingTask.treeContext;
			var overflow = JSCompiler_inline_result.overflow;
			JSCompiler_inline_result = JSCompiler_inline_result.id;
			JSCompiler_inline_result = (JSCompiler_inline_result & ~(1 << 32 - clz32(JSCompiler_inline_result) - 1)).toString(32) + overflow;
			var resumableState = currentResumableState;
			if (null === resumableState) throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
			overflow = localIdCounter++;
			JSCompiler_inline_result = "_" + resumableState.idPrefix + "R_" + JSCompiler_inline_result;
			0 < overflow && (JSCompiler_inline_result += "H" + overflow.toString(32));
			return JSCompiler_inline_result + "_";
		},
		useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
			if (void 0 === getServerSnapshot) throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
			return getServerSnapshot();
		},
		useOptimistic: function(passthrough) {
			resolveCurrentlyRenderingComponent();
			return [passthrough, unsupportedSetOptimisticState];
		},
		useActionState,
		useFormState: useActionState,
		useHostTransitionStatus: function() {
			resolveCurrentlyRenderingComponent();
			return sharedNotPendingObject;
		},
		useMemoCache: function(size) {
			for (var data = Array(size), i = 0; i < size; i++) data[i] = REACT_MEMO_CACHE_SENTINEL;
			return data;
		},
		useCacheRefresh: function() {
			return unsupportedRefresh;
		},
		useEffectEvent: function() {
			return throwOnUseEffectEventCall;
		}
	}, currentResumableState = null, DefaultAsyncDispatcher = {
		getCacheForType: function() {
			throw Error("Not implemented.");
		},
		cacheSignal: function() {
			throw Error("Not implemented.");
		}
	};
	function prepareStackTrace(error, structuredStackTrace) {
		error = (error.name || "Error") + ": " + (error.message || "");
		for (var i = 0; i < structuredStackTrace.length; i++) error += "\n    at " + structuredStackTrace[i].toString();
		return error;
	}
	var prefix, suffix;
	function describeBuiltInComponentFrame(name) {
		if (void 0 === prefix) try {
			throw Error();
		} catch (x) {
			var match = x.stack.trim().match(/\n( *(at )?)/);
			prefix = match && match[1] || "";
			suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
		}
		return "\n" + prefix + name + suffix;
	}
	var reentry = !1;
	function describeNativeComponentFrame(fn, construct) {
		if (!fn || reentry) return "";
		reentry = !0;
		var previousPrepareStackTrace = Error.prepareStackTrace;
		Error.prepareStackTrace = prepareStackTrace;
		try {
			var RunInRootFrame = { DetermineComponentFrameRoot: function() {
				try {
					if (construct) {
						var Fake = function() {
							throw Error();
						};
						Object.defineProperty(Fake.prototype, "props", { set: function() {
							throw Error();
						} });
						if ("object" === typeof Reflect && Reflect.construct) {
							try {
								Reflect.construct(Fake, []);
							} catch (x) {
								var control = x;
							}
							Reflect.construct(fn, [], Fake);
						} else {
							try {
								Fake.call();
							} catch (x$24) {
								control = x$24;
							}
							fn.call(Fake.prototype);
						}
					} else {
						try {
							throw Error();
						} catch (x$25) {
							control = x$25;
						}
						(Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {});
					}
				} catch (sample) {
					if (sample && control && "string" === typeof sample.stack) return [sample.stack, control.stack];
				}
				return [null, null];
			} };
			RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
			var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
			namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
			var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
			if (sampleStack && controlStack) {
				var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
				for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot");) RunInRootFrame++;
				for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes("DetermineComponentFrameRoot");) namePropDescriptor++;
				if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length) for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];) namePropDescriptor--;
				for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--) if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
					if (1 !== RunInRootFrame || 1 !== namePropDescriptor) do
						if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
							var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
							fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
							return frame;
						}
					while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
					break;
				}
			}
		} finally {
			reentry = !1, Error.prepareStackTrace = previousPrepareStackTrace;
		}
		return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
	}
	function describeComponentStackByType(type) {
		if ("string" === typeof type) return describeBuiltInComponentFrame(type);
		if ("function" === typeof type) return type.prototype && type.prototype.isReactComponent ? describeNativeComponentFrame(type, !0) : describeNativeComponentFrame(type, !1);
		if ("object" === typeof type && null !== type) {
			switch (type.$$typeof) {
				case REACT_FORWARD_REF_TYPE: return describeNativeComponentFrame(type.render, !1);
				case REACT_MEMO_TYPE: return describeNativeComponentFrame(type.type, !1);
				case REACT_LAZY_TYPE:
					var lazyComponent = type, payload = lazyComponent._payload;
					lazyComponent = lazyComponent._init;
					try {
						type = lazyComponent(payload);
					} catch (x) {
						return describeBuiltInComponentFrame("Lazy");
					}
					return describeComponentStackByType(type);
			}
			if ("string" === typeof type.name) {
				a: {
					payload = type.name;
					lazyComponent = type.env;
					var location = type.debugLocation;
					if (null != location && (type = Error.prepareStackTrace, Error.prepareStackTrace = prepareStackTrace, location = location.stack, Error.prepareStackTrace = type, location.startsWith("Error: react-stack-top-frame\n") && (location = location.slice(29)), type = location.indexOf("\n"), -1 !== type && (location = location.slice(type + 1)), type = location.indexOf("react_stack_bottom_frame"), -1 !== type && (type = location.lastIndexOf("\n", type)), type = -1 !== type ? location = location.slice(0, type) : "", location = type.lastIndexOf("\n"), type = -1 === location ? type : type.slice(location + 1), -1 !== type.indexOf(payload))) {
						payload = "\n" + type;
						break a;
					}
					payload = describeBuiltInComponentFrame(payload + (lazyComponent ? " [" + lazyComponent + "]" : ""));
				}
				return payload;
			}
		}
		switch (type) {
			case REACT_SUSPENSE_LIST_TYPE: return describeBuiltInComponentFrame("SuspenseList");
			case REACT_SUSPENSE_TYPE: return describeBuiltInComponentFrame("Suspense");
		}
		return "";
	}
	function isEligibleForOutlining(request, boundary) {
		return (500 < boundary.byteSize || hasSuspenseyContent(boundary.contentState)) && null === boundary.contentPreamble;
	}
	function defaultErrorHandler(error) {
		if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
			var JSCompiler_inline_result = error.environmentName;
			error = [error].slice(0);
			"string" === typeof error[0] ? error.splice(0, 1, "\x1B[0m\x1B[7m%c%s\x1B[0m%c " + error[0], "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", " " + JSCompiler_inline_result + " ", "") : error.splice(0, 0, "\x1B[0m\x1B[7m%c%s\x1B[0m%c", "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", " " + JSCompiler_inline_result + " ", "");
			error.unshift(console);
			JSCompiler_inline_result = bind.apply(console.error, error);
			JSCompiler_inline_result();
		} else console.error(error);
		return null;
	}
	function RequestInstance(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError$1, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
		var abortSet = /* @__PURE__ */ new Set();
		this.destination = null;
		this.flushScheduled = !1;
		this.resumableState = resumableState;
		this.renderState = renderState;
		this.rootFormatContext = rootFormatContext;
		this.progressiveChunkSize = void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;
		this.status = 10;
		this.fatalError = null;
		this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
		this.completedPreambleSegments = this.completedRootSegment = null;
		this.byteSize = 0;
		this.abortableTasks = abortSet;
		this.pingedTasks = [];
		this.clientRenderedBoundaries = [];
		this.completedBoundaries = [];
		this.partialBoundaries = [];
		this.trackedPostpones = null;
		this.onError = void 0 === onError$1 ? defaultErrorHandler : onError$1;
		this.onPostpone = void 0 === onPostpone ? noop : onPostpone;
		this.onAllReady = void 0 === onAllReady ? noop : onAllReady;
		this.onShellReady = void 0 === onShellReady ? noop : onShellReady;
		this.onShellError = void 0 === onShellError ? noop : onShellError;
		this.onFatalError = void 0 === onFatalError ? noop : onFatalError;
		this.formState = void 0 === formState ? null : formState;
	}
	function createRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError$1, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
		resumableState = new RequestInstance(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError$1, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState);
		renderState = createPendingSegment(resumableState, 0, null, rootFormatContext, !1, !1);
		renderState.parentFlushed = !0;
		children = createRenderTask(resumableState, null, children, -1, null, renderState, null, null, resumableState.abortableTasks, null, rootFormatContext, null, emptyTreeContext, null, null);
		pushComponentStack(children);
		resumableState.pingedTasks.push(children);
		return resumableState;
	}
	function createPrerenderRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError$1, onAllReady, onShellReady, onShellError, onFatalError, onPostpone) {
		children = createRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError$1, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, void 0);
		children.trackedPostpones = {
			workingMap: /* @__PURE__ */ new Map(),
			rootNodes: [],
			rootSlots: null
		};
		return children;
	}
	function resumeRequest(children, postponedState, renderState, onError$1, onAllReady, onShellReady, onShellError, onFatalError, onPostpone) {
		renderState = new RequestInstance(postponedState.resumableState, renderState, postponedState.rootFormatContext, postponedState.progressiveChunkSize, onError$1, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, null);
		renderState.nextSegmentId = postponedState.nextSegmentId;
		if ("number" === typeof postponedState.replaySlots) return onError$1 = createPendingSegment(renderState, 0, null, postponedState.rootFormatContext, !1, !1), onError$1.parentFlushed = !0, children = createRenderTask(renderState, null, children, -1, null, onError$1, null, null, renderState.abortableTasks, null, postponedState.rootFormatContext, null, emptyTreeContext, null, null), pushComponentStack(children), renderState.pingedTasks.push(children), renderState;
		children = createReplayTask(renderState, null, {
			nodes: postponedState.replayNodes,
			slots: postponedState.replaySlots,
			pendingTasks: 0
		}, children, -1, null, null, renderState.abortableTasks, null, postponedState.rootFormatContext, null, emptyTreeContext, null, null);
		pushComponentStack(children);
		renderState.pingedTasks.push(children);
		return renderState;
	}
	function resumeAndPrerenderRequest(children, postponedState, renderState, onError$1, onAllReady, onShellReady, onShellError, onFatalError, onPostpone) {
		children = resumeRequest(children, postponedState, renderState, onError$1, onAllReady, onShellReady, onShellError, onFatalError, onPostpone);
		children.trackedPostpones = {
			workingMap: /* @__PURE__ */ new Map(),
			rootNodes: [],
			rootSlots: null
		};
		return children;
	}
	var currentRequest = null;
	function resolveRequest() {
		if (currentRequest) return currentRequest;
		var store = requestStorage.getStore();
		return store ? store : null;
	}
	function pingTask(request, task) {
		request.pingedTasks.push(task);
		1 === request.pingedTasks.length && (request.flushScheduled = null !== request.destination, null !== request.trackedPostpones || 10 === request.status ? scheduleMicrotask(function() {
			return performWork(request);
		}) : setImmediate(function() {
			return performWork(request);
		}));
	}
	function createSuspenseBoundary(request, row, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {
		fallbackAbortableTasks = {
			status: 0,
			rootSegmentID: -1,
			parentFlushed: !1,
			pendingTasks: 0,
			row,
			completedSegments: [],
			byteSize: 0,
			fallbackAbortableTasks,
			errorDigest: null,
			contentState: createHoistableState(),
			fallbackState: createHoistableState(),
			contentPreamble,
			fallbackPreamble,
			trackedContentKeyPath: null,
			trackedFallbackNode: null
		};
		null !== row && (row.pendingTasks++, contentPreamble = row.boundaries, null !== contentPreamble && (request.allPendingTasks++, fallbackAbortableTasks.pendingTasks++, contentPreamble.push(fallbackAbortableTasks)), request = row.inheritedHoistables, null !== request && hoistHoistables(fallbackAbortableTasks.contentState, request));
		return fallbackAbortableTasks;
	}
	function createRenderTask(request, thenableState$2, node, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context, treeContext, row, componentStack) {
		request.allPendingTasks++;
		null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
		null !== row && row.pendingTasks++;
		var task = {
			replay: null,
			node,
			childIndex,
			ping: function() {
				return pingTask(request, task);
			},
			blockedBoundary,
			blockedSegment,
			blockedPreamble,
			hoistableState,
			abortSet,
			keyPath,
			formatContext,
			context,
			treeContext,
			row,
			componentStack,
			thenableState: thenableState$2
		};
		abortSet.add(task);
		return task;
	}
	function createReplayTask(request, thenableState$2, replay, node, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context, treeContext, row, componentStack) {
		request.allPendingTasks++;
		null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
		null !== row && row.pendingTasks++;
		replay.pendingTasks++;
		var task = {
			replay,
			node,
			childIndex,
			ping: function() {
				return pingTask(request, task);
			},
			blockedBoundary,
			blockedSegment: null,
			blockedPreamble: null,
			hoistableState,
			abortSet,
			keyPath,
			formatContext,
			context,
			treeContext,
			row,
			componentStack,
			thenableState: thenableState$2
		};
		abortSet.add(task);
		return task;
	}
	function createPendingSegment(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {
		return {
			status: 0,
			parentFlushed: !1,
			id: -1,
			index,
			chunks: [],
			children: [],
			preambleChildren: [],
			parentFormatContext,
			boundary,
			lastPushedText,
			textEmbedded
		};
	}
	function pushComponentStack(task) {
		var node = task.node;
		if ("object" === typeof node && null !== node) switch (node.$$typeof) {
			case REACT_ELEMENT_TYPE: task.componentStack = {
				parent: task.componentStack,
				type: node.type
			};
		}
	}
	function replaceSuspenseComponentStackWithSuspenseFallbackStack(componentStack) {
		return null === componentStack ? null : {
			parent: componentStack.parent,
			type: "Suspense Fallback"
		};
	}
	function getThrownInfo(node$jscomp$0) {
		var errorInfo = {};
		node$jscomp$0 && Object.defineProperty(errorInfo, "componentStack", {
			configurable: !0,
			enumerable: !0,
			get: function() {
				try {
					var info = "", node = node$jscomp$0;
					do
						info += describeComponentStackByType(node.type), node = node.parent;
					while (node);
					var JSCompiler_inline_result = info;
				} catch (x) {
					JSCompiler_inline_result = "\nError generating stack: " + x.message + "\n" + x.stack;
				}
				Object.defineProperty(errorInfo, "componentStack", { value: JSCompiler_inline_result });
				return JSCompiler_inline_result;
			}
		});
		return errorInfo;
	}
	function logRecoverableError(request, error, errorInfo) {
		request = request.onError;
		error = request(error, errorInfo);
		if (null == error || "string" === typeof error) return error;
	}
	function fatalError(request, error) {
		var onShellError = request.onShellError, onFatalError = request.onFatalError;
		onShellError(error);
		onFatalError(error);
		null !== request.destination ? (request.status = 14, request.destination.destroy(error)) : (request.status = 13, request.fatalError = error);
	}
	function finishSuspenseListRow(request, row) {
		unblockSuspenseListRow(request, row.next, row.hoistables);
	}
	function unblockSuspenseListRow(request, unblockedRow, inheritedHoistables) {
		for (; null !== unblockedRow;) {
			null !== inheritedHoistables && (hoistHoistables(unblockedRow.hoistables, inheritedHoistables), unblockedRow.inheritedHoistables = inheritedHoistables);
			var unblockedBoundaries = unblockedRow.boundaries;
			if (null !== unblockedBoundaries) {
				unblockedRow.boundaries = null;
				for (var i = 0; i < unblockedBoundaries.length; i++) {
					var unblockedBoundary = unblockedBoundaries[i];
					null !== inheritedHoistables && hoistHoistables(unblockedBoundary.contentState, inheritedHoistables);
					finishedTask(request, unblockedBoundary, null, null);
				}
			}
			unblockedRow.pendingTasks--;
			if (0 < unblockedRow.pendingTasks) break;
			inheritedHoistables = unblockedRow.hoistables;
			unblockedRow = unblockedRow.next;
		}
	}
	function tryToResolveTogetherRow(request, togetherRow) {
		var boundaries = togetherRow.boundaries;
		if (null !== boundaries && togetherRow.pendingTasks === boundaries.length) {
			for (var allCompleteAndInlinable = !0, i = 0; i < boundaries.length; i++) {
				var rowBoundary = boundaries[i];
				if (1 !== rowBoundary.pendingTasks || rowBoundary.parentFlushed || isEligibleForOutlining(request, rowBoundary)) {
					allCompleteAndInlinable = !1;
					break;
				}
			}
			allCompleteAndInlinable && unblockSuspenseListRow(request, togetherRow, togetherRow.hoistables);
		}
	}
	function createSuspenseListRow(previousRow) {
		var newRow = {
			pendingTasks: 1,
			boundaries: null,
			hoistables: createHoistableState(),
			inheritedHoistables: null,
			together: !1,
			next: null
		};
		null !== previousRow && 0 < previousRow.pendingTasks && (newRow.pendingTasks++, newRow.boundaries = [], previousRow.next = newRow);
		return newRow;
	}
	function renderSuspenseListRows(request, task, keyPath, rows, revealOrder) {
		var prevKeyPath = task.keyPath, prevTreeContext = task.treeContext, prevRow = task.row;
		task.keyPath = keyPath;
		keyPath = rows.length;
		var previousSuspenseListRow = null;
		if (null !== task.replay) {
			var resumeSlots = task.replay.slots;
			if (null !== resumeSlots && "object" === typeof resumeSlots) for (var n = 0; n < keyPath; n++) {
				var i = "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder ? n : keyPath - 1 - n, node = rows[i];
				task.row = previousSuspenseListRow = createSuspenseListRow(previousSuspenseListRow);
				task.treeContext = pushTreeContext(prevTreeContext, keyPath, i);
				var resumeSegmentID = resumeSlots[i];
				"number" === typeof resumeSegmentID ? (resumeNode(request, task, resumeSegmentID, node, i), delete resumeSlots[i]) : renderNode(request, task, node, i);
				0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow(request, previousSuspenseListRow);
			}
			else for (resumeSlots = 0; resumeSlots < keyPath; resumeSlots++) n = "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder ? resumeSlots : keyPath - 1 - resumeSlots, i = rows[n], task.row = previousSuspenseListRow = createSuspenseListRow(previousSuspenseListRow), task.treeContext = pushTreeContext(prevTreeContext, keyPath, n), renderNode(request, task, i, n), 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow(request, previousSuspenseListRow);
		} else if ("backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder) for (revealOrder = 0; revealOrder < keyPath; revealOrder++) resumeSlots = rows[revealOrder], task.row = previousSuspenseListRow = createSuspenseListRow(previousSuspenseListRow), task.treeContext = pushTreeContext(prevTreeContext, keyPath, revealOrder), renderNode(request, task, resumeSlots, revealOrder), 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow(request, previousSuspenseListRow);
		else {
			revealOrder = task.blockedSegment;
			resumeSlots = revealOrder.children.length;
			n = revealOrder.chunks.length;
			for (i = keyPath - 1; 0 <= i; i--) {
				node = rows[i];
				task.row = previousSuspenseListRow = createSuspenseListRow(previousSuspenseListRow);
				task.treeContext = pushTreeContext(prevTreeContext, keyPath, i);
				resumeSegmentID = createPendingSegment(request, n, null, task.formatContext, 0 === i ? revealOrder.lastPushedText : !0, !0);
				revealOrder.children.splice(resumeSlots, 0, resumeSegmentID);
				task.blockedSegment = resumeSegmentID;
				try {
					renderNode(request, task, node, i), resumeSegmentID.lastPushedText && resumeSegmentID.textEmbedded && resumeSegmentID.chunks.push(textSeparator), resumeSegmentID.status = 1, finishedSegment(request, task.blockedBoundary, resumeSegmentID), 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow(request, previousSuspenseListRow);
				} catch (thrownValue) {
					throw resumeSegmentID.status = 12 === request.status ? 3 : 4, thrownValue;
				}
			}
			task.blockedSegment = revealOrder;
			revealOrder.lastPushedText = !1;
		}
		null !== prevRow && null !== previousSuspenseListRow && 0 < previousSuspenseListRow.pendingTasks && (prevRow.pendingTasks++, previousSuspenseListRow.next = prevRow);
		task.treeContext = prevTreeContext;
		task.row = prevRow;
		task.keyPath = prevKeyPath;
	}
	function renderWithHooks(request, task, keyPath, Component, props, secondArg) {
		var prevThenableState = task.thenableState;
		task.thenableState = null;
		currentlyRenderingComponent = {};
		currentlyRenderingTask = task;
		currentlyRenderingRequest = request;
		currentlyRenderingKeyPath = keyPath;
		actionStateCounter = localIdCounter = 0;
		actionStateMatchingIndex = -1;
		thenableIndexCounter = 0;
		thenableState = prevThenableState;
		for (request = Component(props, secondArg); didScheduleRenderPhaseUpdate;) didScheduleRenderPhaseUpdate = !1, actionStateCounter = localIdCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, numberOfReRenders += 1, workInProgressHook = null, request = Component(props, secondArg);
		resetHooksState();
		return request;
	}
	function finishFunctionComponent(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex$2) {
		var didEmitActionStateMarkers = !1;
		if (0 !== actionStateCount && null !== request.formState) {
			var segment = task.blockedSegment;
			if (null !== segment) {
				didEmitActionStateMarkers = !0;
				segment = segment.chunks;
				for (var i = 0; i < actionStateCount; i++) i === actionStateMatchingIndex$2 ? segment.push(formStateMarkerIsMatching) : segment.push(formStateMarkerIsNotMatching);
			}
		}
		actionStateCount = task.keyPath;
		task.keyPath = keyPath;
		hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext(keyPath, 1, 0), renderNode(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode(request, task, children, -1) : renderNodeDestructive(request, task, children, -1);
		task.keyPath = actionStateCount;
	}
	function renderElement(request, task, keyPath, type, props, ref) {
		if ("function" === typeof type) if (type.prototype && type.prototype.isReactComponent) {
			var newProps = props;
			if ("ref" in props) {
				newProps = {};
				for (var propName in props) "ref" !== propName && (newProps[propName] = props[propName]);
			}
			var defaultProps = type.defaultProps;
			if (defaultProps) {
				newProps === props && (newProps = assign({}, newProps, props));
				for (var propName$44 in defaultProps) void 0 === newProps[propName$44] && (newProps[propName$44] = defaultProps[propName$44]);
			}
			props = newProps;
			newProps = emptyContextObject;
			defaultProps = type.contextType;
			"object" === typeof defaultProps && null !== defaultProps && (newProps = defaultProps._currentValue);
			newProps = new type(props, newProps);
			var initialState = void 0 !== newProps.state ? newProps.state : null;
			newProps.updater = classComponentUpdater;
			newProps.props = props;
			newProps.state = initialState;
			defaultProps = {
				queue: [],
				replace: !1
			};
			newProps._reactInternals = defaultProps;
			ref = type.contextType;
			newProps.context = "object" === typeof ref && null !== ref ? ref._currentValue : emptyContextObject;
			ref = type.getDerivedStateFromProps;
			"function" === typeof ref && (ref = ref(props, initialState), initialState = null === ref || void 0 === ref ? initialState : assign({}, initialState, ref), newProps.state = initialState);
			if ("function" !== typeof type.getDerivedStateFromProps && "function" !== typeof newProps.getSnapshotBeforeUpdate && ("function" === typeof newProps.UNSAFE_componentWillMount || "function" === typeof newProps.componentWillMount)) if (type = newProps.state, "function" === typeof newProps.componentWillMount && newProps.componentWillMount(), "function" === typeof newProps.UNSAFE_componentWillMount && newProps.UNSAFE_componentWillMount(), type !== newProps.state && classComponentUpdater.enqueueReplaceState(newProps, newProps.state, null), null !== defaultProps.queue && 0 < defaultProps.queue.length) if (type = defaultProps.queue, ref = defaultProps.replace, defaultProps.queue = null, defaultProps.replace = !1, ref && 1 === type.length) newProps.state = type[0];
			else {
				defaultProps = ref ? type[0] : newProps.state;
				initialState = !0;
				for (ref = ref ? 1 : 0; ref < type.length; ref++) propName$44 = type[ref], propName$44 = "function" === typeof propName$44 ? propName$44.call(newProps, defaultProps, props, void 0) : propName$44, null != propName$44 && (initialState ? (initialState = !1, defaultProps = assign({}, defaultProps, propName$44)) : assign(defaultProps, propName$44));
				newProps.state = defaultProps;
			}
			else defaultProps.queue = null;
			type = newProps.render();
			if (12 === request.status) throw null;
			props = task.keyPath;
			task.keyPath = keyPath;
			renderNodeDestructive(request, task, type, -1);
			task.keyPath = props;
		} else {
			type = renderWithHooks(request, task, keyPath, type, props, void 0);
			if (12 === request.status) throw null;
			finishFunctionComponent(request, task, keyPath, type, 0 !== localIdCounter, actionStateCounter, actionStateMatchingIndex);
		}
		else if ("string" === typeof type) if (newProps = task.blockedSegment, null === newProps) newProps = props.children, defaultProps = task.formatContext, initialState = task.keyPath, task.formatContext = getChildFormatContext(defaultProps, type, props), task.keyPath = keyPath, renderNode(request, task, newProps, -1), task.formatContext = defaultProps, task.keyPath = initialState;
		else {
			initialState = pushStartInstance(newProps.chunks, type, props, request.resumableState, request.renderState, task.blockedPreamble, task.hoistableState, task.formatContext, newProps.lastPushedText);
			newProps.lastPushedText = !1;
			defaultProps = task.formatContext;
			ref = task.keyPath;
			task.keyPath = keyPath;
			if (3 === (task.formatContext = getChildFormatContext(defaultProps, type, props)).insertionMode) {
				keyPath = createPendingSegment(request, 0, null, task.formatContext, !1, !1);
				newProps.preambleChildren.push(keyPath);
				task.blockedSegment = keyPath;
				try {
					keyPath.status = 6, renderNode(request, task, initialState, -1), keyPath.lastPushedText && keyPath.textEmbedded && keyPath.chunks.push(textSeparator), keyPath.status = 1, finishedSegment(request, task.blockedBoundary, keyPath);
				} finally {
					task.blockedSegment = newProps;
				}
			} else renderNode(request, task, initialState, -1);
			task.formatContext = defaultProps;
			task.keyPath = ref;
			a: {
				task = newProps.chunks;
				request = request.resumableState;
				switch (type) {
					case "title":
					case "style":
					case "script":
					case "area":
					case "base":
					case "br":
					case "col":
					case "embed":
					case "hr":
					case "img":
					case "input":
					case "keygen":
					case "link":
					case "meta":
					case "param":
					case "source":
					case "track":
					case "wbr": break a;
					case "body":
						if (1 >= defaultProps.insertionMode) {
							request.hasBody = !0;
							break a;
						}
						break;
					case "html":
						if (0 === defaultProps.insertionMode) {
							request.hasHtml = !0;
							break a;
						}
						break;
					case "head": if (1 >= defaultProps.insertionMode) break a;
				}
				task.push(endChunkForTag(type));
			}
			newProps.lastPushedText = !1;
		}
		else {
			switch (type) {
				case REACT_LEGACY_HIDDEN_TYPE:
				case REACT_STRICT_MODE_TYPE:
				case REACT_PROFILER_TYPE:
				case REACT_FRAGMENT_TYPE:
					type = task.keyPath;
					task.keyPath = keyPath;
					renderNodeDestructive(request, task, props.children, -1);
					task.keyPath = type;
					return;
				case REACT_ACTIVITY_TYPE:
					type = task.blockedSegment;
					null === type ? "hidden" !== props.mode && (type = task.keyPath, task.keyPath = keyPath, renderNode(request, task, props.children, -1), task.keyPath = type) : "hidden" !== props.mode && (type.chunks.push(startActivityBoundary), type.lastPushedText = !1, newProps = task.keyPath, task.keyPath = keyPath, renderNode(request, task, props.children, -1), task.keyPath = newProps, type.chunks.push(endActivityBoundary), type.lastPushedText = !1);
					return;
				case REACT_SUSPENSE_LIST_TYPE:
					a: {
						type = props.children;
						props = props.revealOrder;
						if ("forwards" === props || "backwards" === props || "unstable_legacy-backwards" === props) {
							if (isArrayImpl(type)) {
								renderSuspenseListRows(request, task, keyPath, type, props);
								break a;
							}
							if (newProps = getIteratorFn(type)) {
								if (newProps = newProps.call(type)) {
									defaultProps = newProps.next();
									if (!defaultProps.done) {
										do
											defaultProps = newProps.next();
										while (!defaultProps.done);
										renderSuspenseListRows(request, task, keyPath, type, props);
									}
									break a;
								}
							}
						}
						"together" === props ? (props = task.keyPath, newProps = task.row, defaultProps = task.row = createSuspenseListRow(null), defaultProps.boundaries = [], defaultProps.together = !0, task.keyPath = keyPath, renderNodeDestructive(request, task, type, -1), 0 === --defaultProps.pendingTasks && finishSuspenseListRow(request, defaultProps), task.keyPath = props, task.row = newProps, null !== newProps && 0 < defaultProps.pendingTasks && (newProps.pendingTasks++, defaultProps.next = newProps)) : (props = task.keyPath, task.keyPath = keyPath, renderNodeDestructive(request, task, type, -1), task.keyPath = props);
					}
					return;
				case REACT_VIEW_TRANSITION_TYPE:
				case REACT_SCOPE_TYPE: throw Error("ReactDOMServer does not yet support scope components.");
				case REACT_SUSPENSE_TYPE:
					a: if (null !== task.replay) {
						type = task.keyPath;
						newProps = task.formatContext;
						defaultProps = task.row;
						task.keyPath = keyPath;
						task.formatContext = getSuspenseContentFormatContext(request.resumableState, newProps);
						task.row = null;
						keyPath = props.children;
						try {
							renderNode(request, task, keyPath, -1);
						} finally {
							task.keyPath = type, task.formatContext = newProps, task.row = defaultProps;
						}
					} else {
						type = task.keyPath;
						ref = task.formatContext;
						var prevRow = task.row;
						propName$44 = task.blockedBoundary;
						propName = task.blockedPreamble;
						var parentHoistableState = task.hoistableState, parentSegment = task.blockedSegment, fallback = props.fallback;
						props = props.children;
						var fallbackAbortSet = /* @__PURE__ */ new Set();
						var newBoundary = 2 > task.formatContext.insertionMode ? createSuspenseBoundary(request, task.row, fallbackAbortSet, createPreambleState(), createPreambleState()) : createSuspenseBoundary(request, task.row, fallbackAbortSet, null, null);
						null !== request.trackedPostpones && (newBoundary.trackedContentKeyPath = keyPath);
						var boundarySegment = createPendingSegment(request, parentSegment.chunks.length, newBoundary, task.formatContext, !1, !1);
						parentSegment.children.push(boundarySegment);
						parentSegment.lastPushedText = !1;
						var contentRootSegment = createPendingSegment(request, 0, null, task.formatContext, !1, !1);
						contentRootSegment.parentFlushed = !0;
						if (null !== request.trackedPostpones) {
							newProps = task.componentStack;
							defaultProps = [
								keyPath[0],
								"Suspense Fallback",
								keyPath[2]
							];
							initialState = [
								defaultProps[1],
								defaultProps[2],
								[],
								null
							];
							request.trackedPostpones.workingMap.set(defaultProps, initialState);
							newBoundary.trackedFallbackNode = initialState;
							task.blockedSegment = boundarySegment;
							task.blockedPreamble = newBoundary.fallbackPreamble;
							task.keyPath = defaultProps;
							task.formatContext = getSuspenseFallbackFormatContext(request.resumableState, ref);
							task.componentStack = replaceSuspenseComponentStackWithSuspenseFallbackStack(newProps);
							boundarySegment.status = 6;
							try {
								renderNode(request, task, fallback, -1), boundarySegment.lastPushedText && boundarySegment.textEmbedded && boundarySegment.chunks.push(textSeparator), boundarySegment.status = 1, finishedSegment(request, propName$44, boundarySegment);
							} catch (thrownValue) {
								throw boundarySegment.status = 12 === request.status ? 3 : 4, thrownValue;
							} finally {
								task.blockedSegment = parentSegment, task.blockedPreamble = propName, task.keyPath = type, task.formatContext = ref;
							}
							task = createRenderTask(request, null, props, -1, newBoundary, contentRootSegment, newBoundary.contentPreamble, newBoundary.contentState, task.abortSet, keyPath, getSuspenseContentFormatContext(request.resumableState, task.formatContext), task.context, task.treeContext, null, newProps);
							pushComponentStack(task);
							request.pingedTasks.push(task);
						} else {
							task.blockedBoundary = newBoundary;
							task.blockedPreamble = newBoundary.contentPreamble;
							task.hoistableState = newBoundary.contentState;
							task.blockedSegment = contentRootSegment;
							task.keyPath = keyPath;
							task.formatContext = getSuspenseContentFormatContext(request.resumableState, ref);
							task.row = null;
							contentRootSegment.status = 6;
							try {
								if (renderNode(request, task, props, -1), contentRootSegment.lastPushedText && contentRootSegment.textEmbedded && contentRootSegment.chunks.push(textSeparator), contentRootSegment.status = 1, finishedSegment(request, newBoundary, contentRootSegment), queueCompletedSegment(newBoundary, contentRootSegment), 0 === newBoundary.pendingTasks && 0 === newBoundary.status) {
									if (newBoundary.status = 1, !isEligibleForOutlining(request, newBoundary)) {
										null !== prevRow && 0 === --prevRow.pendingTasks && finishSuspenseListRow(request, prevRow);
										0 === request.pendingRootTasks && task.blockedPreamble && preparePreamble(request);
										break a;
									}
								} else null !== prevRow && prevRow.together && tryToResolveTogetherRow(request, prevRow);
							} catch (thrownValue$31) {
								newBoundary.status = 4, 12 === request.status ? (contentRootSegment.status = 3, newProps = request.fatalError) : (contentRootSegment.status = 4, newProps = thrownValue$31), defaultProps = getThrownInfo(task.componentStack), initialState = logRecoverableError(request, newProps, defaultProps), newBoundary.errorDigest = initialState, untrackBoundary(request, newBoundary);
							} finally {
								task.blockedBoundary = propName$44, task.blockedPreamble = propName, task.hoistableState = parentHoistableState, task.blockedSegment = parentSegment, task.keyPath = type, task.formatContext = ref, task.row = prevRow;
							}
							task = createRenderTask(request, null, fallback, -1, propName$44, boundarySegment, newBoundary.fallbackPreamble, newBoundary.fallbackState, fallbackAbortSet, [
								keyPath[0],
								"Suspense Fallback",
								keyPath[2]
							], getSuspenseFallbackFormatContext(request.resumableState, task.formatContext), task.context, task.treeContext, task.row, replaceSuspenseComponentStackWithSuspenseFallbackStack(task.componentStack));
							pushComponentStack(task);
							request.pingedTasks.push(task);
						}
					}
					return;
			}
			if ("object" === typeof type && null !== type) switch (type.$$typeof) {
				case REACT_FORWARD_REF_TYPE:
					if ("ref" in props) for (parentSegment in newProps = {}, props) "ref" !== parentSegment && (newProps[parentSegment] = props[parentSegment]);
					else newProps = props;
					type = renderWithHooks(request, task, keyPath, type.render, newProps, ref);
					finishFunctionComponent(request, task, keyPath, type, 0 !== localIdCounter, actionStateCounter, actionStateMatchingIndex);
					return;
				case REACT_MEMO_TYPE:
					renderElement(request, task, keyPath, type.type, props, ref);
					return;
				case REACT_CONTEXT_TYPE:
					defaultProps = props.children;
					newProps = task.keyPath;
					props = props.value;
					initialState = type._currentValue;
					type._currentValue = props;
					ref = currentActiveSnapshot;
					currentActiveSnapshot = type = {
						parent: ref,
						depth: null === ref ? 0 : ref.depth + 1,
						context: type,
						parentValue: initialState,
						value: props
					};
					task.context = type;
					task.keyPath = keyPath;
					renderNodeDestructive(request, task, defaultProps, -1);
					request = currentActiveSnapshot;
					if (null === request) throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
					request.context._currentValue = request.parentValue;
					request = currentActiveSnapshot = request.parent;
					task.context = request;
					task.keyPath = newProps;
					return;
				case REACT_CONSUMER_TYPE:
					props = props.children;
					type = props(type._context._currentValue);
					props = task.keyPath;
					task.keyPath = keyPath;
					renderNodeDestructive(request, task, type, -1);
					task.keyPath = props;
					return;
				case REACT_LAZY_TYPE:
					newProps = type._init;
					type = newProps(type._payload);
					if (12 === request.status) throw null;
					renderElement(request, task, keyPath, type, props, ref);
					return;
			}
			throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((null == type ? type : typeof type) + "."));
		}
	}
	function resumeNode(request, task, segmentId, node, childIndex) {
		var prevReplay = task.replay, blockedBoundary = task.blockedBoundary, resumedSegment = createPendingSegment(request, 0, null, task.formatContext, !1, !1);
		resumedSegment.id = segmentId;
		resumedSegment.parentFlushed = !0;
		try {
			task.replay = null, task.blockedSegment = resumedSegment, renderNode(request, task, node, childIndex), resumedSegment.status = 1, finishedSegment(request, blockedBoundary, resumedSegment), null === blockedBoundary ? request.completedRootSegment = resumedSegment : (queueCompletedSegment(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));
		} finally {
			task.replay = prevReplay, task.blockedSegment = null;
		}
	}
	function renderNodeDestructive(request, task, node, childIndex) {
		null !== task.replay && "number" === typeof task.replay.slots ? resumeNode(request, task, task.replay.slots, node, childIndex) : (task.node = node, task.childIndex = childIndex, node = task.componentStack, pushComponentStack(task), retryNode(request, task), task.componentStack = node);
	}
	function retryNode(request, task) {
		var node = task.node, childIndex = task.childIndex;
		if (null !== node) {
			if ("object" === typeof node) {
				switch (node.$$typeof) {
					case REACT_ELEMENT_TYPE:
						var type = node.type, key = node.key, props = node.props;
						node = props.ref;
						var ref = void 0 !== node ? node : null, name = getComponentNameFromType(type), keyOrIndex = null == key ? -1 === childIndex ? 0 : childIndex : key;
						key = [
							task.keyPath,
							name,
							keyOrIndex
						];
						if (null !== task.replay) a: {
							var replay = task.replay;
							childIndex = replay.nodes;
							for (node = 0; node < childIndex.length; node++) {
								var node$jscomp$0 = childIndex[node];
								if (keyOrIndex === node$jscomp$0[1]) {
									if (4 === node$jscomp$0.length) {
										if (null !== name && name !== node$jscomp$0[0]) throw Error("Expected the resume to render <" + node$jscomp$0[0] + "> in this slot but instead it rendered <" + name + ">. The tree doesn't match so React will fallback to client rendering.");
										var childNodes = node$jscomp$0[2];
										name = node$jscomp$0[3];
										keyOrIndex = task.node;
										task.replay = {
											nodes: childNodes,
											slots: name,
											pendingTasks: 1
										};
										try {
											renderElement(request, task, key, type, props, ref);
											if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length) throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
											task.replay.pendingTasks--;
										} catch (x) {
											if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then)) throw task.node === keyOrIndex ? task.replay = replay : childIndex.splice(node, 1), x;
											task.replay.pendingTasks--;
											props = getThrownInfo(task.componentStack);
											key = request;
											request = task.blockedBoundary;
											type = x;
											props = logRecoverableError(key, type, props);
											abortRemainingReplayNodes(key, request, childNodes, name, type, props);
										}
										task.replay = replay;
									} else {
										if (type !== REACT_SUSPENSE_TYPE) throw Error("Expected the resume to render <Suspense> in this slot but instead it rendered <" + (getComponentNameFromType(type) || "Unknown") + ">. The tree doesn't match so React will fallback to client rendering.");
										b: {
											replay = void 0;
											type = node$jscomp$0[5];
											ref = node$jscomp$0[2];
											name = node$jscomp$0[3];
											keyOrIndex = null === node$jscomp$0[4] ? [] : node$jscomp$0[4][2];
											node$jscomp$0 = null === node$jscomp$0[4] ? null : node$jscomp$0[4][3];
											var prevKeyPath = task.keyPath, prevContext = task.formatContext, prevRow = task.row, previousReplaySet = task.replay, parentBoundary = task.blockedBoundary, parentHoistableState = task.hoistableState, content = props.children, fallback = props.fallback, fallbackAbortSet = /* @__PURE__ */ new Set();
											props = 2 > task.formatContext.insertionMode ? createSuspenseBoundary(request, task.row, fallbackAbortSet, createPreambleState(), createPreambleState()) : createSuspenseBoundary(request, task.row, fallbackAbortSet, null, null);
											props.parentFlushed = !0;
											props.rootSegmentID = type;
											task.blockedBoundary = props;
											task.hoistableState = props.contentState;
											task.keyPath = key;
											task.formatContext = getSuspenseContentFormatContext(request.resumableState, prevContext);
											task.row = null;
											task.replay = {
												nodes: ref,
												slots: name,
												pendingTasks: 1
											};
											try {
												renderNode(request, task, content, -1);
												if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length) throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
												task.replay.pendingTasks--;
												if (0 === props.pendingTasks && 0 === props.status) {
													props.status = 1;
													request.completedBoundaries.push(props);
													break b;
												}
											} catch (error) {
												props.status = 4, childNodes = getThrownInfo(task.componentStack), replay = logRecoverableError(request, error, childNodes), props.errorDigest = replay, task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);
											} finally {
												task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath, task.formatContext = prevContext, task.row = prevRow;
											}
											childNodes = createReplayTask(request, null, {
												nodes: keyOrIndex,
												slots: node$jscomp$0,
												pendingTasks: 0
											}, fallback, -1, parentBoundary, props.fallbackState, fallbackAbortSet, [
												key[0],
												"Suspense Fallback",
												key[2]
											], getSuspenseFallbackFormatContext(request.resumableState, task.formatContext), task.context, task.treeContext, task.row, replaceSuspenseComponentStackWithSuspenseFallbackStack(task.componentStack));
											pushComponentStack(childNodes);
											request.pingedTasks.push(childNodes);
										}
									}
									childIndex.splice(node, 1);
									break a;
								}
							}
						}
						else renderElement(request, task, key, type, props, ref);
						return;
					case REACT_PORTAL_TYPE: throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
					case REACT_LAZY_TYPE:
						childNodes = node._init;
						node = childNodes(node._payload);
						if (12 === request.status) throw null;
						renderNodeDestructive(request, task, node, childIndex);
						return;
				}
				if (isArrayImpl(node)) {
					renderChildrenArray(request, task, node, childIndex);
					return;
				}
				if (childNodes = getIteratorFn(node)) {
					if (childNodes = childNodes.call(node)) {
						node = childNodes.next();
						if (!node.done) {
							props = [];
							do
								props.push(node.value), node = childNodes.next();
							while (!node.done);
							renderChildrenArray(request, task, props, childIndex);
						}
						return;
					}
				}
				if ("function" === typeof node.then) return task.thenableState = null, renderNodeDestructive(request, task, unwrapThenable(node), childIndex);
				if (node.$$typeof === REACT_CONTEXT_TYPE) return renderNodeDestructive(request, task, node._currentValue, childIndex);
				childIndex = Object.prototype.toString.call(node);
				throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === childIndex ? "object with keys {" + Object.keys(node).join(", ") + "}" : childIndex) + "). If you meant to render a collection of children, use an array instead.");
			}
			if ("string" === typeof node) childIndex = task.blockedSegment, null !== childIndex && (childIndex.lastPushedText = pushTextInstance(childIndex.chunks, node, request.renderState, childIndex.lastPushedText));
			else if ("number" === typeof node || "bigint" === typeof node) childIndex = task.blockedSegment, null !== childIndex && (childIndex.lastPushedText = pushTextInstance(childIndex.chunks, "" + node, request.renderState, childIndex.lastPushedText));
		}
	}
	function renderChildrenArray(request, task, children, childIndex) {
		var prevKeyPath = task.keyPath;
		if (-1 !== childIndex && (task.keyPath = [
			task.keyPath,
			"Fragment",
			childIndex
		], null !== task.replay)) {
			for (var replay = task.replay, replayNodes = replay.nodes, j = 0; j < replayNodes.length; j++) {
				var node = replayNodes[j];
				if (node[1] === childIndex) {
					childIndex = node[2];
					node = node[3];
					task.replay = {
						nodes: childIndex,
						slots: node,
						pendingTasks: 1
					};
					try {
						renderChildrenArray(request, task, children, -1);
						if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length) throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
						task.replay.pendingTasks--;
					} catch (x) {
						if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then)) throw x;
						task.replay.pendingTasks--;
						children = getThrownInfo(task.componentStack);
						var boundary = task.blockedBoundary, error = x;
						children = logRecoverableError(request, error, children);
						abortRemainingReplayNodes(request, boundary, childIndex, node, error, children);
					}
					task.replay = replay;
					replayNodes.splice(j, 1);
					break;
				}
			}
			task.keyPath = prevKeyPath;
			return;
		}
		replay = task.treeContext;
		replayNodes = children.length;
		if (null !== task.replay && (j = task.replay.slots, null !== j && "object" === typeof j)) {
			for (childIndex = 0; childIndex < replayNodes; childIndex++) node = children[childIndex], task.treeContext = pushTreeContext(replay, replayNodes, childIndex), boundary = j[childIndex], "number" === typeof boundary ? (resumeNode(request, task, boundary, node, childIndex), delete j[childIndex]) : renderNode(request, task, node, childIndex);
			task.treeContext = replay;
			task.keyPath = prevKeyPath;
			return;
		}
		for (j = 0; j < replayNodes; j++) childIndex = children[j], task.treeContext = pushTreeContext(replay, replayNodes, j), renderNode(request, task, childIndex, j);
		task.treeContext = replay;
		task.keyPath = prevKeyPath;
	}
	function trackPostponedBoundary(request, trackedPostpones, boundary) {
		boundary.status = 5;
		boundary.rootSegmentID = request.nextSegmentId++;
		request = boundary.trackedContentKeyPath;
		if (null === request) throw Error("It should not be possible to postpone at the root. This is a bug in React.");
		var fallbackReplayNode = boundary.trackedFallbackNode, children = [], boundaryNode = trackedPostpones.workingMap.get(request);
		if (void 0 === boundaryNode) return boundary = [
			request[1],
			request[2],
			children,
			null,
			fallbackReplayNode,
			boundary.rootSegmentID
		], trackedPostpones.workingMap.set(request, boundary), addToReplayParent(boundary, request[0], trackedPostpones), boundary;
		boundaryNode[4] = fallbackReplayNode;
		boundaryNode[5] = boundary.rootSegmentID;
		return boundaryNode;
	}
	function trackPostpone(request, trackedPostpones, task, segment) {
		segment.status = 5;
		var keyPath = task.keyPath, boundary = task.blockedBoundary;
		if (null === boundary) segment.id = request.nextSegmentId++, trackedPostpones.rootSlots = segment.id, null !== request.completedRootSegment && (request.completedRootSegment.status = 5);
		else {
			if (null !== boundary && 0 === boundary.status) {
				var boundaryNode = trackPostponedBoundary(request, trackedPostpones, boundary);
				if (boundary.trackedContentKeyPath === keyPath && -1 === task.childIndex) {
					-1 === segment.id && (segment.id = segment.parentFlushed ? boundary.rootSegmentID : request.nextSegmentId++);
					boundaryNode[3] = segment.id;
					return;
				}
			}
			-1 === segment.id && (segment.id = segment.parentFlushed && null !== boundary ? boundary.rootSegmentID : request.nextSegmentId++);
			if (-1 === task.childIndex) null === keyPath ? trackedPostpones.rootSlots = segment.id : (task = trackedPostpones.workingMap.get(keyPath), void 0 === task ? (task = [
				keyPath[1],
				keyPath[2],
				[],
				segment.id
			], addToReplayParent(task, keyPath[0], trackedPostpones)) : task[3] = segment.id);
			else {
				if (null === keyPath) {
					if (request = trackedPostpones.rootSlots, null === request) request = trackedPostpones.rootSlots = {};
					else if ("number" === typeof request) throw Error("It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.");
				} else if (boundary = trackedPostpones.workingMap, boundaryNode = boundary.get(keyPath), void 0 === boundaryNode) request = {}, boundaryNode = [
					keyPath[1],
					keyPath[2],
					[],
					request
				], boundary.set(keyPath, boundaryNode), addToReplayParent(boundaryNode, keyPath[0], trackedPostpones);
				else if (request = boundaryNode[3], null === request) request = boundaryNode[3] = {};
				else if ("number" === typeof request) throw Error("It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.");
				request[task.childIndex] = segment.id;
			}
		}
	}
	function untrackBoundary(request, boundary) {
		request = request.trackedPostpones;
		null !== request && (boundary = boundary.trackedContentKeyPath, null !== boundary && (boundary = request.workingMap.get(boundary), void 0 !== boundary && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));
	}
	function spawnNewSuspendedReplayTask(request, task, thenableState$2) {
		return createReplayTask(request, thenableState$2, task.replay, task.node, task.childIndex, task.blockedBoundary, task.hoistableState, task.abortSet, task.keyPath, task.formatContext, task.context, task.treeContext, task.row, task.componentStack);
	}
	function spawnNewSuspendedRenderTask(request, task, thenableState$2) {
		var segment = task.blockedSegment, newSegment = createPendingSegment(request, segment.chunks.length, null, task.formatContext, segment.lastPushedText, !0);
		segment.children.push(newSegment);
		segment.lastPushedText = !1;
		return createRenderTask(request, thenableState$2, task.node, task.childIndex, task.blockedBoundary, newSegment, task.blockedPreamble, task.hoistableState, task.abortSet, task.keyPath, task.formatContext, task.context, task.treeContext, task.row, task.componentStack);
	}
	function renderNode(request, task, node, childIndex) {
		var previousFormatContext = task.formatContext, previousContext = task.context, previousKeyPath = task.keyPath, previousTreeContext = task.treeContext, previousComponentStack = task.componentStack, segment = task.blockedSegment;
		if (null === segment) {
			segment = task.replay;
			try {
				return renderNodeDestructive(request, task, node, childIndex);
			} catch (thrownValue) {
				if (resetHooksState(), node = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue, 12 !== request.status && "object" === typeof node && null !== node) {
					if ("function" === typeof node.then) {
						childIndex = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
						request = spawnNewSuspendedReplayTask(request, task, childIndex).ping;
						node.then(request, request);
						task.formatContext = previousFormatContext;
						task.context = previousContext;
						task.keyPath = previousKeyPath;
						task.treeContext = previousTreeContext;
						task.componentStack = previousComponentStack;
						task.replay = segment;
						switchContext(previousContext);
						return;
					}
					if ("Maximum call stack size exceeded" === node.message) {
						node = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
						node = spawnNewSuspendedReplayTask(request, task, node);
						request.pingedTasks.push(node);
						task.formatContext = previousFormatContext;
						task.context = previousContext;
						task.keyPath = previousKeyPath;
						task.treeContext = previousTreeContext;
						task.componentStack = previousComponentStack;
						task.replay = segment;
						switchContext(previousContext);
						return;
					}
				}
			}
		} else {
			var childrenLength = segment.children.length, chunkLength = segment.chunks.length;
			try {
				return renderNodeDestructive(request, task, node, childIndex);
			} catch (thrownValue$63) {
				if (resetHooksState(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node = thrownValue$63 === SuspenseException ? getSuspendedThenable() : thrownValue$63, 12 !== request.status && "object" === typeof node && null !== node) {
					if ("function" === typeof node.then) {
						segment = node;
						node = thrownValue$63 === SuspenseException ? getThenableStateAfterSuspending() : null;
						request = spawnNewSuspendedRenderTask(request, task, node).ping;
						segment.then(request, request);
						task.formatContext = previousFormatContext;
						task.context = previousContext;
						task.keyPath = previousKeyPath;
						task.treeContext = previousTreeContext;
						task.componentStack = previousComponentStack;
						switchContext(previousContext);
						return;
					}
					if ("Maximum call stack size exceeded" === node.message) {
						segment = thrownValue$63 === SuspenseException ? getThenableStateAfterSuspending() : null;
						segment = spawnNewSuspendedRenderTask(request, task, segment);
						request.pingedTasks.push(segment);
						task.formatContext = previousFormatContext;
						task.context = previousContext;
						task.keyPath = previousKeyPath;
						task.treeContext = previousTreeContext;
						task.componentStack = previousComponentStack;
						switchContext(previousContext);
						return;
					}
				}
			}
		}
		task.formatContext = previousFormatContext;
		task.context = previousContext;
		task.keyPath = previousKeyPath;
		task.treeContext = previousTreeContext;
		switchContext(previousContext);
		throw node;
	}
	function abortTaskSoft(task) {
		var boundary = task.blockedBoundary, segment = task.blockedSegment;
		null !== segment && (segment.status = 3, finishedTask(this, boundary, task.row, segment));
	}
	function abortRemainingReplayNodes(request$jscomp$0, boundary, nodes, slots, error, errorDigest$jscomp$0) {
		for (var i = 0; i < nodes.length; i++) {
			var node = nodes[i];
			if (4 === node.length) abortRemainingReplayNodes(request$jscomp$0, boundary, node[2], node[3], error, errorDigest$jscomp$0);
			else {
				node = node[5];
				var request = request$jscomp$0, errorDigest = errorDigest$jscomp$0, resumedBoundary = createSuspenseBoundary(request, null, /* @__PURE__ */ new Set(), null, null);
				resumedBoundary.parentFlushed = !0;
				resumedBoundary.rootSegmentID = node;
				resumedBoundary.status = 4;
				resumedBoundary.errorDigest = errorDigest;
				resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);
			}
		}
		nodes.length = 0;
		if (null !== slots) {
			if (null === boundary) throw Error("We should not have any resumable nodes in the shell. This is a bug in React.");
			4 !== boundary.status && (boundary.status = 4, boundary.errorDigest = errorDigest$jscomp$0, boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));
			if ("object" === typeof slots) for (var index in slots) delete slots[index];
		}
	}
	function abortTask(task, request, error) {
		var boundary = task.blockedBoundary, segment = task.blockedSegment;
		if (null !== segment) {
			if (6 === segment.status) return;
			segment.status = 3;
		}
		var errorInfo = getThrownInfo(task.componentStack);
		if (null === boundary) {
			if (13 !== request.status && 14 !== request.status) {
				boundary = task.replay;
				if (null === boundary) {
					null !== request.trackedPostpones && null !== segment ? (boundary = request.trackedPostpones, logRecoverableError(request, error, errorInfo), trackPostpone(request, boundary, task, segment), finishedTask(request, null, task.row, segment)) : (logRecoverableError(request, error, errorInfo), fatalError(request, error));
					return;
				}
				boundary.pendingTasks--;
				0 === boundary.pendingTasks && 0 < boundary.nodes.length && (segment = logRecoverableError(request, error, errorInfo), abortRemainingReplayNodes(request, null, boundary.nodes, boundary.slots, error, segment));
				request.pendingRootTasks--;
				0 === request.pendingRootTasks && completeShell(request);
			}
		} else {
			var trackedPostpones$64 = request.trackedPostpones;
			if (4 !== boundary.status) {
				if (null !== trackedPostpones$64 && null !== segment) return logRecoverableError(request, error, errorInfo), trackPostpone(request, trackedPostpones$64, task, segment), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
					return abortTask(fallbackTask, request, error);
				}), boundary.fallbackAbortableTasks.clear(), finishedTask(request, boundary, task.row, segment);
				boundary.status = 4;
				segment = logRecoverableError(request, error, errorInfo);
				boundary.status = 4;
				boundary.errorDigest = segment;
				untrackBoundary(request, boundary);
				boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);
			}
			boundary.pendingTasks--;
			segment = boundary.row;
			null !== segment && 0 === --segment.pendingTasks && finishSuspenseListRow(request, segment);
			boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
				return abortTask(fallbackTask, request, error);
			});
			boundary.fallbackAbortableTasks.clear();
		}
		task = task.row;
		null !== task && 0 === --task.pendingTasks && finishSuspenseListRow(request, task);
		request.allPendingTasks--;
		0 === request.allPendingTasks && completeAll(request);
	}
	function safelyEmitEarlyPreloads(request, shellComplete) {
		try {
			var renderState = request.renderState, onHeaders = renderState.onHeaders;
			if (onHeaders) {
				var headers = renderState.headers;
				if (headers) {
					renderState.headers = null;
					var linkHeader = headers.preconnects;
					headers.fontPreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.fontPreloads);
					headers.highImagePreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.highImagePreloads);
					if (!shellComplete) {
						var queueIter = renderState.styles.values(), queueStep = queueIter.next();
						b: for (; 0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next()) for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next(); 0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {
							var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props, header = getPreloadAsHeader(props$jscomp$0.href, "style", {
								crossOrigin: props$jscomp$0.crossOrigin,
								integrity: props$jscomp$0.integrity,
								nonce: props$jscomp$0.nonce,
								type: props$jscomp$0.type,
								fetchPriority: props$jscomp$0.fetchPriority,
								referrerPolicy: props$jscomp$0.referrerPolicy,
								media: props$jscomp$0.media
							});
							if (0 <= (headers.remainingCapacity -= header.length + 2)) renderState.resets.style[key] = PRELOAD_NO_CREDS, linkHeader && (linkHeader += ", "), linkHeader += header, renderState.resets.style[key] = "string" === typeof props.crossOrigin || "string" === typeof props.integrity ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS;
							else break b;
						}
					}
					linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});
				}
			}
		} catch (error) {
			logRecoverableError(request, error, {});
		}
	}
	function completeShell(request) {
		null === request.trackedPostpones && safelyEmitEarlyPreloads(request, !0);
		null === request.trackedPostpones && preparePreamble(request);
		request.onShellError = noop;
		request = request.onShellReady;
		request();
	}
	function completeAll(request) {
		safelyEmitEarlyPreloads(request, null === request.trackedPostpones ? !0 : null === request.completedRootSegment || 5 !== request.completedRootSegment.status);
		preparePreamble(request);
		request = request.onAllReady;
		request();
	}
	function queueCompletedSegment(boundary, segment) {
		if (0 === segment.chunks.length && 1 === segment.children.length && null === segment.children[0].boundary && -1 === segment.children[0].id) {
			var childSegment = segment.children[0];
			childSegment.id = segment.id;
			childSegment.parentFlushed = !0;
			1 !== childSegment.status && 3 !== childSegment.status && 4 !== childSegment.status || queueCompletedSegment(boundary, childSegment);
		} else boundary.completedSegments.push(segment);
	}
	function finishedSegment(request, boundary, segment) {
		if (null !== byteLengthOfChunk) {
			segment = segment.chunks;
			for (var segmentByteSize = 0, i = 0; i < segment.length; i++) segmentByteSize += byteLengthOfChunk(segment[i]);
			null === boundary ? request.byteSize += segmentByteSize : boundary.byteSize += segmentByteSize;
		}
	}
	function finishedTask(request, boundary, row, segment) {
		null !== row && (0 === --row.pendingTasks ? finishSuspenseListRow(request, row) : row.together && tryToResolveTogetherRow(request, row));
		request.allPendingTasks--;
		if (null === boundary) {
			if (null !== segment && segment.parentFlushed) {
				if (null !== request.completedRootSegment) throw Error("There can only be one root segment. This is a bug in React.");
				request.completedRootSegment = segment;
			}
			request.pendingRootTasks--;
			0 === request.pendingRootTasks && completeShell(request);
		} else if (boundary.pendingTasks--, 4 !== boundary.status) if (0 === boundary.pendingTasks) {
			if (0 === boundary.status && (boundary.status = 1), null !== segment && segment.parentFlushed && (1 === segment.status || 3 === segment.status) && queueCompletedSegment(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), 1 === boundary.status) row = boundary.row, null !== row && hoistHoistables(row.hoistables, boundary.contentState), isEligibleForOutlining(request, boundary) || (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request), boundary.fallbackAbortableTasks.clear(), null !== row && 0 === --row.pendingTasks && finishSuspenseListRow(request, row)), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary.contentPreamble && preparePreamble(request);
			else if (5 === boundary.status && (boundary = boundary.row, null !== boundary)) {
				if (null !== request.trackedPostpones) {
					row = request.trackedPostpones;
					var postponedRow = boundary.next;
					if (null !== postponedRow && (segment = postponedRow.boundaries, null !== segment)) for (postponedRow.boundaries = null, postponedRow = 0; postponedRow < segment.length; postponedRow++) {
						var postponedBoundary = segment[postponedRow];
						trackPostponedBoundary(request, row, postponedBoundary);
						finishedTask(request, postponedBoundary, null, null);
					}
				}
				0 === --boundary.pendingTasks && finishSuspenseListRow(request, boundary);
			}
		} else null === segment || !segment.parentFlushed || 1 !== segment.status && 3 !== segment.status || (queueCompletedSegment(boundary, segment), 1 === boundary.completedSegments.length && boundary.parentFlushed && request.partialBoundaries.push(boundary)), boundary = boundary.row, null !== boundary && boundary.together && tryToResolveTogetherRow(request, boundary);
		0 === request.allPendingTasks && completeAll(request);
	}
	function performWork(request$jscomp$2) {
		if (14 !== request$jscomp$2.status && 13 !== request$jscomp$2.status) {
			var prevContext = currentActiveSnapshot, prevDispatcher = ReactSharedInternals.H;
			ReactSharedInternals.H = HooksDispatcher;
			var prevAsyncDispatcher = ReactSharedInternals.A;
			ReactSharedInternals.A = DefaultAsyncDispatcher;
			var prevRequest = currentRequest;
			currentRequest = request$jscomp$2;
			var prevResumableState = currentResumableState;
			currentResumableState = request$jscomp$2.resumableState;
			try {
				var pingedTasks = request$jscomp$2.pingedTasks, i;
				for (i = 0; i < pingedTasks.length; i++) {
					var task = pingedTasks[i], request = request$jscomp$2, segment = task.blockedSegment;
					if (null === segment) {
						var request$jscomp$0 = request;
						if (0 !== task.replay.pendingTasks) {
							switchContext(task.context);
							try {
								"number" === typeof task.replay.slots ? resumeNode(request$jscomp$0, task, task.replay.slots, task.node, task.childIndex) : retryNode(request$jscomp$0, task);
								if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length) throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
								task.replay.pendingTasks--;
								task.abortSet.delete(task);
								finishedTask(request$jscomp$0, task.blockedBoundary, task.row, null);
							} catch (thrownValue) {
								resetHooksState();
								var x = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;
								if ("object" === typeof x && null !== x && "function" === typeof x.then) {
									var ping = task.ping;
									x.then(ping, ping);
									task.thenableState = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
								} else {
									task.replay.pendingTasks--;
									task.abortSet.delete(task);
									var errorInfo = getThrownInfo(task.componentStack);
									request = void 0;
									var request$jscomp$1 = request$jscomp$0, boundary = task.blockedBoundary, error$jscomp$0 = 12 === request$jscomp$0.status ? request$jscomp$0.fatalError : x, replayNodes = task.replay.nodes, resumeSlots = task.replay.slots;
									request = logRecoverableError(request$jscomp$1, error$jscomp$0, errorInfo);
									abortRemainingReplayNodes(request$jscomp$1, boundary, replayNodes, resumeSlots, error$jscomp$0, request);
									request$jscomp$0.pendingRootTasks--;
									0 === request$jscomp$0.pendingRootTasks && completeShell(request$jscomp$0);
									request$jscomp$0.allPendingTasks--;
									0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);
								}
							}
						}
					} else if (request$jscomp$0 = void 0, request$jscomp$1 = segment, 0 === request$jscomp$1.status) {
						request$jscomp$1.status = 6;
						switchContext(task.context);
						var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;
						try {
							retryNode(request, task), request$jscomp$1.lastPushedText && request$jscomp$1.textEmbedded && request$jscomp$1.chunks.push(textSeparator), task.abortSet.delete(task), request$jscomp$1.status = 1, finishedSegment(request, task.blockedBoundary, request$jscomp$1), finishedTask(request, task.blockedBoundary, task.row, request$jscomp$1);
						} catch (thrownValue) {
							resetHooksState();
							request$jscomp$1.children.length = childrenLength;
							request$jscomp$1.chunks.length = chunkLength;
							var x$jscomp$0 = thrownValue === SuspenseException ? getSuspendedThenable() : 12 === request.status ? request.fatalError : thrownValue;
							if (12 === request.status && null !== request.trackedPostpones) {
								var trackedPostpones = request.trackedPostpones, thrownInfo = getThrownInfo(task.componentStack);
								task.abortSet.delete(task);
								logRecoverableError(request, x$jscomp$0, thrownInfo);
								trackPostpone(request, trackedPostpones, task, request$jscomp$1);
								finishedTask(request, task.blockedBoundary, task.row, request$jscomp$1);
							} else if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0 && "function" === typeof x$jscomp$0.then) {
								request$jscomp$1.status = 0;
								task.thenableState = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
								var ping$jscomp$0 = task.ping;
								x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
							} else {
								var errorInfo$jscomp$0 = getThrownInfo(task.componentStack);
								task.abortSet.delete(task);
								request$jscomp$1.status = 4;
								var boundary$jscomp$0 = task.blockedBoundary, row = task.row;
								null !== row && 0 === --row.pendingTasks && finishSuspenseListRow(request, row);
								request.allPendingTasks--;
								request$jscomp$0 = logRecoverableError(request, x$jscomp$0, errorInfo$jscomp$0);
								if (null === boundary$jscomp$0) fatalError(request, x$jscomp$0);
								else if (boundary$jscomp$0.pendingTasks--, 4 !== boundary$jscomp$0.status) {
									boundary$jscomp$0.status = 4;
									boundary$jscomp$0.errorDigest = request$jscomp$0;
									untrackBoundary(request, boundary$jscomp$0);
									var boundaryRow = boundary$jscomp$0.row;
									null !== boundaryRow && 0 === --boundaryRow.pendingTasks && finishSuspenseListRow(request, boundaryRow);
									boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(boundary$jscomp$0);
									0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary$jscomp$0.contentPreamble && preparePreamble(request);
								}
								0 === request.allPendingTasks && completeAll(request);
							}
						}
					}
				}
				pingedTasks.splice(0, i);
				null !== request$jscomp$2.destination && flushCompletedQueues(request$jscomp$2, request$jscomp$2.destination);
			} catch (error) {
				logRecoverableError(request$jscomp$2, error, {}), fatalError(request$jscomp$2, error);
			} finally {
				currentResumableState = prevResumableState, ReactSharedInternals.H = prevDispatcher, ReactSharedInternals.A = prevAsyncDispatcher, prevDispatcher === HooksDispatcher && switchContext(prevContext), currentRequest = prevRequest;
			}
		}
	}
	function preparePreambleFromSubtree(request, segment, collectedPreambleSegments) {
		segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);
		for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++) pendingPreambles = preparePreambleFromSegment(request, segment.children[i], collectedPreambleSegments) || pendingPreambles;
		return pendingPreambles;
	}
	function preparePreambleFromSegment(request, segment, collectedPreambleSegments) {
		var boundary = segment.boundary;
		if (null === boundary) return preparePreambleFromSubtree(request, segment, collectedPreambleSegments);
		var preamble = boundary.contentPreamble, fallbackPreamble = boundary.fallbackPreamble;
		if (null === preamble || null === fallbackPreamble) return !1;
		switch (boundary.status) {
			case 1:
				hoistPreambleState(request.renderState, preamble);
				request.byteSize += boundary.byteSize;
				segment = boundary.completedSegments[0];
				if (!segment) throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
				return preparePreambleFromSubtree(request, segment, collectedPreambleSegments);
			case 5: if (null !== request.trackedPostpones) return !0;
			case 4: if (1 === segment.status) return hoistPreambleState(request.renderState, fallbackPreamble), preparePreambleFromSubtree(request, segment, collectedPreambleSegments);
			default: return !0;
		}
	}
	function preparePreamble(request) {
		if (request.completedRootSegment && null === request.completedPreambleSegments) {
			var collectedPreambleSegments = [], originalRequestByteSize = request.byteSize, hasPendingPreambles = preparePreambleFromSegment(request, request.completedRootSegment, collectedPreambleSegments), preamble = request.renderState.preamble;
			!1 === hasPendingPreambles || preamble.headChunks && preamble.bodyChunks ? request.completedPreambleSegments = collectedPreambleSegments : request.byteSize = originalRequestByteSize;
		}
	}
	function flushSubtree(request, destination, segment, hoistableState) {
		segment.parentFlushed = !0;
		switch (segment.status) {
			case 0: segment.id = request.nextSegmentId++;
			case 5: return hoistableState = segment.id, segment.lastPushedText = !1, segment.textEmbedded = !1, request = request.renderState, writeChunk(destination, placeholder1), writeChunk(destination, request.placeholderPrefix), request = hoistableState.toString(16), writeChunk(destination, request), writeChunkAndReturn(destination, placeholder2);
			case 1:
				segment.status = 2;
				var r = !0, chunks = segment.chunks, chunkIdx = 0;
				segment = segment.children;
				for (var childIdx = 0; childIdx < segment.length; childIdx++) {
					for (r = segment[childIdx]; chunkIdx < r.index; chunkIdx++) writeChunk(destination, chunks[chunkIdx]);
					r = flushSegment(request, destination, r, hoistableState);
				}
				for (; chunkIdx < chunks.length - 1; chunkIdx++) writeChunk(destination, chunks[chunkIdx]);
				chunkIdx < chunks.length && (r = writeChunkAndReturn(destination, chunks[chunkIdx]));
				return r;
			case 3: return !0;
			default: throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
		}
	}
	var flushedByteSize = 0;
	function flushSegment(request, destination, segment, hoistableState) {
		var boundary = segment.boundary;
		if (null === boundary) return flushSubtree(request, destination, segment, hoistableState);
		boundary.parentFlushed = !0;
		if (4 === boundary.status) {
			var row = boundary.row;
			null !== row && 0 === --row.pendingTasks && finishSuspenseListRow(request, row);
			boundary = boundary.errorDigest;
			writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
			writeChunk(destination, clientRenderedSuspenseBoundaryError1);
			boundary && (writeChunk(destination, clientRenderedSuspenseBoundaryError1A), writeChunk(destination, escapeTextForBrowser(boundary)), writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial));
			writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
			flushSubtree(request, destination, segment, hoistableState);
		} else if (1 !== boundary.status) 0 === boundary.status && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary(destination, request.renderState, boundary.rootSegmentID), hoistableState && hoistHoistables(hoistableState, boundary.fallbackState), flushSubtree(request, destination, segment, hoistableState);
		else if (!flushingPartialBoundaries && isEligibleForOutlining(request, boundary) && (flushedByteSize + boundary.byteSize > request.progressiveChunkSize || hasSuspenseyContent(boundary.contentState))) boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary(destination, request.renderState, boundary.rootSegmentID), flushSubtree(request, destination, segment, hoistableState);
		else {
			flushedByteSize += boundary.byteSize;
			hoistableState && hoistHoistables(hoistableState, boundary.contentState);
			segment = boundary.row;
			null !== segment && isEligibleForOutlining(request, boundary) && 0 === --segment.pendingTasks && finishSuspenseListRow(request, segment);
			writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
			segment = boundary.completedSegments;
			if (1 !== segment.length) throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
			flushSegment(request, destination, segment[0], hoistableState);
		}
		return writeChunkAndReturn(destination, endSuspenseBoundary);
	}
	function flushSegmentContainer(request, destination, segment, hoistableState) {
		writeStartSegment(destination, request.renderState, segment.parentFormatContext, segment.id);
		flushSegment(request, destination, segment, hoistableState);
		return writeEndSegment(destination, segment.parentFormatContext);
	}
	function flushCompletedBoundary(request, destination, boundary) {
		flushedByteSize = boundary.byteSize;
		for (var completedSegments = boundary.completedSegments, i = 0; i < completedSegments.length; i++) flushPartiallyCompletedSegment(request, destination, boundary, completedSegments[i]);
		completedSegments.length = 0;
		completedSegments = boundary.row;
		null !== completedSegments && isEligibleForOutlining(request, boundary) && 0 === --completedSegments.pendingTasks && finishSuspenseListRow(request, completedSegments);
		writeHoistablesForBoundary(destination, boundary.contentState, request.renderState);
		completedSegments = request.resumableState;
		request = request.renderState;
		i = boundary.rootSegmentID;
		boundary = boundary.contentState;
		var requiresStyleInsertion = request.stylesToHoist;
		request.stylesToHoist = !1;
		writeChunk(destination, request.startInlineScript);
		writeChunk(destination, endOfStartTag);
		requiresStyleInsertion ? (0 === (completedSegments.instructions & 4) && (completedSegments.instructions |= 4, writeChunk(destination, clientRenderScriptFunctionOnly)), 0 === (completedSegments.instructions & 2) && (completedSegments.instructions |= 2, writeChunk(destination, completeBoundaryScriptFunctionOnly)), 0 === (completedSegments.instructions & 8) ? (completedSegments.instructions |= 8, writeChunk(destination, completeBoundaryWithStylesScript1FullPartial)) : writeChunk(destination, completeBoundaryWithStylesScript1Partial)) : (0 === (completedSegments.instructions & 2) && (completedSegments.instructions |= 2, writeChunk(destination, completeBoundaryScriptFunctionOnly)), writeChunk(destination, completeBoundaryScript1Partial));
		completedSegments = i.toString(16);
		writeChunk(destination, request.boundaryPrefix);
		writeChunk(destination, completedSegments);
		writeChunk(destination, completeBoundaryScript2);
		writeChunk(destination, request.segmentPrefix);
		writeChunk(destination, completedSegments);
		requiresStyleInsertion ? (writeChunk(destination, completeBoundaryScript3a), writeStyleResourceDependenciesInJS(destination, boundary)) : writeChunk(destination, completeBoundaryScript3b);
		boundary = writeChunkAndReturn(destination, completeBoundaryScriptEnd);
		return writeBootstrap(destination, request) && boundary;
	}
	function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
		if (2 === segment.status) return !0;
		var hoistableState = boundary.contentState, segmentID = segment.id;
		if (-1 === segmentID) {
			if (-1 === (segment.id = boundary.rootSegmentID)) throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
			return flushSegmentContainer(request, destination, segment, hoistableState);
		}
		if (segmentID === boundary.rootSegmentID) return flushSegmentContainer(request, destination, segment, hoistableState);
		flushSegmentContainer(request, destination, segment, hoistableState);
		boundary = request.resumableState;
		request = request.renderState;
		writeChunk(destination, request.startInlineScript);
		writeChunk(destination, endOfStartTag);
		0 === (boundary.instructions & 1) ? (boundary.instructions |= 1, writeChunk(destination, completeSegmentScript1Full)) : writeChunk(destination, completeSegmentScript1Partial);
		writeChunk(destination, request.segmentPrefix);
		segmentID = segmentID.toString(16);
		writeChunk(destination, segmentID);
		writeChunk(destination, completeSegmentScript2);
		writeChunk(destination, request.placeholderPrefix);
		writeChunk(destination, segmentID);
		destination = writeChunkAndReturn(destination, completeSegmentScriptEnd);
		return destination;
	}
	var flushingPartialBoundaries = !1;
	function flushCompletedQueues(request, destination) {
		currentView = new Uint8Array(2048);
		writtenBytes = 0;
		destinationHasCapacity$1 = !0;
		try {
			if (!(0 < request.pendingRootTasks)) {
				var i, completedRootSegment = request.completedRootSegment;
				if (null !== completedRootSegment) {
					if (5 === completedRootSegment.status) return;
					var completedPreambleSegments = request.completedPreambleSegments;
					if (null === completedPreambleSegments) return;
					flushedByteSize = request.byteSize;
					var resumableState = request.resumableState, renderState = request.renderState, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;
					if (htmlChunks) {
						for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++) writeChunk(destination, htmlChunks[i$jscomp$0]);
						if (headChunks) for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++) writeChunk(destination, headChunks[i$jscomp$0]);
						else writeChunk(destination, startChunkForTag("head")), writeChunk(destination, endOfStartTag);
					} else if (headChunks) for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++) writeChunk(destination, headChunks[i$jscomp$0]);
					var charsetChunks = renderState.charsetChunks;
					for (i$jscomp$0 = 0; i$jscomp$0 < charsetChunks.length; i$jscomp$0++) writeChunk(destination, charsetChunks[i$jscomp$0]);
					charsetChunks.length = 0;
					renderState.preconnects.forEach(flushResource, destination);
					renderState.preconnects.clear();
					var viewportChunks = renderState.viewportChunks;
					for (i$jscomp$0 = 0; i$jscomp$0 < viewportChunks.length; i$jscomp$0++) writeChunk(destination, viewportChunks[i$jscomp$0]);
					viewportChunks.length = 0;
					renderState.fontPreloads.forEach(flushResource, destination);
					renderState.fontPreloads.clear();
					renderState.highImagePreloads.forEach(flushResource, destination);
					renderState.highImagePreloads.clear();
					currentlyFlushingRenderState = renderState;
					renderState.styles.forEach(flushStylesInPreamble, destination);
					currentlyFlushingRenderState = null;
					var importMapChunks = renderState.importMapChunks;
					for (i$jscomp$0 = 0; i$jscomp$0 < importMapChunks.length; i$jscomp$0++) writeChunk(destination, importMapChunks[i$jscomp$0]);
					importMapChunks.length = 0;
					renderState.bootstrapScripts.forEach(flushResource, destination);
					renderState.scripts.forEach(flushResource, destination);
					renderState.scripts.clear();
					renderState.bulkPreloads.forEach(flushResource, destination);
					renderState.bulkPreloads.clear();
					htmlChunks || headChunks || (resumableState.instructions |= 32);
					var hoistableChunks = renderState.hoistableChunks;
					for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++) writeChunk(destination, hoistableChunks[i$jscomp$0]);
					for (resumableState = hoistableChunks.length = 0; resumableState < completedPreambleSegments.length; resumableState++) {
						var segments = completedPreambleSegments[resumableState];
						for (renderState = 0; renderState < segments.length; renderState++) flushSegment(request, destination, segments[renderState], null);
					}
					var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
					(preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) && writeChunk(destination, endChunkForTag("head"));
					var bodyChunks = preamble$jscomp$0.bodyChunks;
					if (bodyChunks) for (completedPreambleSegments = 0; completedPreambleSegments < bodyChunks.length; completedPreambleSegments++) writeChunk(destination, bodyChunks[completedPreambleSegments]);
					flushSegment(request, destination, completedRootSegment, null);
					request.completedRootSegment = null;
					var renderState$jscomp$0 = request.renderState;
					if (0 !== request.allPendingTasks || 0 !== request.clientRenderedBoundaries.length || 0 !== request.completedBoundaries.length || null !== request.trackedPostpones && (0 !== request.trackedPostpones.rootNodes.length || null !== request.trackedPostpones.rootSlots)) {
						var resumableState$jscomp$0 = request.resumableState;
						if (0 === (resumableState$jscomp$0.instructions & 64)) {
							resumableState$jscomp$0.instructions |= 64;
							writeChunk(destination, renderState$jscomp$0.startInlineScript);
							if (0 === (resumableState$jscomp$0.instructions & 32)) {
								resumableState$jscomp$0.instructions |= 32;
								var shellId = "_" + resumableState$jscomp$0.idPrefix + "R_";
								writeChunk(destination, completedShellIdAttributeStart);
								writeChunk(destination, escapeTextForBrowser(shellId));
								writeChunk(destination, attributeEnd);
							}
							writeChunk(destination, endOfStartTag);
							writeChunk(destination, shellTimeRuntimeScript);
							writeChunkAndReturn(destination, endInlineScript);
						}
					}
					writeBootstrap(destination, renderState$jscomp$0);
				}
				var renderState$jscomp$1 = request.renderState;
				completedRootSegment = 0;
				var viewportChunks$jscomp$0 = renderState$jscomp$1.viewportChunks;
				for (completedRootSegment = 0; completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++) writeChunk(destination, viewportChunks$jscomp$0[completedRootSegment]);
				viewportChunks$jscomp$0.length = 0;
				renderState$jscomp$1.preconnects.forEach(flushResource, destination);
				renderState$jscomp$1.preconnects.clear();
				renderState$jscomp$1.fontPreloads.forEach(flushResource, destination);
				renderState$jscomp$1.fontPreloads.clear();
				renderState$jscomp$1.highImagePreloads.forEach(flushResource, destination);
				renderState$jscomp$1.highImagePreloads.clear();
				renderState$jscomp$1.styles.forEach(preloadLateStyles, destination);
				renderState$jscomp$1.scripts.forEach(flushResource, destination);
				renderState$jscomp$1.scripts.clear();
				renderState$jscomp$1.bulkPreloads.forEach(flushResource, destination);
				renderState$jscomp$1.bulkPreloads.clear();
				var hoistableChunks$jscomp$0 = renderState$jscomp$1.hoistableChunks;
				for (completedRootSegment = 0; completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++) writeChunk(destination, hoistableChunks$jscomp$0[completedRootSegment]);
				hoistableChunks$jscomp$0.length = 0;
				var clientRenderedBoundaries = request.clientRenderedBoundaries;
				for (i = 0; i < clientRenderedBoundaries.length; i++) {
					var boundary = clientRenderedBoundaries[i];
					renderState$jscomp$1 = destination;
					var resumableState$jscomp$1 = request.resumableState, renderState$jscomp$2 = request.renderState, id = boundary.rootSegmentID, errorDigest = boundary.errorDigest;
					writeChunk(renderState$jscomp$1, renderState$jscomp$2.startInlineScript);
					writeChunk(renderState$jscomp$1, endOfStartTag);
					0 === (resumableState$jscomp$1.instructions & 4) ? (resumableState$jscomp$1.instructions |= 4, writeChunk(renderState$jscomp$1, clientRenderScript1Full)) : writeChunk(renderState$jscomp$1, clientRenderScript1Partial);
					writeChunk(renderState$jscomp$1, renderState$jscomp$2.boundaryPrefix);
					writeChunk(renderState$jscomp$1, id.toString(16));
					writeChunk(renderState$jscomp$1, clientRenderScript1A);
					errorDigest && (writeChunk(renderState$jscomp$1, clientRenderErrorScriptArgInterstitial), writeChunk(renderState$jscomp$1, escapeJSStringsForInstructionScripts(errorDigest || "")));
					var JSCompiler_inline_result = writeChunkAndReturn(renderState$jscomp$1, clientRenderScriptEnd);
					if (!JSCompiler_inline_result) {
						request.destination = null;
						i++;
						clientRenderedBoundaries.splice(0, i);
						return;
					}
				}
				clientRenderedBoundaries.splice(0, i);
				var completedBoundaries = request.completedBoundaries;
				for (i = 0; i < completedBoundaries.length; i++) if (!flushCompletedBoundary(request, destination, completedBoundaries[i])) {
					request.destination = null;
					i++;
					completedBoundaries.splice(0, i);
					return;
				}
				completedBoundaries.splice(0, i);
				completeWriting(destination);
				currentView = new Uint8Array(2048);
				writtenBytes = 0;
				flushingPartialBoundaries = destinationHasCapacity$1 = !0;
				var partialBoundaries = request.partialBoundaries;
				for (i = 0; i < partialBoundaries.length; i++) {
					var boundary$70 = partialBoundaries[i];
					a: {
						clientRenderedBoundaries = request;
						boundary = destination;
						flushedByteSize = boundary$70.byteSize;
						var completedSegments = boundary$70.completedSegments;
						for (JSCompiler_inline_result = 0; JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++) if (!flushPartiallyCompletedSegment(clientRenderedBoundaries, boundary, boundary$70, completedSegments[JSCompiler_inline_result])) {
							JSCompiler_inline_result++;
							completedSegments.splice(0, JSCompiler_inline_result);
							var JSCompiler_inline_result$jscomp$0 = !1;
							break a;
						}
						completedSegments.splice(0, JSCompiler_inline_result);
						var row = boundary$70.row;
						null !== row && row.together && 1 === boundary$70.pendingTasks && (1 === row.pendingTasks ? unblockSuspenseListRow(clientRenderedBoundaries, row, row.hoistables) : row.pendingTasks--);
						JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(boundary, boundary$70.contentState, clientRenderedBoundaries.renderState);
					}
					if (!JSCompiler_inline_result$jscomp$0) {
						request.destination = null;
						i++;
						partialBoundaries.splice(0, i);
						return;
					}
				}
				partialBoundaries.splice(0, i);
				flushingPartialBoundaries = !1;
				var largeBoundaries = request.completedBoundaries;
				for (i = 0; i < largeBoundaries.length; i++) if (!flushCompletedBoundary(request, destination, largeBoundaries[i])) {
					request.destination = null;
					i++;
					largeBoundaries.splice(0, i);
					return;
				}
				largeBoundaries.splice(0, i);
			}
		} finally {
			flushingPartialBoundaries = !1, 0 === request.allPendingTasks && 0 === request.clientRenderedBoundaries.length && 0 === request.completedBoundaries.length ? (request.flushScheduled = !1, i = request.resumableState, i.hasBody && writeChunk(destination, endChunkForTag("body")), i.hasHtml && writeChunk(destination, endChunkForTag("html")), completeWriting(destination), flushBuffered(destination), request.status = 14, destination.end(), request.destination = null) : (completeWriting(destination), flushBuffered(destination));
		}
	}
	function startWork(request) {
		request.flushScheduled = null !== request.destination;
		scheduleMicrotask(function() {
			return requestStorage.run(request, performWork, request);
		});
		setImmediate(function() {
			10 === request.status && (request.status = 11);
			null === request.trackedPostpones && requestStorage.run(request, enqueueEarlyPreloadsAfterInitialWork, request);
		});
	}
	function enqueueEarlyPreloadsAfterInitialWork(request) {
		safelyEmitEarlyPreloads(request, 0 === request.pendingRootTasks);
	}
	function enqueueFlush(request) {
		!1 === request.flushScheduled && 0 === request.pingedTasks.length && null !== request.destination && (request.flushScheduled = !0, setImmediate(function() {
			var destination = request.destination;
			destination ? flushCompletedQueues(request, destination) : request.flushScheduled = !1;
		}));
	}
	function startFlowing(request, destination) {
		if (13 === request.status) request.status = 14, destination.destroy(request.fatalError);
		else if (14 !== request.status && null === request.destination) {
			request.destination = destination;
			try {
				flushCompletedQueues(request, destination);
			} catch (error) {
				logRecoverableError(request, error, {}), fatalError(request, error);
			}
		}
	}
	function abort(request, reason) {
		if (11 === request.status || 10 === request.status) request.status = 12;
		try {
			var abortableTasks = request.abortableTasks;
			if (0 < abortableTasks.size) {
				var error = void 0 === reason ? Error("The render was aborted by the server without a reason.") : "object" === typeof reason && null !== reason && "function" === typeof reason.then ? Error("The render was aborted by the server with a promise.") : reason;
				request.fatalError = error;
				abortableTasks.forEach(function(task) {
					return abortTask(task, request, error);
				});
				abortableTasks.clear();
			}
			null !== request.destination && flushCompletedQueues(request, request.destination);
		} catch (error$72) {
			logRecoverableError(request, error$72, {}), fatalError(request, error$72);
		}
	}
	function addToReplayParent(node, parentKeyPath, trackedPostpones) {
		if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);
		else {
			var workingMap = trackedPostpones.workingMap, parentNode = workingMap.get(parentKeyPath);
			void 0 === parentNode && (parentNode = [
				parentKeyPath[1],
				parentKeyPath[2],
				[],
				null
			], workingMap.set(parentKeyPath, parentNode), addToReplayParent(parentNode, parentKeyPath[0], trackedPostpones));
			parentNode[2].push(node);
		}
	}
	function getPostponedState(request) {
		var trackedPostpones = request.trackedPostpones;
		if (null === trackedPostpones || 0 === trackedPostpones.rootNodes.length && null === trackedPostpones.rootSlots) return request.trackedPostpones = null;
		if (null === request.completedRootSegment || 5 !== request.completedRootSegment.status && null !== request.completedPreambleSegments) {
			var nextSegmentId = request.nextSegmentId;
			var replaySlots = trackedPostpones.rootSlots;
			var resumableState = request.resumableState;
			resumableState.bootstrapScriptContent = void 0;
			resumableState.bootstrapScripts = void 0;
			resumableState.bootstrapModules = void 0;
		} else {
			nextSegmentId = 0;
			replaySlots = -1;
			resumableState = request.resumableState;
			var renderState = request.renderState;
			resumableState.nextFormID = 0;
			resumableState.hasBody = !1;
			resumableState.hasHtml = !1;
			resumableState.unknownResources = { font: renderState.resets.font };
			resumableState.dnsResources = renderState.resets.dns;
			resumableState.connectResources = renderState.resets.connect;
			resumableState.imageResources = renderState.resets.image;
			resumableState.styleResources = renderState.resets.style;
			resumableState.scriptResources = {};
			resumableState.moduleUnknownResources = {};
			resumableState.moduleScriptResources = {};
			resumableState.instructions = 0;
		}
		return {
			nextSegmentId,
			rootFormatContext: request.rootFormatContext,
			progressiveChunkSize: request.progressiveChunkSize,
			resumableState: request.resumableState,
			replayNodes: trackedPostpones.rootNodes,
			replaySlots
		};
	}
	function ensureCorrectIsomorphicReactVersion() {
		var isomorphicReactPackageVersion = React$1.version;
		if ("19.2.0" !== isomorphicReactPackageVersion) throw Error("Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\n  - react:      " + (isomorphicReactPackageVersion + "\n  - react-dom:  19.2.0\nLearn more: https://react.dev/warnings/version-mismatch"));
	}
	ensureCorrectIsomorphicReactVersion();
	function createDrainHandler(destination, request) {
		return function() {
			return startFlowing(request, destination);
		};
	}
	function createCancelHandler(request, reason) {
		return function() {
			request.destination = null;
			abort(request, Error(reason));
		};
	}
	function createRequestImpl(children, options) {
		var resumableState = createResumableState(options ? options.identifierPrefix : void 0, options ? options.unstable_externalRuntimeSrc : void 0, options ? options.bootstrapScriptContent : void 0, options ? options.bootstrapScripts : void 0, options ? options.bootstrapModules : void 0);
		return createRequest(children, resumableState, createRenderState(resumableState, options ? options.nonce : void 0, options ? options.unstable_externalRuntimeSrc : void 0, options ? options.importMap : void 0, options ? options.onHeaders : void 0, options ? options.maxHeadersLength : void 0), createRootFormatContext(options ? options.namespaceURI : void 0), options ? options.progressiveChunkSize : void 0, options ? options.onError : void 0, options ? options.onAllReady : void 0, options ? options.onShellReady : void 0, options ? options.onShellError : void 0, void 0, options ? options.onPostpone : void 0, options ? options.formState : void 0);
	}
	function createFakeWritableFromReadableStreamController$1(controller) {
		return {
			write: function(chunk) {
				"string" === typeof chunk && (chunk = textEncoder.encode(chunk));
				controller.enqueue(chunk);
				return !0;
			},
			end: function() {
				controller.close();
			},
			destroy: function(error) {
				"function" === typeof controller.error ? controller.error(error) : controller.close();
			}
		};
	}
	function resumeRequestImpl(children, postponedState, options) {
		return resumeRequest(children, postponedState, createRenderState(postponedState.resumableState, options ? options.nonce : void 0, void 0, void 0, void 0, void 0), options ? options.onError : void 0, options ? options.onAllReady : void 0, options ? options.onShellReady : void 0, options ? options.onShellError : void 0, void 0, options ? options.onPostpone : void 0);
	}
	ensureCorrectIsomorphicReactVersion();
	function createFakeWritableFromReadableStreamController(controller) {
		return {
			write: function(chunk) {
				"string" === typeof chunk && (chunk = textEncoder.encode(chunk));
				controller.enqueue(chunk);
				return !0;
			},
			end: function() {
				controller.close();
			},
			destroy: function(error) {
				"function" === typeof controller.error ? controller.error(error) : controller.close();
			}
		};
	}
	function createFakeWritableFromReadable(readable) {
		return {
			write: function(chunk) {
				return readable.push(chunk);
			},
			end: function() {
				readable.push(null);
			},
			destroy: function(error) {
				readable.destroy(error);
			}
		};
	}
	exports.prerender = function(children, options) {
		return new Promise(function(resolve, reject) {
			var onHeaders = options ? options.onHeaders : void 0, onHeadersImpl;
			onHeaders && (onHeadersImpl = function(headersDescriptor) {
				onHeaders(new Headers(headersDescriptor));
			});
			var resources = createResumableState(options ? options.identifierPrefix : void 0, options ? options.unstable_externalRuntimeSrc : void 0, options ? options.bootstrapScriptContent : void 0, options ? options.bootstrapScripts : void 0, options ? options.bootstrapModules : void 0), request = createPrerenderRequest(children, resources, createRenderState(resources, void 0, options ? options.unstable_externalRuntimeSrc : void 0, options ? options.importMap : void 0, onHeadersImpl, options ? options.maxHeadersLength : void 0), createRootFormatContext(options ? options.namespaceURI : void 0), options ? options.progressiveChunkSize : void 0, options ? options.onError : void 0, function() {
				var writable, stream$1 = new ReadableStream({
					type: "bytes",
					start: function(controller) {
						writable = createFakeWritableFromReadableStreamController(controller);
					},
					pull: function() {
						startFlowing(request, writable);
					},
					cancel: function(reason) {
						request.destination = null;
						abort(request, reason);
					}
				}, { highWaterMark: 0 });
				stream$1 = {
					postponed: getPostponedState(request),
					prelude: stream$1
				};
				resolve(stream$1);
			}, void 0, void 0, reject, options ? options.onPostpone : void 0);
			if (options && options.signal) {
				var signal = options.signal;
				if (signal.aborted) abort(request, signal.reason);
				else {
					var listener = function() {
						abort(request, signal.reason);
						signal.removeEventListener("abort", listener);
					};
					signal.addEventListener("abort", listener);
				}
			}
			startWork(request);
		});
	};
	exports.prerenderToNodeStream = function(children, options) {
		return new Promise(function(resolve, reject) {
			var resumableState = createResumableState(options ? options.identifierPrefix : void 0, options ? options.unstable_externalRuntimeSrc : void 0, options ? options.bootstrapScriptContent : void 0, options ? options.bootstrapScripts : void 0, options ? options.bootstrapModules : void 0), request = createPrerenderRequest(children, resumableState, createRenderState(resumableState, void 0, options ? options.unstable_externalRuntimeSrc : void 0, options ? options.importMap : void 0, options ? options.onHeaders : void 0, options ? options.maxHeadersLength : void 0), createRootFormatContext(options ? options.namespaceURI : void 0), options ? options.progressiveChunkSize : void 0, options ? options.onError : void 0, function() {
				var readable = new stream.Readable({ read: function() {
					startFlowing(request, writable);
				} }), writable = createFakeWritableFromReadable(readable);
				readable = {
					postponed: getPostponedState(request),
					prelude: readable
				};
				resolve(readable);
			}, void 0, void 0, reject, options ? options.onPostpone : void 0);
			if (options && options.signal) {
				var signal = options.signal;
				if (signal.aborted) abort(request, signal.reason);
				else {
					var listener = function() {
						abort(request, signal.reason);
						signal.removeEventListener("abort", listener);
					};
					signal.addEventListener("abort", listener);
				}
			}
			startWork(request);
		});
	};
	exports.renderToPipeableStream = function(children, options) {
		var request = createRequestImpl(children, options), hasStartedFlowing = !1;
		startWork(request);
		return {
			pipe: function(destination) {
				if (hasStartedFlowing) throw Error("React currently only supports piping to one writable stream.");
				hasStartedFlowing = !0;
				safelyEmitEarlyPreloads(request, null === request.trackedPostpones ? 0 === request.pendingRootTasks : null === request.completedRootSegment ? 0 === request.pendingRootTasks : 5 !== request.completedRootSegment.status);
				startFlowing(request, destination);
				destination.on("drain", createDrainHandler(destination, request));
				destination.on("error", createCancelHandler(request, "The destination stream errored while writing data."));
				destination.on("close", createCancelHandler(request, "The destination stream closed early."));
				return destination;
			},
			abort: function(reason) {
				abort(request, reason);
			}
		};
	};
	exports.renderToReadableStream = function(children, options) {
		return new Promise(function(resolve, reject) {
			var onFatalError, onAllReady, allReady = new Promise(function(res, rej) {
				onAllReady = res;
				onFatalError = rej;
			}), onHeaders = options ? options.onHeaders : void 0, onHeadersImpl;
			onHeaders && (onHeadersImpl = function(headersDescriptor) {
				onHeaders(new Headers(headersDescriptor));
			});
			var resumableState = createResumableState(options ? options.identifierPrefix : void 0, options ? options.unstable_externalRuntimeSrc : void 0, options ? options.bootstrapScriptContent : void 0, options ? options.bootstrapScripts : void 0, options ? options.bootstrapModules : void 0), request = createRequest(children, resumableState, createRenderState(resumableState, options ? options.nonce : void 0, options ? options.unstable_externalRuntimeSrc : void 0, options ? options.importMap : void 0, onHeadersImpl, options ? options.maxHeadersLength : void 0), createRootFormatContext(options ? options.namespaceURI : void 0), options ? options.progressiveChunkSize : void 0, options ? options.onError : void 0, onAllReady, function() {
				var writable, stream$1 = new ReadableStream({
					type: "bytes",
					start: function(controller) {
						writable = createFakeWritableFromReadableStreamController$1(controller);
					},
					pull: function() {
						startFlowing(request, writable);
					},
					cancel: function(reason) {
						request.destination = null;
						abort(request, reason);
					}
				}, { highWaterMark: 0 });
				stream$1.allReady = allReady;
				resolve(stream$1);
			}, function(error) {
				allReady.catch(function() {});
				reject(error);
			}, onFatalError, options ? options.onPostpone : void 0, options ? options.formState : void 0);
			if (options && options.signal) {
				var signal = options.signal;
				if (signal.aborted) abort(request, signal.reason);
				else {
					var listener = function() {
						abort(request, signal.reason);
						signal.removeEventListener("abort", listener);
					};
					signal.addEventListener("abort", listener);
				}
			}
			startWork(request);
		});
	};
	exports.resume = function(children, postponedState, options) {
		return new Promise(function(resolve, reject) {
			var onFatalError, onAllReady, allReady = new Promise(function(res, rej) {
				onAllReady = res;
				onFatalError = rej;
			}), request = resumeRequest(children, postponedState, createRenderState(postponedState.resumableState, options ? options.nonce : void 0, void 0, void 0, void 0, void 0), options ? options.onError : void 0, onAllReady, function() {
				var writable, stream$1 = new ReadableStream({
					type: "bytes",
					start: function(controller) {
						writable = createFakeWritableFromReadableStreamController$1(controller);
					},
					pull: function() {
						startFlowing(request, writable);
					},
					cancel: function(reason) {
						request.destination = null;
						abort(request, reason);
					}
				}, { highWaterMark: 0 });
				stream$1.allReady = allReady;
				resolve(stream$1);
			}, function(error) {
				allReady.catch(function() {});
				reject(error);
			}, onFatalError, options ? options.onPostpone : void 0);
			if (options && options.signal) {
				var signal = options.signal;
				if (signal.aborted) abort(request, signal.reason);
				else {
					var listener = function() {
						abort(request, signal.reason);
						signal.removeEventListener("abort", listener);
					};
					signal.addEventListener("abort", listener);
				}
			}
			startWork(request);
		});
	};
	exports.resumeAndPrerender = function(children, postponedState, options) {
		return new Promise(function(resolve, reject) {
			var request = resumeAndPrerenderRequest(children, postponedState, createRenderState(postponedState.resumableState, void 0, void 0, void 0, void 0, void 0), options ? options.onError : void 0, function() {
				var writable, stream$1 = new ReadableStream({
					type: "bytes",
					start: function(controller) {
						writable = createFakeWritableFromReadableStreamController(controller);
					},
					pull: function() {
						startFlowing(request, writable);
					},
					cancel: function(reason) {
						request.destination = null;
						abort(request, reason);
					}
				}, { highWaterMark: 0 });
				stream$1 = {
					postponed: getPostponedState(request),
					prelude: stream$1
				};
				resolve(stream$1);
			}, void 0, void 0, reject, options ? options.onPostpone : void 0);
			if (options && options.signal) {
				var signal = options.signal;
				if (signal.aborted) abort(request, signal.reason);
				else {
					var listener = function() {
						abort(request, signal.reason);
						signal.removeEventListener("abort", listener);
					};
					signal.addEventListener("abort", listener);
				}
			}
			startWork(request);
		});
	};
	exports.resumeAndPrerenderToNodeStream = function(children, postponedState, options) {
		return new Promise(function(resolve, reject) {
			var request = resumeAndPrerenderRequest(children, postponedState, createRenderState(postponedState.resumableState, void 0, void 0, void 0, void 0, void 0), options ? options.onError : void 0, function() {
				var readable = new stream.Readable({ read: function() {
					startFlowing(request, writable);
				} }), writable = createFakeWritableFromReadable(readable);
				readable = {
					postponed: getPostponedState(request),
					prelude: readable
				};
				resolve(readable);
			}, void 0, void 0, reject, options ? options.onPostpone : void 0);
			if (options && options.signal) {
				var signal = options.signal;
				if (signal.aborted) abort(request, signal.reason);
				else {
					var listener = function() {
						abort(request, signal.reason);
						signal.removeEventListener("abort", listener);
					};
					signal.addEventListener("abort", listener);
				}
			}
			startWork(request);
		});
	};
	exports.resumeToPipeableStream = function(children, postponedState, options) {
		var request = resumeRequestImpl(children, postponedState, options), hasStartedFlowing = !1;
		startWork(request);
		return {
			pipe: function(destination) {
				if (hasStartedFlowing) throw Error("React currently only supports piping to one writable stream.");
				hasStartedFlowing = !0;
				startFlowing(request, destination);
				destination.on("drain", createDrainHandler(destination, request));
				destination.on("error", createCancelHandler(request, "The destination stream errored while writing data."));
				destination.on("close", createCancelHandler(request, "The destination stream closed early."));
				return destination;
			},
			abort: function(reason) {
				abort(request, reason);
			}
		};
	};
	exports.version = "19.2.0";
}) });

//#endregion
//#region ../../node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js
var require_react_dom_server_legacy_node_development = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js": ((exports) => {
	"production" !== process.env.NODE_ENV && (function() {
		function styleReplacer$2(match, prefix$3, s$1, suffix$3) {
			return "" + prefix$3 + ("s" === s$1 ? "\\73 " : "\\53 ") + suffix$3;
		}
		function scriptReplacer$2(match, prefix$3, s$1, suffix$3) {
			return "" + prefix$3 + ("s" === s$1 ? "\\u0073" : "\\u0053") + suffix$3;
		}
		function getIteratorFn$2(maybeIterable) {
			if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
			maybeIterable = MAYBE_ITERATOR_SYMBOL$2 && maybeIterable[MAYBE_ITERATOR_SYMBOL$2] || maybeIterable["@@iterator"];
			return "function" === typeof maybeIterable ? maybeIterable : null;
		}
		function objectName(object) {
			object = Object.prototype.toString.call(object);
			return object.slice(8, object.length - 1);
		}
		function describeKeyForErrorMessage(key) {
			var encodedKey = JSON.stringify(key);
			return "\"" + key + "\"" === encodedKey ? key : encodedKey;
		}
		function describeValueForErrorMessage(value) {
			switch (typeof value) {
				case "string": return JSON.stringify(10 >= value.length ? value : value.slice(0, 10) + "...");
				case "object":
					if (isArrayImpl$2(value)) return "[...]";
					if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG) return "client";
					value = objectName(value);
					return "Object" === value ? "{...}" : value;
				case "function": return value.$$typeof === CLIENT_REFERENCE_TAG ? "client" : (value = value.displayName || value.name) ? "function " + value : "function";
				default: return String(value);
			}
		}
		function describeElementType(type) {
			if ("string" === typeof type) return type;
			switch (type) {
				case REACT_SUSPENSE_TYPE$2: return "Suspense";
				case REACT_SUSPENSE_LIST_TYPE$2: return "SuspenseList";
			}
			if ("object" === typeof type) switch (type.$$typeof) {
				case REACT_FORWARD_REF_TYPE$2: return describeElementType(type.render);
				case REACT_MEMO_TYPE$2: return describeElementType(type.type);
				case REACT_LAZY_TYPE$2:
					var payload = type._payload;
					type = type._init;
					try {
						return describeElementType(type(payload));
					} catch (x) {}
			}
			return "";
		}
		function describeObjectForErrorMessage(objectOrArray, expandedName) {
			var objKind = objectName(objectOrArray);
			if ("Object" !== objKind && "Array" !== objKind) return objKind;
			var start = -1, length = 0;
			if (isArrayImpl$2(objectOrArray)) if (jsxChildrenParents.has(objectOrArray)) {
				var type = jsxChildrenParents.get(objectOrArray);
				objKind = "<" + describeElementType(type) + ">";
				for (var i = 0; i < objectOrArray.length; i++) {
					var value = objectOrArray[i];
					value = "string" === typeof value ? value : "object" === typeof value && null !== value ? "{" + describeObjectForErrorMessage(value) + "}" : "{" + describeValueForErrorMessage(value) + "}";
					"" + i === expandedName ? (start = objKind.length, length = value.length, objKind += value) : objKind = 15 > value.length && 40 > objKind.length + value.length ? objKind + value : objKind + "{...}";
				}
				objKind += "</" + describeElementType(type) + ">";
			} else {
				objKind = "[";
				for (type = 0; type < objectOrArray.length; type++) 0 < type && (objKind += ", "), i = objectOrArray[type], i = "object" === typeof i && null !== i ? describeObjectForErrorMessage(i) : describeValueForErrorMessage(i), "" + type === expandedName ? (start = objKind.length, length = i.length, objKind += i) : objKind = 10 > i.length && 40 > objKind.length + i.length ? objKind + i : objKind + "...";
				objKind += "]";
			}
			else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE$2) objKind = "<" + describeElementType(objectOrArray.type) + "/>";
			else {
				if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
				if (jsxPropsParents.has(objectOrArray)) {
					objKind = jsxPropsParents.get(objectOrArray);
					objKind = "<" + (describeElementType(objKind) || "...");
					type = Object.keys(objectOrArray);
					for (i = 0; i < type.length; i++) {
						objKind += " ";
						value = type[i];
						objKind += describeKeyForErrorMessage(value) + "=";
						var _value2 = objectOrArray[value];
						var _substr2 = value === expandedName && "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2);
						"string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
						value === expandedName ? (start = objKind.length, length = _substr2.length, objKind += _substr2) : objKind = 10 > _substr2.length && 40 > objKind.length + _substr2.length ? objKind + _substr2 : objKind + "...";
					}
					objKind += ">";
				} else {
					objKind = "{";
					type = Object.keys(objectOrArray);
					for (i = 0; i < type.length; i++) 0 < i && (objKind += ", "), value = type[i], objKind += describeKeyForErrorMessage(value) + ": ", _value2 = objectOrArray[value], _value2 = "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2), value === expandedName ? (start = objKind.length, length = _value2.length, objKind += _value2) : objKind = 10 > _value2.length && 40 > objKind.length + _value2.length ? objKind + _value2 : objKind + "...";
					objKind += "}";
				}
			}
			return void 0 === expandedName ? objKind : -1 < start && 0 < length ? (objectOrArray = " ".repeat(start) + "^".repeat(length), "\n  " + objKind + "\n  " + objectOrArray) : "\n  " + objKind;
		}
		function murmurhash3_32_gc$1(key, seed) {
			var remainder = key.length & 3;
			var bytes = key.length - remainder;
			var h1 = seed;
			for (seed = 0; seed < bytes;) {
				var k1 = key.charCodeAt(seed) & 255 | (key.charCodeAt(++seed) & 255) << 8 | (key.charCodeAt(++seed) & 255) << 16 | (key.charCodeAt(++seed) & 255) << 24;
				++seed;
				k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295;
				k1 = k1 << 15 | k1 >>> 17;
				k1 = 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
				h1 ^= k1;
				h1 = h1 << 13 | h1 >>> 19;
				h1 = 5 * (h1 & 65535) + ((5 * (h1 >>> 16) & 65535) << 16) & 4294967295;
				h1 = (h1 & 65535) + 27492 + (((h1 >>> 16) + 58964 & 65535) << 16);
			}
			k1 = 0;
			switch (remainder) {
				case 3: k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;
				case 2: k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;
				case 1: k1 ^= key.charCodeAt(seed) & 255, k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295, k1 = k1 << 15 | k1 >>> 17, h1 ^= 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
			}
			h1 ^= key.length;
			h1 ^= h1 >>> 16;
			h1 = 2246822507 * (h1 & 65535) + ((2246822507 * (h1 >>> 16) & 65535) << 16) & 4294967295;
			h1 ^= h1 >>> 13;
			h1 = 3266489909 * (h1 & 65535) + ((3266489909 * (h1 >>> 16) & 65535) << 16) & 4294967295;
			return (h1 ^ h1 >>> 16) >>> 0;
		}
		function typeName(value) {
			return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
		}
		function willCoercionThrow(value) {
			try {
				return testStringCoercion(value), !1;
			} catch (e) {
				return !0;
			}
		}
		function testStringCoercion(value) {
			return "" + value;
		}
		function checkAttributeStringCoercion(value, attributeName) {
			if (willCoercionThrow(value)) return console.error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.", attributeName, typeName(value)), testStringCoercion(value);
		}
		function checkCSSPropertyStringCoercion(value, propName) {
			if (willCoercionThrow(value)) return console.error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.", propName, typeName(value)), testStringCoercion(value);
		}
		function checkHtmlStringCoercion(value) {
			if (willCoercionThrow(value)) return console.error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.", typeName(value)), testStringCoercion(value);
		}
		function isAttributeNameSafe$2(attributeName) {
			if (hasOwnProperty$2.call(validatedAttributeNameCache$2, attributeName)) return !0;
			if (hasOwnProperty$2.call(illegalAttributeNameCache$2, attributeName)) return !1;
			if (VALID_ATTRIBUTE_NAME_REGEX$2.test(attributeName)) return validatedAttributeNameCache$2[attributeName] = !0;
			illegalAttributeNameCache$2[attributeName] = !0;
			console.error("Invalid attribute name: `%s`", attributeName);
			return !1;
		}
		function checkControlledValueProps(tagName, props) {
			hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.") : console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."));
			props.onChange || props.readOnly || props.disabled || null == props.checked || console.error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
		}
		function validateProperty$1(tagName, name) {
			if (hasOwnProperty$2.call(warnedProperties$1, name) && warnedProperties$1[name]) return !0;
			if (rARIACamel$1.test(name)) {
				tagName = "aria-" + name.slice(4).toLowerCase();
				tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
				if (null == tagName) return console.error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name), warnedProperties$1[name] = !0;
				if (name !== tagName) return console.error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, tagName), warnedProperties$1[name] = !0;
			}
			if (rARIA$1.test(name)) {
				tagName = name.toLowerCase();
				tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
				if (null == tagName) return warnedProperties$1[name] = !0, !1;
				name !== tagName && (console.error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, tagName), warnedProperties$1[name] = !0);
			}
			return !0;
		}
		function validateProperties$2(type, props) {
			var invalidProps = [], key;
			for (key in props) validateProperty$1(type, key) || invalidProps.push(key);
			props = invalidProps.map(function(prop) {
				return "`" + prop + "`";
			}).join(", ");
			1 === invalidProps.length ? console.error("Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type) : 1 < invalidProps.length && console.error("Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type);
		}
		function validateProperty(tagName, name, value, eventRegistry) {
			if (hasOwnProperty$2.call(warnedProperties, name) && warnedProperties[name]) return !0;
			var lowerCasedName = name.toLowerCase();
			if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName) return console.error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), warnedProperties[name] = !0;
			if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name)) return !0;
			if (null != eventRegistry) {
				tagName = eventRegistry.possibleRegistrationNames;
				if (eventRegistry.registrationNameDependencies.hasOwnProperty(name)) return !0;
				eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
				if (null != eventRegistry) return console.error("Invalid event handler property `%s`. Did you mean `%s`?", name, eventRegistry), warnedProperties[name] = !0;
				if (EVENT_NAME_REGEX.test(name)) return console.error("Unknown event handler property `%s`. It will be ignored.", name), warnedProperties[name] = !0;
			} else if (EVENT_NAME_REGEX.test(name)) return INVALID_EVENT_NAME_REGEX.test(name) && console.error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name), warnedProperties[name] = !0;
			if (rARIA.test(name) || rARIACamel.test(name)) return !0;
			if ("innerhtml" === lowerCasedName) return console.error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), warnedProperties[name] = !0;
			if ("aria" === lowerCasedName) return console.error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), warnedProperties[name] = !0;
			if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value) return console.error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value), warnedProperties[name] = !0;
			if ("number" === typeof value && isNaN(value)) return console.error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name), warnedProperties[name] = !0;
			if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
				if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name) return console.error("Invalid DOM property `%s`. Did you mean `%s`?", name, lowerCasedName), warnedProperties[name] = !0;
			} else if (name !== lowerCasedName) return console.error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName), warnedProperties[name] = !0;
			switch (name) {
				case "dangerouslySetInnerHTML":
				case "children":
				case "style":
				case "suppressContentEditableWarning":
				case "suppressHydrationWarning":
				case "defaultValue":
				case "defaultChecked":
				case "innerHTML":
				case "ref": return !0;
				case "innerText":
				case "textContent": return !0;
			}
			switch (typeof value) {
				case "boolean": switch (name) {
					case "autoFocus":
					case "checked":
					case "multiple":
					case "muted":
					case "selected":
					case "contentEditable":
					case "spellCheck":
					case "draggable":
					case "value":
					case "autoReverse":
					case "externalResourcesRequired":
					case "focusable":
					case "preserveAlpha":
					case "allowFullScreen":
					case "async":
					case "autoPlay":
					case "controls":
					case "default":
					case "defer":
					case "disabled":
					case "disablePictureInPicture":
					case "disableRemotePlayback":
					case "formNoValidate":
					case "hidden":
					case "loop":
					case "noModule":
					case "noValidate":
					case "open":
					case "playsInline":
					case "readOnly":
					case "required":
					case "reversed":
					case "scoped":
					case "seamless":
					case "itemScope":
					case "capture":
					case "download":
					case "inert": return !0;
					default:
						lowerCasedName = name.toLowerCase().slice(0, 5);
						if ("data-" === lowerCasedName || "aria-" === lowerCasedName) return !0;
						value ? console.error("Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.", value, name, name, value, name) : console.error("Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", value, name, name, value, name, name, name);
						return warnedProperties[name] = !0;
				}
				case "function":
				case "symbol": return warnedProperties[name] = !0, !1;
				case "string": if ("false" === value || "true" === value) {
					switch (name) {
						case "checked":
						case "selected":
						case "multiple":
						case "muted":
						case "allowFullScreen":
						case "async":
						case "autoPlay":
						case "controls":
						case "default":
						case "defer":
						case "disabled":
						case "disablePictureInPicture":
						case "disableRemotePlayback":
						case "formNoValidate":
						case "hidden":
						case "loop":
						case "noModule":
						case "noValidate":
						case "open":
						case "playsInline":
						case "readOnly":
						case "required":
						case "reversed":
						case "scoped":
						case "seamless":
						case "itemScope":
						case "inert": break;
						default: return !0;
					}
					console.error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, "false" === value ? "The browser will interpret it as a truthy value." : "Although this works, it will not work as expected if you pass the string \"false\".", name, value);
					warnedProperties[name] = !0;
				}
			}
			return !0;
		}
		function warnUnknownProperties(type, props, eventRegistry) {
			var unknownProps = [], key;
			for (key in props) validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
			props = unknownProps.map(function(prop) {
				return "`" + prop + "`";
			}).join(", ");
			1 === unknownProps.length ? console.error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type) : 1 < unknownProps.length && console.error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type);
		}
		function camelize(string) {
			return string.replace(hyphenPattern, function(_, character) {
				return character.toUpperCase();
			});
		}
		function escapeTextForBrowser$2(text) {
			if ("boolean" === typeof text || "number" === typeof text || "bigint" === typeof text) return "" + text;
			checkHtmlStringCoercion(text);
			text = "" + text;
			var match = matchHtmlRegExp$2.exec(text);
			if (match) {
				var html = "", index, lastIndex = 0;
				for (index = match.index; index < text.length; index++) {
					switch (text.charCodeAt(index)) {
						case 34:
							match = "&quot;";
							break;
						case 38:
							match = "&amp;";
							break;
						case 39:
							match = "&#x27;";
							break;
						case 60:
							match = "&lt;";
							break;
						case 62:
							match = "&gt;";
							break;
						default: continue;
					}
					lastIndex !== index && (html += text.slice(lastIndex, index));
					lastIndex = index + 1;
					html += match;
				}
				text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;
			}
			return text;
		}
		function sanitizeURL$2(url) {
			return isJavaScriptProtocol$2.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
		}
		function escapeEntireInlineScriptContent(scriptText) {
			checkHtmlStringCoercion(scriptText);
			return ("" + scriptText).replace(scriptRegex$2, scriptReplacer$2);
		}
		function createResumableState$2(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
			return {
				idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
				nextFormID: 0,
				streamingFormat: 0,
				bootstrapScriptContent,
				bootstrapScripts,
				bootstrapModules,
				instructions: NothingSent,
				hasBody: !1,
				hasHtml: !1,
				unknownResources: {},
				dnsResources: {},
				connectResources: {
					default: {},
					anonymous: {},
					credentials: {}
				},
				imageResources: {},
				styleResources: {},
				scriptResources: {},
				moduleUnknownResources: {},
				moduleScriptResources: {}
			};
		}
		function createFormatContext$2(insertionMode, selectedValue, tagScope, viewTransition) {
			return {
				insertionMode,
				selectedValue,
				tagScope,
				viewTransition
			};
		}
		function getChildFormatContext$2(parentContext, type, props) {
			var subtreeScope = parentContext.tagScope & -25;
			switch (type) {
				case "noscript": return createFormatContext$2(HTML_MODE, null, subtreeScope | 1, null);
				case "select": return createFormatContext$2(HTML_MODE, null != props.value ? props.value : props.defaultValue, subtreeScope, null);
				case "svg": return createFormatContext$2(SVG_MODE, null, subtreeScope, null);
				case "picture": return createFormatContext$2(HTML_MODE, null, subtreeScope | 2, null);
				case "math": return createFormatContext$2(MATHML_MODE, null, subtreeScope, null);
				case "foreignObject": return createFormatContext$2(HTML_MODE, null, subtreeScope, null);
				case "table": return createFormatContext$2(HTML_TABLE_MODE, null, subtreeScope, null);
				case "thead":
				case "tbody":
				case "tfoot": return createFormatContext$2(HTML_TABLE_BODY_MODE, null, subtreeScope, null);
				case "colgroup": return createFormatContext$2(HTML_COLGROUP_MODE, null, subtreeScope, null);
				case "tr": return createFormatContext$2(HTML_TABLE_ROW_MODE, null, subtreeScope, null);
				case "head":
					if (parentContext.insertionMode < HTML_MODE) return createFormatContext$2(HTML_HEAD_MODE, null, subtreeScope, null);
					break;
				case "html": if (parentContext.insertionMode === ROOT_HTML_MODE) return createFormatContext$2(HTML_HTML_MODE, null, subtreeScope, null);
			}
			return parentContext.insertionMode >= HTML_TABLE_MODE || parentContext.insertionMode < HTML_MODE ? createFormatContext$2(HTML_MODE, null, subtreeScope, null) : parentContext.tagScope !== subtreeScope ? createFormatContext$2(parentContext.insertionMode, parentContext.selectedValue, subtreeScope, null) : parentContext;
		}
		function getSuspenseViewTransition$2(parentViewTransition) {
			return null === parentViewTransition ? null : {
				update: parentViewTransition.update,
				enter: "none",
				exit: "none",
				share: parentViewTransition.update,
				name: parentViewTransition.autoName,
				autoName: parentViewTransition.autoName,
				nameIdx: 0
			};
		}
		function getSuspenseFallbackFormatContext$2(resumableState, parentContext) {
			parentContext.tagScope & 32 && (resumableState.instructions |= 128);
			return createFormatContext$2(parentContext.insertionMode, parentContext.selectedValue, parentContext.tagScope | 12, getSuspenseViewTransition$2(parentContext.viewTransition));
		}
		function getSuspenseContentFormatContext$2(resumableState, parentContext) {
			resumableState = getSuspenseViewTransition$2(parentContext.viewTransition);
			var subtreeScope = parentContext.tagScope | 16;
			null !== resumableState && "none" !== resumableState.share && (subtreeScope |= 64);
			return createFormatContext$2(parentContext.insertionMode, parentContext.selectedValue, subtreeScope, resumableState);
		}
		function pushStyleAttribute$2(target, style) {
			if ("object" !== typeof style) throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
			var isFirst = !0, styleName;
			for (styleName in style) if (hasOwnProperty$2.call(style, styleName)) {
				var styleValue = style[styleName];
				if (null != styleValue && "boolean" !== typeof styleValue && "" !== styleValue) {
					if (0 === styleName.indexOf("--")) {
						var nameChunk = escapeTextForBrowser$2(styleName);
						checkCSSPropertyStringCoercion(styleValue, styleName);
						styleValue = escapeTextForBrowser$2(("" + styleValue).trim());
					} else {
						nameChunk = styleName;
						var value = styleValue;
						if (-1 < nameChunk.indexOf("-")) {
							var name = nameChunk;
							warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = !0, console.error("Unsupported style property %s. Did you mean %s?", name, camelize(name.replace(msPattern$1$1, "ms-"))));
						} else if (badVendoredStyleNamePattern.test(nameChunk)) name = nameChunk, warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = !0, console.error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1)));
						else if (badStyleValueWithSemicolonPattern.test(value)) {
							name = nameChunk;
							var value$jscomp$0 = value;
							warnedStyleValues.hasOwnProperty(value$jscomp$0) && warnedStyleValues[value$jscomp$0] || (warnedStyleValues[value$jscomp$0] = !0, console.error("Style property values shouldn't contain a semicolon. Try \"%s: %s\" instead.", name, value$jscomp$0.replace(badStyleValueWithSemicolonPattern, "")));
						}
						"number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = !0, console.error("`NaN` is an invalid value for the `%s` css style property.", nameChunk)) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = !0, console.error("`Infinity` is an invalid value for the `%s` css style property.", nameChunk)));
						nameChunk = styleName;
						value = styleNameCache$2.get(nameChunk);
						void 0 !== value ? nameChunk = value : (value = escapeTextForBrowser$2(nameChunk.replace(uppercasePattern$2, "-$1").toLowerCase().replace(msPattern$2, "-ms-")), styleNameCache$2.set(nameChunk, value), nameChunk = value);
						"number" === typeof styleValue ? styleValue = 0 === styleValue || unitlessNumbers$2.has(styleName) ? "" + styleValue : styleValue + "px" : (checkCSSPropertyStringCoercion(styleValue, styleName), styleValue = escapeTextForBrowser$2(("" + styleValue).trim()));
					}
					isFirst ? (isFirst = !1, target.push(styleAttributeStart$1, nameChunk, styleAssign$1, styleValue)) : target.push(styleSeparator$1, nameChunk, styleAssign$1, styleValue);
				}
			}
			isFirst || target.push(attributeEnd$1);
		}
		function pushBooleanAttribute$2(target, name, value) {
			value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator$1, name, attributeEmptyString$1);
		}
		function pushStringAttribute$2(target, name, value) {
			"function" !== typeof value && "symbol" !== typeof value && "boolean" !== typeof value && target.push(attributeSeparator$1, name, attributeAssign$1, escapeTextForBrowser$2(value), attributeEnd$1);
		}
		function pushAdditionalFormField$2(value, key) {
			this.push("<input type=\"hidden\"");
			validateAdditionalFormField$2(value);
			pushStringAttribute$2(this, "name", key);
			pushStringAttribute$2(this, "value", value);
			this.push(endOfStartTagSelfClosing$1);
		}
		function validateAdditionalFormField$2(value) {
			if ("string" !== typeof value) throw Error("File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration.");
		}
		function getCustomFormFields$2(resumableState, formAction) {
			if ("function" === typeof formAction.$$FORM_ACTION) {
				var id = resumableState.nextFormID++;
				resumableState = resumableState.idPrefix + id;
				try {
					var customFields = formAction.$$FORM_ACTION(resumableState);
					if (customFields) customFields.data?.forEach(validateAdditionalFormField$2);
					return customFields;
				} catch (x) {
					if ("object" === typeof x && null !== x && "function" === typeof x.then) throw x;
					console.error("Failed to serialize an action for progressive enhancement:\n%s", x);
				}
			}
			return null;
		}
		function pushFormActionAttribute$2(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name) {
			var formData = null;
			if ("function" === typeof formAction) {
				null === name || didWarnFormActionName || (didWarnFormActionName = !0, console.error("Cannot specify a \"name\" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden."));
				null === formEncType && null === formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = !0, console.error("Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."));
				null === formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = !0, console.error("Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."));
				var customFields = getCustomFormFields$2(resumableState, formAction);
				null !== customFields ? (name = customFields.name, formAction = customFields.action || "", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(attributeSeparator$1, "formAction", attributeAssign$1, actionJavaScriptURL$2, attributeEnd$1), formTarget = formMethod = formEncType = formAction = name = null, injectFormReplayingRuntime$2(resumableState, renderState));
			}
			null != name && pushAttribute$2(target, "name", name);
			null != formAction && pushAttribute$2(target, "formAction", formAction);
			null != formEncType && pushAttribute$2(target, "formEncType", formEncType);
			null != formMethod && pushAttribute$2(target, "formMethod", formMethod);
			null != formTarget && pushAttribute$2(target, "formTarget", formTarget);
			return formData;
		}
		function pushAttribute$2(target, name, value) {
			switch (name) {
				case "className":
					pushStringAttribute$2(target, "class", value);
					break;
				case "tabIndex":
					pushStringAttribute$2(target, "tabindex", value);
					break;
				case "dir":
				case "role":
				case "viewBox":
				case "width":
				case "height":
					pushStringAttribute$2(target, name, value);
					break;
				case "style":
					pushStyleAttribute$2(target, value);
					break;
				case "src":
				case "href": if ("" === value) {
					"src" === name ? console.error("An empty string (\"\") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.", name, name) : console.error("An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.", name, name);
					break;
				}
				case "action":
				case "formAction":
					if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) break;
					checkAttributeStringCoercion(value, name);
					value = sanitizeURL$2("" + value);
					target.push(attributeSeparator$1, name, attributeAssign$1, escapeTextForBrowser$2(value), attributeEnd$1);
					break;
				case "defaultValue":
				case "defaultChecked":
				case "innerHTML":
				case "suppressContentEditableWarning":
				case "suppressHydrationWarning":
				case "ref": break;
				case "autoFocus":
				case "multiple":
				case "muted":
					pushBooleanAttribute$2(target, name.toLowerCase(), value);
					break;
				case "xlinkHref":
					if ("function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) break;
					checkAttributeStringCoercion(value, name);
					value = sanitizeURL$2("" + value);
					target.push(attributeSeparator$1, "xlink:href", attributeAssign$1, escapeTextForBrowser$2(value), attributeEnd$1);
					break;
				case "contentEditable":
				case "spellCheck":
				case "draggable":
				case "value":
				case "autoReverse":
				case "externalResourcesRequired":
				case "focusable":
				case "preserveAlpha":
					"function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator$1, name, attributeAssign$1, escapeTextForBrowser$2(value), attributeEnd$1);
					break;
				case "inert": "" !== value || didWarnForNewBooleanPropsWithEmptyValue[name] || (didWarnForNewBooleanPropsWithEmptyValue[name] = !0, console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.", name));
				case "allowFullScreen":
				case "async":
				case "autoPlay":
				case "controls":
				case "default":
				case "defer":
				case "disabled":
				case "disablePictureInPicture":
				case "disableRemotePlayback":
				case "formNoValidate":
				case "hidden":
				case "loop":
				case "noModule":
				case "noValidate":
				case "open":
				case "playsInline":
				case "readOnly":
				case "required":
				case "reversed":
				case "scoped":
				case "seamless":
				case "itemScope":
					value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator$1, name, attributeEmptyString$1);
					break;
				case "capture":
				case "download":
					!0 === value ? target.push(attributeSeparator$1, name, attributeEmptyString$1) : !1 !== value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator$1, name, attributeAssign$1, escapeTextForBrowser$2(value), attributeEnd$1);
					break;
				case "cols":
				case "rows":
				case "size":
				case "span":
					"function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value && target.push(attributeSeparator$1, name, attributeAssign$1, escapeTextForBrowser$2(value), attributeEnd$1);
					break;
				case "rowSpan":
				case "start":
					"function" === typeof value || "symbol" === typeof value || isNaN(value) || target.push(attributeSeparator$1, name, attributeAssign$1, escapeTextForBrowser$2(value), attributeEnd$1);
					break;
				case "xlinkActuate":
					pushStringAttribute$2(target, "xlink:actuate", value);
					break;
				case "xlinkArcrole":
					pushStringAttribute$2(target, "xlink:arcrole", value);
					break;
				case "xlinkRole":
					pushStringAttribute$2(target, "xlink:role", value);
					break;
				case "xlinkShow":
					pushStringAttribute$2(target, "xlink:show", value);
					break;
				case "xlinkTitle":
					pushStringAttribute$2(target, "xlink:title", value);
					break;
				case "xlinkType":
					pushStringAttribute$2(target, "xlink:type", value);
					break;
				case "xmlBase":
					pushStringAttribute$2(target, "xml:base", value);
					break;
				case "xmlLang":
					pushStringAttribute$2(target, "xml:lang", value);
					break;
				case "xmlSpace":
					pushStringAttribute$2(target, "xml:space", value);
					break;
				default: if (!(2 < name.length) || "o" !== name[0] && "O" !== name[0] || "n" !== name[1] && "N" !== name[1]) {
					if (name = aliases$2.get(name) || name, isAttributeNameSafe$2(name)) {
						switch (typeof value) {
							case "function":
							case "symbol": return;
							case "boolean":
								var prefix$3 = name.toLowerCase().slice(0, 5);
								if ("data-" !== prefix$3 && "aria-" !== prefix$3) return;
						}
						target.push(attributeSeparator$1, name, attributeAssign$1, escapeTextForBrowser$2(value), attributeEnd$1);
					}
				}
			}
		}
		function pushInnerHTML$2(target, innerHTML, children) {
			if (null != innerHTML) {
				if (null != children) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
				if ("object" !== typeof innerHTML || !("__html" in innerHTML)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
				innerHTML = innerHTML.__html;
				null !== innerHTML && void 0 !== innerHTML && (checkHtmlStringCoercion(innerHTML), target.push("" + innerHTML));
			}
		}
		function checkSelectProp(props, propName) {
			var value = props[propName];
			null != value && (value = isArrayImpl$2(value), props.multiple && !value ? console.error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName) : !props.multiple && value && console.error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName));
		}
		function flattenOptionChildren$2(children) {
			var content = "";
			React$3.Children.forEach(children, function(child) {
				null != child && (content += child, didWarnInvalidOptionChildren || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || (didWarnInvalidOptionChildren = !0, console.error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
			});
			return content;
		}
		function injectFormReplayingRuntime$2(resumableState, renderState) {
			if ((resumableState.instructions & 16) === NothingSent) {
				resumableState.instructions |= 16;
				var preamble = renderState.preamble, bootstrapChunks = renderState.bootstrapChunks;
				(preamble.htmlChunks || preamble.headChunks) && 0 === bootstrapChunks.length ? (bootstrapChunks.push(renderState.startInlineScript), pushCompletedShellIdAttribute$2(bootstrapChunks, resumableState), bootstrapChunks.push(endOfStartTag$1, formReplayingRuntimeScript$1, endInlineScript$1)) : bootstrapChunks.unshift(renderState.startInlineScript, endOfStartTag$1, formReplayingRuntimeScript$1, endInlineScript$1);
			}
		}
		function pushLinkImpl$2(target, props) {
			target.push(startChunkForTag$2("link"));
			for (var propKey in props) if (hasOwnProperty$2.call(props, propKey)) {
				var propValue = props[propKey];
				if (null != propValue) switch (propKey) {
					case "children":
					case "dangerouslySetInnerHTML": throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
					default: pushAttribute$2(target, propKey, propValue);
				}
			}
			target.push(endOfStartTagSelfClosing$1);
			return null;
		}
		function escapeStyleTextContent(styleText) {
			checkHtmlStringCoercion(styleText);
			return ("" + styleText).replace(styleRegex$2, styleReplacer$2);
		}
		function pushSelfClosing$2(target, props, tag) {
			target.push(startChunkForTag$2(tag));
			for (var propKey in props) if (hasOwnProperty$2.call(props, propKey)) {
				var propValue = props[propKey];
				if (null != propValue) switch (propKey) {
					case "children":
					case "dangerouslySetInnerHTML": throw Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
					default: pushAttribute$2(target, propKey, propValue);
				}
			}
			target.push(endOfStartTagSelfClosing$1);
			return null;
		}
		function pushTitleImpl$2(target, props) {
			target.push(startChunkForTag$2("title"));
			var children = null, innerHTML = null, propKey;
			for (propKey in props) if (hasOwnProperty$2.call(props, propKey)) {
				var propValue = props[propKey];
				if (null != propValue) switch (propKey) {
					case "children":
						children = propValue;
						break;
					case "dangerouslySetInnerHTML":
						innerHTML = propValue;
						break;
					default: pushAttribute$2(target, propKey, propValue);
				}
			}
			target.push(endOfStartTag$1);
			props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;
			"function" !== typeof props && "symbol" !== typeof props && null !== props && void 0 !== props && target.push(escapeTextForBrowser$2("" + props));
			pushInnerHTML$2(target, innerHTML, children);
			target.push(endChunkForTag$2("title"));
			return null;
		}
		function pushScriptImpl$2(target, props) {
			target.push(startChunkForTag$2("script"));
			var children = null, innerHTML = null, propKey;
			for (propKey in props) if (hasOwnProperty$2.call(props, propKey)) {
				var propValue = props[propKey];
				if (null != propValue) switch (propKey) {
					case "children":
						children = propValue;
						break;
					case "dangerouslySetInnerHTML":
						innerHTML = propValue;
						break;
					default: pushAttribute$2(target, propKey, propValue);
				}
			}
			target.push(endOfStartTag$1);
			null != children && "string" !== typeof children && (props = "number" === typeof children ? "a number for children" : Array.isArray(children) ? "an array for children" : "something unexpected for children", console.error("A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.", props));
			pushInnerHTML$2(target, innerHTML, children);
			"string" === typeof children && target.push(escapeEntireInlineScriptContent(children));
			target.push(endChunkForTag$2("script"));
			return null;
		}
		function pushStartSingletonElement$2(target, props, tag) {
			target.push(startChunkForTag$2(tag));
			var innerHTML = tag = null, propKey;
			for (propKey in props) if (hasOwnProperty$2.call(props, propKey)) {
				var propValue = props[propKey];
				if (null != propValue) switch (propKey) {
					case "children":
						tag = propValue;
						break;
					case "dangerouslySetInnerHTML":
						innerHTML = propValue;
						break;
					default: pushAttribute$2(target, propKey, propValue);
				}
			}
			target.push(endOfStartTag$1);
			pushInnerHTML$2(target, innerHTML, tag);
			return tag;
		}
		function pushStartGenericElement$2(target, props, tag) {
			target.push(startChunkForTag$2(tag));
			var innerHTML = tag = null, propKey;
			for (propKey in props) if (hasOwnProperty$2.call(props, propKey)) {
				var propValue = props[propKey];
				if (null != propValue) switch (propKey) {
					case "children":
						tag = propValue;
						break;
					case "dangerouslySetInnerHTML":
						innerHTML = propValue;
						break;
					default: pushAttribute$2(target, propKey, propValue);
				}
			}
			target.push(endOfStartTag$1);
			pushInnerHTML$2(target, innerHTML, tag);
			return "string" === typeof tag ? (target.push(escapeTextForBrowser$2(tag)), null) : tag;
		}
		function startChunkForTag$2(tag) {
			var tagStartChunk = validatedTagCache$2.get(tag);
			if (void 0 === tagStartChunk) {
				if (!VALID_TAG_REGEX$2.test(tag)) throw Error("Invalid tag: " + tag);
				tagStartChunk = "<" + tag;
				validatedTagCache$2.set(tag, tagStartChunk);
			}
			return tagStartChunk;
		}
		function pushStartInstance$2(target$jscomp$0, type, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded) {
			validateProperties$2(type, props);
			"input" !== type && "textarea" !== type && "select" !== type || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = !0, "select" === type && props.multiple ? console.error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type) : console.error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type));
			b: if (-1 === type.indexOf("-")) var JSCompiler_inline_result = !1;
			else switch (type) {
				case "annotation-xml":
				case "color-profile":
				case "font-face":
				case "font-face-src":
				case "font-face-uri":
				case "font-face-format":
				case "font-face-name":
				case "missing-glyph":
					JSCompiler_inline_result = !1;
					break b;
				default: JSCompiler_inline_result = !0;
			}
			JSCompiler_inline_result || "string" === typeof props.is || warnUnknownProperties(type, props, null);
			!props.suppressContentEditableWarning && props.contentEditable && null != props.children && console.error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
			formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE && -1 === type.indexOf("-") && type.toLowerCase() !== type && console.error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
			switch (type) {
				case "div":
				case "span":
				case "svg":
				case "path": break;
				case "a":
					target$jscomp$0.push(startChunkForTag$2("a"));
					var children = null, innerHTML = null, propKey;
					for (propKey in props) if (hasOwnProperty$2.call(props, propKey)) {
						var propValue = props[propKey];
						if (null != propValue) switch (propKey) {
							case "children":
								children = propValue;
								break;
							case "dangerouslySetInnerHTML":
								innerHTML = propValue;
								break;
							case "href":
								"" === propValue ? pushStringAttribute$2(target$jscomp$0, "href", "") : pushAttribute$2(target$jscomp$0, propKey, propValue);
								break;
							default: pushAttribute$2(target$jscomp$0, propKey, propValue);
						}
					}
					target$jscomp$0.push(endOfStartTag$1);
					pushInnerHTML$2(target$jscomp$0, innerHTML, children);
					if ("string" === typeof children) {
						target$jscomp$0.push(escapeTextForBrowser$2(children));
						var JSCompiler_inline_result$jscomp$0 = null;
					} else JSCompiler_inline_result$jscomp$0 = children;
					return JSCompiler_inline_result$jscomp$0;
				case "g":
				case "p":
				case "li": break;
				case "select":
					checkControlledValueProps("select", props);
					checkSelectProp(props, "value");
					checkSelectProp(props, "defaultValue");
					void 0 === props.value || void 0 === props.defaultValue || didWarnDefaultSelectValue || (console.error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"), didWarnDefaultSelectValue = !0);
					target$jscomp$0.push(startChunkForTag$2("select"));
					var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;
					for (propKey$jscomp$0 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$0)) {
						var propValue$jscomp$0 = props[propKey$jscomp$0];
						if (null != propValue$jscomp$0) switch (propKey$jscomp$0) {
							case "children":
								children$jscomp$0 = propValue$jscomp$0;
								break;
							case "dangerouslySetInnerHTML":
								innerHTML$jscomp$0 = propValue$jscomp$0;
								break;
							case "defaultValue":
							case "value": break;
							default: pushAttribute$2(target$jscomp$0, propKey$jscomp$0, propValue$jscomp$0);
						}
					}
					target$jscomp$0.push(endOfStartTag$1);
					pushInnerHTML$2(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);
					return children$jscomp$0;
				case "option":
					var selectedValue = formatContext.selectedValue;
					target$jscomp$0.push(startChunkForTag$2("option"));
					var children$jscomp$1 = null, value = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;
					for (propKey$jscomp$1 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$1)) {
						var propValue$jscomp$1 = props[propKey$jscomp$1];
						if (null != propValue$jscomp$1) switch (propKey$jscomp$1) {
							case "children":
								children$jscomp$1 = propValue$jscomp$1;
								break;
							case "selected":
								selected = propValue$jscomp$1;
								didWarnSelectedSetOnOption || (console.error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), didWarnSelectedSetOnOption = !0);
								break;
							case "dangerouslySetInnerHTML":
								innerHTML$jscomp$1 = propValue$jscomp$1;
								break;
							case "value": value = propValue$jscomp$1;
							default: pushAttribute$2(target$jscomp$0, propKey$jscomp$1, propValue$jscomp$1);
						}
					}
					if (null != selectedValue) {
						if (null !== value) {
							checkAttributeStringCoercion(value, "value");
							var stringValue = "" + value;
						} else null === innerHTML$jscomp$1 || didWarnInvalidOptionInnerHTML || (didWarnInvalidOptionInnerHTML = !0, console.error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")), stringValue = flattenOptionChildren$2(children$jscomp$1);
						if (isArrayImpl$2(selectedValue)) {
							for (var i = 0; i < selectedValue.length; i++) if (checkAttributeStringCoercion(selectedValue[i], "value"), "" + selectedValue[i] === stringValue) {
								target$jscomp$0.push(" selected=\"\"");
								break;
							}
						} else checkAttributeStringCoercion(selectedValue, "select.value"), "" + selectedValue === stringValue && target$jscomp$0.push(" selected=\"\"");
					} else selected && target$jscomp$0.push(" selected=\"\"");
					target$jscomp$0.push(endOfStartTag$1);
					pushInnerHTML$2(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);
					return children$jscomp$1;
				case "textarea":
					checkControlledValueProps("textarea", props);
					void 0 === props.value || void 0 === props.defaultValue || didWarnDefaultTextareaValue || (console.error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components"), didWarnDefaultTextareaValue = !0);
					target$jscomp$0.push(startChunkForTag$2("textarea"));
					var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;
					for (propKey$jscomp$2 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$2)) {
						var propValue$jscomp$2 = props[propKey$jscomp$2];
						if (null != propValue$jscomp$2) switch (propKey$jscomp$2) {
							case "children":
								children$jscomp$2 = propValue$jscomp$2;
								break;
							case "value":
								value$jscomp$0 = propValue$jscomp$2;
								break;
							case "defaultValue":
								defaultValue = propValue$jscomp$2;
								break;
							case "dangerouslySetInnerHTML": throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
							default: pushAttribute$2(target$jscomp$0, propKey$jscomp$2, propValue$jscomp$2);
						}
					}
					null === value$jscomp$0 && null !== defaultValue && (value$jscomp$0 = defaultValue);
					target$jscomp$0.push(endOfStartTag$1);
					if (null != children$jscomp$2) {
						console.error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
						if (null != value$jscomp$0) throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
						if (isArrayImpl$2(children$jscomp$2)) {
							if (1 < children$jscomp$2.length) throw Error("<textarea> can only have at most one child.");
							checkHtmlStringCoercion(children$jscomp$2[0]);
							value$jscomp$0 = "" + children$jscomp$2[0];
						}
						checkHtmlStringCoercion(children$jscomp$2);
						value$jscomp$0 = "" + children$jscomp$2;
					}
					"string" === typeof value$jscomp$0 && "\n" === value$jscomp$0[0] && target$jscomp$0.push(leadingNewline$1);
					null !== value$jscomp$0 && (checkAttributeStringCoercion(value$jscomp$0, "value"), target$jscomp$0.push(escapeTextForBrowser$2("" + value$jscomp$0)));
					return null;
				case "input":
					checkControlledValueProps("input", props);
					target$jscomp$0.push(startChunkForTag$2("input"));
					var name = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;
					for (propKey$jscomp$3 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$3)) {
						var propValue$jscomp$3 = props[propKey$jscomp$3];
						if (null != propValue$jscomp$3) switch (propKey$jscomp$3) {
							case "children":
							case "dangerouslySetInnerHTML": throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
							case "name":
								name = propValue$jscomp$3;
								break;
							case "formAction":
								formAction = propValue$jscomp$3;
								break;
							case "formEncType":
								formEncType = propValue$jscomp$3;
								break;
							case "formMethod":
								formMethod = propValue$jscomp$3;
								break;
							case "formTarget":
								formTarget = propValue$jscomp$3;
								break;
							case "defaultChecked":
								defaultChecked = propValue$jscomp$3;
								break;
							case "defaultValue":
								defaultValue$jscomp$0 = propValue$jscomp$3;
								break;
							case "checked":
								checked = propValue$jscomp$3;
								break;
							case "value":
								value$jscomp$1 = propValue$jscomp$3;
								break;
							default: pushAttribute$2(target$jscomp$0, propKey$jscomp$3, propValue$jscomp$3);
						}
					}
					null === formAction || "image" === props.type || "submit" === props.type || didWarnFormActionType || (didWarnFormActionType = !0, console.error("An input can only specify a formAction along with type=\"submit\" or type=\"image\"."));
					var formData = pushFormActionAttribute$2(target$jscomp$0, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name);
					null === checked || null === defaultChecked || didWarnDefaultChecked || (console.error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", "A component", props.type), didWarnDefaultChecked = !0);
					null === value$jscomp$1 || null === defaultValue$jscomp$0 || didWarnDefaultInputValue || (console.error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", "A component", props.type), didWarnDefaultInputValue = !0);
					null !== checked ? pushBooleanAttribute$2(target$jscomp$0, "checked", checked) : null !== defaultChecked && pushBooleanAttribute$2(target$jscomp$0, "checked", defaultChecked);
					null !== value$jscomp$1 ? pushAttribute$2(target$jscomp$0, "value", value$jscomp$1) : null !== defaultValue$jscomp$0 && pushAttribute$2(target$jscomp$0, "value", defaultValue$jscomp$0);
					target$jscomp$0.push(endOfStartTagSelfClosing$1);
					formData?.forEach(pushAdditionalFormField$2, target$jscomp$0);
					return null;
				case "button":
					target$jscomp$0.push(startChunkForTag$2("button"));
					var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;
					for (propKey$jscomp$4 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$4)) {
						var propValue$jscomp$4 = props[propKey$jscomp$4];
						if (null != propValue$jscomp$4) switch (propKey$jscomp$4) {
							case "children":
								children$jscomp$3 = propValue$jscomp$4;
								break;
							case "dangerouslySetInnerHTML":
								innerHTML$jscomp$2 = propValue$jscomp$4;
								break;
							case "name":
								name$jscomp$0 = propValue$jscomp$4;
								break;
							case "formAction":
								formAction$jscomp$0 = propValue$jscomp$4;
								break;
							case "formEncType":
								formEncType$jscomp$0 = propValue$jscomp$4;
								break;
							case "formMethod":
								formMethod$jscomp$0 = propValue$jscomp$4;
								break;
							case "formTarget":
								formTarget$jscomp$0 = propValue$jscomp$4;
								break;
							default: pushAttribute$2(target$jscomp$0, propKey$jscomp$4, propValue$jscomp$4);
						}
					}
					null === formAction$jscomp$0 || null == props.type || "submit" === props.type || didWarnFormActionType || (didWarnFormActionType = !0, console.error("A button can only specify a formAction along with type=\"submit\" or no type."));
					var formData$jscomp$0 = pushFormActionAttribute$2(target$jscomp$0, resumableState, renderState, formAction$jscomp$0, formEncType$jscomp$0, formMethod$jscomp$0, formTarget$jscomp$0, name$jscomp$0);
					target$jscomp$0.push(endOfStartTag$1);
					formData$jscomp$0?.forEach(pushAdditionalFormField$2, target$jscomp$0);
					pushInnerHTML$2(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);
					if ("string" === typeof children$jscomp$3) {
						target$jscomp$0.push(escapeTextForBrowser$2(children$jscomp$3));
						var JSCompiler_inline_result$jscomp$1 = null;
					} else JSCompiler_inline_result$jscomp$1 = children$jscomp$3;
					return JSCompiler_inline_result$jscomp$1;
				case "form":
					target$jscomp$0.push(startChunkForTag$2("form"));
					var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;
					for (propKey$jscomp$5 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$5)) {
						var propValue$jscomp$5 = props[propKey$jscomp$5];
						if (null != propValue$jscomp$5) switch (propKey$jscomp$5) {
							case "children":
								children$jscomp$4 = propValue$jscomp$5;
								break;
							case "dangerouslySetInnerHTML":
								innerHTML$jscomp$3 = propValue$jscomp$5;
								break;
							case "action":
								formAction$jscomp$1 = propValue$jscomp$5;
								break;
							case "encType":
								formEncType$jscomp$1 = propValue$jscomp$5;
								break;
							case "method":
								formMethod$jscomp$1 = propValue$jscomp$5;
								break;
							case "target":
								formTarget$jscomp$1 = propValue$jscomp$5;
								break;
							default: pushAttribute$2(target$jscomp$0, propKey$jscomp$5, propValue$jscomp$5);
						}
					}
					var formData$jscomp$1 = null, formActionName = null;
					if ("function" === typeof formAction$jscomp$1) {
						null === formEncType$jscomp$1 && null === formMethod$jscomp$1 || didWarnFormActionMethod || (didWarnFormActionMethod = !0, console.error("Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."));
						null === formTarget$jscomp$1 || didWarnFormActionTarget || (didWarnFormActionTarget = !0, console.error("Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."));
						var customFields = getCustomFormFields$2(resumableState, formAction$jscomp$1);
						null !== customFields ? (formAction$jscomp$1 = customFields.action || "", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(attributeSeparator$1, "action", attributeAssign$1, actionJavaScriptURL$2, attributeEnd$1), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime$2(resumableState, renderState));
					}
					null != formAction$jscomp$1 && pushAttribute$2(target$jscomp$0, "action", formAction$jscomp$1);
					null != formEncType$jscomp$1 && pushAttribute$2(target$jscomp$0, "encType", formEncType$jscomp$1);
					null != formMethod$jscomp$1 && pushAttribute$2(target$jscomp$0, "method", formMethod$jscomp$1);
					null != formTarget$jscomp$1 && pushAttribute$2(target$jscomp$0, "target", formTarget$jscomp$1);
					target$jscomp$0.push(endOfStartTag$1);
					null !== formActionName && (target$jscomp$0.push("<input type=\"hidden\""), pushStringAttribute$2(target$jscomp$0, "name", formActionName), target$jscomp$0.push(endOfStartTagSelfClosing$1), formData$jscomp$1?.forEach(pushAdditionalFormField$2, target$jscomp$0));
					pushInnerHTML$2(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);
					if ("string" === typeof children$jscomp$4) {
						target$jscomp$0.push(escapeTextForBrowser$2(children$jscomp$4));
						var JSCompiler_inline_result$jscomp$2 = null;
					} else JSCompiler_inline_result$jscomp$2 = children$jscomp$4;
					return JSCompiler_inline_result$jscomp$2;
				case "menuitem":
					target$jscomp$0.push(startChunkForTag$2("menuitem"));
					for (var propKey$jscomp$6 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$6)) {
						var propValue$jscomp$6 = props[propKey$jscomp$6];
						if (null != propValue$jscomp$6) switch (propKey$jscomp$6) {
							case "children":
							case "dangerouslySetInnerHTML": throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
							default: pushAttribute$2(target$jscomp$0, propKey$jscomp$6, propValue$jscomp$6);
						}
					}
					target$jscomp$0.push(endOfStartTag$1);
					return null;
				case "object":
					target$jscomp$0.push(startChunkForTag$2("object"));
					var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;
					for (propKey$jscomp$7 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$7)) {
						var propValue$jscomp$7 = props[propKey$jscomp$7];
						if (null != propValue$jscomp$7) switch (propKey$jscomp$7) {
							case "children":
								children$jscomp$5 = propValue$jscomp$7;
								break;
							case "dangerouslySetInnerHTML":
								innerHTML$jscomp$4 = propValue$jscomp$7;
								break;
							case "data":
								checkAttributeStringCoercion(propValue$jscomp$7, "data");
								var sanitizedValue = sanitizeURL$2("" + propValue$jscomp$7);
								if ("" === sanitizedValue) {
									console.error("An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.", propKey$jscomp$7, propKey$jscomp$7);
									break;
								}
								target$jscomp$0.push(attributeSeparator$1, "data", attributeAssign$1, escapeTextForBrowser$2(sanitizedValue), attributeEnd$1);
								break;
							default: pushAttribute$2(target$jscomp$0, propKey$jscomp$7, propValue$jscomp$7);
						}
					}
					target$jscomp$0.push(endOfStartTag$1);
					pushInnerHTML$2(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);
					if ("string" === typeof children$jscomp$5) {
						target$jscomp$0.push(escapeTextForBrowser$2(children$jscomp$5));
						var JSCompiler_inline_result$jscomp$3 = null;
					} else JSCompiler_inline_result$jscomp$3 = children$jscomp$5;
					return JSCompiler_inline_result$jscomp$3;
				case "title":
					var noscriptTagInScope = formatContext.tagScope & 1, isFallback = formatContext.tagScope & 4;
					if (hasOwnProperty$2.call(props, "children")) {
						var children$jscomp$6 = props.children, child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;
						Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length ? console.error("React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be common to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.", children$jscomp$6.length) : "function" === typeof child || "symbol" === typeof child ? console.error("React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.", "function" === typeof child ? "a Function" : "a Sybmol") : child && child.toString === {}.toString && (null != child.$$typeof ? console.error("React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML.") : console.error("React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>."));
					}
					if (formatContext.insertionMode === SVG_MODE || noscriptTagInScope || null != props.itemProp) var JSCompiler_inline_result$jscomp$4 = pushTitleImpl$2(target$jscomp$0, props);
					else isFallback ? JSCompiler_inline_result$jscomp$4 = null : (pushTitleImpl$2(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$4 = void 0);
					return JSCompiler_inline_result$jscomp$4;
				case "link":
					var noscriptTagInScope$jscomp$0 = formatContext.tagScope & 1, isFallback$jscomp$0 = formatContext.tagScope & 4, rel = props.rel, href = props.href, precedence = props.precedence;
					if (formatContext.insertionMode === SVG_MODE || noscriptTagInScope$jscomp$0 || null != props.itemProp || "string" !== typeof rel || "string" !== typeof href || "" === href) {
						"stylesheet" === rel && "string" === typeof props.precedence && ("string" === typeof href && href || console.error("React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.", null === href ? "`null`" : void 0 === href ? "`undefined`" : "" === href ? "an empty string" : "something with type \"" + typeof href + "\""));
						pushLinkImpl$2(target$jscomp$0, props);
						var JSCompiler_inline_result$jscomp$5 = null;
					} else if ("stylesheet" === props.rel) if ("string" !== typeof precedence || null != props.disabled || props.onLoad || props.onError) {
						if ("string" === typeof precedence) {
							if (null != props.disabled) console.error("React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.");
							else if (props.onLoad || props.onError) {
								var propDescription = props.onLoad && props.onError ? "`onLoad` and `onError` props" : props.onLoad ? "`onLoad` prop" : "`onError` prop";
								console.error("React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.", propDescription, propDescription);
							}
						}
						JSCompiler_inline_result$jscomp$5 = pushLinkImpl$2(target$jscomp$0, props);
					} else {
						var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
						if (resourceState !== EXISTS) {
							resumableState.styleResources[href] = EXISTS;
							styleQueue || (styleQueue = {
								precedence: escapeTextForBrowser$2(precedence),
								rules: [],
								hrefs: [],
								sheets: /* @__PURE__ */ new Map()
							}, renderState.styles.set(precedence, styleQueue));
							var resource = {
								state: PENDING$1,
								props: assign$2({}, props, {
									"data-precedence": props.precedence,
									precedence: null
								})
							};
							if (resourceState) {
								2 === resourceState.length && adoptPreloadCredentials$2(resource.props, resourceState);
								var preloadResource = renderState.preloads.stylesheets.get(href);
								preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = PRELOADED;
							}
							styleQueue.sheets.set(href, resource);
							hoistableState && hoistableState.stylesheets.add(resource);
						} else if (styleQueue) {
							var _resource = styleQueue.sheets.get(href);
							_resource && hoistableState && hoistableState.stylesheets.add(_resource);
						}
						textEmbedded && target$jscomp$0.push("<!-- -->");
						JSCompiler_inline_result$jscomp$5 = null;
					}
					else props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$5 = pushLinkImpl$2(target$jscomp$0, props) : (textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$5 = isFallback$jscomp$0 ? null : pushLinkImpl$2(renderState.hoistableChunks, props));
					return JSCompiler_inline_result$jscomp$5;
				case "script":
					var noscriptTagInScope$jscomp$1 = formatContext.tagScope & 1, asyncProp = props.async;
					if ("string" !== typeof props.src || !props.src || !asyncProp || "function" === typeof asyncProp || "symbol" === typeof asyncProp || props.onLoad || props.onError || formatContext.insertionMode === SVG_MODE || noscriptTagInScope$jscomp$1 || null != props.itemProp) var JSCompiler_inline_result$jscomp$6 = pushScriptImpl$2(target$jscomp$0, props);
					else {
						var key = props.src;
						if ("module" === props.type) {
							var resources = resumableState.moduleScriptResources;
							var preloads = renderState.preloads.moduleScripts;
						} else resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;
						var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : void 0;
						if (resourceState$jscomp$0 !== EXISTS) {
							resources[key] = EXISTS;
							var scriptProps = props;
							if (resourceState$jscomp$0) {
								2 === resourceState$jscomp$0.length && (scriptProps = assign$2({}, props), adoptPreloadCredentials$2(scriptProps, resourceState$jscomp$0));
								var preloadResource$jscomp$0 = preloads.get(key);
								preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);
							}
							var resource$jscomp$0 = [];
							renderState.scripts.add(resource$jscomp$0);
							pushScriptImpl$2(resource$jscomp$0, scriptProps);
						}
						textEmbedded && target$jscomp$0.push("<!-- -->");
						JSCompiler_inline_result$jscomp$6 = null;
					}
					return JSCompiler_inline_result$jscomp$6;
				case "style":
					var noscriptTagInScope$jscomp$2 = formatContext.tagScope & 1;
					if (hasOwnProperty$2.call(props, "children")) {
						var children$jscomp$7 = props.children, child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;
						("function" === typeof child$jscomp$0 || "symbol" === typeof child$jscomp$0 || Array.isArray(child$jscomp$0)) && console.error("React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.", "function" === typeof child$jscomp$0 ? "a Function" : "symbol" === typeof child$jscomp$0 ? "a Sybmol" : "an Array");
					}
					var precedence$jscomp$0 = props.precedence, href$jscomp$0 = props.href, nonce = props.nonce;
					if (formatContext.insertionMode === SVG_MODE || noscriptTagInScope$jscomp$2 || null != props.itemProp || "string" !== typeof precedence$jscomp$0 || "string" !== typeof href$jscomp$0 || "" === href$jscomp$0) {
						target$jscomp$0.push(startChunkForTag$2("style"));
						var children$jscomp$8 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;
						for (propKey$jscomp$8 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$8)) {
							var propValue$jscomp$8 = props[propKey$jscomp$8];
							if (null != propValue$jscomp$8) switch (propKey$jscomp$8) {
								case "children":
									children$jscomp$8 = propValue$jscomp$8;
									break;
								case "dangerouslySetInnerHTML":
									innerHTML$jscomp$5 = propValue$jscomp$8;
									break;
								default: pushAttribute$2(target$jscomp$0, propKey$jscomp$8, propValue$jscomp$8);
							}
						}
						target$jscomp$0.push(endOfStartTag$1);
						var child$jscomp$1 = Array.isArray(children$jscomp$8) ? 2 > children$jscomp$8.length ? children$jscomp$8[0] : null : children$jscomp$8;
						"function" !== typeof child$jscomp$1 && "symbol" !== typeof child$jscomp$1 && null !== child$jscomp$1 && void 0 !== child$jscomp$1 && target$jscomp$0.push(escapeStyleTextContent(child$jscomp$1));
						pushInnerHTML$2(target$jscomp$0, innerHTML$jscomp$5, children$jscomp$8);
						target$jscomp$0.push(endChunkForTag$2("style"));
						var JSCompiler_inline_result$jscomp$7 = null;
					} else {
						href$jscomp$0.includes(" ") && console.error("React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is \"%s\".", href$jscomp$0);
						var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0), resourceState$jscomp$1 = resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : void 0;
						if (resourceState$jscomp$1 !== EXISTS) {
							resumableState.styleResources[href$jscomp$0] = EXISTS;
							resourceState$jscomp$1 && console.error("React encountered a hoistable style tag for the same href as a preload: \"%s\". When using a style tag to inline styles you should not also preload it as a stylsheet.", href$jscomp$0);
							styleQueue$jscomp$0 || (styleQueue$jscomp$0 = {
								precedence: escapeTextForBrowser$2(precedence$jscomp$0),
								rules: [],
								hrefs: [],
								sheets: /* @__PURE__ */ new Map()
							}, renderState.styles.set(precedence$jscomp$0, styleQueue$jscomp$0));
							var nonceStyle = renderState.nonce.style;
							if (nonceStyle && nonceStyle !== nonce) console.error("React encountered a style tag with `precedence` \"%s\" and `nonce` \"%s\". When React manages style rules using `precedence` it will only include rules if the nonce matches the style nonce \"%s\" that was included with this render.", precedence$jscomp$0, nonce, nonceStyle);
							else {
								!nonceStyle && nonce && console.error("React encountered a style tag with `precedence` \"%s\" and `nonce` \"%s\". When React manages style rules using `precedence` it will only include a nonce attributes if you also provide the same style nonce value as a render option.", precedence$jscomp$0, nonce);
								styleQueue$jscomp$0.hrefs.push(escapeTextForBrowser$2(href$jscomp$0));
								var target = styleQueue$jscomp$0.rules, children$jscomp$9 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;
								for (propKey$jscomp$9 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$9)) {
									var propValue$jscomp$9 = props[propKey$jscomp$9];
									if (null != propValue$jscomp$9) switch (propKey$jscomp$9) {
										case "children":
											children$jscomp$9 = propValue$jscomp$9;
											break;
										case "dangerouslySetInnerHTML": innerHTML$jscomp$6 = propValue$jscomp$9;
									}
								}
								var child$jscomp$2 = Array.isArray(children$jscomp$9) ? 2 > children$jscomp$9.length ? children$jscomp$9[0] : null : children$jscomp$9;
								"function" !== typeof child$jscomp$2 && "symbol" !== typeof child$jscomp$2 && null !== child$jscomp$2 && void 0 !== child$jscomp$2 && target.push(escapeStyleTextContent(child$jscomp$2));
								pushInnerHTML$2(target, innerHTML$jscomp$6, children$jscomp$9);
							}
						}
						styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);
						textEmbedded && target$jscomp$0.push("<!-- -->");
						JSCompiler_inline_result$jscomp$7 = void 0;
					}
					return JSCompiler_inline_result$jscomp$7;
				case "meta":
					var noscriptTagInScope$jscomp$3 = formatContext.tagScope & 1, isFallback$jscomp$1 = formatContext.tagScope & 4;
					if (formatContext.insertionMode === SVG_MODE || noscriptTagInScope$jscomp$3 || null != props.itemProp) var JSCompiler_inline_result$jscomp$8 = pushSelfClosing$2(target$jscomp$0, props, "meta");
					else textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$8 = isFallback$jscomp$1 ? null : "string" === typeof props.charSet ? pushSelfClosing$2(renderState.charsetChunks, props, "meta") : "viewport" === props.name ? pushSelfClosing$2(renderState.viewportChunks, props, "meta") : pushSelfClosing$2(renderState.hoistableChunks, props, "meta");
					return JSCompiler_inline_result$jscomp$8;
				case "listing":
				case "pre":
					target$jscomp$0.push(startChunkForTag$2(type));
					var children$jscomp$10 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;
					for (propKey$jscomp$10 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$10)) {
						var propValue$jscomp$10 = props[propKey$jscomp$10];
						if (null != propValue$jscomp$10) switch (propKey$jscomp$10) {
							case "children":
								children$jscomp$10 = propValue$jscomp$10;
								break;
							case "dangerouslySetInnerHTML":
								innerHTML$jscomp$7 = propValue$jscomp$10;
								break;
							default: pushAttribute$2(target$jscomp$0, propKey$jscomp$10, propValue$jscomp$10);
						}
					}
					target$jscomp$0.push(endOfStartTag$1);
					if (null != innerHTML$jscomp$7) {
						if (null != children$jscomp$10) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
						if ("object" !== typeof innerHTML$jscomp$7 || !("__html" in innerHTML$jscomp$7)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
						var html = innerHTML$jscomp$7.__html;
						null !== html && void 0 !== html && ("string" === typeof html && 0 < html.length && "\n" === html[0] ? target$jscomp$0.push(leadingNewline$1, html) : (checkHtmlStringCoercion(html), target$jscomp$0.push("" + html)));
					}
					"string" === typeof children$jscomp$10 && "\n" === children$jscomp$10[0] && target$jscomp$0.push(leadingNewline$1);
					return children$jscomp$10;
				case "img":
					var pictureOrNoScriptTagInScope = formatContext.tagScope & 3, src = props.src, srcSet = props.srcSet;
					if (!("lazy" === props.loading || !src && !srcSet || "string" !== typeof src && null != src || "string" !== typeof srcSet && null != srcSet || "low" === props.fetchPriority || pictureOrNoScriptTagInScope) && ("string" !== typeof src || ":" !== src[4] || "d" !== src[0] && "D" !== src[0] || "a" !== src[1] && "A" !== src[1] || "t" !== src[2] && "T" !== src[2] || "a" !== src[3] && "A" !== src[3]) && ("string" !== typeof srcSet || ":" !== srcSet[4] || "d" !== srcSet[0] && "D" !== srcSet[0] || "a" !== srcSet[1] && "A" !== srcSet[1] || "t" !== srcSet[2] && "T" !== srcSet[2] || "a" !== srcSet[3] && "A" !== srcSet[3])) {
						null !== hoistableState && formatContext.tagScope & 64 && (hoistableState.suspenseyImages = !0);
						var sizes = "string" === typeof props.sizes ? props.sizes : void 0, key$jscomp$0 = srcSet ? srcSet + "\n" + (sizes || "") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);
						if (resource$jscomp$1) {
							if ("high" === props.fetchPriority || 10 > renderState.highImagePreloads.size) promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);
						} else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {
							resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS$2;
							var input = props.crossOrigin;
							var crossOrigin = "string" === typeof input ? "use-credentials" === input ? input : "" : void 0;
							var headers = renderState.headers, header;
							headers && 0 < headers.remainingCapacity && "string" !== typeof props.srcSet && ("high" === props.fetchPriority || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader$2(src, "image", {
								imageSrcSet: props.srcSet,
								imageSizes: props.sizes,
								crossOrigin,
								integrity: props.integrity,
								nonce: props.nonce,
								type: props.type,
								fetchPriority: props.fetchPriority,
								referrerPolicy: props.refererPolicy
							}), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS$2, headers.highImagePreloads && (headers.highImagePreloads += ", "), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl$2(resource$jscomp$1, {
								rel: "preload",
								as: "image",
								href: srcSet ? void 0 : src,
								imageSrcSet: srcSet,
								imageSizes: sizes,
								crossOrigin,
								integrity: props.integrity,
								type: props.type,
								fetchPriority: props.fetchPriority,
								referrerPolicy: props.referrerPolicy
							}), "high" === props.fetchPriority || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));
						}
					}
					return pushSelfClosing$2(target$jscomp$0, props, "img");
				case "base":
				case "area":
				case "br":
				case "col":
				case "embed":
				case "hr":
				case "keygen":
				case "param":
				case "source":
				case "track":
				case "wbr": return pushSelfClosing$2(target$jscomp$0, props, type);
				case "annotation-xml":
				case "color-profile":
				case "font-face":
				case "font-face-src":
				case "font-face-uri":
				case "font-face-format":
				case "font-face-name":
				case "missing-glyph": break;
				case "head":
					if (formatContext.insertionMode < HTML_MODE) {
						var preamble = preambleState || renderState.preamble;
						if (preamble.headChunks) throw Error("The `<head>` tag may only be rendered once.");
						null !== preambleState && target$jscomp$0.push("<!--head-->");
						preamble.headChunks = [];
						var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement$2(preamble.headChunks, props, "head");
					} else JSCompiler_inline_result$jscomp$9 = pushStartGenericElement$2(target$jscomp$0, props, "head");
					return JSCompiler_inline_result$jscomp$9;
				case "body":
					if (formatContext.insertionMode < HTML_MODE) {
						var preamble$jscomp$0 = preambleState || renderState.preamble;
						if (preamble$jscomp$0.bodyChunks) throw Error("The `<body>` tag may only be rendered once.");
						null !== preambleState && target$jscomp$0.push("<!--body-->");
						preamble$jscomp$0.bodyChunks = [];
						var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement$2(preamble$jscomp$0.bodyChunks, props, "body");
					} else JSCompiler_inline_result$jscomp$10 = pushStartGenericElement$2(target$jscomp$0, props, "body");
					return JSCompiler_inline_result$jscomp$10;
				case "html":
					if (formatContext.insertionMode === ROOT_HTML_MODE) {
						var preamble$jscomp$1 = preambleState || renderState.preamble;
						if (preamble$jscomp$1.htmlChunks) throw Error("The `<html>` tag may only be rendered once.");
						null !== preambleState && target$jscomp$0.push("<!--html-->");
						preamble$jscomp$1.htmlChunks = [doctypeChunk$1];
						var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement$2(preamble$jscomp$1.htmlChunks, props, "html");
					} else JSCompiler_inline_result$jscomp$11 = pushStartGenericElement$2(target$jscomp$0, props, "html");
					return JSCompiler_inline_result$jscomp$11;
				default: if (-1 !== type.indexOf("-")) {
					target$jscomp$0.push(startChunkForTag$2(type));
					var children$jscomp$11 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;
					for (propKey$jscomp$11 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$11)) {
						var propValue$jscomp$11 = props[propKey$jscomp$11];
						if (null != propValue$jscomp$11) {
							var attributeName = propKey$jscomp$11;
							switch (propKey$jscomp$11) {
								case "children":
									children$jscomp$11 = propValue$jscomp$11;
									break;
								case "dangerouslySetInnerHTML":
									innerHTML$jscomp$8 = propValue$jscomp$11;
									break;
								case "style":
									pushStyleAttribute$2(target$jscomp$0, propValue$jscomp$11);
									break;
								case "suppressContentEditableWarning":
								case "suppressHydrationWarning":
								case "ref": break;
								case "className": attributeName = "class";
								default: if (isAttributeNameSafe$2(propKey$jscomp$11) && "function" !== typeof propValue$jscomp$11 && "symbol" !== typeof propValue$jscomp$11 && !1 !== propValue$jscomp$11) {
									if (!0 === propValue$jscomp$11) propValue$jscomp$11 = "";
									else if ("object" === typeof propValue$jscomp$11) continue;
									target$jscomp$0.push(attributeSeparator$1, attributeName, attributeAssign$1, escapeTextForBrowser$2(propValue$jscomp$11), attributeEnd$1);
								}
							}
						}
					}
					target$jscomp$0.push(endOfStartTag$1);
					pushInnerHTML$2(target$jscomp$0, innerHTML$jscomp$8, children$jscomp$11);
					return children$jscomp$11;
				}
			}
			return pushStartGenericElement$2(target$jscomp$0, props, type);
		}
		function endChunkForTag$2(tag) {
			var chunk = endTagCache$2.get(tag);
			void 0 === chunk && (chunk = "</" + tag + ">", endTagCache$2.set(tag, chunk));
			return chunk;
		}
		function hoistPreambleState$2(renderState, preambleState) {
			renderState = renderState.preamble;
			null === renderState.htmlChunks && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks);
			null === renderState.headChunks && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks);
			null === renderState.bodyChunks && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks);
		}
		function writeBootstrap$2(destination, renderState) {
			renderState = renderState.bootstrapChunks;
			for (var i = 0; i < renderState.length - 1; i++) destination.push(renderState[i]);
			return i < renderState.length ? (i = renderState[i], renderState.length = 0, destination.push(i)) : !0;
		}
		function writeStartPendingSuspenseBoundary$2(destination, renderState, id) {
			destination.push(startPendingSuspenseBoundary1$1);
			if (null === id) throw Error("An ID must have been assigned before we can complete the boundary.");
			destination.push(renderState.boundaryPrefix);
			renderState = id.toString(16);
			destination.push(renderState);
			return destination.push(startPendingSuspenseBoundary2$1);
		}
		function writeStartSegment$2(destination, renderState, formatContext, id) {
			switch (formatContext.insertionMode) {
				case ROOT_HTML_MODE:
				case HTML_HTML_MODE:
				case HTML_HEAD_MODE:
				case HTML_MODE: return destination.push(startSegmentHTML$1), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentHTML2$1);
				case SVG_MODE: return destination.push(startSegmentSVG$1), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentSVG2$1);
				case MATHML_MODE: return destination.push(startSegmentMathML$1), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentMathML2$1);
				case HTML_TABLE_MODE: return destination.push(startSegmentTable$1), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentTable2$1);
				case HTML_TABLE_BODY_MODE: return destination.push(startSegmentTableBody$1), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentTableBody2$1);
				case HTML_TABLE_ROW_MODE: return destination.push(startSegmentTableRow$1), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentTableRow2$1);
				case HTML_COLGROUP_MODE: return destination.push(startSegmentColGroup$1), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentColGroup2$1);
				default: throw Error("Unknown insertion mode. This is a bug in React.");
			}
		}
		function writeEndSegment$2(destination, formatContext) {
			switch (formatContext.insertionMode) {
				case ROOT_HTML_MODE:
				case HTML_HTML_MODE:
				case HTML_HEAD_MODE:
				case HTML_MODE: return destination.push(endSegmentHTML$1);
				case SVG_MODE: return destination.push(endSegmentSVG$1);
				case MATHML_MODE: return destination.push(endSegmentMathML$1);
				case HTML_TABLE_MODE: return destination.push(endSegmentTable$1);
				case HTML_TABLE_BODY_MODE: return destination.push(endSegmentTableBody$1);
				case HTML_TABLE_ROW_MODE: return destination.push(endSegmentTableRow$1);
				case HTML_COLGROUP_MODE: return destination.push(endSegmentColGroup$1);
				default: throw Error("Unknown insertion mode. This is a bug in React.");
			}
		}
		function escapeJSStringsForInstructionScripts$2(input) {
			return JSON.stringify(input).replace(regexForJSStringsInInstructionScripts$2, function(match) {
				switch (match) {
					case "<": return "\\u003c";
					case "\u2028": return "\\u2028";
					case "\u2029": return "\\u2029";
					default: throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
				}
			});
		}
		function escapeJSObjectForInstructionScripts$2(input) {
			return JSON.stringify(input).replace(regexForJSStringsInScripts$2, function(match) {
				switch (match) {
					case "&": return "\\u0026";
					case ">": return "\\u003e";
					case "<": return "\\u003c";
					case "\u2028": return "\\u2028";
					case "\u2029": return "\\u2029";
					default: throw Error("escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
				}
			});
		}
		function flushStyleTagsLateForBoundary$2(styleQueue) {
			var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
			0 < rules.length && 0 === hrefs.length && console.error("React expected to have at least one href for an a hoistable style but found none. This is a bug in React.");
			var i = 0;
			if (hrefs.length) {
				this.push(currentlyFlushingRenderState$2.startInlineStyle);
				this.push(lateStyleTagResourceOpen1$1);
				this.push(styleQueue.precedence);
				for (this.push(lateStyleTagResourceOpen2$1); i < hrefs.length - 1; i++) this.push(hrefs[i]), this.push(spaceSeparator$1);
				this.push(hrefs[i]);
				this.push(lateStyleTagResourceOpen3$1);
				for (i = 0; i < rules.length; i++) this.push(rules[i]);
				destinationHasCapacity$3 = this.push(lateStyleTagTemplateClose$1);
				currentlyRenderingBoundaryHasStylesToHoist$2 = !0;
				rules.length = 0;
				hrefs.length = 0;
			}
		}
		function hasStylesToHoist$2(stylesheet) {
			return stylesheet.state !== PREAMBLE ? currentlyRenderingBoundaryHasStylesToHoist$2 = !0 : !1;
		}
		function writeHoistablesForBoundary$2(destination, hoistableState, renderState) {
			currentlyRenderingBoundaryHasStylesToHoist$2 = !1;
			destinationHasCapacity$3 = !0;
			currentlyFlushingRenderState$2 = renderState;
			hoistableState.styles.forEach(flushStyleTagsLateForBoundary$2, destination);
			currentlyFlushingRenderState$2 = null;
			hoistableState.stylesheets.forEach(hasStylesToHoist$2);
			currentlyRenderingBoundaryHasStylesToHoist$2 && (renderState.stylesToHoist = !0);
			return destinationHasCapacity$3;
		}
		function flushResource$2(resource) {
			for (var i = 0; i < resource.length; i++) this.push(resource[i]);
			resource.length = 0;
		}
		function flushStyleInPreamble$2(stylesheet) {
			pushLinkImpl$2(stylesheetFlushingQueue$2, stylesheet.props);
			for (var i = 0; i < stylesheetFlushingQueue$2.length; i++) this.push(stylesheetFlushingQueue$2[i]);
			stylesheetFlushingQueue$2.length = 0;
			stylesheet.state = PREAMBLE;
		}
		function flushStylesInPreamble$2(styleQueue) {
			var hasStylesheets = 0 < styleQueue.sheets.size;
			styleQueue.sheets.forEach(flushStyleInPreamble$2, this);
			styleQueue.sheets.clear();
			var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
			if (!hasStylesheets || hrefs.length) {
				this.push(currentlyFlushingRenderState$2.startInlineStyle);
				this.push(styleTagResourceOpen1$1);
				this.push(styleQueue.precedence);
				styleQueue = 0;
				if (hrefs.length) {
					for (this.push(styleTagResourceOpen2$1); styleQueue < hrefs.length - 1; styleQueue++) this.push(hrefs[styleQueue]), this.push(spaceSeparator$1);
					this.push(hrefs[styleQueue]);
				}
				this.push(styleTagResourceOpen3$1);
				for (styleQueue = 0; styleQueue < rules.length; styleQueue++) this.push(rules[styleQueue]);
				this.push(styleTagResourceClose$1);
				rules.length = 0;
				hrefs.length = 0;
			}
		}
		function preloadLateStyle$2(stylesheet) {
			if (stylesheet.state === PENDING$1) {
				stylesheet.state = PRELOADED;
				var props = stylesheet.props;
				pushLinkImpl$2(stylesheetFlushingQueue$2, {
					rel: "preload",
					as: "style",
					href: stylesheet.props.href,
					crossOrigin: props.crossOrigin,
					fetchPriority: props.fetchPriority,
					integrity: props.integrity,
					media: props.media,
					hrefLang: props.hrefLang,
					referrerPolicy: props.referrerPolicy
				});
				for (stylesheet = 0; stylesheet < stylesheetFlushingQueue$2.length; stylesheet++) this.push(stylesheetFlushingQueue$2[stylesheet]);
				stylesheetFlushingQueue$2.length = 0;
			}
		}
		function preloadLateStyles$2(styleQueue) {
			styleQueue.sheets.forEach(preloadLateStyle$2, this);
			styleQueue.sheets.clear();
		}
		function pushCompletedShellIdAttribute$2(target, resumableState) {
			(resumableState.instructions & SentCompletedShellId) === NothingSent && (resumableState.instructions |= SentCompletedShellId, target.push(completedShellIdAttributeStart$1, escapeTextForBrowser$2("_" + resumableState.idPrefix + "R_"), attributeEnd$1));
		}
		function writeStyleResourceDependenciesInJS$2(destination, hoistableState) {
			destination.push(arrayFirstOpenBracket$1);
			var nextArrayOpenBrackChunk = arrayFirstOpenBracket$1;
			hoistableState.stylesheets.forEach(function(resource) {
				if (resource.state !== PREAMBLE) if (resource.state === LATE) destination.push(nextArrayOpenBrackChunk), resource = resource.props.href, checkAttributeStringCoercion(resource, "href"), resource = escapeJSObjectForInstructionScripts$2("" + resource), destination.push(resource), destination.push(arrayCloseBracket$1), nextArrayOpenBrackChunk = arraySubsequentOpenBracket$1;
				else {
					destination.push(nextArrayOpenBrackChunk);
					var precedence = resource.props["data-precedence"], props = resource.props, coercedHref = sanitizeURL$2("" + resource.props.href);
					coercedHref = escapeJSObjectForInstructionScripts$2(coercedHref);
					destination.push(coercedHref);
					checkAttributeStringCoercion(precedence, "precedence");
					precedence = "" + precedence;
					destination.push(arrayInterstitial$1);
					precedence = escapeJSObjectForInstructionScripts$2(precedence);
					destination.push(precedence);
					for (var propKey in props) if (hasOwnProperty$2.call(props, propKey) && (precedence = props[propKey], null != precedence)) switch (propKey) {
						case "href":
						case "rel":
						case "precedence":
						case "data-precedence": break;
						case "children":
						case "dangerouslySetInnerHTML": throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
						default: writeStyleResourceAttributeInJS$2(destination, propKey, precedence);
					}
					destination.push(arrayCloseBracket$1);
					nextArrayOpenBrackChunk = arraySubsequentOpenBracket$1;
					resource.state = LATE;
				}
			});
			destination.push(arrayCloseBracket$1);
		}
		function writeStyleResourceAttributeInJS$2(destination, name, value) {
			var attributeName = name.toLowerCase();
			switch (typeof value) {
				case "function":
				case "symbol": return;
			}
			switch (name) {
				case "innerHTML":
				case "dangerouslySetInnerHTML":
				case "suppressContentEditableWarning":
				case "suppressHydrationWarning":
				case "style":
				case "ref": return;
				case "className":
					attributeName = "class";
					checkAttributeStringCoercion(value, attributeName);
					name = "" + value;
					break;
				case "hidden":
					if (!1 === value) return;
					name = "";
					break;
				case "src":
				case "href":
					value = sanitizeURL$2(value);
					checkAttributeStringCoercion(value, attributeName);
					name = "" + value;
					break;
				default:
					if (2 < name.length && ("o" === name[0] || "O" === name[0]) && ("n" === name[1] || "N" === name[1]) || !isAttributeNameSafe$2(name)) return;
					checkAttributeStringCoercion(value, attributeName);
					name = "" + value;
			}
			destination.push(arrayInterstitial$1);
			attributeName = escapeJSObjectForInstructionScripts$2(attributeName);
			destination.push(attributeName);
			destination.push(arrayInterstitial$1);
			attributeName = escapeJSObjectForInstructionScripts$2(name);
			destination.push(attributeName);
		}
		function createHoistableState$2() {
			return {
				styles: /* @__PURE__ */ new Set(),
				stylesheets: /* @__PURE__ */ new Set(),
				suspenseyImages: !1
			};
		}
		function preloadBootstrapScriptOrModule(resumableState, renderState, href, props) {
			(resumableState.scriptResources.hasOwnProperty(href) || resumableState.moduleScriptResources.hasOwnProperty(href)) && console.error("Internal React Error: React expected bootstrap script or module with src \"%s\" to not have been preloaded already. please file an issue", href);
			resumableState.scriptResources[href] = EXISTS;
			resumableState.moduleScriptResources[href] = EXISTS;
			resumableState = [];
			pushLinkImpl$2(resumableState, props);
			renderState.bootstrapScripts.add(resumableState);
		}
		function adoptPreloadCredentials$2(target, preloadState) {
			target.crossOrigin ??= preloadState[0];
			target.integrity ??= preloadState[1];
		}
		function getPreloadAsHeader$2(href, as, params) {
			href = escapeHrefForLinkHeaderURLContext(href);
			as = escapeStringForLinkHeaderQuotedParamValueContext(as, "as");
			as = "<" + href + ">; rel=preload; as=\"" + as + "\"";
			for (var paramName in params) hasOwnProperty$2.call(params, paramName) && (href = params[paramName], "string" === typeof href && (as += "; " + paramName.toLowerCase() + "=\"" + escapeStringForLinkHeaderQuotedParamValueContext(href, paramName) + "\""));
			return as;
		}
		function escapeHrefForLinkHeaderURLContext(hrefInput) {
			checkAttributeStringCoercion(hrefInput, "href");
			return ("" + hrefInput).replace(regexForHrefInLinkHeaderURLContext$2, escapeHrefForLinkHeaderURLContextReplacer$2);
		}
		function escapeHrefForLinkHeaderURLContextReplacer$2(match) {
			switch (match) {
				case "<": return "%3C";
				case ">": return "%3E";
				case "\n": return "%0A";
				case "\r": return "%0D";
				default: throw Error("escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
			}
		}
		function escapeStringForLinkHeaderQuotedParamValueContext(value, name) {
			willCoercionThrow(value) && (console.error("The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.", name, typeName(value)), testStringCoercion(value));
			return ("" + value).replace(regexForLinkHeaderQuotedParamValueContext$2, escapeStringForLinkHeaderQuotedParamValueContextReplacer$2);
		}
		function escapeStringForLinkHeaderQuotedParamValueContextReplacer$2(match) {
			switch (match) {
				case "\"": return "%22";
				case "'": return "%27";
				case ";": return "%3B";
				case ",": return "%2C";
				case "\n": return "%0A";
				case "\r": return "%0D";
				default: throw Error("escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
			}
		}
		function hoistStyleQueueDependency$2(styleQueue) {
			this.styles.add(styleQueue);
		}
		function hoistStylesheetDependency$2(stylesheet) {
			this.stylesheets.add(stylesheet);
		}
		function hoistHoistables$2(parentState, childState) {
			childState.styles.forEach(hoistStyleQueueDependency$2, parentState);
			childState.stylesheets.forEach(hoistStylesheetDependency$2, parentState);
			childState.suspenseyImages && (parentState.suspenseyImages = !0);
		}
		function createRenderState$2(resumableState, generateStaticMarkup) {
			var idPrefix = resumableState.idPrefix, bootstrapChunks = [], bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;
			void 0 !== bootstrapScriptContent && (bootstrapChunks.push("<script"), pushCompletedShellIdAttribute$2(bootstrapChunks, resumableState), bootstrapChunks.push(endOfStartTag$1, escapeEntireInlineScriptContent(bootstrapScriptContent), endInlineScript$1));
			idPrefix = {
				placeholderPrefix: idPrefix + "P:",
				segmentPrefix: idPrefix + "S:",
				boundaryPrefix: idPrefix + "B:",
				startInlineScript: "<script",
				startInlineStyle: "<style",
				preamble: {
					htmlChunks: null,
					headChunks: null,
					bodyChunks: null
				},
				externalRuntimeScript: null,
				bootstrapChunks,
				importMapChunks: [],
				onHeaders: void 0,
				headers: null,
				resets: {
					font: {},
					dns: {},
					connect: {
						default: {},
						anonymous: {},
						credentials: {}
					},
					image: {},
					style: {}
				},
				charsetChunks: [],
				viewportChunks: [],
				hoistableChunks: [],
				preconnects: /* @__PURE__ */ new Set(),
				fontPreloads: /* @__PURE__ */ new Set(),
				highImagePreloads: /* @__PURE__ */ new Set(),
				styles: /* @__PURE__ */ new Map(),
				bootstrapScripts: /* @__PURE__ */ new Set(),
				scripts: /* @__PURE__ */ new Set(),
				bulkPreloads: /* @__PURE__ */ new Set(),
				preloads: {
					images: /* @__PURE__ */ new Map(),
					stylesheets: /* @__PURE__ */ new Map(),
					scripts: /* @__PURE__ */ new Map(),
					moduleScripts: /* @__PURE__ */ new Map()
				},
				nonce: {
					script: void 0,
					style: void 0
				},
				hoistableState: null,
				stylesToHoist: !1
			};
			if (void 0 !== bootstrapScripts) for (bootstrapScriptContent = 0; bootstrapScriptContent < bootstrapScripts.length; bootstrapScriptContent++) {
				var scriptConfig = bootstrapScripts[bootstrapScriptContent], src, crossOrigin = void 0, integrity = void 0, props = {
					rel: "preload",
					as: "script",
					fetchPriority: "low",
					nonce: void 0
				};
				"string" === typeof scriptConfig ? props.href = src = scriptConfig : (props.href = src = scriptConfig.src, props.integrity = integrity = "string" === typeof scriptConfig.integrity ? scriptConfig.integrity : void 0, props.crossOrigin = crossOrigin = "string" === typeof scriptConfig || null == scriptConfig.crossOrigin ? void 0 : "use-credentials" === scriptConfig.crossOrigin ? "use-credentials" : "");
				preloadBootstrapScriptOrModule(resumableState, idPrefix, src, props);
				bootstrapChunks.push("<script src=\"", escapeTextForBrowser$2(src), attributeEnd$1);
				"string" === typeof integrity && bootstrapChunks.push(" integrity=\"", escapeTextForBrowser$2(integrity), attributeEnd$1);
				"string" === typeof crossOrigin && bootstrapChunks.push(" crossorigin=\"", escapeTextForBrowser$2(crossOrigin), attributeEnd$1);
				pushCompletedShellIdAttribute$2(bootstrapChunks, resumableState);
				bootstrapChunks.push(" async=\"\"><\/script>");
			}
			if (void 0 !== bootstrapModules) for (bootstrapScripts = 0; bootstrapScripts < bootstrapModules.length; bootstrapScripts++) bootstrapScriptContent = bootstrapModules[bootstrapScripts], crossOrigin = src = void 0, integrity = {
				rel: "modulepreload",
				fetchPriority: "low",
				nonce: void 0
			}, "string" === typeof bootstrapScriptContent ? integrity.href = scriptConfig = bootstrapScriptContent : (integrity.href = scriptConfig = bootstrapScriptContent.src, integrity.integrity = crossOrigin = "string" === typeof bootstrapScriptContent.integrity ? bootstrapScriptContent.integrity : void 0, integrity.crossOrigin = src = "string" === typeof bootstrapScriptContent || null == bootstrapScriptContent.crossOrigin ? void 0 : "use-credentials" === bootstrapScriptContent.crossOrigin ? "use-credentials" : ""), preloadBootstrapScriptOrModule(resumableState, idPrefix, scriptConfig, integrity), bootstrapChunks.push("<script type=\"module\" src=\"", escapeTextForBrowser$2(scriptConfig), attributeEnd$1), "string" === typeof crossOrigin && bootstrapChunks.push(" integrity=\"", escapeTextForBrowser$2(crossOrigin), attributeEnd$1), "string" === typeof src && bootstrapChunks.push(" crossorigin=\"", escapeTextForBrowser$2(src), attributeEnd$1), pushCompletedShellIdAttribute$2(bootstrapChunks, resumableState), bootstrapChunks.push(" async=\"\"><\/script>");
			return {
				placeholderPrefix: idPrefix.placeholderPrefix,
				segmentPrefix: idPrefix.segmentPrefix,
				boundaryPrefix: idPrefix.boundaryPrefix,
				startInlineScript: idPrefix.startInlineScript,
				startInlineStyle: idPrefix.startInlineStyle,
				preamble: idPrefix.preamble,
				externalRuntimeScript: idPrefix.externalRuntimeScript,
				bootstrapChunks: idPrefix.bootstrapChunks,
				importMapChunks: idPrefix.importMapChunks,
				onHeaders: idPrefix.onHeaders,
				headers: idPrefix.headers,
				resets: idPrefix.resets,
				charsetChunks: idPrefix.charsetChunks,
				viewportChunks: idPrefix.viewportChunks,
				hoistableChunks: idPrefix.hoistableChunks,
				preconnects: idPrefix.preconnects,
				fontPreloads: idPrefix.fontPreloads,
				highImagePreloads: idPrefix.highImagePreloads,
				styles: idPrefix.styles,
				bootstrapScripts: idPrefix.bootstrapScripts,
				scripts: idPrefix.scripts,
				bulkPreloads: idPrefix.bulkPreloads,
				preloads: idPrefix.preloads,
				nonce: idPrefix.nonce,
				stylesToHoist: idPrefix.stylesToHoist,
				generateStaticMarkup
			};
		}
		function pushTextInstance$2(target, text, renderState, textEmbedded) {
			if (renderState.generateStaticMarkup) return target.push(escapeTextForBrowser$2(text)), !1;
			"" === text ? target = textEmbedded : (textEmbedded && target.push("<!-- -->"), target.push(escapeTextForBrowser$2(text)), target = !0);
			return target;
		}
		function pushSegmentFinale$1(target, renderState, lastPushedText, textEmbedded) {
			renderState.generateStaticMarkup || lastPushedText && textEmbedded && target.push("<!-- -->");
		}
		function getComponentNameFromType$2(type) {
			if (null == type) return null;
			if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE$2 ? null : type.displayName || type.name || null;
			if ("string" === typeof type) return type;
			switch (type) {
				case REACT_FRAGMENT_TYPE$2: return "Fragment";
				case REACT_PROFILER_TYPE$2: return "Profiler";
				case REACT_STRICT_MODE_TYPE$2: return "StrictMode";
				case REACT_SUSPENSE_TYPE$2: return "Suspense";
				case REACT_SUSPENSE_LIST_TYPE$2: return "SuspenseList";
				case REACT_ACTIVITY_TYPE$2: return "Activity";
			}
			if ("object" === typeof type) switch ("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
				case REACT_PORTAL_TYPE$2: return "Portal";
				case REACT_CONTEXT_TYPE$2: return type.displayName || "Context";
				case REACT_CONSUMER_TYPE$2: return (type._context.displayName || "Context") + ".Consumer";
				case REACT_FORWARD_REF_TYPE$2:
					var innerType = type.render;
					type = type.displayName;
					type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
					return type;
				case REACT_MEMO_TYPE$2: return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType$2(type.type) || "Memo";
				case REACT_LAZY_TYPE$2:
					innerType = type._payload;
					type = type._init;
					try {
						return getComponentNameFromType$2(type(innerType));
					} catch (x) {}
			}
			return null;
		}
		function popToNearestCommonAncestor$2(prev, next) {
			if (prev !== next) {
				prev.context._currentValue2 = prev.parentValue;
				prev = prev.parent;
				var parentNext = next.parent;
				if (null === prev) {
					if (null !== parentNext) throw Error("The stacks must reach the root at the same time. This is a bug in React.");
				} else {
					if (null === parentNext) throw Error("The stacks must reach the root at the same time. This is a bug in React.");
					popToNearestCommonAncestor$2(prev, parentNext);
				}
				next.context._currentValue2 = next.value;
			}
		}
		function popAllPrevious$2(prev) {
			prev.context._currentValue2 = prev.parentValue;
			prev = prev.parent;
			null !== prev && popAllPrevious$2(prev);
		}
		function pushAllNext$2(next) {
			var parentNext = next.parent;
			null !== parentNext && pushAllNext$2(parentNext);
			next.context._currentValue2 = next.value;
		}
		function popPreviousToCommonLevel$2(prev, next) {
			prev.context._currentValue2 = prev.parentValue;
			prev = prev.parent;
			if (null === prev) throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
			prev.depth === next.depth ? popToNearestCommonAncestor$2(prev, next) : popPreviousToCommonLevel$2(prev, next);
		}
		function popNextToCommonLevel$2(prev, next) {
			var parentNext = next.parent;
			if (null === parentNext) throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
			prev.depth === parentNext.depth ? popToNearestCommonAncestor$2(prev, parentNext) : popNextToCommonLevel$2(prev, parentNext);
			next.context._currentValue2 = next.value;
		}
		function switchContext$2(newSnapshot) {
			var prev = currentActiveSnapshot$2;
			prev !== newSnapshot && (null === prev ? pushAllNext$2(newSnapshot) : null === newSnapshot ? popAllPrevious$2(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor$2(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel$2(prev, newSnapshot) : popNextToCommonLevel$2(prev, newSnapshot), currentActiveSnapshot$2 = newSnapshot);
		}
		function warnOnInvalidCallback(callback) {
			if (null !== callback && "function" !== typeof callback) {
				var key = String(callback);
				didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback));
			}
		}
		function warnNoop(publicInstance, callerName) {
			publicInstance = (publicInstance = publicInstance.constructor) && getComponentNameFromType$2(publicInstance) || "ReactClass";
			var warningKey = publicInstance + "." + callerName;
			didWarnAboutNoopUpdateForComponent[warningKey] || (console.error("Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, publicInstance), didWarnAboutNoopUpdateForComponent[warningKey] = !0);
		}
		function pushTreeContext$2(baseContext, totalChildren, index) {
			var baseIdWithLeadingBit = baseContext.id;
			baseContext = baseContext.overflow;
			var baseLength = 32 - clz32$2(baseIdWithLeadingBit) - 1;
			baseIdWithLeadingBit &= ~(1 << baseLength);
			index += 1;
			var length = 32 - clz32$2(totalChildren) + baseLength;
			if (30 < length) {
				var numberOfOverflowBits = baseLength - baseLength % 5;
				length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
				baseIdWithLeadingBit >>= numberOfOverflowBits;
				baseLength -= numberOfOverflowBits;
				return {
					id: 1 << 32 - clz32$2(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit,
					overflow: length + baseContext
				};
			}
			return {
				id: 1 << length | index << baseLength | baseIdWithLeadingBit,
				overflow: baseContext
			};
		}
		function clz32Fallback$2(x) {
			x >>>= 0;
			return 0 === x ? 32 : 31 - (log$2(x) / LN2$2 | 0) | 0;
		}
		function noop$2() {}
		function trackUsedThenable$2(thenableState$3, thenable, index) {
			index = thenableState$3[index];
			void 0 === index ? thenableState$3.push(thenable) : index !== thenable && (thenable.then(noop$2, noop$2), thenable = index);
			switch (thenable.status) {
				case "fulfilled": return thenable.value;
				case "rejected": throw thenable.reason;
				default:
					"string" === typeof thenable.status ? thenable.then(noop$2, noop$2) : (thenableState$3 = thenable, thenableState$3.status = "pending", thenableState$3.then(function(fulfilledValue) {
						if ("pending" === thenable.status) {
							var fulfilledThenable = thenable;
							fulfilledThenable.status = "fulfilled";
							fulfilledThenable.value = fulfilledValue;
						}
					}, function(error) {
						if ("pending" === thenable.status) {
							var rejectedThenable = thenable;
							rejectedThenable.status = "rejected";
							rejectedThenable.reason = error;
						}
					}));
					switch (thenable.status) {
						case "fulfilled": return thenable.value;
						case "rejected": throw thenable.reason;
					}
					suspendedThenable$2 = thenable;
					throw SuspenseException$2;
			}
		}
		function getSuspendedThenable$2() {
			if (null === suspendedThenable$2) throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
			var thenable = suspendedThenable$2;
			suspendedThenable$2 = null;
			return thenable;
		}
		function is$2(x, y) {
			return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
		}
		function resolveCurrentlyRenderingComponent$2() {
			if (null === currentlyRenderingComponent$2) throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
			isInHookUserCodeInDev && console.error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks");
			return currentlyRenderingComponent$2;
		}
		function createHook$2() {
			if (0 < numberOfReRenders$2) throw Error("Rendered more hooks than during the previous render");
			return {
				memoizedState: null,
				queue: null,
				next: null
			};
		}
		function createWorkInProgressHook$2() {
			null === workInProgressHook$2 ? null === firstWorkInProgressHook$2 ? (isReRender$2 = !1, firstWorkInProgressHook$2 = workInProgressHook$2 = createHook$2()) : (isReRender$2 = !0, workInProgressHook$2 = firstWorkInProgressHook$2) : null === workInProgressHook$2.next ? (isReRender$2 = !1, workInProgressHook$2 = workInProgressHook$2.next = createHook$2()) : (isReRender$2 = !0, workInProgressHook$2 = workInProgressHook$2.next);
			return workInProgressHook$2;
		}
		function getThenableStateAfterSuspending$2() {
			var state = thenableState$2;
			thenableState$2 = null;
			return state;
		}
		function resetHooksState$2() {
			isInHookUserCodeInDev = !1;
			currentlyRenderingKeyPath$2 = currentlyRenderingRequest$2 = currentlyRenderingTask$2 = currentlyRenderingComponent$2 = null;
			didScheduleRenderPhaseUpdate$2 = !1;
			firstWorkInProgressHook$2 = null;
			numberOfReRenders$2 = 0;
			workInProgressHook$2 = renderPhaseUpdates$2 = null;
		}
		function readContext(context) {
			isInHookUserCodeInDev && console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
			return context._currentValue2;
		}
		function basicStateReducer$2(state, action) {
			return "function" === typeof action ? action(state) : action;
		}
		function useReducer$2(reducer, initialArg, init) {
			reducer !== basicStateReducer$2 && (currentHookNameInDev = "useReducer");
			currentlyRenderingComponent$2 = resolveCurrentlyRenderingComponent$2();
			workInProgressHook$2 = createWorkInProgressHook$2();
			if (isReRender$2) {
				init = workInProgressHook$2.queue;
				initialArg = init.dispatch;
				if (null !== renderPhaseUpdates$2) {
					var firstRenderPhaseUpdate = renderPhaseUpdates$2.get(init);
					if (void 0 !== firstRenderPhaseUpdate) {
						renderPhaseUpdates$2.delete(init);
						init = workInProgressHook$2.memoizedState;
						do {
							var action = firstRenderPhaseUpdate.action;
							isInHookUserCodeInDev = !0;
							init = reducer(init, action);
							isInHookUserCodeInDev = !1;
							firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;
						} while (null !== firstRenderPhaseUpdate);
						workInProgressHook$2.memoizedState = init;
						return [init, initialArg];
					}
				}
				return [workInProgressHook$2.memoizedState, initialArg];
			}
			isInHookUserCodeInDev = !0;
			reducer = reducer === basicStateReducer$2 ? "function" === typeof initialArg ? initialArg() : initialArg : void 0 !== init ? init(initialArg) : initialArg;
			isInHookUserCodeInDev = !1;
			workInProgressHook$2.memoizedState = reducer;
			reducer = workInProgressHook$2.queue = {
				last: null,
				dispatch: null
			};
			reducer = reducer.dispatch = dispatchAction$2.bind(null, currentlyRenderingComponent$2, reducer);
			return [workInProgressHook$2.memoizedState, reducer];
		}
		function useMemo$2(nextCreate, deps) {
			currentlyRenderingComponent$2 = resolveCurrentlyRenderingComponent$2();
			workInProgressHook$2 = createWorkInProgressHook$2();
			deps = void 0 === deps ? null : deps;
			if (null !== workInProgressHook$2) {
				var prevState = workInProgressHook$2.memoizedState;
				if (null !== prevState && null !== deps) {
					a: {
						var JSCompiler_inline_result = prevState[1];
						if (null === JSCompiler_inline_result) console.error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev), JSCompiler_inline_result = !1;
						else {
							deps.length !== JSCompiler_inline_result.length && console.error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + deps.join(", ") + "]", "[" + JSCompiler_inline_result.join(", ") + "]");
							for (var i = 0; i < JSCompiler_inline_result.length && i < deps.length; i++) if (!objectIs$2(deps[i], JSCompiler_inline_result[i])) {
								JSCompiler_inline_result = !1;
								break a;
							}
							JSCompiler_inline_result = !0;
						}
					}
					if (JSCompiler_inline_result) return prevState[0];
				}
			}
			isInHookUserCodeInDev = !0;
			nextCreate = nextCreate();
			isInHookUserCodeInDev = !1;
			workInProgressHook$2.memoizedState = [nextCreate, deps];
			return nextCreate;
		}
		function dispatchAction$2(componentIdentity, queue, action) {
			if (25 <= numberOfReRenders$2) throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
			if (componentIdentity === currentlyRenderingComponent$2) if (didScheduleRenderPhaseUpdate$2 = !0, componentIdentity = {
				action,
				next: null
			}, null === renderPhaseUpdates$2 && (renderPhaseUpdates$2 = /* @__PURE__ */ new Map()), action = renderPhaseUpdates$2.get(queue), void 0 === action) renderPhaseUpdates$2.set(queue, componentIdentity);
			else {
				for (queue = action; null !== queue.next;) queue = queue.next;
				queue.next = componentIdentity;
			}
		}
		function throwOnUseEffectEventCall$2() {
			throw Error("A function wrapped in useEffectEvent can't be called during rendering.");
		}
		function unsupportedStartTransition$2() {
			throw Error("startTransition cannot be called during server rendering.");
		}
		function unsupportedSetOptimisticState$2() {
			throw Error("Cannot update optimistic state while rendering.");
		}
		function useActionState$2(action, initialState, permalink) {
			resolveCurrentlyRenderingComponent$2();
			var actionStateHookIndex = actionStateCounter$2++, request = currentlyRenderingRequest$2;
			if ("function" === typeof action.$$FORM_ACTION) {
				var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath$2;
				request = request.formState;
				var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;
				if (null !== request && "function" === typeof isSignatureEqual) {
					var postbackKey = request[1];
					isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc$1(JSON.stringify([
						componentKeyPath,
						null,
						actionStateHookIndex
					]), 0), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex$2 = actionStateHookIndex, initialState = request[0]));
				}
				var boundAction = action.bind(null, initialState);
				action = function(payload) {
					boundAction(payload);
				};
				"function" === typeof boundAction.$$FORM_ACTION && (action.$$FORM_ACTION = function(prefix$3) {
					prefix$3 = boundAction.$$FORM_ACTION(prefix$3);
					void 0 !== permalink && (checkAttributeStringCoercion(permalink, "target"), permalink += "", prefix$3.action = permalink);
					var formData = prefix$3.data;
					formData && (null === nextPostbackStateKey && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc$1(JSON.stringify([
						componentKeyPath,
						null,
						actionStateHookIndex
					]), 0)), formData.append("$ACTION_KEY", nextPostbackStateKey));
					return prefix$3;
				});
				return [
					initialState,
					action,
					!1
				];
			}
			var _boundAction = action.bind(null, initialState);
			return [
				initialState,
				function(payload) {
					_boundAction(payload);
				},
				!1
			];
		}
		function unwrapThenable$2(thenable) {
			var index = thenableIndexCounter$2;
			thenableIndexCounter$2 += 1;
			null === thenableState$2 && (thenableState$2 = []);
			return trackUsedThenable$2(thenableState$2, thenable, index);
		}
		function unsupportedRefresh$2() {
			throw Error("Cache cannot be refreshed during server rendering.");
		}
		function disabledLog() {}
		function disableLogs() {
			if (0 === disabledDepth) {
				prevLog = console.log;
				prevInfo = console.info;
				prevWarn = console.warn;
				prevError = console.error;
				prevGroup = console.group;
				prevGroupCollapsed = console.groupCollapsed;
				prevGroupEnd = console.groupEnd;
				var props = {
					configurable: !0,
					enumerable: !0,
					value: disabledLog,
					writable: !0
				};
				Object.defineProperties(console, {
					info: props,
					log: props,
					warn: props,
					error: props,
					group: props,
					groupCollapsed: props,
					groupEnd: props
				});
			}
			disabledDepth++;
		}
		function reenableLogs() {
			disabledDepth--;
			if (0 === disabledDepth) {
				var props = {
					configurable: !0,
					enumerable: !0,
					writable: !0
				};
				Object.defineProperties(console, {
					log: assign$2({}, props, { value: prevLog }),
					info: assign$2({}, props, { value: prevInfo }),
					warn: assign$2({}, props, { value: prevWarn }),
					error: assign$2({}, props, { value: prevError }),
					group: assign$2({}, props, { value: prevGroup }),
					groupCollapsed: assign$2({}, props, { value: prevGroupCollapsed }),
					groupEnd: assign$2({}, props, { value: prevGroupEnd })
				});
			}
			0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
		}
		function formatOwnerStack(error) {
			var prevPrepareStackTrace = Error.prepareStackTrace;
			Error.prepareStackTrace = void 0;
			error = error.stack;
			Error.prepareStackTrace = prevPrepareStackTrace;
			error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
			prevPrepareStackTrace = error.indexOf("\n");
			-1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
			prevPrepareStackTrace = error.indexOf("react_stack_bottom_frame");
			-1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf("\n", prevPrepareStackTrace));
			if (-1 !== prevPrepareStackTrace) error = error.slice(0, prevPrepareStackTrace);
			else return "";
			return error;
		}
		function describeBuiltInComponentFrame$2(name) {
			if (void 0 === prefix$2) try {
				throw Error();
			} catch (x) {
				var match = x.stack.trim().match(/\n( *(at )?)/);
				prefix$2 = match && match[1] || "";
				suffix$2 = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
			}
			return "\n" + prefix$2 + name + suffix$2;
		}
		function describeNativeComponentFrame$2(fn, construct) {
			if (!fn || reentry$2) return "";
			var frame = componentFrameCache.get(fn);
			if (void 0 !== frame) return frame;
			reentry$2 = !0;
			frame = Error.prepareStackTrace;
			Error.prepareStackTrace = void 0;
			var previousDispatcher$3 = null;
			previousDispatcher$3 = ReactSharedInternals$2.H;
			ReactSharedInternals$2.H = null;
			disableLogs();
			try {
				var RunInRootFrame = { DetermineComponentFrameRoot: function() {
					try {
						if (construct) {
							var Fake = function() {
								throw Error();
							};
							Object.defineProperty(Fake.prototype, "props", { set: function() {
								throw Error();
							} });
							if ("object" === typeof Reflect && Reflect.construct) {
								try {
									Reflect.construct(Fake, []);
								} catch (x) {
									var control = x;
								}
								Reflect.construct(fn, [], Fake);
							} else {
								try {
									Fake.call();
								} catch (x$0) {
									control = x$0;
								}
								fn.call(Fake.prototype);
							}
						} else {
							try {
								throw Error();
							} catch (x$1) {
								control = x$1;
							}
							(Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {});
						}
					} catch (sample) {
						if (sample && control && "string" === typeof sample.stack) return [sample.stack, control.stack];
					}
					return [null, null];
				} };
				RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
				var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
				namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
				var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
				if (sampleStack && controlStack) {
					var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
					for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot");) namePropDescriptor++;
					for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot");) _RunInRootFrame$Deter++;
					if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];) _RunInRootFrame$Deter--;
					for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--) if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
						if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) do
							if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
								var _frame = "\n" + sampleLines[namePropDescriptor].replace(" at new ", " at ");
								fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
								"function" === typeof fn && componentFrameCache.set(fn, _frame);
								return _frame;
							}
						while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
						break;
					}
				}
			} finally {
				reentry$2 = !1, ReactSharedInternals$2.H = previousDispatcher$3, reenableLogs(), Error.prepareStackTrace = frame;
			}
			sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame$2(sampleLines) : "";
			"function" === typeof fn && componentFrameCache.set(fn, sampleLines);
			return sampleLines;
		}
		function describeComponentStackByType$2(type) {
			if ("string" === typeof type) return describeBuiltInComponentFrame$2(type);
			if ("function" === typeof type) return type.prototype && type.prototype.isReactComponent ? describeNativeComponentFrame$2(type, !0) : describeNativeComponentFrame$2(type, !1);
			if ("object" === typeof type && null !== type) {
				switch (type.$$typeof) {
					case REACT_FORWARD_REF_TYPE$2: return describeNativeComponentFrame$2(type.render, !1);
					case REACT_MEMO_TYPE$2: return describeNativeComponentFrame$2(type.type, !1);
					case REACT_LAZY_TYPE$2:
						var lazyComponent = type, payload = lazyComponent._payload;
						lazyComponent = lazyComponent._init;
						try {
							type = lazyComponent(payload);
						} catch (x) {
							return describeBuiltInComponentFrame$2("Lazy");
						}
						return describeComponentStackByType$2(type);
				}
				if ("string" === typeof type.name) {
					a: {
						payload = type.name;
						lazyComponent = type.env;
						type = type.debugLocation;
						if (null != type) {
							type = formatOwnerStack(type);
							var idx = type.lastIndexOf("\n");
							type = -1 === idx ? type : type.slice(idx + 1);
							if (-1 !== type.indexOf(payload)) {
								payload = "\n" + type;
								break a;
							}
						}
						payload = describeBuiltInComponentFrame$2(payload + (lazyComponent ? " [" + lazyComponent + "]" : ""));
					}
					return payload;
				}
			}
			switch (type) {
				case REACT_SUSPENSE_LIST_TYPE$2: return describeBuiltInComponentFrame$2("SuspenseList");
				case REACT_SUSPENSE_TYPE$2: return describeBuiltInComponentFrame$2("Suspense");
			}
			return "";
		}
		function isEligibleForOutlining$2(request, boundary) {
			return (500 < boundary.byteSize || !1) && null === boundary.contentPreamble;
		}
		function defaultErrorHandler$2(error) {
			if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
				var JSCompiler_inline_result = error.environmentName;
				error = [error].slice(0);
				"string" === typeof error[0] ? error.splice(0, 1, "[%s] " + error[0], " " + JSCompiler_inline_result + " ") : error.splice(0, 0, "[%s]", " " + JSCompiler_inline_result + " ");
				error.unshift(console);
				JSCompiler_inline_result = bind$2.apply(console.error, error);
				JSCompiler_inline_result();
			} else console.error(error);
			return null;
		}
		function RequestInstance$2(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError$2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
			var abortSet = /* @__PURE__ */ new Set();
			this.destination = null;
			this.flushScheduled = !1;
			this.resumableState = resumableState;
			this.renderState = renderState;
			this.rootFormatContext = rootFormatContext;
			this.progressiveChunkSize = void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;
			this.status = 10;
			this.fatalError = null;
			this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
			this.completedPreambleSegments = this.completedRootSegment = null;
			this.byteSize = 0;
			this.abortableTasks = abortSet;
			this.pingedTasks = [];
			this.clientRenderedBoundaries = [];
			this.completedBoundaries = [];
			this.partialBoundaries = [];
			this.trackedPostpones = null;
			this.onError = void 0 === onError$2 ? defaultErrorHandler$2 : onError$2;
			this.onPostpone = void 0 === onPostpone ? noop$2 : onPostpone;
			this.onAllReady = void 0 === onAllReady ? noop$2 : onAllReady;
			this.onShellReady = void 0 === onShellReady ? noop$2 : onShellReady;
			this.onShellError = void 0 === onShellError ? noop$2 : onShellError;
			this.onFatalError = void 0 === onFatalError ? noop$2 : onFatalError;
			this.formState = void 0 === formState ? null : formState;
			this.didWarnForKey = null;
		}
		function createRequest$2(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError$2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
			var now = getCurrentTime();
			1e3 < now - lastResetTime && (ReactSharedInternals$2.recentlyCreatedOwnerStacks = 0, lastResetTime = now);
			resumableState = new RequestInstance$2(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError$2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState);
			renderState = createPendingSegment$2(resumableState, 0, null, rootFormatContext, !1, !1);
			renderState.parentFlushed = !0;
			children = createRenderTask$2(resumableState, null, children, -1, null, renderState, null, null, resumableState.abortableTasks, null, rootFormatContext, null, emptyTreeContext$2, null, null, emptyContextObject$2, null);
			pushComponentStack$2(children);
			resumableState.pingedTasks.push(children);
			return resumableState;
		}
		function pingTask$2(request, task) {
			request.pingedTasks.push(task);
			1 === request.pingedTasks.length && (request.flushScheduled = null !== request.destination, performWork$2(request));
		}
		function createSuspenseBoundary$2(request, row, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {
			fallbackAbortableTasks = {
				status: PENDING,
				rootSegmentID: -1,
				parentFlushed: !1,
				pendingTasks: 0,
				row,
				completedSegments: [],
				byteSize: 0,
				fallbackAbortableTasks,
				errorDigest: null,
				contentState: createHoistableState$2(),
				fallbackState: createHoistableState$2(),
				contentPreamble,
				fallbackPreamble,
				trackedContentKeyPath: null,
				trackedFallbackNode: null,
				errorMessage: null,
				errorStack: null,
				errorComponentStack: null
			};
			null !== row && (row.pendingTasks++, contentPreamble = row.boundaries, null !== contentPreamble && (request.allPendingTasks++, fallbackAbortableTasks.pendingTasks++, contentPreamble.push(fallbackAbortableTasks)), request = row.inheritedHoistables, null !== request && hoistHoistables$2(fallbackAbortableTasks.contentState, request));
			return fallbackAbortableTasks;
		}
		function createRenderTask$2(request, thenableState$3, node, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context, treeContext, row, componentStack, legacyContext, debugTask) {
			request.allPendingTasks++;
			null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
			null !== row && row.pendingTasks++;
			var task = {
				replay: null,
				node,
				childIndex,
				ping: function() {
					return pingTask$2(request, task);
				},
				blockedBoundary,
				blockedSegment,
				blockedPreamble,
				hoistableState,
				abortSet,
				keyPath,
				formatContext,
				context,
				treeContext,
				row,
				componentStack,
				thenableState: thenableState$3
			};
			task.debugTask = debugTask;
			abortSet.add(task);
			return task;
		}
		function createReplayTask$2(request, thenableState$3, replay, node, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context, treeContext, row, componentStack, legacyContext, debugTask) {
			request.allPendingTasks++;
			null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
			null !== row && row.pendingTasks++;
			replay.pendingTasks++;
			var task = {
				replay,
				node,
				childIndex,
				ping: function() {
					return pingTask$2(request, task);
				},
				blockedBoundary,
				blockedSegment: null,
				blockedPreamble: null,
				hoistableState,
				abortSet,
				keyPath,
				formatContext,
				context,
				treeContext,
				row,
				componentStack,
				thenableState: thenableState$3
			};
			task.debugTask = debugTask;
			abortSet.add(task);
			return task;
		}
		function createPendingSegment$2(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {
			return {
				status: PENDING,
				parentFlushed: !1,
				id: -1,
				index,
				chunks: [],
				children: [],
				preambleChildren: [],
				parentFormatContext,
				boundary,
				lastPushedText,
				textEmbedded
			};
		}
		function getCurrentStackInDEV() {
			if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack) return "";
			var componentStack = currentTaskInDEV.componentStack;
			try {
				var info = "";
				if ("string" === typeof componentStack.type) info += describeBuiltInComponentFrame$2(componentStack.type);
				else if ("function" === typeof componentStack.type) {
					if (!componentStack.owner) {
						var JSCompiler_temp_const = info, fn = componentStack.type, name = fn ? fn.displayName || fn.name : "";
						var JSCompiler_inline_result = name ? describeBuiltInComponentFrame$2(name) : "";
						info = JSCompiler_temp_const + JSCompiler_inline_result;
					}
				} else componentStack.owner || (info += describeComponentStackByType$2(componentStack.type));
				for (; componentStack;) JSCompiler_temp_const = null, null != componentStack.debugStack ? JSCompiler_temp_const = formatOwnerStack(componentStack.debugStack) : (JSCompiler_inline_result = componentStack, null != JSCompiler_inline_result.stack && (JSCompiler_temp_const = "string" !== typeof JSCompiler_inline_result.stack ? JSCompiler_inline_result.stack = formatOwnerStack(JSCompiler_inline_result.stack) : JSCompiler_inline_result.stack)), (componentStack = componentStack.owner) && JSCompiler_temp_const && (info += "\n" + JSCompiler_temp_const);
				var JSCompiler_inline_result$jscomp$0 = info;
			} catch (x) {
				JSCompiler_inline_result$jscomp$0 = "\nError generating stack: " + x.message + "\n" + x.stack;
			}
			return JSCompiler_inline_result$jscomp$0;
		}
		function pushHaltedAwaitOnComponentStack(task, debugInfo) {
			if (null != debugInfo) for (var i = debugInfo.length - 1; 0 <= i; i--) {
				var info = debugInfo[i];
				if ("string" === typeof info.name) break;
				if ("number" === typeof info.time) break;
				if (null != info.awaited) {
					var bestStack = null == info.debugStack ? info.awaited : info;
					if (void 0 !== bestStack.debugStack) {
						task.componentStack = {
							parent: task.componentStack,
							type: info,
							owner: bestStack.owner,
							stack: bestStack.debugStack
						};
						task.debugTask = bestStack.debugTask;
						break;
					}
				}
			}
		}
		function pushServerComponentStack(task, debugInfo) {
			if (null != debugInfo) for (var i = 0; i < debugInfo.length; i++) {
				var componentInfo = debugInfo[i];
				"string" === typeof componentInfo.name && void 0 !== componentInfo.debugStack && (task.componentStack = {
					parent: task.componentStack,
					type: componentInfo,
					owner: componentInfo.owner,
					stack: componentInfo.debugStack
				}, task.debugTask = componentInfo.debugTask);
			}
		}
		function pushComponentStack$2(task) {
			var node = task.node;
			if ("object" === typeof node && null !== node) switch (node.$$typeof) {
				case REACT_ELEMENT_TYPE$2:
					var type = node.type, owner = node._owner, stack = node._debugStack;
					pushServerComponentStack(task, node._debugInfo);
					task.debugTask = node._debugTask;
					task.componentStack = {
						parent: task.componentStack,
						type,
						owner,
						stack
					};
					break;
				case REACT_LAZY_TYPE$2:
					pushServerComponentStack(task, node._debugInfo);
					break;
				default: "function" === typeof node.then && pushServerComponentStack(task, node._debugInfo);
			}
		}
		function replaceSuspenseComponentStackWithSuspenseFallbackStack$2(componentStack) {
			return null === componentStack ? null : {
				parent: componentStack.parent,
				type: "Suspense Fallback",
				owner: componentStack.owner,
				stack: componentStack.stack
			};
		}
		function getThrownInfo$2(node$jscomp$0) {
			var errorInfo = {};
			node$jscomp$0 && Object.defineProperty(errorInfo, "componentStack", {
				configurable: !0,
				enumerable: !0,
				get: function() {
					try {
						var info = "", node = node$jscomp$0;
						do
							info += describeComponentStackByType$2(node.type), node = node.parent;
						while (node);
						var stack = info;
					} catch (x) {
						stack = "\nError generating stack: " + x.message + "\n" + x.stack;
					}
					Object.defineProperty(errorInfo, "componentStack", { value: stack });
					return stack;
				}
			});
			return errorInfo;
		}
		function encodeErrorForBoundary(boundary, digest, error, thrownInfo, wasAborted) {
			boundary.errorDigest = digest;
			error instanceof Error ? (digest = String(error.message), error = String(error.stack)) : (digest = "object" === typeof error && null !== error ? describeObjectForErrorMessage(error) : String(error), error = null);
			wasAborted = wasAborted ? "Switched to client rendering because the server rendering aborted due to:\n\n" : "Switched to client rendering because the server rendering errored:\n\n";
			boundary.errorMessage = wasAborted + digest;
			boundary.errorStack = null !== error ? wasAborted + error : null;
			boundary.errorComponentStack = thrownInfo.componentStack;
		}
		function logRecoverableError$2(request, error, errorInfo, debugTask) {
			request = request.onError;
			error = debugTask ? debugTask.run(request.bind(null, error, errorInfo)) : request(error, errorInfo);
			if (null != error && "string" !== typeof error) console.error("onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"%s\" instead", typeof error);
			else return error;
		}
		function fatalError$2(request, error, errorInfo, debugTask) {
			errorInfo = request.onShellError;
			var onFatalError = request.onFatalError;
			debugTask ? (debugTask.run(errorInfo.bind(null, error)), debugTask.run(onFatalError.bind(null, error))) : (errorInfo(error), onFatalError(error));
			null !== request.destination ? (request.status = CLOSED, request.destination.destroy(error)) : (request.status = 13, request.fatalError = error);
		}
		function finishSuspenseListRow$2(request, row) {
			unblockSuspenseListRow$2(request, row.next, row.hoistables);
		}
		function unblockSuspenseListRow$2(request, unblockedRow, inheritedHoistables) {
			for (; null !== unblockedRow;) {
				null !== inheritedHoistables && (hoistHoistables$2(unblockedRow.hoistables, inheritedHoistables), unblockedRow.inheritedHoistables = inheritedHoistables);
				var unblockedBoundaries = unblockedRow.boundaries;
				if (null !== unblockedBoundaries) {
					unblockedRow.boundaries = null;
					for (var i = 0; i < unblockedBoundaries.length; i++) {
						var unblockedBoundary = unblockedBoundaries[i];
						null !== inheritedHoistables && hoistHoistables$2(unblockedBoundary.contentState, inheritedHoistables);
						finishedTask$2(request, unblockedBoundary, null, null);
					}
				}
				unblockedRow.pendingTasks--;
				if (0 < unblockedRow.pendingTasks) break;
				inheritedHoistables = unblockedRow.hoistables;
				unblockedRow = unblockedRow.next;
			}
		}
		function tryToResolveTogetherRow$2(request, togetherRow) {
			var boundaries = togetherRow.boundaries;
			if (null !== boundaries && togetherRow.pendingTasks === boundaries.length) {
				for (var allCompleteAndInlinable = !0, i = 0; i < boundaries.length; i++) {
					var rowBoundary = boundaries[i];
					if (1 !== rowBoundary.pendingTasks || rowBoundary.parentFlushed || isEligibleForOutlining$2(request, rowBoundary)) {
						allCompleteAndInlinable = !1;
						break;
					}
				}
				allCompleteAndInlinable && unblockSuspenseListRow$2(request, togetherRow, togetherRow.hoistables);
			}
		}
		function createSuspenseListRow$2(previousRow) {
			var newRow = {
				pendingTasks: 1,
				boundaries: null,
				hoistables: createHoistableState$2(),
				inheritedHoistables: null,
				together: !1,
				next: null
			};
			null !== previousRow && 0 < previousRow.pendingTasks && (newRow.pendingTasks++, newRow.boundaries = [], previousRow.next = newRow);
			return newRow;
		}
		function renderSuspenseListRows$2(request, task, keyPath, rows, revealOrder) {
			var prevKeyPath = task.keyPath, prevTreeContext = task.treeContext, prevRow = task.row, previousComponentStack = task.componentStack;
			var previousDebugTask = task.debugTask;
			pushServerComponentStack(task, task.node.props.children._debugInfo);
			task.keyPath = keyPath;
			keyPath = rows.length;
			var previousSuspenseListRow = null;
			if (null !== task.replay) {
				var resumeSlots = task.replay.slots;
				if (null !== resumeSlots && "object" === typeof resumeSlots) for (var n = 0; n < keyPath; n++) {
					var i = "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder ? n : keyPath - 1 - n, node = rows[i];
					task.row = previousSuspenseListRow = createSuspenseListRow$2(previousSuspenseListRow);
					task.treeContext = pushTreeContext$2(prevTreeContext, keyPath, i);
					var resumeSegmentID = resumeSlots[i];
					"number" === typeof resumeSegmentID ? (resumeNode$2(request, task, resumeSegmentID, node, i), delete resumeSlots[i]) : renderNode$2(request, task, node, i);
					0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow$2(request, previousSuspenseListRow);
				}
				else for (resumeSlots = 0; resumeSlots < keyPath; resumeSlots++) n = "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder ? resumeSlots : keyPath - 1 - resumeSlots, i = rows[n], warnForMissingKey(request, task, i), task.row = previousSuspenseListRow = createSuspenseListRow$2(previousSuspenseListRow), task.treeContext = pushTreeContext$2(prevTreeContext, keyPath, n), renderNode$2(request, task, i, n), 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow$2(request, previousSuspenseListRow);
			} else if ("backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder) for (revealOrder = 0; revealOrder < keyPath; revealOrder++) resumeSlots = rows[revealOrder], warnForMissingKey(request, task, resumeSlots), task.row = previousSuspenseListRow = createSuspenseListRow$2(previousSuspenseListRow), task.treeContext = pushTreeContext$2(prevTreeContext, keyPath, revealOrder), renderNode$2(request, task, resumeSlots, revealOrder), 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow$2(request, previousSuspenseListRow);
			else {
				revealOrder = task.blockedSegment;
				resumeSlots = revealOrder.children.length;
				n = revealOrder.chunks.length;
				for (i = keyPath - 1; 0 <= i; i--) {
					node = rows[i];
					task.row = previousSuspenseListRow = createSuspenseListRow$2(previousSuspenseListRow);
					task.treeContext = pushTreeContext$2(prevTreeContext, keyPath, i);
					resumeSegmentID = createPendingSegment$2(request, n, null, task.formatContext, 0 === i ? revealOrder.lastPushedText : !0, !0);
					revealOrder.children.splice(resumeSlots, 0, resumeSegmentID);
					task.blockedSegment = resumeSegmentID;
					warnForMissingKey(request, task, node);
					try {
						renderNode$2(request, task, node, i), pushSegmentFinale$1(resumeSegmentID.chunks, request.renderState, resumeSegmentID.lastPushedText, resumeSegmentID.textEmbedded), resumeSegmentID.status = COMPLETED, 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow$2(request, previousSuspenseListRow);
					} catch (thrownValue) {
						throw resumeSegmentID.status = 12 === request.status ? ABORTED : ERRORED, thrownValue;
					}
				}
				task.blockedSegment = revealOrder;
				revealOrder.lastPushedText = !1;
			}
			null !== prevRow && null !== previousSuspenseListRow && 0 < previousSuspenseListRow.pendingTasks && (prevRow.pendingTasks++, previousSuspenseListRow.next = prevRow);
			task.treeContext = prevTreeContext;
			task.row = prevRow;
			task.keyPath = prevKeyPath;
			task.componentStack = previousComponentStack;
			task.debugTask = previousDebugTask;
		}
		function renderWithHooks$2(request, task, keyPath, Component, props, secondArg) {
			var prevThenableState = task.thenableState;
			task.thenableState = null;
			currentlyRenderingComponent$2 = {};
			currentlyRenderingTask$2 = task;
			currentlyRenderingRequest$2 = request;
			currentlyRenderingKeyPath$2 = keyPath;
			isInHookUserCodeInDev = !1;
			actionStateCounter$2 = localIdCounter$2 = 0;
			actionStateMatchingIndex$2 = -1;
			thenableIndexCounter$2 = 0;
			thenableState$2 = prevThenableState;
			for (request = callComponentInDEV(Component, props, secondArg); didScheduleRenderPhaseUpdate$2;) didScheduleRenderPhaseUpdate$2 = !1, actionStateCounter$2 = localIdCounter$2 = 0, actionStateMatchingIndex$2 = -1, thenableIndexCounter$2 = 0, numberOfReRenders$2 += 1, workInProgressHook$2 = null, request = Component(props, secondArg);
			resetHooksState$2();
			return request;
		}
		function finishFunctionComponent$2(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex$3) {
			var didEmitActionStateMarkers = !1;
			if (0 !== actionStateCount && null !== request.formState) {
				var segment = task.blockedSegment;
				if (null !== segment) {
					didEmitActionStateMarkers = !0;
					segment = segment.chunks;
					for (var i = 0; i < actionStateCount; i++) i === actionStateMatchingIndex$3 ? segment.push("<!--F!-->") : segment.push("<!--F-->");
				}
			}
			actionStateCount = task.keyPath;
			task.keyPath = keyPath;
			hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext$2(keyPath, 1, 0), renderNode$2(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode$2(request, task, children, -1) : renderNodeDestructive$2(request, task, children, -1);
			task.keyPath = actionStateCount;
		}
		function renderElement$2(request, task, keyPath, type, props, ref) {
			if ("function" === typeof type) if (type.prototype && type.prototype.isReactComponent) {
				var newProps = props;
				if ("ref" in props) {
					newProps = {};
					for (var propName in props) "ref" !== propName && (newProps[propName] = props[propName]);
				}
				var defaultProps = type.defaultProps;
				if (defaultProps) {
					newProps === props && (newProps = assign$2({}, newProps, props));
					for (var _propName in defaultProps) void 0 === newProps[_propName] && (newProps[_propName] = defaultProps[_propName]);
				}
				var resolvedProps = newProps;
				var context = emptyContextObject$2, contextType = type.contextType;
				if ("contextType" in type && null !== contextType && (void 0 === contextType || contextType.$$typeof !== REACT_CONTEXT_TYPE$2) && !didWarnAboutInvalidateContextType.has(type)) {
					didWarnAboutInvalidateContextType.add(type);
					var addendum = void 0 === contextType ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof contextType ? " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_CONSUMER_TYPE$2 ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
					console.error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType$2(type) || "Component", addendum);
				}
				"object" === typeof contextType && null !== contextType && (context = contextType._currentValue2);
				var instance = new type(resolvedProps, context);
				if ("function" === typeof type.getDerivedStateFromProps && (null === instance.state || void 0 === instance.state)) {
					var componentName = getComponentNameFromType$2(type) || "Component";
					didWarnAboutUninitializedState.has(componentName) || (didWarnAboutUninitializedState.add(componentName), console.error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, null === instance.state ? "null" : "undefined", componentName));
				}
				if ("function" === typeof type.getDerivedStateFromProps || "function" === typeof instance.getSnapshotBeforeUpdate) {
					var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
					"function" === typeof instance.componentWillMount && !0 !== instance.componentWillMount.__suppressDeprecationWarning ? foundWillMountName = "componentWillMount" : "function" === typeof instance.UNSAFE_componentWillMount && (foundWillMountName = "UNSAFE_componentWillMount");
					"function" === typeof instance.componentWillReceiveProps && !0 !== instance.componentWillReceiveProps.__suppressDeprecationWarning ? foundWillReceivePropsName = "componentWillReceiveProps" : "function" === typeof instance.UNSAFE_componentWillReceiveProps && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps");
					"function" === typeof instance.componentWillUpdate && !0 !== instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
					if (null !== foundWillMountName || null !== foundWillReceivePropsName || null !== foundWillUpdateName) {
						var _componentName = getComponentNameFromType$2(type) || "Component", newApiName = "function" === typeof type.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
						didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName), console.error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles", _componentName, newApiName, null !== foundWillMountName ? "\n  " + foundWillMountName : "", null !== foundWillReceivePropsName ? "\n  " + foundWillReceivePropsName : "", null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""));
					}
				}
				var name = getComponentNameFromType$2(type) || "Component";
				instance.render || (type.prototype && "function" === typeof type.prototype.render ? console.error("No `render` method found on the %s instance: did you accidentally return an object from the constructor?", name) : console.error("No `render` method found on the %s instance: you may have forgotten to define `render`.", name));
				!instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state || console.error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
				instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved && console.error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
				instance.contextType && console.error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
				type.childContextTypes && !didWarnAboutChildContextTypes.has(type) && (didWarnAboutChildContextTypes.add(type), console.error("%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)", name));
				type.contextTypes && !didWarnAboutContextTypes$1.has(type) && (didWarnAboutContextTypes$1.add(type), console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)", name));
				"function" === typeof instance.componentShouldUpdate && console.error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
				type.prototype && type.prototype.isPureReactComponent && "undefined" !== typeof instance.shouldComponentUpdate && console.error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType$2(type) || "A pure component");
				"function" === typeof instance.componentDidUnmount && console.error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
				"function" === typeof instance.componentDidReceiveProps && console.error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
				"function" === typeof instance.componentWillRecieveProps && console.error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
				"function" === typeof instance.UNSAFE_componentWillRecieveProps && console.error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
				var hasMutatedProps = instance.props !== resolvedProps;
				void 0 !== instance.props && hasMutatedProps && console.error("When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name);
				instance.defaultProps && console.error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
				"function" !== typeof instance.getSnapshotBeforeUpdate || "function" === typeof instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type), console.error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType$2(type)));
				"function" === typeof instance.getDerivedStateFromProps && console.error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
				"function" === typeof instance.getDerivedStateFromError && console.error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
				"function" === typeof type.getSnapshotBeforeUpdate && console.error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
				var state = instance.state;
				state && ("object" !== typeof state || isArrayImpl$2(state)) && console.error("%s.state: must be set to an object or null", name);
				"function" === typeof instance.getChildContext && "object" !== typeof type.childContextTypes && console.error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
				var initialState = void 0 !== instance.state ? instance.state : null;
				instance.updater = classComponentUpdater$2;
				instance.props = resolvedProps;
				instance.state = initialState;
				var internalInstance = {
					queue: [],
					replace: !1
				};
				instance._reactInternals = internalInstance;
				var contextType$jscomp$0 = type.contextType;
				instance.context = "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 ? contextType$jscomp$0._currentValue2 : emptyContextObject$2;
				if (instance.state === resolvedProps) {
					var componentName$jscomp$0 = getComponentNameFromType$2(type) || "Component";
					didWarnAboutDirectlyAssigningPropsToState.has(componentName$jscomp$0) || (didWarnAboutDirectlyAssigningPropsToState.add(componentName$jscomp$0), console.error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName$jscomp$0));
				}
				var getDerivedStateFromProps = type.getDerivedStateFromProps;
				if ("function" === typeof getDerivedStateFromProps) {
					var partialState = getDerivedStateFromProps(resolvedProps, initialState);
					if (void 0 === partialState) {
						var componentName$jscomp$1 = getComponentNameFromType$2(type) || "Component";
						didWarnAboutUndefinedDerivedState.has(componentName$jscomp$1) || (didWarnAboutUndefinedDerivedState.add(componentName$jscomp$1), console.error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName$jscomp$1));
					}
					instance.state = null === partialState || void 0 === partialState ? initialState : assign$2({}, initialState, partialState);
				}
				if ("function" !== typeof type.getDerivedStateFromProps && "function" !== typeof instance.getSnapshotBeforeUpdate && ("function" === typeof instance.UNSAFE_componentWillMount || "function" === typeof instance.componentWillMount)) {
					var oldState = instance.state;
					if ("function" === typeof instance.componentWillMount) {
						if (!0 !== instance.componentWillMount.__suppressDeprecationWarning) {
							var componentName$jscomp$2 = getComponentNameFromType$2(type) || "Unknown";
							didWarnAboutDeprecatedWillMount[componentName$jscomp$2] || (console.warn("componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s", componentName$jscomp$2), didWarnAboutDeprecatedWillMount[componentName$jscomp$2] = !0);
						}
						instance.componentWillMount();
					}
					"function" === typeof instance.UNSAFE_componentWillMount && instance.UNSAFE_componentWillMount();
					oldState !== instance.state && (console.error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType$2(type) || "Component"), classComponentUpdater$2.enqueueReplaceState(instance, instance.state, null));
					if (null !== internalInstance.queue && 0 < internalInstance.queue.length) {
						var oldQueue = internalInstance.queue, oldReplace = internalInstance.replace;
						internalInstance.queue = null;
						internalInstance.replace = !1;
						if (oldReplace && 1 === oldQueue.length) instance.state = oldQueue[0];
						else {
							for (var nextState = oldReplace ? oldQueue[0] : instance.state, dontMutate = !0, i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
								var partial = oldQueue[i], partialState$jscomp$0 = "function" === typeof partial ? partial.call(instance, nextState, resolvedProps, void 0) : partial;
								null != partialState$jscomp$0 && (dontMutate ? (dontMutate = !1, nextState = assign$2({}, nextState, partialState$jscomp$0)) : assign$2(nextState, partialState$jscomp$0));
							}
							instance.state = nextState;
						}
					} else internalInstance.queue = null;
				}
				var nextChildren = callRenderInDEV(instance);
				if (12 === request.status) throw null;
				instance.props !== resolvedProps && (didWarnAboutReassigningProps || console.error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType$2(type) || "a component"), didWarnAboutReassigningProps = !0);
				var prevKeyPath = task.keyPath;
				task.keyPath = keyPath;
				renderNodeDestructive$2(request, task, nextChildren, -1);
				task.keyPath = prevKeyPath;
			} else {
				if (type.prototype && "function" === typeof type.prototype.render) {
					var componentName$jscomp$3 = getComponentNameFromType$2(type) || "Unknown";
					didWarnAboutBadClass[componentName$jscomp$3] || (console.error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName$jscomp$3, componentName$jscomp$3), didWarnAboutBadClass[componentName$jscomp$3] = !0);
				}
				var value = renderWithHooks$2(request, task, keyPath, type, props, void 0);
				if (12 === request.status) throw null;
				var hasId = 0 !== localIdCounter$2, actionStateCount = actionStateCounter$2, actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex$2;
				if (type.contextTypes) {
					var _componentName$jscomp$0 = getComponentNameFromType$2(type) || "Unknown";
					didWarnAboutContextTypes[_componentName$jscomp$0] || (didWarnAboutContextTypes[_componentName$jscomp$0] = !0, console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)", _componentName$jscomp$0));
				}
				type && type.childContextTypes && console.error("childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...", type.displayName || type.name || "Component");
				if ("function" === typeof type.getDerivedStateFromProps) {
					var componentName$jscomp$4 = getComponentNameFromType$2(type) || "Unknown";
					didWarnAboutGetDerivedStateOnFunctionComponent[componentName$jscomp$4] || (console.error("%s: Function components do not support getDerivedStateFromProps.", componentName$jscomp$4), didWarnAboutGetDerivedStateOnFunctionComponent[componentName$jscomp$4] = !0);
				}
				if ("object" === typeof type.contextType && null !== type.contextType) {
					var _componentName2 = getComponentNameFromType$2(type) || "Unknown";
					didWarnAboutContextTypeOnFunctionComponent[_componentName2] || (console.error("%s: Function components do not support contextType.", _componentName2), didWarnAboutContextTypeOnFunctionComponent[_componentName2] = !0);
				}
				finishFunctionComponent$2(request, task, keyPath, value, hasId, actionStateCount, actionStateMatchingIndex$jscomp$0);
			}
			else if ("string" === typeof type) {
				var segment = task.blockedSegment;
				if (null === segment) {
					var children = props.children, prevContext = task.formatContext, prevKeyPath$jscomp$0 = task.keyPath;
					task.formatContext = getChildFormatContext$2(prevContext, type, props);
					task.keyPath = keyPath;
					renderNode$2(request, task, children, -1);
					task.formatContext = prevContext;
					task.keyPath = prevKeyPath$jscomp$0;
				} else {
					var _children = pushStartInstance$2(segment.chunks, type, props, request.resumableState, request.renderState, task.blockedPreamble, task.hoistableState, task.formatContext, segment.lastPushedText);
					segment.lastPushedText = !1;
					var _prevContext2 = task.formatContext, _prevKeyPath3 = task.keyPath;
					task.keyPath = keyPath;
					if ((task.formatContext = getChildFormatContext$2(_prevContext2, type, props)).insertionMode === HTML_HEAD_MODE) {
						var preambleSegment = createPendingSegment$2(request, 0, null, task.formatContext, !1, !1);
						segment.preambleChildren.push(preambleSegment);
						task.blockedSegment = preambleSegment;
						try {
							preambleSegment.status = 6, renderNode$2(request, task, _children, -1), pushSegmentFinale$1(preambleSegment.chunks, request.renderState, preambleSegment.lastPushedText, preambleSegment.textEmbedded), preambleSegment.status = COMPLETED;
						} finally {
							task.blockedSegment = segment;
						}
					} else renderNode$2(request, task, _children, -1);
					task.formatContext = _prevContext2;
					task.keyPath = _prevKeyPath3;
					a: {
						var target = segment.chunks, resumableState = request.resumableState;
						switch (type) {
							case "title":
							case "style":
							case "script":
							case "area":
							case "base":
							case "br":
							case "col":
							case "embed":
							case "hr":
							case "img":
							case "input":
							case "keygen":
							case "link":
							case "meta":
							case "param":
							case "source":
							case "track":
							case "wbr": break a;
							case "body":
								if (_prevContext2.insertionMode <= HTML_HTML_MODE) {
									resumableState.hasBody = !0;
									break a;
								}
								break;
							case "html":
								if (_prevContext2.insertionMode === ROOT_HTML_MODE) {
									resumableState.hasHtml = !0;
									break a;
								}
								break;
							case "head": if (_prevContext2.insertionMode <= HTML_HTML_MODE) break a;
						}
						target.push(endChunkForTag$2(type));
					}
					segment.lastPushedText = !1;
				}
			} else {
				switch (type) {
					case REACT_LEGACY_HIDDEN_TYPE$2:
					case REACT_STRICT_MODE_TYPE$2:
					case REACT_PROFILER_TYPE$2:
					case REACT_FRAGMENT_TYPE$2:
						var prevKeyPath$jscomp$1 = task.keyPath;
						task.keyPath = keyPath;
						renderNodeDestructive$2(request, task, props.children, -1);
						task.keyPath = prevKeyPath$jscomp$1;
						return;
					case REACT_ACTIVITY_TYPE$2:
						var segment$jscomp$0 = task.blockedSegment;
						if (null === segment$jscomp$0) {
							if ("hidden" !== props.mode) {
								var prevKeyPath$jscomp$2 = task.keyPath;
								task.keyPath = keyPath;
								renderNode$2(request, task, props.children, -1);
								task.keyPath = prevKeyPath$jscomp$2;
							}
						} else if ("hidden" !== props.mode) {
							request.renderState.generateStaticMarkup || segment$jscomp$0.chunks.push("<!--&-->");
							segment$jscomp$0.lastPushedText = !1;
							var _prevKeyPath4 = task.keyPath;
							task.keyPath = keyPath;
							renderNode$2(request, task, props.children, -1);
							task.keyPath = _prevKeyPath4;
							request.renderState.generateStaticMarkup || segment$jscomp$0.chunks.push("<!--/&-->");
							segment$jscomp$0.lastPushedText = !1;
						}
						return;
					case REACT_SUSPENSE_LIST_TYPE$2:
						a: {
							var children$jscomp$0 = props.children, revealOrder = props.revealOrder;
							if ("forwards" === revealOrder || "backwards" === revealOrder || "unstable_legacy-backwards" === revealOrder) {
								if (isArrayImpl$2(children$jscomp$0)) {
									renderSuspenseListRows$2(request, task, keyPath, children$jscomp$0, revealOrder);
									break a;
								}
								var iteratorFn = getIteratorFn$2(children$jscomp$0);
								if (iteratorFn) {
									var iterator = iteratorFn.call(children$jscomp$0);
									if (iterator) {
										validateIterable(task, children$jscomp$0, -1, iterator, iteratorFn);
										var step = iterator.next();
										if (!step.done) {
											var rows = [];
											do
												rows.push(step.value), step = iterator.next();
											while (!step.done);
											renderSuspenseListRows$2(request, task, keyPath, children$jscomp$0, revealOrder);
										}
										break a;
									}
								}
							}
							if ("together" === revealOrder) {
								var _prevKeyPath2 = task.keyPath, prevRow = task.row, newRow = task.row = createSuspenseListRow$2(null);
								newRow.boundaries = [];
								newRow.together = !0;
								task.keyPath = keyPath;
								renderNodeDestructive$2(request, task, children$jscomp$0, -1);
								0 === --newRow.pendingTasks && finishSuspenseListRow$2(request, newRow);
								task.keyPath = _prevKeyPath2;
								task.row = prevRow;
								null !== prevRow && 0 < newRow.pendingTasks && (prevRow.pendingTasks++, newRow.next = prevRow);
							} else {
								var prevKeyPath$jscomp$3 = task.keyPath;
								task.keyPath = keyPath;
								renderNodeDestructive$2(request, task, children$jscomp$0, -1);
								task.keyPath = prevKeyPath$jscomp$3;
							}
						}
						return;
					case REACT_VIEW_TRANSITION_TYPE$2:
					case REACT_SCOPE_TYPE$2: throw Error("ReactDOMServer does not yet support scope components.");
					case REACT_SUSPENSE_TYPE$2:
						a: if (null !== task.replay) {
							var _prevKeyPath = task.keyPath, _prevContext = task.formatContext, _prevRow = task.row;
							task.keyPath = keyPath;
							task.formatContext = getSuspenseContentFormatContext$2(request.resumableState, _prevContext);
							task.row = null;
							var _content = props.children;
							try {
								renderNode$2(request, task, _content, -1);
							} finally {
								task.keyPath = _prevKeyPath, task.formatContext = _prevContext, task.row = _prevRow;
							}
						} else {
							var prevKeyPath$jscomp$4 = task.keyPath, prevContext$jscomp$0 = task.formatContext, prevRow$jscomp$0 = task.row, parentBoundary = task.blockedBoundary, parentPreamble = task.blockedPreamble, parentHoistableState = task.hoistableState, parentSegment = task.blockedSegment, fallback = props.fallback, content = props.children, fallbackAbortSet = /* @__PURE__ */ new Set();
							var newBoundary = createSuspenseBoundary$2(request, task.row, fallbackAbortSet, null, null);
							null !== request.trackedPostpones && (newBoundary.trackedContentKeyPath = keyPath);
							var boundarySegment = createPendingSegment$2(request, parentSegment.chunks.length, newBoundary, task.formatContext, !1, !1);
							parentSegment.children.push(boundarySegment);
							parentSegment.lastPushedText = !1;
							var contentRootSegment = createPendingSegment$2(request, 0, null, task.formatContext, !1, !1);
							contentRootSegment.parentFlushed = !0;
							if (null !== request.trackedPostpones) {
								var suspenseComponentStack = task.componentStack, fallbackKeyPath = [
									keyPath[0],
									"Suspense Fallback",
									keyPath[2]
								], fallbackReplayNode = [
									fallbackKeyPath[1],
									fallbackKeyPath[2],
									[],
									null
								];
								request.trackedPostpones.workingMap.set(fallbackKeyPath, fallbackReplayNode);
								newBoundary.trackedFallbackNode = fallbackReplayNode;
								task.blockedSegment = boundarySegment;
								task.blockedPreamble = newBoundary.fallbackPreamble;
								task.keyPath = fallbackKeyPath;
								task.formatContext = getSuspenseFallbackFormatContext$2(request.resumableState, prevContext$jscomp$0);
								task.componentStack = replaceSuspenseComponentStackWithSuspenseFallbackStack$2(suspenseComponentStack);
								boundarySegment.status = 6;
								try {
									renderNode$2(request, task, fallback, -1), pushSegmentFinale$1(boundarySegment.chunks, request.renderState, boundarySegment.lastPushedText, boundarySegment.textEmbedded), boundarySegment.status = COMPLETED;
								} catch (thrownValue) {
									throw boundarySegment.status = 12 === request.status ? ABORTED : ERRORED, thrownValue;
								} finally {
									task.blockedSegment = parentSegment, task.blockedPreamble = parentPreamble, task.keyPath = prevKeyPath$jscomp$4, task.formatContext = prevContext$jscomp$0;
								}
								var suspendedPrimaryTask = createRenderTask$2(request, null, content, -1, newBoundary, contentRootSegment, newBoundary.contentPreamble, newBoundary.contentState, task.abortSet, keyPath, getSuspenseContentFormatContext$2(request.resumableState, task.formatContext), task.context, task.treeContext, null, suspenseComponentStack, emptyContextObject$2, task.debugTask);
								pushComponentStack$2(suspendedPrimaryTask);
								request.pingedTasks.push(suspendedPrimaryTask);
							} else {
								task.blockedBoundary = newBoundary;
								task.blockedPreamble = newBoundary.contentPreamble;
								task.hoistableState = newBoundary.contentState;
								task.blockedSegment = contentRootSegment;
								task.keyPath = keyPath;
								task.formatContext = getSuspenseContentFormatContext$2(request.resumableState, prevContext$jscomp$0);
								task.row = null;
								contentRootSegment.status = 6;
								try {
									if (renderNode$2(request, task, content, -1), pushSegmentFinale$1(contentRootSegment.chunks, request.renderState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded), contentRootSegment.status = COMPLETED, queueCompletedSegment$2(newBoundary, contentRootSegment), 0 === newBoundary.pendingTasks && newBoundary.status === PENDING) {
										if (newBoundary.status = COMPLETED, !isEligibleForOutlining$2(request, newBoundary)) {
											null !== prevRow$jscomp$0 && 0 === --prevRow$jscomp$0.pendingTasks && finishSuspenseListRow$2(request, prevRow$jscomp$0);
											0 === request.pendingRootTasks && task.blockedPreamble && preparePreamble$2(request);
											break a;
										}
									} else null !== prevRow$jscomp$0 && prevRow$jscomp$0.together && tryToResolveTogetherRow$2(request, prevRow$jscomp$0);
								} catch (thrownValue$2) {
									newBoundary.status = CLIENT_RENDERED;
									if (12 === request.status) {
										contentRootSegment.status = ABORTED;
										var error = request.fatalError;
									} else contentRootSegment.status = ERRORED, error = thrownValue$2;
									var thrownInfo = getThrownInfo$2(task.componentStack);
									encodeErrorForBoundary(newBoundary, logRecoverableError$2(request, error, thrownInfo, task.debugTask), error, thrownInfo, !1);
									untrackBoundary$2(request, newBoundary);
								} finally {
									task.blockedBoundary = parentBoundary, task.blockedPreamble = parentPreamble, task.hoistableState = parentHoistableState, task.blockedSegment = parentSegment, task.keyPath = prevKeyPath$jscomp$4, task.formatContext = prevContext$jscomp$0, task.row = prevRow$jscomp$0;
								}
								var suspendedFallbackTask = createRenderTask$2(request, null, fallback, -1, parentBoundary, boundarySegment, newBoundary.fallbackPreamble, newBoundary.fallbackState, fallbackAbortSet, [
									keyPath[0],
									"Suspense Fallback",
									keyPath[2]
								], getSuspenseFallbackFormatContext$2(request.resumableState, task.formatContext), task.context, task.treeContext, task.row, replaceSuspenseComponentStackWithSuspenseFallbackStack$2(task.componentStack), emptyContextObject$2, task.debugTask);
								pushComponentStack$2(suspendedFallbackTask);
								request.pingedTasks.push(suspendedFallbackTask);
							}
						}
						return;
				}
				if ("object" === typeof type && null !== type) switch (type.$$typeof) {
					case REACT_FORWARD_REF_TYPE$2:
						if ("ref" in props) {
							var propsWithoutRef = {};
							for (var key in props) "ref" !== key && (propsWithoutRef[key] = props[key]);
						} else propsWithoutRef = props;
						finishFunctionComponent$2(request, task, keyPath, renderWithHooks$2(request, task, keyPath, type.render, propsWithoutRef, ref), 0 !== localIdCounter$2, actionStateCounter$2, actionStateMatchingIndex$2);
						return;
					case REACT_MEMO_TYPE$2:
						renderElement$2(request, task, keyPath, type.type, props, ref);
						return;
					case REACT_CONTEXT_TYPE$2:
						var value$jscomp$0 = props.value, children$jscomp$2 = props.children;
						var prevSnapshot = task.context;
						var prevKeyPath$jscomp$5 = task.keyPath;
						var prevValue = type._currentValue2;
						type._currentValue2 = value$jscomp$0;
						void 0 !== type._currentRenderer2 && null !== type._currentRenderer2 && type._currentRenderer2 !== rendererSigil && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
						type._currentRenderer2 = rendererSigil;
						var prevNode = currentActiveSnapshot$2, newNode = {
							parent: prevNode,
							depth: null === prevNode ? 0 : prevNode.depth + 1,
							context: type,
							parentValue: prevValue,
							value: value$jscomp$0
						};
						currentActiveSnapshot$2 = newNode;
						task.context = newNode;
						task.keyPath = keyPath;
						renderNodeDestructive$2(request, task, children$jscomp$2, -1);
						var prevSnapshot$jscomp$0 = currentActiveSnapshot$2;
						if (null === prevSnapshot$jscomp$0) throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
						prevSnapshot$jscomp$0.context !== type && console.error("The parent context is not the expected context. This is probably a bug in React.");
						prevSnapshot$jscomp$0.context._currentValue2 = prevSnapshot$jscomp$0.parentValue;
						void 0 !== type._currentRenderer2 && null !== type._currentRenderer2 && type._currentRenderer2 !== rendererSigil && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
						type._currentRenderer2 = rendererSigil;
						task.context = currentActiveSnapshot$2 = prevSnapshot$jscomp$0.parent;
						task.keyPath = prevKeyPath$jscomp$5;
						prevSnapshot !== task.context && console.error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
						return;
					case REACT_CONSUMER_TYPE$2:
						var context$jscomp$0 = type._context, render$1 = props.children;
						"function" !== typeof render$1 && console.error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
						var newChildren = render$1(context$jscomp$0._currentValue2), prevKeyPath$jscomp$6 = task.keyPath;
						task.keyPath = keyPath;
						renderNodeDestructive$2(request, task, newChildren, -1);
						task.keyPath = prevKeyPath$jscomp$6;
						return;
					case REACT_LAZY_TYPE$2:
						var Component = callLazyInitInDEV(type);
						if (12 === request.status) throw null;
						renderElement$2(request, task, keyPath, Component, props, ref);
						return;
				}
				var info = "";
				if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length) info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
				throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((null == type ? type : typeof type) + "." + info));
			}
		}
		function resumeNode$2(request, task, segmentId, node, childIndex) {
			var prevReplay = task.replay, blockedBoundary = task.blockedBoundary, resumedSegment = createPendingSegment$2(request, 0, null, task.formatContext, !1, !1);
			resumedSegment.id = segmentId;
			resumedSegment.parentFlushed = !0;
			try {
				task.replay = null, task.blockedSegment = resumedSegment, renderNode$2(request, task, node, childIndex), resumedSegment.status = COMPLETED, null === blockedBoundary ? request.completedRootSegment = resumedSegment : (queueCompletedSegment$2(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));
			} finally {
				task.replay = prevReplay, task.blockedSegment = null;
			}
		}
		function replayElement(request, task, keyPath, name, keyOrIndex, childIndex, type, props, ref, replay) {
			childIndex = replay.nodes;
			for (var i = 0; i < childIndex.length; i++) {
				var node = childIndex[i];
				if (keyOrIndex === node[1]) {
					if (4 === node.length) {
						if (null !== name && name !== node[0]) throw Error("Expected the resume to render <" + node[0] + "> in this slot but instead it rendered <" + name + ">. The tree doesn't match so React will fallback to client rendering.");
						var childNodes = node[2];
						name = node[3];
						keyOrIndex = task.node;
						task.replay = {
							nodes: childNodes,
							slots: name,
							pendingTasks: 1
						};
						try {
							renderElement$2(request, task, keyPath, type, props, ref);
							if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length) throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
							task.replay.pendingTasks--;
						} catch (x) {
							if ("object" === typeof x && null !== x && (x === SuspenseException$2 || "function" === typeof x.then)) throw task.node === keyOrIndex ? task.replay = replay : childIndex.splice(i, 1), x;
							task.replay.pendingTasks--;
							type = getThrownInfo$2(task.componentStack);
							props = request;
							request = task.blockedBoundary;
							keyPath = x;
							ref = name;
							name = logRecoverableError$2(props, keyPath, type, task.debugTask);
							abortRemainingReplayNodes$2(props, request, childNodes, ref, keyPath, name, type, !1);
						}
						task.replay = replay;
					} else {
						if (type !== REACT_SUSPENSE_TYPE$2) throw Error("Expected the resume to render <Suspense> in this slot but instead it rendered <" + (getComponentNameFromType$2(type) || "Unknown") + ">. The tree doesn't match so React will fallback to client rendering.");
						a: {
							replay = void 0;
							name = node[5];
							type = node[2];
							ref = node[3];
							keyOrIndex = null === node[4] ? [] : node[4][2];
							node = null === node[4] ? null : node[4][3];
							var prevKeyPath = task.keyPath, prevContext = task.formatContext, prevRow = task.row, previousReplaySet = task.replay, parentBoundary = task.blockedBoundary, parentHoistableState = task.hoistableState, content = props.children, fallback = props.fallback, fallbackAbortSet = /* @__PURE__ */ new Set();
							props = createSuspenseBoundary$2(request, task.row, fallbackAbortSet, null, null);
							props.parentFlushed = !0;
							props.rootSegmentID = name;
							task.blockedBoundary = props;
							task.hoistableState = props.contentState;
							task.keyPath = keyPath;
							task.formatContext = getSuspenseContentFormatContext$2(request.resumableState, prevContext);
							task.row = null;
							task.replay = {
								nodes: type,
								slots: ref,
								pendingTasks: 1
							};
							try {
								renderNode$2(request, task, content, -1);
								if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length) throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
								task.replay.pendingTasks--;
								if (0 === props.pendingTasks && props.status === PENDING) {
									props.status = COMPLETED;
									request.completedBoundaries.push(props);
									break a;
								}
							} catch (error) {
								props.status = CLIENT_RENDERED, childNodes = getThrownInfo$2(task.componentStack), replay = logRecoverableError$2(request, error, childNodes, task.debugTask), encodeErrorForBoundary(props, replay, error, childNodes, !1), task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);
							} finally {
								task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath, task.formatContext = prevContext, task.row = prevRow;
							}
							props = createReplayTask$2(request, null, {
								nodes: keyOrIndex,
								slots: node,
								pendingTasks: 0
							}, fallback, -1, parentBoundary, props.fallbackState, fallbackAbortSet, [
								keyPath[0],
								"Suspense Fallback",
								keyPath[2]
							], getSuspenseFallbackFormatContext$2(request.resumableState, task.formatContext), task.context, task.treeContext, task.row, replaceSuspenseComponentStackWithSuspenseFallbackStack$2(task.componentStack), emptyContextObject$2, task.debugTask);
							pushComponentStack$2(props);
							request.pingedTasks.push(props);
						}
					}
					childIndex.splice(i, 1);
					break;
				}
			}
		}
		function validateIterable(task, iterable, childIndex, iterator, iteratorFn) {
			if (iterator === iterable) {
				if (-1 !== childIndex || null === task.componentStack || "function" !== typeof task.componentStack.type || "[object GeneratorFunction]" !== Object.prototype.toString.call(task.componentStack.type) || "[object Generator]" !== Object.prototype.toString.call(iterator)) didWarnAboutGenerators || console.error("Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."), didWarnAboutGenerators = !0;
			} else iterable.entries !== iteratorFn || didWarnAboutMaps || (console.error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0);
		}
		function renderNodeDestructive$2(request, task, node, childIndex) {
			null !== task.replay && "number" === typeof task.replay.slots ? resumeNode$2(request, task, task.replay.slots, node, childIndex) : (task.node = node, task.childIndex = childIndex, node = task.componentStack, childIndex = task.debugTask, pushComponentStack$2(task), retryNode$2(request, task), task.componentStack = node, task.debugTask = childIndex);
		}
		function retryNode$2(request, task) {
			var node = task.node, childIndex = task.childIndex;
			if (null !== node) {
				if ("object" === typeof node) {
					switch (node.$$typeof) {
						case REACT_ELEMENT_TYPE$2:
							var type = node.type, key = node.key;
							node = node.props;
							var refProp = node.ref;
							refProp = void 0 !== refProp ? refProp : null;
							var debugTask = task.debugTask, name = getComponentNameFromType$2(type);
							key = null == key ? -1 === childIndex ? 0 : childIndex : key;
							var keyPath = [
								task.keyPath,
								name,
								key
							];
							null !== task.replay ? debugTask ? debugTask.run(replayElement.bind(null, request, task, keyPath, name, key, childIndex, type, node, refProp, task.replay)) : replayElement(request, task, keyPath, name, key, childIndex, type, node, refProp, task.replay) : debugTask ? debugTask.run(renderElement$2.bind(null, request, task, keyPath, type, node, refProp)) : renderElement$2(request, task, keyPath, type, node, refProp);
							return;
						case REACT_PORTAL_TYPE$2: throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
						case REACT_LAZY_TYPE$2:
							type = callLazyInitInDEV(node);
							if (12 === request.status) throw null;
							renderNodeDestructive$2(request, task, type, childIndex);
							return;
					}
					if (isArrayImpl$2(node)) {
						renderChildrenArray$2(request, task, node, childIndex);
						return;
					}
					if (key = getIteratorFn$2(node)) {
						if (type = key.call(node)) {
							validateIterable(task, node, childIndex, type, key);
							node = type.next();
							if (!node.done) {
								key = [];
								do
									key.push(node.value), node = type.next();
								while (!node.done);
								renderChildrenArray$2(request, task, key, childIndex);
							}
							return;
						}
					}
					if ("function" === typeof node.then) return task.thenableState = null, renderNodeDestructive$2(request, task, unwrapThenable$2(node), childIndex);
					if (node.$$typeof === REACT_CONTEXT_TYPE$2) return renderNodeDestructive$2(request, task, node._currentValue2, childIndex);
					request = Object.prototype.toString.call(node);
					throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === request ? "object with keys {" + Object.keys(node).join(", ") + "}" : request) + "). If you meant to render a collection of children, use an array instead.");
				}
				"string" === typeof node ? (task = task.blockedSegment, null !== task && (task.lastPushedText = pushTextInstance$2(task.chunks, node, request.renderState, task.lastPushedText))) : "number" === typeof node || "bigint" === typeof node ? (task = task.blockedSegment, null !== task && (task.lastPushedText = pushTextInstance$2(task.chunks, "" + node, request.renderState, task.lastPushedText))) : ("function" === typeof node && (request = node.displayName || node.name || "Component", console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.", request, request)), "symbol" === typeof node && console.error("Symbols are not valid as a React child.\n  %s", String(node)));
			}
		}
		function warnForMissingKey(request, task, child) {
			if (null !== child && "object" === typeof child && (child.$$typeof === REACT_ELEMENT_TYPE$2 || child.$$typeof === REACT_PORTAL_TYPE$2) && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {
				if ("object" !== typeof child._store) throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
				child._store.validated = 1;
				var didWarnForKey = request.didWarnForKey;
				didWarnForKey ??= request.didWarnForKey = /* @__PURE__ */ new WeakSet();
				request = task.componentStack;
				if (null !== request && !didWarnForKey.has(request)) {
					didWarnForKey.add(request);
					var componentName = getComponentNameFromType$2(child.type);
					didWarnForKey = child._owner;
					var parentOwner = request.owner;
					request = "";
					if (parentOwner && "undefined" !== typeof parentOwner.type) {
						var name = getComponentNameFromType$2(parentOwner.type);
						name && (request = "\n\nCheck the render method of `" + name + "`.");
					}
					request || componentName && (request = "\n\nCheck the top-level render call using <" + componentName + ">.");
					componentName = "";
					null != didWarnForKey && parentOwner !== didWarnForKey && (parentOwner = null, "undefined" !== typeof didWarnForKey.type ? parentOwner = getComponentNameFromType$2(didWarnForKey.type) : "string" === typeof didWarnForKey.name && (parentOwner = didWarnForKey.name), parentOwner && (componentName = " It was passed a child from " + parentOwner + "."));
					didWarnForKey = task.componentStack;
					task.componentStack = {
						parent: task.componentStack,
						type: child.type,
						owner: child._owner,
						stack: child._debugStack
					};
					console.error("Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.", request, componentName);
					task.componentStack = didWarnForKey;
				}
			}
		}
		function renderChildrenArray$2(request, task, children, childIndex) {
			var prevKeyPath = task.keyPath, previousComponentStack = task.componentStack;
			var previousDebugTask = task.debugTask;
			pushServerComponentStack(task, task.node._debugInfo);
			if (-1 !== childIndex && (task.keyPath = [
				task.keyPath,
				"Fragment",
				childIndex
			], null !== task.replay)) {
				for (var replay = task.replay, replayNodes = replay.nodes, j = 0; j < replayNodes.length; j++) {
					var node = replayNodes[j];
					if (node[1] === childIndex) {
						childIndex = node[2];
						node = node[3];
						task.replay = {
							nodes: childIndex,
							slots: node,
							pendingTasks: 1
						};
						try {
							renderChildrenArray$2(request, task, children, -1);
							if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length) throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
							task.replay.pendingTasks--;
						} catch (x) {
							if ("object" === typeof x && null !== x && (x === SuspenseException$2 || "function" === typeof x.then)) throw x;
							task.replay.pendingTasks--;
							var thrownInfo = getThrownInfo$2(task.componentStack);
							children = task.blockedBoundary;
							var error = x, resumeSlots = node;
							node = logRecoverableError$2(request, error, thrownInfo, task.debugTask);
							abortRemainingReplayNodes$2(request, children, childIndex, resumeSlots, error, node, thrownInfo, !1);
						}
						task.replay = replay;
						replayNodes.splice(j, 1);
						break;
					}
				}
				task.keyPath = prevKeyPath;
				task.componentStack = previousComponentStack;
				task.debugTask = previousDebugTask;
				return;
			}
			replay = task.treeContext;
			replayNodes = children.length;
			if (null !== task.replay && (j = task.replay.slots, null !== j && "object" === typeof j)) {
				for (childIndex = 0; childIndex < replayNodes; childIndex++) node = children[childIndex], task.treeContext = pushTreeContext$2(replay, replayNodes, childIndex), error = j[childIndex], "number" === typeof error ? (resumeNode$2(request, task, error, node, childIndex), delete j[childIndex]) : renderNode$2(request, task, node, childIndex);
				task.treeContext = replay;
				task.keyPath = prevKeyPath;
				task.componentStack = previousComponentStack;
				task.debugTask = previousDebugTask;
				return;
			}
			for (j = 0; j < replayNodes; j++) childIndex = children[j], warnForMissingKey(request, task, childIndex), task.treeContext = pushTreeContext$2(replay, replayNodes, j), renderNode$2(request, task, childIndex, j);
			task.treeContext = replay;
			task.keyPath = prevKeyPath;
			task.componentStack = previousComponentStack;
			task.debugTask = previousDebugTask;
		}
		function trackPostponedBoundary$2(request, trackedPostpones, boundary) {
			boundary.status = POSTPONED;
			boundary.rootSegmentID = request.nextSegmentId++;
			request = boundary.trackedContentKeyPath;
			if (null === request) throw Error("It should not be possible to postpone at the root. This is a bug in React.");
			var fallbackReplayNode = boundary.trackedFallbackNode, children = [], boundaryNode = trackedPostpones.workingMap.get(request);
			if (void 0 === boundaryNode) return boundary = [
				request[1],
				request[2],
				children,
				null,
				fallbackReplayNode,
				boundary.rootSegmentID
			], trackedPostpones.workingMap.set(request, boundary), addToReplayParent$2(boundary, request[0], trackedPostpones), boundary;
			boundaryNode[4] = fallbackReplayNode;
			boundaryNode[5] = boundary.rootSegmentID;
			return boundaryNode;
		}
		function trackPostpone$2(request, trackedPostpones, task, segment) {
			segment.status = POSTPONED;
			var keyPath = task.keyPath, boundary = task.blockedBoundary;
			if (null === boundary) segment.id = request.nextSegmentId++, trackedPostpones.rootSlots = segment.id, null !== request.completedRootSegment && (request.completedRootSegment.status = POSTPONED);
			else {
				if (null !== boundary && boundary.status === PENDING) {
					var boundaryNode = trackPostponedBoundary$2(request, trackedPostpones, boundary);
					if (boundary.trackedContentKeyPath === keyPath && -1 === task.childIndex) {
						-1 === segment.id && (segment.id = segment.parentFlushed ? boundary.rootSegmentID : request.nextSegmentId++);
						boundaryNode[3] = segment.id;
						return;
					}
				}
				-1 === segment.id && (segment.id = segment.parentFlushed && null !== boundary ? boundary.rootSegmentID : request.nextSegmentId++);
				if (-1 === task.childIndex) null === keyPath ? trackedPostpones.rootSlots = segment.id : (task = trackedPostpones.workingMap.get(keyPath), void 0 === task ? (task = [
					keyPath[1],
					keyPath[2],
					[],
					segment.id
				], addToReplayParent$2(task, keyPath[0], trackedPostpones)) : task[3] = segment.id);
				else {
					if (null === keyPath) {
						if (request = trackedPostpones.rootSlots, null === request) request = trackedPostpones.rootSlots = {};
						else if ("number" === typeof request) throw Error("It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.");
					} else if (boundary = trackedPostpones.workingMap, boundaryNode = boundary.get(keyPath), void 0 === boundaryNode) request = {}, boundaryNode = [
						keyPath[1],
						keyPath[2],
						[],
						request
					], boundary.set(keyPath, boundaryNode), addToReplayParent$2(boundaryNode, keyPath[0], trackedPostpones);
					else if (request = boundaryNode[3], null === request) request = boundaryNode[3] = {};
					else if ("number" === typeof request) throw Error("It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.");
					request[task.childIndex] = segment.id;
				}
			}
		}
		function untrackBoundary$2(request, boundary) {
			request = request.trackedPostpones;
			null !== request && (boundary = boundary.trackedContentKeyPath, null !== boundary && (boundary = request.workingMap.get(boundary), void 0 !== boundary && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));
		}
		function spawnNewSuspendedReplayTask$2(request, task, thenableState$3) {
			return createReplayTask$2(request, thenableState$3, task.replay, task.node, task.childIndex, task.blockedBoundary, task.hoistableState, task.abortSet, task.keyPath, task.formatContext, task.context, task.treeContext, task.row, task.componentStack, emptyContextObject$2, task.debugTask);
		}
		function spawnNewSuspendedRenderTask$2(request, task, thenableState$3) {
			var segment = task.blockedSegment, newSegment = createPendingSegment$2(request, segment.chunks.length, null, task.formatContext, segment.lastPushedText, !0);
			segment.children.push(newSegment);
			segment.lastPushedText = !1;
			return createRenderTask$2(request, thenableState$3, task.node, task.childIndex, task.blockedBoundary, newSegment, task.blockedPreamble, task.hoistableState, task.abortSet, task.keyPath, task.formatContext, task.context, task.treeContext, task.row, task.componentStack, emptyContextObject$2, task.debugTask);
		}
		function renderNode$2(request, task, node, childIndex) {
			var previousFormatContext = task.formatContext, previousContext = task.context, previousKeyPath = task.keyPath, previousTreeContext = task.treeContext, previousComponentStack = task.componentStack, previousDebugTask = task.debugTask, segment = task.blockedSegment;
			if (null === segment) {
				segment = task.replay;
				try {
					return renderNodeDestructive$2(request, task, node, childIndex);
				} catch (thrownValue) {
					if (resetHooksState$2(), node = thrownValue === SuspenseException$2 ? getSuspendedThenable$2() : thrownValue, 12 !== request.status && "object" === typeof node && null !== node) {
						if ("function" === typeof node.then) {
							childIndex = thrownValue === SuspenseException$2 ? getThenableStateAfterSuspending$2() : null;
							request = spawnNewSuspendedReplayTask$2(request, task, childIndex).ping;
							node.then(request, request);
							task.formatContext = previousFormatContext;
							task.context = previousContext;
							task.keyPath = previousKeyPath;
							task.treeContext = previousTreeContext;
							task.componentStack = previousComponentStack;
							task.replay = segment;
							task.debugTask = previousDebugTask;
							switchContext$2(previousContext);
							return;
						}
						if ("Maximum call stack size exceeded" === node.message) {
							node = thrownValue === SuspenseException$2 ? getThenableStateAfterSuspending$2() : null;
							node = spawnNewSuspendedReplayTask$2(request, task, node);
							request.pingedTasks.push(node);
							task.formatContext = previousFormatContext;
							task.context = previousContext;
							task.keyPath = previousKeyPath;
							task.treeContext = previousTreeContext;
							task.componentStack = previousComponentStack;
							task.replay = segment;
							task.debugTask = previousDebugTask;
							switchContext$2(previousContext);
							return;
						}
					}
				}
			} else {
				var childrenLength = segment.children.length, chunkLength = segment.chunks.length;
				try {
					return renderNodeDestructive$2(request, task, node, childIndex);
				} catch (thrownValue$3) {
					if (resetHooksState$2(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node = thrownValue$3 === SuspenseException$2 ? getSuspendedThenable$2() : thrownValue$3, 12 !== request.status && "object" === typeof node && null !== node) {
						if ("function" === typeof node.then) {
							segment = node;
							node = thrownValue$3 === SuspenseException$2 ? getThenableStateAfterSuspending$2() : null;
							request = spawnNewSuspendedRenderTask$2(request, task, node).ping;
							segment.then(request, request);
							task.formatContext = previousFormatContext;
							task.context = previousContext;
							task.keyPath = previousKeyPath;
							task.treeContext = previousTreeContext;
							task.componentStack = previousComponentStack;
							task.debugTask = previousDebugTask;
							switchContext$2(previousContext);
							return;
						}
						if ("Maximum call stack size exceeded" === node.message) {
							segment = thrownValue$3 === SuspenseException$2 ? getThenableStateAfterSuspending$2() : null;
							segment = spawnNewSuspendedRenderTask$2(request, task, segment);
							request.pingedTasks.push(segment);
							task.formatContext = previousFormatContext;
							task.context = previousContext;
							task.keyPath = previousKeyPath;
							task.treeContext = previousTreeContext;
							task.componentStack = previousComponentStack;
							task.debugTask = previousDebugTask;
							switchContext$2(previousContext);
							return;
						}
					}
				}
			}
			task.formatContext = previousFormatContext;
			task.context = previousContext;
			task.keyPath = previousKeyPath;
			task.treeContext = previousTreeContext;
			switchContext$2(previousContext);
			throw node;
		}
		function abortTaskSoft$2(task) {
			var boundary = task.blockedBoundary, segment = task.blockedSegment;
			null !== segment && (segment.status = ABORTED, finishedTask$2(this, boundary, task.row, segment));
		}
		function abortRemainingReplayNodes$2(request$jscomp$0, boundary, nodes, slots, error$jscomp$0, errorDigest$jscomp$0, errorInfo$jscomp$0, aborted) {
			for (var i = 0; i < nodes.length; i++) {
				var node = nodes[i];
				if (4 === node.length) abortRemainingReplayNodes$2(request$jscomp$0, boundary, node[2], node[3], error$jscomp$0, errorDigest$jscomp$0, errorInfo$jscomp$0, aborted);
				else {
					var request = request$jscomp$0;
					node = node[5];
					var error = error$jscomp$0, errorDigest = errorDigest$jscomp$0, errorInfo = errorInfo$jscomp$0, wasAborted = aborted, resumedBoundary = createSuspenseBoundary$2(request, null, /* @__PURE__ */ new Set(), null, null);
					resumedBoundary.parentFlushed = !0;
					resumedBoundary.rootSegmentID = node;
					resumedBoundary.status = CLIENT_RENDERED;
					encodeErrorForBoundary(resumedBoundary, errorDigest, error, errorInfo, wasAborted);
					resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);
				}
			}
			nodes.length = 0;
			if (null !== slots) {
				if (null === boundary) throw Error("We should not have any resumable nodes in the shell. This is a bug in React.");
				boundary.status !== CLIENT_RENDERED && (boundary.status = CLIENT_RENDERED, encodeErrorForBoundary(boundary, errorDigest$jscomp$0, error$jscomp$0, errorInfo$jscomp$0, aborted), boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));
				if ("object" === typeof slots) for (var index in slots) delete slots[index];
			}
		}
		function abortTask$2(task, request, error) {
			var boundary = task.blockedBoundary, segment = task.blockedSegment;
			if (null !== segment) {
				if (6 === segment.status) return;
				segment.status = ABORTED;
			}
			var errorInfo = getThrownInfo$2(task.componentStack), node = task.node;
			null !== node && "object" === typeof node && pushHaltedAwaitOnComponentStack(task, node._debugInfo);
			if (null === boundary) {
				if (13 !== request.status && request.status !== CLOSED) {
					boundary = task.replay;
					if (null === boundary) {
						null !== request.trackedPostpones && null !== segment ? (boundary = request.trackedPostpones, logRecoverableError$2(request, error, errorInfo, task.debugTask), trackPostpone$2(request, boundary, task, segment), finishedTask$2(request, null, task.row, segment)) : (logRecoverableError$2(request, error, errorInfo, task.debugTask), fatalError$2(request, error, errorInfo, task.debugTask));
						return;
					}
					boundary.pendingTasks--;
					0 === boundary.pendingTasks && 0 < boundary.nodes.length && (segment = logRecoverableError$2(request, error, errorInfo, null), abortRemainingReplayNodes$2(request, null, boundary.nodes, boundary.slots, error, segment, errorInfo, !0));
					request.pendingRootTasks--;
					0 === request.pendingRootTasks && completeShell$2(request);
				}
			} else {
				node = request.trackedPostpones;
				if (boundary.status !== CLIENT_RENDERED) {
					if (null !== node && null !== segment) return logRecoverableError$2(request, error, errorInfo, task.debugTask), trackPostpone$2(request, node, task, segment), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
						return abortTask$2(fallbackTask, request, error);
					}), boundary.fallbackAbortableTasks.clear(), finishedTask$2(request, boundary, task.row, segment);
					boundary.status = CLIENT_RENDERED;
					segment = logRecoverableError$2(request, error, errorInfo, task.debugTask);
					boundary.status = CLIENT_RENDERED;
					encodeErrorForBoundary(boundary, segment, error, errorInfo, !0);
					untrackBoundary$2(request, boundary);
					boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);
				}
				boundary.pendingTasks--;
				errorInfo = boundary.row;
				null !== errorInfo && 0 === --errorInfo.pendingTasks && finishSuspenseListRow$2(request, errorInfo);
				boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
					return abortTask$2(fallbackTask, request, error);
				});
				boundary.fallbackAbortableTasks.clear();
			}
			task = task.row;
			null !== task && 0 === --task.pendingTasks && finishSuspenseListRow$2(request, task);
			request.allPendingTasks--;
			0 === request.allPendingTasks && completeAll$2(request);
		}
		function safelyEmitEarlyPreloads$2(request, shellComplete) {
			try {
				var renderState = request.renderState, onHeaders = renderState.onHeaders;
				if (onHeaders) {
					var headers = renderState.headers;
					if (headers) {
						renderState.headers = null;
						var linkHeader = headers.preconnects;
						headers.fontPreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.fontPreloads);
						headers.highImagePreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.highImagePreloads);
						if (!shellComplete) {
							var queueIter = renderState.styles.values(), queueStep = queueIter.next();
							b: for (; 0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next()) for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next(); 0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {
								var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props;
								var header = getPreloadAsHeader$2(props$jscomp$0.href, "style", {
									crossOrigin: props$jscomp$0.crossOrigin,
									integrity: props$jscomp$0.integrity,
									nonce: props$jscomp$0.nonce,
									type: props$jscomp$0.type,
									fetchPriority: props$jscomp$0.fetchPriority,
									referrerPolicy: props$jscomp$0.referrerPolicy,
									media: props$jscomp$0.media
								});
								if (0 <= (headers.remainingCapacity -= header.length + 2)) renderState.resets.style[key] = PRELOAD_NO_CREDS$2, linkHeader && (linkHeader += ", "), linkHeader += header, renderState.resets.style[key] = "string" === typeof props.crossOrigin || "string" === typeof props.integrity ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS$2;
								else break b;
							}
						}
						linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});
					}
				}
			} catch (error) {
				logRecoverableError$2(request, error, {}, null);
			}
		}
		function completeShell$2(request) {
			null === request.trackedPostpones && safelyEmitEarlyPreloads$2(request, !0);
			null === request.trackedPostpones && preparePreamble$2(request);
			request.onShellError = noop$2;
			request = request.onShellReady;
			request();
		}
		function completeAll$2(request) {
			safelyEmitEarlyPreloads$2(request, null === request.trackedPostpones ? !0 : null === request.completedRootSegment || request.completedRootSegment.status !== POSTPONED);
			preparePreamble$2(request);
			request = request.onAllReady;
			request();
		}
		function queueCompletedSegment$2(boundary, segment) {
			if (0 === segment.chunks.length && 1 === segment.children.length && null === segment.children[0].boundary && -1 === segment.children[0].id) {
				var childSegment = segment.children[0];
				childSegment.id = segment.id;
				childSegment.parentFlushed = !0;
				childSegment.status !== COMPLETED && childSegment.status !== ABORTED && childSegment.status !== ERRORED || queueCompletedSegment$2(boundary, childSegment);
			} else boundary.completedSegments.push(segment);
		}
		function finishedTask$2(request, boundary, row, segment) {
			null !== row && (0 === --row.pendingTasks ? finishSuspenseListRow$2(request, row) : row.together && tryToResolveTogetherRow$2(request, row));
			request.allPendingTasks--;
			if (null === boundary) {
				if (null !== segment && segment.parentFlushed) {
					if (null !== request.completedRootSegment) throw Error("There can only be one root segment. This is a bug in React.");
					request.completedRootSegment = segment;
				}
				request.pendingRootTasks--;
				0 === request.pendingRootTasks && completeShell$2(request);
			} else if (boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED) if (0 === boundary.pendingTasks) {
				if (boundary.status === PENDING && (boundary.status = COMPLETED), null !== segment && segment.parentFlushed && (segment.status === COMPLETED || segment.status === ABORTED) && queueCompletedSegment$2(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), boundary.status === COMPLETED) row = boundary.row, null !== row && hoistHoistables$2(row.hoistables, boundary.contentState), isEligibleForOutlining$2(request, boundary) || (boundary.fallbackAbortableTasks.forEach(abortTaskSoft$2, request), boundary.fallbackAbortableTasks.clear(), null !== row && 0 === --row.pendingTasks && finishSuspenseListRow$2(request, row)), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary.contentPreamble && preparePreamble$2(request);
				else if (boundary.status === POSTPONED && (boundary = boundary.row, null !== boundary)) {
					if (null !== request.trackedPostpones) {
						row = request.trackedPostpones;
						var postponedRow = boundary.next;
						if (null !== postponedRow && (segment = postponedRow.boundaries, null !== segment)) for (postponedRow.boundaries = null, postponedRow = 0; postponedRow < segment.length; postponedRow++) {
							var postponedBoundary = segment[postponedRow];
							trackPostponedBoundary$2(request, row, postponedBoundary);
							finishedTask$2(request, postponedBoundary, null, null);
						}
					}
					0 === --boundary.pendingTasks && finishSuspenseListRow$2(request, boundary);
				}
			} else null === segment || !segment.parentFlushed || segment.status !== COMPLETED && segment.status !== ABORTED || (queueCompletedSegment$2(boundary, segment), 1 === boundary.completedSegments.length && boundary.parentFlushed && request.partialBoundaries.push(boundary)), boundary = boundary.row, null !== boundary && boundary.together && tryToResolveTogetherRow$2(request, boundary);
			0 === request.allPendingTasks && completeAll$2(request);
		}
		function performWork$2(request$jscomp$2) {
			if (request$jscomp$2.status !== CLOSED && 13 !== request$jscomp$2.status) {
				var prevContext = currentActiveSnapshot$2, prevDispatcher = ReactSharedInternals$2.H;
				ReactSharedInternals$2.H = HooksDispatcher$2;
				var prevAsyncDispatcher = ReactSharedInternals$2.A;
				ReactSharedInternals$2.A = DefaultAsyncDispatcher$2;
				var prevRequest = currentRequest$2;
				currentRequest$2 = request$jscomp$2;
				var prevGetCurrentStackImpl = ReactSharedInternals$2.getCurrentStack;
				ReactSharedInternals$2.getCurrentStack = getCurrentStackInDEV;
				var prevResumableState = currentResumableState$2;
				currentResumableState$2 = request$jscomp$2.resumableState;
				try {
					var pingedTasks = request$jscomp$2.pingedTasks, i;
					for (i = 0; i < pingedTasks.length; i++) {
						var request = request$jscomp$2, task = pingedTasks[i], segment = task.blockedSegment;
						if (null === segment) {
							var prevTaskInDEV = void 0, request$jscomp$0 = request;
							request = task;
							if (0 !== request.replay.pendingTasks) {
								switchContext$2(request.context);
								prevTaskInDEV = currentTaskInDEV;
								currentTaskInDEV = request;
								try {
									"number" === typeof request.replay.slots ? resumeNode$2(request$jscomp$0, request, request.replay.slots, request.node, request.childIndex) : retryNode$2(request$jscomp$0, request);
									if (1 === request.replay.pendingTasks && 0 < request.replay.nodes.length) throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
									request.replay.pendingTasks--;
									request.abortSet.delete(request);
									finishedTask$2(request$jscomp$0, request.blockedBoundary, request.row, null);
								} catch (thrownValue) {
									resetHooksState$2();
									var x = thrownValue === SuspenseException$2 ? getSuspendedThenable$2() : thrownValue;
									if ("object" === typeof x && null !== x && "function" === typeof x.then) {
										var ping = request.ping;
										x.then(ping, ping);
										request.thenableState = thrownValue === SuspenseException$2 ? getThenableStateAfterSuspending$2() : null;
									} else {
										request.replay.pendingTasks--;
										request.abortSet.delete(request);
										var errorInfo = getThrownInfo$2(request.componentStack), errorDigest = void 0, request$jscomp$1 = request$jscomp$0, boundary = request.blockedBoundary, error$jscomp$0 = 12 === request$jscomp$0.status ? request$jscomp$0.fatalError : x, errorInfo$jscomp$0 = errorInfo, replayNodes = request.replay.nodes, resumeSlots = request.replay.slots;
										errorDigest = logRecoverableError$2(request$jscomp$1, error$jscomp$0, errorInfo$jscomp$0, request.debugTask);
										abortRemainingReplayNodes$2(request$jscomp$1, boundary, replayNodes, resumeSlots, error$jscomp$0, errorDigest, errorInfo$jscomp$0, !1);
										request$jscomp$0.pendingRootTasks--;
										0 === request$jscomp$0.pendingRootTasks && completeShell$2(request$jscomp$0);
										request$jscomp$0.allPendingTasks--;
										0 === request$jscomp$0.allPendingTasks && completeAll$2(request$jscomp$0);
									}
								} finally {
									currentTaskInDEV = prevTaskInDEV;
								}
							}
						} else if (request$jscomp$0 = prevTaskInDEV = void 0, errorDigest = task, request$jscomp$1 = segment, request$jscomp$1.status === PENDING) {
							request$jscomp$1.status = 6;
							switchContext$2(errorDigest.context);
							request$jscomp$0 = currentTaskInDEV;
							currentTaskInDEV = errorDigest;
							var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;
							try {
								retryNode$2(request, errorDigest), pushSegmentFinale$1(request$jscomp$1.chunks, request.renderState, request$jscomp$1.lastPushedText, request$jscomp$1.textEmbedded), errorDigest.abortSet.delete(errorDigest), request$jscomp$1.status = COMPLETED, finishedTask$2(request, errorDigest.blockedBoundary, errorDigest.row, request$jscomp$1);
							} catch (thrownValue) {
								resetHooksState$2();
								request$jscomp$1.children.length = childrenLength;
								request$jscomp$1.chunks.length = chunkLength;
								var x$jscomp$0 = thrownValue === SuspenseException$2 ? getSuspendedThenable$2() : 12 === request.status ? request.fatalError : thrownValue;
								if (12 === request.status && null !== request.trackedPostpones) {
									var trackedPostpones = request.trackedPostpones, thrownInfo = getThrownInfo$2(errorDigest.componentStack);
									errorDigest.abortSet.delete(errorDigest);
									logRecoverableError$2(request, x$jscomp$0, thrownInfo, errorDigest.debugTask);
									trackPostpone$2(request, trackedPostpones, errorDigest, request$jscomp$1);
									finishedTask$2(request, errorDigest.blockedBoundary, errorDigest.row, request$jscomp$1);
								} else if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0 && "function" === typeof x$jscomp$0.then) {
									request$jscomp$1.status = PENDING;
									errorDigest.thenableState = thrownValue === SuspenseException$2 ? getThenableStateAfterSuspending$2() : null;
									var ping$jscomp$0 = errorDigest.ping;
									x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
								} else {
									var errorInfo$jscomp$1 = getThrownInfo$2(errorDigest.componentStack);
									errorDigest.abortSet.delete(errorDigest);
									request$jscomp$1.status = ERRORED;
									var boundary$jscomp$0 = errorDigest.blockedBoundary, row = errorDigest.row, debugTask = errorDigest.debugTask;
									null !== row && 0 === --row.pendingTasks && finishSuspenseListRow$2(request, row);
									request.allPendingTasks--;
									prevTaskInDEV = logRecoverableError$2(request, x$jscomp$0, errorInfo$jscomp$1, debugTask);
									if (null === boundary$jscomp$0) fatalError$2(request, x$jscomp$0, errorInfo$jscomp$1, debugTask);
									else if (boundary$jscomp$0.pendingTasks--, boundary$jscomp$0.status !== CLIENT_RENDERED) {
										boundary$jscomp$0.status = CLIENT_RENDERED;
										encodeErrorForBoundary(boundary$jscomp$0, prevTaskInDEV, x$jscomp$0, errorInfo$jscomp$1, !1);
										untrackBoundary$2(request, boundary$jscomp$0);
										var boundaryRow = boundary$jscomp$0.row;
										null !== boundaryRow && 0 === --boundaryRow.pendingTasks && finishSuspenseListRow$2(request, boundaryRow);
										boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(boundary$jscomp$0);
										0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary$jscomp$0.contentPreamble && preparePreamble$2(request);
									}
									0 === request.allPendingTasks && completeAll$2(request);
								}
							} finally {
								currentTaskInDEV = request$jscomp$0;
							}
						}
					}
					pingedTasks.splice(0, i);
					null !== request$jscomp$2.destination && flushCompletedQueues$2(request$jscomp$2, request$jscomp$2.destination);
				} catch (error) {
					pingedTasks = {}, logRecoverableError$2(request$jscomp$2, error, pingedTasks, null), fatalError$2(request$jscomp$2, error, pingedTasks, null);
				} finally {
					currentResumableState$2 = prevResumableState, ReactSharedInternals$2.H = prevDispatcher, ReactSharedInternals$2.A = prevAsyncDispatcher, ReactSharedInternals$2.getCurrentStack = prevGetCurrentStackImpl, prevDispatcher === HooksDispatcher$2 && switchContext$2(prevContext), currentRequest$2 = prevRequest;
				}
			}
		}
		function preparePreambleFromSubtree$2(request, segment, collectedPreambleSegments) {
			segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);
			for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++) pendingPreambles = preparePreambleFromSegment$2(request, segment.children[i], collectedPreambleSegments) || pendingPreambles;
			return pendingPreambles;
		}
		function preparePreambleFromSegment$2(request, segment, collectedPreambleSegments) {
			var boundary = segment.boundary;
			if (null === boundary) return preparePreambleFromSubtree$2(request, segment, collectedPreambleSegments);
			var preamble = boundary.contentPreamble, fallbackPreamble = boundary.fallbackPreamble;
			if (null === preamble || null === fallbackPreamble) return !1;
			switch (boundary.status) {
				case COMPLETED:
					hoistPreambleState$2(request.renderState, preamble);
					request.byteSize += boundary.byteSize;
					segment = boundary.completedSegments[0];
					if (!segment) throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
					return preparePreambleFromSubtree$2(request, segment, collectedPreambleSegments);
				case POSTPONED: if (null !== request.trackedPostpones) return !0;
				case CLIENT_RENDERED: if (segment.status === COMPLETED) return hoistPreambleState$2(request.renderState, fallbackPreamble), preparePreambleFromSubtree$2(request, segment, collectedPreambleSegments);
				default: return !0;
			}
		}
		function preparePreamble$2(request) {
			if (request.completedRootSegment && null === request.completedPreambleSegments) {
				var collectedPreambleSegments = [], originalRequestByteSize = request.byteSize, hasPendingPreambles = preparePreambleFromSegment$2(request, request.completedRootSegment, collectedPreambleSegments), preamble = request.renderState.preamble;
				!1 === hasPendingPreambles || preamble.headChunks && preamble.bodyChunks ? request.completedPreambleSegments = collectedPreambleSegments : request.byteSize = originalRequestByteSize;
			}
		}
		function flushSubtree$2(request, destination, segment, hoistableState) {
			segment.parentFlushed = !0;
			switch (segment.status) {
				case PENDING: segment.id = request.nextSegmentId++;
				case POSTPONED: return hoistableState = segment.id, segment.lastPushedText = !1, segment.textEmbedded = !1, request = request.renderState, destination.push(placeholder1$1), destination.push(request.placeholderPrefix), request = hoistableState.toString(16), destination.push(request), destination.push(placeholder2$1);
				case COMPLETED:
					segment.status = FLUSHED;
					var r = !0, chunks = segment.chunks, chunkIdx = 0;
					segment = segment.children;
					for (var childIdx = 0; childIdx < segment.length; childIdx++) {
						for (r = segment[childIdx]; chunkIdx < r.index; chunkIdx++) destination.push(chunks[chunkIdx]);
						r = flushSegment$2(request, destination, r, hoistableState);
					}
					for (; chunkIdx < chunks.length - 1; chunkIdx++) destination.push(chunks[chunkIdx]);
					chunkIdx < chunks.length && (r = destination.push(chunks[chunkIdx]));
					return r;
				case ABORTED: return !0;
				default: throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
			}
		}
		function flushSegment$2(request, destination, segment, hoistableState) {
			var boundary = segment.boundary;
			if (null === boundary) return flushSubtree$2(request, destination, segment, hoistableState);
			boundary.parentFlushed = !0;
			if (boundary.status === CLIENT_RENDERED) {
				var row = boundary.row;
				null !== row && 0 === --row.pendingTasks && finishSuspenseListRow$2(request, row);
				if (!request.renderState.generateStaticMarkup) {
					var errorDigest = boundary.errorDigest, errorMessage = boundary.errorMessage;
					row = boundary.errorStack;
					boundary = boundary.errorComponentStack;
					destination.push(startClientRenderedSuspenseBoundary$1);
					destination.push(clientRenderedSuspenseBoundaryError1$1);
					errorDigest && (destination.push(clientRenderedSuspenseBoundaryError1A$1), errorDigest = escapeTextForBrowser$2(errorDigest), destination.push(errorDigest), destination.push(clientRenderedSuspenseBoundaryErrorAttrInterstitial$1));
					errorMessage && (destination.push(clientRenderedSuspenseBoundaryError1B), errorMessage = escapeTextForBrowser$2(errorMessage), destination.push(errorMessage), destination.push(clientRenderedSuspenseBoundaryErrorAttrInterstitial$1));
					row && (destination.push(clientRenderedSuspenseBoundaryError1C), row = escapeTextForBrowser$2(row), destination.push(row), destination.push(clientRenderedSuspenseBoundaryErrorAttrInterstitial$1));
					boundary && (destination.push(clientRenderedSuspenseBoundaryError1D), row = escapeTextForBrowser$2(boundary), destination.push(row), destination.push(clientRenderedSuspenseBoundaryErrorAttrInterstitial$1));
					destination.push(clientRenderedSuspenseBoundaryError2$1);
				}
				flushSubtree$2(request, destination, segment, hoistableState);
				request = request.renderState.generateStaticMarkup ? !0 : destination.push(endSuspenseBoundary$1);
				return request;
			}
			if (boundary.status !== COMPLETED) return boundary.status === PENDING && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary$2(destination, request.renderState, boundary.rootSegmentID), hoistableState && hoistHoistables$2(hoistableState, boundary.fallbackState), flushSubtree$2(request, destination, segment, hoistableState), destination.push(endSuspenseBoundary$1);
			if (!flushingPartialBoundaries$2 && isEligibleForOutlining$2(request, boundary) && flushedByteSize$2 + boundary.byteSize > request.progressiveChunkSize) return boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary$2(destination, request.renderState, boundary.rootSegmentID), flushSubtree$2(request, destination, segment, hoistableState), destination.push(endSuspenseBoundary$1);
			flushedByteSize$2 += boundary.byteSize;
			hoistableState && hoistHoistables$2(hoistableState, boundary.contentState);
			segment = boundary.row;
			null !== segment && isEligibleForOutlining$2(request, boundary) && 0 === --segment.pendingTasks && finishSuspenseListRow$2(request, segment);
			request.renderState.generateStaticMarkup || destination.push(startCompletedSuspenseBoundary$1);
			segment = boundary.completedSegments;
			if (1 !== segment.length) throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
			flushSegment$2(request, destination, segment[0], hoistableState);
			request = request.renderState.generateStaticMarkup ? !0 : destination.push(endSuspenseBoundary$1);
			return request;
		}
		function flushSegmentContainer$2(request, destination, segment, hoistableState) {
			writeStartSegment$2(destination, request.renderState, segment.parentFormatContext, segment.id);
			flushSegment$2(request, destination, segment, hoistableState);
			return writeEndSegment$2(destination, segment.parentFormatContext);
		}
		function flushCompletedBoundary$2(request, destination, boundary) {
			flushedByteSize$2 = boundary.byteSize;
			for (var completedSegments = boundary.completedSegments, i = 0; i < completedSegments.length; i++) flushPartiallyCompletedSegment$2(request, destination, boundary, completedSegments[i]);
			completedSegments.length = 0;
			completedSegments = boundary.row;
			null !== completedSegments && isEligibleForOutlining$2(request, boundary) && 0 === --completedSegments.pendingTasks && finishSuspenseListRow$2(request, completedSegments);
			writeHoistablesForBoundary$2(destination, boundary.contentState, request.renderState);
			completedSegments = request.resumableState;
			request = request.renderState;
			i = boundary.rootSegmentID;
			boundary = boundary.contentState;
			var requiresStyleInsertion = request.stylesToHoist;
			request.stylesToHoist = !1;
			destination.push(request.startInlineScript);
			destination.push(endOfStartTag$1);
			requiresStyleInsertion ? ((completedSegments.instructions & SentClientRenderFunction) === NothingSent && (completedSegments.instructions |= SentClientRenderFunction, destination.push(clientRenderScriptFunctionOnly$1)), (completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent && (completedSegments.instructions |= SentCompleteBoundaryFunction, destination.push(completeBoundaryScriptFunctionOnly$1)), (completedSegments.instructions & SentStyleInsertionFunction) === NothingSent ? (completedSegments.instructions |= SentStyleInsertionFunction, destination.push(completeBoundaryWithStylesScript1FullPartial$1)) : destination.push(completeBoundaryWithStylesScript1Partial$1)) : ((completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent && (completedSegments.instructions |= SentCompleteBoundaryFunction, destination.push(completeBoundaryScriptFunctionOnly$1)), destination.push(completeBoundaryScript1Partial$1));
			completedSegments = i.toString(16);
			destination.push(request.boundaryPrefix);
			destination.push(completedSegments);
			destination.push(completeBoundaryScript2$1);
			destination.push(request.segmentPrefix);
			destination.push(completedSegments);
			requiresStyleInsertion ? (destination.push(completeBoundaryScript3a$1), writeStyleResourceDependenciesInJS$2(destination, boundary)) : destination.push(completeBoundaryScript3b$1);
			boundary = destination.push(completeBoundaryScriptEnd$1);
			return writeBootstrap$2(destination, request) && boundary;
		}
		function flushPartiallyCompletedSegment$2(request, destination, boundary, segment) {
			if (segment.status === FLUSHED) return !0;
			var hoistableState = boundary.contentState, segmentID = segment.id;
			if (-1 === segmentID) {
				if (-1 === (segment.id = boundary.rootSegmentID)) throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
				return flushSegmentContainer$2(request, destination, segment, hoistableState);
			}
			if (segmentID === boundary.rootSegmentID) return flushSegmentContainer$2(request, destination, segment, hoistableState);
			flushSegmentContainer$2(request, destination, segment, hoistableState);
			boundary = request.resumableState;
			request = request.renderState;
			destination.push(request.startInlineScript);
			destination.push(endOfStartTag$1);
			(boundary.instructions & SentCompleteSegmentFunction) === NothingSent ? (boundary.instructions |= SentCompleteSegmentFunction, destination.push(completeSegmentScript1Full$1)) : destination.push(completeSegmentScript1Partial$1);
			destination.push(request.segmentPrefix);
			segmentID = segmentID.toString(16);
			destination.push(segmentID);
			destination.push(completeSegmentScript2$1);
			destination.push(request.placeholderPrefix);
			destination.push(segmentID);
			destination = destination.push(completeSegmentScriptEnd$1);
			return destination;
		}
		function flushCompletedQueues$2(request, destination) {
			try {
				if (!(0 < request.pendingRootTasks)) {
					var i, completedRootSegment = request.completedRootSegment;
					if (null !== completedRootSegment) {
						if (completedRootSegment.status === POSTPONED) return;
						var completedPreambleSegments = request.completedPreambleSegments;
						if (null === completedPreambleSegments) return;
						flushedByteSize$2 = request.byteSize;
						var resumableState = request.resumableState, renderState = request.renderState, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;
						if (htmlChunks) {
							for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++) destination.push(htmlChunks[i$jscomp$0]);
							if (headChunks) for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++) destination.push(headChunks[i$jscomp$0]);
							else {
								var chunk = startChunkForTag$2("head");
								destination.push(chunk);
								destination.push(endOfStartTag$1);
							}
						} else if (headChunks) for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++) destination.push(headChunks[i$jscomp$0]);
						var charsetChunks = renderState.charsetChunks;
						for (i$jscomp$0 = 0; i$jscomp$0 < charsetChunks.length; i$jscomp$0++) destination.push(charsetChunks[i$jscomp$0]);
						charsetChunks.length = 0;
						renderState.preconnects.forEach(flushResource$2, destination);
						renderState.preconnects.clear();
						var viewportChunks = renderState.viewportChunks;
						for (i$jscomp$0 = 0; i$jscomp$0 < viewportChunks.length; i$jscomp$0++) destination.push(viewportChunks[i$jscomp$0]);
						viewportChunks.length = 0;
						renderState.fontPreloads.forEach(flushResource$2, destination);
						renderState.fontPreloads.clear();
						renderState.highImagePreloads.forEach(flushResource$2, destination);
						renderState.highImagePreloads.clear();
						currentlyFlushingRenderState$2 = renderState;
						renderState.styles.forEach(flushStylesInPreamble$2, destination);
						currentlyFlushingRenderState$2 = null;
						var importMapChunks = renderState.importMapChunks;
						for (i$jscomp$0 = 0; i$jscomp$0 < importMapChunks.length; i$jscomp$0++) destination.push(importMapChunks[i$jscomp$0]);
						importMapChunks.length = 0;
						renderState.bootstrapScripts.forEach(flushResource$2, destination);
						renderState.scripts.forEach(flushResource$2, destination);
						renderState.scripts.clear();
						renderState.bulkPreloads.forEach(flushResource$2, destination);
						renderState.bulkPreloads.clear();
						resumableState.instructions |= SentCompletedShellId;
						var hoistableChunks = renderState.hoistableChunks;
						for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++) destination.push(hoistableChunks[i$jscomp$0]);
						for (resumableState = hoistableChunks.length = 0; resumableState < completedPreambleSegments.length; resumableState++) {
							var segments = completedPreambleSegments[resumableState];
							for (renderState = 0; renderState < segments.length; renderState++) flushSegment$2(request, destination, segments[renderState], null);
						}
						var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
						if (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) {
							var chunk$jscomp$0 = endChunkForTag$2("head");
							destination.push(chunk$jscomp$0);
						}
						var bodyChunks = preamble$jscomp$0.bodyChunks;
						if (bodyChunks) for (completedPreambleSegments = 0; completedPreambleSegments < bodyChunks.length; completedPreambleSegments++) destination.push(bodyChunks[completedPreambleSegments]);
						flushSegment$2(request, destination, completedRootSegment, null);
						request.completedRootSegment = null;
						var renderState$jscomp$0 = request.renderState;
						if (0 !== request.allPendingTasks || 0 !== request.clientRenderedBoundaries.length || 0 !== request.completedBoundaries.length || null !== request.trackedPostpones && (0 !== request.trackedPostpones.rootNodes.length || null !== request.trackedPostpones.rootSlots)) {
							var resumableState$jscomp$0 = request.resumableState;
							if ((resumableState$jscomp$0.instructions & SentMarkShellTime) === NothingSent) {
								resumableState$jscomp$0.instructions |= SentMarkShellTime;
								destination.push(renderState$jscomp$0.startInlineScript);
								if ((resumableState$jscomp$0.instructions & SentCompletedShellId) === NothingSent) {
									resumableState$jscomp$0.instructions |= SentCompletedShellId;
									var shellId = "_" + resumableState$jscomp$0.idPrefix + "R_";
									destination.push(completedShellIdAttributeStart$1);
									var chunk$jscomp$1 = escapeTextForBrowser$2(shellId);
									destination.push(chunk$jscomp$1);
									destination.push(attributeEnd$1);
								}
								destination.push(endOfStartTag$1);
								destination.push(shellTimeRuntimeScript$1);
								destination.push(endInlineScript$1);
							}
						}
						writeBootstrap$2(destination, renderState$jscomp$0);
					}
					var renderState$jscomp$1 = request.renderState;
					completedRootSegment = 0;
					var viewportChunks$jscomp$0 = renderState$jscomp$1.viewportChunks;
					for (completedRootSegment = 0; completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++) destination.push(viewportChunks$jscomp$0[completedRootSegment]);
					viewportChunks$jscomp$0.length = 0;
					renderState$jscomp$1.preconnects.forEach(flushResource$2, destination);
					renderState$jscomp$1.preconnects.clear();
					renderState$jscomp$1.fontPreloads.forEach(flushResource$2, destination);
					renderState$jscomp$1.fontPreloads.clear();
					renderState$jscomp$1.highImagePreloads.forEach(flushResource$2, destination);
					renderState$jscomp$1.highImagePreloads.clear();
					renderState$jscomp$1.styles.forEach(preloadLateStyles$2, destination);
					renderState$jscomp$1.scripts.forEach(flushResource$2, destination);
					renderState$jscomp$1.scripts.clear();
					renderState$jscomp$1.bulkPreloads.forEach(flushResource$2, destination);
					renderState$jscomp$1.bulkPreloads.clear();
					var hoistableChunks$jscomp$0 = renderState$jscomp$1.hoistableChunks;
					for (completedRootSegment = 0; completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++) destination.push(hoistableChunks$jscomp$0[completedRootSegment]);
					hoistableChunks$jscomp$0.length = 0;
					var clientRenderedBoundaries = request.clientRenderedBoundaries;
					for (i = 0; i < clientRenderedBoundaries.length; i++) {
						var boundary = clientRenderedBoundaries[i];
						renderState$jscomp$1 = destination;
						var resumableState$jscomp$1 = request.resumableState, renderState$jscomp$2 = request.renderState, id = boundary.rootSegmentID, errorDigest = boundary.errorDigest, errorMessage = boundary.errorMessage, errorStack = boundary.errorStack, errorComponentStack = boundary.errorComponentStack;
						renderState$jscomp$1.push(renderState$jscomp$2.startInlineScript);
						renderState$jscomp$1.push(endOfStartTag$1);
						(resumableState$jscomp$1.instructions & SentClientRenderFunction) === NothingSent ? (resumableState$jscomp$1.instructions |= SentClientRenderFunction, renderState$jscomp$1.push(clientRenderScript1Full$1)) : renderState$jscomp$1.push(clientRenderScript1Partial$1);
						renderState$jscomp$1.push(renderState$jscomp$2.boundaryPrefix);
						var chunk$jscomp$2 = id.toString(16);
						renderState$jscomp$1.push(chunk$jscomp$2);
						renderState$jscomp$1.push(clientRenderScript1A$1);
						if (errorDigest || errorMessage || errorStack || errorComponentStack) {
							renderState$jscomp$1.push(clientRenderErrorScriptArgInterstitial$1);
							var chunk$jscomp$3 = escapeJSStringsForInstructionScripts$2(errorDigest || "");
							renderState$jscomp$1.push(chunk$jscomp$3);
						}
						if (errorMessage || errorStack || errorComponentStack) {
							renderState$jscomp$1.push(clientRenderErrorScriptArgInterstitial$1);
							var chunk$jscomp$4 = escapeJSStringsForInstructionScripts$2(errorMessage || "");
							renderState$jscomp$1.push(chunk$jscomp$4);
						}
						if (errorStack || errorComponentStack) {
							renderState$jscomp$1.push(clientRenderErrorScriptArgInterstitial$1);
							var chunk$jscomp$5 = escapeJSStringsForInstructionScripts$2(errorStack || "");
							renderState$jscomp$1.push(chunk$jscomp$5);
						}
						if (errorComponentStack) {
							renderState$jscomp$1.push(clientRenderErrorScriptArgInterstitial$1);
							var chunk$jscomp$6 = escapeJSStringsForInstructionScripts$2(errorComponentStack);
							renderState$jscomp$1.push(chunk$jscomp$6);
						}
						var JSCompiler_inline_result = renderState$jscomp$1.push(clientRenderScriptEnd$1);
						if (!JSCompiler_inline_result) {
							request.destination = null;
							i++;
							clientRenderedBoundaries.splice(0, i);
							return;
						}
					}
					clientRenderedBoundaries.splice(0, i);
					var completedBoundaries = request.completedBoundaries;
					for (i = 0; i < completedBoundaries.length; i++) if (!flushCompletedBoundary$2(request, destination, completedBoundaries[i])) {
						request.destination = null;
						i++;
						completedBoundaries.splice(0, i);
						return;
					}
					completedBoundaries.splice(0, i);
					flushingPartialBoundaries$2 = !0;
					var partialBoundaries = request.partialBoundaries;
					for (i = 0; i < partialBoundaries.length; i++) {
						a: {
							clientRenderedBoundaries = request;
							boundary = destination;
							var boundary$jscomp$0 = partialBoundaries[i];
							flushedByteSize$2 = boundary$jscomp$0.byteSize;
							var completedSegments = boundary$jscomp$0.completedSegments;
							for (JSCompiler_inline_result = 0; JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++) if (!flushPartiallyCompletedSegment$2(clientRenderedBoundaries, boundary, boundary$jscomp$0, completedSegments[JSCompiler_inline_result])) {
								JSCompiler_inline_result++;
								completedSegments.splice(0, JSCompiler_inline_result);
								var JSCompiler_inline_result$jscomp$0 = !1;
								break a;
							}
							completedSegments.splice(0, JSCompiler_inline_result);
							var row = boundary$jscomp$0.row;
							null !== row && row.together && 1 === boundary$jscomp$0.pendingTasks && (1 === row.pendingTasks ? unblockSuspenseListRow$2(clientRenderedBoundaries, row, row.hoistables) : row.pendingTasks--);
							JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary$2(boundary, boundary$jscomp$0.contentState, clientRenderedBoundaries.renderState);
						}
						if (!JSCompiler_inline_result$jscomp$0) {
							request.destination = null;
							i++;
							partialBoundaries.splice(0, i);
							return;
						}
					}
					partialBoundaries.splice(0, i);
					flushingPartialBoundaries$2 = !1;
					var largeBoundaries = request.completedBoundaries;
					for (i = 0; i < largeBoundaries.length; i++) if (!flushCompletedBoundary$2(request, destination, largeBoundaries[i])) {
						request.destination = null;
						i++;
						largeBoundaries.splice(0, i);
						return;
					}
					largeBoundaries.splice(0, i);
				}
			} finally {
				flushingPartialBoundaries$2 = !1, 0 === request.allPendingTasks && 0 === request.clientRenderedBoundaries.length && 0 === request.completedBoundaries.length && (request.flushScheduled = !1, i = request.resumableState, i.hasBody && (partialBoundaries = endChunkForTag$2("body"), destination.push(partialBoundaries)), i.hasHtml && (i = endChunkForTag$2("html"), destination.push(i)), 0 !== request.abortableTasks.size && console.error("There was still abortable task at the root when we closed. This is a bug in React."), request.status = CLOSED, destination.push(null), request.destination = null);
			}
		}
		function startWork$1(request) {
			request.flushScheduled = null !== request.destination;
			performWork$2(request);
			10 === request.status && (request.status = 11);
			null === request.trackedPostpones && safelyEmitEarlyPreloads$2(request, 0 === request.pendingRootTasks);
		}
		function enqueueFlush$2(request) {
			if (!1 === request.flushScheduled && 0 === request.pingedTasks.length && null !== request.destination) {
				request.flushScheduled = !0;
				var destination = request.destination;
				destination ? flushCompletedQueues$2(request, destination) : request.flushScheduled = !1;
			}
		}
		function startFlowing$2(request, destination) {
			if (13 === request.status) request.status = CLOSED, destination.destroy(request.fatalError);
			else if (request.status !== CLOSED && null === request.destination) {
				request.destination = destination;
				try {
					flushCompletedQueues$2(request, destination);
				} catch (error) {
					destination = {}, logRecoverableError$2(request, error, destination, null), fatalError$2(request, error, destination, null);
				}
			}
		}
		function abort$2(request, reason) {
			if (11 === request.status || 10 === request.status) request.status = 12;
			try {
				var abortableTasks = request.abortableTasks;
				if (0 < abortableTasks.size) {
					var error = void 0 === reason ? Error("The render was aborted by the server without a reason.") : "object" === typeof reason && null !== reason && "function" === typeof reason.then ? Error("The render was aborted by the server with a promise.") : reason;
					request.fatalError = error;
					abortableTasks.forEach(function(task) {
						var prevTaskInDEV = currentTaskInDEV, prevGetCurrentStackImpl = ReactSharedInternals$2.getCurrentStack;
						currentTaskInDEV = task;
						ReactSharedInternals$2.getCurrentStack = getCurrentStackInDEV;
						try {
							abortTask$2(task, request, error);
						} finally {
							currentTaskInDEV = prevTaskInDEV, ReactSharedInternals$2.getCurrentStack = prevGetCurrentStackImpl;
						}
					});
					abortableTasks.clear();
				}
				null !== request.destination && flushCompletedQueues$2(request, request.destination);
			} catch (error$4) {
				reason = {}, logRecoverableError$2(request, error$4, reason, null), fatalError$2(request, error$4, reason, null);
			}
		}
		function addToReplayParent$2(node, parentKeyPath, trackedPostpones) {
			if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);
			else {
				var workingMap = trackedPostpones.workingMap, parentNode = workingMap.get(parentKeyPath);
				void 0 === parentNode && (parentNode = [
					parentKeyPath[1],
					parentKeyPath[2],
					[],
					null
				], workingMap.set(parentKeyPath, parentNode), addToReplayParent$2(parentNode, parentKeyPath[0], trackedPostpones));
				parentNode[2].push(node);
			}
		}
		function onError$1() {}
		function renderToStringImpl$1(children, options, generateStaticMarkup, abortReason) {
			var didFatal = !1, fatalError$3 = null, result = "", readyToStream = !1;
			options = createResumableState$2(options ? options.identifierPrefix : void 0);
			children = createRequest$2(children, options, createRenderState$2(options, generateStaticMarkup), createFormatContext$2(ROOT_HTML_MODE, null, 0, null), Infinity, onError$1, void 0, function() {
				readyToStream = !0;
			}, void 0, void 0, void 0);
			startWork$1(children);
			abort$2(children, abortReason);
			startFlowing$2(children, {
				push: function(chunk) {
					null !== chunk && (result += chunk);
					return !0;
				},
				destroy: function(error) {
					didFatal = !0;
					fatalError$3 = error;
				}
			});
			if (didFatal && fatalError$3 !== abortReason) throw fatalError$3;
			if (!readyToStream) throw Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
			return result;
		}
		var React$3 = require_react(), ReactDOM$2 = require_react_dom(), REACT_ELEMENT_TYPE$2 = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE$2 = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE$2 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE$2 = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE$2 = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE$2 = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE$2 = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE$2 = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE$2 = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE$2 = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE$2 = Symbol.for("react.memo"), REACT_LAZY_TYPE$2 = Symbol.for("react.lazy"), REACT_SCOPE_TYPE$2 = Symbol.for("react.scope"), REACT_ACTIVITY_TYPE$2 = Symbol.for("react.activity"), REACT_LEGACY_HIDDEN_TYPE$2 = Symbol.for("react.legacy_hidden"), REACT_MEMO_CACHE_SENTINEL$2 = Symbol.for("react.memo_cache_sentinel"), REACT_VIEW_TRANSITION_TYPE$2 = Symbol.for("react.view_transition"), MAYBE_ITERATOR_SYMBOL$2 = Symbol.iterator, isArrayImpl$2 = Array.isArray, jsxPropsParents = /* @__PURE__ */ new WeakMap(), jsxChildrenParents = /* @__PURE__ */ new WeakMap(), CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"), assign$2 = Object.assign, hasOwnProperty$2 = Object.prototype.hasOwnProperty, VALID_ATTRIBUTE_NAME_REGEX$2 = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), illegalAttributeNameCache$2 = {}, validatedAttributeNameCache$2 = {}, unitlessNumbers$2 = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")), aliases$2 = new Map([
			["acceptCharset", "accept-charset"],
			["htmlFor", "for"],
			["httpEquiv", "http-equiv"],
			["crossOrigin", "crossorigin"],
			["accentHeight", "accent-height"],
			["alignmentBaseline", "alignment-baseline"],
			["arabicForm", "arabic-form"],
			["baselineShift", "baseline-shift"],
			["capHeight", "cap-height"],
			["clipPath", "clip-path"],
			["clipRule", "clip-rule"],
			["colorInterpolation", "color-interpolation"],
			["colorInterpolationFilters", "color-interpolation-filters"],
			["colorProfile", "color-profile"],
			["colorRendering", "color-rendering"],
			["dominantBaseline", "dominant-baseline"],
			["enableBackground", "enable-background"],
			["fillOpacity", "fill-opacity"],
			["fillRule", "fill-rule"],
			["floodColor", "flood-color"],
			["floodOpacity", "flood-opacity"],
			["fontFamily", "font-family"],
			["fontSize", "font-size"],
			["fontSizeAdjust", "font-size-adjust"],
			["fontStretch", "font-stretch"],
			["fontStyle", "font-style"],
			["fontVariant", "font-variant"],
			["fontWeight", "font-weight"],
			["glyphName", "glyph-name"],
			["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
			["glyphOrientationVertical", "glyph-orientation-vertical"],
			["horizAdvX", "horiz-adv-x"],
			["horizOriginX", "horiz-origin-x"],
			["imageRendering", "image-rendering"],
			["letterSpacing", "letter-spacing"],
			["lightingColor", "lighting-color"],
			["markerEnd", "marker-end"],
			["markerMid", "marker-mid"],
			["markerStart", "marker-start"],
			["overlinePosition", "overline-position"],
			["overlineThickness", "overline-thickness"],
			["paintOrder", "paint-order"],
			["panose-1", "panose-1"],
			["pointerEvents", "pointer-events"],
			["renderingIntent", "rendering-intent"],
			["shapeRendering", "shape-rendering"],
			["stopColor", "stop-color"],
			["stopOpacity", "stop-opacity"],
			["strikethroughPosition", "strikethrough-position"],
			["strikethroughThickness", "strikethrough-thickness"],
			["strokeDasharray", "stroke-dasharray"],
			["strokeDashoffset", "stroke-dashoffset"],
			["strokeLinecap", "stroke-linecap"],
			["strokeLinejoin", "stroke-linejoin"],
			["strokeMiterlimit", "stroke-miterlimit"],
			["strokeOpacity", "stroke-opacity"],
			["strokeWidth", "stroke-width"],
			["textAnchor", "text-anchor"],
			["textDecoration", "text-decoration"],
			["textRendering", "text-rendering"],
			["transformOrigin", "transform-origin"],
			["underlinePosition", "underline-position"],
			["underlineThickness", "underline-thickness"],
			["unicodeBidi", "unicode-bidi"],
			["unicodeRange", "unicode-range"],
			["unitsPerEm", "units-per-em"],
			["vAlphabetic", "v-alphabetic"],
			["vHanging", "v-hanging"],
			["vIdeographic", "v-ideographic"],
			["vMathematical", "v-mathematical"],
			["vectorEffect", "vector-effect"],
			["vertAdvY", "vert-adv-y"],
			["vertOriginX", "vert-origin-x"],
			["vertOriginY", "vert-origin-y"],
			["wordSpacing", "word-spacing"],
			["writingMode", "writing-mode"],
			["xmlnsXlink", "xmlns:xlink"],
			["xHeight", "x-height"]
		]), hasReadOnlyValue = {
			button: !0,
			checkbox: !0,
			image: !0,
			hidden: !0,
			radio: !0,
			reset: !0,
			submit: !0
		}, ariaProperties = {
			"aria-current": 0,
			"aria-description": 0,
			"aria-details": 0,
			"aria-disabled": 0,
			"aria-hidden": 0,
			"aria-invalid": 0,
			"aria-keyshortcuts": 0,
			"aria-label": 0,
			"aria-roledescription": 0,
			"aria-autocomplete": 0,
			"aria-checked": 0,
			"aria-expanded": 0,
			"aria-haspopup": 0,
			"aria-level": 0,
			"aria-modal": 0,
			"aria-multiline": 0,
			"aria-multiselectable": 0,
			"aria-orientation": 0,
			"aria-placeholder": 0,
			"aria-pressed": 0,
			"aria-readonly": 0,
			"aria-required": 0,
			"aria-selected": 0,
			"aria-sort": 0,
			"aria-valuemax": 0,
			"aria-valuemin": 0,
			"aria-valuenow": 0,
			"aria-valuetext": 0,
			"aria-atomic": 0,
			"aria-busy": 0,
			"aria-live": 0,
			"aria-relevant": 0,
			"aria-dropeffect": 0,
			"aria-grabbed": 0,
			"aria-activedescendant": 0,
			"aria-colcount": 0,
			"aria-colindex": 0,
			"aria-colspan": 0,
			"aria-controls": 0,
			"aria-describedby": 0,
			"aria-errormessage": 0,
			"aria-flowto": 0,
			"aria-labelledby": 0,
			"aria-owns": 0,
			"aria-posinset": 0,
			"aria-rowcount": 0,
			"aria-rowindex": 0,
			"aria-rowspan": 0,
			"aria-setsize": 0,
			"aria-braillelabel": 0,
			"aria-brailleroledescription": 0,
			"aria-colindextext": 0,
			"aria-rowindextext": 0
		}, warnedProperties$1 = {}, rARIA$1 = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), rARIACamel$1 = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), didWarnValueNull = !1, possibleStandardNames = {
			accept: "accept",
			acceptcharset: "acceptCharset",
			"accept-charset": "acceptCharset",
			accesskey: "accessKey",
			action: "action",
			allowfullscreen: "allowFullScreen",
			alt: "alt",
			as: "as",
			async: "async",
			autocapitalize: "autoCapitalize",
			autocomplete: "autoComplete",
			autocorrect: "autoCorrect",
			autofocus: "autoFocus",
			autoplay: "autoPlay",
			autosave: "autoSave",
			capture: "capture",
			cellpadding: "cellPadding",
			cellspacing: "cellSpacing",
			challenge: "challenge",
			charset: "charSet",
			checked: "checked",
			children: "children",
			cite: "cite",
			class: "className",
			classid: "classID",
			classname: "className",
			cols: "cols",
			colspan: "colSpan",
			content: "content",
			contenteditable: "contentEditable",
			contextmenu: "contextMenu",
			controls: "controls",
			controlslist: "controlsList",
			coords: "coords",
			crossorigin: "crossOrigin",
			dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
			data: "data",
			datetime: "dateTime",
			default: "default",
			defaultchecked: "defaultChecked",
			defaultvalue: "defaultValue",
			defer: "defer",
			dir: "dir",
			disabled: "disabled",
			disablepictureinpicture: "disablePictureInPicture",
			disableremoteplayback: "disableRemotePlayback",
			download: "download",
			draggable: "draggable",
			enctype: "encType",
			enterkeyhint: "enterKeyHint",
			fetchpriority: "fetchPriority",
			for: "htmlFor",
			form: "form",
			formmethod: "formMethod",
			formaction: "formAction",
			formenctype: "formEncType",
			formnovalidate: "formNoValidate",
			formtarget: "formTarget",
			frameborder: "frameBorder",
			headers: "headers",
			height: "height",
			hidden: "hidden",
			high: "high",
			href: "href",
			hreflang: "hrefLang",
			htmlfor: "htmlFor",
			httpequiv: "httpEquiv",
			"http-equiv": "httpEquiv",
			icon: "icon",
			id: "id",
			imagesizes: "imageSizes",
			imagesrcset: "imageSrcSet",
			inert: "inert",
			innerhtml: "innerHTML",
			inputmode: "inputMode",
			integrity: "integrity",
			is: "is",
			itemid: "itemID",
			itemprop: "itemProp",
			itemref: "itemRef",
			itemscope: "itemScope",
			itemtype: "itemType",
			keyparams: "keyParams",
			keytype: "keyType",
			kind: "kind",
			label: "label",
			lang: "lang",
			list: "list",
			loop: "loop",
			low: "low",
			manifest: "manifest",
			marginwidth: "marginWidth",
			marginheight: "marginHeight",
			max: "max",
			maxlength: "maxLength",
			media: "media",
			mediagroup: "mediaGroup",
			method: "method",
			min: "min",
			minlength: "minLength",
			multiple: "multiple",
			muted: "muted",
			name: "name",
			nomodule: "noModule",
			nonce: "nonce",
			novalidate: "noValidate",
			open: "open",
			optimum: "optimum",
			pattern: "pattern",
			placeholder: "placeholder",
			playsinline: "playsInline",
			poster: "poster",
			preload: "preload",
			profile: "profile",
			radiogroup: "radioGroup",
			readonly: "readOnly",
			referrerpolicy: "referrerPolicy",
			rel: "rel",
			required: "required",
			reversed: "reversed",
			role: "role",
			rows: "rows",
			rowspan: "rowSpan",
			sandbox: "sandbox",
			scope: "scope",
			scoped: "scoped",
			scrolling: "scrolling",
			seamless: "seamless",
			selected: "selected",
			shape: "shape",
			size: "size",
			sizes: "sizes",
			span: "span",
			spellcheck: "spellCheck",
			src: "src",
			srcdoc: "srcDoc",
			srclang: "srcLang",
			srcset: "srcSet",
			start: "start",
			step: "step",
			style: "style",
			summary: "summary",
			tabindex: "tabIndex",
			target: "target",
			title: "title",
			type: "type",
			usemap: "useMap",
			value: "value",
			width: "width",
			wmode: "wmode",
			wrap: "wrap",
			about: "about",
			accentheight: "accentHeight",
			"accent-height": "accentHeight",
			accumulate: "accumulate",
			additive: "additive",
			alignmentbaseline: "alignmentBaseline",
			"alignment-baseline": "alignmentBaseline",
			allowreorder: "allowReorder",
			alphabetic: "alphabetic",
			amplitude: "amplitude",
			arabicform: "arabicForm",
			"arabic-form": "arabicForm",
			ascent: "ascent",
			attributename: "attributeName",
			attributetype: "attributeType",
			autoreverse: "autoReverse",
			azimuth: "azimuth",
			basefrequency: "baseFrequency",
			baselineshift: "baselineShift",
			"baseline-shift": "baselineShift",
			baseprofile: "baseProfile",
			bbox: "bbox",
			begin: "begin",
			bias: "bias",
			by: "by",
			calcmode: "calcMode",
			capheight: "capHeight",
			"cap-height": "capHeight",
			clip: "clip",
			clippath: "clipPath",
			"clip-path": "clipPath",
			clippathunits: "clipPathUnits",
			cliprule: "clipRule",
			"clip-rule": "clipRule",
			color: "color",
			colorinterpolation: "colorInterpolation",
			"color-interpolation": "colorInterpolation",
			colorinterpolationfilters: "colorInterpolationFilters",
			"color-interpolation-filters": "colorInterpolationFilters",
			colorprofile: "colorProfile",
			"color-profile": "colorProfile",
			colorrendering: "colorRendering",
			"color-rendering": "colorRendering",
			contentscripttype: "contentScriptType",
			contentstyletype: "contentStyleType",
			cursor: "cursor",
			cx: "cx",
			cy: "cy",
			d: "d",
			datatype: "datatype",
			decelerate: "decelerate",
			descent: "descent",
			diffuseconstant: "diffuseConstant",
			direction: "direction",
			display: "display",
			divisor: "divisor",
			dominantbaseline: "dominantBaseline",
			"dominant-baseline": "dominantBaseline",
			dur: "dur",
			dx: "dx",
			dy: "dy",
			edgemode: "edgeMode",
			elevation: "elevation",
			enablebackground: "enableBackground",
			"enable-background": "enableBackground",
			end: "end",
			exponent: "exponent",
			externalresourcesrequired: "externalResourcesRequired",
			fill: "fill",
			fillopacity: "fillOpacity",
			"fill-opacity": "fillOpacity",
			fillrule: "fillRule",
			"fill-rule": "fillRule",
			filter: "filter",
			filterres: "filterRes",
			filterunits: "filterUnits",
			floodopacity: "floodOpacity",
			"flood-opacity": "floodOpacity",
			floodcolor: "floodColor",
			"flood-color": "floodColor",
			focusable: "focusable",
			fontfamily: "fontFamily",
			"font-family": "fontFamily",
			fontsize: "fontSize",
			"font-size": "fontSize",
			fontsizeadjust: "fontSizeAdjust",
			"font-size-adjust": "fontSizeAdjust",
			fontstretch: "fontStretch",
			"font-stretch": "fontStretch",
			fontstyle: "fontStyle",
			"font-style": "fontStyle",
			fontvariant: "fontVariant",
			"font-variant": "fontVariant",
			fontweight: "fontWeight",
			"font-weight": "fontWeight",
			format: "format",
			from: "from",
			fx: "fx",
			fy: "fy",
			g1: "g1",
			g2: "g2",
			glyphname: "glyphName",
			"glyph-name": "glyphName",
			glyphorientationhorizontal: "glyphOrientationHorizontal",
			"glyph-orientation-horizontal": "glyphOrientationHorizontal",
			glyphorientationvertical: "glyphOrientationVertical",
			"glyph-orientation-vertical": "glyphOrientationVertical",
			glyphref: "glyphRef",
			gradienttransform: "gradientTransform",
			gradientunits: "gradientUnits",
			hanging: "hanging",
			horizadvx: "horizAdvX",
			"horiz-adv-x": "horizAdvX",
			horizoriginx: "horizOriginX",
			"horiz-origin-x": "horizOriginX",
			ideographic: "ideographic",
			imagerendering: "imageRendering",
			"image-rendering": "imageRendering",
			in2: "in2",
			in: "in",
			inlist: "inlist",
			intercept: "intercept",
			k1: "k1",
			k2: "k2",
			k3: "k3",
			k4: "k4",
			k: "k",
			kernelmatrix: "kernelMatrix",
			kernelunitlength: "kernelUnitLength",
			kerning: "kerning",
			keypoints: "keyPoints",
			keysplines: "keySplines",
			keytimes: "keyTimes",
			lengthadjust: "lengthAdjust",
			letterspacing: "letterSpacing",
			"letter-spacing": "letterSpacing",
			lightingcolor: "lightingColor",
			"lighting-color": "lightingColor",
			limitingconeangle: "limitingConeAngle",
			local: "local",
			markerend: "markerEnd",
			"marker-end": "markerEnd",
			markerheight: "markerHeight",
			markermid: "markerMid",
			"marker-mid": "markerMid",
			markerstart: "markerStart",
			"marker-start": "markerStart",
			markerunits: "markerUnits",
			markerwidth: "markerWidth",
			mask: "mask",
			maskcontentunits: "maskContentUnits",
			maskunits: "maskUnits",
			mathematical: "mathematical",
			mode: "mode",
			numoctaves: "numOctaves",
			offset: "offset",
			opacity: "opacity",
			operator: "operator",
			order: "order",
			orient: "orient",
			orientation: "orientation",
			origin: "origin",
			overflow: "overflow",
			overlineposition: "overlinePosition",
			"overline-position": "overlinePosition",
			overlinethickness: "overlineThickness",
			"overline-thickness": "overlineThickness",
			paintorder: "paintOrder",
			"paint-order": "paintOrder",
			panose1: "panose1",
			"panose-1": "panose1",
			pathlength: "pathLength",
			patterncontentunits: "patternContentUnits",
			patterntransform: "patternTransform",
			patternunits: "patternUnits",
			pointerevents: "pointerEvents",
			"pointer-events": "pointerEvents",
			points: "points",
			pointsatx: "pointsAtX",
			pointsaty: "pointsAtY",
			pointsatz: "pointsAtZ",
			popover: "popover",
			popovertarget: "popoverTarget",
			popovertargetaction: "popoverTargetAction",
			prefix: "prefix",
			preservealpha: "preserveAlpha",
			preserveaspectratio: "preserveAspectRatio",
			primitiveunits: "primitiveUnits",
			property: "property",
			r: "r",
			radius: "radius",
			refx: "refX",
			refy: "refY",
			renderingintent: "renderingIntent",
			"rendering-intent": "renderingIntent",
			repeatcount: "repeatCount",
			repeatdur: "repeatDur",
			requiredextensions: "requiredExtensions",
			requiredfeatures: "requiredFeatures",
			resource: "resource",
			restart: "restart",
			result: "result",
			results: "results",
			rotate: "rotate",
			rx: "rx",
			ry: "ry",
			scale: "scale",
			security: "security",
			seed: "seed",
			shaperendering: "shapeRendering",
			"shape-rendering": "shapeRendering",
			slope: "slope",
			spacing: "spacing",
			specularconstant: "specularConstant",
			specularexponent: "specularExponent",
			speed: "speed",
			spreadmethod: "spreadMethod",
			startoffset: "startOffset",
			stddeviation: "stdDeviation",
			stemh: "stemh",
			stemv: "stemv",
			stitchtiles: "stitchTiles",
			stopcolor: "stopColor",
			"stop-color": "stopColor",
			stopopacity: "stopOpacity",
			"stop-opacity": "stopOpacity",
			strikethroughposition: "strikethroughPosition",
			"strikethrough-position": "strikethroughPosition",
			strikethroughthickness: "strikethroughThickness",
			"strikethrough-thickness": "strikethroughThickness",
			string: "string",
			stroke: "stroke",
			strokedasharray: "strokeDasharray",
			"stroke-dasharray": "strokeDasharray",
			strokedashoffset: "strokeDashoffset",
			"stroke-dashoffset": "strokeDashoffset",
			strokelinecap: "strokeLinecap",
			"stroke-linecap": "strokeLinecap",
			strokelinejoin: "strokeLinejoin",
			"stroke-linejoin": "strokeLinejoin",
			strokemiterlimit: "strokeMiterlimit",
			"stroke-miterlimit": "strokeMiterlimit",
			strokewidth: "strokeWidth",
			"stroke-width": "strokeWidth",
			strokeopacity: "strokeOpacity",
			"stroke-opacity": "strokeOpacity",
			suppresscontenteditablewarning: "suppressContentEditableWarning",
			suppresshydrationwarning: "suppressHydrationWarning",
			surfacescale: "surfaceScale",
			systemlanguage: "systemLanguage",
			tablevalues: "tableValues",
			targetx: "targetX",
			targety: "targetY",
			textanchor: "textAnchor",
			"text-anchor": "textAnchor",
			textdecoration: "textDecoration",
			"text-decoration": "textDecoration",
			textlength: "textLength",
			textrendering: "textRendering",
			"text-rendering": "textRendering",
			to: "to",
			transform: "transform",
			transformorigin: "transformOrigin",
			"transform-origin": "transformOrigin",
			typeof: "typeof",
			u1: "u1",
			u2: "u2",
			underlineposition: "underlinePosition",
			"underline-position": "underlinePosition",
			underlinethickness: "underlineThickness",
			"underline-thickness": "underlineThickness",
			unicode: "unicode",
			unicodebidi: "unicodeBidi",
			"unicode-bidi": "unicodeBidi",
			unicoderange: "unicodeRange",
			"unicode-range": "unicodeRange",
			unitsperem: "unitsPerEm",
			"units-per-em": "unitsPerEm",
			unselectable: "unselectable",
			valphabetic: "vAlphabetic",
			"v-alphabetic": "vAlphabetic",
			values: "values",
			vectoreffect: "vectorEffect",
			"vector-effect": "vectorEffect",
			version: "version",
			vertadvy: "vertAdvY",
			"vert-adv-y": "vertAdvY",
			vertoriginx: "vertOriginX",
			"vert-origin-x": "vertOriginX",
			vertoriginy: "vertOriginY",
			"vert-origin-y": "vertOriginY",
			vhanging: "vHanging",
			"v-hanging": "vHanging",
			videographic: "vIdeographic",
			"v-ideographic": "vIdeographic",
			viewbox: "viewBox",
			viewtarget: "viewTarget",
			visibility: "visibility",
			vmathematical: "vMathematical",
			"v-mathematical": "vMathematical",
			vocab: "vocab",
			widths: "widths",
			wordspacing: "wordSpacing",
			"word-spacing": "wordSpacing",
			writingmode: "writingMode",
			"writing-mode": "writingMode",
			x1: "x1",
			x2: "x2",
			x: "x",
			xchannelselector: "xChannelSelector",
			xheight: "xHeight",
			"x-height": "xHeight",
			xlinkactuate: "xlinkActuate",
			"xlink:actuate": "xlinkActuate",
			xlinkarcrole: "xlinkArcrole",
			"xlink:arcrole": "xlinkArcrole",
			xlinkhref: "xlinkHref",
			"xlink:href": "xlinkHref",
			xlinkrole: "xlinkRole",
			"xlink:role": "xlinkRole",
			xlinkshow: "xlinkShow",
			"xlink:show": "xlinkShow",
			xlinktitle: "xlinkTitle",
			"xlink:title": "xlinkTitle",
			xlinktype: "xlinkType",
			"xlink:type": "xlinkType",
			xmlbase: "xmlBase",
			"xml:base": "xmlBase",
			xmllang: "xmlLang",
			"xml:lang": "xmlLang",
			xmlns: "xmlns",
			"xml:space": "xmlSpace",
			xmlnsxlink: "xmlnsXlink",
			"xmlns:xlink": "xmlnsXlink",
			xmlspace: "xmlSpace",
			y1: "y1",
			y2: "y2",
			y: "y",
			ychannelselector: "yChannelSelector",
			z: "z",
			zoomandpan: "zoomAndPan"
		}, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), rARIACamel = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern$1$1 = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = !1, warnedForInfinityValue = !1, matchHtmlRegExp$2 = /["'&<>]/, uppercasePattern$2 = /([A-Z])/g, msPattern$2 = /^ms-/, isJavaScriptProtocol$2 = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, ReactSharedInternals$2 = React$3.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals$2 = ReactDOM$2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
			pending: !1,
			data: null,
			method: null,
			action: null
		}), previousDispatcher$2 = ReactDOMSharedInternals$2.d;
		ReactDOMSharedInternals$2.d = {
			f: previousDispatcher$2.f,
			r: previousDispatcher$2.r,
			D: function(href) {
				var request = currentRequest$2 ? currentRequest$2 : null;
				if (request) {
					var resumableState = request.resumableState, renderState = request.renderState;
					if ("string" === typeof href && href) {
						if (!resumableState.dnsResources.hasOwnProperty(href)) {
							resumableState.dnsResources[href] = EXISTS;
							resumableState = renderState.headers;
							var header, JSCompiler_temp;
							if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) JSCompiler_temp = (header = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=dns-prefetch", 0 <= (resumableState.remainingCapacity -= header.length + 2));
							JSCompiler_temp ? (renderState.resets.dns[href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (header = [], pushLinkImpl$2(header, {
								href,
								rel: "dns-prefetch"
							}), renderState.preconnects.add(header));
						}
						enqueueFlush$2(request);
					}
				} else previousDispatcher$2.D(href);
			},
			C: function(href, crossOrigin) {
				var request = currentRequest$2 ? currentRequest$2 : null;
				if (request) {
					var resumableState = request.resumableState, renderState = request.renderState;
					if ("string" === typeof href && href) {
						var bucket = "use-credentials" === crossOrigin ? "credentials" : "string" === typeof crossOrigin ? "anonymous" : "default";
						if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {
							resumableState.connectResources[bucket][href] = EXISTS;
							resumableState = renderState.headers;
							var header, JSCompiler_temp;
							if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {
								JSCompiler_temp = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=preconnect";
								if ("string" === typeof crossOrigin) {
									var escapedCrossOrigin = escapeStringForLinkHeaderQuotedParamValueContext(crossOrigin, "crossOrigin");
									JSCompiler_temp += "; crossorigin=\"" + escapedCrossOrigin + "\"";
								}
								JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));
							}
							JSCompiler_temp ? (renderState.resets.connect[bucket][href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (bucket = [], pushLinkImpl$2(bucket, {
								rel: "preconnect",
								href,
								crossOrigin
							}), renderState.preconnects.add(bucket));
						}
						enqueueFlush$2(request);
					}
				} else previousDispatcher$2.C(href, crossOrigin);
			},
			L: function(href, as, options) {
				var request = currentRequest$2 ? currentRequest$2 : null;
				if (request) {
					var resumableState = request.resumableState, renderState = request.renderState;
					if (as && href) {
						switch (as) {
							case "image":
								if (options) {
									var imageSrcSet = options.imageSrcSet;
									var imageSizes = options.imageSizes;
									var fetchPriority = options.fetchPriority;
								}
								var key = imageSrcSet ? imageSrcSet + "\n" + (imageSizes || "") : href;
								if (resumableState.imageResources.hasOwnProperty(key)) return;
								resumableState.imageResources[key] = PRELOAD_NO_CREDS$2;
								resumableState = renderState.headers;
								var header;
								resumableState && 0 < resumableState.remainingCapacity && "string" !== typeof imageSrcSet && "high" === fetchPriority && (header = getPreloadAsHeader$2(href, as, options), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS$2, resumableState.highImagePreloads && (resumableState.highImagePreloads += ", "), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl$2(resumableState, assign$2({
									rel: "preload",
									href: imageSrcSet ? void 0 : href,
									as
								}, options)), "high" === fetchPriority ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));
								break;
							case "style":
								if (resumableState.styleResources.hasOwnProperty(href)) return;
								imageSrcSet = [];
								pushLinkImpl$2(imageSrcSet, assign$2({
									rel: "preload",
									href,
									as
								}, options));
								resumableState.styleResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS$2 : [options.crossOrigin, options.integrity];
								renderState.preloads.stylesheets.set(href, imageSrcSet);
								renderState.bulkPreloads.add(imageSrcSet);
								break;
							case "script":
								if (resumableState.scriptResources.hasOwnProperty(href)) return;
								imageSrcSet = [];
								renderState.preloads.scripts.set(href, imageSrcSet);
								renderState.bulkPreloads.add(imageSrcSet);
								pushLinkImpl$2(imageSrcSet, assign$2({
									rel: "preload",
									href,
									as
								}, options));
								resumableState.scriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS$2 : [options.crossOrigin, options.integrity];
								break;
							default:
								if (resumableState.unknownResources.hasOwnProperty(as)) {
									if (imageSrcSet = resumableState.unknownResources[as], imageSrcSet.hasOwnProperty(href)) return;
								} else imageSrcSet = {}, resumableState.unknownResources[as] = imageSrcSet;
								imageSrcSet[href] = PRELOAD_NO_CREDS$2;
								if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && "font" === as && (key = getPreloadAsHeader$2(href, as, options), 0 <= (resumableState.remainingCapacity -= key.length + 2))) renderState.resets.font[href] = PRELOAD_NO_CREDS$2, resumableState.fontPreloads && (resumableState.fontPreloads += ", "), resumableState.fontPreloads += key;
								else switch (resumableState = [], href = assign$2({
									rel: "preload",
									href,
									as
								}, options), pushLinkImpl$2(resumableState, href), as) {
									case "font":
										renderState.fontPreloads.add(resumableState);
										break;
									default: renderState.bulkPreloads.add(resumableState);
								}
						}
						enqueueFlush$2(request);
					}
				} else previousDispatcher$2.L(href, as, options);
			},
			m: function(href, options) {
				var request = currentRequest$2 ? currentRequest$2 : null;
				if (request) {
					var resumableState = request.resumableState, renderState = request.renderState;
					if (href) {
						var as = options && "string" === typeof options.as ? options.as : "script";
						switch (as) {
							case "script":
								if (resumableState.moduleScriptResources.hasOwnProperty(href)) return;
								as = [];
								resumableState.moduleScriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS$2 : [options.crossOrigin, options.integrity];
								renderState.preloads.moduleScripts.set(href, as);
								break;
							default:
								if (resumableState.moduleUnknownResources.hasOwnProperty(as)) {
									var resources = resumableState.unknownResources[as];
									if (resources.hasOwnProperty(href)) return;
								} else resources = {}, resumableState.moduleUnknownResources[as] = resources;
								as = [];
								resources[href] = PRELOAD_NO_CREDS$2;
						}
						pushLinkImpl$2(as, assign$2({
							rel: "modulepreload",
							href
						}, options));
						renderState.bulkPreloads.add(as);
						enqueueFlush$2(request);
					}
				} else previousDispatcher$2.m(href, options);
			},
			X: function(src, options) {
				var request = currentRequest$2 ? currentRequest$2 : null;
				if (request) {
					var resumableState = request.resumableState, renderState = request.renderState;
					if (src) {
						var resourceState = resumableState.scriptResources.hasOwnProperty(src) ? resumableState.scriptResources[src] : void 0;
						resourceState !== EXISTS && (resumableState.scriptResources[src] = EXISTS, options = assign$2({
							src,
							async: !0
						}, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials$2(options, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl$2(src, options), enqueueFlush$2(request));
					}
				} else previousDispatcher$2.X(src, options);
			},
			S: function(href, precedence, options) {
				var request = currentRequest$2 ? currentRequest$2 : null;
				if (request) {
					var resumableState = request.resumableState, renderState = request.renderState;
					if (href) {
						precedence = precedence || "default";
						var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
						resourceState !== EXISTS && (resumableState.styleResources[href] = EXISTS, styleQueue || (styleQueue = {
							precedence: escapeTextForBrowser$2(precedence),
							rules: [],
							hrefs: [],
							sheets: /* @__PURE__ */ new Map()
						}, renderState.styles.set(precedence, styleQueue)), precedence = {
							state: PENDING$1,
							props: assign$2({
								rel: "stylesheet",
								href,
								"data-precedence": precedence
							}, options)
						}, resourceState && (2 === resourceState.length && adoptPreloadCredentials$2(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = PRELOADED), styleQueue.sheets.set(href, precedence), enqueueFlush$2(request));
					}
				} else previousDispatcher$2.S(href, precedence, options);
			},
			M: function(src, options) {
				var request = currentRequest$2 ? currentRequest$2 : null;
				if (request) {
					var resumableState = request.resumableState, renderState = request.renderState;
					if (src) {
						var resourceState = resumableState.moduleScriptResources.hasOwnProperty(src) ? resumableState.moduleScriptResources[src] : void 0;
						resourceState !== EXISTS && (resumableState.moduleScriptResources[src] = EXISTS, options = assign$2({
							src,
							type: "module",
							async: !0
						}, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials$2(options, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl$2(src, options), enqueueFlush$2(request));
					}
				} else previousDispatcher$2.M(src, options);
			}
		};
		var NothingSent = 0, SentCompleteSegmentFunction = 1, SentCompleteBoundaryFunction = 2, SentClientRenderFunction = 4, SentStyleInsertionFunction = 8, SentCompletedShellId = 32, SentMarkShellTime = 64, EXISTS = null, PRELOAD_NO_CREDS$2 = [];
		Object.freeze(PRELOAD_NO_CREDS$2);
		var currentlyFlushingRenderState$2 = null, endInlineScript$1 = "<\/script>", scriptRegex$2 = /(<\/|<)(s)(cript)/gi;
		var didWarnForNewBooleanPropsWithEmptyValue = {};
		var ROOT_HTML_MODE = 0, HTML_HTML_MODE = 1, HTML_MODE = 2, HTML_HEAD_MODE = 3, SVG_MODE = 4, MATHML_MODE = 5, HTML_TABLE_MODE = 6, HTML_TABLE_BODY_MODE = 7, HTML_TABLE_ROW_MODE = 8, HTML_COLGROUP_MODE = 9, styleNameCache$2 = /* @__PURE__ */ new Map(), styleAttributeStart$1 = " style=\"", styleAssign$1 = ":", styleSeparator$1 = ";", attributeSeparator$1 = " ", attributeAssign$1 = "=\"", attributeEnd$1 = "\"", attributeEmptyString$1 = "=\"\"", actionJavaScriptURL$2 = escapeTextForBrowser$2("javascript:throw new Error('React form unexpectedly submitted.')"), endOfStartTag$1 = ">", endOfStartTagSelfClosing$1 = "/>", didWarnDefaultInputValue = !1, didWarnDefaultChecked = !1, didWarnDefaultSelectValue = !1, didWarnDefaultTextareaValue = !1, didWarnInvalidOptionChildren = !1, didWarnInvalidOptionInnerHTML = !1, didWarnSelectedSetOnOption = !1, didWarnFormActionType = !1, didWarnFormActionName = !1, didWarnFormActionTarget = !1, didWarnFormActionMethod = !1, formReplayingRuntimeScript$1 = "addEventListener(\"submit\",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute(\"formAction\");null!=f&&(e=f,b=null)}\"javascript:throw new Error('React form unexpectedly submitted.')\"===e&&(a.preventDefault(),b?(a=document.createElement(\"input\"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});", styleRegex$2 = /(<\/|<)(s)(tyle)/gi, leadingNewline$1 = "\n", VALID_TAG_REGEX$2 = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache$2 = /* @__PURE__ */ new Map(), endTagCache$2 = /* @__PURE__ */ new Map(), shellTimeRuntimeScript$1 = "requestAnimationFrame(function(){$RT=performance.now()});", placeholder1$1 = "<template id=\"", placeholder2$1 = "\"></template>", startCompletedSuspenseBoundary$1 = "<!--$-->", startPendingSuspenseBoundary1$1 = "<!--$?--><template id=\"", startPendingSuspenseBoundary2$1 = "\"></template>", startClientRenderedSuspenseBoundary$1 = "<!--$!-->", endSuspenseBoundary$1 = "<!--/$-->", clientRenderedSuspenseBoundaryError1$1 = "<template", clientRenderedSuspenseBoundaryErrorAttrInterstitial$1 = "\"", clientRenderedSuspenseBoundaryError1A$1 = " data-dgst=\"", clientRenderedSuspenseBoundaryError1B = " data-msg=\"", clientRenderedSuspenseBoundaryError1C = " data-stck=\"", clientRenderedSuspenseBoundaryError1D = " data-cstck=\"", clientRenderedSuspenseBoundaryError2$1 = "></template>", startSegmentHTML$1 = "<div hidden id=\"", startSegmentHTML2$1 = "\">", endSegmentHTML$1 = "</div>", startSegmentSVG$1 = "<svg aria-hidden=\"true\" style=\"display:none\" id=\"", startSegmentSVG2$1 = "\">", endSegmentSVG$1 = "</svg>", startSegmentMathML$1 = "<math aria-hidden=\"true\" style=\"display:none\" id=\"", startSegmentMathML2$1 = "\">", endSegmentMathML$1 = "</math>", startSegmentTable$1 = "<table hidden id=\"", startSegmentTable2$1 = "\">", endSegmentTable$1 = "</table>", startSegmentTableBody$1 = "<table hidden><tbody id=\"", startSegmentTableBody2$1 = "\">", endSegmentTableBody$1 = "</tbody></table>", startSegmentTableRow$1 = "<table hidden><tr id=\"", startSegmentTableRow2$1 = "\">", endSegmentTableRow$1 = "</tr></table>", startSegmentColGroup$1 = "<table hidden><colgroup id=\"", startSegmentColGroup2$1 = "\">", endSegmentColGroup$1 = "</colgroup></table>", completeSegmentScript1Full$1 = "$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(\"", completeSegmentScript1Partial$1 = "$RS(\"", completeSegmentScript2$1 = "\",\"", completeSegmentScriptEnd$1 = "\")<\/script>", completeBoundaryScriptFunctionOnly$1 = "$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if(\"/$\"===d||\"/&\"===d)if(0===h)break;else h--;else\"$\"!==d&&\"$?\"!==d&&\"$~\"!==d&&\"$!\"!==d&&\"&\"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data=\"$\";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};\n$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data=\"$~\",$RB.push(a,b),2===$RB.length&&(\"number\"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};", completeBoundaryScript1Partial$1 = "$RC(\"", completeBoundaryWithStylesScript1FullPartial$1 = "$RM=new Map;$RR=function(n,w,p){function u(q){this._p=null;q()}for(var r=new Map,t=document,h,b,e=t.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),v=[],k=0;b=e[k++];)\"not all\"===b.getAttribute(\"media\")?v.push(b):(\"LINK\"===b.tagName&&$RM.set(b.getAttribute(\"href\"),b),r.set(b.dataset.precedence,h=b));e=0;b=[];var l,a;for(k=!0;;){if(k){var f=p[e++];if(!f){k=!1;e=0;continue}var c=!1,m=0;var d=f[m++];if(a=$RM.get(d)){var g=a._p;c=!0}else{a=t.createElement(\"link\");a.href=d;a.rel=\n\"stylesheet\";for(a.dataset.precedence=l=f[m++];g=f[m++];)a.setAttribute(g,f[m++]);g=a._p=new Promise(function(q,x){a.onload=u.bind(a,q);a.onerror=u.bind(a,x)});$RM.set(d,a)}d=a.getAttribute(\"media\");!g||d&&!matchMedia(d).matches||b.push(g);if(c)continue}else{a=v[e++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=r.get(l)||h;c===h&&(h=a);r.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=t.head,c.insertBefore(a,c.firstChild))}if(p=document.getElementById(n))p.previousSibling.data=\n\"$~\";Promise.all(b).then($RC.bind(null,n,w),$RX.bind(null,n,\"CSS failed to load\"))};$RR(\"", completeBoundaryWithStylesScript1Partial$1 = "$RR(\"", completeBoundaryScript2$1 = "\",\"", completeBoundaryScript3a$1 = "\",", completeBoundaryScript3b$1 = "\"", completeBoundaryScriptEnd$1 = ")<\/script>", clientRenderScriptFunctionOnly$1 = "$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};", clientRenderScript1Full$1 = "$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX(\"", clientRenderScript1Partial$1 = "$RX(\"", clientRenderScript1A$1 = "\"", clientRenderErrorScriptArgInterstitial$1 = ",", clientRenderScriptEnd$1 = ")<\/script>", regexForJSStringsInInstructionScripts$2 = /[<\u2028\u2029]/g, regexForJSStringsInScripts$2 = /[&><\u2028\u2029]/g, lateStyleTagResourceOpen1$1 = " media=\"not all\" data-precedence=\"", lateStyleTagResourceOpen2$1 = "\" data-href=\"", lateStyleTagResourceOpen3$1 = "\">", lateStyleTagTemplateClose$1 = "</style>", currentlyRenderingBoundaryHasStylesToHoist$2 = !1, destinationHasCapacity$3 = !0, stylesheetFlushingQueue$2 = [], styleTagResourceOpen1$1 = " data-precedence=\"", styleTagResourceOpen2$1 = "\" data-href=\"", spaceSeparator$1 = " ", styleTagResourceOpen3$1 = "\">", styleTagResourceClose$1 = "</style>", completedShellIdAttributeStart$1 = " id=\"", arrayFirstOpenBracket$1 = "[", arraySubsequentOpenBracket$1 = ",[", arrayInterstitial$1 = ",", arrayCloseBracket$1 = "]", PENDING$1 = 0, PRELOADED = 1, PREAMBLE = 2, LATE = 3, regexForHrefInLinkHeaderURLContext$2 = /[<>\r\n]/g, regexForLinkHeaderQuotedParamValueContext$2 = /["';,\r\n]/g, doctypeChunk$1 = "", bind$2 = Function.prototype.bind, REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"), emptyContextObject$2 = {};
		Object.freeze(emptyContextObject$2);
		var rendererSigil = {};
		var currentActiveSnapshot$2 = null, didWarnAboutNoopUpdateForComponent = {}, didWarnAboutDeprecatedWillMount = {};
		var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
		var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
		var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
		var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
		var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
		var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
		var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
		var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
		var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
		var classComponentUpdater$2 = {
			enqueueSetState: function(inst, payload, callback) {
				var internals = inst._reactInternals;
				null === internals.queue ? warnNoop(inst, "setState") : (internals.queue.push(payload), void 0 !== callback && null !== callback && warnOnInvalidCallback(callback));
			},
			enqueueReplaceState: function(inst, payload, callback) {
				inst = inst._reactInternals;
				inst.replace = !0;
				inst.queue = [payload];
				void 0 !== callback && null !== callback && warnOnInvalidCallback(callback);
			},
			enqueueForceUpdate: function(inst, callback) {
				null === inst._reactInternals.queue ? warnNoop(inst, "forceUpdate") : void 0 !== callback && null !== callback && warnOnInvalidCallback(callback);
			}
		}, emptyTreeContext$2 = {
			id: 1,
			overflow: ""
		}, clz32$2 = Math.clz32 ? Math.clz32 : clz32Fallback$2, log$2 = Math.log, LN2$2 = Math.LN2, SuspenseException$2 = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."), suspendedThenable$2 = null, objectIs$2 = "function" === typeof Object.is ? Object.is : is$2, currentlyRenderingComponent$2 = null, currentlyRenderingTask$2 = null, currentlyRenderingRequest$2 = null, currentlyRenderingKeyPath$2 = null, firstWorkInProgressHook$2 = null, workInProgressHook$2 = null, isReRender$2 = !1, didScheduleRenderPhaseUpdate$2 = !1, localIdCounter$2 = 0, actionStateCounter$2 = 0, actionStateMatchingIndex$2 = -1, thenableIndexCounter$2 = 0, thenableState$2 = null, renderPhaseUpdates$2 = null, numberOfReRenders$2 = 0, isInHookUserCodeInDev = !1, currentHookNameInDev, HooksDispatcher$2 = {
			readContext,
			use: function(usable) {
				if (null !== usable && "object" === typeof usable) {
					if ("function" === typeof usable.then) return unwrapThenable$2(usable);
					if (usable.$$typeof === REACT_CONTEXT_TYPE$2) return readContext(usable);
				}
				throw Error("An unsupported type was passed to use(): " + String(usable));
			},
			useContext: function(context) {
				currentHookNameInDev = "useContext";
				resolveCurrentlyRenderingComponent$2();
				return context._currentValue2;
			},
			useMemo: useMemo$2,
			useReducer: useReducer$2,
			useRef: function(initialValue) {
				currentlyRenderingComponent$2 = resolveCurrentlyRenderingComponent$2();
				workInProgressHook$2 = createWorkInProgressHook$2();
				var previousRef = workInProgressHook$2.memoizedState;
				return null === previousRef ? (initialValue = { current: initialValue }, Object.seal(initialValue), workInProgressHook$2.memoizedState = initialValue) : previousRef;
			},
			useState: function(initialState) {
				currentHookNameInDev = "useState";
				return useReducer$2(basicStateReducer$2, initialState);
			},
			useInsertionEffect: noop$2,
			useLayoutEffect: noop$2,
			useCallback: function(callback, deps) {
				return useMemo$2(function() {
					return callback;
				}, deps);
			},
			useImperativeHandle: noop$2,
			useEffect: noop$2,
			useDebugValue: noop$2,
			useDeferredValue: function(value, initialValue) {
				resolveCurrentlyRenderingComponent$2();
				return void 0 !== initialValue ? initialValue : value;
			},
			useTransition: function() {
				resolveCurrentlyRenderingComponent$2();
				return [!1, unsupportedStartTransition$2];
			},
			useId: function() {
				var treeId = currentlyRenderingTask$2.treeContext;
				var overflow = treeId.overflow;
				treeId = treeId.id;
				treeId = (treeId & ~(1 << 32 - clz32$2(treeId) - 1)).toString(32) + overflow;
				var resumableState = currentResumableState$2;
				if (null === resumableState) throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
				overflow = localIdCounter$2++;
				treeId = "_" + resumableState.idPrefix + "R_" + treeId;
				0 < overflow && (treeId += "H" + overflow.toString(32));
				return treeId + "_";
			},
			useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
				if (void 0 === getServerSnapshot) throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
				return getServerSnapshot();
			},
			useOptimistic: function(passthrough) {
				resolveCurrentlyRenderingComponent$2();
				return [passthrough, unsupportedSetOptimisticState$2];
			},
			useActionState: useActionState$2,
			useFormState: useActionState$2,
			useHostTransitionStatus: function() {
				resolveCurrentlyRenderingComponent$2();
				return NotPending;
			},
			useMemoCache: function(size) {
				for (var data = Array(size), i = 0; i < size; i++) data[i] = REACT_MEMO_CACHE_SENTINEL$2;
				return data;
			},
			useCacheRefresh: function() {
				return unsupportedRefresh$2;
			},
			useEffectEvent: function() {
				return throwOnUseEffectEventCall$2;
			}
		}, currentResumableState$2 = null, currentTaskInDEV = null, DefaultAsyncDispatcher$2 = {
			getCacheForType: function() {
				throw Error("Not implemented.");
			},
			cacheSignal: function() {
				throw Error("Not implemented.");
			},
			getOwner: function() {
				return null === currentTaskInDEV ? null : currentTaskInDEV.componentStack;
			}
		}, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
		disabledLog.__reactDisabledLog = !0;
		var prefix$2, suffix$2, reentry$2 = !1;
		var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
		var callComponent = { react_stack_bottom_frame: function(Component, props, secondArg) {
			return Component(props, secondArg);
		} }, callComponentInDEV = callComponent.react_stack_bottom_frame.bind(callComponent), callRender = { react_stack_bottom_frame: function(instance) {
			return instance.render();
		} }, callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender), callLazyInit = { react_stack_bottom_frame: function(lazy) {
			var init = lazy._init;
			return init(lazy._payload);
		} }, callLazyInitInDEV = callLazyInit.react_stack_bottom_frame.bind(callLazyInit), lastResetTime = 0;
		if ("object" === typeof performance && "function" === typeof performance.now) {
			var localPerformance = performance;
			var getCurrentTime = function() {
				return localPerformance.now();
			};
		} else {
			var localDate = Date;
			getCurrentTime = function() {
				return localDate.now();
			};
		}
		var CLIENT_RENDERED = 4, PENDING = 0, COMPLETED = 1, FLUSHED = 2, ABORTED = 3, ERRORED = 4, POSTPONED = 5, CLOSED = 14, currentRequest$2 = null, didWarnAboutBadClass = {}, didWarnAboutContextTypes = {}, didWarnAboutContextTypeOnFunctionComponent = {}, didWarnAboutGetDerivedStateOnFunctionComponent = {}, didWarnAboutReassigningProps = !1, didWarnAboutGenerators = !1, didWarnAboutMaps = !1, flushedByteSize$2 = 0, flushingPartialBoundaries$2 = !1;
		exports.renderToStaticMarkup = function(children, options) {
			return renderToStringImpl$1(children, options, !0, "The server used \"renderToStaticMarkup\" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to \"renderToPipeableStream\" which supports Suspense on the server");
		};
		exports.renderToString = function(children, options) {
			return renderToStringImpl$1(children, options, !1, "The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToPipeableStream\" which supports Suspense on the server");
		};
		exports.version = "19.2.0";
	})();
}) });

//#endregion
//#region ../../node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom-server.node.development.js
var require_react_dom_server_node_development = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom-server.node.development.js": ((exports) => {
	"production" !== process.env.NODE_ENV && (function() {
		function styleReplacer$2(match, prefix$3, s$1, suffix$3) {
			return "" + prefix$3 + ("s" === s$1 ? "\\73 " : "\\53 ") + suffix$3;
		}
		function scriptReplacer$2(match, prefix$3, s$1, suffix$3) {
			return "" + prefix$3 + ("s" === s$1 ? "\\u0073" : "\\u0053") + suffix$3;
		}
		function getIteratorFn$2(maybeIterable) {
			if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
			maybeIterable = MAYBE_ITERATOR_SYMBOL$2 && maybeIterable[MAYBE_ITERATOR_SYMBOL$2] || maybeIterable["@@iterator"];
			return "function" === typeof maybeIterable ? maybeIterable : null;
		}
		function objectName(object) {
			object = Object.prototype.toString.call(object);
			return object.slice(8, object.length - 1);
		}
		function describeKeyForErrorMessage(key) {
			var encodedKey = JSON.stringify(key);
			return "\"" + key + "\"" === encodedKey ? key : encodedKey;
		}
		function describeValueForErrorMessage(value) {
			switch (typeof value) {
				case "string": return JSON.stringify(10 >= value.length ? value : value.slice(0, 10) + "...");
				case "object":
					if (isArrayImpl$2(value)) return "[...]";
					if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG) return "client";
					value = objectName(value);
					return "Object" === value ? "{...}" : value;
				case "function": return value.$$typeof === CLIENT_REFERENCE_TAG ? "client" : (value = value.displayName || value.name) ? "function " + value : "function";
				default: return String(value);
			}
		}
		function describeElementType(type) {
			if ("string" === typeof type) return type;
			switch (type) {
				case REACT_SUSPENSE_TYPE$2: return "Suspense";
				case REACT_SUSPENSE_LIST_TYPE$2: return "SuspenseList";
			}
			if ("object" === typeof type) switch (type.$$typeof) {
				case REACT_FORWARD_REF_TYPE$2: return describeElementType(type.render);
				case REACT_MEMO_TYPE$2: return describeElementType(type.type);
				case REACT_LAZY_TYPE$2:
					var payload = type._payload;
					type = type._init;
					try {
						return describeElementType(type(payload));
					} catch (x) {}
			}
			return "";
		}
		function describeObjectForErrorMessage(objectOrArray, expandedName) {
			var objKind = objectName(objectOrArray);
			if ("Object" !== objKind && "Array" !== objKind) return objKind;
			var start = -1, length = 0;
			if (isArrayImpl$2(objectOrArray)) if (jsxChildrenParents.has(objectOrArray)) {
				var type = jsxChildrenParents.get(objectOrArray);
				objKind = "<" + describeElementType(type) + ">";
				for (var i = 0; i < objectOrArray.length; i++) {
					var value = objectOrArray[i];
					value = "string" === typeof value ? value : "object" === typeof value && null !== value ? "{" + describeObjectForErrorMessage(value) + "}" : "{" + describeValueForErrorMessage(value) + "}";
					"" + i === expandedName ? (start = objKind.length, length = value.length, objKind += value) : objKind = 15 > value.length && 40 > objKind.length + value.length ? objKind + value : objKind + "{...}";
				}
				objKind += "</" + describeElementType(type) + ">";
			} else {
				objKind = "[";
				for (type = 0; type < objectOrArray.length; type++) 0 < type && (objKind += ", "), i = objectOrArray[type], i = "object" === typeof i && null !== i ? describeObjectForErrorMessage(i) : describeValueForErrorMessage(i), "" + type === expandedName ? (start = objKind.length, length = i.length, objKind += i) : objKind = 10 > i.length && 40 > objKind.length + i.length ? objKind + i : objKind + "...";
				objKind += "]";
			}
			else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE$2) objKind = "<" + describeElementType(objectOrArray.type) + "/>";
			else {
				if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
				if (jsxPropsParents.has(objectOrArray)) {
					objKind = jsxPropsParents.get(objectOrArray);
					objKind = "<" + (describeElementType(objKind) || "...");
					type = Object.keys(objectOrArray);
					for (i = 0; i < type.length; i++) {
						objKind += " ";
						value = type[i];
						objKind += describeKeyForErrorMessage(value) + "=";
						var _value2 = objectOrArray[value];
						var _substr2 = value === expandedName && "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2);
						"string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
						value === expandedName ? (start = objKind.length, length = _substr2.length, objKind += _substr2) : objKind = 10 > _substr2.length && 40 > objKind.length + _substr2.length ? objKind + _substr2 : objKind + "...";
					}
					objKind += ">";
				} else {
					objKind = "{";
					type = Object.keys(objectOrArray);
					for (i = 0; i < type.length; i++) 0 < i && (objKind += ", "), value = type[i], objKind += describeKeyForErrorMessage(value) + ": ", _value2 = objectOrArray[value], _value2 = "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2), value === expandedName ? (start = objKind.length, length = _value2.length, objKind += _value2) : objKind = 10 > _value2.length && 40 > objKind.length + _value2.length ? objKind + _value2 : objKind + "...";
					objKind += "}";
				}
			}
			return void 0 === expandedName ? objKind : -1 < start && 0 < length ? (objectOrArray = " ".repeat(start) + "^".repeat(length), "\n  " + objKind + "\n  " + objectOrArray) : "\n  " + objKind;
		}
		function flushBuffered$1(destination) {
			"function" === typeof destination.flush && destination.flush();
		}
		function writeChunk$1(destination, chunk) {
			if ("string" === typeof chunk) {
				if (0 !== chunk.length) if (2048 < 3 * chunk.length) 0 < writtenBytes$1 && (writeToDestination$1(destination, currentView$1.subarray(0, writtenBytes$1)), currentView$1 = new Uint8Array(2048), writtenBytes$1 = 0), writeToDestination$1(destination, chunk);
				else {
					var target = currentView$1;
					0 < writtenBytes$1 && (target = currentView$1.subarray(writtenBytes$1));
					target = textEncoder$1.encodeInto(chunk, target);
					var read = target.read;
					writtenBytes$1 += target.written;
					read < chunk.length && (writeToDestination$1(destination, currentView$1.subarray(0, writtenBytes$1)), currentView$1 = new Uint8Array(2048), writtenBytes$1 = textEncoder$1.encodeInto(chunk.slice(read), currentView$1).written);
					2048 === writtenBytes$1 && (writeToDestination$1(destination, currentView$1), currentView$1 = new Uint8Array(2048), writtenBytes$1 = 0);
				}
			} else 0 !== chunk.byteLength && (2048 < chunk.byteLength ? (0 < writtenBytes$1 && (writeToDestination$1(destination, currentView$1.subarray(0, writtenBytes$1)), currentView$1 = new Uint8Array(2048), writtenBytes$1 = 0), writeToDestination$1(destination, chunk)) : (target = currentView$1.length - writtenBytes$1, target < chunk.byteLength && (0 === target ? writeToDestination$1(destination, currentView$1) : (currentView$1.set(chunk.subarray(0, target), writtenBytes$1), writtenBytes$1 += target, writeToDestination$1(destination, currentView$1), chunk = chunk.subarray(target)), currentView$1 = new Uint8Array(2048), writtenBytes$1 = 0), currentView$1.set(chunk, writtenBytes$1), writtenBytes$1 += chunk.byteLength, 2048 === writtenBytes$1 && (writeToDestination$1(destination, currentView$1), currentView$1 = new Uint8Array(2048), writtenBytes$1 = 0)));
		}
		function writeToDestination$1(destination, view) {
			destination = destination.write(view);
			destinationHasCapacity$1$1 = destinationHasCapacity$1$1 && destination;
		}
		function writeChunkAndReturn$1(destination, chunk) {
			writeChunk$1(destination, chunk);
			return destinationHasCapacity$1$1;
		}
		function completeWriting$1(destination) {
			currentView$1 && 0 < writtenBytes$1 && destination.write(currentView$1.subarray(0, writtenBytes$1));
			currentView$1 = null;
			writtenBytes$1 = 0;
			destinationHasCapacity$1$1 = !0;
		}
		function stringToPrecomputedChunk$1(content) {
			content = textEncoder$1.encode(content);
			2048 < content.byteLength && console.error("precomputed chunks must be smaller than the view size configured for this host. This is a bug in React.");
			return content;
		}
		function byteLengthOfChunk$1(chunk) {
			return "string" === typeof chunk ? Buffer.byteLength(chunk, "utf8") : chunk.byteLength;
		}
		function typeName(value) {
			return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
		}
		function willCoercionThrow(value) {
			try {
				return testStringCoercion(value), !1;
			} catch (e) {
				return !0;
			}
		}
		function testStringCoercion(value) {
			return "" + value;
		}
		function checkAttributeStringCoercion(value, attributeName) {
			if (willCoercionThrow(value)) return console.error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.", attributeName, typeName(value)), testStringCoercion(value);
		}
		function checkCSSPropertyStringCoercion(value, propName) {
			if (willCoercionThrow(value)) return console.error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.", propName, typeName(value)), testStringCoercion(value);
		}
		function checkHtmlStringCoercion(value) {
			if (willCoercionThrow(value)) return console.error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.", typeName(value)), testStringCoercion(value);
		}
		function isAttributeNameSafe$2(attributeName) {
			if (hasOwnProperty$2.call(validatedAttributeNameCache$2, attributeName)) return !0;
			if (hasOwnProperty$2.call(illegalAttributeNameCache$2, attributeName)) return !1;
			if (VALID_ATTRIBUTE_NAME_REGEX$2.test(attributeName)) return validatedAttributeNameCache$2[attributeName] = !0;
			illegalAttributeNameCache$2[attributeName] = !0;
			console.error("Invalid attribute name: `%s`", attributeName);
			return !1;
		}
		function checkControlledValueProps(tagName, props) {
			hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.") : console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."));
			props.onChange || props.readOnly || props.disabled || null == props.checked || console.error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
		}
		function validateProperty$1(tagName, name) {
			if (hasOwnProperty$2.call(warnedProperties$1, name) && warnedProperties$1[name]) return !0;
			if (rARIACamel$1.test(name)) {
				tagName = "aria-" + name.slice(4).toLowerCase();
				tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
				if (null == tagName) return console.error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name), warnedProperties$1[name] = !0;
				if (name !== tagName) return console.error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, tagName), warnedProperties$1[name] = !0;
			}
			if (rARIA$1.test(name)) {
				tagName = name.toLowerCase();
				tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
				if (null == tagName) return warnedProperties$1[name] = !0, !1;
				name !== tagName && (console.error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, tagName), warnedProperties$1[name] = !0);
			}
			return !0;
		}
		function validateProperties$2(type, props) {
			var invalidProps = [], key;
			for (key in props) validateProperty$1(type, key) || invalidProps.push(key);
			props = invalidProps.map(function(prop) {
				return "`" + prop + "`";
			}).join(", ");
			1 === invalidProps.length ? console.error("Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type) : 1 < invalidProps.length && console.error("Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type);
		}
		function validateProperty(tagName, name, value, eventRegistry) {
			if (hasOwnProperty$2.call(warnedProperties, name) && warnedProperties[name]) return !0;
			var lowerCasedName = name.toLowerCase();
			if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName) return console.error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), warnedProperties[name] = !0;
			if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name)) return !0;
			if (null != eventRegistry) {
				tagName = eventRegistry.possibleRegistrationNames;
				if (eventRegistry.registrationNameDependencies.hasOwnProperty(name)) return !0;
				eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
				if (null != eventRegistry) return console.error("Invalid event handler property `%s`. Did you mean `%s`?", name, eventRegistry), warnedProperties[name] = !0;
				if (EVENT_NAME_REGEX.test(name)) return console.error("Unknown event handler property `%s`. It will be ignored.", name), warnedProperties[name] = !0;
			} else if (EVENT_NAME_REGEX.test(name)) return INVALID_EVENT_NAME_REGEX.test(name) && console.error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name), warnedProperties[name] = !0;
			if (rARIA.test(name) || rARIACamel.test(name)) return !0;
			if ("innerhtml" === lowerCasedName) return console.error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), warnedProperties[name] = !0;
			if ("aria" === lowerCasedName) return console.error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), warnedProperties[name] = !0;
			if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value) return console.error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value), warnedProperties[name] = !0;
			if ("number" === typeof value && isNaN(value)) return console.error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name), warnedProperties[name] = !0;
			if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
				if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name) return console.error("Invalid DOM property `%s`. Did you mean `%s`?", name, lowerCasedName), warnedProperties[name] = !0;
			} else if (name !== lowerCasedName) return console.error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName), warnedProperties[name] = !0;
			switch (name) {
				case "dangerouslySetInnerHTML":
				case "children":
				case "style":
				case "suppressContentEditableWarning":
				case "suppressHydrationWarning":
				case "defaultValue":
				case "defaultChecked":
				case "innerHTML":
				case "ref": return !0;
				case "innerText":
				case "textContent": return !0;
			}
			switch (typeof value) {
				case "boolean": switch (name) {
					case "autoFocus":
					case "checked":
					case "multiple":
					case "muted":
					case "selected":
					case "contentEditable":
					case "spellCheck":
					case "draggable":
					case "value":
					case "autoReverse":
					case "externalResourcesRequired":
					case "focusable":
					case "preserveAlpha":
					case "allowFullScreen":
					case "async":
					case "autoPlay":
					case "controls":
					case "default":
					case "defer":
					case "disabled":
					case "disablePictureInPicture":
					case "disableRemotePlayback":
					case "formNoValidate":
					case "hidden":
					case "loop":
					case "noModule":
					case "noValidate":
					case "open":
					case "playsInline":
					case "readOnly":
					case "required":
					case "reversed":
					case "scoped":
					case "seamless":
					case "itemScope":
					case "capture":
					case "download":
					case "inert": return !0;
					default:
						lowerCasedName = name.toLowerCase().slice(0, 5);
						if ("data-" === lowerCasedName || "aria-" === lowerCasedName) return !0;
						value ? console.error("Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.", value, name, name, value, name) : console.error("Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", value, name, name, value, name, name, name);
						return warnedProperties[name] = !0;
				}
				case "function":
				case "symbol": return warnedProperties[name] = !0, !1;
				case "string": if ("false" === value || "true" === value) {
					switch (name) {
						case "checked":
						case "selected":
						case "multiple":
						case "muted":
						case "allowFullScreen":
						case "async":
						case "autoPlay":
						case "controls":
						case "default":
						case "defer":
						case "disabled":
						case "disablePictureInPicture":
						case "disableRemotePlayback":
						case "formNoValidate":
						case "hidden":
						case "loop":
						case "noModule":
						case "noValidate":
						case "open":
						case "playsInline":
						case "readOnly":
						case "required":
						case "reversed":
						case "scoped":
						case "seamless":
						case "itemScope":
						case "inert": break;
						default: return !0;
					}
					console.error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, "false" === value ? "The browser will interpret it as a truthy value." : "Although this works, it will not work as expected if you pass the string \"false\".", name, value);
					warnedProperties[name] = !0;
				}
			}
			return !0;
		}
		function warnUnknownProperties(type, props, eventRegistry) {
			var unknownProps = [], key;
			for (key in props) validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
			props = unknownProps.map(function(prop) {
				return "`" + prop + "`";
			}).join(", ");
			1 === unknownProps.length ? console.error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type) : 1 < unknownProps.length && console.error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type);
		}
		function camelize(string) {
			return string.replace(hyphenPattern, function(_, character) {
				return character.toUpperCase();
			});
		}
		function escapeTextForBrowser$2(text) {
			if ("boolean" === typeof text || "number" === typeof text || "bigint" === typeof text) return "" + text;
			checkHtmlStringCoercion(text);
			text = "" + text;
			var match = matchHtmlRegExp$2.exec(text);
			if (match) {
				var html = "", index, lastIndex = 0;
				for (index = match.index; index < text.length; index++) {
					switch (text.charCodeAt(index)) {
						case 34:
							match = "&quot;";
							break;
						case 38:
							match = "&amp;";
							break;
						case 39:
							match = "&#x27;";
							break;
						case 60:
							match = "&lt;";
							break;
						case 62:
							match = "&gt;";
							break;
						default: continue;
					}
					lastIndex !== index && (html += text.slice(lastIndex, index));
					lastIndex = index + 1;
					html += match;
				}
				text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;
			}
			return text;
		}
		function sanitizeURL$2(url) {
			return isJavaScriptProtocol$2.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
		}
		function escapeEntireInlineScriptContent(scriptText) {
			checkHtmlStringCoercion(scriptText);
			return ("" + scriptText).replace(scriptRegex$2, scriptReplacer$2);
		}
		function createRenderState$2(resumableState, nonce, externalRuntimeConfig, importMap, onHeaders, maxHeadersLength) {
			externalRuntimeConfig = "string" === typeof nonce ? nonce : nonce && nonce.script;
			var inlineScriptWithNonce = void 0 === externalRuntimeConfig ? startInlineScript$1 : stringToPrecomputedChunk$1("<script nonce=\"" + escapeTextForBrowser$2(externalRuntimeConfig) + "\""), nonceStyle = "string" === typeof nonce ? void 0 : nonce && nonce.style, inlineStyleWithNonce = void 0 === nonceStyle ? startInlineStyle$1 : stringToPrecomputedChunk$1("<style nonce=\"" + escapeTextForBrowser$2(nonceStyle) + "\""), idPrefix = resumableState.idPrefix, bootstrapChunks = [], bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;
			void 0 !== bootstrapScriptContent && (bootstrapChunks.push(inlineScriptWithNonce), pushCompletedShellIdAttribute$2(bootstrapChunks, resumableState), bootstrapChunks.push(endOfStartTag$1, escapeEntireInlineScriptContent(bootstrapScriptContent), endInlineScript$1));
			bootstrapScriptContent = [];
			void 0 !== importMap && (bootstrapScriptContent.push(importMapScriptStart$1), bootstrapScriptContent.push(escapeEntireInlineScriptContent(JSON.stringify(importMap))), bootstrapScriptContent.push(importMapScriptEnd$1));
			onHeaders && "number" === typeof maxHeadersLength && 0 >= maxHeadersLength && console.error("React expected a positive non-zero `maxHeadersLength` option but found %s instead. When using the `onHeaders` option you may supply an optional `maxHeadersLength` option as well however, when setting this value to zero or less no headers will be captured.", 0 === maxHeadersLength ? "zero" : maxHeadersLength);
			importMap = onHeaders ? {
				preconnects: "",
				fontPreloads: "",
				highImagePreloads: "",
				remainingCapacity: 2 + ("number" === typeof maxHeadersLength ? maxHeadersLength : 2e3)
			} : null;
			onHeaders = {
				placeholderPrefix: stringToPrecomputedChunk$1(idPrefix + "P:"),
				segmentPrefix: stringToPrecomputedChunk$1(idPrefix + "S:"),
				boundaryPrefix: stringToPrecomputedChunk$1(idPrefix + "B:"),
				startInlineScript: inlineScriptWithNonce,
				startInlineStyle: inlineStyleWithNonce,
				preamble: createPreambleState$1(),
				externalRuntimeScript: null,
				bootstrapChunks,
				importMapChunks: bootstrapScriptContent,
				onHeaders,
				headers: importMap,
				resets: {
					font: {},
					dns: {},
					connect: {
						default: {},
						anonymous: {},
						credentials: {}
					},
					image: {},
					style: {}
				},
				charsetChunks: [],
				viewportChunks: [],
				hoistableChunks: [],
				preconnects: /* @__PURE__ */ new Set(),
				fontPreloads: /* @__PURE__ */ new Set(),
				highImagePreloads: /* @__PURE__ */ new Set(),
				styles: /* @__PURE__ */ new Map(),
				bootstrapScripts: /* @__PURE__ */ new Set(),
				scripts: /* @__PURE__ */ new Set(),
				bulkPreloads: /* @__PURE__ */ new Set(),
				preloads: {
					images: /* @__PURE__ */ new Map(),
					stylesheets: /* @__PURE__ */ new Map(),
					scripts: /* @__PURE__ */ new Map(),
					moduleScripts: /* @__PURE__ */ new Map()
				},
				nonce: {
					script: externalRuntimeConfig,
					style: nonceStyle
				},
				hoistableState: null,
				stylesToHoist: !1
			};
			if (void 0 !== bootstrapScripts) for (importMap = 0; importMap < bootstrapScripts.length; importMap++) maxHeadersLength = bootstrapScripts[importMap], inlineStyleWithNonce = nonceStyle = void 0, idPrefix = {
				rel: "preload",
				as: "script",
				fetchPriority: "low",
				nonce
			}, "string" === typeof maxHeadersLength ? idPrefix.href = inlineScriptWithNonce = maxHeadersLength : (idPrefix.href = inlineScriptWithNonce = maxHeadersLength.src, idPrefix.integrity = inlineStyleWithNonce = "string" === typeof maxHeadersLength.integrity ? maxHeadersLength.integrity : void 0, idPrefix.crossOrigin = nonceStyle = "string" === typeof maxHeadersLength || null == maxHeadersLength.crossOrigin ? void 0 : "use-credentials" === maxHeadersLength.crossOrigin ? "use-credentials" : ""), preloadBootstrapScriptOrModule(resumableState, onHeaders, inlineScriptWithNonce, idPrefix), bootstrapChunks.push(startScriptSrc$1, escapeTextForBrowser$2(inlineScriptWithNonce), attributeEnd$1), externalRuntimeConfig && bootstrapChunks.push(scriptNonce$1, escapeTextForBrowser$2(externalRuntimeConfig), attributeEnd$1), "string" === typeof inlineStyleWithNonce && bootstrapChunks.push(scriptIntegirty$1, escapeTextForBrowser$2(inlineStyleWithNonce), attributeEnd$1), "string" === typeof nonceStyle && bootstrapChunks.push(scriptCrossOrigin$1, escapeTextForBrowser$2(nonceStyle), attributeEnd$1), pushCompletedShellIdAttribute$2(bootstrapChunks, resumableState), bootstrapChunks.push(endAsyncScript$1);
			if (void 0 !== bootstrapModules) for (nonce = 0; nonce < bootstrapModules.length; nonce++) bootstrapScripts = bootstrapModules[nonce], inlineScriptWithNonce = maxHeadersLength = void 0, nonceStyle = {
				rel: "modulepreload",
				fetchPriority: "low",
				nonce: externalRuntimeConfig
			}, "string" === typeof bootstrapScripts ? nonceStyle.href = importMap = bootstrapScripts : (nonceStyle.href = importMap = bootstrapScripts.src, nonceStyle.integrity = inlineScriptWithNonce = "string" === typeof bootstrapScripts.integrity ? bootstrapScripts.integrity : void 0, nonceStyle.crossOrigin = maxHeadersLength = "string" === typeof bootstrapScripts || null == bootstrapScripts.crossOrigin ? void 0 : "use-credentials" === bootstrapScripts.crossOrigin ? "use-credentials" : ""), preloadBootstrapScriptOrModule(resumableState, onHeaders, importMap, nonceStyle), bootstrapChunks.push(startModuleSrc$1, escapeTextForBrowser$2(importMap), attributeEnd$1), externalRuntimeConfig && bootstrapChunks.push(scriptNonce$1, escapeTextForBrowser$2(externalRuntimeConfig), attributeEnd$1), "string" === typeof inlineScriptWithNonce && bootstrapChunks.push(scriptIntegirty$1, escapeTextForBrowser$2(inlineScriptWithNonce), attributeEnd$1), "string" === typeof maxHeadersLength && bootstrapChunks.push(scriptCrossOrigin$1, escapeTextForBrowser$2(maxHeadersLength), attributeEnd$1), pushCompletedShellIdAttribute$2(bootstrapChunks, resumableState), bootstrapChunks.push(endAsyncScript$1);
			return onHeaders;
		}
		function createResumableState$2(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
			return {
				idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
				nextFormID: 0,
				streamingFormat: 0,
				bootstrapScriptContent,
				bootstrapScripts,
				bootstrapModules,
				instructions: NothingSent,
				hasBody: !1,
				hasHtml: !1,
				unknownResources: {},
				dnsResources: {},
				connectResources: {
					default: {},
					anonymous: {},
					credentials: {}
				},
				imageResources: {},
				styleResources: {},
				scriptResources: {},
				moduleUnknownResources: {},
				moduleScriptResources: {}
			};
		}
		function createPreambleState$1() {
			return {
				htmlChunks: null,
				headChunks: null,
				bodyChunks: null
			};
		}
		function createFormatContext$2(insertionMode, selectedValue, tagScope, viewTransition) {
			return {
				insertionMode,
				selectedValue,
				tagScope,
				viewTransition
			};
		}
		function createRootFormatContext$1(namespaceURI) {
			return createFormatContext$2("http://www.w3.org/2000/svg" === namespaceURI ? SVG_MODE : "http://www.w3.org/1998/Math/MathML" === namespaceURI ? MATHML_MODE : ROOT_HTML_MODE, null, 0, null);
		}
		function getChildFormatContext$2(parentContext, type, props) {
			var subtreeScope = parentContext.tagScope & -25;
			switch (type) {
				case "noscript": return createFormatContext$2(HTML_MODE, null, subtreeScope | 1, null);
				case "select": return createFormatContext$2(HTML_MODE, null != props.value ? props.value : props.defaultValue, subtreeScope, null);
				case "svg": return createFormatContext$2(SVG_MODE, null, subtreeScope, null);
				case "picture": return createFormatContext$2(HTML_MODE, null, subtreeScope | 2, null);
				case "math": return createFormatContext$2(MATHML_MODE, null, subtreeScope, null);
				case "foreignObject": return createFormatContext$2(HTML_MODE, null, subtreeScope, null);
				case "table": return createFormatContext$2(HTML_TABLE_MODE, null, subtreeScope, null);
				case "thead":
				case "tbody":
				case "tfoot": return createFormatContext$2(HTML_TABLE_BODY_MODE, null, subtreeScope, null);
				case "colgroup": return createFormatContext$2(HTML_COLGROUP_MODE, null, subtreeScope, null);
				case "tr": return createFormatContext$2(HTML_TABLE_ROW_MODE, null, subtreeScope, null);
				case "head":
					if (parentContext.insertionMode < HTML_MODE) return createFormatContext$2(HTML_HEAD_MODE, null, subtreeScope, null);
					break;
				case "html": if (parentContext.insertionMode === ROOT_HTML_MODE) return createFormatContext$2(HTML_HTML_MODE, null, subtreeScope, null);
			}
			return parentContext.insertionMode >= HTML_TABLE_MODE || parentContext.insertionMode < HTML_MODE ? createFormatContext$2(HTML_MODE, null, subtreeScope, null) : parentContext.tagScope !== subtreeScope ? createFormatContext$2(parentContext.insertionMode, parentContext.selectedValue, subtreeScope, null) : parentContext;
		}
		function getSuspenseViewTransition$2(parentViewTransition) {
			return null === parentViewTransition ? null : {
				update: parentViewTransition.update,
				enter: "none",
				exit: "none",
				share: parentViewTransition.update,
				name: parentViewTransition.autoName,
				autoName: parentViewTransition.autoName,
				nameIdx: 0
			};
		}
		function getSuspenseFallbackFormatContext$2(resumableState, parentContext) {
			parentContext.tagScope & 32 && (resumableState.instructions |= 128);
			return createFormatContext$2(parentContext.insertionMode, parentContext.selectedValue, parentContext.tagScope | 12, getSuspenseViewTransition$2(parentContext.viewTransition));
		}
		function getSuspenseContentFormatContext$2(resumableState, parentContext) {
			resumableState = getSuspenseViewTransition$2(parentContext.viewTransition);
			var subtreeScope = parentContext.tagScope | 16;
			null !== resumableState && "none" !== resumableState.share && (subtreeScope |= 64);
			return createFormatContext$2(parentContext.insertionMode, parentContext.selectedValue, subtreeScope, resumableState);
		}
		function pushTextInstance$2(target, text, renderState, textEmbedded) {
			if ("" === text) return textEmbedded;
			textEmbedded && target.push(textSeparator$1);
			target.push(escapeTextForBrowser$2(text));
			return !0;
		}
		function pushStyleAttribute$2(target, style) {
			if ("object" !== typeof style) throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
			var isFirst = !0, styleName;
			for (styleName in style) if (hasOwnProperty$2.call(style, styleName)) {
				var styleValue = style[styleName];
				if (null != styleValue && "boolean" !== typeof styleValue && "" !== styleValue) {
					if (0 === styleName.indexOf("--")) {
						var nameChunk = escapeTextForBrowser$2(styleName);
						checkCSSPropertyStringCoercion(styleValue, styleName);
						styleValue = escapeTextForBrowser$2(("" + styleValue).trim());
					} else {
						nameChunk = styleName;
						var value = styleValue;
						if (-1 < nameChunk.indexOf("-")) {
							var name = nameChunk;
							warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = !0, console.error("Unsupported style property %s. Did you mean %s?", name, camelize(name.replace(msPattern$1$1, "ms-"))));
						} else if (badVendoredStyleNamePattern.test(nameChunk)) name = nameChunk, warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = !0, console.error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1)));
						else if (badStyleValueWithSemicolonPattern.test(value)) {
							name = nameChunk;
							var value$jscomp$0 = value;
							warnedStyleValues.hasOwnProperty(value$jscomp$0) && warnedStyleValues[value$jscomp$0] || (warnedStyleValues[value$jscomp$0] = !0, console.error("Style property values shouldn't contain a semicolon. Try \"%s: %s\" instead.", name, value$jscomp$0.replace(badStyleValueWithSemicolonPattern, "")));
						}
						"number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = !0, console.error("`NaN` is an invalid value for the `%s` css style property.", nameChunk)) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = !0, console.error("`Infinity` is an invalid value for the `%s` css style property.", nameChunk)));
						nameChunk = styleName;
						value = styleNameCache$2.get(nameChunk);
						void 0 !== value ? nameChunk = value : (value = stringToPrecomputedChunk$1(escapeTextForBrowser$2(nameChunk.replace(uppercasePattern$2, "-$1").toLowerCase().replace(msPattern$2, "-ms-"))), styleNameCache$2.set(nameChunk, value), nameChunk = value);
						"number" === typeof styleValue ? styleValue = 0 === styleValue || unitlessNumbers$2.has(styleName) ? "" + styleValue : styleValue + "px" : (checkCSSPropertyStringCoercion(styleValue, styleName), styleValue = escapeTextForBrowser$2(("" + styleValue).trim()));
					}
					isFirst ? (isFirst = !1, target.push(styleAttributeStart$1, nameChunk, styleAssign$1, styleValue)) : target.push(styleSeparator$1, nameChunk, styleAssign$1, styleValue);
				}
			}
			isFirst || target.push(attributeEnd$1);
		}
		function pushBooleanAttribute$2(target, name, value) {
			value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator$1, name, attributeEmptyString$1);
		}
		function pushStringAttribute$2(target, name, value) {
			"function" !== typeof value && "symbol" !== typeof value && "boolean" !== typeof value && target.push(attributeSeparator$1, name, attributeAssign$1, escapeTextForBrowser$2(value), attributeEnd$1);
		}
		function pushAdditionalFormField$2(value, key) {
			this.push(startHiddenInputChunk$1);
			validateAdditionalFormField$2(value);
			pushStringAttribute$2(this, "name", key);
			pushStringAttribute$2(this, "value", value);
			this.push(endOfStartTagSelfClosing$1);
		}
		function validateAdditionalFormField$2(value) {
			if ("string" !== typeof value) throw Error("File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration.");
		}
		function getCustomFormFields$2(resumableState, formAction) {
			if ("function" === typeof formAction.$$FORM_ACTION) {
				var id = resumableState.nextFormID++;
				resumableState = resumableState.idPrefix + id;
				try {
					var customFields = formAction.$$FORM_ACTION(resumableState);
					if (customFields) customFields.data?.forEach(validateAdditionalFormField$2);
					return customFields;
				} catch (x) {
					if ("object" === typeof x && null !== x && "function" === typeof x.then) throw x;
					console.error("Failed to serialize an action for progressive enhancement:\n%s", x);
				}
			}
			return null;
		}
		function pushFormActionAttribute$2(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name) {
			var formData = null;
			if ("function" === typeof formAction) {
				null === name || didWarnFormActionName || (didWarnFormActionName = !0, console.error("Cannot specify a \"name\" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden."));
				null === formEncType && null === formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = !0, console.error("Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."));
				null === formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = !0, console.error("Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."));
				var customFields = getCustomFormFields$2(resumableState, formAction);
				null !== customFields ? (name = customFields.name, formAction = customFields.action || "", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(attributeSeparator$1, "formAction", attributeAssign$1, actionJavaScriptURL$2, attributeEnd$1), formTarget = formMethod = formEncType = formAction = name = null, injectFormReplayingRuntime$2(resumableState, renderState));
			}
			null != name && pushAttribute$2(target, "name", name);
			null != formAction && pushAttribute$2(target, "formAction", formAction);
			null != formEncType && pushAttribute$2(target, "formEncType", formEncType);
			null != formMethod && pushAttribute$2(target, "formMethod", formMethod);
			null != formTarget && pushAttribute$2(target, "formTarget", formTarget);
			return formData;
		}
		function pushAttribute$2(target, name, value) {
			switch (name) {
				case "className":
					pushStringAttribute$2(target, "class", value);
					break;
				case "tabIndex":
					pushStringAttribute$2(target, "tabindex", value);
					break;
				case "dir":
				case "role":
				case "viewBox":
				case "width":
				case "height":
					pushStringAttribute$2(target, name, value);
					break;
				case "style":
					pushStyleAttribute$2(target, value);
					break;
				case "src":
				case "href": if ("" === value) {
					"src" === name ? console.error("An empty string (\"\") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.", name, name) : console.error("An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.", name, name);
					break;
				}
				case "action":
				case "formAction":
					if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) break;
					checkAttributeStringCoercion(value, name);
					value = sanitizeURL$2("" + value);
					target.push(attributeSeparator$1, name, attributeAssign$1, escapeTextForBrowser$2(value), attributeEnd$1);
					break;
				case "defaultValue":
				case "defaultChecked":
				case "innerHTML":
				case "suppressContentEditableWarning":
				case "suppressHydrationWarning":
				case "ref": break;
				case "autoFocus":
				case "multiple":
				case "muted":
					pushBooleanAttribute$2(target, name.toLowerCase(), value);
					break;
				case "xlinkHref":
					if ("function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) break;
					checkAttributeStringCoercion(value, name);
					value = sanitizeURL$2("" + value);
					target.push(attributeSeparator$1, "xlink:href", attributeAssign$1, escapeTextForBrowser$2(value), attributeEnd$1);
					break;
				case "contentEditable":
				case "spellCheck":
				case "draggable":
				case "value":
				case "autoReverse":
				case "externalResourcesRequired":
				case "focusable":
				case "preserveAlpha":
					"function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator$1, name, attributeAssign$1, escapeTextForBrowser$2(value), attributeEnd$1);
					break;
				case "inert": "" !== value || didWarnForNewBooleanPropsWithEmptyValue[name] || (didWarnForNewBooleanPropsWithEmptyValue[name] = !0, console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.", name));
				case "allowFullScreen":
				case "async":
				case "autoPlay":
				case "controls":
				case "default":
				case "defer":
				case "disabled":
				case "disablePictureInPicture":
				case "disableRemotePlayback":
				case "formNoValidate":
				case "hidden":
				case "loop":
				case "noModule":
				case "noValidate":
				case "open":
				case "playsInline":
				case "readOnly":
				case "required":
				case "reversed":
				case "scoped":
				case "seamless":
				case "itemScope":
					value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator$1, name, attributeEmptyString$1);
					break;
				case "capture":
				case "download":
					!0 === value ? target.push(attributeSeparator$1, name, attributeEmptyString$1) : !1 !== value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator$1, name, attributeAssign$1, escapeTextForBrowser$2(value), attributeEnd$1);
					break;
				case "cols":
				case "rows":
				case "size":
				case "span":
					"function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value && target.push(attributeSeparator$1, name, attributeAssign$1, escapeTextForBrowser$2(value), attributeEnd$1);
					break;
				case "rowSpan":
				case "start":
					"function" === typeof value || "symbol" === typeof value || isNaN(value) || target.push(attributeSeparator$1, name, attributeAssign$1, escapeTextForBrowser$2(value), attributeEnd$1);
					break;
				case "xlinkActuate":
					pushStringAttribute$2(target, "xlink:actuate", value);
					break;
				case "xlinkArcrole":
					pushStringAttribute$2(target, "xlink:arcrole", value);
					break;
				case "xlinkRole":
					pushStringAttribute$2(target, "xlink:role", value);
					break;
				case "xlinkShow":
					pushStringAttribute$2(target, "xlink:show", value);
					break;
				case "xlinkTitle":
					pushStringAttribute$2(target, "xlink:title", value);
					break;
				case "xlinkType":
					pushStringAttribute$2(target, "xlink:type", value);
					break;
				case "xmlBase":
					pushStringAttribute$2(target, "xml:base", value);
					break;
				case "xmlLang":
					pushStringAttribute$2(target, "xml:lang", value);
					break;
				case "xmlSpace":
					pushStringAttribute$2(target, "xml:space", value);
					break;
				default: if (!(2 < name.length) || "o" !== name[0] && "O" !== name[0] || "n" !== name[1] && "N" !== name[1]) {
					if (name = aliases$2.get(name) || name, isAttributeNameSafe$2(name)) {
						switch (typeof value) {
							case "function":
							case "symbol": return;
							case "boolean":
								var prefix$3 = name.toLowerCase().slice(0, 5);
								if ("data-" !== prefix$3 && "aria-" !== prefix$3) return;
						}
						target.push(attributeSeparator$1, name, attributeAssign$1, escapeTextForBrowser$2(value), attributeEnd$1);
					}
				}
			}
		}
		function pushInnerHTML$2(target, innerHTML, children) {
			if (null != innerHTML) {
				if (null != children) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
				if ("object" !== typeof innerHTML || !("__html" in innerHTML)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
				innerHTML = innerHTML.__html;
				null !== innerHTML && void 0 !== innerHTML && (checkHtmlStringCoercion(innerHTML), target.push("" + innerHTML));
			}
		}
		function checkSelectProp(props, propName) {
			var value = props[propName];
			null != value && (value = isArrayImpl$2(value), props.multiple && !value ? console.error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName) : !props.multiple && value && console.error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName));
		}
		function flattenOptionChildren$2(children) {
			var content = "";
			React$3.Children.forEach(children, function(child) {
				null != child && (content += child, didWarnInvalidOptionChildren || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || (didWarnInvalidOptionChildren = !0, console.error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
			});
			return content;
		}
		function injectFormReplayingRuntime$2(resumableState, renderState) {
			if ((resumableState.instructions & 16) === NothingSent) {
				resumableState.instructions |= 16;
				var preamble = renderState.preamble, bootstrapChunks = renderState.bootstrapChunks;
				(preamble.htmlChunks || preamble.headChunks) && 0 === bootstrapChunks.length ? (bootstrapChunks.push(renderState.startInlineScript), pushCompletedShellIdAttribute$2(bootstrapChunks, resumableState), bootstrapChunks.push(endOfStartTag$1, formReplayingRuntimeScript$1, endInlineScript$1)) : bootstrapChunks.unshift(renderState.startInlineScript, endOfStartTag$1, formReplayingRuntimeScript$1, endInlineScript$1);
			}
		}
		function pushLinkImpl$2(target, props) {
			target.push(startChunkForTag$2("link"));
			for (var propKey in props) if (hasOwnProperty$2.call(props, propKey)) {
				var propValue = props[propKey];
				if (null != propValue) switch (propKey) {
					case "children":
					case "dangerouslySetInnerHTML": throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
					default: pushAttribute$2(target, propKey, propValue);
				}
			}
			target.push(endOfStartTagSelfClosing$1);
			return null;
		}
		function escapeStyleTextContent(styleText) {
			checkHtmlStringCoercion(styleText);
			return ("" + styleText).replace(styleRegex$2, styleReplacer$2);
		}
		function pushSelfClosing$2(target, props, tag) {
			target.push(startChunkForTag$2(tag));
			for (var propKey in props) if (hasOwnProperty$2.call(props, propKey)) {
				var propValue = props[propKey];
				if (null != propValue) switch (propKey) {
					case "children":
					case "dangerouslySetInnerHTML": throw Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
					default: pushAttribute$2(target, propKey, propValue);
				}
			}
			target.push(endOfStartTagSelfClosing$1);
			return null;
		}
		function pushTitleImpl$2(target, props) {
			target.push(startChunkForTag$2("title"));
			var children = null, innerHTML = null, propKey;
			for (propKey in props) if (hasOwnProperty$2.call(props, propKey)) {
				var propValue = props[propKey];
				if (null != propValue) switch (propKey) {
					case "children":
						children = propValue;
						break;
					case "dangerouslySetInnerHTML":
						innerHTML = propValue;
						break;
					default: pushAttribute$2(target, propKey, propValue);
				}
			}
			target.push(endOfStartTag$1);
			props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;
			"function" !== typeof props && "symbol" !== typeof props && null !== props && void 0 !== props && target.push(escapeTextForBrowser$2("" + props));
			pushInnerHTML$2(target, innerHTML, children);
			target.push(endChunkForTag$2("title"));
			return null;
		}
		function pushScriptImpl$2(target, props) {
			target.push(startChunkForTag$2("script"));
			var children = null, innerHTML = null, propKey;
			for (propKey in props) if (hasOwnProperty$2.call(props, propKey)) {
				var propValue = props[propKey];
				if (null != propValue) switch (propKey) {
					case "children":
						children = propValue;
						break;
					case "dangerouslySetInnerHTML":
						innerHTML = propValue;
						break;
					default: pushAttribute$2(target, propKey, propValue);
				}
			}
			target.push(endOfStartTag$1);
			null != children && "string" !== typeof children && (props = "number" === typeof children ? "a number for children" : Array.isArray(children) ? "an array for children" : "something unexpected for children", console.error("A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.", props));
			pushInnerHTML$2(target, innerHTML, children);
			"string" === typeof children && target.push(escapeEntireInlineScriptContent(children));
			target.push(endChunkForTag$2("script"));
			return null;
		}
		function pushStartSingletonElement$2(target, props, tag) {
			target.push(startChunkForTag$2(tag));
			var innerHTML = tag = null, propKey;
			for (propKey in props) if (hasOwnProperty$2.call(props, propKey)) {
				var propValue = props[propKey];
				if (null != propValue) switch (propKey) {
					case "children":
						tag = propValue;
						break;
					case "dangerouslySetInnerHTML":
						innerHTML = propValue;
						break;
					default: pushAttribute$2(target, propKey, propValue);
				}
			}
			target.push(endOfStartTag$1);
			pushInnerHTML$2(target, innerHTML, tag);
			return tag;
		}
		function pushStartGenericElement$2(target, props, tag) {
			target.push(startChunkForTag$2(tag));
			var innerHTML = tag = null, propKey;
			for (propKey in props) if (hasOwnProperty$2.call(props, propKey)) {
				var propValue = props[propKey];
				if (null != propValue) switch (propKey) {
					case "children":
						tag = propValue;
						break;
					case "dangerouslySetInnerHTML":
						innerHTML = propValue;
						break;
					default: pushAttribute$2(target, propKey, propValue);
				}
			}
			target.push(endOfStartTag$1);
			pushInnerHTML$2(target, innerHTML, tag);
			return "string" === typeof tag ? (target.push(escapeTextForBrowser$2(tag)), null) : tag;
		}
		function startChunkForTag$2(tag) {
			var tagStartChunk = validatedTagCache$2.get(tag);
			if (void 0 === tagStartChunk) {
				if (!VALID_TAG_REGEX$2.test(tag)) throw Error("Invalid tag: " + tag);
				tagStartChunk = stringToPrecomputedChunk$1("<" + tag);
				validatedTagCache$2.set(tag, tagStartChunk);
			}
			return tagStartChunk;
		}
		function pushStartInstance$2(target$jscomp$0, type, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded) {
			validateProperties$2(type, props);
			"input" !== type && "textarea" !== type && "select" !== type || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = !0, "select" === type && props.multiple ? console.error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type) : console.error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type));
			b: if (-1 === type.indexOf("-")) var JSCompiler_inline_result = !1;
			else switch (type) {
				case "annotation-xml":
				case "color-profile":
				case "font-face":
				case "font-face-src":
				case "font-face-uri":
				case "font-face-format":
				case "font-face-name":
				case "missing-glyph":
					JSCompiler_inline_result = !1;
					break b;
				default: JSCompiler_inline_result = !0;
			}
			JSCompiler_inline_result || "string" === typeof props.is || warnUnknownProperties(type, props, null);
			!props.suppressContentEditableWarning && props.contentEditable && null != props.children && console.error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
			formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE && -1 === type.indexOf("-") && type.toLowerCase() !== type && console.error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
			switch (type) {
				case "div":
				case "span":
				case "svg":
				case "path": break;
				case "a":
					target$jscomp$0.push(startChunkForTag$2("a"));
					var children = null, innerHTML = null, propKey;
					for (propKey in props) if (hasOwnProperty$2.call(props, propKey)) {
						var propValue = props[propKey];
						if (null != propValue) switch (propKey) {
							case "children":
								children = propValue;
								break;
							case "dangerouslySetInnerHTML":
								innerHTML = propValue;
								break;
							case "href":
								"" === propValue ? pushStringAttribute$2(target$jscomp$0, "href", "") : pushAttribute$2(target$jscomp$0, propKey, propValue);
								break;
							default: pushAttribute$2(target$jscomp$0, propKey, propValue);
						}
					}
					target$jscomp$0.push(endOfStartTag$1);
					pushInnerHTML$2(target$jscomp$0, innerHTML, children);
					if ("string" === typeof children) {
						target$jscomp$0.push(escapeTextForBrowser$2(children));
						var JSCompiler_inline_result$jscomp$0 = null;
					} else JSCompiler_inline_result$jscomp$0 = children;
					return JSCompiler_inline_result$jscomp$0;
				case "g":
				case "p":
				case "li": break;
				case "select":
					checkControlledValueProps("select", props);
					checkSelectProp(props, "value");
					checkSelectProp(props, "defaultValue");
					void 0 === props.value || void 0 === props.defaultValue || didWarnDefaultSelectValue || (console.error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"), didWarnDefaultSelectValue = !0);
					target$jscomp$0.push(startChunkForTag$2("select"));
					var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;
					for (propKey$jscomp$0 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$0)) {
						var propValue$jscomp$0 = props[propKey$jscomp$0];
						if (null != propValue$jscomp$0) switch (propKey$jscomp$0) {
							case "children":
								children$jscomp$0 = propValue$jscomp$0;
								break;
							case "dangerouslySetInnerHTML":
								innerHTML$jscomp$0 = propValue$jscomp$0;
								break;
							case "defaultValue":
							case "value": break;
							default: pushAttribute$2(target$jscomp$0, propKey$jscomp$0, propValue$jscomp$0);
						}
					}
					target$jscomp$0.push(endOfStartTag$1);
					pushInnerHTML$2(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);
					return children$jscomp$0;
				case "option":
					var selectedValue = formatContext.selectedValue;
					target$jscomp$0.push(startChunkForTag$2("option"));
					var children$jscomp$1 = null, value = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;
					for (propKey$jscomp$1 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$1)) {
						var propValue$jscomp$1 = props[propKey$jscomp$1];
						if (null != propValue$jscomp$1) switch (propKey$jscomp$1) {
							case "children":
								children$jscomp$1 = propValue$jscomp$1;
								break;
							case "selected":
								selected = propValue$jscomp$1;
								didWarnSelectedSetOnOption || (console.error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), didWarnSelectedSetOnOption = !0);
								break;
							case "dangerouslySetInnerHTML":
								innerHTML$jscomp$1 = propValue$jscomp$1;
								break;
							case "value": value = propValue$jscomp$1;
							default: pushAttribute$2(target$jscomp$0, propKey$jscomp$1, propValue$jscomp$1);
						}
					}
					if (null != selectedValue) {
						if (null !== value) {
							checkAttributeStringCoercion(value, "value");
							var stringValue = "" + value;
						} else null === innerHTML$jscomp$1 || didWarnInvalidOptionInnerHTML || (didWarnInvalidOptionInnerHTML = !0, console.error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")), stringValue = flattenOptionChildren$2(children$jscomp$1);
						if (isArrayImpl$2(selectedValue)) {
							for (var i = 0; i < selectedValue.length; i++) if (checkAttributeStringCoercion(selectedValue[i], "value"), "" + selectedValue[i] === stringValue) {
								target$jscomp$0.push(selectedMarkerAttribute$1);
								break;
							}
						} else checkAttributeStringCoercion(selectedValue, "select.value"), "" + selectedValue === stringValue && target$jscomp$0.push(selectedMarkerAttribute$1);
					} else selected && target$jscomp$0.push(selectedMarkerAttribute$1);
					target$jscomp$0.push(endOfStartTag$1);
					pushInnerHTML$2(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);
					return children$jscomp$1;
				case "textarea":
					checkControlledValueProps("textarea", props);
					void 0 === props.value || void 0 === props.defaultValue || didWarnDefaultTextareaValue || (console.error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components"), didWarnDefaultTextareaValue = !0);
					target$jscomp$0.push(startChunkForTag$2("textarea"));
					var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;
					for (propKey$jscomp$2 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$2)) {
						var propValue$jscomp$2 = props[propKey$jscomp$2];
						if (null != propValue$jscomp$2) switch (propKey$jscomp$2) {
							case "children":
								children$jscomp$2 = propValue$jscomp$2;
								break;
							case "value":
								value$jscomp$0 = propValue$jscomp$2;
								break;
							case "defaultValue":
								defaultValue = propValue$jscomp$2;
								break;
							case "dangerouslySetInnerHTML": throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
							default: pushAttribute$2(target$jscomp$0, propKey$jscomp$2, propValue$jscomp$2);
						}
					}
					null === value$jscomp$0 && null !== defaultValue && (value$jscomp$0 = defaultValue);
					target$jscomp$0.push(endOfStartTag$1);
					if (null != children$jscomp$2) {
						console.error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
						if (null != value$jscomp$0) throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
						if (isArrayImpl$2(children$jscomp$2)) {
							if (1 < children$jscomp$2.length) throw Error("<textarea> can only have at most one child.");
							checkHtmlStringCoercion(children$jscomp$2[0]);
							value$jscomp$0 = "" + children$jscomp$2[0];
						}
						checkHtmlStringCoercion(children$jscomp$2);
						value$jscomp$0 = "" + children$jscomp$2;
					}
					"string" === typeof value$jscomp$0 && "\n" === value$jscomp$0[0] && target$jscomp$0.push(leadingNewline$1);
					null !== value$jscomp$0 && (checkAttributeStringCoercion(value$jscomp$0, "value"), target$jscomp$0.push(escapeTextForBrowser$2("" + value$jscomp$0)));
					return null;
				case "input":
					checkControlledValueProps("input", props);
					target$jscomp$0.push(startChunkForTag$2("input"));
					var name = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;
					for (propKey$jscomp$3 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$3)) {
						var propValue$jscomp$3 = props[propKey$jscomp$3];
						if (null != propValue$jscomp$3) switch (propKey$jscomp$3) {
							case "children":
							case "dangerouslySetInnerHTML": throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
							case "name":
								name = propValue$jscomp$3;
								break;
							case "formAction":
								formAction = propValue$jscomp$3;
								break;
							case "formEncType":
								formEncType = propValue$jscomp$3;
								break;
							case "formMethod":
								formMethod = propValue$jscomp$3;
								break;
							case "formTarget":
								formTarget = propValue$jscomp$3;
								break;
							case "defaultChecked":
								defaultChecked = propValue$jscomp$3;
								break;
							case "defaultValue":
								defaultValue$jscomp$0 = propValue$jscomp$3;
								break;
							case "checked":
								checked = propValue$jscomp$3;
								break;
							case "value":
								value$jscomp$1 = propValue$jscomp$3;
								break;
							default: pushAttribute$2(target$jscomp$0, propKey$jscomp$3, propValue$jscomp$3);
						}
					}
					null === formAction || "image" === props.type || "submit" === props.type || didWarnFormActionType || (didWarnFormActionType = !0, console.error("An input can only specify a formAction along with type=\"submit\" or type=\"image\"."));
					var formData = pushFormActionAttribute$2(target$jscomp$0, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name);
					null === checked || null === defaultChecked || didWarnDefaultChecked || (console.error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", "A component", props.type), didWarnDefaultChecked = !0);
					null === value$jscomp$1 || null === defaultValue$jscomp$0 || didWarnDefaultInputValue || (console.error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", "A component", props.type), didWarnDefaultInputValue = !0);
					null !== checked ? pushBooleanAttribute$2(target$jscomp$0, "checked", checked) : null !== defaultChecked && pushBooleanAttribute$2(target$jscomp$0, "checked", defaultChecked);
					null !== value$jscomp$1 ? pushAttribute$2(target$jscomp$0, "value", value$jscomp$1) : null !== defaultValue$jscomp$0 && pushAttribute$2(target$jscomp$0, "value", defaultValue$jscomp$0);
					target$jscomp$0.push(endOfStartTagSelfClosing$1);
					formData?.forEach(pushAdditionalFormField$2, target$jscomp$0);
					return null;
				case "button":
					target$jscomp$0.push(startChunkForTag$2("button"));
					var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;
					for (propKey$jscomp$4 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$4)) {
						var propValue$jscomp$4 = props[propKey$jscomp$4];
						if (null != propValue$jscomp$4) switch (propKey$jscomp$4) {
							case "children":
								children$jscomp$3 = propValue$jscomp$4;
								break;
							case "dangerouslySetInnerHTML":
								innerHTML$jscomp$2 = propValue$jscomp$4;
								break;
							case "name":
								name$jscomp$0 = propValue$jscomp$4;
								break;
							case "formAction":
								formAction$jscomp$0 = propValue$jscomp$4;
								break;
							case "formEncType":
								formEncType$jscomp$0 = propValue$jscomp$4;
								break;
							case "formMethod":
								formMethod$jscomp$0 = propValue$jscomp$4;
								break;
							case "formTarget":
								formTarget$jscomp$0 = propValue$jscomp$4;
								break;
							default: pushAttribute$2(target$jscomp$0, propKey$jscomp$4, propValue$jscomp$4);
						}
					}
					null === formAction$jscomp$0 || null == props.type || "submit" === props.type || didWarnFormActionType || (didWarnFormActionType = !0, console.error("A button can only specify a formAction along with type=\"submit\" or no type."));
					var formData$jscomp$0 = pushFormActionAttribute$2(target$jscomp$0, resumableState, renderState, formAction$jscomp$0, formEncType$jscomp$0, formMethod$jscomp$0, formTarget$jscomp$0, name$jscomp$0);
					target$jscomp$0.push(endOfStartTag$1);
					formData$jscomp$0?.forEach(pushAdditionalFormField$2, target$jscomp$0);
					pushInnerHTML$2(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);
					if ("string" === typeof children$jscomp$3) {
						target$jscomp$0.push(escapeTextForBrowser$2(children$jscomp$3));
						var JSCompiler_inline_result$jscomp$1 = null;
					} else JSCompiler_inline_result$jscomp$1 = children$jscomp$3;
					return JSCompiler_inline_result$jscomp$1;
				case "form":
					target$jscomp$0.push(startChunkForTag$2("form"));
					var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;
					for (propKey$jscomp$5 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$5)) {
						var propValue$jscomp$5 = props[propKey$jscomp$5];
						if (null != propValue$jscomp$5) switch (propKey$jscomp$5) {
							case "children":
								children$jscomp$4 = propValue$jscomp$5;
								break;
							case "dangerouslySetInnerHTML":
								innerHTML$jscomp$3 = propValue$jscomp$5;
								break;
							case "action":
								formAction$jscomp$1 = propValue$jscomp$5;
								break;
							case "encType":
								formEncType$jscomp$1 = propValue$jscomp$5;
								break;
							case "method":
								formMethod$jscomp$1 = propValue$jscomp$5;
								break;
							case "target":
								formTarget$jscomp$1 = propValue$jscomp$5;
								break;
							default: pushAttribute$2(target$jscomp$0, propKey$jscomp$5, propValue$jscomp$5);
						}
					}
					var formData$jscomp$1 = null, formActionName = null;
					if ("function" === typeof formAction$jscomp$1) {
						null === formEncType$jscomp$1 && null === formMethod$jscomp$1 || didWarnFormActionMethod || (didWarnFormActionMethod = !0, console.error("Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."));
						null === formTarget$jscomp$1 || didWarnFormActionTarget || (didWarnFormActionTarget = !0, console.error("Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."));
						var customFields = getCustomFormFields$2(resumableState, formAction$jscomp$1);
						null !== customFields ? (formAction$jscomp$1 = customFields.action || "", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(attributeSeparator$1, "action", attributeAssign$1, actionJavaScriptURL$2, attributeEnd$1), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime$2(resumableState, renderState));
					}
					null != formAction$jscomp$1 && pushAttribute$2(target$jscomp$0, "action", formAction$jscomp$1);
					null != formEncType$jscomp$1 && pushAttribute$2(target$jscomp$0, "encType", formEncType$jscomp$1);
					null != formMethod$jscomp$1 && pushAttribute$2(target$jscomp$0, "method", formMethod$jscomp$1);
					null != formTarget$jscomp$1 && pushAttribute$2(target$jscomp$0, "target", formTarget$jscomp$1);
					target$jscomp$0.push(endOfStartTag$1);
					null !== formActionName && (target$jscomp$0.push(startHiddenInputChunk$1), pushStringAttribute$2(target$jscomp$0, "name", formActionName), target$jscomp$0.push(endOfStartTagSelfClosing$1), formData$jscomp$1?.forEach(pushAdditionalFormField$2, target$jscomp$0));
					pushInnerHTML$2(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);
					if ("string" === typeof children$jscomp$4) {
						target$jscomp$0.push(escapeTextForBrowser$2(children$jscomp$4));
						var JSCompiler_inline_result$jscomp$2 = null;
					} else JSCompiler_inline_result$jscomp$2 = children$jscomp$4;
					return JSCompiler_inline_result$jscomp$2;
				case "menuitem":
					target$jscomp$0.push(startChunkForTag$2("menuitem"));
					for (var propKey$jscomp$6 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$6)) {
						var propValue$jscomp$6 = props[propKey$jscomp$6];
						if (null != propValue$jscomp$6) switch (propKey$jscomp$6) {
							case "children":
							case "dangerouslySetInnerHTML": throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
							default: pushAttribute$2(target$jscomp$0, propKey$jscomp$6, propValue$jscomp$6);
						}
					}
					target$jscomp$0.push(endOfStartTag$1);
					return null;
				case "object":
					target$jscomp$0.push(startChunkForTag$2("object"));
					var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;
					for (propKey$jscomp$7 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$7)) {
						var propValue$jscomp$7 = props[propKey$jscomp$7];
						if (null != propValue$jscomp$7) switch (propKey$jscomp$7) {
							case "children":
								children$jscomp$5 = propValue$jscomp$7;
								break;
							case "dangerouslySetInnerHTML":
								innerHTML$jscomp$4 = propValue$jscomp$7;
								break;
							case "data":
								checkAttributeStringCoercion(propValue$jscomp$7, "data");
								var sanitizedValue = sanitizeURL$2("" + propValue$jscomp$7);
								if ("" === sanitizedValue) {
									console.error("An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.", propKey$jscomp$7, propKey$jscomp$7);
									break;
								}
								target$jscomp$0.push(attributeSeparator$1, "data", attributeAssign$1, escapeTextForBrowser$2(sanitizedValue), attributeEnd$1);
								break;
							default: pushAttribute$2(target$jscomp$0, propKey$jscomp$7, propValue$jscomp$7);
						}
					}
					target$jscomp$0.push(endOfStartTag$1);
					pushInnerHTML$2(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);
					if ("string" === typeof children$jscomp$5) {
						target$jscomp$0.push(escapeTextForBrowser$2(children$jscomp$5));
						var JSCompiler_inline_result$jscomp$3 = null;
					} else JSCompiler_inline_result$jscomp$3 = children$jscomp$5;
					return JSCompiler_inline_result$jscomp$3;
				case "title":
					var noscriptTagInScope = formatContext.tagScope & 1, isFallback = formatContext.tagScope & 4;
					if (hasOwnProperty$2.call(props, "children")) {
						var children$jscomp$6 = props.children, child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;
						Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length ? console.error("React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be common to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.", children$jscomp$6.length) : "function" === typeof child || "symbol" === typeof child ? console.error("React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.", "function" === typeof child ? "a Function" : "a Sybmol") : child && child.toString === {}.toString && (null != child.$$typeof ? console.error("React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML.") : console.error("React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>."));
					}
					if (formatContext.insertionMode === SVG_MODE || noscriptTagInScope || null != props.itemProp) var JSCompiler_inline_result$jscomp$4 = pushTitleImpl$2(target$jscomp$0, props);
					else isFallback ? JSCompiler_inline_result$jscomp$4 = null : (pushTitleImpl$2(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$4 = void 0);
					return JSCompiler_inline_result$jscomp$4;
				case "link":
					var noscriptTagInScope$jscomp$0 = formatContext.tagScope & 1, isFallback$jscomp$0 = formatContext.tagScope & 4, rel = props.rel, href = props.href, precedence = props.precedence;
					if (formatContext.insertionMode === SVG_MODE || noscriptTagInScope$jscomp$0 || null != props.itemProp || "string" !== typeof rel || "string" !== typeof href || "" === href) {
						"stylesheet" === rel && "string" === typeof props.precedence && ("string" === typeof href && href || console.error("React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.", null === href ? "`null`" : void 0 === href ? "`undefined`" : "" === href ? "an empty string" : "something with type \"" + typeof href + "\""));
						pushLinkImpl$2(target$jscomp$0, props);
						var JSCompiler_inline_result$jscomp$5 = null;
					} else if ("stylesheet" === props.rel) if ("string" !== typeof precedence || null != props.disabled || props.onLoad || props.onError) {
						if ("string" === typeof precedence) {
							if (null != props.disabled) console.error("React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.");
							else if (props.onLoad || props.onError) {
								var propDescription = props.onLoad && props.onError ? "`onLoad` and `onError` props" : props.onLoad ? "`onLoad` prop" : "`onError` prop";
								console.error("React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.", propDescription, propDescription);
							}
						}
						JSCompiler_inline_result$jscomp$5 = pushLinkImpl$2(target$jscomp$0, props);
					} else {
						var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
						if (resourceState !== EXISTS) {
							resumableState.styleResources[href] = EXISTS;
							styleQueue || (styleQueue = {
								precedence: escapeTextForBrowser$2(precedence),
								rules: [],
								hrefs: [],
								sheets: /* @__PURE__ */ new Map()
							}, renderState.styles.set(precedence, styleQueue));
							var resource = {
								state: PENDING$1,
								props: assign$2({}, props, {
									"data-precedence": props.precedence,
									precedence: null
								})
							};
							if (resourceState) {
								2 === resourceState.length && adoptPreloadCredentials$2(resource.props, resourceState);
								var preloadResource = renderState.preloads.stylesheets.get(href);
								preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = PRELOADED;
							}
							styleQueue.sheets.set(href, resource);
							hoistableState && hoistableState.stylesheets.add(resource);
						} else if (styleQueue) {
							var _resource = styleQueue.sheets.get(href);
							_resource && hoistableState && hoistableState.stylesheets.add(_resource);
						}
						textEmbedded && target$jscomp$0.push(textSeparator$1);
						JSCompiler_inline_result$jscomp$5 = null;
					}
					else props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$5 = pushLinkImpl$2(target$jscomp$0, props) : (textEmbedded && target$jscomp$0.push(textSeparator$1), JSCompiler_inline_result$jscomp$5 = isFallback$jscomp$0 ? null : pushLinkImpl$2(renderState.hoistableChunks, props));
					return JSCompiler_inline_result$jscomp$5;
				case "script":
					var noscriptTagInScope$jscomp$1 = formatContext.tagScope & 1, asyncProp = props.async;
					if ("string" !== typeof props.src || !props.src || !asyncProp || "function" === typeof asyncProp || "symbol" === typeof asyncProp || props.onLoad || props.onError || formatContext.insertionMode === SVG_MODE || noscriptTagInScope$jscomp$1 || null != props.itemProp) var JSCompiler_inline_result$jscomp$6 = pushScriptImpl$2(target$jscomp$0, props);
					else {
						var key = props.src;
						if ("module" === props.type) {
							var resources = resumableState.moduleScriptResources;
							var preloads = renderState.preloads.moduleScripts;
						} else resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;
						var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : void 0;
						if (resourceState$jscomp$0 !== EXISTS) {
							resources[key] = EXISTS;
							var scriptProps = props;
							if (resourceState$jscomp$0) {
								2 === resourceState$jscomp$0.length && (scriptProps = assign$2({}, props), adoptPreloadCredentials$2(scriptProps, resourceState$jscomp$0));
								var preloadResource$jscomp$0 = preloads.get(key);
								preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);
							}
							var resource$jscomp$0 = [];
							renderState.scripts.add(resource$jscomp$0);
							pushScriptImpl$2(resource$jscomp$0, scriptProps);
						}
						textEmbedded && target$jscomp$0.push(textSeparator$1);
						JSCompiler_inline_result$jscomp$6 = null;
					}
					return JSCompiler_inline_result$jscomp$6;
				case "style":
					var noscriptTagInScope$jscomp$2 = formatContext.tagScope & 1;
					if (hasOwnProperty$2.call(props, "children")) {
						var children$jscomp$7 = props.children, child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;
						("function" === typeof child$jscomp$0 || "symbol" === typeof child$jscomp$0 || Array.isArray(child$jscomp$0)) && console.error("React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.", "function" === typeof child$jscomp$0 ? "a Function" : "symbol" === typeof child$jscomp$0 ? "a Sybmol" : "an Array");
					}
					var precedence$jscomp$0 = props.precedence, href$jscomp$0 = props.href, nonce = props.nonce;
					if (formatContext.insertionMode === SVG_MODE || noscriptTagInScope$jscomp$2 || null != props.itemProp || "string" !== typeof precedence$jscomp$0 || "string" !== typeof href$jscomp$0 || "" === href$jscomp$0) {
						target$jscomp$0.push(startChunkForTag$2("style"));
						var children$jscomp$8 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;
						for (propKey$jscomp$8 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$8)) {
							var propValue$jscomp$8 = props[propKey$jscomp$8];
							if (null != propValue$jscomp$8) switch (propKey$jscomp$8) {
								case "children":
									children$jscomp$8 = propValue$jscomp$8;
									break;
								case "dangerouslySetInnerHTML":
									innerHTML$jscomp$5 = propValue$jscomp$8;
									break;
								default: pushAttribute$2(target$jscomp$0, propKey$jscomp$8, propValue$jscomp$8);
							}
						}
						target$jscomp$0.push(endOfStartTag$1);
						var child$jscomp$1 = Array.isArray(children$jscomp$8) ? 2 > children$jscomp$8.length ? children$jscomp$8[0] : null : children$jscomp$8;
						"function" !== typeof child$jscomp$1 && "symbol" !== typeof child$jscomp$1 && null !== child$jscomp$1 && void 0 !== child$jscomp$1 && target$jscomp$0.push(escapeStyleTextContent(child$jscomp$1));
						pushInnerHTML$2(target$jscomp$0, innerHTML$jscomp$5, children$jscomp$8);
						target$jscomp$0.push(endChunkForTag$2("style"));
						var JSCompiler_inline_result$jscomp$7 = null;
					} else {
						href$jscomp$0.includes(" ") && console.error("React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is \"%s\".", href$jscomp$0);
						var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0), resourceState$jscomp$1 = resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : void 0;
						if (resourceState$jscomp$1 !== EXISTS) {
							resumableState.styleResources[href$jscomp$0] = EXISTS;
							resourceState$jscomp$1 && console.error("React encountered a hoistable style tag for the same href as a preload: \"%s\". When using a style tag to inline styles you should not also preload it as a stylsheet.", href$jscomp$0);
							styleQueue$jscomp$0 || (styleQueue$jscomp$0 = {
								precedence: escapeTextForBrowser$2(precedence$jscomp$0),
								rules: [],
								hrefs: [],
								sheets: /* @__PURE__ */ new Map()
							}, renderState.styles.set(precedence$jscomp$0, styleQueue$jscomp$0));
							var nonceStyle = renderState.nonce.style;
							if (nonceStyle && nonceStyle !== nonce) console.error("React encountered a style tag with `precedence` \"%s\" and `nonce` \"%s\". When React manages style rules using `precedence` it will only include rules if the nonce matches the style nonce \"%s\" that was included with this render.", precedence$jscomp$0, nonce, nonceStyle);
							else {
								!nonceStyle && nonce && console.error("React encountered a style tag with `precedence` \"%s\" and `nonce` \"%s\". When React manages style rules using `precedence` it will only include a nonce attributes if you also provide the same style nonce value as a render option.", precedence$jscomp$0, nonce);
								styleQueue$jscomp$0.hrefs.push(escapeTextForBrowser$2(href$jscomp$0));
								var target = styleQueue$jscomp$0.rules, children$jscomp$9 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;
								for (propKey$jscomp$9 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$9)) {
									var propValue$jscomp$9 = props[propKey$jscomp$9];
									if (null != propValue$jscomp$9) switch (propKey$jscomp$9) {
										case "children":
											children$jscomp$9 = propValue$jscomp$9;
											break;
										case "dangerouslySetInnerHTML": innerHTML$jscomp$6 = propValue$jscomp$9;
									}
								}
								var child$jscomp$2 = Array.isArray(children$jscomp$9) ? 2 > children$jscomp$9.length ? children$jscomp$9[0] : null : children$jscomp$9;
								"function" !== typeof child$jscomp$2 && "symbol" !== typeof child$jscomp$2 && null !== child$jscomp$2 && void 0 !== child$jscomp$2 && target.push(escapeStyleTextContent(child$jscomp$2));
								pushInnerHTML$2(target, innerHTML$jscomp$6, children$jscomp$9);
							}
						}
						styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);
						textEmbedded && target$jscomp$0.push(textSeparator$1);
						JSCompiler_inline_result$jscomp$7 = void 0;
					}
					return JSCompiler_inline_result$jscomp$7;
				case "meta":
					var noscriptTagInScope$jscomp$3 = formatContext.tagScope & 1, isFallback$jscomp$1 = formatContext.tagScope & 4;
					if (formatContext.insertionMode === SVG_MODE || noscriptTagInScope$jscomp$3 || null != props.itemProp) var JSCompiler_inline_result$jscomp$8 = pushSelfClosing$2(target$jscomp$0, props, "meta");
					else textEmbedded && target$jscomp$0.push(textSeparator$1), JSCompiler_inline_result$jscomp$8 = isFallback$jscomp$1 ? null : "string" === typeof props.charSet ? pushSelfClosing$2(renderState.charsetChunks, props, "meta") : "viewport" === props.name ? pushSelfClosing$2(renderState.viewportChunks, props, "meta") : pushSelfClosing$2(renderState.hoistableChunks, props, "meta");
					return JSCompiler_inline_result$jscomp$8;
				case "listing":
				case "pre":
					target$jscomp$0.push(startChunkForTag$2(type));
					var children$jscomp$10 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;
					for (propKey$jscomp$10 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$10)) {
						var propValue$jscomp$10 = props[propKey$jscomp$10];
						if (null != propValue$jscomp$10) switch (propKey$jscomp$10) {
							case "children":
								children$jscomp$10 = propValue$jscomp$10;
								break;
							case "dangerouslySetInnerHTML":
								innerHTML$jscomp$7 = propValue$jscomp$10;
								break;
							default: pushAttribute$2(target$jscomp$0, propKey$jscomp$10, propValue$jscomp$10);
						}
					}
					target$jscomp$0.push(endOfStartTag$1);
					if (null != innerHTML$jscomp$7) {
						if (null != children$jscomp$10) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
						if ("object" !== typeof innerHTML$jscomp$7 || !("__html" in innerHTML$jscomp$7)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
						var html = innerHTML$jscomp$7.__html;
						null !== html && void 0 !== html && ("string" === typeof html && 0 < html.length && "\n" === html[0] ? target$jscomp$0.push(leadingNewline$1, html) : (checkHtmlStringCoercion(html), target$jscomp$0.push("" + html)));
					}
					"string" === typeof children$jscomp$10 && "\n" === children$jscomp$10[0] && target$jscomp$0.push(leadingNewline$1);
					return children$jscomp$10;
				case "img":
					var pictureOrNoScriptTagInScope = formatContext.tagScope & 3, src = props.src, srcSet = props.srcSet;
					if (!("lazy" === props.loading || !src && !srcSet || "string" !== typeof src && null != src || "string" !== typeof srcSet && null != srcSet || "low" === props.fetchPriority || pictureOrNoScriptTagInScope) && ("string" !== typeof src || ":" !== src[4] || "d" !== src[0] && "D" !== src[0] || "a" !== src[1] && "A" !== src[1] || "t" !== src[2] && "T" !== src[2] || "a" !== src[3] && "A" !== src[3]) && ("string" !== typeof srcSet || ":" !== srcSet[4] || "d" !== srcSet[0] && "D" !== srcSet[0] || "a" !== srcSet[1] && "A" !== srcSet[1] || "t" !== srcSet[2] && "T" !== srcSet[2] || "a" !== srcSet[3] && "A" !== srcSet[3])) {
						null !== hoistableState && formatContext.tagScope & 64 && (hoistableState.suspenseyImages = !0);
						var sizes = "string" === typeof props.sizes ? props.sizes : void 0, key$jscomp$0 = srcSet ? srcSet + "\n" + (sizes || "") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);
						if (resource$jscomp$1) {
							if ("high" === props.fetchPriority || 10 > renderState.highImagePreloads.size) promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);
						} else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {
							resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS$2;
							var input = props.crossOrigin;
							var crossOrigin = "string" === typeof input ? "use-credentials" === input ? input : "" : void 0;
							var headers = renderState.headers, header;
							headers && 0 < headers.remainingCapacity && "string" !== typeof props.srcSet && ("high" === props.fetchPriority || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader$2(src, "image", {
								imageSrcSet: props.srcSet,
								imageSizes: props.sizes,
								crossOrigin,
								integrity: props.integrity,
								nonce: props.nonce,
								type: props.type,
								fetchPriority: props.fetchPriority,
								referrerPolicy: props.refererPolicy
							}), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS$2, headers.highImagePreloads && (headers.highImagePreloads += ", "), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl$2(resource$jscomp$1, {
								rel: "preload",
								as: "image",
								href: srcSet ? void 0 : src,
								imageSrcSet: srcSet,
								imageSizes: sizes,
								crossOrigin,
								integrity: props.integrity,
								type: props.type,
								fetchPriority: props.fetchPriority,
								referrerPolicy: props.referrerPolicy
							}), "high" === props.fetchPriority || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));
						}
					}
					return pushSelfClosing$2(target$jscomp$0, props, "img");
				case "base":
				case "area":
				case "br":
				case "col":
				case "embed":
				case "hr":
				case "keygen":
				case "param":
				case "source":
				case "track":
				case "wbr": return pushSelfClosing$2(target$jscomp$0, props, type);
				case "annotation-xml":
				case "color-profile":
				case "font-face":
				case "font-face-src":
				case "font-face-uri":
				case "font-face-format":
				case "font-face-name":
				case "missing-glyph": break;
				case "head":
					if (formatContext.insertionMode < HTML_MODE) {
						var preamble = preambleState || renderState.preamble;
						if (preamble.headChunks) throw Error("The `<head>` tag may only be rendered once.");
						null !== preambleState && target$jscomp$0.push(headPreambleContributionChunk$1);
						preamble.headChunks = [];
						var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement$2(preamble.headChunks, props, "head");
					} else JSCompiler_inline_result$jscomp$9 = pushStartGenericElement$2(target$jscomp$0, props, "head");
					return JSCompiler_inline_result$jscomp$9;
				case "body":
					if (formatContext.insertionMode < HTML_MODE) {
						var preamble$jscomp$0 = preambleState || renderState.preamble;
						if (preamble$jscomp$0.bodyChunks) throw Error("The `<body>` tag may only be rendered once.");
						null !== preambleState && target$jscomp$0.push(bodyPreambleContributionChunk$1);
						preamble$jscomp$0.bodyChunks = [];
						var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement$2(preamble$jscomp$0.bodyChunks, props, "body");
					} else JSCompiler_inline_result$jscomp$10 = pushStartGenericElement$2(target$jscomp$0, props, "body");
					return JSCompiler_inline_result$jscomp$10;
				case "html":
					if (formatContext.insertionMode === ROOT_HTML_MODE) {
						var preamble$jscomp$1 = preambleState || renderState.preamble;
						if (preamble$jscomp$1.htmlChunks) throw Error("The `<html>` tag may only be rendered once.");
						null !== preambleState && target$jscomp$0.push(htmlPreambleContributionChunk$1);
						preamble$jscomp$1.htmlChunks = [doctypeChunk$1];
						var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement$2(preamble$jscomp$1.htmlChunks, props, "html");
					} else JSCompiler_inline_result$jscomp$11 = pushStartGenericElement$2(target$jscomp$0, props, "html");
					return JSCompiler_inline_result$jscomp$11;
				default: if (-1 !== type.indexOf("-")) {
					target$jscomp$0.push(startChunkForTag$2(type));
					var children$jscomp$11 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;
					for (propKey$jscomp$11 in props) if (hasOwnProperty$2.call(props, propKey$jscomp$11)) {
						var propValue$jscomp$11 = props[propKey$jscomp$11];
						if (null != propValue$jscomp$11) {
							var attributeName = propKey$jscomp$11;
							switch (propKey$jscomp$11) {
								case "children":
									children$jscomp$11 = propValue$jscomp$11;
									break;
								case "dangerouslySetInnerHTML":
									innerHTML$jscomp$8 = propValue$jscomp$11;
									break;
								case "style":
									pushStyleAttribute$2(target$jscomp$0, propValue$jscomp$11);
									break;
								case "suppressContentEditableWarning":
								case "suppressHydrationWarning":
								case "ref": break;
								case "className": attributeName = "class";
								default: if (isAttributeNameSafe$2(propKey$jscomp$11) && "function" !== typeof propValue$jscomp$11 && "symbol" !== typeof propValue$jscomp$11 && !1 !== propValue$jscomp$11) {
									if (!0 === propValue$jscomp$11) propValue$jscomp$11 = "";
									else if ("object" === typeof propValue$jscomp$11) continue;
									target$jscomp$0.push(attributeSeparator$1, attributeName, attributeAssign$1, escapeTextForBrowser$2(propValue$jscomp$11), attributeEnd$1);
								}
							}
						}
					}
					target$jscomp$0.push(endOfStartTag$1);
					pushInnerHTML$2(target$jscomp$0, innerHTML$jscomp$8, children$jscomp$11);
					return children$jscomp$11;
				}
			}
			return pushStartGenericElement$2(target$jscomp$0, props, type);
		}
		function endChunkForTag$2(tag) {
			var chunk = endTagCache$2.get(tag);
			void 0 === chunk && (chunk = stringToPrecomputedChunk$1("</" + tag + ">"), endTagCache$2.set(tag, chunk));
			return chunk;
		}
		function hoistPreambleState$2(renderState, preambleState) {
			renderState = renderState.preamble;
			null === renderState.htmlChunks && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks);
			null === renderState.headChunks && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks);
			null === renderState.bodyChunks && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks);
		}
		function writeBootstrap$2(destination, renderState) {
			renderState = renderState.bootstrapChunks;
			for (var i = 0; i < renderState.length - 1; i++) writeChunk$1(destination, renderState[i]);
			return i < renderState.length ? (i = renderState[i], renderState.length = 0, writeChunkAndReturn$1(destination, i)) : !0;
		}
		function writeStartPendingSuspenseBoundary$2(destination, renderState, id) {
			writeChunk$1(destination, startPendingSuspenseBoundary1$1);
			if (null === id) throw Error("An ID must have been assigned before we can complete the boundary.");
			writeChunk$1(destination, renderState.boundaryPrefix);
			writeChunk$1(destination, id.toString(16));
			return writeChunkAndReturn$1(destination, startPendingSuspenseBoundary2$1);
		}
		function writeStartSegment$2(destination, renderState, formatContext, id) {
			switch (formatContext.insertionMode) {
				case ROOT_HTML_MODE:
				case HTML_HTML_MODE:
				case HTML_HEAD_MODE:
				case HTML_MODE: return writeChunk$1(destination, startSegmentHTML$1), writeChunk$1(destination, renderState.segmentPrefix), writeChunk$1(destination, id.toString(16)), writeChunkAndReturn$1(destination, startSegmentHTML2$1);
				case SVG_MODE: return writeChunk$1(destination, startSegmentSVG$1), writeChunk$1(destination, renderState.segmentPrefix), writeChunk$1(destination, id.toString(16)), writeChunkAndReturn$1(destination, startSegmentSVG2$1);
				case MATHML_MODE: return writeChunk$1(destination, startSegmentMathML$1), writeChunk$1(destination, renderState.segmentPrefix), writeChunk$1(destination, id.toString(16)), writeChunkAndReturn$1(destination, startSegmentMathML2$1);
				case HTML_TABLE_MODE: return writeChunk$1(destination, startSegmentTable$1), writeChunk$1(destination, renderState.segmentPrefix), writeChunk$1(destination, id.toString(16)), writeChunkAndReturn$1(destination, startSegmentTable2$1);
				case HTML_TABLE_BODY_MODE: return writeChunk$1(destination, startSegmentTableBody$1), writeChunk$1(destination, renderState.segmentPrefix), writeChunk$1(destination, id.toString(16)), writeChunkAndReturn$1(destination, startSegmentTableBody2$1);
				case HTML_TABLE_ROW_MODE: return writeChunk$1(destination, startSegmentTableRow$1), writeChunk$1(destination, renderState.segmentPrefix), writeChunk$1(destination, id.toString(16)), writeChunkAndReturn$1(destination, startSegmentTableRow2$1);
				case HTML_COLGROUP_MODE: return writeChunk$1(destination, startSegmentColGroup$1), writeChunk$1(destination, renderState.segmentPrefix), writeChunk$1(destination, id.toString(16)), writeChunkAndReturn$1(destination, startSegmentColGroup2$1);
				default: throw Error("Unknown insertion mode. This is a bug in React.");
			}
		}
		function writeEndSegment$2(destination, formatContext) {
			switch (formatContext.insertionMode) {
				case ROOT_HTML_MODE:
				case HTML_HTML_MODE:
				case HTML_HEAD_MODE:
				case HTML_MODE: return writeChunkAndReturn$1(destination, endSegmentHTML$1);
				case SVG_MODE: return writeChunkAndReturn$1(destination, endSegmentSVG$1);
				case MATHML_MODE: return writeChunkAndReturn$1(destination, endSegmentMathML$1);
				case HTML_TABLE_MODE: return writeChunkAndReturn$1(destination, endSegmentTable$1);
				case HTML_TABLE_BODY_MODE: return writeChunkAndReturn$1(destination, endSegmentTableBody$1);
				case HTML_TABLE_ROW_MODE: return writeChunkAndReturn$1(destination, endSegmentTableRow$1);
				case HTML_COLGROUP_MODE: return writeChunkAndReturn$1(destination, endSegmentColGroup$1);
				default: throw Error("Unknown insertion mode. This is a bug in React.");
			}
		}
		function escapeJSStringsForInstructionScripts$2(input) {
			return JSON.stringify(input).replace(regexForJSStringsInInstructionScripts$2, function(match) {
				switch (match) {
					case "<": return "\\u003c";
					case "\u2028": return "\\u2028";
					case "\u2029": return "\\u2029";
					default: throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
				}
			});
		}
		function escapeJSObjectForInstructionScripts$2(input) {
			return JSON.stringify(input).replace(regexForJSStringsInScripts$2, function(match) {
				switch (match) {
					case "&": return "\\u0026";
					case ">": return "\\u003e";
					case "<": return "\\u003c";
					case "\u2028": return "\\u2028";
					case "\u2029": return "\\u2029";
					default: throw Error("escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
				}
			});
		}
		function flushStyleTagsLateForBoundary$2(styleQueue) {
			var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
			0 < rules.length && 0 === hrefs.length && console.error("React expected to have at least one href for an a hoistable style but found none. This is a bug in React.");
			var i = 0;
			if (hrefs.length) {
				writeChunk$1(this, currentlyFlushingRenderState$2.startInlineStyle);
				writeChunk$1(this, lateStyleTagResourceOpen1$1);
				writeChunk$1(this, styleQueue.precedence);
				for (writeChunk$1(this, lateStyleTagResourceOpen2$1); i < hrefs.length - 1; i++) writeChunk$1(this, hrefs[i]), writeChunk$1(this, spaceSeparator$1);
				writeChunk$1(this, hrefs[i]);
				writeChunk$1(this, lateStyleTagResourceOpen3$1);
				for (i = 0; i < rules.length; i++) writeChunk$1(this, rules[i]);
				destinationHasCapacity$3 = writeChunkAndReturn$1(this, lateStyleTagTemplateClose$1);
				currentlyRenderingBoundaryHasStylesToHoist$2 = !0;
				rules.length = 0;
				hrefs.length = 0;
			}
		}
		function hasStylesToHoist$2(stylesheet) {
			return stylesheet.state !== PREAMBLE ? currentlyRenderingBoundaryHasStylesToHoist$2 = !0 : !1;
		}
		function writeHoistablesForBoundary$2(destination, hoistableState, renderState) {
			currentlyRenderingBoundaryHasStylesToHoist$2 = !1;
			destinationHasCapacity$3 = !0;
			currentlyFlushingRenderState$2 = renderState;
			hoistableState.styles.forEach(flushStyleTagsLateForBoundary$2, destination);
			currentlyFlushingRenderState$2 = null;
			hoistableState.stylesheets.forEach(hasStylesToHoist$2);
			currentlyRenderingBoundaryHasStylesToHoist$2 && (renderState.stylesToHoist = !0);
			return destinationHasCapacity$3;
		}
		function flushResource$2(resource) {
			for (var i = 0; i < resource.length; i++) writeChunk$1(this, resource[i]);
			resource.length = 0;
		}
		function flushStyleInPreamble$2(stylesheet) {
			pushLinkImpl$2(stylesheetFlushingQueue$2, stylesheet.props);
			for (var i = 0; i < stylesheetFlushingQueue$2.length; i++) writeChunk$1(this, stylesheetFlushingQueue$2[i]);
			stylesheetFlushingQueue$2.length = 0;
			stylesheet.state = PREAMBLE;
		}
		function flushStylesInPreamble$2(styleQueue) {
			var hasStylesheets = 0 < styleQueue.sheets.size;
			styleQueue.sheets.forEach(flushStyleInPreamble$2, this);
			styleQueue.sheets.clear();
			var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
			if (!hasStylesheets || hrefs.length) {
				writeChunk$1(this, currentlyFlushingRenderState$2.startInlineStyle);
				writeChunk$1(this, styleTagResourceOpen1$1);
				writeChunk$1(this, styleQueue.precedence);
				styleQueue = 0;
				if (hrefs.length) {
					for (writeChunk$1(this, styleTagResourceOpen2$1); styleQueue < hrefs.length - 1; styleQueue++) writeChunk$1(this, hrefs[styleQueue]), writeChunk$1(this, spaceSeparator$1);
					writeChunk$1(this, hrefs[styleQueue]);
				}
				writeChunk$1(this, styleTagResourceOpen3$1);
				for (styleQueue = 0; styleQueue < rules.length; styleQueue++) writeChunk$1(this, rules[styleQueue]);
				writeChunk$1(this, styleTagResourceClose$1);
				rules.length = 0;
				hrefs.length = 0;
			}
		}
		function preloadLateStyle$2(stylesheet) {
			if (stylesheet.state === PENDING$1) {
				stylesheet.state = PRELOADED;
				var props = stylesheet.props;
				pushLinkImpl$2(stylesheetFlushingQueue$2, {
					rel: "preload",
					as: "style",
					href: stylesheet.props.href,
					crossOrigin: props.crossOrigin,
					fetchPriority: props.fetchPriority,
					integrity: props.integrity,
					media: props.media,
					hrefLang: props.hrefLang,
					referrerPolicy: props.referrerPolicy
				});
				for (stylesheet = 0; stylesheet < stylesheetFlushingQueue$2.length; stylesheet++) writeChunk$1(this, stylesheetFlushingQueue$2[stylesheet]);
				stylesheetFlushingQueue$2.length = 0;
			}
		}
		function preloadLateStyles$2(styleQueue) {
			styleQueue.sheets.forEach(preloadLateStyle$2, this);
			styleQueue.sheets.clear();
		}
		function pushCompletedShellIdAttribute$2(target, resumableState) {
			(resumableState.instructions & SentCompletedShellId) === NothingSent && (resumableState.instructions |= SentCompletedShellId, target.push(completedShellIdAttributeStart$1, escapeTextForBrowser$2("_" + resumableState.idPrefix + "R_"), attributeEnd$1));
		}
		function writeStyleResourceDependenciesInJS$2(destination, hoistableState) {
			writeChunk$1(destination, arrayFirstOpenBracket$1);
			var nextArrayOpenBrackChunk = arrayFirstOpenBracket$1;
			hoistableState.stylesheets.forEach(function(resource) {
				if (resource.state !== PREAMBLE) if (resource.state === LATE) writeChunk$1(destination, nextArrayOpenBrackChunk), resource = resource.props.href, checkAttributeStringCoercion(resource, "href"), writeChunk$1(destination, escapeJSObjectForInstructionScripts$2("" + resource)), writeChunk$1(destination, arrayCloseBracket$1), nextArrayOpenBrackChunk = arraySubsequentOpenBracket$1;
				else {
					writeChunk$1(destination, nextArrayOpenBrackChunk);
					var precedence = resource.props["data-precedence"], props = resource.props;
					writeChunk$1(destination, escapeJSObjectForInstructionScripts$2(sanitizeURL$2("" + resource.props.href)));
					checkAttributeStringCoercion(precedence, "precedence");
					precedence = "" + precedence;
					writeChunk$1(destination, arrayInterstitial$1);
					writeChunk$1(destination, escapeJSObjectForInstructionScripts$2(precedence));
					for (var propKey in props) if (hasOwnProperty$2.call(props, propKey) && (precedence = props[propKey], null != precedence)) switch (propKey) {
						case "href":
						case "rel":
						case "precedence":
						case "data-precedence": break;
						case "children":
						case "dangerouslySetInnerHTML": throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
						default: writeStyleResourceAttributeInJS$2(destination, propKey, precedence);
					}
					writeChunk$1(destination, arrayCloseBracket$1);
					nextArrayOpenBrackChunk = arraySubsequentOpenBracket$1;
					resource.state = LATE;
				}
			});
			writeChunk$1(destination, arrayCloseBracket$1);
		}
		function writeStyleResourceAttributeInJS$2(destination, name, value) {
			var attributeName = name.toLowerCase();
			switch (typeof value) {
				case "function":
				case "symbol": return;
			}
			switch (name) {
				case "innerHTML":
				case "dangerouslySetInnerHTML":
				case "suppressContentEditableWarning":
				case "suppressHydrationWarning":
				case "style":
				case "ref": return;
				case "className":
					attributeName = "class";
					checkAttributeStringCoercion(value, attributeName);
					name = "" + value;
					break;
				case "hidden":
					if (!1 === value) return;
					name = "";
					break;
				case "src":
				case "href":
					value = sanitizeURL$2(value);
					checkAttributeStringCoercion(value, attributeName);
					name = "" + value;
					break;
				default:
					if (2 < name.length && ("o" === name[0] || "O" === name[0]) && ("n" === name[1] || "N" === name[1]) || !isAttributeNameSafe$2(name)) return;
					checkAttributeStringCoercion(value, attributeName);
					name = "" + value;
			}
			writeChunk$1(destination, arrayInterstitial$1);
			writeChunk$1(destination, escapeJSObjectForInstructionScripts$2(attributeName));
			writeChunk$1(destination, arrayInterstitial$1);
			writeChunk$1(destination, escapeJSObjectForInstructionScripts$2(name));
		}
		function createHoistableState$2() {
			return {
				styles: /* @__PURE__ */ new Set(),
				stylesheets: /* @__PURE__ */ new Set(),
				suspenseyImages: !1
			};
		}
		function preloadBootstrapScriptOrModule(resumableState, renderState, href, props) {
			(resumableState.scriptResources.hasOwnProperty(href) || resumableState.moduleScriptResources.hasOwnProperty(href)) && console.error("Internal React Error: React expected bootstrap script or module with src \"%s\" to not have been preloaded already. please file an issue", href);
			resumableState.scriptResources[href] = EXISTS;
			resumableState.moduleScriptResources[href] = EXISTS;
			resumableState = [];
			pushLinkImpl$2(resumableState, props);
			renderState.bootstrapScripts.add(resumableState);
		}
		function adoptPreloadCredentials$2(target, preloadState) {
			target.crossOrigin ??= preloadState[0];
			target.integrity ??= preloadState[1];
		}
		function getPreloadAsHeader$2(href, as, params) {
			href = escapeHrefForLinkHeaderURLContext(href);
			as = escapeStringForLinkHeaderQuotedParamValueContext(as, "as");
			as = "<" + href + ">; rel=preload; as=\"" + as + "\"";
			for (var paramName in params) hasOwnProperty$2.call(params, paramName) && (href = params[paramName], "string" === typeof href && (as += "; " + paramName.toLowerCase() + "=\"" + escapeStringForLinkHeaderQuotedParamValueContext(href, paramName) + "\""));
			return as;
		}
		function escapeHrefForLinkHeaderURLContext(hrefInput) {
			checkAttributeStringCoercion(hrefInput, "href");
			return ("" + hrefInput).replace(regexForHrefInLinkHeaderURLContext$2, escapeHrefForLinkHeaderURLContextReplacer$2);
		}
		function escapeHrefForLinkHeaderURLContextReplacer$2(match) {
			switch (match) {
				case "<": return "%3C";
				case ">": return "%3E";
				case "\n": return "%0A";
				case "\r": return "%0D";
				default: throw Error("escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
			}
		}
		function escapeStringForLinkHeaderQuotedParamValueContext(value, name) {
			willCoercionThrow(value) && (console.error("The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.", name, typeName(value)), testStringCoercion(value));
			return ("" + value).replace(regexForLinkHeaderQuotedParamValueContext$2, escapeStringForLinkHeaderQuotedParamValueContextReplacer$2);
		}
		function escapeStringForLinkHeaderQuotedParamValueContextReplacer$2(match) {
			switch (match) {
				case "\"": return "%22";
				case "'": return "%27";
				case ";": return "%3B";
				case ",": return "%2C";
				case "\n": return "%0A";
				case "\r": return "%0D";
				default: throw Error("escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
			}
		}
		function hoistStyleQueueDependency$2(styleQueue) {
			this.styles.add(styleQueue);
		}
		function hoistStylesheetDependency$2(stylesheet) {
			this.stylesheets.add(stylesheet);
		}
		function hoistHoistables$2(parentState, childState) {
			childState.styles.forEach(hoistStyleQueueDependency$2, parentState);
			childState.stylesheets.forEach(hoistStylesheetDependency$2, parentState);
			childState.suspenseyImages && (parentState.suspenseyImages = !0);
		}
		function hasSuspenseyContent$1(hoistableState) {
			return 0 < hoistableState.stylesheets.size || hoistableState.suspenseyImages;
		}
		function getComponentNameFromType$2(type) {
			if (null == type) return null;
			if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE$2 ? null : type.displayName || type.name || null;
			if ("string" === typeof type) return type;
			switch (type) {
				case REACT_FRAGMENT_TYPE$2: return "Fragment";
				case REACT_PROFILER_TYPE$2: return "Profiler";
				case REACT_STRICT_MODE_TYPE$2: return "StrictMode";
				case REACT_SUSPENSE_TYPE$2: return "Suspense";
				case REACT_SUSPENSE_LIST_TYPE$2: return "SuspenseList";
				case REACT_ACTIVITY_TYPE$2: return "Activity";
			}
			if ("object" === typeof type) switch ("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
				case REACT_PORTAL_TYPE$2: return "Portal";
				case REACT_CONTEXT_TYPE$2: return type.displayName || "Context";
				case REACT_CONSUMER_TYPE$2: return (type._context.displayName || "Context") + ".Consumer";
				case REACT_FORWARD_REF_TYPE$2:
					var innerType = type.render;
					type = type.displayName;
					type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
					return type;
				case REACT_MEMO_TYPE$2: return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType$2(type.type) || "Memo";
				case REACT_LAZY_TYPE$2:
					innerType = type._payload;
					type = type._init;
					try {
						return getComponentNameFromType$2(type(innerType));
					} catch (x) {}
			}
			return null;
		}
		function popToNearestCommonAncestor$2(prev, next) {
			if (prev !== next) {
				prev.context._currentValue = prev.parentValue;
				prev = prev.parent;
				var parentNext = next.parent;
				if (null === prev) {
					if (null !== parentNext) throw Error("The stacks must reach the root at the same time. This is a bug in React.");
				} else {
					if (null === parentNext) throw Error("The stacks must reach the root at the same time. This is a bug in React.");
					popToNearestCommonAncestor$2(prev, parentNext);
				}
				next.context._currentValue = next.value;
			}
		}
		function popAllPrevious$2(prev) {
			prev.context._currentValue = prev.parentValue;
			prev = prev.parent;
			null !== prev && popAllPrevious$2(prev);
		}
		function pushAllNext$2(next) {
			var parentNext = next.parent;
			null !== parentNext && pushAllNext$2(parentNext);
			next.context._currentValue = next.value;
		}
		function popPreviousToCommonLevel$2(prev, next) {
			prev.context._currentValue = prev.parentValue;
			prev = prev.parent;
			if (null === prev) throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
			prev.depth === next.depth ? popToNearestCommonAncestor$2(prev, next) : popPreviousToCommonLevel$2(prev, next);
		}
		function popNextToCommonLevel$2(prev, next) {
			var parentNext = next.parent;
			if (null === parentNext) throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
			prev.depth === parentNext.depth ? popToNearestCommonAncestor$2(prev, parentNext) : popNextToCommonLevel$2(prev, parentNext);
			next.context._currentValue = next.value;
		}
		function switchContext$2(newSnapshot) {
			var prev = currentActiveSnapshot$2;
			prev !== newSnapshot && (null === prev ? pushAllNext$2(newSnapshot) : null === newSnapshot ? popAllPrevious$2(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor$2(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel$2(prev, newSnapshot) : popNextToCommonLevel$2(prev, newSnapshot), currentActiveSnapshot$2 = newSnapshot);
		}
		function warnOnInvalidCallback(callback) {
			if (null !== callback && "function" !== typeof callback) {
				var key = String(callback);
				didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback));
			}
		}
		function warnNoop(publicInstance, callerName) {
			publicInstance = (publicInstance = publicInstance.constructor) && getComponentNameFromType$2(publicInstance) || "ReactClass";
			var warningKey = publicInstance + "." + callerName;
			didWarnAboutNoopUpdateForComponent[warningKey] || (console.error("Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, publicInstance), didWarnAboutNoopUpdateForComponent[warningKey] = !0);
		}
		function pushTreeContext$2(baseContext, totalChildren, index) {
			var baseIdWithLeadingBit = baseContext.id;
			baseContext = baseContext.overflow;
			var baseLength = 32 - clz32$2(baseIdWithLeadingBit) - 1;
			baseIdWithLeadingBit &= ~(1 << baseLength);
			index += 1;
			var length = 32 - clz32$2(totalChildren) + baseLength;
			if (30 < length) {
				var numberOfOverflowBits = baseLength - baseLength % 5;
				length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
				baseIdWithLeadingBit >>= numberOfOverflowBits;
				baseLength -= numberOfOverflowBits;
				return {
					id: 1 << 32 - clz32$2(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit,
					overflow: length + baseContext
				};
			}
			return {
				id: 1 << length | index << baseLength | baseIdWithLeadingBit,
				overflow: baseContext
			};
		}
		function clz32Fallback$2(x) {
			x >>>= 0;
			return 0 === x ? 32 : 31 - (log$2(x) / LN2$2 | 0) | 0;
		}
		function noop$2() {}
		function trackUsedThenable$2(thenableState$3, thenable, index) {
			index = thenableState$3[index];
			void 0 === index ? thenableState$3.push(thenable) : index !== thenable && (thenable.then(noop$2, noop$2), thenable = index);
			switch (thenable.status) {
				case "fulfilled": return thenable.value;
				case "rejected": throw thenable.reason;
				default:
					"string" === typeof thenable.status ? thenable.then(noop$2, noop$2) : (thenableState$3 = thenable, thenableState$3.status = "pending", thenableState$3.then(function(fulfilledValue) {
						if ("pending" === thenable.status) {
							var fulfilledThenable = thenable;
							fulfilledThenable.status = "fulfilled";
							fulfilledThenable.value = fulfilledValue;
						}
					}, function(error) {
						if ("pending" === thenable.status) {
							var rejectedThenable = thenable;
							rejectedThenable.status = "rejected";
							rejectedThenable.reason = error;
						}
					}));
					switch (thenable.status) {
						case "fulfilled": return thenable.value;
						case "rejected": throw thenable.reason;
					}
					suspendedThenable$2 = thenable;
					throw SuspenseException$2;
			}
		}
		function getSuspendedThenable$2() {
			if (null === suspendedThenable$2) throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
			var thenable = suspendedThenable$2;
			suspendedThenable$2 = null;
			return thenable;
		}
		function is$2(x, y) {
			return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
		}
		function resolveCurrentlyRenderingComponent$2() {
			if (null === currentlyRenderingComponent$2) throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
			isInHookUserCodeInDev && console.error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks");
			return currentlyRenderingComponent$2;
		}
		function createHook$2() {
			if (0 < numberOfReRenders$2) throw Error("Rendered more hooks than during the previous render");
			return {
				memoizedState: null,
				queue: null,
				next: null
			};
		}
		function createWorkInProgressHook$2() {
			null === workInProgressHook$2 ? null === firstWorkInProgressHook$2 ? (isReRender$2 = !1, firstWorkInProgressHook$2 = workInProgressHook$2 = createHook$2()) : (isReRender$2 = !0, workInProgressHook$2 = firstWorkInProgressHook$2) : null === workInProgressHook$2.next ? (isReRender$2 = !1, workInProgressHook$2 = workInProgressHook$2.next = createHook$2()) : (isReRender$2 = !0, workInProgressHook$2 = workInProgressHook$2.next);
			return workInProgressHook$2;
		}
		function getThenableStateAfterSuspending$2() {
			var state = thenableState$2;
			thenableState$2 = null;
			return state;
		}
		function resetHooksState$2() {
			isInHookUserCodeInDev = !1;
			currentlyRenderingKeyPath$2 = currentlyRenderingRequest$2 = currentlyRenderingTask$2 = currentlyRenderingComponent$2 = null;
			didScheduleRenderPhaseUpdate$2 = !1;
			firstWorkInProgressHook$2 = null;
			numberOfReRenders$2 = 0;
			workInProgressHook$2 = renderPhaseUpdates$2 = null;
		}
		function readContext(context) {
			isInHookUserCodeInDev && console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
			return context._currentValue;
		}
		function basicStateReducer$2(state, action) {
			return "function" === typeof action ? action(state) : action;
		}
		function useReducer$2(reducer, initialArg, init) {
			reducer !== basicStateReducer$2 && (currentHookNameInDev = "useReducer");
			currentlyRenderingComponent$2 = resolveCurrentlyRenderingComponent$2();
			workInProgressHook$2 = createWorkInProgressHook$2();
			if (isReRender$2) {
				init = workInProgressHook$2.queue;
				initialArg = init.dispatch;
				if (null !== renderPhaseUpdates$2) {
					var firstRenderPhaseUpdate = renderPhaseUpdates$2.get(init);
					if (void 0 !== firstRenderPhaseUpdate) {
						renderPhaseUpdates$2.delete(init);
						init = workInProgressHook$2.memoizedState;
						do {
							var action = firstRenderPhaseUpdate.action;
							isInHookUserCodeInDev = !0;
							init = reducer(init, action);
							isInHookUserCodeInDev = !1;
							firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;
						} while (null !== firstRenderPhaseUpdate);
						workInProgressHook$2.memoizedState = init;
						return [init, initialArg];
					}
				}
				return [workInProgressHook$2.memoizedState, initialArg];
			}
			isInHookUserCodeInDev = !0;
			reducer = reducer === basicStateReducer$2 ? "function" === typeof initialArg ? initialArg() : initialArg : void 0 !== init ? init(initialArg) : initialArg;
			isInHookUserCodeInDev = !1;
			workInProgressHook$2.memoizedState = reducer;
			reducer = workInProgressHook$2.queue = {
				last: null,
				dispatch: null
			};
			reducer = reducer.dispatch = dispatchAction$2.bind(null, currentlyRenderingComponent$2, reducer);
			return [workInProgressHook$2.memoizedState, reducer];
		}
		function useMemo$2(nextCreate, deps) {
			currentlyRenderingComponent$2 = resolveCurrentlyRenderingComponent$2();
			workInProgressHook$2 = createWorkInProgressHook$2();
			deps = void 0 === deps ? null : deps;
			if (null !== workInProgressHook$2) {
				var prevState = workInProgressHook$2.memoizedState;
				if (null !== prevState && null !== deps) {
					a: {
						var JSCompiler_inline_result = prevState[1];
						if (null === JSCompiler_inline_result) console.error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev), JSCompiler_inline_result = !1;
						else {
							deps.length !== JSCompiler_inline_result.length && console.error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + deps.join(", ") + "]", "[" + JSCompiler_inline_result.join(", ") + "]");
							for (var i = 0; i < JSCompiler_inline_result.length && i < deps.length; i++) if (!objectIs$2(deps[i], JSCompiler_inline_result[i])) {
								JSCompiler_inline_result = !1;
								break a;
							}
							JSCompiler_inline_result = !0;
						}
					}
					if (JSCompiler_inline_result) return prevState[0];
				}
			}
			isInHookUserCodeInDev = !0;
			nextCreate = nextCreate();
			isInHookUserCodeInDev = !1;
			workInProgressHook$2.memoizedState = [nextCreate, deps];
			return nextCreate;
		}
		function dispatchAction$2(componentIdentity, queue, action) {
			if (25 <= numberOfReRenders$2) throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
			if (componentIdentity === currentlyRenderingComponent$2) if (didScheduleRenderPhaseUpdate$2 = !0, componentIdentity = {
				action,
				next: null
			}, null === renderPhaseUpdates$2 && (renderPhaseUpdates$2 = /* @__PURE__ */ new Map()), action = renderPhaseUpdates$2.get(queue), void 0 === action) renderPhaseUpdates$2.set(queue, componentIdentity);
			else {
				for (queue = action; null !== queue.next;) queue = queue.next;
				queue.next = componentIdentity;
			}
		}
		function throwOnUseEffectEventCall$2() {
			throw Error("A function wrapped in useEffectEvent can't be called during rendering.");
		}
		function unsupportedStartTransition$2() {
			throw Error("startTransition cannot be called during server rendering.");
		}
		function unsupportedSetOptimisticState$2() {
			throw Error("Cannot update optimistic state while rendering.");
		}
		function createPostbackActionStateKey$1(permalink, componentKeyPath, hookIndex) {
			if (void 0 !== permalink) return "p" + permalink;
			permalink = JSON.stringify([
				componentKeyPath,
				null,
				hookIndex
			]);
			componentKeyPath = crypto$1.createHash("md5");
			componentKeyPath.update(permalink);
			return "k" + componentKeyPath.digest("hex");
		}
		function useActionState$2(action, initialState, permalink) {
			resolveCurrentlyRenderingComponent$2();
			var actionStateHookIndex = actionStateCounter$2++, request = currentlyRenderingRequest$2;
			if ("function" === typeof action.$$FORM_ACTION) {
				var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath$2;
				request = request.formState;
				var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;
				if (null !== request && "function" === typeof isSignatureEqual) {
					var postbackKey = request[1];
					isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = createPostbackActionStateKey$1(permalink, componentKeyPath, actionStateHookIndex), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex$2 = actionStateHookIndex, initialState = request[0]));
				}
				var boundAction = action.bind(null, initialState);
				action = function(payload) {
					boundAction(payload);
				};
				"function" === typeof boundAction.$$FORM_ACTION && (action.$$FORM_ACTION = function(prefix$3) {
					prefix$3 = boundAction.$$FORM_ACTION(prefix$3);
					void 0 !== permalink && (checkAttributeStringCoercion(permalink, "target"), permalink += "", prefix$3.action = permalink);
					var formData = prefix$3.data;
					formData && (null === nextPostbackStateKey && (nextPostbackStateKey = createPostbackActionStateKey$1(permalink, componentKeyPath, actionStateHookIndex)), formData.append("$ACTION_KEY", nextPostbackStateKey));
					return prefix$3;
				});
				return [
					initialState,
					action,
					!1
				];
			}
			var _boundAction = action.bind(null, initialState);
			return [
				initialState,
				function(payload) {
					_boundAction(payload);
				},
				!1
			];
		}
		function unwrapThenable$2(thenable) {
			var index = thenableIndexCounter$2;
			thenableIndexCounter$2 += 1;
			null === thenableState$2 && (thenableState$2 = []);
			return trackUsedThenable$2(thenableState$2, thenable, index);
		}
		function unsupportedRefresh$2() {
			throw Error("Cache cannot be refreshed during server rendering.");
		}
		function disabledLog() {}
		function disableLogs() {
			if (0 === disabledDepth) {
				prevLog = console.log;
				prevInfo = console.info;
				prevWarn = console.warn;
				prevError = console.error;
				prevGroup = console.group;
				prevGroupCollapsed = console.groupCollapsed;
				prevGroupEnd = console.groupEnd;
				var props = {
					configurable: !0,
					enumerable: !0,
					value: disabledLog,
					writable: !0
				};
				Object.defineProperties(console, {
					info: props,
					log: props,
					warn: props,
					error: props,
					group: props,
					groupCollapsed: props,
					groupEnd: props
				});
			}
			disabledDepth++;
		}
		function reenableLogs() {
			disabledDepth--;
			if (0 === disabledDepth) {
				var props = {
					configurable: !0,
					enumerable: !0,
					writable: !0
				};
				Object.defineProperties(console, {
					log: assign$2({}, props, { value: prevLog }),
					info: assign$2({}, props, { value: prevInfo }),
					warn: assign$2({}, props, { value: prevWarn }),
					error: assign$2({}, props, { value: prevError }),
					group: assign$2({}, props, { value: prevGroup }),
					groupCollapsed: assign$2({}, props, { value: prevGroupCollapsed }),
					groupEnd: assign$2({}, props, { value: prevGroupEnd })
				});
			}
			0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
		}
		function prepareStackTrace$1(error, structuredStackTrace) {
			error = (error.name || "Error") + ": " + (error.message || "");
			for (var i = 0; i < structuredStackTrace.length; i++) error += "\n    at " + structuredStackTrace[i].toString();
			return error;
		}
		function formatOwnerStack(error) {
			var prevPrepareStackTrace = Error.prepareStackTrace;
			Error.prepareStackTrace = prepareStackTrace$1;
			error = error.stack;
			Error.prepareStackTrace = prevPrepareStackTrace;
			error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
			prevPrepareStackTrace = error.indexOf("\n");
			-1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
			prevPrepareStackTrace = error.indexOf("react_stack_bottom_frame");
			-1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf("\n", prevPrepareStackTrace));
			if (-1 !== prevPrepareStackTrace) error = error.slice(0, prevPrepareStackTrace);
			else return "";
			return error;
		}
		function describeBuiltInComponentFrame$2(name) {
			if (void 0 === prefix$2) try {
				throw Error();
			} catch (x) {
				var match = x.stack.trim().match(/\n( *(at )?)/);
				prefix$2 = match && match[1] || "";
				suffix$2 = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
			}
			return "\n" + prefix$2 + name + suffix$2;
		}
		function describeNativeComponentFrame$2(fn, construct) {
			if (!fn || reentry$2) return "";
			var frame = componentFrameCache.get(fn);
			if (void 0 !== frame) return frame;
			reentry$2 = !0;
			frame = Error.prepareStackTrace;
			Error.prepareStackTrace = prepareStackTrace$1;
			var previousDispatcher$3 = null;
			previousDispatcher$3 = ReactSharedInternals$2.H;
			ReactSharedInternals$2.H = null;
			disableLogs();
			try {
				var RunInRootFrame = { DetermineComponentFrameRoot: function() {
					try {
						if (construct) {
							var Fake = function() {
								throw Error();
							};
							Object.defineProperty(Fake.prototype, "props", { set: function() {
								throw Error();
							} });
							if ("object" === typeof Reflect && Reflect.construct) {
								try {
									Reflect.construct(Fake, []);
								} catch (x) {
									var control = x;
								}
								Reflect.construct(fn, [], Fake);
							} else {
								try {
									Fake.call();
								} catch (x$0) {
									control = x$0;
								}
								fn.call(Fake.prototype);
							}
						} else {
							try {
								throw Error();
							} catch (x$1) {
								control = x$1;
							}
							(Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {});
						}
					} catch (sample) {
						if (sample && control && "string" === typeof sample.stack) return [sample.stack, control.stack];
					}
					return [null, null];
				} };
				RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
				var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
				namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
				var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
				if (sampleStack && controlStack) {
					var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
					for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot");) namePropDescriptor++;
					for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot");) _RunInRootFrame$Deter++;
					if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];) _RunInRootFrame$Deter--;
					for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--) if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
						if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) do
							if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
								var _frame = "\n" + sampleLines[namePropDescriptor].replace(" at new ", " at ");
								fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
								"function" === typeof fn && componentFrameCache.set(fn, _frame);
								return _frame;
							}
						while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
						break;
					}
				}
			} finally {
				reentry$2 = !1, ReactSharedInternals$2.H = previousDispatcher$3, reenableLogs(), Error.prepareStackTrace = frame;
			}
			sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame$2(sampleLines) : "";
			"function" === typeof fn && componentFrameCache.set(fn, sampleLines);
			return sampleLines;
		}
		function describeComponentStackByType$2(type) {
			if ("string" === typeof type) return describeBuiltInComponentFrame$2(type);
			if ("function" === typeof type) return type.prototype && type.prototype.isReactComponent ? describeNativeComponentFrame$2(type, !0) : describeNativeComponentFrame$2(type, !1);
			if ("object" === typeof type && null !== type) {
				switch (type.$$typeof) {
					case REACT_FORWARD_REF_TYPE$2: return describeNativeComponentFrame$2(type.render, !1);
					case REACT_MEMO_TYPE$2: return describeNativeComponentFrame$2(type.type, !1);
					case REACT_LAZY_TYPE$2:
						var lazyComponent = type, payload = lazyComponent._payload;
						lazyComponent = lazyComponent._init;
						try {
							type = lazyComponent(payload);
						} catch (x) {
							return describeBuiltInComponentFrame$2("Lazy");
						}
						return describeComponentStackByType$2(type);
				}
				if ("string" === typeof type.name) {
					a: {
						payload = type.name;
						lazyComponent = type.env;
						type = type.debugLocation;
						if (null != type) {
							type = formatOwnerStack(type);
							var idx = type.lastIndexOf("\n");
							type = -1 === idx ? type : type.slice(idx + 1);
							if (-1 !== type.indexOf(payload)) {
								payload = "\n" + type;
								break a;
							}
						}
						payload = describeBuiltInComponentFrame$2(payload + (lazyComponent ? " [" + lazyComponent + "]" : ""));
					}
					return payload;
				}
			}
			switch (type) {
				case REACT_SUSPENSE_LIST_TYPE$2: return describeBuiltInComponentFrame$2("SuspenseList");
				case REACT_SUSPENSE_TYPE$2: return describeBuiltInComponentFrame$2("Suspense");
			}
			return "";
		}
		function resetOwnerStackLimit() {
			var now = getCurrentTime();
			1e3 < now - lastResetTime && (ReactSharedInternals$2.recentlyCreatedOwnerStacks = 0, lastResetTime = now);
		}
		function isEligibleForOutlining$2(request, boundary) {
			return (500 < boundary.byteSize || hasSuspenseyContent$1(boundary.contentState)) && null === boundary.contentPreamble;
		}
		function defaultErrorHandler$2(error) {
			if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
				var JSCompiler_inline_result = error.environmentName;
				error = [error].slice(0);
				"string" === typeof error[0] ? error.splice(0, 1, "\x1B[0m\x1B[7m%c%s\x1B[0m%c " + error[0], "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", " " + JSCompiler_inline_result + " ", "") : error.splice(0, 0, "\x1B[0m\x1B[7m%c%s\x1B[0m%c", "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", " " + JSCompiler_inline_result + " ", "");
				error.unshift(console);
				JSCompiler_inline_result = bind$2.apply(console.error, error);
				JSCompiler_inline_result();
			} else console.error(error);
			return null;
		}
		function RequestInstance$2(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError$1, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
			var abortSet = /* @__PURE__ */ new Set();
			this.destination = null;
			this.flushScheduled = !1;
			this.resumableState = resumableState;
			this.renderState = renderState;
			this.rootFormatContext = rootFormatContext;
			this.progressiveChunkSize = void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;
			this.status = 10;
			this.fatalError = null;
			this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
			this.completedPreambleSegments = this.completedRootSegment = null;
			this.byteSize = 0;
			this.abortableTasks = abortSet;
			this.pingedTasks = [];
			this.clientRenderedBoundaries = [];
			this.completedBoundaries = [];
			this.partialBoundaries = [];
			this.trackedPostpones = null;
			this.onError = void 0 === onError$1 ? defaultErrorHandler$2 : onError$1;
			this.onPostpone = void 0 === onPostpone ? noop$2 : onPostpone;
			this.onAllReady = void 0 === onAllReady ? noop$2 : onAllReady;
			this.onShellReady = void 0 === onShellReady ? noop$2 : onShellReady;
			this.onShellError = void 0 === onShellError ? noop$2 : onShellError;
			this.onFatalError = void 0 === onFatalError ? noop$2 : onFatalError;
			this.formState = void 0 === formState ? null : formState;
			this.didWarnForKey = null;
		}
		function createRequest$2(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError$1, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
			resetOwnerStackLimit();
			resumableState = new RequestInstance$2(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError$1, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState);
			renderState = createPendingSegment$2(resumableState, 0, null, rootFormatContext, !1, !1);
			renderState.parentFlushed = !0;
			children = createRenderTask$2(resumableState, null, children, -1, null, renderState, null, null, resumableState.abortableTasks, null, rootFormatContext, null, emptyTreeContext$2, null, null, emptyContextObject$2, null);
			pushComponentStack$2(children);
			resumableState.pingedTasks.push(children);
			return resumableState;
		}
		function createPrerenderRequest$1(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError$1, onAllReady, onShellReady, onShellError, onFatalError, onPostpone) {
			children = createRequest$2(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError$1, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, void 0);
			children.trackedPostpones = {
				workingMap: /* @__PURE__ */ new Map(),
				rootNodes: [],
				rootSlots: null
			};
			return children;
		}
		function resumeRequest$1(children, postponedState, renderState, onError$1, onAllReady, onShellReady, onShellError, onFatalError, onPostpone) {
			resetOwnerStackLimit();
			renderState = new RequestInstance$2(postponedState.resumableState, renderState, postponedState.rootFormatContext, postponedState.progressiveChunkSize, onError$1, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, null);
			renderState.nextSegmentId = postponedState.nextSegmentId;
			if ("number" === typeof postponedState.replaySlots) return onError$1 = createPendingSegment$2(renderState, 0, null, postponedState.rootFormatContext, !1, !1), onError$1.parentFlushed = !0, children = createRenderTask$2(renderState, null, children, -1, null, onError$1, null, null, renderState.abortableTasks, null, postponedState.rootFormatContext, null, emptyTreeContext$2, null, null, emptyContextObject$2, null), pushComponentStack$2(children), renderState.pingedTasks.push(children), renderState;
			children = createReplayTask$2(renderState, null, {
				nodes: postponedState.replayNodes,
				slots: postponedState.replaySlots,
				pendingTasks: 0
			}, children, -1, null, null, renderState.abortableTasks, null, postponedState.rootFormatContext, null, emptyTreeContext$2, null, null, emptyContextObject$2, null);
			pushComponentStack$2(children);
			renderState.pingedTasks.push(children);
			return renderState;
		}
		function resumeAndPrerenderRequest$1(children, postponedState, renderState, onError$1, onAllReady, onShellReady, onShellError, onFatalError, onPostpone) {
			children = resumeRequest$1(children, postponedState, renderState, onError$1, onAllReady, onShellReady, onShellError, onFatalError, onPostpone);
			children.trackedPostpones = {
				workingMap: /* @__PURE__ */ new Map(),
				rootNodes: [],
				rootSlots: null
			};
			return children;
		}
		function resolveRequest$1() {
			if (currentRequest$2) return currentRequest$2;
			var store = requestStorage$1.getStore();
			return store ? store : null;
		}
		function pingTask$2(request, task) {
			request.pingedTasks.push(task);
			1 === request.pingedTasks.length && (request.flushScheduled = null !== request.destination, null !== request.trackedPostpones || 10 === request.status ? scheduleMicrotask$1(function() {
				return performWork$2(request);
			}) : setImmediate(function() {
				return performWork$2(request);
			}));
		}
		function createSuspenseBoundary$2(request, row, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {
			fallbackAbortableTasks = {
				status: PENDING,
				rootSegmentID: -1,
				parentFlushed: !1,
				pendingTasks: 0,
				row,
				completedSegments: [],
				byteSize: 0,
				fallbackAbortableTasks,
				errorDigest: null,
				contentState: createHoistableState$2(),
				fallbackState: createHoistableState$2(),
				contentPreamble,
				fallbackPreamble,
				trackedContentKeyPath: null,
				trackedFallbackNode: null,
				errorMessage: null,
				errorStack: null,
				errorComponentStack: null
			};
			null !== row && (row.pendingTasks++, contentPreamble = row.boundaries, null !== contentPreamble && (request.allPendingTasks++, fallbackAbortableTasks.pendingTasks++, contentPreamble.push(fallbackAbortableTasks)), request = row.inheritedHoistables, null !== request && hoistHoistables$2(fallbackAbortableTasks.contentState, request));
			return fallbackAbortableTasks;
		}
		function createRenderTask$2(request, thenableState$3, node, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context, treeContext, row, componentStack, legacyContext, debugTask) {
			request.allPendingTasks++;
			null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
			null !== row && row.pendingTasks++;
			var task = {
				replay: null,
				node,
				childIndex,
				ping: function() {
					return pingTask$2(request, task);
				},
				blockedBoundary,
				blockedSegment,
				blockedPreamble,
				hoistableState,
				abortSet,
				keyPath,
				formatContext,
				context,
				treeContext,
				row,
				componentStack,
				thenableState: thenableState$3
			};
			task.debugTask = debugTask;
			abortSet.add(task);
			return task;
		}
		function createReplayTask$2(request, thenableState$3, replay, node, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context, treeContext, row, componentStack, legacyContext, debugTask) {
			request.allPendingTasks++;
			null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
			null !== row && row.pendingTasks++;
			replay.pendingTasks++;
			var task = {
				replay,
				node,
				childIndex,
				ping: function() {
					return pingTask$2(request, task);
				},
				blockedBoundary,
				blockedSegment: null,
				blockedPreamble: null,
				hoistableState,
				abortSet,
				keyPath,
				formatContext,
				context,
				treeContext,
				row,
				componentStack,
				thenableState: thenableState$3
			};
			task.debugTask = debugTask;
			abortSet.add(task);
			return task;
		}
		function createPendingSegment$2(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {
			return {
				status: PENDING,
				parentFlushed: !1,
				id: -1,
				index,
				chunks: [],
				children: [],
				preambleChildren: [],
				parentFormatContext,
				boundary,
				lastPushedText,
				textEmbedded
			};
		}
		function getCurrentStackInDEV() {
			if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack) return "";
			var componentStack = currentTaskInDEV.componentStack;
			try {
				var info = "";
				if ("string" === typeof componentStack.type) info += describeBuiltInComponentFrame$2(componentStack.type);
				else if ("function" === typeof componentStack.type) {
					if (!componentStack.owner) {
						var JSCompiler_temp_const = info, fn = componentStack.type, name = fn ? fn.displayName || fn.name : "";
						var JSCompiler_inline_result = name ? describeBuiltInComponentFrame$2(name) : "";
						info = JSCompiler_temp_const + JSCompiler_inline_result;
					}
				} else componentStack.owner || (info += describeComponentStackByType$2(componentStack.type));
				for (; componentStack;) JSCompiler_temp_const = null, null != componentStack.debugStack ? JSCompiler_temp_const = formatOwnerStack(componentStack.debugStack) : (JSCompiler_inline_result = componentStack, null != JSCompiler_inline_result.stack && (JSCompiler_temp_const = "string" !== typeof JSCompiler_inline_result.stack ? JSCompiler_inline_result.stack = formatOwnerStack(JSCompiler_inline_result.stack) : JSCompiler_inline_result.stack)), (componentStack = componentStack.owner) && JSCompiler_temp_const && (info += "\n" + JSCompiler_temp_const);
				var JSCompiler_inline_result$jscomp$0 = info;
			} catch (x) {
				JSCompiler_inline_result$jscomp$0 = "\nError generating stack: " + x.message + "\n" + x.stack;
			}
			return JSCompiler_inline_result$jscomp$0;
		}
		function pushHaltedAwaitOnComponentStack(task, debugInfo) {
			if (null != debugInfo) for (var i = debugInfo.length - 1; 0 <= i; i--) {
				var info = debugInfo[i];
				if ("string" === typeof info.name) break;
				if ("number" === typeof info.time) break;
				if (null != info.awaited) {
					var bestStack = null == info.debugStack ? info.awaited : info;
					if (void 0 !== bestStack.debugStack) {
						task.componentStack = {
							parent: task.componentStack,
							type: info,
							owner: bestStack.owner,
							stack: bestStack.debugStack
						};
						task.debugTask = bestStack.debugTask;
						break;
					}
				}
			}
		}
		function pushServerComponentStack(task, debugInfo) {
			if (null != debugInfo) for (var i = 0; i < debugInfo.length; i++) {
				var componentInfo = debugInfo[i];
				"string" === typeof componentInfo.name && void 0 !== componentInfo.debugStack && (task.componentStack = {
					parent: task.componentStack,
					type: componentInfo,
					owner: componentInfo.owner,
					stack: componentInfo.debugStack
				}, task.debugTask = componentInfo.debugTask);
			}
		}
		function pushComponentStack$2(task) {
			var node = task.node;
			if ("object" === typeof node && null !== node) switch (node.$$typeof) {
				case REACT_ELEMENT_TYPE$2:
					var type = node.type, owner = node._owner, stack = node._debugStack;
					pushServerComponentStack(task, node._debugInfo);
					task.debugTask = node._debugTask;
					task.componentStack = {
						parent: task.componentStack,
						type,
						owner,
						stack
					};
					break;
				case REACT_LAZY_TYPE$2:
					pushServerComponentStack(task, node._debugInfo);
					break;
				default: "function" === typeof node.then && pushServerComponentStack(task, node._debugInfo);
			}
		}
		function replaceSuspenseComponentStackWithSuspenseFallbackStack$2(componentStack) {
			return null === componentStack ? null : {
				parent: componentStack.parent,
				type: "Suspense Fallback",
				owner: componentStack.owner,
				stack: componentStack.stack
			};
		}
		function getThrownInfo$2(node$jscomp$0) {
			var errorInfo = {};
			node$jscomp$0 && Object.defineProperty(errorInfo, "componentStack", {
				configurable: !0,
				enumerable: !0,
				get: function() {
					try {
						var info = "", node = node$jscomp$0;
						do
							info += describeComponentStackByType$2(node.type), node = node.parent;
						while (node);
						var stack = info;
					} catch (x) {
						stack = "\nError generating stack: " + x.message + "\n" + x.stack;
					}
					Object.defineProperty(errorInfo, "componentStack", { value: stack });
					return stack;
				}
			});
			return errorInfo;
		}
		function encodeErrorForBoundary(boundary, digest, error, thrownInfo, wasAborted) {
			boundary.errorDigest = digest;
			error instanceof Error ? (digest = String(error.message), error = String(error.stack)) : (digest = "object" === typeof error && null !== error ? describeObjectForErrorMessage(error) : String(error), error = null);
			wasAborted = wasAborted ? "Switched to client rendering because the server rendering aborted due to:\n\n" : "Switched to client rendering because the server rendering errored:\n\n";
			boundary.errorMessage = wasAborted + digest;
			boundary.errorStack = null !== error ? wasAborted + error : null;
			boundary.errorComponentStack = thrownInfo.componentStack;
		}
		function logRecoverableError$2(request, error, errorInfo, debugTask) {
			request = request.onError;
			error = debugTask ? debugTask.run(request.bind(null, error, errorInfo)) : request(error, errorInfo);
			if (null != error && "string" !== typeof error) console.error("onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"%s\" instead", typeof error);
			else return error;
		}
		function fatalError$2(request, error, errorInfo, debugTask) {
			errorInfo = request.onShellError;
			var onFatalError = request.onFatalError;
			debugTask ? (debugTask.run(errorInfo.bind(null, error)), debugTask.run(onFatalError.bind(null, error))) : (errorInfo(error), onFatalError(error));
			null !== request.destination ? (request.status = CLOSED, request.destination.destroy(error)) : (request.status = 13, request.fatalError = error);
		}
		function finishSuspenseListRow$2(request, row) {
			unblockSuspenseListRow$2(request, row.next, row.hoistables);
		}
		function unblockSuspenseListRow$2(request, unblockedRow, inheritedHoistables) {
			for (; null !== unblockedRow;) {
				null !== inheritedHoistables && (hoistHoistables$2(unblockedRow.hoistables, inheritedHoistables), unblockedRow.inheritedHoistables = inheritedHoistables);
				var unblockedBoundaries = unblockedRow.boundaries;
				if (null !== unblockedBoundaries) {
					unblockedRow.boundaries = null;
					for (var i = 0; i < unblockedBoundaries.length; i++) {
						var unblockedBoundary = unblockedBoundaries[i];
						null !== inheritedHoistables && hoistHoistables$2(unblockedBoundary.contentState, inheritedHoistables);
						finishedTask$2(request, unblockedBoundary, null, null);
					}
				}
				unblockedRow.pendingTasks--;
				if (0 < unblockedRow.pendingTasks) break;
				inheritedHoistables = unblockedRow.hoistables;
				unblockedRow = unblockedRow.next;
			}
		}
		function tryToResolveTogetherRow$2(request, togetherRow) {
			var boundaries = togetherRow.boundaries;
			if (null !== boundaries && togetherRow.pendingTasks === boundaries.length) {
				for (var allCompleteAndInlinable = !0, i = 0; i < boundaries.length; i++) {
					var rowBoundary = boundaries[i];
					if (1 !== rowBoundary.pendingTasks || rowBoundary.parentFlushed || isEligibleForOutlining$2(request, rowBoundary)) {
						allCompleteAndInlinable = !1;
						break;
					}
				}
				allCompleteAndInlinable && unblockSuspenseListRow$2(request, togetherRow, togetherRow.hoistables);
			}
		}
		function createSuspenseListRow$2(previousRow) {
			var newRow = {
				pendingTasks: 1,
				boundaries: null,
				hoistables: createHoistableState$2(),
				inheritedHoistables: null,
				together: !1,
				next: null
			};
			null !== previousRow && 0 < previousRow.pendingTasks && (newRow.pendingTasks++, newRow.boundaries = [], previousRow.next = newRow);
			return newRow;
		}
		function renderSuspenseListRows$2(request, task, keyPath, rows, revealOrder) {
			var prevKeyPath = task.keyPath, prevTreeContext = task.treeContext, prevRow = task.row, previousComponentStack = task.componentStack;
			var previousDebugTask = task.debugTask;
			pushServerComponentStack(task, task.node.props.children._debugInfo);
			task.keyPath = keyPath;
			keyPath = rows.length;
			var previousSuspenseListRow = null;
			if (null !== task.replay) {
				var resumeSlots = task.replay.slots;
				if (null !== resumeSlots && "object" === typeof resumeSlots) for (var n = 0; n < keyPath; n++) {
					var i = "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder ? n : keyPath - 1 - n, node = rows[i];
					task.row = previousSuspenseListRow = createSuspenseListRow$2(previousSuspenseListRow);
					task.treeContext = pushTreeContext$2(prevTreeContext, keyPath, i);
					var resumeSegmentID = resumeSlots[i];
					"number" === typeof resumeSegmentID ? (resumeNode$2(request, task, resumeSegmentID, node, i), delete resumeSlots[i]) : renderNode$2(request, task, node, i);
					0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow$2(request, previousSuspenseListRow);
				}
				else for (resumeSlots = 0; resumeSlots < keyPath; resumeSlots++) n = "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder ? resumeSlots : keyPath - 1 - resumeSlots, i = rows[n], warnForMissingKey(request, task, i), task.row = previousSuspenseListRow = createSuspenseListRow$2(previousSuspenseListRow), task.treeContext = pushTreeContext$2(prevTreeContext, keyPath, n), renderNode$2(request, task, i, n), 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow$2(request, previousSuspenseListRow);
			} else if ("backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder) for (revealOrder = 0; revealOrder < keyPath; revealOrder++) resumeSlots = rows[revealOrder], warnForMissingKey(request, task, resumeSlots), task.row = previousSuspenseListRow = createSuspenseListRow$2(previousSuspenseListRow), task.treeContext = pushTreeContext$2(prevTreeContext, keyPath, revealOrder), renderNode$2(request, task, resumeSlots, revealOrder), 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow$2(request, previousSuspenseListRow);
			else {
				revealOrder = task.blockedSegment;
				resumeSlots = revealOrder.children.length;
				n = revealOrder.chunks.length;
				for (i = keyPath - 1; 0 <= i; i--) {
					node = rows[i];
					task.row = previousSuspenseListRow = createSuspenseListRow$2(previousSuspenseListRow);
					task.treeContext = pushTreeContext$2(prevTreeContext, keyPath, i);
					resumeSegmentID = createPendingSegment$2(request, n, null, task.formatContext, 0 === i ? revealOrder.lastPushedText : !0, !0);
					revealOrder.children.splice(resumeSlots, 0, resumeSegmentID);
					task.blockedSegment = resumeSegmentID;
					warnForMissingKey(request, task, node);
					try {
						renderNode$2(request, task, node, i), resumeSegmentID.lastPushedText && resumeSegmentID.textEmbedded && resumeSegmentID.chunks.push(textSeparator$1), resumeSegmentID.status = COMPLETED, finishedSegment$1(request, task.blockedBoundary, resumeSegmentID), 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow$2(request, previousSuspenseListRow);
					} catch (thrownValue) {
						throw resumeSegmentID.status = 12 === request.status ? ABORTED : ERRORED, thrownValue;
					}
				}
				task.blockedSegment = revealOrder;
				revealOrder.lastPushedText = !1;
			}
			null !== prevRow && null !== previousSuspenseListRow && 0 < previousSuspenseListRow.pendingTasks && (prevRow.pendingTasks++, previousSuspenseListRow.next = prevRow);
			task.treeContext = prevTreeContext;
			task.row = prevRow;
			task.keyPath = prevKeyPath;
			task.componentStack = previousComponentStack;
			task.debugTask = previousDebugTask;
		}
		function renderWithHooks$2(request, task, keyPath, Component, props, secondArg) {
			var prevThenableState = task.thenableState;
			task.thenableState = null;
			currentlyRenderingComponent$2 = {};
			currentlyRenderingTask$2 = task;
			currentlyRenderingRequest$2 = request;
			currentlyRenderingKeyPath$2 = keyPath;
			isInHookUserCodeInDev = !1;
			actionStateCounter$2 = localIdCounter$2 = 0;
			actionStateMatchingIndex$2 = -1;
			thenableIndexCounter$2 = 0;
			thenableState$2 = prevThenableState;
			for (request = callComponentInDEV(Component, props, secondArg); didScheduleRenderPhaseUpdate$2;) didScheduleRenderPhaseUpdate$2 = !1, actionStateCounter$2 = localIdCounter$2 = 0, actionStateMatchingIndex$2 = -1, thenableIndexCounter$2 = 0, numberOfReRenders$2 += 1, workInProgressHook$2 = null, request = Component(props, secondArg);
			resetHooksState$2();
			return request;
		}
		function finishFunctionComponent$2(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex$3) {
			var didEmitActionStateMarkers = !1;
			if (0 !== actionStateCount && null !== request.formState) {
				var segment = task.blockedSegment;
				if (null !== segment) {
					didEmitActionStateMarkers = !0;
					segment = segment.chunks;
					for (var i = 0; i < actionStateCount; i++) i === actionStateMatchingIndex$3 ? segment.push(formStateMarkerIsMatching$1) : segment.push(formStateMarkerIsNotMatching$1);
				}
			}
			actionStateCount = task.keyPath;
			task.keyPath = keyPath;
			hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext$2(keyPath, 1, 0), renderNode$2(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode$2(request, task, children, -1) : renderNodeDestructive$2(request, task, children, -1);
			task.keyPath = actionStateCount;
		}
		function renderElement$2(request, task, keyPath, type, props, ref) {
			if ("function" === typeof type) if (type.prototype && type.prototype.isReactComponent) {
				var newProps = props;
				if ("ref" in props) {
					newProps = {};
					for (var propName in props) "ref" !== propName && (newProps[propName] = props[propName]);
				}
				var defaultProps = type.defaultProps;
				if (defaultProps) {
					newProps === props && (newProps = assign$2({}, newProps, props));
					for (var _propName in defaultProps) void 0 === newProps[_propName] && (newProps[_propName] = defaultProps[_propName]);
				}
				var resolvedProps = newProps;
				var context = emptyContextObject$2, contextType = type.contextType;
				if ("contextType" in type && null !== contextType && (void 0 === contextType || contextType.$$typeof !== REACT_CONTEXT_TYPE$2) && !didWarnAboutInvalidateContextType.has(type)) {
					didWarnAboutInvalidateContextType.add(type);
					var addendum = void 0 === contextType ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof contextType ? " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_CONSUMER_TYPE$2 ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
					console.error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType$2(type) || "Component", addendum);
				}
				"object" === typeof contextType && null !== contextType && (context = contextType._currentValue);
				var instance = new type(resolvedProps, context);
				if ("function" === typeof type.getDerivedStateFromProps && (null === instance.state || void 0 === instance.state)) {
					var componentName = getComponentNameFromType$2(type) || "Component";
					didWarnAboutUninitializedState.has(componentName) || (didWarnAboutUninitializedState.add(componentName), console.error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, null === instance.state ? "null" : "undefined", componentName));
				}
				if ("function" === typeof type.getDerivedStateFromProps || "function" === typeof instance.getSnapshotBeforeUpdate) {
					var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
					"function" === typeof instance.componentWillMount && !0 !== instance.componentWillMount.__suppressDeprecationWarning ? foundWillMountName = "componentWillMount" : "function" === typeof instance.UNSAFE_componentWillMount && (foundWillMountName = "UNSAFE_componentWillMount");
					"function" === typeof instance.componentWillReceiveProps && !0 !== instance.componentWillReceiveProps.__suppressDeprecationWarning ? foundWillReceivePropsName = "componentWillReceiveProps" : "function" === typeof instance.UNSAFE_componentWillReceiveProps && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps");
					"function" === typeof instance.componentWillUpdate && !0 !== instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
					if (null !== foundWillMountName || null !== foundWillReceivePropsName || null !== foundWillUpdateName) {
						var _componentName = getComponentNameFromType$2(type) || "Component", newApiName = "function" === typeof type.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
						didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName), console.error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles", _componentName, newApiName, null !== foundWillMountName ? "\n  " + foundWillMountName : "", null !== foundWillReceivePropsName ? "\n  " + foundWillReceivePropsName : "", null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""));
					}
				}
				var name = getComponentNameFromType$2(type) || "Component";
				instance.render || (type.prototype && "function" === typeof type.prototype.render ? console.error("No `render` method found on the %s instance: did you accidentally return an object from the constructor?", name) : console.error("No `render` method found on the %s instance: you may have forgotten to define `render`.", name));
				!instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state || console.error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
				instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved && console.error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
				instance.contextType && console.error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
				type.childContextTypes && !didWarnAboutChildContextTypes.has(type) && (didWarnAboutChildContextTypes.add(type), console.error("%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)", name));
				type.contextTypes && !didWarnAboutContextTypes$1.has(type) && (didWarnAboutContextTypes$1.add(type), console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)", name));
				"function" === typeof instance.componentShouldUpdate && console.error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
				type.prototype && type.prototype.isPureReactComponent && "undefined" !== typeof instance.shouldComponentUpdate && console.error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType$2(type) || "A pure component");
				"function" === typeof instance.componentDidUnmount && console.error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
				"function" === typeof instance.componentDidReceiveProps && console.error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
				"function" === typeof instance.componentWillRecieveProps && console.error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
				"function" === typeof instance.UNSAFE_componentWillRecieveProps && console.error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
				var hasMutatedProps = instance.props !== resolvedProps;
				void 0 !== instance.props && hasMutatedProps && console.error("When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name);
				instance.defaultProps && console.error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
				"function" !== typeof instance.getSnapshotBeforeUpdate || "function" === typeof instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type), console.error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType$2(type)));
				"function" === typeof instance.getDerivedStateFromProps && console.error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
				"function" === typeof instance.getDerivedStateFromError && console.error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
				"function" === typeof type.getSnapshotBeforeUpdate && console.error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
				var state = instance.state;
				state && ("object" !== typeof state || isArrayImpl$2(state)) && console.error("%s.state: must be set to an object or null", name);
				"function" === typeof instance.getChildContext && "object" !== typeof type.childContextTypes && console.error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
				var initialState = void 0 !== instance.state ? instance.state : null;
				instance.updater = classComponentUpdater$2;
				instance.props = resolvedProps;
				instance.state = initialState;
				var internalInstance = {
					queue: [],
					replace: !1
				};
				instance._reactInternals = internalInstance;
				var contextType$jscomp$0 = type.contextType;
				instance.context = "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 ? contextType$jscomp$0._currentValue : emptyContextObject$2;
				if (instance.state === resolvedProps) {
					var componentName$jscomp$0 = getComponentNameFromType$2(type) || "Component";
					didWarnAboutDirectlyAssigningPropsToState.has(componentName$jscomp$0) || (didWarnAboutDirectlyAssigningPropsToState.add(componentName$jscomp$0), console.error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName$jscomp$0));
				}
				var getDerivedStateFromProps = type.getDerivedStateFromProps;
				if ("function" === typeof getDerivedStateFromProps) {
					var partialState = getDerivedStateFromProps(resolvedProps, initialState);
					if (void 0 === partialState) {
						var componentName$jscomp$1 = getComponentNameFromType$2(type) || "Component";
						didWarnAboutUndefinedDerivedState.has(componentName$jscomp$1) || (didWarnAboutUndefinedDerivedState.add(componentName$jscomp$1), console.error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName$jscomp$1));
					}
					instance.state = null === partialState || void 0 === partialState ? initialState : assign$2({}, initialState, partialState);
				}
				if ("function" !== typeof type.getDerivedStateFromProps && "function" !== typeof instance.getSnapshotBeforeUpdate && ("function" === typeof instance.UNSAFE_componentWillMount || "function" === typeof instance.componentWillMount)) {
					var oldState = instance.state;
					if ("function" === typeof instance.componentWillMount) {
						if (!0 !== instance.componentWillMount.__suppressDeprecationWarning) {
							var componentName$jscomp$2 = getComponentNameFromType$2(type) || "Unknown";
							didWarnAboutDeprecatedWillMount[componentName$jscomp$2] || (console.warn("componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s", componentName$jscomp$2), didWarnAboutDeprecatedWillMount[componentName$jscomp$2] = !0);
						}
						instance.componentWillMount();
					}
					"function" === typeof instance.UNSAFE_componentWillMount && instance.UNSAFE_componentWillMount();
					oldState !== instance.state && (console.error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType$2(type) || "Component"), classComponentUpdater$2.enqueueReplaceState(instance, instance.state, null));
					if (null !== internalInstance.queue && 0 < internalInstance.queue.length) {
						var oldQueue = internalInstance.queue, oldReplace = internalInstance.replace;
						internalInstance.queue = null;
						internalInstance.replace = !1;
						if (oldReplace && 1 === oldQueue.length) instance.state = oldQueue[0];
						else {
							for (var nextState = oldReplace ? oldQueue[0] : instance.state, dontMutate = !0, i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
								var partial = oldQueue[i], partialState$jscomp$0 = "function" === typeof partial ? partial.call(instance, nextState, resolvedProps, void 0) : partial;
								null != partialState$jscomp$0 && (dontMutate ? (dontMutate = !1, nextState = assign$2({}, nextState, partialState$jscomp$0)) : assign$2(nextState, partialState$jscomp$0));
							}
							instance.state = nextState;
						}
					} else internalInstance.queue = null;
				}
				var nextChildren = callRenderInDEV(instance);
				if (12 === request.status) throw null;
				instance.props !== resolvedProps && (didWarnAboutReassigningProps || console.error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType$2(type) || "a component"), didWarnAboutReassigningProps = !0);
				var prevKeyPath = task.keyPath;
				task.keyPath = keyPath;
				renderNodeDestructive$2(request, task, nextChildren, -1);
				task.keyPath = prevKeyPath;
			} else {
				if (type.prototype && "function" === typeof type.prototype.render) {
					var componentName$jscomp$3 = getComponentNameFromType$2(type) || "Unknown";
					didWarnAboutBadClass[componentName$jscomp$3] || (console.error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName$jscomp$3, componentName$jscomp$3), didWarnAboutBadClass[componentName$jscomp$3] = !0);
				}
				var value = renderWithHooks$2(request, task, keyPath, type, props, void 0);
				if (12 === request.status) throw null;
				var hasId = 0 !== localIdCounter$2, actionStateCount = actionStateCounter$2, actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex$2;
				if (type.contextTypes) {
					var _componentName$jscomp$0 = getComponentNameFromType$2(type) || "Unknown";
					didWarnAboutContextTypes[_componentName$jscomp$0] || (didWarnAboutContextTypes[_componentName$jscomp$0] = !0, console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)", _componentName$jscomp$0));
				}
				type && type.childContextTypes && console.error("childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...", type.displayName || type.name || "Component");
				if ("function" === typeof type.getDerivedStateFromProps) {
					var componentName$jscomp$4 = getComponentNameFromType$2(type) || "Unknown";
					didWarnAboutGetDerivedStateOnFunctionComponent[componentName$jscomp$4] || (console.error("%s: Function components do not support getDerivedStateFromProps.", componentName$jscomp$4), didWarnAboutGetDerivedStateOnFunctionComponent[componentName$jscomp$4] = !0);
				}
				if ("object" === typeof type.contextType && null !== type.contextType) {
					var _componentName2 = getComponentNameFromType$2(type) || "Unknown";
					didWarnAboutContextTypeOnFunctionComponent[_componentName2] || (console.error("%s: Function components do not support contextType.", _componentName2), didWarnAboutContextTypeOnFunctionComponent[_componentName2] = !0);
				}
				finishFunctionComponent$2(request, task, keyPath, value, hasId, actionStateCount, actionStateMatchingIndex$jscomp$0);
			}
			else if ("string" === typeof type) {
				var segment = task.blockedSegment;
				if (null === segment) {
					var children = props.children, prevContext = task.formatContext, prevKeyPath$jscomp$0 = task.keyPath;
					task.formatContext = getChildFormatContext$2(prevContext, type, props);
					task.keyPath = keyPath;
					renderNode$2(request, task, children, -1);
					task.formatContext = prevContext;
					task.keyPath = prevKeyPath$jscomp$0;
				} else {
					var _children = pushStartInstance$2(segment.chunks, type, props, request.resumableState, request.renderState, task.blockedPreamble, task.hoistableState, task.formatContext, segment.lastPushedText);
					segment.lastPushedText = !1;
					var _prevContext2 = task.formatContext, _prevKeyPath3 = task.keyPath;
					task.keyPath = keyPath;
					if ((task.formatContext = getChildFormatContext$2(_prevContext2, type, props)).insertionMode === HTML_HEAD_MODE) {
						var preambleSegment = createPendingSegment$2(request, 0, null, task.formatContext, !1, !1);
						segment.preambleChildren.push(preambleSegment);
						task.blockedSegment = preambleSegment;
						try {
							preambleSegment.status = 6, renderNode$2(request, task, _children, -1), preambleSegment.lastPushedText && preambleSegment.textEmbedded && preambleSegment.chunks.push(textSeparator$1), preambleSegment.status = COMPLETED, finishedSegment$1(request, task.blockedBoundary, preambleSegment);
						} finally {
							task.blockedSegment = segment;
						}
					} else renderNode$2(request, task, _children, -1);
					task.formatContext = _prevContext2;
					task.keyPath = _prevKeyPath3;
					a: {
						var target = segment.chunks, resumableState = request.resumableState;
						switch (type) {
							case "title":
							case "style":
							case "script":
							case "area":
							case "base":
							case "br":
							case "col":
							case "embed":
							case "hr":
							case "img":
							case "input":
							case "keygen":
							case "link":
							case "meta":
							case "param":
							case "source":
							case "track":
							case "wbr": break a;
							case "body":
								if (_prevContext2.insertionMode <= HTML_HTML_MODE) {
									resumableState.hasBody = !0;
									break a;
								}
								break;
							case "html":
								if (_prevContext2.insertionMode === ROOT_HTML_MODE) {
									resumableState.hasHtml = !0;
									break a;
								}
								break;
							case "head": if (_prevContext2.insertionMode <= HTML_HTML_MODE) break a;
						}
						target.push(endChunkForTag$2(type));
					}
					segment.lastPushedText = !1;
				}
			} else {
				switch (type) {
					case REACT_LEGACY_HIDDEN_TYPE$2:
					case REACT_STRICT_MODE_TYPE$2:
					case REACT_PROFILER_TYPE$2:
					case REACT_FRAGMENT_TYPE$2:
						var prevKeyPath$jscomp$1 = task.keyPath;
						task.keyPath = keyPath;
						renderNodeDestructive$2(request, task, props.children, -1);
						task.keyPath = prevKeyPath$jscomp$1;
						return;
					case REACT_ACTIVITY_TYPE$2:
						var segment$jscomp$0 = task.blockedSegment;
						if (null === segment$jscomp$0) {
							if ("hidden" !== props.mode) {
								var prevKeyPath$jscomp$2 = task.keyPath;
								task.keyPath = keyPath;
								renderNode$2(request, task, props.children, -1);
								task.keyPath = prevKeyPath$jscomp$2;
							}
						} else if ("hidden" !== props.mode) {
							segment$jscomp$0.chunks.push(startActivityBoundary$1);
							segment$jscomp$0.lastPushedText = !1;
							var _prevKeyPath4 = task.keyPath;
							task.keyPath = keyPath;
							renderNode$2(request, task, props.children, -1);
							task.keyPath = _prevKeyPath4;
							segment$jscomp$0.chunks.push(endActivityBoundary$1);
							segment$jscomp$0.lastPushedText = !1;
						}
						return;
					case REACT_SUSPENSE_LIST_TYPE$2:
						a: {
							var children$jscomp$0 = props.children, revealOrder = props.revealOrder;
							if ("forwards" === revealOrder || "backwards" === revealOrder || "unstable_legacy-backwards" === revealOrder) {
								if (isArrayImpl$2(children$jscomp$0)) {
									renderSuspenseListRows$2(request, task, keyPath, children$jscomp$0, revealOrder);
									break a;
								}
								var iteratorFn = getIteratorFn$2(children$jscomp$0);
								if (iteratorFn) {
									var iterator = iteratorFn.call(children$jscomp$0);
									if (iterator) {
										validateIterable(task, children$jscomp$0, -1, iterator, iteratorFn);
										var step = iterator.next();
										if (!step.done) {
											var rows = [];
											do
												rows.push(step.value), step = iterator.next();
											while (!step.done);
											renderSuspenseListRows$2(request, task, keyPath, children$jscomp$0, revealOrder);
										}
										break a;
									}
								}
							}
							if ("together" === revealOrder) {
								var _prevKeyPath2 = task.keyPath, prevRow = task.row, newRow = task.row = createSuspenseListRow$2(null);
								newRow.boundaries = [];
								newRow.together = !0;
								task.keyPath = keyPath;
								renderNodeDestructive$2(request, task, children$jscomp$0, -1);
								0 === --newRow.pendingTasks && finishSuspenseListRow$2(request, newRow);
								task.keyPath = _prevKeyPath2;
								task.row = prevRow;
								null !== prevRow && 0 < newRow.pendingTasks && (prevRow.pendingTasks++, newRow.next = prevRow);
							} else {
								var prevKeyPath$jscomp$3 = task.keyPath;
								task.keyPath = keyPath;
								renderNodeDestructive$2(request, task, children$jscomp$0, -1);
								task.keyPath = prevKeyPath$jscomp$3;
							}
						}
						return;
					case REACT_VIEW_TRANSITION_TYPE$2:
					case REACT_SCOPE_TYPE$2: throw Error("ReactDOMServer does not yet support scope components.");
					case REACT_SUSPENSE_TYPE$2:
						a: if (null !== task.replay) {
							var _prevKeyPath = task.keyPath, _prevContext = task.formatContext, _prevRow = task.row;
							task.keyPath = keyPath;
							task.formatContext = getSuspenseContentFormatContext$2(request.resumableState, _prevContext);
							task.row = null;
							var _content = props.children;
							try {
								renderNode$2(request, task, _content, -1);
							} finally {
								task.keyPath = _prevKeyPath, task.formatContext = _prevContext, task.row = _prevRow;
							}
						} else {
							var prevKeyPath$jscomp$4 = task.keyPath, prevContext$jscomp$0 = task.formatContext, prevRow$jscomp$0 = task.row, parentBoundary = task.blockedBoundary, parentPreamble = task.blockedPreamble, parentHoistableState = task.hoistableState, parentSegment = task.blockedSegment, fallback = props.fallback, content = props.children, fallbackAbortSet = /* @__PURE__ */ new Set();
							var newBoundary = task.formatContext.insertionMode < HTML_MODE ? createSuspenseBoundary$2(request, task.row, fallbackAbortSet, createPreambleState$1(), createPreambleState$1()) : createSuspenseBoundary$2(request, task.row, fallbackAbortSet, null, null);
							null !== request.trackedPostpones && (newBoundary.trackedContentKeyPath = keyPath);
							var boundarySegment = createPendingSegment$2(request, parentSegment.chunks.length, newBoundary, task.formatContext, !1, !1);
							parentSegment.children.push(boundarySegment);
							parentSegment.lastPushedText = !1;
							var contentRootSegment = createPendingSegment$2(request, 0, null, task.formatContext, !1, !1);
							contentRootSegment.parentFlushed = !0;
							if (null !== request.trackedPostpones) {
								var suspenseComponentStack = task.componentStack, fallbackKeyPath = [
									keyPath[0],
									"Suspense Fallback",
									keyPath[2]
								], fallbackReplayNode = [
									fallbackKeyPath[1],
									fallbackKeyPath[2],
									[],
									null
								];
								request.trackedPostpones.workingMap.set(fallbackKeyPath, fallbackReplayNode);
								newBoundary.trackedFallbackNode = fallbackReplayNode;
								task.blockedSegment = boundarySegment;
								task.blockedPreamble = newBoundary.fallbackPreamble;
								task.keyPath = fallbackKeyPath;
								task.formatContext = getSuspenseFallbackFormatContext$2(request.resumableState, prevContext$jscomp$0);
								task.componentStack = replaceSuspenseComponentStackWithSuspenseFallbackStack$2(suspenseComponentStack);
								boundarySegment.status = 6;
								try {
									renderNode$2(request, task, fallback, -1), boundarySegment.lastPushedText && boundarySegment.textEmbedded && boundarySegment.chunks.push(textSeparator$1), boundarySegment.status = COMPLETED, finishedSegment$1(request, parentBoundary, boundarySegment);
								} catch (thrownValue) {
									throw boundarySegment.status = 12 === request.status ? ABORTED : ERRORED, thrownValue;
								} finally {
									task.blockedSegment = parentSegment, task.blockedPreamble = parentPreamble, task.keyPath = prevKeyPath$jscomp$4, task.formatContext = prevContext$jscomp$0;
								}
								var suspendedPrimaryTask = createRenderTask$2(request, null, content, -1, newBoundary, contentRootSegment, newBoundary.contentPreamble, newBoundary.contentState, task.abortSet, keyPath, getSuspenseContentFormatContext$2(request.resumableState, task.formatContext), task.context, task.treeContext, null, suspenseComponentStack, emptyContextObject$2, task.debugTask);
								pushComponentStack$2(suspendedPrimaryTask);
								request.pingedTasks.push(suspendedPrimaryTask);
							} else {
								task.blockedBoundary = newBoundary;
								task.blockedPreamble = newBoundary.contentPreamble;
								task.hoistableState = newBoundary.contentState;
								task.blockedSegment = contentRootSegment;
								task.keyPath = keyPath;
								task.formatContext = getSuspenseContentFormatContext$2(request.resumableState, prevContext$jscomp$0);
								task.row = null;
								contentRootSegment.status = 6;
								try {
									if (renderNode$2(request, task, content, -1), contentRootSegment.lastPushedText && contentRootSegment.textEmbedded && contentRootSegment.chunks.push(textSeparator$1), contentRootSegment.status = COMPLETED, finishedSegment$1(request, newBoundary, contentRootSegment), queueCompletedSegment$2(newBoundary, contentRootSegment), 0 === newBoundary.pendingTasks && newBoundary.status === PENDING) {
										if (newBoundary.status = COMPLETED, !isEligibleForOutlining$2(request, newBoundary)) {
											null !== prevRow$jscomp$0 && 0 === --prevRow$jscomp$0.pendingTasks && finishSuspenseListRow$2(request, prevRow$jscomp$0);
											0 === request.pendingRootTasks && task.blockedPreamble && preparePreamble$2(request);
											break a;
										}
									} else null !== prevRow$jscomp$0 && prevRow$jscomp$0.together && tryToResolveTogetherRow$2(request, prevRow$jscomp$0);
								} catch (thrownValue$2) {
									newBoundary.status = CLIENT_RENDERED;
									if (12 === request.status) {
										contentRootSegment.status = ABORTED;
										var error = request.fatalError;
									} else contentRootSegment.status = ERRORED, error = thrownValue$2;
									var thrownInfo = getThrownInfo$2(task.componentStack);
									encodeErrorForBoundary(newBoundary, logRecoverableError$2(request, error, thrownInfo, task.debugTask), error, thrownInfo, !1);
									untrackBoundary$2(request, newBoundary);
								} finally {
									task.blockedBoundary = parentBoundary, task.blockedPreamble = parentPreamble, task.hoistableState = parentHoistableState, task.blockedSegment = parentSegment, task.keyPath = prevKeyPath$jscomp$4, task.formatContext = prevContext$jscomp$0, task.row = prevRow$jscomp$0;
								}
								var suspendedFallbackTask = createRenderTask$2(request, null, fallback, -1, parentBoundary, boundarySegment, newBoundary.fallbackPreamble, newBoundary.fallbackState, fallbackAbortSet, [
									keyPath[0],
									"Suspense Fallback",
									keyPath[2]
								], getSuspenseFallbackFormatContext$2(request.resumableState, task.formatContext), task.context, task.treeContext, task.row, replaceSuspenseComponentStackWithSuspenseFallbackStack$2(task.componentStack), emptyContextObject$2, task.debugTask);
								pushComponentStack$2(suspendedFallbackTask);
								request.pingedTasks.push(suspendedFallbackTask);
							}
						}
						return;
				}
				if ("object" === typeof type && null !== type) switch (type.$$typeof) {
					case REACT_FORWARD_REF_TYPE$2:
						if ("ref" in props) {
							var propsWithoutRef = {};
							for (var key in props) "ref" !== key && (propsWithoutRef[key] = props[key]);
						} else propsWithoutRef = props;
						finishFunctionComponent$2(request, task, keyPath, renderWithHooks$2(request, task, keyPath, type.render, propsWithoutRef, ref), 0 !== localIdCounter$2, actionStateCounter$2, actionStateMatchingIndex$2);
						return;
					case REACT_MEMO_TYPE$2:
						renderElement$2(request, task, keyPath, type.type, props, ref);
						return;
					case REACT_CONTEXT_TYPE$2:
						var value$jscomp$0 = props.value, children$jscomp$2 = props.children;
						var prevSnapshot = task.context;
						var prevKeyPath$jscomp$5 = task.keyPath;
						var prevValue = type._currentValue;
						type._currentValue = value$jscomp$0;
						void 0 !== type._currentRenderer && null !== type._currentRenderer && type._currentRenderer !== rendererSigil && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
						type._currentRenderer = rendererSigil;
						var prevNode = currentActiveSnapshot$2, newNode = {
							parent: prevNode,
							depth: null === prevNode ? 0 : prevNode.depth + 1,
							context: type,
							parentValue: prevValue,
							value: value$jscomp$0
						};
						currentActiveSnapshot$2 = newNode;
						task.context = newNode;
						task.keyPath = keyPath;
						renderNodeDestructive$2(request, task, children$jscomp$2, -1);
						var prevSnapshot$jscomp$0 = currentActiveSnapshot$2;
						if (null === prevSnapshot$jscomp$0) throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
						prevSnapshot$jscomp$0.context !== type && console.error("The parent context is not the expected context. This is probably a bug in React.");
						prevSnapshot$jscomp$0.context._currentValue = prevSnapshot$jscomp$0.parentValue;
						void 0 !== type._currentRenderer && null !== type._currentRenderer && type._currentRenderer !== rendererSigil && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
						type._currentRenderer = rendererSigil;
						task.context = currentActiveSnapshot$2 = prevSnapshot$jscomp$0.parent;
						task.keyPath = prevKeyPath$jscomp$5;
						prevSnapshot !== task.context && console.error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
						return;
					case REACT_CONSUMER_TYPE$2:
						var context$jscomp$0 = type._context, render$1 = props.children;
						"function" !== typeof render$1 && console.error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
						var newChildren = render$1(context$jscomp$0._currentValue), prevKeyPath$jscomp$6 = task.keyPath;
						task.keyPath = keyPath;
						renderNodeDestructive$2(request, task, newChildren, -1);
						task.keyPath = prevKeyPath$jscomp$6;
						return;
					case REACT_LAZY_TYPE$2:
						var Component = callLazyInitInDEV(type);
						if (12 === request.status) throw null;
						renderElement$2(request, task, keyPath, Component, props, ref);
						return;
				}
				var info = "";
				if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length) info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
				throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((null == type ? type : typeof type) + "." + info));
			}
		}
		function resumeNode$2(request, task, segmentId, node, childIndex) {
			var prevReplay = task.replay, blockedBoundary = task.blockedBoundary, resumedSegment = createPendingSegment$2(request, 0, null, task.formatContext, !1, !1);
			resumedSegment.id = segmentId;
			resumedSegment.parentFlushed = !0;
			try {
				task.replay = null, task.blockedSegment = resumedSegment, renderNode$2(request, task, node, childIndex), resumedSegment.status = COMPLETED, finishedSegment$1(request, blockedBoundary, resumedSegment), null === blockedBoundary ? request.completedRootSegment = resumedSegment : (queueCompletedSegment$2(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));
			} finally {
				task.replay = prevReplay, task.blockedSegment = null;
			}
		}
		function replayElement(request, task, keyPath, name, keyOrIndex, childIndex, type, props, ref, replay) {
			childIndex = replay.nodes;
			for (var i = 0; i < childIndex.length; i++) {
				var node = childIndex[i];
				if (keyOrIndex === node[1]) {
					if (4 === node.length) {
						if (null !== name && name !== node[0]) throw Error("Expected the resume to render <" + node[0] + "> in this slot but instead it rendered <" + name + ">. The tree doesn't match so React will fallback to client rendering.");
						var childNodes = node[2];
						name = node[3];
						keyOrIndex = task.node;
						task.replay = {
							nodes: childNodes,
							slots: name,
							pendingTasks: 1
						};
						try {
							renderElement$2(request, task, keyPath, type, props, ref);
							if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length) throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
							task.replay.pendingTasks--;
						} catch (x) {
							if ("object" === typeof x && null !== x && (x === SuspenseException$2 || "function" === typeof x.then)) throw task.node === keyOrIndex ? task.replay = replay : childIndex.splice(i, 1), x;
							task.replay.pendingTasks--;
							type = getThrownInfo$2(task.componentStack);
							props = request;
							request = task.blockedBoundary;
							keyPath = x;
							ref = name;
							name = logRecoverableError$2(props, keyPath, type, task.debugTask);
							abortRemainingReplayNodes$2(props, request, childNodes, ref, keyPath, name, type, !1);
						}
						task.replay = replay;
					} else {
						if (type !== REACT_SUSPENSE_TYPE$2) throw Error("Expected the resume to render <Suspense> in this slot but instead it rendered <" + (getComponentNameFromType$2(type) || "Unknown") + ">. The tree doesn't match so React will fallback to client rendering.");
						a: {
							replay = void 0;
							name = node[5];
							type = node[2];
							ref = node[3];
							keyOrIndex = null === node[4] ? [] : node[4][2];
							node = null === node[4] ? null : node[4][3];
							var prevKeyPath = task.keyPath, prevContext = task.formatContext, prevRow = task.row, previousReplaySet = task.replay, parentBoundary = task.blockedBoundary, parentHoistableState = task.hoistableState, content = props.children, fallback = props.fallback, fallbackAbortSet = /* @__PURE__ */ new Set();
							props = task.formatContext.insertionMode < HTML_MODE ? createSuspenseBoundary$2(request, task.row, fallbackAbortSet, createPreambleState$1(), createPreambleState$1()) : createSuspenseBoundary$2(request, task.row, fallbackAbortSet, null, null);
							props.parentFlushed = !0;
							props.rootSegmentID = name;
							task.blockedBoundary = props;
							task.hoistableState = props.contentState;
							task.keyPath = keyPath;
							task.formatContext = getSuspenseContentFormatContext$2(request.resumableState, prevContext);
							task.row = null;
							task.replay = {
								nodes: type,
								slots: ref,
								pendingTasks: 1
							};
							try {
								renderNode$2(request, task, content, -1);
								if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length) throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
								task.replay.pendingTasks--;
								if (0 === props.pendingTasks && props.status === PENDING) {
									props.status = COMPLETED;
									request.completedBoundaries.push(props);
									break a;
								}
							} catch (error) {
								props.status = CLIENT_RENDERED, childNodes = getThrownInfo$2(task.componentStack), replay = logRecoverableError$2(request, error, childNodes, task.debugTask), encodeErrorForBoundary(props, replay, error, childNodes, !1), task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);
							} finally {
								task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath, task.formatContext = prevContext, task.row = prevRow;
							}
							props = createReplayTask$2(request, null, {
								nodes: keyOrIndex,
								slots: node,
								pendingTasks: 0
							}, fallback, -1, parentBoundary, props.fallbackState, fallbackAbortSet, [
								keyPath[0],
								"Suspense Fallback",
								keyPath[2]
							], getSuspenseFallbackFormatContext$2(request.resumableState, task.formatContext), task.context, task.treeContext, task.row, replaceSuspenseComponentStackWithSuspenseFallbackStack$2(task.componentStack), emptyContextObject$2, task.debugTask);
							pushComponentStack$2(props);
							request.pingedTasks.push(props);
						}
					}
					childIndex.splice(i, 1);
					break;
				}
			}
		}
		function validateIterable(task, iterable, childIndex, iterator, iteratorFn) {
			if (iterator === iterable) {
				if (-1 !== childIndex || null === task.componentStack || "function" !== typeof task.componentStack.type || "[object GeneratorFunction]" !== Object.prototype.toString.call(task.componentStack.type) || "[object Generator]" !== Object.prototype.toString.call(iterator)) didWarnAboutGenerators || console.error("Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."), didWarnAboutGenerators = !0;
			} else iterable.entries !== iteratorFn || didWarnAboutMaps || (console.error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0);
		}
		function renderNodeDestructive$2(request, task, node, childIndex) {
			null !== task.replay && "number" === typeof task.replay.slots ? resumeNode$2(request, task, task.replay.slots, node, childIndex) : (task.node = node, task.childIndex = childIndex, node = task.componentStack, childIndex = task.debugTask, pushComponentStack$2(task), retryNode$2(request, task), task.componentStack = node, task.debugTask = childIndex);
		}
		function retryNode$2(request, task) {
			var node = task.node, childIndex = task.childIndex;
			if (null !== node) {
				if ("object" === typeof node) {
					switch (node.$$typeof) {
						case REACT_ELEMENT_TYPE$2:
							var type = node.type, key = node.key;
							node = node.props;
							var refProp = node.ref;
							refProp = void 0 !== refProp ? refProp : null;
							var debugTask = task.debugTask, name = getComponentNameFromType$2(type);
							key = null == key ? -1 === childIndex ? 0 : childIndex : key;
							var keyPath = [
								task.keyPath,
								name,
								key
							];
							null !== task.replay ? debugTask ? debugTask.run(replayElement.bind(null, request, task, keyPath, name, key, childIndex, type, node, refProp, task.replay)) : replayElement(request, task, keyPath, name, key, childIndex, type, node, refProp, task.replay) : debugTask ? debugTask.run(renderElement$2.bind(null, request, task, keyPath, type, node, refProp)) : renderElement$2(request, task, keyPath, type, node, refProp);
							return;
						case REACT_PORTAL_TYPE$2: throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
						case REACT_LAZY_TYPE$2:
							type = callLazyInitInDEV(node);
							if (12 === request.status) throw null;
							renderNodeDestructive$2(request, task, type, childIndex);
							return;
					}
					if (isArrayImpl$2(node)) {
						renderChildrenArray$2(request, task, node, childIndex);
						return;
					}
					if (key = getIteratorFn$2(node)) {
						if (type = key.call(node)) {
							validateIterable(task, node, childIndex, type, key);
							node = type.next();
							if (!node.done) {
								key = [];
								do
									key.push(node.value), node = type.next();
								while (!node.done);
								renderChildrenArray$2(request, task, key, childIndex);
							}
							return;
						}
					}
					if ("function" === typeof node.then) return task.thenableState = null, renderNodeDestructive$2(request, task, unwrapThenable$2(node), childIndex);
					if (node.$$typeof === REACT_CONTEXT_TYPE$2) return renderNodeDestructive$2(request, task, node._currentValue, childIndex);
					request = Object.prototype.toString.call(node);
					throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === request ? "object with keys {" + Object.keys(node).join(", ") + "}" : request) + "). If you meant to render a collection of children, use an array instead.");
				}
				"string" === typeof node ? (task = task.blockedSegment, null !== task && (task.lastPushedText = pushTextInstance$2(task.chunks, node, request.renderState, task.lastPushedText))) : "number" === typeof node || "bigint" === typeof node ? (task = task.blockedSegment, null !== task && (task.lastPushedText = pushTextInstance$2(task.chunks, "" + node, request.renderState, task.lastPushedText))) : ("function" === typeof node && (request = node.displayName || node.name || "Component", console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.", request, request)), "symbol" === typeof node && console.error("Symbols are not valid as a React child.\n  %s", String(node)));
			}
		}
		function warnForMissingKey(request, task, child) {
			if (null !== child && "object" === typeof child && (child.$$typeof === REACT_ELEMENT_TYPE$2 || child.$$typeof === REACT_PORTAL_TYPE$2) && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {
				if ("object" !== typeof child._store) throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
				child._store.validated = 1;
				var didWarnForKey = request.didWarnForKey;
				didWarnForKey ??= request.didWarnForKey = /* @__PURE__ */ new WeakSet();
				request = task.componentStack;
				if (null !== request && !didWarnForKey.has(request)) {
					didWarnForKey.add(request);
					var componentName = getComponentNameFromType$2(child.type);
					didWarnForKey = child._owner;
					var parentOwner = request.owner;
					request = "";
					if (parentOwner && "undefined" !== typeof parentOwner.type) {
						var name = getComponentNameFromType$2(parentOwner.type);
						name && (request = "\n\nCheck the render method of `" + name + "`.");
					}
					request || componentName && (request = "\n\nCheck the top-level render call using <" + componentName + ">.");
					componentName = "";
					null != didWarnForKey && parentOwner !== didWarnForKey && (parentOwner = null, "undefined" !== typeof didWarnForKey.type ? parentOwner = getComponentNameFromType$2(didWarnForKey.type) : "string" === typeof didWarnForKey.name && (parentOwner = didWarnForKey.name), parentOwner && (componentName = " It was passed a child from " + parentOwner + "."));
					didWarnForKey = task.componentStack;
					task.componentStack = {
						parent: task.componentStack,
						type: child.type,
						owner: child._owner,
						stack: child._debugStack
					};
					console.error("Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.", request, componentName);
					task.componentStack = didWarnForKey;
				}
			}
		}
		function renderChildrenArray$2(request, task, children, childIndex) {
			var prevKeyPath = task.keyPath, previousComponentStack = task.componentStack;
			var previousDebugTask = task.debugTask;
			pushServerComponentStack(task, task.node._debugInfo);
			if (-1 !== childIndex && (task.keyPath = [
				task.keyPath,
				"Fragment",
				childIndex
			], null !== task.replay)) {
				for (var replay = task.replay, replayNodes = replay.nodes, j = 0; j < replayNodes.length; j++) {
					var node = replayNodes[j];
					if (node[1] === childIndex) {
						childIndex = node[2];
						node = node[3];
						task.replay = {
							nodes: childIndex,
							slots: node,
							pendingTasks: 1
						};
						try {
							renderChildrenArray$2(request, task, children, -1);
							if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length) throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
							task.replay.pendingTasks--;
						} catch (x) {
							if ("object" === typeof x && null !== x && (x === SuspenseException$2 || "function" === typeof x.then)) throw x;
							task.replay.pendingTasks--;
							var thrownInfo = getThrownInfo$2(task.componentStack);
							children = task.blockedBoundary;
							var error = x, resumeSlots = node;
							node = logRecoverableError$2(request, error, thrownInfo, task.debugTask);
							abortRemainingReplayNodes$2(request, children, childIndex, resumeSlots, error, node, thrownInfo, !1);
						}
						task.replay = replay;
						replayNodes.splice(j, 1);
						break;
					}
				}
				task.keyPath = prevKeyPath;
				task.componentStack = previousComponentStack;
				task.debugTask = previousDebugTask;
				return;
			}
			replay = task.treeContext;
			replayNodes = children.length;
			if (null !== task.replay && (j = task.replay.slots, null !== j && "object" === typeof j)) {
				for (childIndex = 0; childIndex < replayNodes; childIndex++) node = children[childIndex], task.treeContext = pushTreeContext$2(replay, replayNodes, childIndex), error = j[childIndex], "number" === typeof error ? (resumeNode$2(request, task, error, node, childIndex), delete j[childIndex]) : renderNode$2(request, task, node, childIndex);
				task.treeContext = replay;
				task.keyPath = prevKeyPath;
				task.componentStack = previousComponentStack;
				task.debugTask = previousDebugTask;
				return;
			}
			for (j = 0; j < replayNodes; j++) childIndex = children[j], warnForMissingKey(request, task, childIndex), task.treeContext = pushTreeContext$2(replay, replayNodes, j), renderNode$2(request, task, childIndex, j);
			task.treeContext = replay;
			task.keyPath = prevKeyPath;
			task.componentStack = previousComponentStack;
			task.debugTask = previousDebugTask;
		}
		function trackPostponedBoundary$2(request, trackedPostpones, boundary) {
			boundary.status = POSTPONED;
			boundary.rootSegmentID = request.nextSegmentId++;
			request = boundary.trackedContentKeyPath;
			if (null === request) throw Error("It should not be possible to postpone at the root. This is a bug in React.");
			var fallbackReplayNode = boundary.trackedFallbackNode, children = [], boundaryNode = trackedPostpones.workingMap.get(request);
			if (void 0 === boundaryNode) return boundary = [
				request[1],
				request[2],
				children,
				null,
				fallbackReplayNode,
				boundary.rootSegmentID
			], trackedPostpones.workingMap.set(request, boundary), addToReplayParent$2(boundary, request[0], trackedPostpones), boundary;
			boundaryNode[4] = fallbackReplayNode;
			boundaryNode[5] = boundary.rootSegmentID;
			return boundaryNode;
		}
		function trackPostpone$2(request, trackedPostpones, task, segment) {
			segment.status = POSTPONED;
			var keyPath = task.keyPath, boundary = task.blockedBoundary;
			if (null === boundary) segment.id = request.nextSegmentId++, trackedPostpones.rootSlots = segment.id, null !== request.completedRootSegment && (request.completedRootSegment.status = POSTPONED);
			else {
				if (null !== boundary && boundary.status === PENDING) {
					var boundaryNode = trackPostponedBoundary$2(request, trackedPostpones, boundary);
					if (boundary.trackedContentKeyPath === keyPath && -1 === task.childIndex) {
						-1 === segment.id && (segment.id = segment.parentFlushed ? boundary.rootSegmentID : request.nextSegmentId++);
						boundaryNode[3] = segment.id;
						return;
					}
				}
				-1 === segment.id && (segment.id = segment.parentFlushed && null !== boundary ? boundary.rootSegmentID : request.nextSegmentId++);
				if (-1 === task.childIndex) null === keyPath ? trackedPostpones.rootSlots = segment.id : (task = trackedPostpones.workingMap.get(keyPath), void 0 === task ? (task = [
					keyPath[1],
					keyPath[2],
					[],
					segment.id
				], addToReplayParent$2(task, keyPath[0], trackedPostpones)) : task[3] = segment.id);
				else {
					if (null === keyPath) {
						if (request = trackedPostpones.rootSlots, null === request) request = trackedPostpones.rootSlots = {};
						else if ("number" === typeof request) throw Error("It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.");
					} else if (boundary = trackedPostpones.workingMap, boundaryNode = boundary.get(keyPath), void 0 === boundaryNode) request = {}, boundaryNode = [
						keyPath[1],
						keyPath[2],
						[],
						request
					], boundary.set(keyPath, boundaryNode), addToReplayParent$2(boundaryNode, keyPath[0], trackedPostpones);
					else if (request = boundaryNode[3], null === request) request = boundaryNode[3] = {};
					else if ("number" === typeof request) throw Error("It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.");
					request[task.childIndex] = segment.id;
				}
			}
		}
		function untrackBoundary$2(request, boundary) {
			request = request.trackedPostpones;
			null !== request && (boundary = boundary.trackedContentKeyPath, null !== boundary && (boundary = request.workingMap.get(boundary), void 0 !== boundary && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));
		}
		function spawnNewSuspendedReplayTask$2(request, task, thenableState$3) {
			return createReplayTask$2(request, thenableState$3, task.replay, task.node, task.childIndex, task.blockedBoundary, task.hoistableState, task.abortSet, task.keyPath, task.formatContext, task.context, task.treeContext, task.row, task.componentStack, emptyContextObject$2, task.debugTask);
		}
		function spawnNewSuspendedRenderTask$2(request, task, thenableState$3) {
			var segment = task.blockedSegment, newSegment = createPendingSegment$2(request, segment.chunks.length, null, task.formatContext, segment.lastPushedText, !0);
			segment.children.push(newSegment);
			segment.lastPushedText = !1;
			return createRenderTask$2(request, thenableState$3, task.node, task.childIndex, task.blockedBoundary, newSegment, task.blockedPreamble, task.hoistableState, task.abortSet, task.keyPath, task.formatContext, task.context, task.treeContext, task.row, task.componentStack, emptyContextObject$2, task.debugTask);
		}
		function renderNode$2(request, task, node, childIndex) {
			var previousFormatContext = task.formatContext, previousContext = task.context, previousKeyPath = task.keyPath, previousTreeContext = task.treeContext, previousComponentStack = task.componentStack, previousDebugTask = task.debugTask, segment = task.blockedSegment;
			if (null === segment) {
				segment = task.replay;
				try {
					return renderNodeDestructive$2(request, task, node, childIndex);
				} catch (thrownValue) {
					if (resetHooksState$2(), node = thrownValue === SuspenseException$2 ? getSuspendedThenable$2() : thrownValue, 12 !== request.status && "object" === typeof node && null !== node) {
						if ("function" === typeof node.then) {
							childIndex = thrownValue === SuspenseException$2 ? getThenableStateAfterSuspending$2() : null;
							request = spawnNewSuspendedReplayTask$2(request, task, childIndex).ping;
							node.then(request, request);
							task.formatContext = previousFormatContext;
							task.context = previousContext;
							task.keyPath = previousKeyPath;
							task.treeContext = previousTreeContext;
							task.componentStack = previousComponentStack;
							task.replay = segment;
							task.debugTask = previousDebugTask;
							switchContext$2(previousContext);
							return;
						}
						if ("Maximum call stack size exceeded" === node.message) {
							node = thrownValue === SuspenseException$2 ? getThenableStateAfterSuspending$2() : null;
							node = spawnNewSuspendedReplayTask$2(request, task, node);
							request.pingedTasks.push(node);
							task.formatContext = previousFormatContext;
							task.context = previousContext;
							task.keyPath = previousKeyPath;
							task.treeContext = previousTreeContext;
							task.componentStack = previousComponentStack;
							task.replay = segment;
							task.debugTask = previousDebugTask;
							switchContext$2(previousContext);
							return;
						}
					}
				}
			} else {
				var childrenLength = segment.children.length, chunkLength = segment.chunks.length;
				try {
					return renderNodeDestructive$2(request, task, node, childIndex);
				} catch (thrownValue$3) {
					if (resetHooksState$2(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node = thrownValue$3 === SuspenseException$2 ? getSuspendedThenable$2() : thrownValue$3, 12 !== request.status && "object" === typeof node && null !== node) {
						if ("function" === typeof node.then) {
							segment = node;
							node = thrownValue$3 === SuspenseException$2 ? getThenableStateAfterSuspending$2() : null;
							request = spawnNewSuspendedRenderTask$2(request, task, node).ping;
							segment.then(request, request);
							task.formatContext = previousFormatContext;
							task.context = previousContext;
							task.keyPath = previousKeyPath;
							task.treeContext = previousTreeContext;
							task.componentStack = previousComponentStack;
							task.debugTask = previousDebugTask;
							switchContext$2(previousContext);
							return;
						}
						if ("Maximum call stack size exceeded" === node.message) {
							segment = thrownValue$3 === SuspenseException$2 ? getThenableStateAfterSuspending$2() : null;
							segment = spawnNewSuspendedRenderTask$2(request, task, segment);
							request.pingedTasks.push(segment);
							task.formatContext = previousFormatContext;
							task.context = previousContext;
							task.keyPath = previousKeyPath;
							task.treeContext = previousTreeContext;
							task.componentStack = previousComponentStack;
							task.debugTask = previousDebugTask;
							switchContext$2(previousContext);
							return;
						}
					}
				}
			}
			task.formatContext = previousFormatContext;
			task.context = previousContext;
			task.keyPath = previousKeyPath;
			task.treeContext = previousTreeContext;
			switchContext$2(previousContext);
			throw node;
		}
		function abortTaskSoft$2(task) {
			var boundary = task.blockedBoundary, segment = task.blockedSegment;
			null !== segment && (segment.status = ABORTED, finishedTask$2(this, boundary, task.row, segment));
		}
		function abortRemainingReplayNodes$2(request$jscomp$0, boundary, nodes, slots, error$jscomp$0, errorDigest$jscomp$0, errorInfo$jscomp$0, aborted) {
			for (var i = 0; i < nodes.length; i++) {
				var node = nodes[i];
				if (4 === node.length) abortRemainingReplayNodes$2(request$jscomp$0, boundary, node[2], node[3], error$jscomp$0, errorDigest$jscomp$0, errorInfo$jscomp$0, aborted);
				else {
					var request = request$jscomp$0;
					node = node[5];
					var error = error$jscomp$0, errorDigest = errorDigest$jscomp$0, errorInfo = errorInfo$jscomp$0, wasAborted = aborted, resumedBoundary = createSuspenseBoundary$2(request, null, /* @__PURE__ */ new Set(), null, null);
					resumedBoundary.parentFlushed = !0;
					resumedBoundary.rootSegmentID = node;
					resumedBoundary.status = CLIENT_RENDERED;
					encodeErrorForBoundary(resumedBoundary, errorDigest, error, errorInfo, wasAborted);
					resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);
				}
			}
			nodes.length = 0;
			if (null !== slots) {
				if (null === boundary) throw Error("We should not have any resumable nodes in the shell. This is a bug in React.");
				boundary.status !== CLIENT_RENDERED && (boundary.status = CLIENT_RENDERED, encodeErrorForBoundary(boundary, errorDigest$jscomp$0, error$jscomp$0, errorInfo$jscomp$0, aborted), boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));
				if ("object" === typeof slots) for (var index in slots) delete slots[index];
			}
		}
		function abortTask$2(task, request, error) {
			var boundary = task.blockedBoundary, segment = task.blockedSegment;
			if (null !== segment) {
				if (6 === segment.status) return;
				segment.status = ABORTED;
			}
			var errorInfo = getThrownInfo$2(task.componentStack), node = task.node;
			null !== node && "object" === typeof node && pushHaltedAwaitOnComponentStack(task, node._debugInfo);
			if (null === boundary) {
				if (13 !== request.status && request.status !== CLOSED) {
					boundary = task.replay;
					if (null === boundary) {
						null !== request.trackedPostpones && null !== segment ? (boundary = request.trackedPostpones, logRecoverableError$2(request, error, errorInfo, task.debugTask), trackPostpone$2(request, boundary, task, segment), finishedTask$2(request, null, task.row, segment)) : (logRecoverableError$2(request, error, errorInfo, task.debugTask), fatalError$2(request, error, errorInfo, task.debugTask));
						return;
					}
					boundary.pendingTasks--;
					0 === boundary.pendingTasks && 0 < boundary.nodes.length && (segment = logRecoverableError$2(request, error, errorInfo, null), abortRemainingReplayNodes$2(request, null, boundary.nodes, boundary.slots, error, segment, errorInfo, !0));
					request.pendingRootTasks--;
					0 === request.pendingRootTasks && completeShell$2(request);
				}
			} else {
				node = request.trackedPostpones;
				if (boundary.status !== CLIENT_RENDERED) {
					if (null !== node && null !== segment) return logRecoverableError$2(request, error, errorInfo, task.debugTask), trackPostpone$2(request, node, task, segment), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
						return abortTask$2(fallbackTask, request, error);
					}), boundary.fallbackAbortableTasks.clear(), finishedTask$2(request, boundary, task.row, segment);
					boundary.status = CLIENT_RENDERED;
					segment = logRecoverableError$2(request, error, errorInfo, task.debugTask);
					boundary.status = CLIENT_RENDERED;
					encodeErrorForBoundary(boundary, segment, error, errorInfo, !0);
					untrackBoundary$2(request, boundary);
					boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);
				}
				boundary.pendingTasks--;
				errorInfo = boundary.row;
				null !== errorInfo && 0 === --errorInfo.pendingTasks && finishSuspenseListRow$2(request, errorInfo);
				boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
					return abortTask$2(fallbackTask, request, error);
				});
				boundary.fallbackAbortableTasks.clear();
			}
			task = task.row;
			null !== task && 0 === --task.pendingTasks && finishSuspenseListRow$2(request, task);
			request.allPendingTasks--;
			0 === request.allPendingTasks && completeAll$2(request);
		}
		function safelyEmitEarlyPreloads$2(request, shellComplete) {
			try {
				var renderState = request.renderState, onHeaders = renderState.onHeaders;
				if (onHeaders) {
					var headers = renderState.headers;
					if (headers) {
						renderState.headers = null;
						var linkHeader = headers.preconnects;
						headers.fontPreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.fontPreloads);
						headers.highImagePreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.highImagePreloads);
						if (!shellComplete) {
							var queueIter = renderState.styles.values(), queueStep = queueIter.next();
							b: for (; 0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next()) for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next(); 0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {
								var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props;
								var header = getPreloadAsHeader$2(props$jscomp$0.href, "style", {
									crossOrigin: props$jscomp$0.crossOrigin,
									integrity: props$jscomp$0.integrity,
									nonce: props$jscomp$0.nonce,
									type: props$jscomp$0.type,
									fetchPriority: props$jscomp$0.fetchPriority,
									referrerPolicy: props$jscomp$0.referrerPolicy,
									media: props$jscomp$0.media
								});
								if (0 <= (headers.remainingCapacity -= header.length + 2)) renderState.resets.style[key] = PRELOAD_NO_CREDS$2, linkHeader && (linkHeader += ", "), linkHeader += header, renderState.resets.style[key] = "string" === typeof props.crossOrigin || "string" === typeof props.integrity ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS$2;
								else break b;
							}
						}
						linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});
					}
				}
			} catch (error) {
				logRecoverableError$2(request, error, {}, null);
			}
		}
		function completeShell$2(request) {
			null === request.trackedPostpones && safelyEmitEarlyPreloads$2(request, !0);
			null === request.trackedPostpones && preparePreamble$2(request);
			request.onShellError = noop$2;
			request = request.onShellReady;
			request();
		}
		function completeAll$2(request) {
			safelyEmitEarlyPreloads$2(request, null === request.trackedPostpones ? !0 : null === request.completedRootSegment || request.completedRootSegment.status !== POSTPONED);
			preparePreamble$2(request);
			request = request.onAllReady;
			request();
		}
		function queueCompletedSegment$2(boundary, segment) {
			if (0 === segment.chunks.length && 1 === segment.children.length && null === segment.children[0].boundary && -1 === segment.children[0].id) {
				var childSegment = segment.children[0];
				childSegment.id = segment.id;
				childSegment.parentFlushed = !0;
				childSegment.status !== COMPLETED && childSegment.status !== ABORTED && childSegment.status !== ERRORED || queueCompletedSegment$2(boundary, childSegment);
			} else boundary.completedSegments.push(segment);
		}
		function finishedSegment$1(request, boundary, segment) {
			if (null !== byteLengthOfChunk$1) {
				segment = segment.chunks;
				for (var segmentByteSize = 0, i = 0; i < segment.length; i++) segmentByteSize += byteLengthOfChunk$1(segment[i]);
				null === boundary ? request.byteSize += segmentByteSize : boundary.byteSize += segmentByteSize;
			}
		}
		function finishedTask$2(request, boundary, row, segment) {
			null !== row && (0 === --row.pendingTasks ? finishSuspenseListRow$2(request, row) : row.together && tryToResolveTogetherRow$2(request, row));
			request.allPendingTasks--;
			if (null === boundary) {
				if (null !== segment && segment.parentFlushed) {
					if (null !== request.completedRootSegment) throw Error("There can only be one root segment. This is a bug in React.");
					request.completedRootSegment = segment;
				}
				request.pendingRootTasks--;
				0 === request.pendingRootTasks && completeShell$2(request);
			} else if (boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED) if (0 === boundary.pendingTasks) {
				if (boundary.status === PENDING && (boundary.status = COMPLETED), null !== segment && segment.parentFlushed && (segment.status === COMPLETED || segment.status === ABORTED) && queueCompletedSegment$2(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), boundary.status === COMPLETED) row = boundary.row, null !== row && hoistHoistables$2(row.hoistables, boundary.contentState), isEligibleForOutlining$2(request, boundary) || (boundary.fallbackAbortableTasks.forEach(abortTaskSoft$2, request), boundary.fallbackAbortableTasks.clear(), null !== row && 0 === --row.pendingTasks && finishSuspenseListRow$2(request, row)), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary.contentPreamble && preparePreamble$2(request);
				else if (boundary.status === POSTPONED && (boundary = boundary.row, null !== boundary)) {
					if (null !== request.trackedPostpones) {
						row = request.trackedPostpones;
						var postponedRow = boundary.next;
						if (null !== postponedRow && (segment = postponedRow.boundaries, null !== segment)) for (postponedRow.boundaries = null, postponedRow = 0; postponedRow < segment.length; postponedRow++) {
							var postponedBoundary = segment[postponedRow];
							trackPostponedBoundary$2(request, row, postponedBoundary);
							finishedTask$2(request, postponedBoundary, null, null);
						}
					}
					0 === --boundary.pendingTasks && finishSuspenseListRow$2(request, boundary);
				}
			} else null === segment || !segment.parentFlushed || segment.status !== COMPLETED && segment.status !== ABORTED || (queueCompletedSegment$2(boundary, segment), 1 === boundary.completedSegments.length && boundary.parentFlushed && request.partialBoundaries.push(boundary)), boundary = boundary.row, null !== boundary && boundary.together && tryToResolveTogetherRow$2(request, boundary);
			0 === request.allPendingTasks && completeAll$2(request);
		}
		function performWork$2(request$jscomp$2) {
			if (request$jscomp$2.status !== CLOSED && 13 !== request$jscomp$2.status) {
				var prevContext = currentActiveSnapshot$2, prevDispatcher = ReactSharedInternals$2.H;
				ReactSharedInternals$2.H = HooksDispatcher$2;
				var prevAsyncDispatcher = ReactSharedInternals$2.A;
				ReactSharedInternals$2.A = DefaultAsyncDispatcher$2;
				var prevRequest = currentRequest$2;
				currentRequest$2 = request$jscomp$2;
				var prevGetCurrentStackImpl = ReactSharedInternals$2.getCurrentStack;
				ReactSharedInternals$2.getCurrentStack = getCurrentStackInDEV;
				var prevResumableState = currentResumableState$2;
				currentResumableState$2 = request$jscomp$2.resumableState;
				try {
					var pingedTasks = request$jscomp$2.pingedTasks, i;
					for (i = 0; i < pingedTasks.length; i++) {
						var request = request$jscomp$2, task = pingedTasks[i], segment = task.blockedSegment;
						if (null === segment) {
							var prevTaskInDEV = void 0, request$jscomp$0 = request;
							request = task;
							if (0 !== request.replay.pendingTasks) {
								switchContext$2(request.context);
								prevTaskInDEV = currentTaskInDEV;
								currentTaskInDEV = request;
								try {
									"number" === typeof request.replay.slots ? resumeNode$2(request$jscomp$0, request, request.replay.slots, request.node, request.childIndex) : retryNode$2(request$jscomp$0, request);
									if (1 === request.replay.pendingTasks && 0 < request.replay.nodes.length) throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
									request.replay.pendingTasks--;
									request.abortSet.delete(request);
									finishedTask$2(request$jscomp$0, request.blockedBoundary, request.row, null);
								} catch (thrownValue) {
									resetHooksState$2();
									var x = thrownValue === SuspenseException$2 ? getSuspendedThenable$2() : thrownValue;
									if ("object" === typeof x && null !== x && "function" === typeof x.then) {
										var ping = request.ping;
										x.then(ping, ping);
										request.thenableState = thrownValue === SuspenseException$2 ? getThenableStateAfterSuspending$2() : null;
									} else {
										request.replay.pendingTasks--;
										request.abortSet.delete(request);
										var errorInfo = getThrownInfo$2(request.componentStack), errorDigest = void 0, request$jscomp$1 = request$jscomp$0, boundary = request.blockedBoundary, error$jscomp$0 = 12 === request$jscomp$0.status ? request$jscomp$0.fatalError : x, errorInfo$jscomp$0 = errorInfo, replayNodes = request.replay.nodes, resumeSlots = request.replay.slots;
										errorDigest = logRecoverableError$2(request$jscomp$1, error$jscomp$0, errorInfo$jscomp$0, request.debugTask);
										abortRemainingReplayNodes$2(request$jscomp$1, boundary, replayNodes, resumeSlots, error$jscomp$0, errorDigest, errorInfo$jscomp$0, !1);
										request$jscomp$0.pendingRootTasks--;
										0 === request$jscomp$0.pendingRootTasks && completeShell$2(request$jscomp$0);
										request$jscomp$0.allPendingTasks--;
										0 === request$jscomp$0.allPendingTasks && completeAll$2(request$jscomp$0);
									}
								} finally {
									currentTaskInDEV = prevTaskInDEV;
								}
							}
						} else if (request$jscomp$0 = prevTaskInDEV = void 0, errorDigest = task, request$jscomp$1 = segment, request$jscomp$1.status === PENDING) {
							request$jscomp$1.status = 6;
							switchContext$2(errorDigest.context);
							request$jscomp$0 = currentTaskInDEV;
							currentTaskInDEV = errorDigest;
							var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;
							try {
								retryNode$2(request, errorDigest), request$jscomp$1.lastPushedText && request$jscomp$1.textEmbedded && request$jscomp$1.chunks.push(textSeparator$1), errorDigest.abortSet.delete(errorDigest), request$jscomp$1.status = COMPLETED, finishedSegment$1(request, errorDigest.blockedBoundary, request$jscomp$1), finishedTask$2(request, errorDigest.blockedBoundary, errorDigest.row, request$jscomp$1);
							} catch (thrownValue) {
								resetHooksState$2();
								request$jscomp$1.children.length = childrenLength;
								request$jscomp$1.chunks.length = chunkLength;
								var x$jscomp$0 = thrownValue === SuspenseException$2 ? getSuspendedThenable$2() : 12 === request.status ? request.fatalError : thrownValue;
								if (12 === request.status && null !== request.trackedPostpones) {
									var trackedPostpones = request.trackedPostpones, thrownInfo = getThrownInfo$2(errorDigest.componentStack);
									errorDigest.abortSet.delete(errorDigest);
									logRecoverableError$2(request, x$jscomp$0, thrownInfo, errorDigest.debugTask);
									trackPostpone$2(request, trackedPostpones, errorDigest, request$jscomp$1);
									finishedTask$2(request, errorDigest.blockedBoundary, errorDigest.row, request$jscomp$1);
								} else if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0 && "function" === typeof x$jscomp$0.then) {
									request$jscomp$1.status = PENDING;
									errorDigest.thenableState = thrownValue === SuspenseException$2 ? getThenableStateAfterSuspending$2() : null;
									var ping$jscomp$0 = errorDigest.ping;
									x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
								} else {
									var errorInfo$jscomp$1 = getThrownInfo$2(errorDigest.componentStack);
									errorDigest.abortSet.delete(errorDigest);
									request$jscomp$1.status = ERRORED;
									var boundary$jscomp$0 = errorDigest.blockedBoundary, row = errorDigest.row, debugTask = errorDigest.debugTask;
									null !== row && 0 === --row.pendingTasks && finishSuspenseListRow$2(request, row);
									request.allPendingTasks--;
									prevTaskInDEV = logRecoverableError$2(request, x$jscomp$0, errorInfo$jscomp$1, debugTask);
									if (null === boundary$jscomp$0) fatalError$2(request, x$jscomp$0, errorInfo$jscomp$1, debugTask);
									else if (boundary$jscomp$0.pendingTasks--, boundary$jscomp$0.status !== CLIENT_RENDERED) {
										boundary$jscomp$0.status = CLIENT_RENDERED;
										encodeErrorForBoundary(boundary$jscomp$0, prevTaskInDEV, x$jscomp$0, errorInfo$jscomp$1, !1);
										untrackBoundary$2(request, boundary$jscomp$0);
										var boundaryRow = boundary$jscomp$0.row;
										null !== boundaryRow && 0 === --boundaryRow.pendingTasks && finishSuspenseListRow$2(request, boundaryRow);
										boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(boundary$jscomp$0);
										0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary$jscomp$0.contentPreamble && preparePreamble$2(request);
									}
									0 === request.allPendingTasks && completeAll$2(request);
								}
							} finally {
								currentTaskInDEV = request$jscomp$0;
							}
						}
					}
					pingedTasks.splice(0, i);
					null !== request$jscomp$2.destination && flushCompletedQueues$2(request$jscomp$2, request$jscomp$2.destination);
				} catch (error) {
					pingedTasks = {}, logRecoverableError$2(request$jscomp$2, error, pingedTasks, null), fatalError$2(request$jscomp$2, error, pingedTasks, null);
				} finally {
					currentResumableState$2 = prevResumableState, ReactSharedInternals$2.H = prevDispatcher, ReactSharedInternals$2.A = prevAsyncDispatcher, ReactSharedInternals$2.getCurrentStack = prevGetCurrentStackImpl, prevDispatcher === HooksDispatcher$2 && switchContext$2(prevContext), currentRequest$2 = prevRequest;
				}
			}
		}
		function preparePreambleFromSubtree$2(request, segment, collectedPreambleSegments) {
			segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);
			for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++) pendingPreambles = preparePreambleFromSegment$2(request, segment.children[i], collectedPreambleSegments) || pendingPreambles;
			return pendingPreambles;
		}
		function preparePreambleFromSegment$2(request, segment, collectedPreambleSegments) {
			var boundary = segment.boundary;
			if (null === boundary) return preparePreambleFromSubtree$2(request, segment, collectedPreambleSegments);
			var preamble = boundary.contentPreamble, fallbackPreamble = boundary.fallbackPreamble;
			if (null === preamble || null === fallbackPreamble) return !1;
			switch (boundary.status) {
				case COMPLETED:
					hoistPreambleState$2(request.renderState, preamble);
					request.byteSize += boundary.byteSize;
					segment = boundary.completedSegments[0];
					if (!segment) throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
					return preparePreambleFromSubtree$2(request, segment, collectedPreambleSegments);
				case POSTPONED: if (null !== request.trackedPostpones) return !0;
				case CLIENT_RENDERED: if (segment.status === COMPLETED) return hoistPreambleState$2(request.renderState, fallbackPreamble), preparePreambleFromSubtree$2(request, segment, collectedPreambleSegments);
				default: return !0;
			}
		}
		function preparePreamble$2(request) {
			if (request.completedRootSegment && null === request.completedPreambleSegments) {
				var collectedPreambleSegments = [], originalRequestByteSize = request.byteSize, hasPendingPreambles = preparePreambleFromSegment$2(request, request.completedRootSegment, collectedPreambleSegments), preamble = request.renderState.preamble;
				!1 === hasPendingPreambles || preamble.headChunks && preamble.bodyChunks ? request.completedPreambleSegments = collectedPreambleSegments : request.byteSize = originalRequestByteSize;
			}
		}
		function flushSubtree$2(request, destination, segment, hoistableState) {
			segment.parentFlushed = !0;
			switch (segment.status) {
				case PENDING: segment.id = request.nextSegmentId++;
				case POSTPONED: return hoistableState = segment.id, segment.lastPushedText = !1, segment.textEmbedded = !1, request = request.renderState, writeChunk$1(destination, placeholder1$1), writeChunk$1(destination, request.placeholderPrefix), request = hoistableState.toString(16), writeChunk$1(destination, request), writeChunkAndReturn$1(destination, placeholder2$1);
				case COMPLETED:
					segment.status = FLUSHED;
					var r = !0, chunks = segment.chunks, chunkIdx = 0;
					segment = segment.children;
					for (var childIdx = 0; childIdx < segment.length; childIdx++) {
						for (r = segment[childIdx]; chunkIdx < r.index; chunkIdx++) writeChunk$1(destination, chunks[chunkIdx]);
						r = flushSegment$2(request, destination, r, hoistableState);
					}
					for (; chunkIdx < chunks.length - 1; chunkIdx++) writeChunk$1(destination, chunks[chunkIdx]);
					chunkIdx < chunks.length && (r = writeChunkAndReturn$1(destination, chunks[chunkIdx]));
					return r;
				case ABORTED: return !0;
				default: throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
			}
		}
		function flushSegment$2(request, destination, segment, hoistableState) {
			var boundary = segment.boundary;
			if (null === boundary) return flushSubtree$2(request, destination, segment, hoistableState);
			boundary.parentFlushed = !0;
			if (boundary.status === CLIENT_RENDERED) {
				var row = boundary.row;
				null !== row && 0 === --row.pendingTasks && finishSuspenseListRow$2(request, row);
				row = boundary.errorDigest;
				var errorMessage = boundary.errorMessage, errorStack = boundary.errorStack;
				boundary = boundary.errorComponentStack;
				writeChunkAndReturn$1(destination, startClientRenderedSuspenseBoundary$1);
				writeChunk$1(destination, clientRenderedSuspenseBoundaryError1$1);
				row && (writeChunk$1(destination, clientRenderedSuspenseBoundaryError1A$1), writeChunk$1(destination, escapeTextForBrowser$2(row)), writeChunk$1(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial$1));
				errorMessage && (writeChunk$1(destination, clientRenderedSuspenseBoundaryError1B), writeChunk$1(destination, escapeTextForBrowser$2(errorMessage)), writeChunk$1(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial$1));
				errorStack && (writeChunk$1(destination, clientRenderedSuspenseBoundaryError1C), writeChunk$1(destination, escapeTextForBrowser$2(errorStack)), writeChunk$1(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial$1));
				boundary && (writeChunk$1(destination, clientRenderedSuspenseBoundaryError1D), writeChunk$1(destination, escapeTextForBrowser$2(boundary)), writeChunk$1(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial$1));
				writeChunkAndReturn$1(destination, clientRenderedSuspenseBoundaryError2$1);
				flushSubtree$2(request, destination, segment, hoistableState);
			} else if (boundary.status !== COMPLETED) boundary.status === PENDING && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary$2(destination, request.renderState, boundary.rootSegmentID), hoistableState && hoistHoistables$2(hoistableState, boundary.fallbackState), flushSubtree$2(request, destination, segment, hoistableState);
			else if (!flushingPartialBoundaries$2 && isEligibleForOutlining$2(request, boundary) && (flushedByteSize$2 + boundary.byteSize > request.progressiveChunkSize || hasSuspenseyContent$1(boundary.contentState))) boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary$2(destination, request.renderState, boundary.rootSegmentID), flushSubtree$2(request, destination, segment, hoistableState);
			else {
				flushedByteSize$2 += boundary.byteSize;
				hoistableState && hoistHoistables$2(hoistableState, boundary.contentState);
				segment = boundary.row;
				null !== segment && isEligibleForOutlining$2(request, boundary) && 0 === --segment.pendingTasks && finishSuspenseListRow$2(request, segment);
				writeChunkAndReturn$1(destination, startCompletedSuspenseBoundary$1);
				segment = boundary.completedSegments;
				if (1 !== segment.length) throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
				flushSegment$2(request, destination, segment[0], hoistableState);
			}
			return writeChunkAndReturn$1(destination, endSuspenseBoundary$1);
		}
		function flushSegmentContainer$2(request, destination, segment, hoistableState) {
			writeStartSegment$2(destination, request.renderState, segment.parentFormatContext, segment.id);
			flushSegment$2(request, destination, segment, hoistableState);
			return writeEndSegment$2(destination, segment.parentFormatContext);
		}
		function flushCompletedBoundary$2(request, destination, boundary) {
			flushedByteSize$2 = boundary.byteSize;
			for (var completedSegments = boundary.completedSegments, i = 0; i < completedSegments.length; i++) flushPartiallyCompletedSegment$2(request, destination, boundary, completedSegments[i]);
			completedSegments.length = 0;
			completedSegments = boundary.row;
			null !== completedSegments && isEligibleForOutlining$2(request, boundary) && 0 === --completedSegments.pendingTasks && finishSuspenseListRow$2(request, completedSegments);
			writeHoistablesForBoundary$2(destination, boundary.contentState, request.renderState);
			completedSegments = request.resumableState;
			request = request.renderState;
			i = boundary.rootSegmentID;
			boundary = boundary.contentState;
			var requiresStyleInsertion = request.stylesToHoist;
			request.stylesToHoist = !1;
			writeChunk$1(destination, request.startInlineScript);
			writeChunk$1(destination, endOfStartTag$1);
			requiresStyleInsertion ? ((completedSegments.instructions & SentClientRenderFunction) === NothingSent && (completedSegments.instructions |= SentClientRenderFunction, writeChunk$1(destination, clientRenderScriptFunctionOnly$1)), (completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent && (completedSegments.instructions |= SentCompleteBoundaryFunction, writeChunk$1(destination, completeBoundaryScriptFunctionOnly$1)), (completedSegments.instructions & SentStyleInsertionFunction) === NothingSent ? (completedSegments.instructions |= SentStyleInsertionFunction, writeChunk$1(destination, completeBoundaryWithStylesScript1FullPartial$1)) : writeChunk$1(destination, completeBoundaryWithStylesScript1Partial$1)) : ((completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent && (completedSegments.instructions |= SentCompleteBoundaryFunction, writeChunk$1(destination, completeBoundaryScriptFunctionOnly$1)), writeChunk$1(destination, completeBoundaryScript1Partial$1));
			completedSegments = i.toString(16);
			writeChunk$1(destination, request.boundaryPrefix);
			writeChunk$1(destination, completedSegments);
			writeChunk$1(destination, completeBoundaryScript2$1);
			writeChunk$1(destination, request.segmentPrefix);
			writeChunk$1(destination, completedSegments);
			requiresStyleInsertion ? (writeChunk$1(destination, completeBoundaryScript3a$1), writeStyleResourceDependenciesInJS$2(destination, boundary)) : writeChunk$1(destination, completeBoundaryScript3b$1);
			boundary = writeChunkAndReturn$1(destination, completeBoundaryScriptEnd$1);
			return writeBootstrap$2(destination, request) && boundary;
		}
		function flushPartiallyCompletedSegment$2(request, destination, boundary, segment) {
			if (segment.status === FLUSHED) return !0;
			var hoistableState = boundary.contentState, segmentID = segment.id;
			if (-1 === segmentID) {
				if (-1 === (segment.id = boundary.rootSegmentID)) throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
				return flushSegmentContainer$2(request, destination, segment, hoistableState);
			}
			if (segmentID === boundary.rootSegmentID) return flushSegmentContainer$2(request, destination, segment, hoistableState);
			flushSegmentContainer$2(request, destination, segment, hoistableState);
			boundary = request.resumableState;
			request = request.renderState;
			writeChunk$1(destination, request.startInlineScript);
			writeChunk$1(destination, endOfStartTag$1);
			(boundary.instructions & SentCompleteSegmentFunction) === NothingSent ? (boundary.instructions |= SentCompleteSegmentFunction, writeChunk$1(destination, completeSegmentScript1Full$1)) : writeChunk$1(destination, completeSegmentScript1Partial$1);
			writeChunk$1(destination, request.segmentPrefix);
			segmentID = segmentID.toString(16);
			writeChunk$1(destination, segmentID);
			writeChunk$1(destination, completeSegmentScript2$1);
			writeChunk$1(destination, request.placeholderPrefix);
			writeChunk$1(destination, segmentID);
			destination = writeChunkAndReturn$1(destination, completeSegmentScriptEnd$1);
			return destination;
		}
		function flushCompletedQueues$2(request, destination) {
			currentView$1 = new Uint8Array(2048);
			writtenBytes$1 = 0;
			destinationHasCapacity$1$1 = !0;
			try {
				if (!(0 < request.pendingRootTasks)) {
					var i, completedRootSegment = request.completedRootSegment;
					if (null !== completedRootSegment) {
						if (completedRootSegment.status === POSTPONED) return;
						var completedPreambleSegments = request.completedPreambleSegments;
						if (null === completedPreambleSegments) return;
						flushedByteSize$2 = request.byteSize;
						var resumableState = request.resumableState, renderState = request.renderState, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;
						if (htmlChunks) {
							for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++) writeChunk$1(destination, htmlChunks[i$jscomp$0]);
							if (headChunks) for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++) writeChunk$1(destination, headChunks[i$jscomp$0]);
							else writeChunk$1(destination, startChunkForTag$2("head")), writeChunk$1(destination, endOfStartTag$1);
						} else if (headChunks) for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++) writeChunk$1(destination, headChunks[i$jscomp$0]);
						var charsetChunks = renderState.charsetChunks;
						for (i$jscomp$0 = 0; i$jscomp$0 < charsetChunks.length; i$jscomp$0++) writeChunk$1(destination, charsetChunks[i$jscomp$0]);
						charsetChunks.length = 0;
						renderState.preconnects.forEach(flushResource$2, destination);
						renderState.preconnects.clear();
						var viewportChunks = renderState.viewportChunks;
						for (i$jscomp$0 = 0; i$jscomp$0 < viewportChunks.length; i$jscomp$0++) writeChunk$1(destination, viewportChunks[i$jscomp$0]);
						viewportChunks.length = 0;
						renderState.fontPreloads.forEach(flushResource$2, destination);
						renderState.fontPreloads.clear();
						renderState.highImagePreloads.forEach(flushResource$2, destination);
						renderState.highImagePreloads.clear();
						currentlyFlushingRenderState$2 = renderState;
						renderState.styles.forEach(flushStylesInPreamble$2, destination);
						currentlyFlushingRenderState$2 = null;
						var importMapChunks = renderState.importMapChunks;
						for (i$jscomp$0 = 0; i$jscomp$0 < importMapChunks.length; i$jscomp$0++) writeChunk$1(destination, importMapChunks[i$jscomp$0]);
						importMapChunks.length = 0;
						renderState.bootstrapScripts.forEach(flushResource$2, destination);
						renderState.scripts.forEach(flushResource$2, destination);
						renderState.scripts.clear();
						renderState.bulkPreloads.forEach(flushResource$2, destination);
						renderState.bulkPreloads.clear();
						htmlChunks || headChunks || (resumableState.instructions |= SentCompletedShellId);
						var hoistableChunks = renderState.hoistableChunks;
						for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++) writeChunk$1(destination, hoistableChunks[i$jscomp$0]);
						for (resumableState = hoistableChunks.length = 0; resumableState < completedPreambleSegments.length; resumableState++) {
							var segments = completedPreambleSegments[resumableState];
							for (renderState = 0; renderState < segments.length; renderState++) flushSegment$2(request, destination, segments[renderState], null);
						}
						var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
						(preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) && writeChunk$1(destination, endChunkForTag$2("head"));
						var bodyChunks = preamble$jscomp$0.bodyChunks;
						if (bodyChunks) for (completedPreambleSegments = 0; completedPreambleSegments < bodyChunks.length; completedPreambleSegments++) writeChunk$1(destination, bodyChunks[completedPreambleSegments]);
						flushSegment$2(request, destination, completedRootSegment, null);
						request.completedRootSegment = null;
						var renderState$jscomp$0 = request.renderState;
						if (0 !== request.allPendingTasks || 0 !== request.clientRenderedBoundaries.length || 0 !== request.completedBoundaries.length || null !== request.trackedPostpones && (0 !== request.trackedPostpones.rootNodes.length || null !== request.trackedPostpones.rootSlots)) {
							var resumableState$jscomp$0 = request.resumableState;
							if ((resumableState$jscomp$0.instructions & SentMarkShellTime) === NothingSent) {
								resumableState$jscomp$0.instructions |= SentMarkShellTime;
								writeChunk$1(destination, renderState$jscomp$0.startInlineScript);
								if ((resumableState$jscomp$0.instructions & SentCompletedShellId) === NothingSent) {
									resumableState$jscomp$0.instructions |= SentCompletedShellId;
									var shellId = "_" + resumableState$jscomp$0.idPrefix + "R_";
									writeChunk$1(destination, completedShellIdAttributeStart$1);
									writeChunk$1(destination, escapeTextForBrowser$2(shellId));
									writeChunk$1(destination, attributeEnd$1);
								}
								writeChunk$1(destination, endOfStartTag$1);
								writeChunk$1(destination, shellTimeRuntimeScript$1);
								writeChunkAndReturn$1(destination, endInlineScript$1);
							}
						}
						writeBootstrap$2(destination, renderState$jscomp$0);
					}
					var renderState$jscomp$1 = request.renderState;
					completedRootSegment = 0;
					var viewportChunks$jscomp$0 = renderState$jscomp$1.viewportChunks;
					for (completedRootSegment = 0; completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++) writeChunk$1(destination, viewportChunks$jscomp$0[completedRootSegment]);
					viewportChunks$jscomp$0.length = 0;
					renderState$jscomp$1.preconnects.forEach(flushResource$2, destination);
					renderState$jscomp$1.preconnects.clear();
					renderState$jscomp$1.fontPreloads.forEach(flushResource$2, destination);
					renderState$jscomp$1.fontPreloads.clear();
					renderState$jscomp$1.highImagePreloads.forEach(flushResource$2, destination);
					renderState$jscomp$1.highImagePreloads.clear();
					renderState$jscomp$1.styles.forEach(preloadLateStyles$2, destination);
					renderState$jscomp$1.scripts.forEach(flushResource$2, destination);
					renderState$jscomp$1.scripts.clear();
					renderState$jscomp$1.bulkPreloads.forEach(flushResource$2, destination);
					renderState$jscomp$1.bulkPreloads.clear();
					var hoistableChunks$jscomp$0 = renderState$jscomp$1.hoistableChunks;
					for (completedRootSegment = 0; completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++) writeChunk$1(destination, hoistableChunks$jscomp$0[completedRootSegment]);
					hoistableChunks$jscomp$0.length = 0;
					var clientRenderedBoundaries = request.clientRenderedBoundaries;
					for (i = 0; i < clientRenderedBoundaries.length; i++) {
						var boundary = clientRenderedBoundaries[i];
						renderState$jscomp$1 = destination;
						var resumableState$jscomp$1 = request.resumableState, renderState$jscomp$2 = request.renderState, id = boundary.rootSegmentID, errorDigest = boundary.errorDigest, errorMessage = boundary.errorMessage, errorStack = boundary.errorStack, errorComponentStack = boundary.errorComponentStack;
						writeChunk$1(renderState$jscomp$1, renderState$jscomp$2.startInlineScript);
						writeChunk$1(renderState$jscomp$1, endOfStartTag$1);
						(resumableState$jscomp$1.instructions & SentClientRenderFunction) === NothingSent ? (resumableState$jscomp$1.instructions |= SentClientRenderFunction, writeChunk$1(renderState$jscomp$1, clientRenderScript1Full$1)) : writeChunk$1(renderState$jscomp$1, clientRenderScript1Partial$1);
						writeChunk$1(renderState$jscomp$1, renderState$jscomp$2.boundaryPrefix);
						writeChunk$1(renderState$jscomp$1, id.toString(16));
						writeChunk$1(renderState$jscomp$1, clientRenderScript1A$1);
						if (errorDigest || errorMessage || errorStack || errorComponentStack) writeChunk$1(renderState$jscomp$1, clientRenderErrorScriptArgInterstitial$1), writeChunk$1(renderState$jscomp$1, escapeJSStringsForInstructionScripts$2(errorDigest || ""));
						if (errorMessage || errorStack || errorComponentStack) writeChunk$1(renderState$jscomp$1, clientRenderErrorScriptArgInterstitial$1), writeChunk$1(renderState$jscomp$1, escapeJSStringsForInstructionScripts$2(errorMessage || ""));
						if (errorStack || errorComponentStack) writeChunk$1(renderState$jscomp$1, clientRenderErrorScriptArgInterstitial$1), writeChunk$1(renderState$jscomp$1, escapeJSStringsForInstructionScripts$2(errorStack || ""));
						errorComponentStack && (writeChunk$1(renderState$jscomp$1, clientRenderErrorScriptArgInterstitial$1), writeChunk$1(renderState$jscomp$1, escapeJSStringsForInstructionScripts$2(errorComponentStack)));
						var JSCompiler_inline_result = writeChunkAndReturn$1(renderState$jscomp$1, clientRenderScriptEnd$1);
						if (!JSCompiler_inline_result) {
							request.destination = null;
							i++;
							clientRenderedBoundaries.splice(0, i);
							return;
						}
					}
					clientRenderedBoundaries.splice(0, i);
					var completedBoundaries = request.completedBoundaries;
					for (i = 0; i < completedBoundaries.length; i++) if (!flushCompletedBoundary$2(request, destination, completedBoundaries[i])) {
						request.destination = null;
						i++;
						completedBoundaries.splice(0, i);
						return;
					}
					completedBoundaries.splice(0, i);
					completeWriting$1(destination);
					currentView$1 = new Uint8Array(2048);
					writtenBytes$1 = 0;
					flushingPartialBoundaries$2 = destinationHasCapacity$1$1 = !0;
					var partialBoundaries = request.partialBoundaries;
					for (i = 0; i < partialBoundaries.length; i++) {
						a: {
							clientRenderedBoundaries = request;
							boundary = destination;
							var boundary$jscomp$0 = partialBoundaries[i];
							flushedByteSize$2 = boundary$jscomp$0.byteSize;
							var completedSegments = boundary$jscomp$0.completedSegments;
							for (JSCompiler_inline_result = 0; JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++) if (!flushPartiallyCompletedSegment$2(clientRenderedBoundaries, boundary, boundary$jscomp$0, completedSegments[JSCompiler_inline_result])) {
								JSCompiler_inline_result++;
								completedSegments.splice(0, JSCompiler_inline_result);
								var JSCompiler_inline_result$jscomp$0 = !1;
								break a;
							}
							completedSegments.splice(0, JSCompiler_inline_result);
							var row = boundary$jscomp$0.row;
							null !== row && row.together && 1 === boundary$jscomp$0.pendingTasks && (1 === row.pendingTasks ? unblockSuspenseListRow$2(clientRenderedBoundaries, row, row.hoistables) : row.pendingTasks--);
							JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary$2(boundary, boundary$jscomp$0.contentState, clientRenderedBoundaries.renderState);
						}
						if (!JSCompiler_inline_result$jscomp$0) {
							request.destination = null;
							i++;
							partialBoundaries.splice(0, i);
							return;
						}
					}
					partialBoundaries.splice(0, i);
					flushingPartialBoundaries$2 = !1;
					var largeBoundaries = request.completedBoundaries;
					for (i = 0; i < largeBoundaries.length; i++) if (!flushCompletedBoundary$2(request, destination, largeBoundaries[i])) {
						request.destination = null;
						i++;
						largeBoundaries.splice(0, i);
						return;
					}
					largeBoundaries.splice(0, i);
				}
			} finally {
				flushingPartialBoundaries$2 = !1, 0 === request.allPendingTasks && 0 === request.clientRenderedBoundaries.length && 0 === request.completedBoundaries.length ? (request.flushScheduled = !1, i = request.resumableState, i.hasBody && writeChunk$1(destination, endChunkForTag$2("body")), i.hasHtml && writeChunk$1(destination, endChunkForTag$2("html")), completeWriting$1(destination), flushBuffered$1(destination), 0 !== request.abortableTasks.size && console.error("There was still abortable task at the root when we closed. This is a bug in React."), request.status = CLOSED, destination.end(), request.destination = null) : (completeWriting$1(destination), flushBuffered$1(destination));
			}
		}
		function startWork$1(request) {
			request.flushScheduled = null !== request.destination;
			scheduleMicrotask$1(function() {
				return requestStorage$1.run(request, performWork$2, request);
			});
			setImmediate(function() {
				10 === request.status && (request.status = 11);
				null === request.trackedPostpones && requestStorage$1.run(request, enqueueEarlyPreloadsAfterInitialWork$1, request);
			});
		}
		function enqueueEarlyPreloadsAfterInitialWork$1(request) {
			safelyEmitEarlyPreloads$2(request, 0 === request.pendingRootTasks);
		}
		function enqueueFlush$2(request) {
			!1 === request.flushScheduled && 0 === request.pingedTasks.length && null !== request.destination && (request.flushScheduled = !0, setImmediate(function() {
				var destination = request.destination;
				destination ? flushCompletedQueues$2(request, destination) : request.flushScheduled = !1;
			}));
		}
		function startFlowing$2(request, destination) {
			if (13 === request.status) request.status = CLOSED, destination.destroy(request.fatalError);
			else if (request.status !== CLOSED && null === request.destination) {
				request.destination = destination;
				try {
					flushCompletedQueues$2(request, destination);
				} catch (error) {
					destination = {}, logRecoverableError$2(request, error, destination, null), fatalError$2(request, error, destination, null);
				}
			}
		}
		function abort$2(request, reason) {
			if (11 === request.status || 10 === request.status) request.status = 12;
			try {
				var abortableTasks = request.abortableTasks;
				if (0 < abortableTasks.size) {
					var error = void 0 === reason ? Error("The render was aborted by the server without a reason.") : "object" === typeof reason && null !== reason && "function" === typeof reason.then ? Error("The render was aborted by the server with a promise.") : reason;
					request.fatalError = error;
					abortableTasks.forEach(function(task) {
						var prevTaskInDEV = currentTaskInDEV, prevGetCurrentStackImpl = ReactSharedInternals$2.getCurrentStack;
						currentTaskInDEV = task;
						ReactSharedInternals$2.getCurrentStack = getCurrentStackInDEV;
						try {
							abortTask$2(task, request, error);
						} finally {
							currentTaskInDEV = prevTaskInDEV, ReactSharedInternals$2.getCurrentStack = prevGetCurrentStackImpl;
						}
					});
					abortableTasks.clear();
				}
				null !== request.destination && flushCompletedQueues$2(request, request.destination);
			} catch (error$4) {
				reason = {}, logRecoverableError$2(request, error$4, reason, null), fatalError$2(request, error$4, reason, null);
			}
		}
		function addToReplayParent$2(node, parentKeyPath, trackedPostpones) {
			if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);
			else {
				var workingMap = trackedPostpones.workingMap, parentNode = workingMap.get(parentKeyPath);
				void 0 === parentNode && (parentNode = [
					parentKeyPath[1],
					parentKeyPath[2],
					[],
					null
				], workingMap.set(parentKeyPath, parentNode), addToReplayParent$2(parentNode, parentKeyPath[0], trackedPostpones));
				parentNode[2].push(node);
			}
		}
		function getPostponedState$1(request) {
			var trackedPostpones = request.trackedPostpones;
			if (null === trackedPostpones || 0 === trackedPostpones.rootNodes.length && null === trackedPostpones.rootSlots) return request.trackedPostpones = null;
			if (null === request.completedRootSegment || request.completedRootSegment.status !== POSTPONED && null !== request.completedPreambleSegments) {
				var nextSegmentId = request.nextSegmentId;
				var replaySlots = trackedPostpones.rootSlots;
				var resumableState = request.resumableState;
				resumableState.bootstrapScriptContent = void 0;
				resumableState.bootstrapScripts = void 0;
				resumableState.bootstrapModules = void 0;
			} else {
				nextSegmentId = 0;
				replaySlots = -1;
				resumableState = request.resumableState;
				var renderState = request.renderState;
				resumableState.nextFormID = 0;
				resumableState.hasBody = !1;
				resumableState.hasHtml = !1;
				resumableState.unknownResources = { font: renderState.resets.font };
				resumableState.dnsResources = renderState.resets.dns;
				resumableState.connectResources = renderState.resets.connect;
				resumableState.imageResources = renderState.resets.image;
				resumableState.styleResources = renderState.resets.style;
				resumableState.scriptResources = {};
				resumableState.moduleUnknownResources = {};
				resumableState.moduleScriptResources = {};
				resumableState.instructions = NothingSent;
			}
			return {
				nextSegmentId,
				rootFormatContext: request.rootFormatContext,
				progressiveChunkSize: request.progressiveChunkSize,
				resumableState: request.resumableState,
				replayNodes: trackedPostpones.rootNodes,
				replaySlots
			};
		}
		function ensureCorrectIsomorphicReactVersion$1() {
			var isomorphicReactPackageVersion = React$3.version;
			if ("19.2.0" !== isomorphicReactPackageVersion) throw Error("Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\n  - react:      " + (isomorphicReactPackageVersion + "\n  - react-dom:  19.2.0\nLearn more: https://react.dev/warnings/version-mismatch"));
		}
		function createDrainHandler$1(destination, request) {
			return function() {
				return startFlowing$2(request, destination);
			};
		}
		function createCancelHandler$1(request, reason) {
			return function() {
				request.destination = null;
				abort$2(request, Error(reason));
			};
		}
		function createRequestImpl$1(children, options) {
			var resumableState = createResumableState$2(options ? options.identifierPrefix : void 0, options ? options.unstable_externalRuntimeSrc : void 0, options ? options.bootstrapScriptContent : void 0, options ? options.bootstrapScripts : void 0, options ? options.bootstrapModules : void 0);
			return createRequest$2(children, resumableState, createRenderState$2(resumableState, options ? options.nonce : void 0, options ? options.unstable_externalRuntimeSrc : void 0, options ? options.importMap : void 0, options ? options.onHeaders : void 0, options ? options.maxHeadersLength : void 0), createRootFormatContext$1(options ? options.namespaceURI : void 0), options ? options.progressiveChunkSize : void 0, options ? options.onError : void 0, options ? options.onAllReady : void 0, options ? options.onShellReady : void 0, options ? options.onShellError : void 0, void 0, options ? options.onPostpone : void 0, options ? options.formState : void 0);
		}
		function createFakeWritableFromReadableStreamController$1$1(controller) {
			return {
				write: function(chunk) {
					"string" === typeof chunk && (chunk = textEncoder$1.encode(chunk));
					controller.enqueue(chunk);
					return !0;
				},
				end: function() {
					controller.close();
				},
				destroy: function(error) {
					"function" === typeof controller.error ? controller.error(error) : controller.close();
				}
			};
		}
		function resumeRequestImpl$1(children, postponedState, options) {
			return resumeRequest$1(children, postponedState, createRenderState$2(postponedState.resumableState, options ? options.nonce : void 0, void 0, void 0, void 0, void 0), options ? options.onError : void 0, options ? options.onAllReady : void 0, options ? options.onShellReady : void 0, options ? options.onShellError : void 0, void 0, options ? options.onPostpone : void 0);
		}
		function createFakeWritableFromReadableStreamController$2(controller) {
			return {
				write: function(chunk) {
					"string" === typeof chunk && (chunk = textEncoder$1.encode(chunk));
					controller.enqueue(chunk);
					return !0;
				},
				end: function() {
					controller.close();
				},
				destroy: function(error) {
					"function" === typeof controller.error ? controller.error(error) : controller.close();
				}
			};
		}
		function createFakeWritableFromReadable$1(readable) {
			return {
				write: function(chunk) {
					return readable.push(chunk);
				},
				end: function() {
					readable.push(null);
				},
				destroy: function(error) {
					readable.destroy(error);
				}
			};
		}
		var util$7 = __require("util"), crypto$1 = __require("crypto"), async_hooks$1 = __require("async_hooks"), React$3 = require_react(), ReactDOM$2 = require_react_dom(), stream$1 = __require("stream"), REACT_ELEMENT_TYPE$2 = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE$2 = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE$2 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE$2 = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE$2 = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE$2 = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE$2 = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE$2 = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE$2 = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE$2 = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE$2 = Symbol.for("react.memo"), REACT_LAZY_TYPE$2 = Symbol.for("react.lazy"), REACT_SCOPE_TYPE$2 = Symbol.for("react.scope"), REACT_ACTIVITY_TYPE$2 = Symbol.for("react.activity"), REACT_LEGACY_HIDDEN_TYPE$2 = Symbol.for("react.legacy_hidden"), REACT_MEMO_CACHE_SENTINEL$2 = Symbol.for("react.memo_cache_sentinel"), REACT_VIEW_TRANSITION_TYPE$2 = Symbol.for("react.view_transition"), MAYBE_ITERATOR_SYMBOL$2 = Symbol.iterator, isArrayImpl$2 = Array.isArray, jsxPropsParents = /* @__PURE__ */ new WeakMap(), jsxChildrenParents = /* @__PURE__ */ new WeakMap(), CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"), scheduleMicrotask$1 = queueMicrotask, currentView$1 = null, writtenBytes$1 = 0, destinationHasCapacity$1$1 = !0, textEncoder$1 = new util$7.TextEncoder(), assign$2 = Object.assign, hasOwnProperty$2 = Object.prototype.hasOwnProperty, VALID_ATTRIBUTE_NAME_REGEX$2 = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), illegalAttributeNameCache$2 = {}, validatedAttributeNameCache$2 = {}, unitlessNumbers$2 = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")), aliases$2 = new Map([
			["acceptCharset", "accept-charset"],
			["htmlFor", "for"],
			["httpEquiv", "http-equiv"],
			["crossOrigin", "crossorigin"],
			["accentHeight", "accent-height"],
			["alignmentBaseline", "alignment-baseline"],
			["arabicForm", "arabic-form"],
			["baselineShift", "baseline-shift"],
			["capHeight", "cap-height"],
			["clipPath", "clip-path"],
			["clipRule", "clip-rule"],
			["colorInterpolation", "color-interpolation"],
			["colorInterpolationFilters", "color-interpolation-filters"],
			["colorProfile", "color-profile"],
			["colorRendering", "color-rendering"],
			["dominantBaseline", "dominant-baseline"],
			["enableBackground", "enable-background"],
			["fillOpacity", "fill-opacity"],
			["fillRule", "fill-rule"],
			["floodColor", "flood-color"],
			["floodOpacity", "flood-opacity"],
			["fontFamily", "font-family"],
			["fontSize", "font-size"],
			["fontSizeAdjust", "font-size-adjust"],
			["fontStretch", "font-stretch"],
			["fontStyle", "font-style"],
			["fontVariant", "font-variant"],
			["fontWeight", "font-weight"],
			["glyphName", "glyph-name"],
			["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
			["glyphOrientationVertical", "glyph-orientation-vertical"],
			["horizAdvX", "horiz-adv-x"],
			["horizOriginX", "horiz-origin-x"],
			["imageRendering", "image-rendering"],
			["letterSpacing", "letter-spacing"],
			["lightingColor", "lighting-color"],
			["markerEnd", "marker-end"],
			["markerMid", "marker-mid"],
			["markerStart", "marker-start"],
			["overlinePosition", "overline-position"],
			["overlineThickness", "overline-thickness"],
			["paintOrder", "paint-order"],
			["panose-1", "panose-1"],
			["pointerEvents", "pointer-events"],
			["renderingIntent", "rendering-intent"],
			["shapeRendering", "shape-rendering"],
			["stopColor", "stop-color"],
			["stopOpacity", "stop-opacity"],
			["strikethroughPosition", "strikethrough-position"],
			["strikethroughThickness", "strikethrough-thickness"],
			["strokeDasharray", "stroke-dasharray"],
			["strokeDashoffset", "stroke-dashoffset"],
			["strokeLinecap", "stroke-linecap"],
			["strokeLinejoin", "stroke-linejoin"],
			["strokeMiterlimit", "stroke-miterlimit"],
			["strokeOpacity", "stroke-opacity"],
			["strokeWidth", "stroke-width"],
			["textAnchor", "text-anchor"],
			["textDecoration", "text-decoration"],
			["textRendering", "text-rendering"],
			["transformOrigin", "transform-origin"],
			["underlinePosition", "underline-position"],
			["underlineThickness", "underline-thickness"],
			["unicodeBidi", "unicode-bidi"],
			["unicodeRange", "unicode-range"],
			["unitsPerEm", "units-per-em"],
			["vAlphabetic", "v-alphabetic"],
			["vHanging", "v-hanging"],
			["vIdeographic", "v-ideographic"],
			["vMathematical", "v-mathematical"],
			["vectorEffect", "vector-effect"],
			["vertAdvY", "vert-adv-y"],
			["vertOriginX", "vert-origin-x"],
			["vertOriginY", "vert-origin-y"],
			["wordSpacing", "word-spacing"],
			["writingMode", "writing-mode"],
			["xmlnsXlink", "xmlns:xlink"],
			["xHeight", "x-height"]
		]), hasReadOnlyValue = {
			button: !0,
			checkbox: !0,
			image: !0,
			hidden: !0,
			radio: !0,
			reset: !0,
			submit: !0
		}, ariaProperties = {
			"aria-current": 0,
			"aria-description": 0,
			"aria-details": 0,
			"aria-disabled": 0,
			"aria-hidden": 0,
			"aria-invalid": 0,
			"aria-keyshortcuts": 0,
			"aria-label": 0,
			"aria-roledescription": 0,
			"aria-autocomplete": 0,
			"aria-checked": 0,
			"aria-expanded": 0,
			"aria-haspopup": 0,
			"aria-level": 0,
			"aria-modal": 0,
			"aria-multiline": 0,
			"aria-multiselectable": 0,
			"aria-orientation": 0,
			"aria-placeholder": 0,
			"aria-pressed": 0,
			"aria-readonly": 0,
			"aria-required": 0,
			"aria-selected": 0,
			"aria-sort": 0,
			"aria-valuemax": 0,
			"aria-valuemin": 0,
			"aria-valuenow": 0,
			"aria-valuetext": 0,
			"aria-atomic": 0,
			"aria-busy": 0,
			"aria-live": 0,
			"aria-relevant": 0,
			"aria-dropeffect": 0,
			"aria-grabbed": 0,
			"aria-activedescendant": 0,
			"aria-colcount": 0,
			"aria-colindex": 0,
			"aria-colspan": 0,
			"aria-controls": 0,
			"aria-describedby": 0,
			"aria-errormessage": 0,
			"aria-flowto": 0,
			"aria-labelledby": 0,
			"aria-owns": 0,
			"aria-posinset": 0,
			"aria-rowcount": 0,
			"aria-rowindex": 0,
			"aria-rowspan": 0,
			"aria-setsize": 0,
			"aria-braillelabel": 0,
			"aria-brailleroledescription": 0,
			"aria-colindextext": 0,
			"aria-rowindextext": 0
		}, warnedProperties$1 = {}, rARIA$1 = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), rARIACamel$1 = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), didWarnValueNull = !1, possibleStandardNames = {
			accept: "accept",
			acceptcharset: "acceptCharset",
			"accept-charset": "acceptCharset",
			accesskey: "accessKey",
			action: "action",
			allowfullscreen: "allowFullScreen",
			alt: "alt",
			as: "as",
			async: "async",
			autocapitalize: "autoCapitalize",
			autocomplete: "autoComplete",
			autocorrect: "autoCorrect",
			autofocus: "autoFocus",
			autoplay: "autoPlay",
			autosave: "autoSave",
			capture: "capture",
			cellpadding: "cellPadding",
			cellspacing: "cellSpacing",
			challenge: "challenge",
			charset: "charSet",
			checked: "checked",
			children: "children",
			cite: "cite",
			class: "className",
			classid: "classID",
			classname: "className",
			cols: "cols",
			colspan: "colSpan",
			content: "content",
			contenteditable: "contentEditable",
			contextmenu: "contextMenu",
			controls: "controls",
			controlslist: "controlsList",
			coords: "coords",
			crossorigin: "crossOrigin",
			dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
			data: "data",
			datetime: "dateTime",
			default: "default",
			defaultchecked: "defaultChecked",
			defaultvalue: "defaultValue",
			defer: "defer",
			dir: "dir",
			disabled: "disabled",
			disablepictureinpicture: "disablePictureInPicture",
			disableremoteplayback: "disableRemotePlayback",
			download: "download",
			draggable: "draggable",
			enctype: "encType",
			enterkeyhint: "enterKeyHint",
			fetchpriority: "fetchPriority",
			for: "htmlFor",
			form: "form",
			formmethod: "formMethod",
			formaction: "formAction",
			formenctype: "formEncType",
			formnovalidate: "formNoValidate",
			formtarget: "formTarget",
			frameborder: "frameBorder",
			headers: "headers",
			height: "height",
			hidden: "hidden",
			high: "high",
			href: "href",
			hreflang: "hrefLang",
			htmlfor: "htmlFor",
			httpequiv: "httpEquiv",
			"http-equiv": "httpEquiv",
			icon: "icon",
			id: "id",
			imagesizes: "imageSizes",
			imagesrcset: "imageSrcSet",
			inert: "inert",
			innerhtml: "innerHTML",
			inputmode: "inputMode",
			integrity: "integrity",
			is: "is",
			itemid: "itemID",
			itemprop: "itemProp",
			itemref: "itemRef",
			itemscope: "itemScope",
			itemtype: "itemType",
			keyparams: "keyParams",
			keytype: "keyType",
			kind: "kind",
			label: "label",
			lang: "lang",
			list: "list",
			loop: "loop",
			low: "low",
			manifest: "manifest",
			marginwidth: "marginWidth",
			marginheight: "marginHeight",
			max: "max",
			maxlength: "maxLength",
			media: "media",
			mediagroup: "mediaGroup",
			method: "method",
			min: "min",
			minlength: "minLength",
			multiple: "multiple",
			muted: "muted",
			name: "name",
			nomodule: "noModule",
			nonce: "nonce",
			novalidate: "noValidate",
			open: "open",
			optimum: "optimum",
			pattern: "pattern",
			placeholder: "placeholder",
			playsinline: "playsInline",
			poster: "poster",
			preload: "preload",
			profile: "profile",
			radiogroup: "radioGroup",
			readonly: "readOnly",
			referrerpolicy: "referrerPolicy",
			rel: "rel",
			required: "required",
			reversed: "reversed",
			role: "role",
			rows: "rows",
			rowspan: "rowSpan",
			sandbox: "sandbox",
			scope: "scope",
			scoped: "scoped",
			scrolling: "scrolling",
			seamless: "seamless",
			selected: "selected",
			shape: "shape",
			size: "size",
			sizes: "sizes",
			span: "span",
			spellcheck: "spellCheck",
			src: "src",
			srcdoc: "srcDoc",
			srclang: "srcLang",
			srcset: "srcSet",
			start: "start",
			step: "step",
			style: "style",
			summary: "summary",
			tabindex: "tabIndex",
			target: "target",
			title: "title",
			type: "type",
			usemap: "useMap",
			value: "value",
			width: "width",
			wmode: "wmode",
			wrap: "wrap",
			about: "about",
			accentheight: "accentHeight",
			"accent-height": "accentHeight",
			accumulate: "accumulate",
			additive: "additive",
			alignmentbaseline: "alignmentBaseline",
			"alignment-baseline": "alignmentBaseline",
			allowreorder: "allowReorder",
			alphabetic: "alphabetic",
			amplitude: "amplitude",
			arabicform: "arabicForm",
			"arabic-form": "arabicForm",
			ascent: "ascent",
			attributename: "attributeName",
			attributetype: "attributeType",
			autoreverse: "autoReverse",
			azimuth: "azimuth",
			basefrequency: "baseFrequency",
			baselineshift: "baselineShift",
			"baseline-shift": "baselineShift",
			baseprofile: "baseProfile",
			bbox: "bbox",
			begin: "begin",
			bias: "bias",
			by: "by",
			calcmode: "calcMode",
			capheight: "capHeight",
			"cap-height": "capHeight",
			clip: "clip",
			clippath: "clipPath",
			"clip-path": "clipPath",
			clippathunits: "clipPathUnits",
			cliprule: "clipRule",
			"clip-rule": "clipRule",
			color: "color",
			colorinterpolation: "colorInterpolation",
			"color-interpolation": "colorInterpolation",
			colorinterpolationfilters: "colorInterpolationFilters",
			"color-interpolation-filters": "colorInterpolationFilters",
			colorprofile: "colorProfile",
			"color-profile": "colorProfile",
			colorrendering: "colorRendering",
			"color-rendering": "colorRendering",
			contentscripttype: "contentScriptType",
			contentstyletype: "contentStyleType",
			cursor: "cursor",
			cx: "cx",
			cy: "cy",
			d: "d",
			datatype: "datatype",
			decelerate: "decelerate",
			descent: "descent",
			diffuseconstant: "diffuseConstant",
			direction: "direction",
			display: "display",
			divisor: "divisor",
			dominantbaseline: "dominantBaseline",
			"dominant-baseline": "dominantBaseline",
			dur: "dur",
			dx: "dx",
			dy: "dy",
			edgemode: "edgeMode",
			elevation: "elevation",
			enablebackground: "enableBackground",
			"enable-background": "enableBackground",
			end: "end",
			exponent: "exponent",
			externalresourcesrequired: "externalResourcesRequired",
			fill: "fill",
			fillopacity: "fillOpacity",
			"fill-opacity": "fillOpacity",
			fillrule: "fillRule",
			"fill-rule": "fillRule",
			filter: "filter",
			filterres: "filterRes",
			filterunits: "filterUnits",
			floodopacity: "floodOpacity",
			"flood-opacity": "floodOpacity",
			floodcolor: "floodColor",
			"flood-color": "floodColor",
			focusable: "focusable",
			fontfamily: "fontFamily",
			"font-family": "fontFamily",
			fontsize: "fontSize",
			"font-size": "fontSize",
			fontsizeadjust: "fontSizeAdjust",
			"font-size-adjust": "fontSizeAdjust",
			fontstretch: "fontStretch",
			"font-stretch": "fontStretch",
			fontstyle: "fontStyle",
			"font-style": "fontStyle",
			fontvariant: "fontVariant",
			"font-variant": "fontVariant",
			fontweight: "fontWeight",
			"font-weight": "fontWeight",
			format: "format",
			from: "from",
			fx: "fx",
			fy: "fy",
			g1: "g1",
			g2: "g2",
			glyphname: "glyphName",
			"glyph-name": "glyphName",
			glyphorientationhorizontal: "glyphOrientationHorizontal",
			"glyph-orientation-horizontal": "glyphOrientationHorizontal",
			glyphorientationvertical: "glyphOrientationVertical",
			"glyph-orientation-vertical": "glyphOrientationVertical",
			glyphref: "glyphRef",
			gradienttransform: "gradientTransform",
			gradientunits: "gradientUnits",
			hanging: "hanging",
			horizadvx: "horizAdvX",
			"horiz-adv-x": "horizAdvX",
			horizoriginx: "horizOriginX",
			"horiz-origin-x": "horizOriginX",
			ideographic: "ideographic",
			imagerendering: "imageRendering",
			"image-rendering": "imageRendering",
			in2: "in2",
			in: "in",
			inlist: "inlist",
			intercept: "intercept",
			k1: "k1",
			k2: "k2",
			k3: "k3",
			k4: "k4",
			k: "k",
			kernelmatrix: "kernelMatrix",
			kernelunitlength: "kernelUnitLength",
			kerning: "kerning",
			keypoints: "keyPoints",
			keysplines: "keySplines",
			keytimes: "keyTimes",
			lengthadjust: "lengthAdjust",
			letterspacing: "letterSpacing",
			"letter-spacing": "letterSpacing",
			lightingcolor: "lightingColor",
			"lighting-color": "lightingColor",
			limitingconeangle: "limitingConeAngle",
			local: "local",
			markerend: "markerEnd",
			"marker-end": "markerEnd",
			markerheight: "markerHeight",
			markermid: "markerMid",
			"marker-mid": "markerMid",
			markerstart: "markerStart",
			"marker-start": "markerStart",
			markerunits: "markerUnits",
			markerwidth: "markerWidth",
			mask: "mask",
			maskcontentunits: "maskContentUnits",
			maskunits: "maskUnits",
			mathematical: "mathematical",
			mode: "mode",
			numoctaves: "numOctaves",
			offset: "offset",
			opacity: "opacity",
			operator: "operator",
			order: "order",
			orient: "orient",
			orientation: "orientation",
			origin: "origin",
			overflow: "overflow",
			overlineposition: "overlinePosition",
			"overline-position": "overlinePosition",
			overlinethickness: "overlineThickness",
			"overline-thickness": "overlineThickness",
			paintorder: "paintOrder",
			"paint-order": "paintOrder",
			panose1: "panose1",
			"panose-1": "panose1",
			pathlength: "pathLength",
			patterncontentunits: "patternContentUnits",
			patterntransform: "patternTransform",
			patternunits: "patternUnits",
			pointerevents: "pointerEvents",
			"pointer-events": "pointerEvents",
			points: "points",
			pointsatx: "pointsAtX",
			pointsaty: "pointsAtY",
			pointsatz: "pointsAtZ",
			popover: "popover",
			popovertarget: "popoverTarget",
			popovertargetaction: "popoverTargetAction",
			prefix: "prefix",
			preservealpha: "preserveAlpha",
			preserveaspectratio: "preserveAspectRatio",
			primitiveunits: "primitiveUnits",
			property: "property",
			r: "r",
			radius: "radius",
			refx: "refX",
			refy: "refY",
			renderingintent: "renderingIntent",
			"rendering-intent": "renderingIntent",
			repeatcount: "repeatCount",
			repeatdur: "repeatDur",
			requiredextensions: "requiredExtensions",
			requiredfeatures: "requiredFeatures",
			resource: "resource",
			restart: "restart",
			result: "result",
			results: "results",
			rotate: "rotate",
			rx: "rx",
			ry: "ry",
			scale: "scale",
			security: "security",
			seed: "seed",
			shaperendering: "shapeRendering",
			"shape-rendering": "shapeRendering",
			slope: "slope",
			spacing: "spacing",
			specularconstant: "specularConstant",
			specularexponent: "specularExponent",
			speed: "speed",
			spreadmethod: "spreadMethod",
			startoffset: "startOffset",
			stddeviation: "stdDeviation",
			stemh: "stemh",
			stemv: "stemv",
			stitchtiles: "stitchTiles",
			stopcolor: "stopColor",
			"stop-color": "stopColor",
			stopopacity: "stopOpacity",
			"stop-opacity": "stopOpacity",
			strikethroughposition: "strikethroughPosition",
			"strikethrough-position": "strikethroughPosition",
			strikethroughthickness: "strikethroughThickness",
			"strikethrough-thickness": "strikethroughThickness",
			string: "string",
			stroke: "stroke",
			strokedasharray: "strokeDasharray",
			"stroke-dasharray": "strokeDasharray",
			strokedashoffset: "strokeDashoffset",
			"stroke-dashoffset": "strokeDashoffset",
			strokelinecap: "strokeLinecap",
			"stroke-linecap": "strokeLinecap",
			strokelinejoin: "strokeLinejoin",
			"stroke-linejoin": "strokeLinejoin",
			strokemiterlimit: "strokeMiterlimit",
			"stroke-miterlimit": "strokeMiterlimit",
			strokewidth: "strokeWidth",
			"stroke-width": "strokeWidth",
			strokeopacity: "strokeOpacity",
			"stroke-opacity": "strokeOpacity",
			suppresscontenteditablewarning: "suppressContentEditableWarning",
			suppresshydrationwarning: "suppressHydrationWarning",
			surfacescale: "surfaceScale",
			systemlanguage: "systemLanguage",
			tablevalues: "tableValues",
			targetx: "targetX",
			targety: "targetY",
			textanchor: "textAnchor",
			"text-anchor": "textAnchor",
			textdecoration: "textDecoration",
			"text-decoration": "textDecoration",
			textlength: "textLength",
			textrendering: "textRendering",
			"text-rendering": "textRendering",
			to: "to",
			transform: "transform",
			transformorigin: "transformOrigin",
			"transform-origin": "transformOrigin",
			typeof: "typeof",
			u1: "u1",
			u2: "u2",
			underlineposition: "underlinePosition",
			"underline-position": "underlinePosition",
			underlinethickness: "underlineThickness",
			"underline-thickness": "underlineThickness",
			unicode: "unicode",
			unicodebidi: "unicodeBidi",
			"unicode-bidi": "unicodeBidi",
			unicoderange: "unicodeRange",
			"unicode-range": "unicodeRange",
			unitsperem: "unitsPerEm",
			"units-per-em": "unitsPerEm",
			unselectable: "unselectable",
			valphabetic: "vAlphabetic",
			"v-alphabetic": "vAlphabetic",
			values: "values",
			vectoreffect: "vectorEffect",
			"vector-effect": "vectorEffect",
			version: "version",
			vertadvy: "vertAdvY",
			"vert-adv-y": "vertAdvY",
			vertoriginx: "vertOriginX",
			"vert-origin-x": "vertOriginX",
			vertoriginy: "vertOriginY",
			"vert-origin-y": "vertOriginY",
			vhanging: "vHanging",
			"v-hanging": "vHanging",
			videographic: "vIdeographic",
			"v-ideographic": "vIdeographic",
			viewbox: "viewBox",
			viewtarget: "viewTarget",
			visibility: "visibility",
			vmathematical: "vMathematical",
			"v-mathematical": "vMathematical",
			vocab: "vocab",
			widths: "widths",
			wordspacing: "wordSpacing",
			"word-spacing": "wordSpacing",
			writingmode: "writingMode",
			"writing-mode": "writingMode",
			x1: "x1",
			x2: "x2",
			x: "x",
			xchannelselector: "xChannelSelector",
			xheight: "xHeight",
			"x-height": "xHeight",
			xlinkactuate: "xlinkActuate",
			"xlink:actuate": "xlinkActuate",
			xlinkarcrole: "xlinkArcrole",
			"xlink:arcrole": "xlinkArcrole",
			xlinkhref: "xlinkHref",
			"xlink:href": "xlinkHref",
			xlinkrole: "xlinkRole",
			"xlink:role": "xlinkRole",
			xlinkshow: "xlinkShow",
			"xlink:show": "xlinkShow",
			xlinktitle: "xlinkTitle",
			"xlink:title": "xlinkTitle",
			xlinktype: "xlinkType",
			"xlink:type": "xlinkType",
			xmlbase: "xmlBase",
			"xml:base": "xmlBase",
			xmllang: "xmlLang",
			"xml:lang": "xmlLang",
			xmlns: "xmlns",
			"xml:space": "xmlSpace",
			xmlnsxlink: "xmlnsXlink",
			"xmlns:xlink": "xmlnsXlink",
			xmlspace: "xmlSpace",
			y1: "y1",
			y2: "y2",
			y: "y",
			ychannelselector: "yChannelSelector",
			z: "z",
			zoomandpan: "zoomAndPan"
		}, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), rARIACamel = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern$1$1 = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = !1, warnedForInfinityValue = !1, matchHtmlRegExp$2 = /["'&<>]/, uppercasePattern$2 = /([A-Z])/g, msPattern$2 = /^ms-/, isJavaScriptProtocol$2 = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, ReactSharedInternals$2 = React$3.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals$2 = ReactDOM$2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
			pending: !1,
			data: null,
			method: null,
			action: null
		}), previousDispatcher$2 = ReactDOMSharedInternals$2.d;
		ReactDOMSharedInternals$2.d = {
			f: previousDispatcher$2.f,
			r: previousDispatcher$2.r,
			D: function(href) {
				var request = resolveRequest$1();
				if (request) {
					var resumableState = request.resumableState, renderState = request.renderState;
					if ("string" === typeof href && href) {
						if (!resumableState.dnsResources.hasOwnProperty(href)) {
							resumableState.dnsResources[href] = EXISTS;
							resumableState = renderState.headers;
							var header, JSCompiler_temp;
							if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) JSCompiler_temp = (header = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=dns-prefetch", 0 <= (resumableState.remainingCapacity -= header.length + 2));
							JSCompiler_temp ? (renderState.resets.dns[href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (header = [], pushLinkImpl$2(header, {
								href,
								rel: "dns-prefetch"
							}), renderState.preconnects.add(header));
						}
						enqueueFlush$2(request);
					}
				} else previousDispatcher$2.D(href);
			},
			C: function(href, crossOrigin) {
				var request = resolveRequest$1();
				if (request) {
					var resumableState = request.resumableState, renderState = request.renderState;
					if ("string" === typeof href && href) {
						var bucket = "use-credentials" === crossOrigin ? "credentials" : "string" === typeof crossOrigin ? "anonymous" : "default";
						if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {
							resumableState.connectResources[bucket][href] = EXISTS;
							resumableState = renderState.headers;
							var header, JSCompiler_temp;
							if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {
								JSCompiler_temp = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=preconnect";
								if ("string" === typeof crossOrigin) {
									var escapedCrossOrigin = escapeStringForLinkHeaderQuotedParamValueContext(crossOrigin, "crossOrigin");
									JSCompiler_temp += "; crossorigin=\"" + escapedCrossOrigin + "\"";
								}
								JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));
							}
							JSCompiler_temp ? (renderState.resets.connect[bucket][href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (bucket = [], pushLinkImpl$2(bucket, {
								rel: "preconnect",
								href,
								crossOrigin
							}), renderState.preconnects.add(bucket));
						}
						enqueueFlush$2(request);
					}
				} else previousDispatcher$2.C(href, crossOrigin);
			},
			L: function(href, as, options) {
				var request = resolveRequest$1();
				if (request) {
					var resumableState = request.resumableState, renderState = request.renderState;
					if (as && href) {
						switch (as) {
							case "image":
								if (options) {
									var imageSrcSet = options.imageSrcSet;
									var imageSizes = options.imageSizes;
									var fetchPriority = options.fetchPriority;
								}
								var key = imageSrcSet ? imageSrcSet + "\n" + (imageSizes || "") : href;
								if (resumableState.imageResources.hasOwnProperty(key)) return;
								resumableState.imageResources[key] = PRELOAD_NO_CREDS$2;
								resumableState = renderState.headers;
								var header;
								resumableState && 0 < resumableState.remainingCapacity && "string" !== typeof imageSrcSet && "high" === fetchPriority && (header = getPreloadAsHeader$2(href, as, options), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS$2, resumableState.highImagePreloads && (resumableState.highImagePreloads += ", "), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl$2(resumableState, assign$2({
									rel: "preload",
									href: imageSrcSet ? void 0 : href,
									as
								}, options)), "high" === fetchPriority ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));
								break;
							case "style":
								if (resumableState.styleResources.hasOwnProperty(href)) return;
								imageSrcSet = [];
								pushLinkImpl$2(imageSrcSet, assign$2({
									rel: "preload",
									href,
									as
								}, options));
								resumableState.styleResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS$2 : [options.crossOrigin, options.integrity];
								renderState.preloads.stylesheets.set(href, imageSrcSet);
								renderState.bulkPreloads.add(imageSrcSet);
								break;
							case "script":
								if (resumableState.scriptResources.hasOwnProperty(href)) return;
								imageSrcSet = [];
								renderState.preloads.scripts.set(href, imageSrcSet);
								renderState.bulkPreloads.add(imageSrcSet);
								pushLinkImpl$2(imageSrcSet, assign$2({
									rel: "preload",
									href,
									as
								}, options));
								resumableState.scriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS$2 : [options.crossOrigin, options.integrity];
								break;
							default:
								if (resumableState.unknownResources.hasOwnProperty(as)) {
									if (imageSrcSet = resumableState.unknownResources[as], imageSrcSet.hasOwnProperty(href)) return;
								} else imageSrcSet = {}, resumableState.unknownResources[as] = imageSrcSet;
								imageSrcSet[href] = PRELOAD_NO_CREDS$2;
								if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && "font" === as && (key = getPreloadAsHeader$2(href, as, options), 0 <= (resumableState.remainingCapacity -= key.length + 2))) renderState.resets.font[href] = PRELOAD_NO_CREDS$2, resumableState.fontPreloads && (resumableState.fontPreloads += ", "), resumableState.fontPreloads += key;
								else switch (resumableState = [], href = assign$2({
									rel: "preload",
									href,
									as
								}, options), pushLinkImpl$2(resumableState, href), as) {
									case "font":
										renderState.fontPreloads.add(resumableState);
										break;
									default: renderState.bulkPreloads.add(resumableState);
								}
						}
						enqueueFlush$2(request);
					}
				} else previousDispatcher$2.L(href, as, options);
			},
			m: function(href, options) {
				var request = resolveRequest$1();
				if (request) {
					var resumableState = request.resumableState, renderState = request.renderState;
					if (href) {
						var as = options && "string" === typeof options.as ? options.as : "script";
						switch (as) {
							case "script":
								if (resumableState.moduleScriptResources.hasOwnProperty(href)) return;
								as = [];
								resumableState.moduleScriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS$2 : [options.crossOrigin, options.integrity];
								renderState.preloads.moduleScripts.set(href, as);
								break;
							default:
								if (resumableState.moduleUnknownResources.hasOwnProperty(as)) {
									var resources = resumableState.unknownResources[as];
									if (resources.hasOwnProperty(href)) return;
								} else resources = {}, resumableState.moduleUnknownResources[as] = resources;
								as = [];
								resources[href] = PRELOAD_NO_CREDS$2;
						}
						pushLinkImpl$2(as, assign$2({
							rel: "modulepreload",
							href
						}, options));
						renderState.bulkPreloads.add(as);
						enqueueFlush$2(request);
					}
				} else previousDispatcher$2.m(href, options);
			},
			X: function(src, options) {
				var request = resolveRequest$1();
				if (request) {
					var resumableState = request.resumableState, renderState = request.renderState;
					if (src) {
						var resourceState = resumableState.scriptResources.hasOwnProperty(src) ? resumableState.scriptResources[src] : void 0;
						resourceState !== EXISTS && (resumableState.scriptResources[src] = EXISTS, options = assign$2({
							src,
							async: !0
						}, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials$2(options, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl$2(src, options), enqueueFlush$2(request));
					}
				} else previousDispatcher$2.X(src, options);
			},
			S: function(href, precedence, options) {
				var request = resolveRequest$1();
				if (request) {
					var resumableState = request.resumableState, renderState = request.renderState;
					if (href) {
						precedence = precedence || "default";
						var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
						resourceState !== EXISTS && (resumableState.styleResources[href] = EXISTS, styleQueue || (styleQueue = {
							precedence: escapeTextForBrowser$2(precedence),
							rules: [],
							hrefs: [],
							sheets: /* @__PURE__ */ new Map()
						}, renderState.styles.set(precedence, styleQueue)), precedence = {
							state: PENDING$1,
							props: assign$2({
								rel: "stylesheet",
								href,
								"data-precedence": precedence
							}, options)
						}, resourceState && (2 === resourceState.length && adoptPreloadCredentials$2(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = PRELOADED), styleQueue.sheets.set(href, precedence), enqueueFlush$2(request));
					}
				} else previousDispatcher$2.S(href, precedence, options);
			},
			M: function(src, options) {
				var request = resolveRequest$1();
				if (request) {
					var resumableState = request.resumableState, renderState = request.renderState;
					if (src) {
						var resourceState = resumableState.moduleScriptResources.hasOwnProperty(src) ? resumableState.moduleScriptResources[src] : void 0;
						resourceState !== EXISTS && (resumableState.moduleScriptResources[src] = EXISTS, options = assign$2({
							src,
							type: "module",
							async: !0
						}, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials$2(options, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl$2(src, options), enqueueFlush$2(request));
					}
				} else previousDispatcher$2.M(src, options);
			}
		};
		var NothingSent = 0, SentCompleteSegmentFunction = 1, SentCompleteBoundaryFunction = 2, SentClientRenderFunction = 4, SentStyleInsertionFunction = 8, SentCompletedShellId = 32, SentMarkShellTime = 64, EXISTS = null, PRELOAD_NO_CREDS$2 = [];
		Object.freeze(PRELOAD_NO_CREDS$2);
		var currentlyFlushingRenderState$2 = null;
		stringToPrecomputedChunk$1("\"></template>");
		var startInlineScript$1 = stringToPrecomputedChunk$1("<script"), endInlineScript$1 = stringToPrecomputedChunk$1("<\/script>"), startScriptSrc$1 = stringToPrecomputedChunk$1("<script src=\""), startModuleSrc$1 = stringToPrecomputedChunk$1("<script type=\"module\" src=\""), scriptNonce$1 = stringToPrecomputedChunk$1(" nonce=\""), scriptIntegirty$1 = stringToPrecomputedChunk$1(" integrity=\""), scriptCrossOrigin$1 = stringToPrecomputedChunk$1(" crossorigin=\""), endAsyncScript$1 = stringToPrecomputedChunk$1(" async=\"\"><\/script>"), startInlineStyle$1 = stringToPrecomputedChunk$1("<style"), scriptRegex$2 = /(<\/|<)(s)(cript)/gi, importMapScriptStart$1 = stringToPrecomputedChunk$1("<script type=\"importmap\">"), importMapScriptEnd$1 = stringToPrecomputedChunk$1("<\/script>");
		var didWarnForNewBooleanPropsWithEmptyValue = {};
		var ROOT_HTML_MODE = 0, HTML_HTML_MODE = 1, HTML_MODE = 2, HTML_HEAD_MODE = 3, SVG_MODE = 4, MATHML_MODE = 5, HTML_TABLE_MODE = 6, HTML_TABLE_BODY_MODE = 7, HTML_TABLE_ROW_MODE = 8, HTML_COLGROUP_MODE = 9, textSeparator$1 = stringToPrecomputedChunk$1("<!-- -->"), styleNameCache$2 = /* @__PURE__ */ new Map(), styleAttributeStart$1 = stringToPrecomputedChunk$1(" style=\""), styleAssign$1 = stringToPrecomputedChunk$1(":"), styleSeparator$1 = stringToPrecomputedChunk$1(";"), attributeSeparator$1 = stringToPrecomputedChunk$1(" "), attributeAssign$1 = stringToPrecomputedChunk$1("=\""), attributeEnd$1 = stringToPrecomputedChunk$1("\""), attributeEmptyString$1 = stringToPrecomputedChunk$1("=\"\""), actionJavaScriptURL$2 = stringToPrecomputedChunk$1(escapeTextForBrowser$2("javascript:throw new Error('React form unexpectedly submitted.')")), startHiddenInputChunk$1 = stringToPrecomputedChunk$1("<input type=\"hidden\""), endOfStartTag$1 = stringToPrecomputedChunk$1(">"), endOfStartTagSelfClosing$1 = stringToPrecomputedChunk$1("/>"), didWarnDefaultInputValue = !1, didWarnDefaultChecked = !1, didWarnDefaultSelectValue = !1, didWarnDefaultTextareaValue = !1, didWarnInvalidOptionChildren = !1, didWarnInvalidOptionInnerHTML = !1, didWarnSelectedSetOnOption = !1, didWarnFormActionType = !1, didWarnFormActionName = !1, didWarnFormActionTarget = !1, didWarnFormActionMethod = !1, selectedMarkerAttribute$1 = stringToPrecomputedChunk$1(" selected=\"\""), formReplayingRuntimeScript$1 = stringToPrecomputedChunk$1("addEventListener(\"submit\",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute(\"formAction\");null!=f&&(e=f,b=null)}\"javascript:throw new Error('React form unexpectedly submitted.')\"===e&&(a.preventDefault(),b?(a=document.createElement(\"input\"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});"), formStateMarkerIsMatching$1 = stringToPrecomputedChunk$1("<!--F!-->"), formStateMarkerIsNotMatching$1 = stringToPrecomputedChunk$1("<!--F-->"), styleRegex$2 = /(<\/|<)(s)(tyle)/gi, headPreambleContributionChunk$1 = stringToPrecomputedChunk$1("<!--head-->"), bodyPreambleContributionChunk$1 = stringToPrecomputedChunk$1("<!--body-->"), htmlPreambleContributionChunk$1 = stringToPrecomputedChunk$1("<!--html-->"), leadingNewline$1 = stringToPrecomputedChunk$1("\n"), VALID_TAG_REGEX$2 = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache$2 = /* @__PURE__ */ new Map(), doctypeChunk$1 = stringToPrecomputedChunk$1("<!DOCTYPE html>"), endTagCache$2 = /* @__PURE__ */ new Map(), shellTimeRuntimeScript$1 = stringToPrecomputedChunk$1("requestAnimationFrame(function(){$RT=performance.now()});"), placeholder1$1 = stringToPrecomputedChunk$1("<template id=\""), placeholder2$1 = stringToPrecomputedChunk$1("\"></template>"), startActivityBoundary$1 = stringToPrecomputedChunk$1("<!--&-->"), endActivityBoundary$1 = stringToPrecomputedChunk$1("<!--/&-->"), startCompletedSuspenseBoundary$1 = stringToPrecomputedChunk$1("<!--$-->"), startPendingSuspenseBoundary1$1 = stringToPrecomputedChunk$1("<!--$?--><template id=\""), startPendingSuspenseBoundary2$1 = stringToPrecomputedChunk$1("\"></template>"), startClientRenderedSuspenseBoundary$1 = stringToPrecomputedChunk$1("<!--$!-->"), endSuspenseBoundary$1 = stringToPrecomputedChunk$1("<!--/$-->"), clientRenderedSuspenseBoundaryError1$1 = stringToPrecomputedChunk$1("<template"), clientRenderedSuspenseBoundaryErrorAttrInterstitial$1 = stringToPrecomputedChunk$1("\""), clientRenderedSuspenseBoundaryError1A$1 = stringToPrecomputedChunk$1(" data-dgst=\""), clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk$1(" data-msg=\""), clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk$1(" data-stck=\""), clientRenderedSuspenseBoundaryError1D = stringToPrecomputedChunk$1(" data-cstck=\""), clientRenderedSuspenseBoundaryError2$1 = stringToPrecomputedChunk$1("></template>"), startSegmentHTML$1 = stringToPrecomputedChunk$1("<div hidden id=\""), startSegmentHTML2$1 = stringToPrecomputedChunk$1("\">"), endSegmentHTML$1 = stringToPrecomputedChunk$1("</div>"), startSegmentSVG$1 = stringToPrecomputedChunk$1("<svg aria-hidden=\"true\" style=\"display:none\" id=\""), startSegmentSVG2$1 = stringToPrecomputedChunk$1("\">"), endSegmentSVG$1 = stringToPrecomputedChunk$1("</svg>"), startSegmentMathML$1 = stringToPrecomputedChunk$1("<math aria-hidden=\"true\" style=\"display:none\" id=\""), startSegmentMathML2$1 = stringToPrecomputedChunk$1("\">"), endSegmentMathML$1 = stringToPrecomputedChunk$1("</math>"), startSegmentTable$1 = stringToPrecomputedChunk$1("<table hidden id=\""), startSegmentTable2$1 = stringToPrecomputedChunk$1("\">"), endSegmentTable$1 = stringToPrecomputedChunk$1("</table>"), startSegmentTableBody$1 = stringToPrecomputedChunk$1("<table hidden><tbody id=\""), startSegmentTableBody2$1 = stringToPrecomputedChunk$1("\">"), endSegmentTableBody$1 = stringToPrecomputedChunk$1("</tbody></table>"), startSegmentTableRow$1 = stringToPrecomputedChunk$1("<table hidden><tr id=\""), startSegmentTableRow2$1 = stringToPrecomputedChunk$1("\">"), endSegmentTableRow$1 = stringToPrecomputedChunk$1("</tr></table>"), startSegmentColGroup$1 = stringToPrecomputedChunk$1("<table hidden><colgroup id=\""), startSegmentColGroup2$1 = stringToPrecomputedChunk$1("\">"), endSegmentColGroup$1 = stringToPrecomputedChunk$1("</colgroup></table>"), completeSegmentScript1Full$1 = stringToPrecomputedChunk$1("$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(\""), completeSegmentScript1Partial$1 = stringToPrecomputedChunk$1("$RS(\""), completeSegmentScript2$1 = stringToPrecomputedChunk$1("\",\""), completeSegmentScriptEnd$1 = stringToPrecomputedChunk$1("\")<\/script>");
		stringToPrecomputedChunk$1("<template data-rsi=\"\" data-sid=\"");
		stringToPrecomputedChunk$1("\" data-pid=\"");
		var completeBoundaryScriptFunctionOnly$1 = stringToPrecomputedChunk$1("$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if(\"/$\"===d||\"/&\"===d)if(0===h)break;else h--;else\"$\"!==d&&\"$?\"!==d&&\"$~\"!==d&&\"$!\"!==d&&\"&\"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data=\"$\";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};\n$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data=\"$~\",$RB.push(a,b),2===$RB.length&&(\"number\"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};"), completeBoundaryScript1Partial$1 = stringToPrecomputedChunk$1("$RC(\""), completeBoundaryWithStylesScript1FullPartial$1 = stringToPrecomputedChunk$1("$RM=new Map;$RR=function(n,w,p){function u(q){this._p=null;q()}for(var r=new Map,t=document,h,b,e=t.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),v=[],k=0;b=e[k++];)\"not all\"===b.getAttribute(\"media\")?v.push(b):(\"LINK\"===b.tagName&&$RM.set(b.getAttribute(\"href\"),b),r.set(b.dataset.precedence,h=b));e=0;b=[];var l,a;for(k=!0;;){if(k){var f=p[e++];if(!f){k=!1;e=0;continue}var c=!1,m=0;var d=f[m++];if(a=$RM.get(d)){var g=a._p;c=!0}else{a=t.createElement(\"link\");a.href=d;a.rel=\n\"stylesheet\";for(a.dataset.precedence=l=f[m++];g=f[m++];)a.setAttribute(g,f[m++]);g=a._p=new Promise(function(q,x){a.onload=u.bind(a,q);a.onerror=u.bind(a,x)});$RM.set(d,a)}d=a.getAttribute(\"media\");!g||d&&!matchMedia(d).matches||b.push(g);if(c)continue}else{a=v[e++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=r.get(l)||h;c===h&&(h=a);r.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=t.head,c.insertBefore(a,c.firstChild))}if(p=document.getElementById(n))p.previousSibling.data=\n\"$~\";Promise.all(b).then($RC.bind(null,n,w),$RX.bind(null,n,\"CSS failed to load\"))};$RR(\""), completeBoundaryWithStylesScript1Partial$1 = stringToPrecomputedChunk$1("$RR(\""), completeBoundaryScript2$1 = stringToPrecomputedChunk$1("\",\""), completeBoundaryScript3a$1 = stringToPrecomputedChunk$1("\","), completeBoundaryScript3b$1 = stringToPrecomputedChunk$1("\""), completeBoundaryScriptEnd$1 = stringToPrecomputedChunk$1(")<\/script>");
		stringToPrecomputedChunk$1("<template data-rci=\"\" data-bid=\"");
		stringToPrecomputedChunk$1("<template data-rri=\"\" data-bid=\"");
		stringToPrecomputedChunk$1("\" data-sid=\"");
		stringToPrecomputedChunk$1("\" data-sty=\"");
		var clientRenderScriptFunctionOnly$1 = stringToPrecomputedChunk$1("$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};"), clientRenderScript1Full$1 = stringToPrecomputedChunk$1("$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX(\""), clientRenderScript1Partial$1 = stringToPrecomputedChunk$1("$RX(\""), clientRenderScript1A$1 = stringToPrecomputedChunk$1("\""), clientRenderErrorScriptArgInterstitial$1 = stringToPrecomputedChunk$1(","), clientRenderScriptEnd$1 = stringToPrecomputedChunk$1(")<\/script>");
		stringToPrecomputedChunk$1("<template data-rxi=\"\" data-bid=\"");
		stringToPrecomputedChunk$1("\" data-dgst=\"");
		stringToPrecomputedChunk$1("\" data-msg=\"");
		stringToPrecomputedChunk$1("\" data-stck=\"");
		stringToPrecomputedChunk$1("\" data-cstck=\"");
		var regexForJSStringsInInstructionScripts$2 = /[<\u2028\u2029]/g, regexForJSStringsInScripts$2 = /[&><\u2028\u2029]/g, lateStyleTagResourceOpen1$1 = stringToPrecomputedChunk$1(" media=\"not all\" data-precedence=\""), lateStyleTagResourceOpen2$1 = stringToPrecomputedChunk$1("\" data-href=\""), lateStyleTagResourceOpen3$1 = stringToPrecomputedChunk$1("\">"), lateStyleTagTemplateClose$1 = stringToPrecomputedChunk$1("</style>"), currentlyRenderingBoundaryHasStylesToHoist$2 = !1, destinationHasCapacity$3 = !0, stylesheetFlushingQueue$2 = [], styleTagResourceOpen1$1 = stringToPrecomputedChunk$1(" data-precedence=\""), styleTagResourceOpen2$1 = stringToPrecomputedChunk$1("\" data-href=\""), spaceSeparator$1 = stringToPrecomputedChunk$1(" "), styleTagResourceOpen3$1 = stringToPrecomputedChunk$1("\">"), styleTagResourceClose$1 = stringToPrecomputedChunk$1("</style>");
		stringToPrecomputedChunk$1("<link rel=\"expect\" href=\"#");
		stringToPrecomputedChunk$1("\" blocking=\"render\"/>");
		var completedShellIdAttributeStart$1 = stringToPrecomputedChunk$1(" id=\""), arrayFirstOpenBracket$1 = stringToPrecomputedChunk$1("["), arraySubsequentOpenBracket$1 = stringToPrecomputedChunk$1(",["), arrayInterstitial$1 = stringToPrecomputedChunk$1(","), arrayCloseBracket$1 = stringToPrecomputedChunk$1("]"), PENDING$1 = 0, PRELOADED = 1, PREAMBLE = 2, LATE = 3, regexForHrefInLinkHeaderURLContext$2 = /[<>\r\n]/g, regexForLinkHeaderQuotedParamValueContext$2 = /["';,\r\n]/g, bind$2 = Function.prototype.bind, requestStorage$1 = new async_hooks$1.AsyncLocalStorage(), REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"), emptyContextObject$2 = {};
		Object.freeze(emptyContextObject$2);
		var rendererSigil = {};
		var currentActiveSnapshot$2 = null, didWarnAboutNoopUpdateForComponent = {}, didWarnAboutDeprecatedWillMount = {};
		var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
		var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
		var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
		var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
		var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
		var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
		var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
		var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
		var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
		var classComponentUpdater$2 = {
			enqueueSetState: function(inst, payload, callback) {
				var internals = inst._reactInternals;
				null === internals.queue ? warnNoop(inst, "setState") : (internals.queue.push(payload), void 0 !== callback && null !== callback && warnOnInvalidCallback(callback));
			},
			enqueueReplaceState: function(inst, payload, callback) {
				inst = inst._reactInternals;
				inst.replace = !0;
				inst.queue = [payload];
				void 0 !== callback && null !== callback && warnOnInvalidCallback(callback);
			},
			enqueueForceUpdate: function(inst, callback) {
				null === inst._reactInternals.queue ? warnNoop(inst, "forceUpdate") : void 0 !== callback && null !== callback && warnOnInvalidCallback(callback);
			}
		}, emptyTreeContext$2 = {
			id: 1,
			overflow: ""
		}, clz32$2 = Math.clz32 ? Math.clz32 : clz32Fallback$2, log$2 = Math.log, LN2$2 = Math.LN2, SuspenseException$2 = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."), suspendedThenable$2 = null, objectIs$2 = "function" === typeof Object.is ? Object.is : is$2, currentlyRenderingComponent$2 = null, currentlyRenderingTask$2 = null, currentlyRenderingRequest$2 = null, currentlyRenderingKeyPath$2 = null, firstWorkInProgressHook$2 = null, workInProgressHook$2 = null, isReRender$2 = !1, didScheduleRenderPhaseUpdate$2 = !1, localIdCounter$2 = 0, actionStateCounter$2 = 0, actionStateMatchingIndex$2 = -1, thenableIndexCounter$2 = 0, thenableState$2 = null, renderPhaseUpdates$2 = null, numberOfReRenders$2 = 0, isInHookUserCodeInDev = !1, currentHookNameInDev, HooksDispatcher$2 = {
			readContext,
			use: function(usable) {
				if (null !== usable && "object" === typeof usable) {
					if ("function" === typeof usable.then) return unwrapThenable$2(usable);
					if (usable.$$typeof === REACT_CONTEXT_TYPE$2) return readContext(usable);
				}
				throw Error("An unsupported type was passed to use(): " + String(usable));
			},
			useContext: function(context) {
				currentHookNameInDev = "useContext";
				resolveCurrentlyRenderingComponent$2();
				return context._currentValue;
			},
			useMemo: useMemo$2,
			useReducer: useReducer$2,
			useRef: function(initialValue) {
				currentlyRenderingComponent$2 = resolveCurrentlyRenderingComponent$2();
				workInProgressHook$2 = createWorkInProgressHook$2();
				var previousRef = workInProgressHook$2.memoizedState;
				return null === previousRef ? (initialValue = { current: initialValue }, Object.seal(initialValue), workInProgressHook$2.memoizedState = initialValue) : previousRef;
			},
			useState: function(initialState) {
				currentHookNameInDev = "useState";
				return useReducer$2(basicStateReducer$2, initialState);
			},
			useInsertionEffect: noop$2,
			useLayoutEffect: noop$2,
			useCallback: function(callback, deps) {
				return useMemo$2(function() {
					return callback;
				}, deps);
			},
			useImperativeHandle: noop$2,
			useEffect: noop$2,
			useDebugValue: noop$2,
			useDeferredValue: function(value, initialValue) {
				resolveCurrentlyRenderingComponent$2();
				return void 0 !== initialValue ? initialValue : value;
			},
			useTransition: function() {
				resolveCurrentlyRenderingComponent$2();
				return [!1, unsupportedStartTransition$2];
			},
			useId: function() {
				var treeId = currentlyRenderingTask$2.treeContext;
				var overflow = treeId.overflow;
				treeId = treeId.id;
				treeId = (treeId & ~(1 << 32 - clz32$2(treeId) - 1)).toString(32) + overflow;
				var resumableState = currentResumableState$2;
				if (null === resumableState) throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
				overflow = localIdCounter$2++;
				treeId = "_" + resumableState.idPrefix + "R_" + treeId;
				0 < overflow && (treeId += "H" + overflow.toString(32));
				return treeId + "_";
			},
			useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
				if (void 0 === getServerSnapshot) throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
				return getServerSnapshot();
			},
			useOptimistic: function(passthrough) {
				resolveCurrentlyRenderingComponent$2();
				return [passthrough, unsupportedSetOptimisticState$2];
			},
			useActionState: useActionState$2,
			useFormState: useActionState$2,
			useHostTransitionStatus: function() {
				resolveCurrentlyRenderingComponent$2();
				return NotPending;
			},
			useMemoCache: function(size) {
				for (var data = Array(size), i = 0; i < size; i++) data[i] = REACT_MEMO_CACHE_SENTINEL$2;
				return data;
			},
			useCacheRefresh: function() {
				return unsupportedRefresh$2;
			},
			useEffectEvent: function() {
				return throwOnUseEffectEventCall$2;
			}
		}, currentResumableState$2 = null, currentTaskInDEV = null, DefaultAsyncDispatcher$2 = {
			getCacheForType: function() {
				throw Error("Not implemented.");
			},
			cacheSignal: function() {
				throw Error("Not implemented.");
			},
			getOwner: function() {
				return null === currentTaskInDEV ? null : currentTaskInDEV.componentStack;
			}
		}, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
		disabledLog.__reactDisabledLog = !0;
		var prefix$2, suffix$2, reentry$2 = !1;
		var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
		var callComponent = { react_stack_bottom_frame: function(Component, props, secondArg) {
			return Component(props, secondArg);
		} }, callComponentInDEV = callComponent.react_stack_bottom_frame.bind(callComponent), callRender = { react_stack_bottom_frame: function(instance) {
			return instance.render();
		} }, callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender), callLazyInit = { react_stack_bottom_frame: function(lazy) {
			var init = lazy._init;
			return init(lazy._payload);
		} }, callLazyInitInDEV = callLazyInit.react_stack_bottom_frame.bind(callLazyInit), lastResetTime = 0;
		if ("object" === typeof performance && "function" === typeof performance.now) {
			var localPerformance = performance;
			var getCurrentTime = function() {
				return localPerformance.now();
			};
		} else {
			var localDate = Date;
			getCurrentTime = function() {
				return localDate.now();
			};
		}
		var CLIENT_RENDERED = 4, PENDING = 0, COMPLETED = 1, FLUSHED = 2, ABORTED = 3, ERRORED = 4, POSTPONED = 5, CLOSED = 14, currentRequest$2 = null, didWarnAboutBadClass = {}, didWarnAboutContextTypes = {}, didWarnAboutContextTypeOnFunctionComponent = {}, didWarnAboutGetDerivedStateOnFunctionComponent = {}, didWarnAboutReassigningProps = !1, didWarnAboutGenerators = !1, didWarnAboutMaps = !1, flushedByteSize$2 = 0, flushingPartialBoundaries$2 = !1;
		ensureCorrectIsomorphicReactVersion$1();
		ensureCorrectIsomorphicReactVersion$1();
		exports.prerender = function(children, options) {
			return new Promise(function(resolve, reject) {
				var onHeaders = options ? options.onHeaders : void 0, onHeadersImpl;
				onHeaders && (onHeadersImpl = function(headersDescriptor) {
					onHeaders(new Headers(headersDescriptor));
				});
				var resources = createResumableState$2(options ? options.identifierPrefix : void 0, options ? options.unstable_externalRuntimeSrc : void 0, options ? options.bootstrapScriptContent : void 0, options ? options.bootstrapScripts : void 0, options ? options.bootstrapModules : void 0), request = createPrerenderRequest$1(children, resources, createRenderState$2(resources, void 0, options ? options.unstable_externalRuntimeSrc : void 0, options ? options.importMap : void 0, onHeadersImpl, options ? options.maxHeadersLength : void 0), createRootFormatContext$1(options ? options.namespaceURI : void 0), options ? options.progressiveChunkSize : void 0, options ? options.onError : void 0, function() {
					var writable, stream$2 = new ReadableStream({
						type: "bytes",
						start: function(controller) {
							writable = createFakeWritableFromReadableStreamController$2(controller);
						},
						pull: function() {
							startFlowing$2(request, writable);
						},
						cancel: function(reason) {
							request.destination = null;
							abort$2(request, reason);
						}
					}, { highWaterMark: 0 });
					stream$2 = {
						postponed: getPostponedState$1(request),
						prelude: stream$2
					};
					resolve(stream$2);
				}, void 0, void 0, reject, options ? options.onPostpone : void 0);
				if (options && options.signal) {
					var signal = options.signal;
					if (signal.aborted) abort$2(request, signal.reason);
					else {
						var listener = function() {
							abort$2(request, signal.reason);
							signal.removeEventListener("abort", listener);
						};
						signal.addEventListener("abort", listener);
					}
				}
				startWork$1(request);
			});
		};
		exports.prerenderToNodeStream = function(children, options) {
			return new Promise(function(resolve, reject) {
				var resumableState = createResumableState$2(options ? options.identifierPrefix : void 0, options ? options.unstable_externalRuntimeSrc : void 0, options ? options.bootstrapScriptContent : void 0, options ? options.bootstrapScripts : void 0, options ? options.bootstrapModules : void 0), request = createPrerenderRequest$1(children, resumableState, createRenderState$2(resumableState, void 0, options ? options.unstable_externalRuntimeSrc : void 0, options ? options.importMap : void 0, options ? options.onHeaders : void 0, options ? options.maxHeadersLength : void 0), createRootFormatContext$1(options ? options.namespaceURI : void 0), options ? options.progressiveChunkSize : void 0, options ? options.onError : void 0, function() {
					var readable = new stream$1.Readable({ read: function() {
						startFlowing$2(request, writable);
					} }), writable = createFakeWritableFromReadable$1(readable);
					readable = {
						postponed: getPostponedState$1(request),
						prelude: readable
					};
					resolve(readable);
				}, void 0, void 0, reject, options ? options.onPostpone : void 0);
				if (options && options.signal) {
					var signal = options.signal;
					if (signal.aborted) abort$2(request, signal.reason);
					else {
						var listener = function() {
							abort$2(request, signal.reason);
							signal.removeEventListener("abort", listener);
						};
						signal.addEventListener("abort", listener);
					}
				}
				startWork$1(request);
			});
		};
		exports.renderToPipeableStream = function(children, options) {
			var request = createRequestImpl$1(children, options), hasStartedFlowing = !1;
			startWork$1(request);
			return {
				pipe: function(destination) {
					if (hasStartedFlowing) throw Error("React currently only supports piping to one writable stream.");
					hasStartedFlowing = !0;
					safelyEmitEarlyPreloads$2(request, null === request.trackedPostpones ? 0 === request.pendingRootTasks : null === request.completedRootSegment ? 0 === request.pendingRootTasks : request.completedRootSegment.status !== POSTPONED);
					startFlowing$2(request, destination);
					destination.on("drain", createDrainHandler$1(destination, request));
					destination.on("error", createCancelHandler$1(request, "The destination stream errored while writing data."));
					destination.on("close", createCancelHandler$1(request, "The destination stream closed early."));
					return destination;
				},
				abort: function(reason) {
					abort$2(request, reason);
				}
			};
		};
		exports.renderToReadableStream = function(children, options) {
			return new Promise(function(resolve, reject) {
				var onFatalError, onAllReady, allReady = new Promise(function(res, rej) {
					onAllReady = res;
					onFatalError = rej;
				}), onHeaders = options ? options.onHeaders : void 0, onHeadersImpl;
				onHeaders && (onHeadersImpl = function(headersDescriptor) {
					onHeaders(new Headers(headersDescriptor));
				});
				var resumableState = createResumableState$2(options ? options.identifierPrefix : void 0, options ? options.unstable_externalRuntimeSrc : void 0, options ? options.bootstrapScriptContent : void 0, options ? options.bootstrapScripts : void 0, options ? options.bootstrapModules : void 0), request = createRequest$2(children, resumableState, createRenderState$2(resumableState, options ? options.nonce : void 0, options ? options.unstable_externalRuntimeSrc : void 0, options ? options.importMap : void 0, onHeadersImpl, options ? options.maxHeadersLength : void 0), createRootFormatContext$1(options ? options.namespaceURI : void 0), options ? options.progressiveChunkSize : void 0, options ? options.onError : void 0, onAllReady, function() {
					var writable, stream$2 = new ReadableStream({
						type: "bytes",
						start: function(controller) {
							writable = createFakeWritableFromReadableStreamController$1$1(controller);
						},
						pull: function() {
							startFlowing$2(request, writable);
						},
						cancel: function(reason) {
							request.destination = null;
							abort$2(request, reason);
						}
					}, { highWaterMark: 0 });
					stream$2.allReady = allReady;
					resolve(stream$2);
				}, function(error) {
					allReady.catch(function() {});
					reject(error);
				}, onFatalError, options ? options.onPostpone : void 0, options ? options.formState : void 0);
				if (options && options.signal) {
					var signal = options.signal;
					if (signal.aborted) abort$2(request, signal.reason);
					else {
						var listener = function() {
							abort$2(request, signal.reason);
							signal.removeEventListener("abort", listener);
						};
						signal.addEventListener("abort", listener);
					}
				}
				startWork$1(request);
			});
		};
		exports.resume = function(children, postponedState, options) {
			return new Promise(function(resolve, reject) {
				var onFatalError, onAllReady, allReady = new Promise(function(res, rej) {
					onAllReady = res;
					onFatalError = rej;
				}), request = resumeRequest$1(children, postponedState, createRenderState$2(postponedState.resumableState, options ? options.nonce : void 0, void 0, void 0, void 0, void 0), options ? options.onError : void 0, onAllReady, function() {
					var writable, stream$2 = new ReadableStream({
						type: "bytes",
						start: function(controller) {
							writable = createFakeWritableFromReadableStreamController$1$1(controller);
						},
						pull: function() {
							startFlowing$2(request, writable);
						},
						cancel: function(reason) {
							request.destination = null;
							abort$2(request, reason);
						}
					}, { highWaterMark: 0 });
					stream$2.allReady = allReady;
					resolve(stream$2);
				}, function(error) {
					allReady.catch(function() {});
					reject(error);
				}, onFatalError, options ? options.onPostpone : void 0);
				if (options && options.signal) {
					var signal = options.signal;
					if (signal.aborted) abort$2(request, signal.reason);
					else {
						var listener = function() {
							abort$2(request, signal.reason);
							signal.removeEventListener("abort", listener);
						};
						signal.addEventListener("abort", listener);
					}
				}
				startWork$1(request);
			});
		};
		exports.resumeAndPrerender = function(children, postponedState, options) {
			return new Promise(function(resolve, reject) {
				var request = resumeAndPrerenderRequest$1(children, postponedState, createRenderState$2(postponedState.resumableState, void 0, void 0, void 0, void 0, void 0), options ? options.onError : void 0, function() {
					var writable, stream$2 = new ReadableStream({
						type: "bytes",
						start: function(controller) {
							writable = createFakeWritableFromReadableStreamController$2(controller);
						},
						pull: function() {
							startFlowing$2(request, writable);
						},
						cancel: function(reason) {
							request.destination = null;
							abort$2(request, reason);
						}
					}, { highWaterMark: 0 });
					stream$2 = {
						postponed: getPostponedState$1(request),
						prelude: stream$2
					};
					resolve(stream$2);
				}, void 0, void 0, reject, options ? options.onPostpone : void 0);
				if (options && options.signal) {
					var signal = options.signal;
					if (signal.aborted) abort$2(request, signal.reason);
					else {
						var listener = function() {
							abort$2(request, signal.reason);
							signal.removeEventListener("abort", listener);
						};
						signal.addEventListener("abort", listener);
					}
				}
				startWork$1(request);
			});
		};
		exports.resumeAndPrerenderToNodeStream = function(children, postponedState, options) {
			return new Promise(function(resolve, reject) {
				var request = resumeAndPrerenderRequest$1(children, postponedState, createRenderState$2(postponedState.resumableState, void 0, void 0, void 0, void 0, void 0), options ? options.onError : void 0, function() {
					var readable = new stream$1.Readable({ read: function() {
						startFlowing$2(request, writable);
					} }), writable = createFakeWritableFromReadable$1(readable);
					readable = {
						postponed: getPostponedState$1(request),
						prelude: readable
					};
					resolve(readable);
				}, void 0, void 0, reject, options ? options.onPostpone : void 0);
				if (options && options.signal) {
					var signal = options.signal;
					if (signal.aborted) abort$2(request, signal.reason);
					else {
						var listener = function() {
							abort$2(request, signal.reason);
							signal.removeEventListener("abort", listener);
						};
						signal.addEventListener("abort", listener);
					}
				}
				startWork$1(request);
			});
		};
		exports.resumeToPipeableStream = function(children, postponedState, options) {
			var request = resumeRequestImpl$1(children, postponedState, options), hasStartedFlowing = !1;
			startWork$1(request);
			return {
				pipe: function(destination) {
					if (hasStartedFlowing) throw Error("React currently only supports piping to one writable stream.");
					hasStartedFlowing = !0;
					startFlowing$2(request, destination);
					destination.on("drain", createDrainHandler$1(destination, request));
					destination.on("error", createCancelHandler$1(request, "The destination stream errored while writing data."));
					destination.on("close", createCancelHandler$1(request, "The destination stream closed early."));
					return destination;
				},
				abort: function(reason) {
					abort$2(request, reason);
				}
			};
		};
		exports.version = "19.2.0";
	})();
}) });

//#endregion
//#region ../../node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/server.node.js
var require_server_node = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/server.node.js": ((exports) => {
	var l, s;
	if (process.env.NODE_ENV === "production") {
		l = require_react_dom_server_legacy_node_production();
		s = require_react_dom_server_node_production();
	} else {
		l = require_react_dom_server_legacy_node_development();
		s = require_react_dom_server_node_development();
	}
	exports.version = l.version;
	exports.renderToString = l.renderToString;
	exports.renderToStaticMarkup = l.renderToStaticMarkup;
	exports.renderToPipeableStream = s.renderToPipeableStream;
	exports.renderToReadableStream = s.renderToReadableStream;
	exports.resumeToPipeableStream = s.resumeToPipeableStream;
	exports.resume = s.resume;
}) });

//#endregion
//#region ../template/src/types/platforms.ts
/**
* 平台类型枚举
*/
let PlatformType = /* @__PURE__ */ function(PlatformType$1) {
	PlatformType$1["DOUYIN"] = "douyin";
	PlatformType$1["BILIBILI"] = "bilibili";
	PlatformType$1["KUAISHOU"] = "kuaishou";
	PlatformType$1["XIAOHONGSHU"] = "xiaohongshu";
	PlatformType$1["HELP"] = "help";
	PlatformType$1["OTHER"] = "other";
	return PlatformType$1;
}({});

//#endregion
//#region ../template/src/config/config-base.ts
/**
* 基础组件配置（不包含懒加载）
*/
const baseComponentConfigs = [
	{
		type: PlatformType.DOUYIN,
		name: "抖音",
		icon: "🎵",
		color: "danger",
		components: [
			{
				id: "comment",
				name: "评论列表",
				description: "抖音评论列表展示模板",
				enabled: true,
				componentPath: "platforms/douyin/Comment",
				exportName: "DouyinComment"
			},
			{
				id: "dynamic",
				name: "动态作品",
				description: "抖音动态作品展示模板",
				enabled: true,
				componentPath: "platforms/douyin/Dynamic",
				exportName: "DouyinDynamic"
			},
			{
				id: "live",
				name: "直播间",
				description: "抖音直播间信息模板",
				enabled: true,
				componentPath: "platforms/douyin/Live",
				exportName: "DouyinLive"
			},
			{
				id: "musicinfo",
				name: "音乐信息",
				description: "抖音音乐信息展示模板",
				enabled: true,
				componentPath: "platforms/douyin/MusicInfo",
				exportName: "DouyinMusicInfo"
			},
			{
				id: "user_profile",
				name: "用户主页",
				description: "抖音用户主页信息模板",
				enabled: false,
				componentPath: "platforms/douyin/UserProfile",
				exportName: "DouyinUserProfile"
			},
			{
				id: "userlist",
				name: "抖音推送列表",
				description: "抖音用户推送列表组件",
				enabled: true,
				componentPath: "platforms/douyin/UserList",
				exportName: "default"
			},
			{
				id: "videoInfo",
				name: "视频信息",
				description: "抖音视频信息展示模板",
				enabled: true,
				componentPath: "platforms/douyin/videoInfo",
				exportName: "DouyinVideoInfo"
			}
		]
	},
	{
		type: PlatformType.BILIBILI,
		name: "B站",
		icon: "📺",
		color: "primary",
		components: [
			{
				id: "comment",
				name: "评论列表",
				description: "B站视频稿件评论列表展示模板",
				enabled: true,
				componentPath: "platforms/bilibili/Comment",
				exportName: "default"
			},
			{
				id: "userlist",
				name: "B站推送列表",
				description: "B站用户推送列表组件",
				enabled: true,
				componentPath: "platforms/bilibili/UserList",
				exportName: "default"
			},
			{
				id: "bangumi",
				name: "B站番剧列表",
				description: "B站番剧列表组件",
				enabled: true,
				componentPath: "platforms/bilibili/bangumi/BangumiBilibili",
				exportName: "default"
			},
			{
				id: "dynamic/DYNAMIC_TYPE_DRAW",
				name: "图文动态",
				description: "B站图文动态展示模板",
				enabled: true,
				componentPath: "platforms/bilibili/dynamic/DYNAMIC_TYPE_DRAW",
				exportName: "BilibiliDrawDynamic"
			},
			{
				id: "dynamic/DYNAMIC_TYPE_AV",
				name: "视频动态",
				description: "B站视频动态展示模板",
				enabled: true,
				componentPath: "platforms/bilibili/dynamic/DYNAMIC_TYPE_AV",
				exportName: "BilibiliVideoDynamic"
			},
			{
				id: "dynamic/DYNAMIC_TYPE_FORWARD",
				name: "转发动态",
				description: "B站转发动态展示模板",
				enabled: true,
				componentPath: "platforms/bilibili/dynamic/DYNAMIC_TYPE_FORWARD",
				exportName: "BilibiliForwardDynamic"
			},
			{
				id: "dynamic/DYNAMIC_TYPE_LIVE_RCMD",
				name: "直播动态",
				description: "B站直播动态展示模板",
				enabled: true,
				componentPath: "platforms/bilibili/dynamic/DYNAMIC_TYPE_LIVE_RCMD",
				exportName: "BilibiliLiveDynamic"
			},
			{
				id: "dynamic/DYNAMIC_TYPE_WORD",
				name: "纯文字动态",
				description: "B站纯文字动态展示模板",
				enabled: false,
				componentPath: "platforms/bilibili/dynamic/DYNAMIC_TYPE_WORD",
				exportName: "BilibiliWordDynamic"
			},
			{
				id: "videoInfo",
				name: "视频信息",
				description: "B站视频信息展示模板",
				enabled: true,
				componentPath: "platforms/bilibili/videoInfo",
				exportName: "BilibiliVideoInfo"
			},
			{
				id: "qrcodeImg",
				name: "登录二维码",
				description: "B站登录二维码展示模板",
				enabled: true,
				componentPath: "platforms/bilibili/qrcodeImg",
				exportName: "BilibiliQrcodeImg"
			}
		]
	},
	{
		type: PlatformType.KUAISHOU,
		name: "快手",
		icon: "⚡",
		color: "warning",
		components: [{
			id: "comment",
			name: "评论列表",
			description: "快手视频评论列表展示模板",
			enabled: true,
			componentPath: "platforms/kuaishou/Comment",
			exportName: "KuaishouComment"
		}]
	},
	{
		type: PlatformType.XIAOHONGSHU,
		name: "小红书",
		icon: "⚡",
		color: "warning",
		components: [{
			id: "noteInfo",
			name: "笔记信息",
			description: "小红书笔记信息展示模板",
			enabled: true,
			componentPath: "platforms/xiaohongshu/noteInfo",
			exportName: "XiaohongshuNoteInfo"
		}, {
			id: "comment",
			name: "评论列表",
			description: "小红书评论列表展示模板",
			enabled: true,
			componentPath: "platforms/xiaohongshu/comment",
			exportName: "XiaohongshuComment"
		}]
	},
	{
		type: PlatformType.OTHER,
		name: "其他",
		icon: "❓",
		color: "secondary",
		components: [
			{
				id: "help",
				name: "帮助页面",
				description: "KKK插件帮助页面",
				enabled: true,
				componentPath: "platforms/help/Help",
				exportName: "Help"
			},
			{
				id: "handlerError",
				name: "错误页面",
				description: "KKK插件错误页面",
				enabled: true,
				componentPath: "platforms/other/handlerError",
				exportName: "handlerError"
			},
			{
				id: "changelog",
				name: "更新日志",
				description: "KKK插件更新日志",
				enabled: true,
				componentPath: "platforms/other/changelog",
				exportName: "changelog"
			}
		]
	}
];

//#endregion
//#region ../template/src/config/config.ts
/**
* 创建扩展组件配置的辅助函数
* @param baseConfig 基础组件配置
* @param extensions 扩展配置
* @returns 完整的组件配置
*/
function createComponentConfig(baseConfig, extensions = {}) {
	return {
		...baseConfig,
		...extensions
	};
}
/**
* 统一组件配置
*/
const componentConfigs = baseComponentConfigs.map((basePlatform) => {
	const platform = {
		...basePlatform,
		components: []
	};
	switch (basePlatform.type) {
		case PlatformType.DOUYIN:
			platform.components = basePlatform.components.map((baseComponent) => {
				switch (baseComponent.id) {
					case "comment": return createComponentConfig(baseComponent, {
						validateData: (data) => data && typeof data.share_url === "string",
						lazyComponent: () => import("./Comment-BNerYPHc.js").then((module$1) => ({ default: module$1.DouyinComment }))
					});
					case "dynamic": return createComponentConfig(baseComponent, {
						validateData: (data) => data && typeof data.share_url === "string",
						lazyComponent: () => import("./Dynamic-Dgj7YzRD.js").then((module$1) => ({ default: module$1.DouyinDynamic }))
					});
					case "live": return createComponentConfig(baseComponent, {
						validateData: (data) => data && typeof data.share_url === "string",
						lazyComponent: () => import("./Live-BQsMcG-6.js").then((module$1) => ({ default: module$1.DouyinLive }))
					});
					case "musicinfo": return createComponentConfig(baseComponent, {
						validateData: (data) => data && typeof data.share_url === "string",
						lazyComponent: () => import("./MusicInfo-BbBTdf2A.js").then((module$1) => ({ default: module$1.DouyinMusicInfo }))
					});
					case "user_profile": return createComponentConfig(baseComponent, { validateData: (data) => data && typeof data.share_url === "string" });
					case "userlist": return createComponentConfig(baseComponent, {
						validateData: (data) => {
							return data && Array.isArray(data.renderOpt);
						},
						lazyComponent: () => import("./UserList-CGDOc-Ii.js").then((module$1) => ({ default: module$1.default }))
					});
					case "videoInfo": return createComponentConfig(baseComponent, { lazyComponent: () => import("./videoInfo-D9paUBG7.js").then((module$1) => ({ default: module$1.DouyinVideoInfo })) });
					default: return createComponentConfig(baseComponent);
				}
			});
			break;
		case PlatformType.BILIBILI:
			platform.components = basePlatform.components.map((baseComponent) => {
				switch (baseComponent.id) {
					case "comment": return createComponentConfig(baseComponent, {
						validateData: (data) => data && typeof data.share_url === "string",
						lazyComponent: () => import("./Comment-kVO9LtRI.js").then((module$1) => ({ default: module$1.BilibiliComment }))
					});
					case "userlist": return createComponentConfig(baseComponent, {
						validateData: (data) => {
							return data && Array.isArray(data.renderOpt);
						},
						lazyComponent: () => import("./UserList-B5UPSPuZ.js").then((module$1) => ({ default: module$1.default }))
					});
					case "bangumi": return createComponentConfig(baseComponent, { lazyComponent: () => import("./bangumi-CDN8PdK_.js").then((module$1) => ({ default: module$1.default })) });
					case "dynamic/DYNAMIC_TYPE_DRAW": return createComponentConfig(baseComponent, {
						validateData: (data) => data && typeof data.share_url === "string",
						lazyComponent: () => import("./DYNAMIC_TYPE_DRAW-KrrdbEy6.js").then((module$1) => ({ default: module$1.BilibiliDrawDynamic }))
					});
					case "dynamic/DYNAMIC_TYPE_AV": return createComponentConfig(baseComponent, {
						validateData: (data) => data && typeof data.share_url === "string",
						lazyComponent: () => import("./DYNAMIC_TYPE_AV-7IoG66qw.js").then((module$1) => ({ default: module$1.BilibiliVideoDynamic }))
					});
					case "dynamic/DYNAMIC_TYPE_FORWARD": return createComponentConfig(baseComponent, {
						validateData: (data) => data && typeof data.share_url === "string",
						lazyComponent: () => import("./DYNAMIC_TYPE_FORWARD-DvqboHNE.js").then((module$1) => ({ default: module$1.BilibiliForwardDynamic }))
					});
					case "dynamic/DYNAMIC_TYPE_LIVE_RCMD": return createComponentConfig(baseComponent, {
						validateData: (data) => data && typeof data.share_url === "string",
						lazyComponent: () => import("./DYNAMIC_TYPE_LIVE_RCMD-CHgY8rmc.js").then((module$1) => ({ default: module$1.BilibiliLiveDynamic }))
					});
					case "dynamic/DYNAMIC_TYPE_WORD": return createComponentConfig(baseComponent, { validateData: (data) => data && typeof data.share_url === "string" });
					case "videoInfo": return createComponentConfig(baseComponent, {
						validateData: (data) => data && typeof data.share_url === "string",
						lazyComponent: () => import("./videoInfo-BthDgxeq.js").then((module$1) => ({ default: module$1.BilibiliVideoInfo }))
					});
					case "qrcodeImg": return createComponentConfig(baseComponent, {
						validateData: (data) => data && typeof data.share_url === "string",
						lazyComponent: () => import("./qrcodeImg-RuLD4Xmi.js").then((module$1) => ({ default: module$1.BilibiliQrcodeImg }))
					});
					default: return createComponentConfig(baseComponent);
				}
			});
			break;
		case PlatformType.KUAISHOU:
			platform.components = basePlatform.components.map((baseComponent) => {
				switch (baseComponent.id) {
					case "comment": return createComponentConfig(baseComponent, {
						validateData: (data) => data && typeof data.share_url === "string",
						lazyComponent: () => import("./Comment-CuBN7Kdw.js").then((module$1) => ({ default: module$1.KuaishouComment }))
					});
					default: return createComponentConfig(baseComponent);
				}
			});
			break;
		case PlatformType.XIAOHONGSHU:
			platform.components = basePlatform.components.map((baseComponent) => {
				switch (baseComponent.id) {
					case "noteInfo": return createComponentConfig(baseComponent, { lazyComponent: () => import("./noteInfo-B3zI2LUB.js").then((module$1) => ({ default: module$1.XiaohongshuNoteInfo })) });
					case "comment": return createComponentConfig(baseComponent, { lazyComponent: () => import("./Comment-w9M8Vo6r.js").then((module$1) => ({ default: module$1.XiaohongshuComment })) });
					default: return createComponentConfig(baseComponent);
				}
			});
			break;
		case PlatformType.OTHER:
			platform.components = basePlatform.components.map((baseComponent) => {
				switch (baseComponent.id) {
					case "help": return createComponentConfig(baseComponent, { lazyComponent: () => import("./Help-tExFaTA1.js").then((module$1) => ({ default: module$1.Help })) });
					case "handlerError": return createComponentConfig(baseComponent, { lazyComponent: () => import("./handlerError-BELtTgCS.js").then((module$1) => ({ default: module$1.handlerError })) });
					case "changelog": return createComponentConfig(baseComponent, { lazyComponent: () => import("./changelog-Bub5f_Qe.js").then((module$1) => ({ default: module$1.Changelog })) });
					default: return createComponentConfig(baseComponent);
				}
			});
			break;
		default: platform.components = basePlatform.components.map((baseComponent) => createComponentConfig(baseComponent));
	}
	return platform;
});

//#endregion
//#region ../template/src/utils/logger.ts
/**
* 日志级别枚举
*/
var LogLevel = /* @__PURE__ */ function(LogLevel$1) {
	LogLevel$1[LogLevel$1["DEBUG"] = 0] = "DEBUG";
	LogLevel$1[LogLevel$1["INFO"] = 1] = "INFO";
	LogLevel$1[LogLevel$1["WARN"] = 2] = "WARN";
	LogLevel$1[LogLevel$1["ERROR"] = 3] = "ERROR";
	LogLevel$1[LogLevel$1["MARK"] = 4] = "MARK";
	return LogLevel$1;
}(LogLevel || {});
/**
* 获取日志级别，优先使用环境变量，默认为 info
*/
const getLogLevel = () => {
	switch ((process.env.LOG_LEVEL || "info").toLowerCase()) {
		case "debug": return LogLevel.DEBUG;
		case "info": return LogLevel.INFO;
		case "warn": return LogLevel.WARN;
		case "error": return LogLevel.ERROR;
		case "mark": return LogLevel.MARK;
		default: return LogLevel.INFO;
	}
};
/**
* 检查是否应该启用调用栈
*/
const shouldEnableCallStack = () => {
	if (process.env.ENABLE_CALL_STACK !== void 0) return process.env.ENABLE_CALL_STACK === "true";
	if (process.env.NODE_ENV === "development") return true;
	if (process.env.RUNTIME === "tsx") return true;
	try {
		const stack = (/* @__PURE__ */ new Error()).stack;
		if (stack) {
			if (stack.split("\n").some((line) => line && !line.includes("node_modules") && (line.includes(".ts:") || line.includes(".js:")) && !line.includes("at Error") && !line.includes("at shouldEnableCallStack"))) return true;
		}
	} catch {}
	return false;
};
/**
* 检查是否应该启用颜色
*/
const shouldEnableColors = () => {
	if (process.env.FORCE_COLOR !== void 0) return process.env.FORCE_COLOR !== "0";
	if (process.stdout && process.stdout.isTTY) return true;
	if (process.env.CI || process.env.GITHUB_ACTIONS || process.env.GITLAB_CI) return false;
	return true;
};
/**
* 自定义日志器类
*/
var CustomLogger = class {
	enableCallStack;
	enableColors;
	chalk;
	red;
	green;
	yellow;
	blue;
	magenta;
	cyan;
	white;
	gray;
	constructor() {
		this.enableCallStack = shouldEnableCallStack();
		this.enableColors = shouldEnableColors();
		this.chalk = new Chalk({ level: this.enableColors ? 3 : 0 });
		this.red = this.chalk.red;
		this.green = this.chalk.green;
		this.yellow = this.chalk.yellow;
		this.blue = this.chalk.blue;
		this.magenta = this.chalk.magenta;
		this.cyan = this.chalk.cyan;
		this.white = this.chalk.white;
		this.gray = this.chalk.gray;
	}
	/**
	* 获取调用栈信息
	* @returns 调用点信息字符串 [文件名:行号]
	*/
	getCallSite() {
		if (!this.enableCallStack) return "";
		try {
			const stack = (/* @__PURE__ */ new Error()).stack;
			if (!stack) return "";
			const stackLines = stack.split("\n");
			let targetLine = "";
			for (let i = 1; i < stackLines.length; i++) {
				const line = stackLines[i];
				if (!line) continue;
				if (line.includes("getCallSite") || line.includes("CustomLogger.log") || line.includes("CustomLogger.debug") || line.includes("CustomLogger.info") || line.includes("CustomLogger.warn") || line.includes("CustomLogger.error") || line.includes("CustomLogger.mark")) continue;
				if (!line.includes("node_modules")) {
					targetLine = line;
					break;
				} else if (!targetLine && line.includes("node_modules")) targetLine = line;
			}
			if (!targetLine) return "";
			let match = targetLine.match(/at .+? \((.+?):(\d+):\d+\)/) || targetLine.match(/at (.+?):(\d+):\d+/);
			if (!match) return "";
			let fileName = match[1];
			const lineNumber = match[2];
			if (fileName.startsWith("file:///")) {
				fileName = fileName.replace("file:///", "");
				if (process.platform === "win32") fileName = fileName.replace(/\//g, "\\");
			} else if (fileName.startsWith("file://")) fileName = fileName.replace("file://", "");
			let relativePath = "";
			if (fileName.includes("node_modules")) {
				const nodeModulesMatch = fileName.match(/node_modules[\\\/]([^\\\/]+)[\\\/](.+)/);
				if (nodeModulesMatch) {
					const packageName = nodeModulesMatch[1];
					const packagePath = nodeModulesMatch[2];
					if (packageName === "karin-plugin-kkk" || packageName.startsWith("@")) relativePath = `${packageName}/${packagePath}`;
					else relativePath = `node_modules/${packageName}/${packagePath}`;
				} else relativePath = path.basename(fileName);
			} else {
				let currentDir = fileName;
				let monorepoRoot = "";
				while (currentDir !== path.dirname(currentDir)) {
					currentDir = path.dirname(currentDir);
					try {
						const fs$2 = __require("fs");
						if (fs$2.existsSync(path.join(currentDir, "pnpm-workspace.yaml")) || fs$2.existsSync(path.join(currentDir, "lerna.json")) || fs$2.existsSync(path.join(currentDir, "rush.json")) || fs$2.existsSync(path.join(currentDir, "package.json"))) {
							monorepoRoot = currentDir;
							break;
						}
					} catch {
						continue;
					}
				}
				if (monorepoRoot) relativePath = path.relative(monorepoRoot, fileName);
				else {
					const packagesMatch = fileName.match(/.*[\\\/]packages[\\\/](.+)/);
					if (packagesMatch) relativePath = `packages/${packagesMatch[1]}`;
					else relativePath = path.relative(process.cwd(), fileName);
				}
			}
			relativePath = relativePath.replace(/\\/g, "/");
			if (relativePath.length > 60) {
				const parts = relativePath.split("/");
				if (parts.length > 2) relativePath = `.../${parts.slice(-2).join("/")}`;
			}
			return `[${relativePath}:${lineNumber}] `;
		} catch {
			return "";
		}
	}
	/**
	* 格式化时间戳
	* @returns 格式化的时间字符串
	*/
	formatTimestamp() {
		const now = /* @__PURE__ */ new Date();
		return `${now.getHours().toString().padStart(2, "0")}:${now.getMinutes().toString().padStart(2, "0")}:${now.getSeconds().toString().padStart(2, "0")}.${now.getMilliseconds().toString().padStart(3, "0")}`;
	}
	/**
	* 输出日志
	* @param level 日志级别
	* @param levelStr 日志级别字符串
	* @param color 颜色函数
	* @param message 日志消息
	* @param args 额外参数
	*/
	log(level, levelStr, color, message, ...args) {
		if (level < getLogLevel()) return;
		const timestamp = this.formatTimestamp();
		const formattedLevel = levelStr.padEnd(4);
		const callSite = this.getCallSite();
		const basePrefix = `[kkk/template][${timestamp}][${formattedLevel}]`;
		const prefix$2 = (this.enableColors ? color(basePrefix) : basePrefix) + (callSite ? ` ${this.enableColors ? this.gray(callSite) : callSite}` : "");
		switch (level) {
			case LogLevel.ERROR:
				console.error(prefix$2, message, ...args);
				break;
			case LogLevel.WARN:
				console.warn(prefix$2, message, ...args);
				break;
			default:
				console.log(prefix$2, message, ...args);
				break;
		}
	}
	/**
	* 打印调试级别日志
	* @param message 日志消息
	* @param args 额外参数
	*/
	debug(message, ...args) {
		this.log(LogLevel.DEBUG, "DEBU", this.cyan, message, ...args);
	}
	/**
	* 打印信息级别日志
	* @param message 日志消息
	* @param args 额外参数
	*/
	info(message, ...args) {
		this.log(LogLevel.INFO, "INFO", this.green, message, ...args);
	}
	/**
	* 打印警告级别日志
	* @param message 日志消息
	* @param args 额外参数
	*/
	warn(message, ...args) {
		this.log(LogLevel.WARN, "WARN", this.yellow, message, ...args);
	}
	/**
	* 打印错误级别日志
	* @param message 日志消息
	* @param args 额外参数
	*/
	error(message, ...args) {
		this.log(LogLevel.ERROR, "ERRO", this.red, message, ...args);
	}
	/**
	* 打印标记级别日志
	* @param message 日志消息
	* @param args 额外参数
	*/
	mark(message, ...args) {
		this.log(LogLevel.MARK, "MARK", this.gray, message, ...args);
	}
};
const logger = new CustomLogger();

//#endregion
//#region ../template/src/utils/ComponentAutoRegistry.ts
/**
* 自动组件注册器类
*/
var ComponentAutoRegistry = class {
	static components = /* @__PURE__ */ new Map();
	static initialized = false;
	/**
	* 初始化组件注册器
	* 自动扫描配置文件并注册所有启用的组件
	*/
	static async initialize() {
		if (this.initialized) return;
		const cwd = process.cwd();
		logger.debug("当前环境: NODE_ENV =", process.env.NODE_ENV || "production");
		logger.debug("当前工作目录:", cwd);
		logger.debug("开始自动注册组件...");
		for (const platformConfig of componentConfigs) await this.registerPlatformComponents(platformConfig);
		this.initialized = true;
		logger.debug(`✅ 组件自动注册完成，共注册 ${this.components.size} 个组件`);
		logger.debug(`📦 已注册组件: ${Array.from(this.components.keys()).join(", ")}`);
	}
	/**
	* 注册平台下的所有组件
	* @param platformConfig 平台配置
	*/
	static async registerPlatformComponents(platformConfig) {
		for (const componentConfig of platformConfig.components) {
			if (!componentConfig.enabled) {
				logger.debug(`⏭️ 跳过未启用组件: ${platformConfig.type}:${componentConfig.id}`);
				continue;
			}
			try {
				await this.registerComponent(platformConfig.type, componentConfig);
			} catch (error) {
				logger.error(`❌ 注册组件失败: ${platformConfig.type}:${componentConfig.id}`, error);
			}
		}
	}
	/**
	* 注册单个组件
	* @param platform 平台类型
	* @param componentConfig 组件配置
	*/
	static async registerComponent(platform, componentConfig) {
		const key = `${platform}:${componentConfig.id}`;
		if (componentConfig.lazyComponent) try {
			const module$1 = await componentConfig.lazyComponent();
			this.components.set(key, {
				component: module$1.default,
				validateData: componentConfig.validateData,
				config: componentConfig
			});
			logger.debug(`📝 注册懒加载组件: ${key}`);
		} catch (error) {
			logger.error(`❌ 懒加载组件失败: ${key}`, error);
		}
		else try {
			const modulePath = `../components/${componentConfig.componentPath}`;
			const component = (await import(modulePath))[componentConfig.exportName];
			if (!component) throw new Error(`组件 ${componentConfig.exportName} 未在模块 ${modulePath} 中找到`);
			this.components.set(key, {
				component,
				validateData: componentConfig.validateData,
				config: componentConfig
			});
			logger.debug(`📝 注册动态导入组件: ${key}`);
		} catch (error) {
			logger.error(`❌ 动态导入组件失败: ${key}`, error);
		}
	}
	/**
	* 获取组件注册项
	* @param platform 平台类型
	* @param componentId 组件ID
	* @returns 组件注册项或undefined
	*/
	static get(platform, componentId) {
		const key = `${platform}:${componentId}`;
		return this.components.get(key);
	}
	/**
	* 检查组件是否已注册
	* @param platform 平台类型
	* @param componentId 组件ID
	* @returns 是否已注册
	*/
	static has(platform, componentId) {
		const key = `${platform}:${componentId}`;
		return this.components.has(key);
	}
	/**
	* 获取所有已注册的组件键
	* @returns 组件键数组
	*/
	static getAllKeys() {
		return Array.from(this.components.keys());
	}
	/**
	* 重新加载组件注册器
	* 用于开发时热更新
	*/
	static async reload() {
		this.components.clear();
		this.initialized = false;
		await this.initialize();
	}
	/**
	* 获取组件统计信息
	* @returns 组件统计信息
	*/
	static getStats() {
		const stats = {
			total: this.components.size,
			byPlatform: {}
		};
		for (const key of this.components.keys()) {
			const platform = key.split(":")[0];
			stats.byPlatform[platform] = (stats.byPlatform[platform] || 0) + 1;
		}
		return stats;
	}
};

//#endregion
//#region ../template/src/main.ts
var import_lib = /* @__PURE__ */ __toESM(require_lib(), 1);
var import_react = /* @__PURE__ */ __toESM(require_react(), 1);
var import_server_node = /* @__PURE__ */ __toESM(require_server_node(), 1);
/**
* 二维码生成器类
*/
var QRCodeGenerator = class {
	/**
	* 生成二维码SVG数据URL
	* @param url 要生成二维码的URL
	* @param useDarkTheme 是否使用深色主题
	* @param config 二维码配置
	* @returns 二维码数据URL
	*/
	static async generateDataUrl(url, useDarkTheme = false, config = {}) {
		const { width = 600, errorCorrectionLevel = "L" } = config;
		const qrCodeSvg = await import_lib.toString(url, {
			type: "svg",
			width,
			errorCorrectionLevel,
			color: {
				dark: useDarkTheme ? "#C3C3C3" : "#3A3A3A",
				light: useDarkTheme ? "#18181B" : "#FAFAFA"
			},
			margin: 0
		});
		return `data:image/svg+xml;base64,${Buffer.from(qrCodeSvg).toString("base64")}`;
	}
};
/**
* 组件渲染器工厂类
*/
var ComponentRendererFactory = class {
	/**
	* 创建组件实例
	* @param request 渲染请求
	* @param qrCodeDataUrl 二维码数据URL
	* @returns React组件元素
	*/
	static async createComponent(request, qrCodeDataUrl) {
		const { templateType, templateName } = request;
		const registryItem = ComponentAutoRegistry.get(templateType, templateName);
		if (!registryItem) throw new Error(`未找到组件配置: ${templateType}:${templateName}`);
		if (registryItem.validateData && !registryItem.validateData(request.data)) throw new Error(`数据验证失败: ${templateType}:${templateName}`);
		const props = {
			data: request.data,
			qrCodeDataUrl,
			version: request.version,
			scale: request.scale
		};
		if (templateName.includes("/")) props.subType = templateName.split("/")[1];
		return import_react.createElement(registryItem.component, props);
	}
};
/**
* 资源路径管理器类
*/
var ResourcePathManager = class {
	packageDir;
	NODE_ENV;
	constructor() {
		this.NODE_ENV = process.env.NODE_ENV || "production";
		this.packageDir = this.getPackageDir();
	}
	/**
	* 获取包目录路径
	* @returns 包目录的绝对路径
	*/
	getPackageDir() {
		const cwd = process.cwd();
		switch (this.NODE_ENV) {
			case "development":
				let currentDir = cwd;
				while (currentDir !== path.dirname(currentDir)) {
					const renderDir = path.join(currentDir, "render");
					if (existsSync(renderDir)) {
						logger.debug("开发模式：找到 render 目录:", renderDir);
						return currentDir;
					}
					currentDir = path.dirname(currentDir);
				}
				return path.join(path.dirname(cwd), "render");
			case "production":
			default: return this.getPackageDirFromImportMeta();
		}
	}
	/**
	* 通过 import.meta.url 获取 npm 包的安装目录
	* @returns npm 包的安装目录路径
	*/
	getPackageDirFromImportMeta() {
		try {
			const currentModuleUrl = import.meta.url;
			const currentModulePath = new URL(currentModuleUrl).pathname;
			const normalizedPath = process.platform === "win32" ? currentModulePath.slice(1) : currentModulePath;
			const pluginDir = this.extractPluginDirFromPnpmPath(normalizedPath);
			if (pluginDir) {
				logger.debug("从 pnpm 路径提取的插件目录:", pluginDir);
				return pluginDir;
			}
			const fallbackDir = this.findPluginDirByScanning();
			if (fallbackDir) {
				logger.debug("通过扫描找到的插件目录:", fallbackDir);
				return fallbackDir;
			}
			logger.debug(logger.yellow("无法找到插件目录，使用当前项目工作目录"));
			return process.cwd();
		} catch (error) {
			logger.error("获取 import.meta.url 失败:", error);
			return process.cwd();
		}
	}
	/**
	* 从 pnpm 路径中提取插件目录
	* @param pnpmPath pnpm 的符号链接路径
	* @returns 插件目录路径，如果无法提取则返回 null
	*/
	extractPluginDirFromPnpmPath(pnpmPath) {
		const pnpmIndex = pnpmPath.indexOf(".pnpm");
		if (pnpmIndex === -1) return null;
		const projectRoot = pnpmPath.substring(0, pnpmIndex - 14);
		logger.debug("从 pnpm 路径提取的项目根目录:", projectRoot);
		const pluginsDir = path.join(projectRoot, "plugins");
		if (!existsSync(pluginsDir)) {
			logger.debug("plugins 目录不存在:", pluginsDir);
			return null;
		}
		try {
			const pluginDirs = fs.readdirSync(pluginsDir, { withFileTypes: true }).filter((dirent) => dirent.isDirectory());
			for (const pluginDir of pluginDirs) {
				const pluginPath = path.join(pluginsDir, pluginDir.name);
				if (existsSync(path.join(pluginPath, "node_modules", "karin-plugin-kkk"))) {
					logger.debug("找到包含 karin-plugin-kkk 的插件目录:", pluginPath);
					return pluginPath;
				}
			}
		} catch (error) {
			logger.debug("扫描 plugins 目录失败:", error);
		}
		return null;
	}
	/**
	* 通过扫描当前工作目录查找插件目录
	* @returns 插件目录路径，如果找不到则返回 null
	*/
	findPluginDirByScanning() {
		const cwd = process.cwd();
		const pluginsDir = path.join(cwd, "plugins");
		if (!existsSync(pluginsDir)) {
			logger.debug("当前工作目录下没有 plugins 目录");
			return null;
		}
		try {
			const pluginDirs = fs.readdirSync(pluginsDir, { withFileTypes: true }).filter((dirent) => dirent.isDirectory());
			for (const pluginDir of pluginDirs) {
				const pluginPath = path.join(pluginsDir, pluginDir.name);
				if (existsSync(path.join(pluginPath, "node_modules", "karin-plugin-kkk"))) {
					logger.debug("通过扫描找到包含 karin-plugin-kkk 的插件目录:", pluginPath);
					return pluginPath;
				}
			}
		} catch (error) {
			logger.debug("扫描失败:", error);
		}
		return null;
	}
	/**
	* 检测当前是否运行在 Monorepo 模式
	* @returns 如果是 Monorepo 模式返回 true，否则返回 false
	*/
	isPluginMode() {
		const hasPluginsInPath = this.packageDir.includes("plugins");
		const pluginResourcesExists = fs.existsSync(path.join(this.packageDir, "resources"));
		const npmPackageExists = fs.existsSync(path.join(this.packageDir, "node_modules", "karin-plugin-kkk"));
		return hasPluginsInPath && pluginResourcesExists && npmPackageExists;
	}
	/**
	* 获取静态资源路径配置
	* @returns 静态资源路径配置对象
	*/
	getResourcePaths() {
		switch (this.NODE_ENV) {
			case "development": return {
				cssDir: path.join(path.dirname(this.packageDir), "core", "lib"),
				imageDir: path.join(path.dirname(this.packageDir), "core/resources/image")
			};
			case "production":
			default: if (this.isPluginMode()) return {
				cssDir: fs.existsSync(path.join(this.packageDir, "node_modules", "karin-plugin-kkk", "lib")) ? path.join(this.packageDir, "node_modules", "karin-plugin-kkk", "lib") : path.join(this.packageDir, "lib"),
				imageDir: path.join(this.packageDir, "resources", "image")
			};
			else return {
				cssDir: path.join(this.packageDir, "node_modules", "karin-plugin-kkk", "lib"),
				imageDir: path.join(this.packageDir, "node_modules", "karin-plugin-kkk", "resources", "image")
			};
		}
	}
};
/**
* HTML包装器类
*/
var HtmlWrapper = class {
	resourceManager;
	constructor(resourceManager) {
		this.resourceManager = resourceManager;
	}
	wrapContent(htmlContent, htmlFilePath, isDark = false) {
		const htmlDir = path.dirname(htmlFilePath);
		const { cssDir, imageDir } = this.resourceManager.getResourcePaths();
		const cssRelativePath = path.relative(htmlDir, cssDir).replace(/\\/g, "/");
		const imageRelativePath = path.relative(htmlDir, imageDir).replace(/\\/g, "/");
		const cssUrl = path.join(cssRelativePath, "karin-plugin-kkk.css").replace(/\\/g, "/");
		const processedHtml = htmlContent.replace(/src="\/image\//g, `src="${imageRelativePath}/`);
		return `
    <!DOCTYPE html>
    <html lang="zh-CN">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width">
      <link rel="stylesheet" href="${cssUrl}">
    </head>
    <body class="${isDark ? "dark" : ""}">
      ${processedHtml}
    </body>
    </html>
    `;
	}
};
/**
* SSR渲染类
*/
var SSRRender = class {
	outputDir;
	cssContent = "";
	resourceManager;
	htmlWrapper;
	constructor() {
		this.resourceManager = new ResourcePathManager();
		this.htmlWrapper = new HtmlWrapper(this.resourceManager);
		this.outputDir = "";
		this.loadCssContent();
	}
	/**
	* 加载CSS内容到内存中
	*/
	loadCssContent() {
		try {
			const { cssDir } = this.resourceManager.getResourcePaths();
			const cssPath = path.join(cssDir, "karin-plugin-kkk.css");
			if (existsSync(cssPath)) this.cssContent = fs.readFileSync(cssPath, "utf-8");
			else {
				logger.warn("⚠️ CSS文件未找到:", cssPath);
				const fallbackPath = path.join(this.resourceManager["packageDir"], "dist/css/main.css");
				if (existsSync(fallbackPath)) {
					this.cssContent = fs.readFileSync(fallbackPath, "utf-8");
					logger.debug("✅ 从后备路径加载CSS:", fallbackPath);
				}
			}
		} catch (error) {
			logger.error("❌ 加载CSS内容失败:", error);
		}
	}
	/**
	* SSR渲染组件为HTML字符串
	* @param request 渲染请求参数
	* @returns 渲染结果
	*/
	async renderComponent(request) {
		try {
			logger.debug("[SSR]开始渲染组件，预设模板:", `${logger.yellow(`${request.templateType}/`)}${request.templateName}`);
			const qrCodeDataUrl = await QRCodeGenerator.generateDataUrl(request.data.share_url || "https://github.com/ikenxuan/karin-plugin-kkk", request.data.useDarkTheme || false);
			const htmlContent = (0, import_server_node.renderToString)(await ComponentRendererFactory.createComponent(request, qrCodeDataUrl));
			const safeTemplateName = request.templateName.replace(/\//g, "_");
			const fileName = `${request.templateType}_${safeTemplateName}_${Date.now()}.html`;
			const filePath = path.join(this.outputDir, fileName);
			writeFileSync(filePath, this.htmlWrapper.wrapContent(htmlContent, filePath, request.data.useDarkTheme || false), "utf-8");
			return {
				success: true,
				htmlPath: filePath
			};
		} catch (error) {
			logger.error("❌ 渲染组件失败:", error);
			return {
				success: false,
				htmlPath: "",
				error: error instanceof Error ? error.message : String(error)
			};
		}
	}
	/**
	* 重新加载CSS内容（用于开发时热更新）
	*/
	reloadCss() {
		this.loadCssContent();
	}
	/**
	* 启动服务
	*/
	async start() {
		await ComponentAutoRegistry.initialize();
		const stats = ComponentAutoRegistry.getStats();
		logger.debug(`📁 HTML输出目录: ${this.outputDir}`);
		logger.debug(`🎨 CSS文件状态: ${this.cssContent ? "已加载" : "未加载"}`);
		logger.debug(`📦 已注册组件总数: ${stats.total}`);
		logger.debug("📊 各平台组件数量:", stats.byPlatform);
		logger.debug(`🔧 已注册组件: ${ComponentAutoRegistry.getAllKeys().join(", ")}`);
	}
	/**
	* 渲染组件
	* @param request 渲染请求参数
	* @returns 渲染结果
	*/
	async render(request) {
		return this.renderComponent(request);
	}
};
/**
* SSR预渲染组件为HTML的具体实现
* @param request 渲染请求参数
* @param outputDir 输出目录路径
* @returns 渲染结果Promise
*/
const reactServerRender = async (request, outputDir) => {
	if (!existsSync(outputDir)) mkdirSync(outputDir, { recursive: true });
	await ComponentAutoRegistry.initialize();
	const tempServer = new SSRRender();
	tempServer["outputDir"] = outputDir;
	return await tempServer.render(request);
};

//#endregion
//#region ../template/src/index.ts
var src_default = reactServerRender;

//#endregion
export { Chalk, reactServerRender, src_default };