import { __commonJS, __export, __require, __toESM } from "./react-tSI5bnDQ.js";
import { Chalk, src_default } from "./src-CM898wRa.js";
import { Root } from "../root-BijQeroW.js";
import path, { join } from "node:path";
import fs from "fs";
import require$$14 from "util";
import require$$1$1 from "os";
import path$1 from "path";
import URL2, { fileURLToPath } from "url";
import require$$0$1 from "constants";
import require$$13, { Readable } from "stream";
import require$$5 from "assert";
import require$$2 from "zlib";
import require$$1$3 from "net";
import http from "http";
import https from "https";
import crypto, { createHash } from "crypto";
import { EventEmitter } from "events";
import require$$0$4 from "buffer";
import require$$1$1$1 from "string_decoder";
import require$$4$1 from "node:zlib";
import require$$1$5 from "node:events";
import fs$1 from "node:fs";
import require$$2$2 from "node:http";
import require$$6$1 from "querystring";
import require$$1$4 from "node:net";
import karin, { common, copyConfigSync, createNotFoundResponse, ffmpeg, ffprobe, filesByExt, karinPathHtml, logger, render, requireFileSync, segment, watch } from "node-karin";
import { karinPathBase, karinPathTemp } from "node-karin/root";
import sqlite3 from "node-karin/sqlite3";
import YAML from "node-karin/yaml";
import axios, { AxiosError } from "node-karin/axios";
import { pipeline } from "stream/promises";

//#region ../../node_modules/.pnpm/@karinjs+log4js@1.1.4/node_modules/@karinjs/log4js/dist/log4js.js
function _mergeNamespaces$1(n, m$1) {
	for (var i = 0; i < m$1.length; i++) {
		const e = m$1[i];
		if (typeof e !== "string" && !Array.isArray(e)) {
			for (const k in e) if (k !== "default" && !(k in n)) {
				const d$1 = Object.getOwnPropertyDescriptor(e, k);
				if (d$1) Object.defineProperty(n, k, d$1.get ? d$1 : {
					enumerable: true,
					get: () => e[k]
				});
			}
		}
	}
	return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var browser$2 = { exports: {} };
var ms$1;
var hasRequiredMs$1;
function requireMs$1() {
	if (hasRequiredMs$1) return ms$1;
	hasRequiredMs$1 = 1;
	var s$1 = 1e3;
	var m$1 = s$1 * 60;
	var h$1 = m$1 * 60;
	var d$1 = h$1 * 24;
	var w$1 = d$1 * 7;
	var y$1 = d$1 * 365.25;
	ms$1 = function(val, options) {
		options = options || {};
		var type$1 = typeof val;
		if (type$1 === "string" && val.length > 0) return parse$4(val);
		else if (type$1 === "number" && isFinite(val)) return options.long ? fmtLong$1(val) : fmtShort$1(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	function parse$4(str) {
		str = String(str);
		if (str.length > 100) return;
		var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
		if (!match) return;
		var n = parseFloat(match[1]);
		switch ((match[2] || "ms").toLowerCase()) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n * y$1;
			case "weeks":
			case "week":
			case "w": return n * w$1;
			case "days":
			case "day":
			case "d": return n * d$1;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n * h$1;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n * m$1;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n * s$1;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n;
			default: return;
		}
	}
	function fmtShort$1(ms2) {
		var msAbs = Math.abs(ms2);
		if (msAbs >= d$1) return Math.round(ms2 / d$1) + "d";
		if (msAbs >= h$1) return Math.round(ms2 / h$1) + "h";
		if (msAbs >= m$1) return Math.round(ms2 / m$1) + "m";
		if (msAbs >= s$1) return Math.round(ms2 / s$1) + "s";
		return ms2 + "ms";
	}
	function fmtLong$1(ms2) {
		var msAbs = Math.abs(ms2);
		if (msAbs >= d$1) return plural$1(ms2, msAbs, d$1, "day");
		if (msAbs >= h$1) return plural$1(ms2, msAbs, h$1, "hour");
		if (msAbs >= m$1) return plural$1(ms2, msAbs, m$1, "minute");
		if (msAbs >= s$1) return plural$1(ms2, msAbs, s$1, "second");
		return ms2 + " ms";
	}
	function plural$1(ms2, msAbs, n, name) {
		var isPlural = msAbs >= n * 1.5;
		return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
	}
	return ms$1;
}
var common$2;
var hasRequiredCommon$1;
function requireCommon$1() {
	if (hasRequiredCommon$1) return common$2;
	hasRequiredCommon$1 = 1;
	function setup$1(env$1) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = requireMs$1();
		createDebug.destroy = destroy$1;
		Object.keys(env$1).forEach((key) => {
			createDebug[key] = env$1[key];
		});
		createDebug.names = [];
		createDebug.skips = [];
		createDebug.formatters = {};
		function selectColor(namespace) {
			let hash = 0;
			for (let i = 0; i < namespace.length; i++) {
				hash = (hash << 5) - hash + namespace.charCodeAt(i);
				hash |= 0;
			}
			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;
			function debug$2(...args) {
				if (!debug$2.enabled) return;
				const self2 = debug$2;
				const curr = Number(/* @__PURE__ */ new Date());
				self2.diff = curr - (prevTime || curr);
				self2.prev = prevTime;
				self2.curr = curr;
				prevTime = curr;
				args[0] = createDebug.coerce(args[0]);
				if (typeof args[0] !== "string") args.unshift("%O");
				let index$1 = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					if (match === "%%") return "%";
					index$1++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === "function") {
						const val = args[index$1];
						match = formatter.call(self2, val);
						args.splice(index$1, 1);
						index$1--;
					}
					return match;
				});
				createDebug.formatArgs.call(self2, args);
				(self2.log || createDebug.log).apply(self2, args);
			}
			debug$2.namespace = namespace;
			debug$2.useColors = createDebug.useColors();
			debug$2.color = createDebug.selectColor(namespace);
			debug$2.extend = extend$2;
			debug$2.destroy = createDebug.destroy;
			Object.defineProperty(debug$2, "enabled", {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) return enableOverride;
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}
					return enabledCache;
				},
				set: (v) => {
					enableOverride = v;
				}
			});
			if (typeof createDebug.init === "function") createDebug.init(debug$2);
			return debug$2;
		}
		function extend$2(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;
			createDebug.names = [];
			createDebug.skips = [];
			const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
			for (const ns of split) if (ns[0] === "-") createDebug.skips.push(ns.slice(1));
			else createDebug.names.push(ns);
		}
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;
			while (searchIndex < search.length) if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) if (template[templateIndex] === "*") {
				starIndex = templateIndex;
				matchIndex = searchIndex;
				templateIndex++;
			} else {
				searchIndex++;
				templateIndex++;
			}
			else if (starIndex !== -1) {
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else return false;
			while (templateIndex < template.length && template[templateIndex] === "*") templateIndex++;
			return templateIndex === template.length;
		}
		function disable() {
			const namespaces = [...createDebug.names, ...createDebug.skips.map((namespace) => "-" + namespace)].join(",");
			createDebug.enable("");
			return namespaces;
		}
		function enabled(name) {
			for (const skip of createDebug.skips) if (matchesTemplate(name, skip)) return false;
			for (const ns of createDebug.names) if (matchesTemplate(name, ns)) return true;
			return false;
		}
		function coerce(val) {
			if (val instanceof Error) return val.stack || val.message;
			return val;
		}
		function destroy$1() {
			console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
		}
		createDebug.enable(createDebug.load());
		return createDebug;
	}
	common$2 = setup$1;
	return common$2;
}
var hasRequiredBrowser$2;
function requireBrowser$2() {
	if (hasRequiredBrowser$2) return browser$2.exports;
	hasRequiredBrowser$2 = 1;
	(function(module$1, exports$1) {
		exports$1.formatArgs = formatArgs$2;
		exports$1.save = save$2;
		exports$1.load = load$2;
		exports$1.useColors = useColors$2;
		exports$1.storage = localstorage$1();
		exports$1.destroy = /* @__PURE__ */ (() => {
			let warned = false;
			return () => {
				if (!warned) {
					warned = true;
					console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
				}
			};
		})();
		exports$1.colors = [
			"#0000CC",
			"#0000FF",
			"#0033CC",
			"#0033FF",
			"#0066CC",
			"#0066FF",
			"#0099CC",
			"#0099FF",
			"#00CC00",
			"#00CC33",
			"#00CC66",
			"#00CC99",
			"#00CCCC",
			"#00CCFF",
			"#3300CC",
			"#3300FF",
			"#3333CC",
			"#3333FF",
			"#3366CC",
			"#3366FF",
			"#3399CC",
			"#3399FF",
			"#33CC00",
			"#33CC33",
			"#33CC66",
			"#33CC99",
			"#33CCCC",
			"#33CCFF",
			"#6600CC",
			"#6600FF",
			"#6633CC",
			"#6633FF",
			"#66CC00",
			"#66CC33",
			"#9900CC",
			"#9900FF",
			"#9933CC",
			"#9933FF",
			"#99CC00",
			"#99CC33",
			"#CC0000",
			"#CC0033",
			"#CC0066",
			"#CC0099",
			"#CC00CC",
			"#CC00FF",
			"#CC3300",
			"#CC3333",
			"#CC3366",
			"#CC3399",
			"#CC33CC",
			"#CC33FF",
			"#CC6600",
			"#CC6633",
			"#CC9900",
			"#CC9933",
			"#CCCC00",
			"#CCCC33",
			"#FF0000",
			"#FF0033",
			"#FF0066",
			"#FF0099",
			"#FF00CC",
			"#FF00FF",
			"#FF3300",
			"#FF3333",
			"#FF3366",
			"#FF3399",
			"#FF33CC",
			"#FF33FF",
			"#FF6600",
			"#FF6633",
			"#FF9900",
			"#FF9933",
			"#FFCC00",
			"#FFCC33"
		];
		function useColors$2() {
			if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
			if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
			let m$1;
			return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m$1 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m$1[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
		}
		function formatArgs$2(args) {
			args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module$1.exports.humanize(this.diff);
			if (!this.useColors) return;
			const c = "color: " + this.color;
			args.splice(1, 0, c, "color: inherit");
			let index$1 = 0;
			let lastC = 0;
			args[0].replace(/%[a-zA-Z%]/g, (match) => {
				if (match === "%%") return;
				index$1++;
				if (match === "%c") lastC = index$1;
			});
			args.splice(lastC, 0, c);
		}
		exports$1.log = console.debug || console.log || (() => {});
		function save$2(namespaces) {
			try {
				if (namespaces) exports$1.storage.setItem("debug", namespaces);
				else exports$1.storage.removeItem("debug");
			} catch (error) {}
		}
		function load$2() {
			let r;
			try {
				r = exports$1.storage.getItem("debug");
			} catch (error) {}
			if (!r && typeof process !== "undefined" && "env" in process) r = process.env.DEBUG;
			return r;
		}
		function localstorage$1() {
			try {
				return localStorage;
			} catch (error) {}
		}
		module$1.exports = requireCommon$1()(exports$1);
		const { formatters: formatters$2 } = module$1.exports;
		formatters$2.j = function(v) {
			try {
				return JSON.stringify(v);
			} catch (error) {
				return "[UnexpectedJSONParseError]: " + error.message;
			}
		};
	})(browser$2, browser$2.exports);
	return browser$2.exports;
}
var rfdc_1;
var hasRequiredRfdc;
function requireRfdc() {
	if (hasRequiredRfdc) return rfdc_1;
	hasRequiredRfdc = 1;
	rfdc_1 = rfdc;
	function copyBuffer(cur) {
		if (cur instanceof Buffer) return Buffer.from(cur);
		return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
	}
	function rfdc(opts) {
		opts = opts || {};
		if (opts.circles) return rfdcCircles(opts);
		const constructorHandlers = /* @__PURE__ */ new Map();
		constructorHandlers.set(Date, (o) => new Date(o));
		constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
		constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
		if (opts.constructorHandlers) for (const handler2 of opts.constructorHandlers) constructorHandlers.set(handler2[0], handler2[1]);
		let handler = null;
		return opts.proto ? cloneProto : clone$1;
		function cloneArray(a, fn) {
			const keys = Object.keys(a);
			const a2 = new Array(keys.length);
			for (let i = 0; i < keys.length; i++) {
				const k = keys[i];
				const cur = a[k];
				if (typeof cur !== "object" || cur === null) a2[k] = cur;
				else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) a2[k] = handler(cur, fn);
				else if (ArrayBuffer.isView(cur)) a2[k] = copyBuffer(cur);
				else a2[k] = fn(cur);
			}
			return a2;
		}
		function clone$1(o) {
			if (typeof o !== "object" || o === null) return o;
			if (Array.isArray(o)) return cloneArray(o, clone$1);
			if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) return handler(o, clone$1);
			const o2 = {};
			for (const k in o) {
				if (Object.hasOwnProperty.call(o, k) === false) continue;
				const cur = o[k];
				if (typeof cur !== "object" || cur === null) o2[k] = cur;
				else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) o2[k] = handler(cur, clone$1);
				else if (ArrayBuffer.isView(cur)) o2[k] = copyBuffer(cur);
				else o2[k] = clone$1(cur);
			}
			return o2;
		}
		function cloneProto(o) {
			if (typeof o !== "object" || o === null) return o;
			if (Array.isArray(o)) return cloneArray(o, cloneProto);
			if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) return handler(o, cloneProto);
			const o2 = {};
			for (const k in o) {
				const cur = o[k];
				if (typeof cur !== "object" || cur === null) o2[k] = cur;
				else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) o2[k] = handler(cur, cloneProto);
				else if (ArrayBuffer.isView(cur)) o2[k] = copyBuffer(cur);
				else o2[k] = cloneProto(cur);
			}
			return o2;
		}
	}
	function rfdcCircles(opts) {
		const refs = [];
		const refsNew = [];
		const constructorHandlers = /* @__PURE__ */ new Map();
		constructorHandlers.set(Date, (o) => new Date(o));
		constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
		constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
		if (opts.constructorHandlers) for (const handler2 of opts.constructorHandlers) constructorHandlers.set(handler2[0], handler2[1]);
		let handler = null;
		return opts.proto ? cloneProto : clone$1;
		function cloneArray(a, fn) {
			const keys = Object.keys(a);
			const a2 = new Array(keys.length);
			for (let i = 0; i < keys.length; i++) {
				const k = keys[i];
				const cur = a[k];
				if (typeof cur !== "object" || cur === null) a2[k] = cur;
				else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) a2[k] = handler(cur, fn);
				else if (ArrayBuffer.isView(cur)) a2[k] = copyBuffer(cur);
				else {
					const index$1 = refs.indexOf(cur);
					if (index$1 !== -1) a2[k] = refsNew[index$1];
					else a2[k] = fn(cur);
				}
			}
			return a2;
		}
		function clone$1(o) {
			if (typeof o !== "object" || o === null) return o;
			if (Array.isArray(o)) return cloneArray(o, clone$1);
			if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) return handler(o, clone$1);
			const o2 = {};
			refs.push(o);
			refsNew.push(o2);
			for (const k in o) {
				if (Object.hasOwnProperty.call(o, k) === false) continue;
				const cur = o[k];
				if (typeof cur !== "object" || cur === null) o2[k] = cur;
				else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) o2[k] = handler(cur, clone$1);
				else if (ArrayBuffer.isView(cur)) o2[k] = copyBuffer(cur);
				else {
					const i = refs.indexOf(cur);
					if (i !== -1) o2[k] = refsNew[i];
					else o2[k] = clone$1(cur);
				}
			}
			refs.pop();
			refsNew.pop();
			return o2;
		}
		function cloneProto(o) {
			if (typeof o !== "object" || o === null) return o;
			if (Array.isArray(o)) return cloneArray(o, cloneProto);
			if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) return handler(o, cloneProto);
			const o2 = {};
			refs.push(o);
			refsNew.push(o2);
			for (const k in o) {
				const cur = o[k];
				if (typeof cur !== "object" || cur === null) o2[k] = cur;
				else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) o2[k] = handler(cur, cloneProto);
				else if (ArrayBuffer.isView(cur)) o2[k] = copyBuffer(cur);
				else {
					const i = refs.indexOf(cur);
					if (i !== -1) o2[k] = refsNew[i];
					else o2[k] = cloneProto(cur);
				}
			}
			refs.pop();
			refsNew.pop();
			return o2;
		}
	}
	return rfdc_1;
}
var configuration;
var hasRequiredConfiguration;
function requireConfiguration() {
	if (hasRequiredConfiguration) return configuration;
	hasRequiredConfiguration = 1;
	const util$4 = require$$14;
	const debug$2 = requireBrowser$2()("log4js:configuration");
	const preProcessingListeners = [];
	const listeners = [];
	const not = (thing) => !thing;
	const anObject = (thing) => thing && typeof thing === "object" && !Array.isArray(thing);
	const validIdentifier = (thing) => /^[A-Za-z][A-Za-z0-9_]*$/g.test(thing);
	const anInteger = (thing) => thing && typeof thing === "number" && Number.isInteger(thing);
	const addListener = (fn) => {
		listeners.push(fn);
		debug$2(`Added listener, now ${listeners.length} listeners`);
	};
	const addPreProcessingListener = (fn) => {
		preProcessingListeners.push(fn);
		debug$2(`Added pre-processing listener, now ${preProcessingListeners.length} listeners`);
	};
	const throwExceptionIf = (config$2, checks, message) => {
		(Array.isArray(checks) ? checks : [checks]).forEach((test$1) => {
			if (test$1) throw new Error(`Problem with log4js configuration: (${util$4.inspect(config$2, { depth: 5 })}) - ${message}`);
		});
	};
	const configure2 = (candidate) => {
		debug$2("New configuration to be validated: ", candidate);
		throwExceptionIf(candidate, not(anObject(candidate)), "must be an object.");
		debug$2(`Calling pre-processing listeners (${preProcessingListeners.length})`);
		preProcessingListeners.forEach((listener) => listener(candidate));
		debug$2("Configuration pre-processing finished.");
		debug$2(`Calling configuration listeners (${listeners.length})`);
		listeners.forEach((listener) => listener(candidate));
		debug$2("Configuration finished.");
	};
	configuration = {
		configure: configure2,
		addListener,
		addPreProcessingListener,
		throwExceptionIf,
		anObject,
		anInteger,
		validIdentifier,
		not
	};
	return configuration;
}
var lib$2 = { exports: {} };
var hasRequiredLib$2;
function requireLib$2() {
	if (hasRequiredLib$2) return lib$2.exports;
	hasRequiredLib$2 = 1;
	(function(module$1) {
		function padWithZeros(vNumber, width) {
			var numAsString = vNumber.toString();
			while (numAsString.length < width) numAsString = "0" + numAsString;
			return numAsString;
		}
		function addZero(vNumber) {
			return padWithZeros(vNumber, 2);
		}
		function offset(timezoneOffset) {
			var os$1 = Math.abs(timezoneOffset);
			var h$1 = String(Math.floor(os$1 / 60));
			var m$1 = String(os$1 % 60);
			h$1 = ("0" + h$1).slice(-2);
			m$1 = ("0" + m$1).slice(-2);
			return timezoneOffset === 0 ? "Z" : (timezoneOffset < 0 ? "+" : "-") + h$1 + ":" + m$1;
		}
		function asString(format, date$2) {
			if (typeof format !== "string") {
				date$2 = format;
				format = module$1.exports.ISO8601_FORMAT;
			}
			if (!date$2) date$2 = module$1.exports.now();
			var vDay = addZero(date$2.getDate());
			var vMonth = addZero(date$2.getMonth() + 1);
			var vYearLong = addZero(date$2.getFullYear());
			var vYearShort = addZero(vYearLong.substring(2, 4));
			var vYear = format.indexOf("yyyy") > -1 ? vYearLong : vYearShort;
			var vHour = addZero(date$2.getHours());
			var vMinute = addZero(date$2.getMinutes());
			var vSecond = addZero(date$2.getSeconds());
			var vMillisecond = padWithZeros(date$2.getMilliseconds(), 3);
			var vTimeZone = offset(date$2.getTimezoneOffset());
			return format.replace(/dd/g, vDay).replace(/MM/g, vMonth).replace(/y{1,4}/g, vYear).replace(/hh/g, vHour).replace(/mm/g, vMinute).replace(/ss/g, vSecond).replace(/SSS/g, vMillisecond).replace(/O/g, vTimeZone);
		}
		function setDatePart(date$2, part, value, local) {
			date$2["set" + (local ? "" : "UTC") + part](value);
		}
		function extractDateParts(pattern, str, missingValuesDate) {
			var local = pattern.indexOf("O") < 0;
			var monthOverflow = false;
			var matchers = [
				{
					pattern: /y{1,4}/,
					regexp: "\\d{1,4}",
					fn: function(date2, value) {
						setDatePart(date2, "FullYear", value, local);
					}
				},
				{
					pattern: /MM/,
					regexp: "\\d{1,2}",
					fn: function(date2, value) {
						setDatePart(date2, "Month", value - 1, local);
						if (date2.getMonth() !== value - 1) monthOverflow = true;
					}
				},
				{
					pattern: /dd/,
					regexp: "\\d{1,2}",
					fn: function(date2, value) {
						if (monthOverflow) setDatePart(date2, "Month", date2.getMonth() - 1, local);
						setDatePart(date2, "Date", value, local);
					}
				},
				{
					pattern: /hh/,
					regexp: "\\d{1,2}",
					fn: function(date2, value) {
						setDatePart(date2, "Hours", value, local);
					}
				},
				{
					pattern: /mm/,
					regexp: "\\d\\d",
					fn: function(date2, value) {
						setDatePart(date2, "Minutes", value, local);
					}
				},
				{
					pattern: /ss/,
					regexp: "\\d\\d",
					fn: function(date2, value) {
						setDatePart(date2, "Seconds", value, local);
					}
				},
				{
					pattern: /SSS/,
					regexp: "\\d\\d\\d",
					fn: function(date2, value) {
						setDatePart(date2, "Milliseconds", value, local);
					}
				},
				{
					pattern: /O/,
					regexp: "[+-]\\d{1,2}:?\\d{2}?|Z",
					fn: function(date2, value) {
						if (value === "Z") value = 0;
						else value = value.replace(":", "");
						var offset2 = Math.abs(value);
						var timezoneOffset = (value > 0 ? -1 : 1) * (offset2 % 100 + Math.floor(offset2 / 100) * 60);
						date2.setUTCMinutes(date2.getUTCMinutes() + timezoneOffset);
					}
				}
			];
			var parsedPattern = matchers.reduce(function(p, m$1) {
				if (m$1.pattern.test(p.regexp)) {
					m$1.index = p.regexp.match(m$1.pattern).index;
					p.regexp = p.regexp.replace(m$1.pattern, "(" + m$1.regexp + ")");
				} else m$1.index = -1;
				return p;
			}, {
				regexp: pattern,
				index: []
			});
			var dateFns = matchers.filter(function(m$1) {
				return m$1.index > -1;
			});
			dateFns.sort(function(a, b) {
				return a.index - b.index;
			});
			var matches = new RegExp(parsedPattern.regexp).exec(str);
			if (matches) {
				var date$2 = missingValuesDate || module$1.exports.now();
				dateFns.forEach(function(f, i) {
					f.fn(date$2, matches[i + 1]);
				});
				return date$2;
			}
			throw new Error("String '" + str + "' could not be parsed as '" + pattern + "'");
		}
		function parse$4(pattern, str, missingValuesDate) {
			if (!pattern) throw new Error("pattern must be supplied");
			return extractDateParts(pattern, str, missingValuesDate);
		}
		function now2() {
			return /* @__PURE__ */ new Date();
		}
		module$1.exports = asString;
		module$1.exports.asString = asString;
		module$1.exports.parse = parse$4;
		module$1.exports.now = now2;
		module$1.exports.ISO8601_FORMAT = "yyyy-MM-ddThh:mm:ss.SSS";
		module$1.exports.ISO8601_WITH_TZ_OFFSET_FORMAT = "yyyy-MM-ddThh:mm:ss.SSSO";
		module$1.exports.DATETIME_FORMAT = "dd MM yyyy hh:mm:ss.SSS";
		module$1.exports.ABSOLUTETIME_FORMAT = "hh:mm:ss.SSS";
	})(lib$2);
	return lib$2.exports;
}
var layouts;
var hasRequiredLayouts;
function requireLayouts() {
	if (hasRequiredLayouts) return layouts;
	hasRequiredLayouts = 1;
	const dateFormat = requireLib$2();
	const os$1 = require$$1$1;
	const util$4 = require$$14;
	const path$3 = path$1;
	const url$1 = URL2;
	const debug$2 = requireBrowser$2()("log4js:layouts");
	const styles = {
		bold: [1, 22],
		italic: [3, 23],
		underline: [4, 24],
		inverse: [7, 27],
		white: [37, 39],
		grey: [90, 39],
		black: [90, 39],
		blue: [34, 39],
		cyan: [36, 39],
		green: [32, 39],
		magenta: [35, 39],
		red: [91, 39],
		yellow: [33, 39]
	};
	function colorizeStart(style) {
		return style ? `\x1B[${styles[style][0]}m` : "";
	}
	function colorizeEnd(style) {
		return style ? `\x1B[${styles[style][1]}m` : "";
	}
	function colorize(str, style) {
		return colorizeStart(style) + str + colorizeEnd(style);
	}
	function timestampLevelAndCategory(loggingEvent, colour) {
		return colorize(util$4.format("[%s] [%s] %s - ", dateFormat.asString(loggingEvent.startTime), loggingEvent.level.toString(), loggingEvent.categoryName), colour);
	}
	function basicLayout(loggingEvent) {
		return timestampLevelAndCategory(loggingEvent) + util$4.format(...loggingEvent.data);
	}
	function colouredLayout(loggingEvent) {
		return timestampLevelAndCategory(loggingEvent, loggingEvent.level.colour) + util$4.format(...loggingEvent.data);
	}
	function messagePassThroughLayout(loggingEvent) {
		return util$4.format(...loggingEvent.data);
	}
	function dummyLayout(loggingEvent) {
		return loggingEvent.data[0];
	}
	function patternLayout(pattern, tokens) {
		const TTCC_CONVERSION_PATTERN = "%r %p %c - %m%n";
		const regex = /%(-?[0-9]+)?(\.?-?[0-9]+)?([[\]cdhmnprzxXyflosCMAF%])(\{([^}]+)\})?|([^%]+)/;
		pattern = pattern || TTCC_CONVERSION_PATTERN;
		function categoryName(loggingEvent, specifier) {
			let loggerName = loggingEvent.categoryName;
			if (specifier) {
				const precision = parseInt(specifier, 10);
				const loggerNameBits = loggerName.split(".");
				if (precision < loggerNameBits.length) loggerName = loggerNameBits.slice(loggerNameBits.length - precision).join(".");
			}
			return loggerName;
		}
		function formatAsDate(loggingEvent, specifier) {
			let format = dateFormat.ISO8601_FORMAT;
			if (specifier) {
				format = specifier;
				switch (format) {
					case "ISO8601":
					case "ISO8601_FORMAT":
						format = dateFormat.ISO8601_FORMAT;
						break;
					case "ISO8601_WITH_TZ_OFFSET":
					case "ISO8601_WITH_TZ_OFFSET_FORMAT":
						format = dateFormat.ISO8601_WITH_TZ_OFFSET_FORMAT;
						break;
					case "ABSOLUTE":
						process.emitWarning("Pattern %d{ABSOLUTE} is deprecated in favor of %d{ABSOLUTETIME}. Please use %d{ABSOLUTETIME} instead.", "DeprecationWarning", "log4js-node-DEP0003");
						debug$2("[log4js-node-DEP0003]", "DEPRECATION: Pattern %d{ABSOLUTE} is deprecated and replaced by %d{ABSOLUTETIME}.");
					case "ABSOLUTETIME":
					case "ABSOLUTETIME_FORMAT":
						format = dateFormat.ABSOLUTETIME_FORMAT;
						break;
					case "DATE":
						process.emitWarning("Pattern %d{DATE} is deprecated due to the confusion it causes when used. Please use %d{DATETIME} instead.", "DeprecationWarning", "log4js-node-DEP0004");
						debug$2("[log4js-node-DEP0004]", "DEPRECATION: Pattern %d{DATE} is deprecated and replaced by %d{DATETIME}.");
					case "DATETIME":
					case "DATETIME_FORMAT":
						format = dateFormat.DATETIME_FORMAT;
						break;
				}
			}
			return dateFormat.asString(format, loggingEvent.startTime);
		}
		function hostname$1() {
			return os$1.hostname().toString();
		}
		function formatMessage(loggingEvent, specifier) {
			let dataSlice = loggingEvent.data;
			if (specifier) {
				const [lowerBound, upperBound] = specifier.split(",");
				dataSlice = dataSlice.slice(lowerBound, upperBound);
			}
			return util$4.format(...dataSlice);
		}
		function endOfLine() {
			return os$1.EOL;
		}
		function logLevel(loggingEvent) {
			return loggingEvent.level.toString();
		}
		function startTime(loggingEvent) {
			return dateFormat.asString("hh:mm:ss", loggingEvent.startTime);
		}
		function startColour(loggingEvent) {
			return colorizeStart(loggingEvent.level.colour);
		}
		function endColour(loggingEvent) {
			return colorizeEnd(loggingEvent.level.colour);
		}
		function percent() {
			return "%";
		}
		function pid(loggingEvent) {
			return loggingEvent && loggingEvent.pid ? loggingEvent.pid.toString() : process.pid.toString();
		}
		function clusterInfo() {
			return pid();
		}
		function userDefined(loggingEvent, specifier) {
			if (typeof tokens[specifier] !== "undefined") return typeof tokens[specifier] === "function" ? tokens[specifier](loggingEvent) : tokens[specifier];
			return null;
		}
		function contextDefined(loggingEvent, specifier) {
			const resolver = loggingEvent.context[specifier];
			if (typeof resolver !== "undefined") return typeof resolver === "function" ? resolver(loggingEvent) : resolver;
			return null;
		}
		function fileName(loggingEvent, specifier) {
			let filename = loggingEvent.fileName || "";
			const convertFileURLToPath = function(filepath) {
				const urlPrefix = "file://";
				if (filepath.startsWith(urlPrefix)) if (typeof url$1.fileURLToPath === "function") filepath = url$1.fileURLToPath(filepath);
				else {
					filepath = path$3.normalize(filepath.replace(/* @__PURE__ */ new RegExp(`^${urlPrefix}`), ""));
					if (process.platform === "win32") if (filepath.startsWith("\\")) filepath = filepath.slice(1);
					else filepath = path$3.sep + path$3.sep + filepath;
				}
				return filepath;
			};
			filename = convertFileURLToPath(filename);
			if (specifier) {
				const fileDepth = parseInt(specifier, 10);
				const fileList = filename.split(path$3.sep);
				if (fileList.length > fileDepth) filename = fileList.slice(-fileDepth).join(path$3.sep);
			}
			return filename;
		}
		function lineNumber(loggingEvent) {
			return loggingEvent.lineNumber ? `${loggingEvent.lineNumber}` : "";
		}
		function columnNumber(loggingEvent) {
			return loggingEvent.columnNumber ? `${loggingEvent.columnNumber}` : "";
		}
		function callStack(loggingEvent) {
			return loggingEvent.callStack || "";
		}
		function className(loggingEvent) {
			return loggingEvent.className || "";
		}
		function functionName(loggingEvent) {
			return loggingEvent.functionName || "";
		}
		function functionAlias(loggingEvent) {
			return loggingEvent.functionAlias || "";
		}
		function callerName(loggingEvent) {
			return loggingEvent.callerName || "";
		}
		const replacers = {
			c: categoryName,
			d: formatAsDate,
			h: hostname$1,
			m: formatMessage,
			n: endOfLine,
			p: logLevel,
			r: startTime,
			"[": startColour,
			"]": endColour,
			y: clusterInfo,
			z: pid,
			"%": percent,
			x: userDefined,
			X: contextDefined,
			f: fileName,
			l: lineNumber,
			o: columnNumber,
			s: callStack,
			C: className,
			M: functionName,
			A: functionAlias,
			F: callerName
		};
		function replaceToken(conversionCharacter, loggingEvent, specifier) {
			return replacers[conversionCharacter](loggingEvent, specifier);
		}
		function truncate(truncation, toTruncate) {
			let len;
			if (truncation) {
				len = parseInt(truncation.slice(1), 10);
				return len > 0 ? toTruncate.slice(0, len) : toTruncate.slice(len);
			}
			return toTruncate;
		}
		function pad(padding, toPad) {
			let len;
			if (padding) if (padding.charAt(0) === "-") {
				len = parseInt(padding.slice(1), 10);
				while (toPad.length < len) toPad += " ";
			} else {
				len = parseInt(padding, 10);
				while (toPad.length < len) toPad = ` ${toPad}`;
			}
			return toPad;
		}
		function truncateAndPad(toTruncAndPad, truncation, padding) {
			let replacement = toTruncAndPad;
			replacement = truncate(truncation, replacement);
			replacement = pad(padding, replacement);
			return replacement;
		}
		return function(loggingEvent) {
			let formattedString = "";
			let result;
			let searchString = pattern;
			while ((result = regex.exec(searchString)) !== null) {
				const padding = result[1];
				const truncation = result[2];
				const conversionCharacter = result[3];
				const specifier = result[5];
				const text$1 = result[6];
				if (text$1) formattedString += text$1.toString();
				else {
					const replacement = replaceToken(conversionCharacter, loggingEvent, specifier);
					formattedString += truncateAndPad(replacement, truncation, padding);
				}
				searchString = searchString.slice(result.index + result[0].length);
			}
			return formattedString;
		};
	}
	const layoutMakers = {
		messagePassThrough() {
			return messagePassThroughLayout;
		},
		basic() {
			return basicLayout;
		},
		colored() {
			return colouredLayout;
		},
		coloured() {
			return colouredLayout;
		},
		pattern(config$2) {
			return patternLayout(config$2 && config$2.pattern, config$2 && config$2.tokens);
		},
		dummy() {
			return dummyLayout;
		}
	};
	layouts = {
		basicLayout,
		messagePassThroughLayout,
		patternLayout,
		colouredLayout,
		coloredLayout: colouredLayout,
		dummyLayout,
		addLayout(name, serializerGenerator) {
			layoutMakers[name] = serializerGenerator;
		},
		layout(name, config$2) {
			return layoutMakers[name] && layoutMakers[name](config$2);
		}
	};
	return layouts;
}
var levels;
var hasRequiredLevels;
function requireLevels() {
	if (hasRequiredLevels) return levels;
	hasRequiredLevels = 1;
	const configuration2 = requireConfiguration();
	const validColours = [
		"white",
		"grey",
		"black",
		"blue",
		"cyan",
		"green",
		"magenta",
		"red",
		"yellow"
	];
	class Level {
		constructor(level, levelStr, colour) {
			this.level = level;
			this.levelStr = levelStr;
			this.colour = colour;
		}
		toString() {
			return this.levelStr;
		}
		/**
		* converts given String to corresponding Level
		* @param {(Level|string)} sArg -- String value of Level OR Log4js.Level
		* @param {Level} [defaultLevel] -- default Level, if no String representation
		* @return {Level}
		*/
		static getLevel(sArg, defaultLevel) {
			if (!sArg) return defaultLevel;
			if (sArg instanceof Level) return sArg;
			if (sArg instanceof Object && sArg.levelStr) sArg = sArg.levelStr;
			return Level[sArg.toString().toUpperCase()] || defaultLevel;
		}
		static addLevels(customLevels) {
			if (customLevels) {
				Object.keys(customLevels).forEach((l) => {
					const levelStr = l.toUpperCase();
					Level[levelStr] = new Level(customLevels[l].value, levelStr, customLevels[l].colour);
					const existingLevelIndex = Level.levels.findIndex((lvl) => lvl.levelStr === levelStr);
					if (existingLevelIndex > -1) Level.levels[existingLevelIndex] = Level[levelStr];
					else Level.levels.push(Level[levelStr]);
				});
				Level.levels.sort((a, b) => a.level - b.level);
			}
		}
		isLessThanOrEqualTo(otherLevel) {
			if (typeof otherLevel === "string") otherLevel = Level.getLevel(otherLevel);
			return this.level <= otherLevel.level;
		}
		isGreaterThanOrEqualTo(otherLevel) {
			if (typeof otherLevel === "string") otherLevel = Level.getLevel(otherLevel);
			return this.level >= otherLevel.level;
		}
		isEqualTo(otherLevel) {
			if (typeof otherLevel === "string") otherLevel = Level.getLevel(otherLevel);
			return this.level === otherLevel.level;
		}
	}
	Level.levels = [];
	Level.addLevels({
		ALL: {
			value: Number.MIN_VALUE,
			colour: "grey"
		},
		TRACE: {
			value: 5e3,
			colour: "blue"
		},
		DEBUG: {
			value: 1e4,
			colour: "cyan"
		},
		INFO: {
			value: 2e4,
			colour: "green"
		},
		WARN: {
			value: 3e4,
			colour: "yellow"
		},
		ERROR: {
			value: 4e4,
			colour: "red"
		},
		FATAL: {
			value: 5e4,
			colour: "magenta"
		},
		MARK: {
			value: 9007199254740992,
			colour: "grey"
		},
		OFF: {
			value: Number.MAX_VALUE,
			colour: "grey"
		}
	});
	configuration2.addListener((config$2) => {
		const levelConfig = config$2.levels;
		if (levelConfig) {
			configuration2.throwExceptionIf(config$2, configuration2.not(configuration2.anObject(levelConfig)), "levels must be an object");
			Object.keys(levelConfig).forEach((l) => {
				configuration2.throwExceptionIf(config$2, configuration2.not(configuration2.validIdentifier(l)), `level name "${l}" is not a valid identifier (must start with a letter, only contain A-Z,a-z,0-9,_)`);
				configuration2.throwExceptionIf(config$2, configuration2.not(configuration2.anObject(levelConfig[l])), `level "${l}" must be an object`);
				configuration2.throwExceptionIf(config$2, configuration2.not(levelConfig[l].value), `level "${l}" must have a 'value' property`);
				configuration2.throwExceptionIf(config$2, configuration2.not(configuration2.anInteger(levelConfig[l].value)), `level "${l}".value must have an integer value`);
				configuration2.throwExceptionIf(config$2, configuration2.not(levelConfig[l].colour), `level "${l}" must have a 'colour' property`);
				configuration2.throwExceptionIf(config$2, configuration2.not(validColours.indexOf(levelConfig[l].colour) > -1), `level "${l}".colour must be one of ${validColours.join(", ")}`);
			});
		}
	});
	configuration2.addListener((config$2) => {
		Level.addLevels(config$2.levels);
	});
	levels = Level;
	return levels;
}
function commonjsRequire$1(path$3) {
	throw new Error("Could not dynamically require \"" + path$3 + "\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.");
}
var appenders = { exports: {} };
var cjs = {};
var hasRequiredCjs;
function requireCjs() {
	if (hasRequiredCjs) return cjs;
	hasRequiredCjs = 1;
	const { parse: $parse, stringify: $stringify } = JSON;
	const { keys } = Object;
	const Primitive = String;
	const primitive = "string";
	const ignore = {};
	const object$1 = "object";
	const noop$2 = (_, value) => value;
	const primitives = (value) => value instanceof Primitive ? Primitive(value) : value;
	const Primitives = (_, value) => typeof value === primitive ? new Primitive(value) : value;
	const revive = (input, parsed, output2, $) => {
		const lazy = [];
		for (let ke = keys(output2), { length } = ke, y$1 = 0; y$1 < length; y$1++) {
			const k = ke[y$1];
			const value = output2[k];
			if (value instanceof Primitive) {
				const tmp = input[value];
				if (typeof tmp === object$1 && !parsed.has(tmp)) {
					parsed.add(tmp);
					output2[k] = ignore;
					lazy.push({
						k,
						a: [
							input,
							parsed,
							tmp,
							$
						]
					});
				} else output2[k] = $.call(output2, k, tmp);
			} else if (output2[k] !== ignore) output2[k] = $.call(output2, k, value);
		}
		for (let { length } = lazy, i = 0; i < length; i++) {
			const { k, a } = lazy[i];
			output2[k] = $.call(output2, k, revive.apply(null, a));
		}
		return output2;
	};
	const set = (known, input, value) => {
		const index$1 = Primitive(input.push(value) - 1);
		known.set(value, index$1);
		return index$1;
	};
	const parse$4 = (text$1, reviver) => {
		const input = $parse(text$1, Primitives).map(primitives);
		const value = input[0];
		const $ = reviver || noop$2;
		const tmp = typeof value === object$1 && value ? revive(input, /* @__PURE__ */ new Set(), value, $) : value;
		return $.call({ "": tmp }, "", tmp);
	};
	cjs.parse = parse$4;
	const stringify = (value, replacer, space$1) => {
		const $ = replacer && typeof replacer === object$1 ? (k, v) => k === "" || -1 < replacer.indexOf(k) ? v : void 0 : replacer || noop$2;
		const known = /* @__PURE__ */ new Map();
		const input = [];
		const output2 = [];
		let i = +set(known, input, $.call({ "": value }, "", value));
		let firstRun = !i;
		while (i < input.length) {
			firstRun = true;
			output2[i] = $stringify(input[i++], replace, space$1);
		}
		return "[" + output2.join(",") + "]";
		function replace(key, value2) {
			if (firstRun) {
				firstRun = !firstRun;
				return value2;
			}
			const after = $.call(this, key, value2);
			switch (typeof after) {
				case object$1: if (after === null) return after;
				case primitive: return known.get(after) || set(known, input, after);
			}
			return after;
		}
	};
	cjs.stringify = stringify;
	const toJSON = (value) => $parse(stringify(value));
	cjs.toJSON = toJSON;
	const fromJSON = (value) => parse$4($stringify(value));
	cjs.fromJSON = fromJSON;
	return cjs;
}
var LoggingEvent_1;
var hasRequiredLoggingEvent;
function requireLoggingEvent() {
	if (hasRequiredLoggingEvent) return LoggingEvent_1;
	hasRequiredLoggingEvent = 1;
	const flatted = requireCjs();
	const levels2 = requireLevels();
	class SerDe {
		constructor() {
			this.deMap = {
				__LOG4JS_undefined__: void 0,
				__LOG4JS_NaN__: NaN,
				__LOG4JS_Infinity__: Infinity,
				"__LOG4JS_-Infinity__": -Infinity
			};
			this.serMap = {};
			Object.keys(this.deMap).forEach((key) => {
				const value = this.deMap[key];
				this.serMap[value] = key;
			});
		}
		canSerialise(key) {
			if (typeof key === "string") return false;
			return key in this.serMap;
		}
		serialise(key) {
			if (this.canSerialise(key)) return this.serMap[key];
			return key;
		}
		canDeserialise(key) {
			return key in this.deMap;
		}
		deserialise(key) {
			if (this.canDeserialise(key)) return this.deMap[key];
			return key;
		}
	}
	const serde = new SerDe();
	class LoggingEvent {
		/**
		* Models a logging event.
		* @constructor
		* @param {string} categoryName name of category
		* @param {Log4js.Level} level level of message
		* @param {Array} data objects to log
		* @param {Error} [error]
		* @author Seth Chisamore
		*/
		constructor(categoryName, level, data$1, context, location, error) {
			this.startTime = /* @__PURE__ */ new Date();
			this.categoryName = categoryName;
			this.data = data$1;
			this.level = level;
			this.context = Object.assign({}, context);
			this.pid = process.pid;
			this.error = error;
			if (typeof location !== "undefined") {
				if (!location || typeof location !== "object" || Array.isArray(location)) throw new TypeError("Invalid location type passed to LoggingEvent constructor");
				this.constructor._getLocationKeys().forEach((key) => {
					if (typeof location[key] !== "undefined") this[key] = location[key];
				});
			}
		}
		/** @private */
		static _getLocationKeys() {
			return [
				"fileName",
				"lineNumber",
				"columnNumber",
				"callStack",
				"className",
				"functionName",
				"functionAlias",
				"callerName"
			];
		}
		serialise() {
			return flatted.stringify(this, (key, value) => {
				if (value instanceof Error) value = Object.assign({
					message: value.message,
					stack: value.stack
				}, value);
				return serde.serialise(value);
			});
		}
		static deserialise(serialised) {
			let event;
			try {
				const rehydratedEvent = flatted.parse(serialised, (key, value) => {
					if (value && value.message && value.stack) {
						const fakeError = new Error(value);
						Object.keys(value).forEach((k) => {
							fakeError[k] = value[k];
						});
						value = fakeError;
					}
					return serde.deserialise(value);
				});
				this._getLocationKeys().forEach((key) => {
					if (typeof rehydratedEvent[key] !== "undefined") {
						if (!rehydratedEvent.location) rehydratedEvent.location = {};
						rehydratedEvent.location[key] = rehydratedEvent[key];
					}
				});
				event = new LoggingEvent(rehydratedEvent.categoryName, levels2.getLevel(rehydratedEvent.level.levelStr), rehydratedEvent.data, rehydratedEvent.context, rehydratedEvent.location, rehydratedEvent.error);
				event.startTime = new Date(rehydratedEvent.startTime);
				event.pid = rehydratedEvent.pid;
				if (rehydratedEvent.cluster) event.cluster = rehydratedEvent.cluster;
			} catch (e) {
				event = new LoggingEvent("log4js", levels2.ERROR, [
					"Unable to parse log:",
					serialised,
					"because: ",
					e
				]);
			}
			return event;
		}
	}
	LoggingEvent_1 = LoggingEvent;
	return LoggingEvent_1;
}
var clustering;
var hasRequiredClustering;
function requireClustering() {
	if (hasRequiredClustering) return clustering;
	hasRequiredClustering = 1;
	const debug$2 = requireBrowser$2()("log4js:clustering");
	const LoggingEvent = requireLoggingEvent();
	const configuration2 = requireConfiguration();
	let disabled = false;
	let cluster = null;
	try {
		cluster = __require("cluster");
	} catch (e) {
		debug$2("cluster module not present");
		disabled = true;
	}
	const listeners = [];
	let pm2 = false;
	let pm2InstanceVar = "NODE_APP_INSTANCE";
	const isPM2Master = () => pm2 && process.env[pm2InstanceVar] === "0";
	const isMaster = () => disabled || cluster && cluster.isMaster || isPM2Master();
	const sendToListeners = (logEvent) => {
		listeners.forEach((l) => l(logEvent));
	};
	const receiver = (worker, message) => {
		debug$2("cluster message received from worker ", worker, ": ", message);
		if (worker.topic && worker.data) {
			message = worker;
			worker = void 0;
		}
		if (message && message.topic && message.topic === "log4js:message") {
			debug$2("received message: ", message.data);
			sendToListeners(LoggingEvent.deserialise(message.data));
		}
	};
	if (!disabled) configuration2.addListener((config$2) => {
		listeners.length = 0;
		({pm2, disableClustering: disabled, pm2InstanceVar = "NODE_APP_INSTANCE"} = config$2);
		debug$2(`clustering disabled ? ${disabled}`);
		debug$2(`cluster.isMaster ? ${cluster && cluster.isMaster}`);
		debug$2(`pm2 enabled ? ${pm2}`);
		debug$2(`pm2InstanceVar = ${pm2InstanceVar}`);
		debug$2(`process.env[${pm2InstanceVar}] = ${process.env[pm2InstanceVar]}`);
		if (pm2) process.removeListener("message", receiver);
		if (cluster && cluster.removeListener) cluster.removeListener("message", receiver);
		if (disabled || config$2.disableClustering) debug$2("Not listening for cluster messages, because clustering disabled.");
		else if (isPM2Master()) {
			debug$2("listening for PM2 broadcast messages");
			process.on("message", receiver);
		} else if (cluster && cluster.isMaster) {
			debug$2("listening for cluster messages");
			cluster.on("message", receiver);
		} else debug$2("not listening for messages, because we are not a master process");
	});
	clustering = {
		onlyOnMaster: (fn, notMaster) => isMaster() ? fn() : notMaster,
		isMaster,
		send: (msg) => {
			if (isMaster()) sendToListeners(msg);
			else {
				if (!pm2) msg.cluster = {
					workerId: cluster.worker.id,
					worker: process.pid
				};
				process.send({
					topic: "log4js:message",
					data: msg.serialise()
				});
			}
		},
		onMessage: (listener) => {
			listeners.push(listener);
		}
	};
	return clustering;
}
var adapters = {};
var hasRequiredAdapters;
function requireAdapters() {
	if (hasRequiredAdapters) return adapters;
	hasRequiredAdapters = 1;
	function maxFileSizeUnitTransform(maxLogSize) {
		if (typeof maxLogSize === "number" && Number.isInteger(maxLogSize)) return maxLogSize;
		const units = {
			K: 1024,
			M: 1024 * 1024,
			G: 1024 * 1024 * 1024
		};
		const validUnit = Object.keys(units);
		const unit = maxLogSize.slice(-1).toLocaleUpperCase();
		const value = maxLogSize.slice(0, -1).trim();
		if (validUnit.indexOf(unit) < 0 || !Number.isInteger(Number(value))) throw Error(`maxLogSize: "${maxLogSize}" is invalid`);
		else return value * units[unit];
	}
	function adapter$1(configAdapter, config$2) {
		const newConfig = Object.assign({}, config$2);
		Object.keys(configAdapter).forEach((key) => {
			if (newConfig[key]) newConfig[key] = configAdapter[key](config$2[key]);
		});
		return newConfig;
	}
	function fileAppenderAdapter(config$2) {
		return adapter$1({ maxLogSize: maxFileSizeUnitTransform }, config$2);
	}
	const adapters$1 = {
		dateFile: fileAppenderAdapter,
		file: fileAppenderAdapter,
		fileSync: fileAppenderAdapter
	};
	adapters.modifyConfig = (config$2) => adapters$1[config$2.type] ? adapters$1[config$2.type](config$2) : config$2;
	return adapters;
}
var console$1 = {};
var hasRequiredConsole;
function requireConsole() {
	if (hasRequiredConsole) return console$1;
	hasRequiredConsole = 1;
	const consoleLog = console.log.bind(console);
	function consoleAppender(layout, timezoneOffset) {
		return (loggingEvent) => {
			consoleLog(layout(loggingEvent, timezoneOffset));
		};
	}
	function configure2(config$2, layouts2) {
		let layout = layouts2.colouredLayout;
		if (config$2.layout) layout = layouts2.layout(config$2.layout.type, config$2.layout);
		return consoleAppender(layout, config$2.timezoneOffset);
	}
	console$1.configure = configure2;
	return console$1;
}
var stdout = {};
var hasRequiredStdout;
function requireStdout() {
	if (hasRequiredStdout) return stdout;
	hasRequiredStdout = 1;
	function stdoutAppender(layout, timezoneOffset) {
		return (loggingEvent) => {
			process.stdout.write(`${layout(loggingEvent, timezoneOffset)}
`);
		};
	}
	function configure2(config$2, layouts2) {
		let layout = layouts2.colouredLayout;
		if (config$2.layout) layout = layouts2.layout(config$2.layout.type, config$2.layout);
		return stdoutAppender(layout, config$2.timezoneOffset);
	}
	stdout.configure = configure2;
	return stdout;
}
var stderr = {};
var hasRequiredStderr;
function requireStderr() {
	if (hasRequiredStderr) return stderr;
	hasRequiredStderr = 1;
	function stderrAppender(layout, timezoneOffset) {
		return (loggingEvent) => {
			process.stderr.write(`${layout(loggingEvent, timezoneOffset)}
`);
		};
	}
	function configure2(config$2, layouts2) {
		let layout = layouts2.colouredLayout;
		if (config$2.layout) layout = layouts2.layout(config$2.layout.type, config$2.layout);
		return stderrAppender(layout, config$2.timezoneOffset);
	}
	stderr.configure = configure2;
	return stderr;
}
var logLevelFilter = {};
var hasRequiredLogLevelFilter;
function requireLogLevelFilter() {
	if (hasRequiredLogLevelFilter) return logLevelFilter;
	hasRequiredLogLevelFilter = 1;
	function logLevelFilter$1(minLevelString, maxLevelString, appender, levels2) {
		const minLevel = levels2.getLevel(minLevelString);
		const maxLevel = levels2.getLevel(maxLevelString, levels2.FATAL);
		return (logEvent) => {
			const eventLevel = logEvent.level;
			if (minLevel.isLessThanOrEqualTo(eventLevel) && maxLevel.isGreaterThanOrEqualTo(eventLevel)) appender(logEvent);
		};
	}
	function configure2(config$2, layouts2, findAppender, levels2) {
		const appender = findAppender(config$2.appender);
		return logLevelFilter$1(config$2.level, config$2.maxLevel, appender, levels2);
	}
	logLevelFilter.configure = configure2;
	return logLevelFilter;
}
var categoryFilter = {};
var hasRequiredCategoryFilter;
function requireCategoryFilter() {
	if (hasRequiredCategoryFilter) return categoryFilter;
	hasRequiredCategoryFilter = 1;
	const debug$2 = requireBrowser$2()("log4js:categoryFilter");
	function categoryFilter$1(excludes, appender) {
		if (typeof excludes === "string") excludes = [excludes];
		return (logEvent) => {
			debug$2(`Checking ${logEvent.categoryName} against ${excludes}`);
			if (excludes.indexOf(logEvent.categoryName) === -1) {
				debug$2("Not excluded, sending to appender");
				appender(logEvent);
			}
		};
	}
	function configure2(config$2, layouts2, findAppender) {
		const appender = findAppender(config$2.appender);
		return categoryFilter$1(config$2.exclude, appender);
	}
	categoryFilter.configure = configure2;
	return categoryFilter;
}
var noLogFilter = {};
var hasRequiredNoLogFilter;
function requireNoLogFilter() {
	if (hasRequiredNoLogFilter) return noLogFilter;
	hasRequiredNoLogFilter = 1;
	const debug$2 = requireBrowser$2()("log4js:noLogFilter");
	function removeNullOrEmptyRegexp(regexp) {
		return regexp.filter((el) => el != null && el !== "");
	}
	function noLogFilter$1(filters, appender) {
		return (logEvent) => {
			debug$2(`Checking data: ${logEvent.data} against filters: ${filters}`);
			if (typeof filters === "string") filters = [filters];
			filters = removeNullOrEmptyRegexp(filters);
			const regex = new RegExp(filters.join("|"), "i");
			if (filters.length === 0 || logEvent.data.findIndex((value) => regex.test(value)) < 0) {
				debug$2("Not excluded, sending to appender");
				appender(logEvent);
			}
		};
	}
	function configure2(config$2, layouts2, findAppender) {
		const appender = findAppender(config$2.appender);
		return noLogFilter$1(config$2.exclude, appender);
	}
	noLogFilter.configure = configure2;
	return noLogFilter;
}
var file$1 = {};
var lib$1$1 = { exports: {} };
var fs$3 = {};
var universalify = {};
var hasRequiredUniversalify;
function requireUniversalify() {
	if (hasRequiredUniversalify) return universalify;
	hasRequiredUniversalify = 1;
	universalify.fromCallback = function(fn) {
		return Object.defineProperty(function() {
			if (typeof arguments[arguments.length - 1] === "function") fn.apply(this, arguments);
			else return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
					if (err) return reject(err);
					resolve(res);
				};
				arguments.length++;
				fn.apply(this, arguments);
			});
		}, "name", { value: fn.name });
	};
	universalify.fromPromise = function(fn) {
		return Object.defineProperty(function() {
			const cb = arguments[arguments.length - 1];
			if (typeof cb !== "function") return fn.apply(this, arguments);
			else fn.apply(this, arguments).then((r) => cb(null, r), cb);
		}, "name", { value: fn.name });
	};
	return universalify;
}
var polyfills;
var hasRequiredPolyfills;
function requirePolyfills() {
	if (hasRequiredPolyfills) return polyfills;
	hasRequiredPolyfills = 1;
	var constants = require$$0$1;
	var origCwd = process.cwd;
	var cwd = null;
	var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
	process.cwd = function() {
		if (!cwd) cwd = origCwd.call(process);
		return cwd;
	};
	try {
		process.cwd();
	} catch (er) {}
	if (typeof process.chdir === "function") {
		var chdir = process.chdir;
		process.chdir = function(d$1) {
			cwd = null;
			chdir.call(process, d$1);
		};
		if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
	}
	polyfills = patch;
	function patch(fs2) {
		if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) patchLchmod(fs2);
		if (!fs2.lutimes) patchLutimes(fs2);
		fs2.chown = chownFix(fs2.chown);
		fs2.fchown = chownFix(fs2.fchown);
		fs2.lchown = chownFix(fs2.lchown);
		fs2.chmod = chmodFix(fs2.chmod);
		fs2.fchmod = chmodFix(fs2.fchmod);
		fs2.lchmod = chmodFix(fs2.lchmod);
		fs2.chownSync = chownFixSync(fs2.chownSync);
		fs2.fchownSync = chownFixSync(fs2.fchownSync);
		fs2.lchownSync = chownFixSync(fs2.lchownSync);
		fs2.chmodSync = chmodFixSync(fs2.chmodSync);
		fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
		fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
		fs2.stat = statFix(fs2.stat);
		fs2.fstat = statFix(fs2.fstat);
		fs2.lstat = statFix(fs2.lstat);
		fs2.statSync = statFixSync(fs2.statSync);
		fs2.fstatSync = statFixSync(fs2.fstatSync);
		fs2.lstatSync = statFixSync(fs2.lstatSync);
		if (fs2.chmod && !fs2.lchmod) {
			fs2.lchmod = function(path$3, mode, cb) {
				if (cb) process.nextTick(cb);
			};
			fs2.lchmodSync = function() {};
		}
		if (fs2.chown && !fs2.lchown) {
			fs2.lchown = function(path$3, uid, gid, cb) {
				if (cb) process.nextTick(cb);
			};
			fs2.lchownSync = function() {};
		}
		if (platform === "win32") fs2.rename = typeof fs2.rename !== "function" ? fs2.rename : function(fs$rename) {
			function rename(from, to, cb) {
				var start = Date.now();
				var backoff = 0;
				fs$rename(from, to, function CB(er) {
					if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
						setTimeout(function() {
							fs2.stat(to, function(stater, st) {
								if (stater && stater.code === "ENOENT") fs$rename(from, to, CB);
								else cb(er);
							});
						}, backoff);
						if (backoff < 100) backoff += 10;
						return;
					}
					if (cb) cb(er);
				});
			}
			if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
			return rename;
		}(fs2.rename);
		fs2.read = typeof fs2.read !== "function" ? fs2.read : function(fs$read) {
			function read(fd, buffer2, offset, length, position, callback_) {
				var callback;
				if (callback_ && typeof callback_ === "function") {
					var eagCounter = 0;
					callback = function(er, _, __) {
						if (er && er.code === "EAGAIN" && eagCounter < 10) {
							eagCounter++;
							return fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
						}
						callback_.apply(this, arguments);
					};
				}
				return fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
			}
			if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
			return read;
		}(fs2.read);
		fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : /* @__PURE__ */ function(fs$readSync) {
			return function(fd, buffer2, offset, length, position) {
				var eagCounter = 0;
				while (true) try {
					return fs$readSync.call(fs2, fd, buffer2, offset, length, position);
				} catch (er) {
					if (er.code === "EAGAIN" && eagCounter < 10) {
						eagCounter++;
						continue;
					}
					throw er;
				}
			};
		}(fs2.readSync);
		function patchLchmod(fs3) {
			fs3.lchmod = function(path$3, mode, callback) {
				fs3.open(path$3, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
					if (err) {
						if (callback) callback(err);
						return;
					}
					fs3.fchmod(fd, mode, function(err2) {
						fs3.close(fd, function(err22) {
							if (callback) callback(err2 || err22);
						});
					});
				});
			};
			fs3.lchmodSync = function(path$3, mode) {
				var fd = fs3.openSync(path$3, constants.O_WRONLY | constants.O_SYMLINK, mode);
				var threw = true;
				var ret;
				try {
					ret = fs3.fchmodSync(fd, mode);
					threw = false;
				} finally {
					if (threw) try {
						fs3.closeSync(fd);
					} catch (er) {}
					else fs3.closeSync(fd);
				}
				return ret;
			};
		}
		function patchLutimes(fs3) {
			if (constants.hasOwnProperty("O_SYMLINK") && fs3.futimes) {
				fs3.lutimes = function(path$3, at, mt, cb) {
					fs3.open(path$3, constants.O_SYMLINK, function(er, fd) {
						if (er) {
							if (cb) cb(er);
							return;
						}
						fs3.futimes(fd, at, mt, function(er2) {
							fs3.close(fd, function(er22) {
								if (cb) cb(er2 || er22);
							});
						});
					});
				};
				fs3.lutimesSync = function(path$3, at, mt) {
					var fd = fs3.openSync(path$3, constants.O_SYMLINK);
					var ret;
					var threw = true;
					try {
						ret = fs3.futimesSync(fd, at, mt);
						threw = false;
					} finally {
						if (threw) try {
							fs3.closeSync(fd);
						} catch (er) {}
						else fs3.closeSync(fd);
					}
					return ret;
				};
			} else if (fs3.futimes) {
				fs3.lutimes = function(_a, _b, _c, cb) {
					if (cb) process.nextTick(cb);
				};
				fs3.lutimesSync = function() {};
			}
		}
		function chmodFix(orig) {
			if (!orig) return orig;
			return function(target, mode, cb) {
				return orig.call(fs2, target, mode, function(er) {
					if (chownErOk(er)) er = null;
					if (cb) cb.apply(this, arguments);
				});
			};
		}
		function chmodFixSync(orig) {
			if (!orig) return orig;
			return function(target, mode) {
				try {
					return orig.call(fs2, target, mode);
				} catch (er) {
					if (!chownErOk(er)) throw er;
				}
			};
		}
		function chownFix(orig) {
			if (!orig) return orig;
			return function(target, uid, gid, cb) {
				return orig.call(fs2, target, uid, gid, function(er) {
					if (chownErOk(er)) er = null;
					if (cb) cb.apply(this, arguments);
				});
			};
		}
		function chownFixSync(orig) {
			if (!orig) return orig;
			return function(target, uid, gid) {
				try {
					return orig.call(fs2, target, uid, gid);
				} catch (er) {
					if (!chownErOk(er)) throw er;
				}
			};
		}
		function statFix(orig) {
			if (!orig) return orig;
			return function(target, options, cb) {
				if (typeof options === "function") {
					cb = options;
					options = null;
				}
				function callback(er, stats) {
					if (stats) {
						if (stats.uid < 0) stats.uid += 4294967296;
						if (stats.gid < 0) stats.gid += 4294967296;
					}
					if (cb) cb.apply(this, arguments);
				}
				return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
			};
		}
		function statFixSync(orig) {
			if (!orig) return orig;
			return function(target, options) {
				var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
				if (stats) {
					if (stats.uid < 0) stats.uid += 4294967296;
					if (stats.gid < 0) stats.gid += 4294967296;
				}
				return stats;
			};
		}
		function chownErOk(er) {
			if (!er) return true;
			if (er.code === "ENOSYS") return true;
			if (!process.getuid || process.getuid() !== 0) {
				if (er.code === "EINVAL" || er.code === "EPERM") return true;
			}
			return false;
		}
	}
	return polyfills;
}
var legacyStreams;
var hasRequiredLegacyStreams;
function requireLegacyStreams() {
	if (hasRequiredLegacyStreams) return legacyStreams;
	hasRequiredLegacyStreams = 1;
	var Stream$3 = require$$13.Stream;
	legacyStreams = legacy;
	function legacy(fs2) {
		return {
			ReadStream,
			WriteStream
		};
		function ReadStream(path$3, options) {
			if (!(this instanceof ReadStream)) return new ReadStream(path$3, options);
			Stream$3.call(this);
			var self2 = this;
			this.path = path$3;
			this.fd = null;
			this.readable = true;
			this.paused = false;
			this.flags = "r";
			this.mode = 438;
			this.bufferSize = 64 * 1024;
			options = options || {};
			var keys = Object.keys(options);
			for (var index$1 = 0, length = keys.length; index$1 < length; index$1++) {
				var key = keys[index$1];
				this[key] = options[key];
			}
			if (this.encoding) this.setEncoding(this.encoding);
			if (this.start !== void 0) {
				if ("number" !== typeof this.start) throw TypeError("start must be a Number");
				if (this.end === void 0) this.end = Infinity;
				else if ("number" !== typeof this.end) throw TypeError("end must be a Number");
				if (this.start > this.end) throw new Error("start must be <= end");
				this.pos = this.start;
			}
			if (this.fd !== null) {
				process.nextTick(function() {
					self2._read();
				});
				return;
			}
			fs2.open(this.path, this.flags, this.mode, function(err, fd) {
				if (err) {
					self2.emit("error", err);
					self2.readable = false;
					return;
				}
				self2.fd = fd;
				self2.emit("open", fd);
				self2._read();
			});
		}
		function WriteStream(path$3, options) {
			if (!(this instanceof WriteStream)) return new WriteStream(path$3, options);
			Stream$3.call(this);
			this.path = path$3;
			this.fd = null;
			this.writable = true;
			this.flags = "w";
			this.encoding = "binary";
			this.mode = 438;
			this.bytesWritten = 0;
			options = options || {};
			var keys = Object.keys(options);
			for (var index$1 = 0, length = keys.length; index$1 < length; index$1++) {
				var key = keys[index$1];
				this[key] = options[key];
			}
			if (this.start !== void 0) {
				if ("number" !== typeof this.start) throw TypeError("start must be a Number");
				if (this.start < 0) throw new Error("start must be >= zero");
				this.pos = this.start;
			}
			this.busy = false;
			this._queue = [];
			if (this.fd === null) {
				this._open = fs2.open;
				this._queue.push([
					this._open,
					this.path,
					this.flags,
					this.mode,
					void 0
				]);
				this.flush();
			}
		}
	}
	return legacyStreams;
}
var clone_1;
var hasRequiredClone;
function requireClone() {
	if (hasRequiredClone) return clone_1;
	hasRequiredClone = 1;
	clone_1 = clone$1;
	var getPrototypeOf$1 = Object.getPrototypeOf || function(obj) {
		return obj.__proto__;
	};
	function clone$1(obj) {
		if (obj === null || typeof obj !== "object") return obj;
		if (obj instanceof Object) var copy2 = { __proto__: getPrototypeOf$1(obj) };
		else var copy2 = /* @__PURE__ */ Object.create(null);
		Object.getOwnPropertyNames(obj).forEach(function(key) {
			Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
		});
		return copy2;
	}
	return clone_1;
}
var gracefulFs;
var hasRequiredGracefulFs;
function requireGracefulFs() {
	if (hasRequiredGracefulFs) return gracefulFs;
	hasRequiredGracefulFs = 1;
	var fs2 = fs;
	var polyfills2 = requirePolyfills();
	var legacy = requireLegacyStreams();
	var clone$1 = requireClone();
	var util$4 = require$$14;
	var gracefulQueue;
	var previousSymbol;
	if (typeof Symbol === "function" && typeof Symbol.for === "function") {
		gracefulQueue = Symbol.for("graceful-fs.queue");
		previousSymbol = Symbol.for("graceful-fs.previous");
	} else {
		gracefulQueue = "___graceful-fs.queue";
		previousSymbol = "___graceful-fs.previous";
	}
	function noop$2() {}
	function publishQueue(context, queue2) {
		Object.defineProperty(context, gracefulQueue, { get: function() {
			return queue2;
		} });
	}
	var debug$2 = noop$2;
	if (util$4.debuglog) debug$2 = util$4.debuglog("gfs4");
	else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) debug$2 = function() {
		var m$1 = util$4.format.apply(util$4, arguments);
		m$1 = "GFS4: " + m$1.split(/\n/).join("\nGFS4: ");
		console.error(m$1);
	};
	if (!fs2[gracefulQueue]) {
		publishQueue(fs2, commonjsGlobal$1[gracefulQueue] || []);
		fs2.close = function(fs$close) {
			function close(fd, cb) {
				return fs$close.call(fs2, fd, function(err) {
					if (!err) resetQueue();
					if (typeof cb === "function") cb.apply(this, arguments);
				});
			}
			Object.defineProperty(close, previousSymbol, { value: fs$close });
			return close;
		}(fs2.close);
		fs2.closeSync = function(fs$closeSync) {
			function closeSync(fd) {
				fs$closeSync.apply(fs2, arguments);
				resetQueue();
			}
			Object.defineProperty(closeSync, previousSymbol, { value: fs$closeSync });
			return closeSync;
		}(fs2.closeSync);
		if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) process.on("exit", function() {
			debug$2(fs2[gracefulQueue]);
			require$$5.equal(fs2[gracefulQueue].length, 0);
		});
	}
	if (!commonjsGlobal$1[gracefulQueue]) publishQueue(commonjsGlobal$1, fs2[gracefulQueue]);
	gracefulFs = patch(clone$1(fs2));
	if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched) {
		gracefulFs = patch(fs2);
		fs2.__patched = true;
	}
	function patch(fs3) {
		polyfills2(fs3);
		fs3.gracefulify = patch;
		fs3.createReadStream = createReadStream;
		fs3.createWriteStream = createWriteStream;
		var fs$readFile = fs3.readFile;
		fs3.readFile = readFile;
		function readFile(path$3, options, cb) {
			if (typeof options === "function") cb = options, options = null;
			return go$readFile(path$3, options, cb);
			function go$readFile(path2, options2, cb2, startTime) {
				return fs$readFile(path2, options2, function(err) {
					if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
						go$readFile,
						[
							path2,
							options2,
							cb2
						],
						err,
						startTime || Date.now(),
						Date.now()
					]);
					else if (typeof cb2 === "function") cb2.apply(this, arguments);
				});
			}
		}
		var fs$writeFile = fs3.writeFile;
		fs3.writeFile = writeFile;
		function writeFile(path$3, data$1, options, cb) {
			if (typeof options === "function") cb = options, options = null;
			return go$writeFile(path$3, data$1, options, cb);
			function go$writeFile(path2, data2, options2, cb2, startTime) {
				return fs$writeFile(path2, data2, options2, function(err) {
					if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
						go$writeFile,
						[
							path2,
							data2,
							options2,
							cb2
						],
						err,
						startTime || Date.now(),
						Date.now()
					]);
					else if (typeof cb2 === "function") cb2.apply(this, arguments);
				});
			}
		}
		var fs$appendFile = fs3.appendFile;
		if (fs$appendFile) fs3.appendFile = appendFile;
		function appendFile(path$3, data$1, options, cb) {
			if (typeof options === "function") cb = options, options = null;
			return go$appendFile(path$3, data$1, options, cb);
			function go$appendFile(path2, data2, options2, cb2, startTime) {
				return fs$appendFile(path2, data2, options2, function(err) {
					if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
						go$appendFile,
						[
							path2,
							data2,
							options2,
							cb2
						],
						err,
						startTime || Date.now(),
						Date.now()
					]);
					else if (typeof cb2 === "function") cb2.apply(this, arguments);
				});
			}
		}
		var fs$copyFile = fs3.copyFile;
		if (fs$copyFile) fs3.copyFile = copyFile;
		function copyFile(src, dest, flags, cb) {
			if (typeof flags === "function") {
				cb = flags;
				flags = 0;
			}
			return go$copyFile(src, dest, flags, cb);
			function go$copyFile(src2, dest2, flags2, cb2, startTime) {
				return fs$copyFile(src2, dest2, flags2, function(err) {
					if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
						go$copyFile,
						[
							src2,
							dest2,
							flags2,
							cb2
						],
						err,
						startTime || Date.now(),
						Date.now()
					]);
					else if (typeof cb2 === "function") cb2.apply(this, arguments);
				});
			}
		}
		var fs$readdir = fs3.readdir;
		fs3.readdir = readdir;
		var noReaddirOptionVersions = /^v[0-5]\./;
		function readdir(path$3, options, cb) {
			if (typeof options === "function") cb = options, options = null;
			var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path2, options2, cb2, startTime) {
				return fs$readdir(path2, fs$readdirCallback(path2, options2, cb2, startTime));
			} : function go$readdir2(path2, options2, cb2, startTime) {
				return fs$readdir(path2, options2, fs$readdirCallback(path2, options2, cb2, startTime));
			};
			return go$readdir(path$3, options, cb);
			function fs$readdirCallback(path2, options2, cb2, startTime) {
				return function(err, files) {
					if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
						go$readdir,
						[
							path2,
							options2,
							cb2
						],
						err,
						startTime || Date.now(),
						Date.now()
					]);
					else {
						if (files && files.sort) files.sort();
						if (typeof cb2 === "function") cb2.call(this, err, files);
					}
				};
			}
		}
		if (process.version.substr(0, 4) === "v0.8") {
			var legStreams = legacy(fs3);
			ReadStream = legStreams.ReadStream;
			WriteStream = legStreams.WriteStream;
		}
		var fs$ReadStream = fs3.ReadStream;
		if (fs$ReadStream) {
			ReadStream.prototype = Object.create(fs$ReadStream.prototype);
			ReadStream.prototype.open = ReadStream$open;
		}
		var fs$WriteStream = fs3.WriteStream;
		if (fs$WriteStream) {
			WriteStream.prototype = Object.create(fs$WriteStream.prototype);
			WriteStream.prototype.open = WriteStream$open;
		}
		Object.defineProperty(fs3, "ReadStream", {
			get: function() {
				return ReadStream;
			},
			set: function(val) {
				ReadStream = val;
			},
			enumerable: true,
			configurable: true
		});
		Object.defineProperty(fs3, "WriteStream", {
			get: function() {
				return WriteStream;
			},
			set: function(val) {
				WriteStream = val;
			},
			enumerable: true,
			configurable: true
		});
		var FileReadStream = ReadStream;
		Object.defineProperty(fs3, "FileReadStream", {
			get: function() {
				return FileReadStream;
			},
			set: function(val) {
				FileReadStream = val;
			},
			enumerable: true,
			configurable: true
		});
		var FileWriteStream = WriteStream;
		Object.defineProperty(fs3, "FileWriteStream", {
			get: function() {
				return FileWriteStream;
			},
			set: function(val) {
				FileWriteStream = val;
			},
			enumerable: true,
			configurable: true
		});
		function ReadStream(path$3, options) {
			if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;
			else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
		}
		function ReadStream$open() {
			var that = this;
			open(that.path, that.flags, that.mode, function(err, fd) {
				if (err) {
					if (that.autoClose) that.destroy();
					that.emit("error", err);
				} else {
					that.fd = fd;
					that.emit("open", fd);
					that.read();
				}
			});
		}
		function WriteStream(path$3, options) {
			if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;
			else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
		}
		function WriteStream$open() {
			var that = this;
			open(that.path, that.flags, that.mode, function(err, fd) {
				if (err) {
					that.destroy();
					that.emit("error", err);
				} else {
					that.fd = fd;
					that.emit("open", fd);
				}
			});
		}
		function createReadStream(path$3, options) {
			return new fs3.ReadStream(path$3, options);
		}
		function createWriteStream(path$3, options) {
			return new fs3.WriteStream(path$3, options);
		}
		var fs$open = fs3.open;
		fs3.open = open;
		function open(path$3, flags, mode, cb) {
			if (typeof mode === "function") cb = mode, mode = null;
			return go$open(path$3, flags, mode, cb);
			function go$open(path2, flags2, mode2, cb2, startTime) {
				return fs$open(path2, flags2, mode2, function(err, fd) {
					if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
						go$open,
						[
							path2,
							flags2,
							mode2,
							cb2
						],
						err,
						startTime || Date.now(),
						Date.now()
					]);
					else if (typeof cb2 === "function") cb2.apply(this, arguments);
				});
			}
		}
		return fs3;
	}
	function enqueue(elem) {
		debug$2("ENQUEUE", elem[0].name, elem[1]);
		fs2[gracefulQueue].push(elem);
		retry();
	}
	var retryTimer;
	function resetQueue() {
		var now2 = Date.now();
		for (var i = 0; i < fs2[gracefulQueue].length; ++i) if (fs2[gracefulQueue][i].length > 2) {
			fs2[gracefulQueue][i][3] = now2;
			fs2[gracefulQueue][i][4] = now2;
		}
		retry();
	}
	function retry() {
		clearTimeout(retryTimer);
		retryTimer = void 0;
		if (fs2[gracefulQueue].length === 0) return;
		var elem = fs2[gracefulQueue].shift();
		var fn = elem[0];
		var args = elem[1];
		var err = elem[2];
		var startTime = elem[3];
		var lastTime = elem[4];
		if (startTime === void 0) {
			debug$2("RETRY", fn.name, args);
			fn.apply(null, args);
		} else if (Date.now() - startTime >= 6e4) {
			debug$2("TIMEOUT", fn.name, args);
			var cb = args.pop();
			if (typeof cb === "function") cb.call(null, err);
		} else {
			var sinceAttempt = Date.now() - lastTime;
			var sinceStart = Math.max(lastTime - startTime, 1);
			if (sinceAttempt >= Math.min(sinceStart * 1.2, 100)) {
				debug$2("RETRY", fn.name, args);
				fn.apply(null, args.concat([startTime]));
			} else fs2[gracefulQueue].push(elem);
		}
		if (retryTimer === void 0) retryTimer = setTimeout(retry, 0);
	}
	return gracefulFs;
}
var hasRequiredFs;
function requireFs() {
	if (hasRequiredFs) return fs$3;
	hasRequiredFs = 1;
	(function(exports$1) {
		const u = requireUniversalify().fromCallback;
		const fs2 = requireGracefulFs();
		const api = [
			"access",
			"appendFile",
			"chmod",
			"chown",
			"close",
			"copyFile",
			"fchmod",
			"fchown",
			"fdatasync",
			"fstat",
			"fsync",
			"ftruncate",
			"futimes",
			"lchown",
			"lchmod",
			"link",
			"lstat",
			"mkdir",
			"mkdtemp",
			"open",
			"readFile",
			"readdir",
			"readlink",
			"realpath",
			"rename",
			"rmdir",
			"stat",
			"symlink",
			"truncate",
			"unlink",
			"utimes",
			"writeFile"
		].filter((key) => {
			return typeof fs2[key] === "function";
		});
		Object.keys(fs2).forEach((key) => {
			if (key === "promises") return;
			exports$1[key] = fs2[key];
		});
		api.forEach((method) => {
			exports$1[method] = u(fs2[method]);
		});
		exports$1.exists = function(filename, callback) {
			if (typeof callback === "function") return fs2.exists(filename, callback);
			return new Promise((resolve) => {
				return fs2.exists(filename, resolve);
			});
		};
		exports$1.read = function(fd, buffer2, offset, length, position, callback) {
			if (typeof callback === "function") return fs2.read(fd, buffer2, offset, length, position, callback);
			return new Promise((resolve, reject) => {
				fs2.read(fd, buffer2, offset, length, position, (err, bytesRead, buffer3) => {
					if (err) return reject(err);
					resolve({
						bytesRead,
						buffer: buffer3
					});
				});
			});
		};
		exports$1.write = function(fd, buffer2, ...args) {
			if (typeof args[args.length - 1] === "function") return fs2.write(fd, buffer2, ...args);
			return new Promise((resolve, reject) => {
				fs2.write(fd, buffer2, ...args, (err, bytesWritten, buffer3) => {
					if (err) return reject(err);
					resolve({
						bytesWritten,
						buffer: buffer3
					});
				});
			});
		};
		if (typeof fs2.realpath.native === "function") exports$1.realpath.native = u(fs2.realpath.native);
	})(fs$3);
	return fs$3;
}
var win32;
var hasRequiredWin32;
function requireWin32() {
	if (hasRequiredWin32) return win32;
	hasRequiredWin32 = 1;
	const path$3 = path$1;
	function getRootPath(p) {
		p = path$3.normalize(path$3.resolve(p)).split(path$3.sep);
		if (p.length > 0) return p[0];
		return null;
	}
	const INVALID_PATH_CHARS = /[<>:"|?*]/;
	function invalidWin32Path(p) {
		const rp = getRootPath(p);
		p = p.replace(rp, "");
		return INVALID_PATH_CHARS.test(p);
	}
	win32 = {
		getRootPath,
		invalidWin32Path
	};
	return win32;
}
var mkdirs_1$1;
var hasRequiredMkdirs$1;
function requireMkdirs$1() {
	if (hasRequiredMkdirs$1) return mkdirs_1$1;
	hasRequiredMkdirs$1 = 1;
	const fs2 = requireGracefulFs();
	const path$3 = path$1;
	const invalidWin32Path = requireWin32().invalidWin32Path;
	const o777 = parseInt("0777", 8);
	function mkdirs(p, opts, callback, made) {
		if (typeof opts === "function") {
			callback = opts;
			opts = {};
		} else if (!opts || typeof opts !== "object") opts = { mode: opts };
		if (process.platform === "win32" && invalidWin32Path(p)) {
			const errInval = /* @__PURE__ */ new Error(p + " contains invalid WIN32 path characters.");
			errInval.code = "EINVAL";
			return callback(errInval);
		}
		let mode = opts.mode;
		const xfs = opts.fs || fs2;
		if (mode === void 0) mode = o777 & ~process.umask();
		if (!made) made = null;
		callback = callback || function() {};
		p = path$3.resolve(p);
		xfs.mkdir(p, mode, (er) => {
			if (!er) {
				made = made || p;
				return callback(null, made);
			}
			switch (er.code) {
				case "ENOENT":
					if (path$3.dirname(p) === p) return callback(er);
					mkdirs(path$3.dirname(p), opts, (er2, made2) => {
						if (er2) callback(er2, made2);
						else mkdirs(p, opts, callback, made2);
					});
					break;
				default:
					xfs.stat(p, (er2, stat2) => {
						if (er2 || !stat2.isDirectory()) callback(er, made);
						else callback(null, made);
					});
					break;
			}
		});
	}
	mkdirs_1$1 = mkdirs;
	return mkdirs_1$1;
}
var mkdirsSync_1;
var hasRequiredMkdirsSync;
function requireMkdirsSync() {
	if (hasRequiredMkdirsSync) return mkdirsSync_1;
	hasRequiredMkdirsSync = 1;
	const fs2 = requireGracefulFs();
	const path$3 = path$1;
	const invalidWin32Path = requireWin32().invalidWin32Path;
	const o777 = parseInt("0777", 8);
	function mkdirsSync(p, opts, made) {
		if (!opts || typeof opts !== "object") opts = { mode: opts };
		let mode = opts.mode;
		const xfs = opts.fs || fs2;
		if (process.platform === "win32" && invalidWin32Path(p)) {
			const errInval = /* @__PURE__ */ new Error(p + " contains invalid WIN32 path characters.");
			errInval.code = "EINVAL";
			throw errInval;
		}
		if (mode === void 0) mode = o777 & ~process.umask();
		if (!made) made = null;
		p = path$3.resolve(p);
		try {
			xfs.mkdirSync(p, mode);
			made = made || p;
		} catch (err0) {
			if (err0.code === "ENOENT") {
				if (path$3.dirname(p) === p) throw err0;
				made = mkdirsSync(path$3.dirname(p), opts, made);
				mkdirsSync(p, opts, made);
			} else {
				let stat2;
				try {
					stat2 = xfs.statSync(p);
				} catch (err1) {
					throw err0;
				}
				if (!stat2.isDirectory()) throw err0;
			}
		}
		return made;
	}
	mkdirsSync_1 = mkdirsSync;
	return mkdirsSync_1;
}
var mkdirs_1;
var hasRequiredMkdirs;
function requireMkdirs() {
	if (hasRequiredMkdirs) return mkdirs_1;
	hasRequiredMkdirs = 1;
	const u = requireUniversalify().fromCallback;
	const mkdirs = u(requireMkdirs$1());
	const mkdirsSync = requireMkdirsSync();
	mkdirs_1 = {
		mkdirs,
		mkdirsSync,
		mkdirp: mkdirs,
		mkdirpSync: mkdirsSync,
		ensureDir: mkdirs,
		ensureDirSync: mkdirsSync
	};
	return mkdirs_1;
}
var utimes;
var hasRequiredUtimes;
function requireUtimes() {
	if (hasRequiredUtimes) return utimes;
	hasRequiredUtimes = 1;
	const fs2 = requireGracefulFs();
	const os$1 = require$$1$1;
	const path$3 = path$1;
	function hasMillisResSync() {
		let tmpfile = path$3.join("millis-test-sync" + Date.now().toString() + Math.random().toString().slice(2));
		tmpfile = path$3.join(os$1.tmpdir(), tmpfile);
		const d$1 = /* @__PURE__ */ new Date(1435410243862);
		fs2.writeFileSync(tmpfile, "https://github.com/jprichardson/node-fs-extra/pull/141");
		const fd = fs2.openSync(tmpfile, "r+");
		fs2.futimesSync(fd, d$1, d$1);
		fs2.closeSync(fd);
		return fs2.statSync(tmpfile).mtime > 1435410243e3;
	}
	function hasMillisRes(callback) {
		let tmpfile = path$3.join("millis-test" + Date.now().toString() + Math.random().toString().slice(2));
		tmpfile = path$3.join(os$1.tmpdir(), tmpfile);
		const d$1 = /* @__PURE__ */ new Date(1435410243862);
		fs2.writeFile(tmpfile, "https://github.com/jprichardson/node-fs-extra/pull/141", (err) => {
			if (err) return callback(err);
			fs2.open(tmpfile, "r+", (err2, fd) => {
				if (err2) return callback(err2);
				fs2.futimes(fd, d$1, d$1, (err3) => {
					if (err3) return callback(err3);
					fs2.close(fd, (err4) => {
						if (err4) return callback(err4);
						fs2.stat(tmpfile, (err5, stats) => {
							if (err5) return callback(err5);
							callback(null, stats.mtime > 1435410243e3);
						});
					});
				});
			});
		});
	}
	function timeRemoveMillis(timestamp) {
		if (typeof timestamp === "number") return Math.floor(timestamp / 1e3) * 1e3;
		else if (timestamp instanceof Date) return /* @__PURE__ */ new Date(Math.floor(timestamp.getTime() / 1e3) * 1e3);
		else throw new Error("fs-extra: timeRemoveMillis() unknown parameter type");
	}
	function utimesMillis(path2, atime, mtime, callback) {
		fs2.open(path2, "r+", (err, fd) => {
			if (err) return callback(err);
			fs2.futimes(fd, atime, mtime, (futimesErr) => {
				fs2.close(fd, (closeErr) => {
					if (callback) callback(futimesErr || closeErr);
				});
			});
		});
	}
	function utimesMillisSync(path2, atime, mtime) {
		const fd = fs2.openSync(path2, "r+");
		fs2.futimesSync(fd, atime, mtime);
		return fs2.closeSync(fd);
	}
	utimes = {
		hasMillisRes,
		hasMillisResSync,
		timeRemoveMillis,
		utimesMillis,
		utimesMillisSync
	};
	return utimes;
}
var stat;
var hasRequiredStat;
function requireStat() {
	if (hasRequiredStat) return stat;
	hasRequiredStat = 1;
	const fs2 = requireGracefulFs();
	const path$3 = path$1;
	const NODE_VERSION_MAJOR_WITH_BIGINT = 10;
	const NODE_VERSION_MINOR_WITH_BIGINT = 5;
	const NODE_VERSION_PATCH_WITH_BIGINT = 0;
	const nodeVersion = process.versions.node.split(".");
	const nodeVersionMajor = Number.parseInt(nodeVersion[0], 10);
	const nodeVersionMinor = Number.parseInt(nodeVersion[1], 10);
	const nodeVersionPatch = Number.parseInt(nodeVersion[2], 10);
	function nodeSupportsBigInt() {
		if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) return true;
		else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {
			if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) return true;
			else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {
				if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) return true;
			}
		}
		return false;
	}
	function getStats(src, dest, cb) {
		if (nodeSupportsBigInt()) fs2.stat(src, { bigint: true }, (err, srcStat) => {
			if (err) return cb(err);
			fs2.stat(dest, { bigint: true }, (err2, destStat) => {
				if (err2) {
					if (err2.code === "ENOENT") return cb(null, {
						srcStat,
						destStat: null
					});
					return cb(err2);
				}
				return cb(null, {
					srcStat,
					destStat
				});
			});
		});
		else fs2.stat(src, (err, srcStat) => {
			if (err) return cb(err);
			fs2.stat(dest, (err2, destStat) => {
				if (err2) {
					if (err2.code === "ENOENT") return cb(null, {
						srcStat,
						destStat: null
					});
					return cb(err2);
				}
				return cb(null, {
					srcStat,
					destStat
				});
			});
		});
	}
	function getStatsSync(src, dest) {
		let srcStat, destStat;
		if (nodeSupportsBigInt()) srcStat = fs2.statSync(src, { bigint: true });
		else srcStat = fs2.statSync(src);
		try {
			if (nodeSupportsBigInt()) destStat = fs2.statSync(dest, { bigint: true });
			else destStat = fs2.statSync(dest);
		} catch (err) {
			if (err.code === "ENOENT") return {
				srcStat,
				destStat: null
			};
			throw err;
		}
		return {
			srcStat,
			destStat
		};
	}
	function checkPaths(src, dest, funcName, cb) {
		getStats(src, dest, (err, stats) => {
			if (err) return cb(err);
			const { srcStat, destStat } = stats;
			if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) return cb(/* @__PURE__ */ new Error("Source and destination must not be the same."));
			if (srcStat.isDirectory() && isSrcSubdir(src, dest)) return cb(new Error(errMsg(src, dest, funcName)));
			return cb(null, {
				srcStat,
				destStat
			});
		});
	}
	function checkPathsSync(src, dest, funcName) {
		const { srcStat, destStat } = getStatsSync(src, dest);
		if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) throw new Error("Source and destination must not be the same.");
		if (srcStat.isDirectory() && isSrcSubdir(src, dest)) throw new Error(errMsg(src, dest, funcName));
		return {
			srcStat,
			destStat
		};
	}
	function checkParentPaths(src, srcStat, dest, funcName, cb) {
		const srcParent = path$3.resolve(path$3.dirname(src));
		const destParent = path$3.resolve(path$3.dirname(dest));
		if (destParent === srcParent || destParent === path$3.parse(destParent).root) return cb();
		if (nodeSupportsBigInt()) fs2.stat(destParent, { bigint: true }, (err, destStat) => {
			if (err) {
				if (err.code === "ENOENT") return cb();
				return cb(err);
			}
			if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) return cb(new Error(errMsg(src, dest, funcName)));
			return checkParentPaths(src, srcStat, destParent, funcName, cb);
		});
		else fs2.stat(destParent, (err, destStat) => {
			if (err) {
				if (err.code === "ENOENT") return cb();
				return cb(err);
			}
			if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) return cb(new Error(errMsg(src, dest, funcName)));
			return checkParentPaths(src, srcStat, destParent, funcName, cb);
		});
	}
	function checkParentPathsSync(src, srcStat, dest, funcName) {
		const srcParent = path$3.resolve(path$3.dirname(src));
		const destParent = path$3.resolve(path$3.dirname(dest));
		if (destParent === srcParent || destParent === path$3.parse(destParent).root) return;
		let destStat;
		try {
			if (nodeSupportsBigInt()) destStat = fs2.statSync(destParent, { bigint: true });
			else destStat = fs2.statSync(destParent);
		} catch (err) {
			if (err.code === "ENOENT") return;
			throw err;
		}
		if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) throw new Error(errMsg(src, dest, funcName));
		return checkParentPathsSync(src, srcStat, destParent, funcName);
	}
	function isSrcSubdir(src, dest) {
		const srcArr = path$3.resolve(src).split(path$3.sep).filter((i) => i);
		const destArr = path$3.resolve(dest).split(path$3.sep).filter((i) => i);
		return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
	}
	function errMsg(src, dest, funcName) {
		return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
	}
	stat = {
		checkPaths,
		checkPathsSync,
		checkParentPaths,
		checkParentPathsSync,
		isSrcSubdir
	};
	return stat;
}
var buffer;
var hasRequiredBuffer;
function requireBuffer() {
	if (hasRequiredBuffer) return buffer;
	hasRequiredBuffer = 1;
	buffer = function(size) {
		if (typeof Buffer.allocUnsafe === "function") try {
			return Buffer.allocUnsafe(size);
		} catch (e) {
			return new Buffer(size);
		}
		return new Buffer(size);
	};
	return buffer;
}
var copySync_1;
var hasRequiredCopySync$1;
function requireCopySync$1() {
	if (hasRequiredCopySync$1) return copySync_1;
	hasRequiredCopySync$1 = 1;
	const fs2 = requireGracefulFs();
	const path$3 = path$1;
	const mkdirpSync = requireMkdirs().mkdirsSync;
	const utimesSync = requireUtimes().utimesMillisSync;
	const stat2 = requireStat();
	function copySync2(src, dest, opts) {
		if (typeof opts === "function") opts = { filter: opts };
		opts = opts || {};
		opts.clobber = "clobber" in opts ? !!opts.clobber : true;
		opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
		if (opts.preserveTimestamps && process.arch === "ia32") console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
		const { srcStat, destStat } = stat2.checkPathsSync(src, dest, "copy");
		stat2.checkParentPathsSync(src, srcStat, dest, "copy");
		return handleFilterAndCopy(destStat, src, dest, opts);
	}
	function handleFilterAndCopy(destStat, src, dest, opts) {
		if (opts.filter && !opts.filter(src, dest)) return;
		const destParent = path$3.dirname(dest);
		if (!fs2.existsSync(destParent)) mkdirpSync(destParent);
		return startCopy(destStat, src, dest, opts);
	}
	function startCopy(destStat, src, dest, opts) {
		if (opts.filter && !opts.filter(src, dest)) return;
		return getStats(destStat, src, dest, opts);
	}
	function getStats(destStat, src, dest, opts) {
		const srcStat = (opts.dereference ? fs2.statSync : fs2.lstatSync)(src);
		if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);
		else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);
		else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);
	}
	function onFile(srcStat, destStat, src, dest, opts) {
		if (!destStat) return copyFile(srcStat, src, dest, opts);
		return mayCopyFile(srcStat, src, dest, opts);
	}
	function mayCopyFile(srcStat, src, dest, opts) {
		if (opts.overwrite) {
			fs2.unlinkSync(dest);
			return copyFile(srcStat, src, dest, opts);
		} else if (opts.errorOnExist) throw new Error(`'${dest}' already exists`);
	}
	function copyFile(srcStat, src, dest, opts) {
		if (typeof fs2.copyFileSync === "function") {
			fs2.copyFileSync(src, dest);
			fs2.chmodSync(dest, srcStat.mode);
			if (opts.preserveTimestamps) return utimesSync(dest, srcStat.atime, srcStat.mtime);
			return;
		}
		return copyFileFallback(srcStat, src, dest, opts);
	}
	function copyFileFallback(srcStat, src, dest, opts) {
		const BUF_LENGTH = 64 * 1024;
		const _buff = requireBuffer()(BUF_LENGTH);
		const fdr = fs2.openSync(src, "r");
		const fdw = fs2.openSync(dest, "w", srcStat.mode);
		let pos = 0;
		while (pos < srcStat.size) {
			const bytesRead = fs2.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
			fs2.writeSync(fdw, _buff, 0, bytesRead);
			pos += bytesRead;
		}
		if (opts.preserveTimestamps) fs2.futimesSync(fdw, srcStat.atime, srcStat.mtime);
		fs2.closeSync(fdr);
		fs2.closeSync(fdw);
	}
	function onDir(srcStat, destStat, src, dest, opts) {
		if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts);
		if (destStat && !destStat.isDirectory()) throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
		return copyDir(src, dest, opts);
	}
	function mkDirAndCopy(srcStat, src, dest, opts) {
		fs2.mkdirSync(dest);
		copyDir(src, dest, opts);
		return fs2.chmodSync(dest, srcStat.mode);
	}
	function copyDir(src, dest, opts) {
		fs2.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
	}
	function copyDirItem(item, src, dest, opts) {
		const srcItem = path$3.join(src, item);
		const destItem = path$3.join(dest, item);
		const { destStat } = stat2.checkPathsSync(srcItem, destItem, "copy");
		return startCopy(destStat, srcItem, destItem, opts);
	}
	function onLink(destStat, src, dest, opts) {
		let resolvedSrc = fs2.readlinkSync(src);
		if (opts.dereference) resolvedSrc = path$3.resolve(process.cwd(), resolvedSrc);
		if (!destStat) return fs2.symlinkSync(resolvedSrc, dest);
		else {
			let resolvedDest;
			try {
				resolvedDest = fs2.readlinkSync(dest);
			} catch (err) {
				if (err.code === "EINVAL" || err.code === "UNKNOWN") return fs2.symlinkSync(resolvedSrc, dest);
				throw err;
			}
			if (opts.dereference) resolvedDest = path$3.resolve(process.cwd(), resolvedDest);
			if (stat2.isSrcSubdir(resolvedSrc, resolvedDest)) throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
			if (fs2.statSync(dest).isDirectory() && stat2.isSrcSubdir(resolvedDest, resolvedSrc)) throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
			return copyLink(resolvedSrc, dest);
		}
	}
	function copyLink(resolvedSrc, dest) {
		fs2.unlinkSync(dest);
		return fs2.symlinkSync(resolvedSrc, dest);
	}
	copySync_1 = copySync2;
	return copySync_1;
}
var copySync;
var hasRequiredCopySync;
function requireCopySync() {
	if (hasRequiredCopySync) return copySync;
	hasRequiredCopySync = 1;
	copySync = { copySync: requireCopySync$1() };
	return copySync;
}
var pathExists_1;
var hasRequiredPathExists;
function requirePathExists() {
	if (hasRequiredPathExists) return pathExists_1;
	hasRequiredPathExists = 1;
	const u = requireUniversalify().fromPromise;
	const fs2 = requireFs();
	function pathExists(path$3) {
		return fs2.access(path$3).then(() => true).catch(() => false);
	}
	pathExists_1 = {
		pathExists: u(pathExists),
		pathExistsSync: fs2.existsSync
	};
	return pathExists_1;
}
var copy_1;
var hasRequiredCopy$1;
function requireCopy$1() {
	if (hasRequiredCopy$1) return copy_1;
	hasRequiredCopy$1 = 1;
	const fs2 = requireGracefulFs();
	const path$3 = path$1;
	const mkdirp = requireMkdirs().mkdirs;
	const pathExists = requirePathExists().pathExists;
	const utimes2 = requireUtimes().utimesMillis;
	const stat2 = requireStat();
	function copy2(src, dest, opts, cb) {
		if (typeof opts === "function" && !cb) {
			cb = opts;
			opts = {};
		} else if (typeof opts === "function") opts = { filter: opts };
		cb = cb || function() {};
		opts = opts || {};
		opts.clobber = "clobber" in opts ? !!opts.clobber : true;
		opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
		if (opts.preserveTimestamps && process.arch === "ia32") console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
		stat2.checkPaths(src, dest, "copy", (err, stats) => {
			if (err) return cb(err);
			const { srcStat, destStat } = stats;
			stat2.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
				if (err2) return cb(err2);
				if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
				return checkParentDir(destStat, src, dest, opts, cb);
			});
		});
	}
	function checkParentDir(destStat, src, dest, opts, cb) {
		const destParent = path$3.dirname(dest);
		pathExists(destParent, (err, dirExists) => {
			if (err) return cb(err);
			if (dirExists) return startCopy(destStat, src, dest, opts, cb);
			mkdirp(destParent, (err2) => {
				if (err2) return cb(err2);
				return startCopy(destStat, src, dest, opts, cb);
			});
		});
	}
	function handleFilter(onInclude, destStat, src, dest, opts, cb) {
		Promise.resolve(opts.filter(src, dest)).then((include) => {
			if (include) return onInclude(destStat, src, dest, opts, cb);
			return cb();
		}, (error) => cb(error));
	}
	function startCopy(destStat, src, dest, opts, cb) {
		if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb);
		return getStats(destStat, src, dest, opts, cb);
	}
	function getStats(destStat, src, dest, opts, cb) {
		(opts.dereference ? fs2.stat : fs2.lstat)(src, (err, srcStat) => {
			if (err) return cb(err);
			if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb);
			else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb);
			else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb);
		});
	}
	function onFile(srcStat, destStat, src, dest, opts, cb) {
		if (!destStat) return copyFile(srcStat, src, dest, opts, cb);
		return mayCopyFile(srcStat, src, dest, opts, cb);
	}
	function mayCopyFile(srcStat, src, dest, opts, cb) {
		if (opts.overwrite) fs2.unlink(dest, (err) => {
			if (err) return cb(err);
			return copyFile(srcStat, src, dest, opts, cb);
		});
		else if (opts.errorOnExist) return cb(/* @__PURE__ */ new Error(`'${dest}' already exists`));
		else return cb();
	}
	function copyFile(srcStat, src, dest, opts, cb) {
		if (typeof fs2.copyFile === "function") return fs2.copyFile(src, dest, (err) => {
			if (err) return cb(err);
			return setDestModeAndTimestamps(srcStat, dest, opts, cb);
		});
		return copyFileFallback(srcStat, src, dest, opts, cb);
	}
	function copyFileFallback(srcStat, src, dest, opts, cb) {
		const rs = fs2.createReadStream(src);
		rs.on("error", (err) => cb(err)).once("open", () => {
			const ws = fs2.createWriteStream(dest, { mode: srcStat.mode });
			ws.on("error", (err) => cb(err)).on("open", () => rs.pipe(ws)).once("close", () => setDestModeAndTimestamps(srcStat, dest, opts, cb));
		});
	}
	function setDestModeAndTimestamps(srcStat, dest, opts, cb) {
		fs2.chmod(dest, srcStat.mode, (err) => {
			if (err) return cb(err);
			if (opts.preserveTimestamps) return utimes2(dest, srcStat.atime, srcStat.mtime, cb);
			return cb();
		});
	}
	function onDir(srcStat, destStat, src, dest, opts, cb) {
		if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts, cb);
		if (destStat && !destStat.isDirectory()) return cb(/* @__PURE__ */ new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
		return copyDir(src, dest, opts, cb);
	}
	function mkDirAndCopy(srcStat, src, dest, opts, cb) {
		fs2.mkdir(dest, (err) => {
			if (err) return cb(err);
			copyDir(src, dest, opts, (err2) => {
				if (err2) return cb(err2);
				return fs2.chmod(dest, srcStat.mode, cb);
			});
		});
	}
	function copyDir(src, dest, opts, cb) {
		fs2.readdir(src, (err, items) => {
			if (err) return cb(err);
			return copyDirItems(items, src, dest, opts, cb);
		});
	}
	function copyDirItems(items, src, dest, opts, cb) {
		const item = items.pop();
		if (!item) return cb();
		return copyDirItem(items, item, src, dest, opts, cb);
	}
	function copyDirItem(items, item, src, dest, opts, cb) {
		const srcItem = path$3.join(src, item);
		const destItem = path$3.join(dest, item);
		stat2.checkPaths(srcItem, destItem, "copy", (err, stats) => {
			if (err) return cb(err);
			const { destStat } = stats;
			startCopy(destStat, srcItem, destItem, opts, (err2) => {
				if (err2) return cb(err2);
				return copyDirItems(items, src, dest, opts, cb);
			});
		});
	}
	function onLink(destStat, src, dest, opts, cb) {
		fs2.readlink(src, (err, resolvedSrc) => {
			if (err) return cb(err);
			if (opts.dereference) resolvedSrc = path$3.resolve(process.cwd(), resolvedSrc);
			if (!destStat) return fs2.symlink(resolvedSrc, dest, cb);
			else fs2.readlink(dest, (err2, resolvedDest) => {
				if (err2) {
					if (err2.code === "EINVAL" || err2.code === "UNKNOWN") return fs2.symlink(resolvedSrc, dest, cb);
					return cb(err2);
				}
				if (opts.dereference) resolvedDest = path$3.resolve(process.cwd(), resolvedDest);
				if (stat2.isSrcSubdir(resolvedSrc, resolvedDest)) return cb(/* @__PURE__ */ new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
				if (destStat.isDirectory() && stat2.isSrcSubdir(resolvedDest, resolvedSrc)) return cb(/* @__PURE__ */ new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
				return copyLink(resolvedSrc, dest, cb);
			});
		});
	}
	function copyLink(resolvedSrc, dest, cb) {
		fs2.unlink(dest, (err) => {
			if (err) return cb(err);
			return fs2.symlink(resolvedSrc, dest, cb);
		});
	}
	copy_1 = copy2;
	return copy_1;
}
var copy;
var hasRequiredCopy;
function requireCopy() {
	if (hasRequiredCopy) return copy;
	hasRequiredCopy = 1;
	const u = requireUniversalify().fromCallback;
	copy = { copy: u(requireCopy$1()) };
	return copy;
}
var rimraf_1;
var hasRequiredRimraf;
function requireRimraf() {
	if (hasRequiredRimraf) return rimraf_1;
	hasRequiredRimraf = 1;
	const fs2 = requireGracefulFs();
	const path$3 = path$1;
	const assert$1 = require$$5;
	const isWindows = process.platform === "win32";
	function defaults$1(options) {
		[
			"unlink",
			"chmod",
			"stat",
			"lstat",
			"rmdir",
			"readdir"
		].forEach((m$1) => {
			options[m$1] = options[m$1] || fs2[m$1];
			m$1 = m$1 + "Sync";
			options[m$1] = options[m$1] || fs2[m$1];
		});
		options.maxBusyTries = options.maxBusyTries || 3;
	}
	function rimraf(p, options, cb) {
		let busyTries = 0;
		if (typeof options === "function") {
			cb = options;
			options = {};
		}
		assert$1(p, "rimraf: missing path");
		assert$1.strictEqual(typeof p, "string", "rimraf: path should be a string");
		assert$1.strictEqual(typeof cb, "function", "rimraf: callback function required");
		assert$1(options, "rimraf: invalid options argument provided");
		assert$1.strictEqual(typeof options, "object", "rimraf: options should be object");
		defaults$1(options);
		rimraf_(p, options, function CB(er) {
			if (er) {
				if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
					busyTries++;
					const time$2 = busyTries * 100;
					return setTimeout(() => rimraf_(p, options, CB), time$2);
				}
				if (er.code === "ENOENT") er = null;
			}
			cb(er);
		});
	}
	function rimraf_(p, options, cb) {
		assert$1(p);
		assert$1(options);
		assert$1(typeof cb === "function");
		options.lstat(p, (er, st) => {
			if (er && er.code === "ENOENT") return cb(null);
			if (er && er.code === "EPERM" && isWindows) return fixWinEPERM(p, options, er, cb);
			if (st && st.isDirectory()) return rmdir(p, options, er, cb);
			options.unlink(p, (er2) => {
				if (er2) {
					if (er2.code === "ENOENT") return cb(null);
					if (er2.code === "EPERM") return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
					if (er2.code === "EISDIR") return rmdir(p, options, er2, cb);
				}
				return cb(er2);
			});
		});
	}
	function fixWinEPERM(p, options, er, cb) {
		assert$1(p);
		assert$1(options);
		assert$1(typeof cb === "function");
		if (er) assert$1(er instanceof Error);
		options.chmod(p, 438, (er2) => {
			if (er2) cb(er2.code === "ENOENT" ? null : er);
			else options.stat(p, (er3, stats) => {
				if (er3) cb(er3.code === "ENOENT" ? null : er);
				else if (stats.isDirectory()) rmdir(p, options, er, cb);
				else options.unlink(p, cb);
			});
		});
	}
	function fixWinEPERMSync(p, options, er) {
		let stats;
		assert$1(p);
		assert$1(options);
		if (er) assert$1(er instanceof Error);
		try {
			options.chmodSync(p, 438);
		} catch (er2) {
			if (er2.code === "ENOENT") return;
			else throw er;
		}
		try {
			stats = options.statSync(p);
		} catch (er3) {
			if (er3.code === "ENOENT") return;
			else throw er;
		}
		if (stats.isDirectory()) rmdirSync(p, options, er);
		else options.unlinkSync(p);
	}
	function rmdir(p, options, originalEr, cb) {
		assert$1(p);
		assert$1(options);
		if (originalEr) assert$1(originalEr instanceof Error);
		assert$1(typeof cb === "function");
		options.rmdir(p, (er) => {
			if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) rmkids(p, options, cb);
			else if (er && er.code === "ENOTDIR") cb(originalEr);
			else cb(er);
		});
	}
	function rmkids(p, options, cb) {
		assert$1(p);
		assert$1(options);
		assert$1(typeof cb === "function");
		options.readdir(p, (er, files) => {
			if (er) return cb(er);
			let n = files.length;
			let errState;
			if (n === 0) return options.rmdir(p, cb);
			files.forEach((f) => {
				rimraf(path$3.join(p, f), options, (er2) => {
					if (errState) return;
					if (er2) return cb(errState = er2);
					if (--n === 0) options.rmdir(p, cb);
				});
			});
		});
	}
	function rimrafSync(p, options) {
		let st;
		options = options || {};
		defaults$1(options);
		assert$1(p, "rimraf: missing path");
		assert$1.strictEqual(typeof p, "string", "rimraf: path should be a string");
		assert$1(options, "rimraf: missing options");
		assert$1.strictEqual(typeof options, "object", "rimraf: options should be object");
		try {
			st = options.lstatSync(p);
		} catch (er) {
			if (er.code === "ENOENT") return;
			if (er.code === "EPERM" && isWindows) fixWinEPERMSync(p, options, er);
		}
		try {
			if (st && st.isDirectory()) rmdirSync(p, options, null);
			else options.unlinkSync(p);
		} catch (er) {
			if (er.code === "ENOENT") return;
			else if (er.code === "EPERM") return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
			else if (er.code !== "EISDIR") throw er;
			rmdirSync(p, options, er);
		}
	}
	function rmdirSync(p, options, originalEr) {
		assert$1(p);
		assert$1(options);
		if (originalEr) assert$1(originalEr instanceof Error);
		try {
			options.rmdirSync(p);
		} catch (er) {
			if (er.code === "ENOTDIR") throw originalEr;
			else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") rmkidsSync(p, options);
			else if (er.code !== "ENOENT") throw er;
		}
	}
	function rmkidsSync(p, options) {
		assert$1(p);
		assert$1(options);
		options.readdirSync(p).forEach((f) => rimrafSync(path$3.join(p, f), options));
		if (isWindows) {
			const startTime = Date.now();
			do
				try {
					return options.rmdirSync(p, options);
				} catch (er) {}
			while (Date.now() - startTime < 500);
		} else return options.rmdirSync(p, options);
	}
	rimraf_1 = rimraf;
	rimraf.sync = rimrafSync;
	return rimraf_1;
}
var remove;
var hasRequiredRemove;
function requireRemove() {
	if (hasRequiredRemove) return remove;
	hasRequiredRemove = 1;
	const u = requireUniversalify().fromCallback;
	const rimraf = requireRimraf();
	remove = {
		remove: u(rimraf),
		removeSync: rimraf.sync
	};
	return remove;
}
var empty;
var hasRequiredEmpty;
function requireEmpty() {
	if (hasRequiredEmpty) return empty;
	hasRequiredEmpty = 1;
	const u = requireUniversalify().fromCallback;
	const fs2 = requireGracefulFs();
	const path$3 = path$1;
	const mkdir = requireMkdirs();
	const remove2 = requireRemove();
	const emptyDir = u(function emptyDir2(dir, callback) {
		callback = callback || function() {};
		fs2.readdir(dir, (err, items) => {
			if (err) return mkdir.mkdirs(dir, callback);
			items = items.map((item) => path$3.join(dir, item));
			deleteItem();
			function deleteItem() {
				const item = items.pop();
				if (!item) return callback();
				remove2.remove(item, (err2) => {
					if (err2) return callback(err2);
					deleteItem();
				});
			}
		});
	});
	function emptyDirSync(dir) {
		let items;
		try {
			items = fs2.readdirSync(dir);
		} catch (err) {
			return mkdir.mkdirsSync(dir);
		}
		items.forEach((item) => {
			item = path$3.join(dir, item);
			remove2.removeSync(item);
		});
	}
	empty = {
		emptyDirSync,
		emptydirSync: emptyDirSync,
		emptyDir,
		emptydir: emptyDir
	};
	return empty;
}
var file;
var hasRequiredFile$1;
function requireFile$1() {
	if (hasRequiredFile$1) return file;
	hasRequiredFile$1 = 1;
	const u = requireUniversalify().fromCallback;
	const path$3 = path$1;
	const fs2 = requireGracefulFs();
	const mkdir = requireMkdirs();
	const pathExists = requirePathExists().pathExists;
	function createFile(file2, callback) {
		function makeFile() {
			fs2.writeFile(file2, "", (err) => {
				if (err) return callback(err);
				callback();
			});
		}
		fs2.stat(file2, (err, stats) => {
			if (!err && stats.isFile()) return callback();
			const dir = path$3.dirname(file2);
			pathExists(dir, (err2, dirExists) => {
				if (err2) return callback(err2);
				if (dirExists) return makeFile();
				mkdir.mkdirs(dir, (err3) => {
					if (err3) return callback(err3);
					makeFile();
				});
			});
		});
	}
	function createFileSync(file2) {
		let stats;
		try {
			stats = fs2.statSync(file2);
		} catch (e) {}
		if (stats && stats.isFile()) return;
		const dir = path$3.dirname(file2);
		if (!fs2.existsSync(dir)) mkdir.mkdirsSync(dir);
		fs2.writeFileSync(file2, "");
	}
	file = {
		createFile: u(createFile),
		createFileSync
	};
	return file;
}
var link;
var hasRequiredLink;
function requireLink() {
	if (hasRequiredLink) return link;
	hasRequiredLink = 1;
	const u = requireUniversalify().fromCallback;
	const path$3 = path$1;
	const fs2 = requireGracefulFs();
	const mkdir = requireMkdirs();
	const pathExists = requirePathExists().pathExists;
	function createLink(srcpath, dstpath, callback) {
		function makeLink(srcpath2, dstpath2) {
			fs2.link(srcpath2, dstpath2, (err) => {
				if (err) return callback(err);
				callback(null);
			});
		}
		pathExists(dstpath, (err, destinationExists) => {
			if (err) return callback(err);
			if (destinationExists) return callback(null);
			fs2.lstat(srcpath, (err2) => {
				if (err2) {
					err2.message = err2.message.replace("lstat", "ensureLink");
					return callback(err2);
				}
				const dir = path$3.dirname(dstpath);
				pathExists(dir, (err3, dirExists) => {
					if (err3) return callback(err3);
					if (dirExists) return makeLink(srcpath, dstpath);
					mkdir.mkdirs(dir, (err4) => {
						if (err4) return callback(err4);
						makeLink(srcpath, dstpath);
					});
				});
			});
		});
	}
	function createLinkSync(srcpath, dstpath) {
		if (fs2.existsSync(dstpath)) return void 0;
		try {
			fs2.lstatSync(srcpath);
		} catch (err) {
			err.message = err.message.replace("lstat", "ensureLink");
			throw err;
		}
		const dir = path$3.dirname(dstpath);
		if (fs2.existsSync(dir)) return fs2.linkSync(srcpath, dstpath);
		mkdir.mkdirsSync(dir);
		return fs2.linkSync(srcpath, dstpath);
	}
	link = {
		createLink: u(createLink),
		createLinkSync
	};
	return link;
}
var symlinkPaths_1;
var hasRequiredSymlinkPaths;
function requireSymlinkPaths() {
	if (hasRequiredSymlinkPaths) return symlinkPaths_1;
	hasRequiredSymlinkPaths = 1;
	const path$3 = path$1;
	const fs2 = requireGracefulFs();
	const pathExists = requirePathExists().pathExists;
	function symlinkPaths(srcpath, dstpath, callback) {
		if (path$3.isAbsolute(srcpath)) return fs2.lstat(srcpath, (err) => {
			if (err) {
				err.message = err.message.replace("lstat", "ensureSymlink");
				return callback(err);
			}
			return callback(null, {
				"toCwd": srcpath,
				"toDst": srcpath
			});
		});
		else {
			const dstdir = path$3.dirname(dstpath);
			const relativeToDst = path$3.join(dstdir, srcpath);
			return pathExists(relativeToDst, (err, exists) => {
				if (err) return callback(err);
				if (exists) return callback(null, {
					"toCwd": relativeToDst,
					"toDst": srcpath
				});
				else return fs2.lstat(srcpath, (err2) => {
					if (err2) {
						err2.message = err2.message.replace("lstat", "ensureSymlink");
						return callback(err2);
					}
					return callback(null, {
						"toCwd": srcpath,
						"toDst": path$3.relative(dstdir, srcpath)
					});
				});
			});
		}
	}
	function symlinkPathsSync(srcpath, dstpath) {
		let exists;
		if (path$3.isAbsolute(srcpath)) {
			exists = fs2.existsSync(srcpath);
			if (!exists) throw new Error("absolute srcpath does not exist");
			return {
				"toCwd": srcpath,
				"toDst": srcpath
			};
		} else {
			const dstdir = path$3.dirname(dstpath);
			const relativeToDst = path$3.join(dstdir, srcpath);
			exists = fs2.existsSync(relativeToDst);
			if (exists) return {
				"toCwd": relativeToDst,
				"toDst": srcpath
			};
			else {
				exists = fs2.existsSync(srcpath);
				if (!exists) throw new Error("relative srcpath does not exist");
				return {
					"toCwd": srcpath,
					"toDst": path$3.relative(dstdir, srcpath)
				};
			}
		}
	}
	symlinkPaths_1 = {
		symlinkPaths,
		symlinkPathsSync
	};
	return symlinkPaths_1;
}
var symlinkType_1;
var hasRequiredSymlinkType;
function requireSymlinkType() {
	if (hasRequiredSymlinkType) return symlinkType_1;
	hasRequiredSymlinkType = 1;
	const fs2 = requireGracefulFs();
	function symlinkType(srcpath, type$1, callback) {
		callback = typeof type$1 === "function" ? type$1 : callback;
		type$1 = typeof type$1 === "function" ? false : type$1;
		if (type$1) return callback(null, type$1);
		fs2.lstat(srcpath, (err, stats) => {
			if (err) return callback(null, "file");
			type$1 = stats && stats.isDirectory() ? "dir" : "file";
			callback(null, type$1);
		});
	}
	function symlinkTypeSync(srcpath, type$1) {
		let stats;
		if (type$1) return type$1;
		try {
			stats = fs2.lstatSync(srcpath);
		} catch (e) {
			return "file";
		}
		return stats && stats.isDirectory() ? "dir" : "file";
	}
	symlinkType_1 = {
		symlinkType,
		symlinkTypeSync
	};
	return symlinkType_1;
}
var symlink;
var hasRequiredSymlink;
function requireSymlink() {
	if (hasRequiredSymlink) return symlink;
	hasRequiredSymlink = 1;
	const u = requireUniversalify().fromCallback;
	const path$3 = path$1;
	const fs2 = requireGracefulFs();
	const _mkdirs = requireMkdirs();
	const mkdirs = _mkdirs.mkdirs;
	const mkdirsSync = _mkdirs.mkdirsSync;
	const _symlinkPaths = requireSymlinkPaths();
	const symlinkPaths = _symlinkPaths.symlinkPaths;
	const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
	const _symlinkType = requireSymlinkType();
	const symlinkType = _symlinkType.symlinkType;
	const symlinkTypeSync = _symlinkType.symlinkTypeSync;
	const pathExists = requirePathExists().pathExists;
	function createSymlink(srcpath, dstpath, type$1, callback) {
		callback = typeof type$1 === "function" ? type$1 : callback;
		type$1 = typeof type$1 === "function" ? false : type$1;
		pathExists(dstpath, (err, destinationExists) => {
			if (err) return callback(err);
			if (destinationExists) return callback(null);
			symlinkPaths(srcpath, dstpath, (err2, relative) => {
				if (err2) return callback(err2);
				srcpath = relative.toDst;
				symlinkType(relative.toCwd, type$1, (err3, type2) => {
					if (err3) return callback(err3);
					const dir = path$3.dirname(dstpath);
					pathExists(dir, (err4, dirExists) => {
						if (err4) return callback(err4);
						if (dirExists) return fs2.symlink(srcpath, dstpath, type2, callback);
						mkdirs(dir, (err5) => {
							if (err5) return callback(err5);
							fs2.symlink(srcpath, dstpath, type2, callback);
						});
					});
				});
			});
		});
	}
	function createSymlinkSync(srcpath, dstpath, type$1) {
		if (fs2.existsSync(dstpath)) return void 0;
		const relative = symlinkPathsSync(srcpath, dstpath);
		srcpath = relative.toDst;
		type$1 = symlinkTypeSync(relative.toCwd, type$1);
		const dir = path$3.dirname(dstpath);
		if (fs2.existsSync(dir)) return fs2.symlinkSync(srcpath, dstpath, type$1);
		mkdirsSync(dir);
		return fs2.symlinkSync(srcpath, dstpath, type$1);
	}
	symlink = {
		createSymlink: u(createSymlink),
		createSymlinkSync
	};
	return symlink;
}
var ensure;
var hasRequiredEnsure;
function requireEnsure() {
	if (hasRequiredEnsure) return ensure;
	hasRequiredEnsure = 1;
	const file2 = requireFile$1();
	const link2 = requireLink();
	const symlink2 = requireSymlink();
	ensure = {
		createFile: file2.createFile,
		createFileSync: file2.createFileSync,
		ensureFile: file2.createFile,
		ensureFileSync: file2.createFileSync,
		createLink: link2.createLink,
		createLinkSync: link2.createLinkSync,
		ensureLink: link2.createLink,
		ensureLinkSync: link2.createLinkSync,
		createSymlink: symlink2.createSymlink,
		createSymlinkSync: symlink2.createSymlinkSync,
		ensureSymlink: symlink2.createSymlink,
		ensureSymlinkSync: symlink2.createSymlinkSync
	};
	return ensure;
}
var jsonfile_1;
var hasRequiredJsonfile$1;
function requireJsonfile$1() {
	if (hasRequiredJsonfile$1) return jsonfile_1;
	hasRequiredJsonfile$1 = 1;
	var _fs;
	try {
		_fs = requireGracefulFs();
	} catch (_) {
		_fs = fs;
	}
	function readFile(file2, options, callback) {
		if (callback == null) {
			callback = options;
			options = {};
		}
		if (typeof options === "string") options = { encoding: options };
		options = options || {};
		var fs2 = options.fs || _fs;
		var shouldThrow = true;
		if ("throws" in options) shouldThrow = options.throws;
		fs2.readFile(file2, options, function(err, data$1) {
			if (err) return callback(err);
			data$1 = stripBom(data$1);
			var obj;
			try {
				obj = JSON.parse(data$1, options ? options.reviver : null);
			} catch (err2) {
				if (shouldThrow) {
					err2.message = file2 + ": " + err2.message;
					return callback(err2);
				} else return callback(null, null);
			}
			callback(null, obj);
		});
	}
	function readFileSync(file2, options) {
		options = options || {};
		if (typeof options === "string") options = { encoding: options };
		var fs2 = options.fs || _fs;
		var shouldThrow = true;
		if ("throws" in options) shouldThrow = options.throws;
		try {
			var content = fs2.readFileSync(file2, options);
			content = stripBom(content);
			return JSON.parse(content, options.reviver);
		} catch (err) {
			if (shouldThrow) {
				err.message = file2 + ": " + err.message;
				throw err;
			} else return null;
		}
	}
	function stringify(obj, options) {
		var spaces;
		var EOL = "\n";
		if (typeof options === "object" && options !== null) {
			if (options.spaces) spaces = options.spaces;
			if (options.EOL) EOL = options.EOL;
		}
		return JSON.stringify(obj, options ? options.replacer : null, spaces).replace(/\n/g, EOL) + EOL;
	}
	function writeFile(file2, obj, options, callback) {
		if (callback == null) {
			callback = options;
			options = {};
		}
		options = options || {};
		var fs2 = options.fs || _fs;
		var str = "";
		try {
			str = stringify(obj, options);
		} catch (err) {
			if (callback) callback(err, null);
			return;
		}
		fs2.writeFile(file2, str, options, callback);
	}
	function writeFileSync$1(file2, obj, options) {
		options = options || {};
		var fs2 = options.fs || _fs;
		var str = stringify(obj, options);
		return fs2.writeFileSync(file2, str, options);
	}
	function stripBom(content) {
		if (Buffer.isBuffer(content)) content = content.toString("utf8");
		content = content.replace(/^\uFEFF/, "");
		return content;
	}
	jsonfile_1 = {
		readFile,
		readFileSync,
		writeFile,
		writeFileSync: writeFileSync$1
	};
	return jsonfile_1;
}
var jsonfile;
var hasRequiredJsonfile;
function requireJsonfile() {
	if (hasRequiredJsonfile) return jsonfile;
	hasRequiredJsonfile = 1;
	const u = requireUniversalify().fromCallback;
	const jsonFile = requireJsonfile$1();
	jsonfile = {
		readJson: u(jsonFile.readFile),
		readJsonSync: jsonFile.readFileSync,
		writeJson: u(jsonFile.writeFile),
		writeJsonSync: jsonFile.writeFileSync
	};
	return jsonfile;
}
var outputJson_1;
var hasRequiredOutputJson;
function requireOutputJson() {
	if (hasRequiredOutputJson) return outputJson_1;
	hasRequiredOutputJson = 1;
	const path$3 = path$1;
	const mkdir = requireMkdirs();
	const pathExists = requirePathExists().pathExists;
	const jsonFile = requireJsonfile();
	function outputJson(file2, data$1, options, callback) {
		if (typeof options === "function") {
			callback = options;
			options = {};
		}
		const dir = path$3.dirname(file2);
		pathExists(dir, (err, itDoes) => {
			if (err) return callback(err);
			if (itDoes) return jsonFile.writeJson(file2, data$1, options, callback);
			mkdir.mkdirs(dir, (err2) => {
				if (err2) return callback(err2);
				jsonFile.writeJson(file2, data$1, options, callback);
			});
		});
	}
	outputJson_1 = outputJson;
	return outputJson_1;
}
var outputJsonSync_1;
var hasRequiredOutputJsonSync;
function requireOutputJsonSync() {
	if (hasRequiredOutputJsonSync) return outputJsonSync_1;
	hasRequiredOutputJsonSync = 1;
	const fs2 = requireGracefulFs();
	const path$3 = path$1;
	const mkdir = requireMkdirs();
	const jsonFile = requireJsonfile();
	function outputJsonSync(file2, data$1, options) {
		const dir = path$3.dirname(file2);
		if (!fs2.existsSync(dir)) mkdir.mkdirsSync(dir);
		jsonFile.writeJsonSync(file2, data$1, options);
	}
	outputJsonSync_1 = outputJsonSync;
	return outputJsonSync_1;
}
var json$1;
var hasRequiredJson$1;
function requireJson$1() {
	if (hasRequiredJson$1) return json$1;
	hasRequiredJson$1 = 1;
	const u = requireUniversalify().fromCallback;
	const jsonFile = requireJsonfile();
	jsonFile.outputJson = u(requireOutputJson());
	jsonFile.outputJsonSync = requireOutputJsonSync();
	jsonFile.outputJSON = jsonFile.outputJson;
	jsonFile.outputJSONSync = jsonFile.outputJsonSync;
	jsonFile.writeJSON = jsonFile.writeJson;
	jsonFile.writeJSONSync = jsonFile.writeJsonSync;
	jsonFile.readJSON = jsonFile.readJson;
	jsonFile.readJSONSync = jsonFile.readJsonSync;
	json$1 = jsonFile;
	return json$1;
}
var moveSync_1;
var hasRequiredMoveSync$1;
function requireMoveSync$1() {
	if (hasRequiredMoveSync$1) return moveSync_1;
	hasRequiredMoveSync$1 = 1;
	const fs2 = requireGracefulFs();
	const path$3 = path$1;
	const copySync2 = requireCopySync().copySync;
	const removeSync = requireRemove().removeSync;
	const mkdirpSync = requireMkdirs().mkdirpSync;
	const stat2 = requireStat();
	function moveSync2(src, dest, opts) {
		opts = opts || {};
		const overwrite = opts.overwrite || opts.clobber || false;
		const { srcStat } = stat2.checkPathsSync(src, dest, "move");
		stat2.checkParentPathsSync(src, srcStat, dest, "move");
		mkdirpSync(path$3.dirname(dest));
		return doRename(src, dest, overwrite);
	}
	function doRename(src, dest, overwrite) {
		if (overwrite) {
			removeSync(dest);
			return rename(src, dest, overwrite);
		}
		if (fs2.existsSync(dest)) throw new Error("dest already exists.");
		return rename(src, dest, overwrite);
	}
	function rename(src, dest, overwrite) {
		try {
			fs2.renameSync(src, dest);
		} catch (err) {
			if (err.code !== "EXDEV") throw err;
			return moveAcrossDevice(src, dest, overwrite);
		}
	}
	function moveAcrossDevice(src, dest, overwrite) {
		copySync2(src, dest, {
			overwrite,
			errorOnExist: true
		});
		return removeSync(src);
	}
	moveSync_1 = moveSync2;
	return moveSync_1;
}
var moveSync;
var hasRequiredMoveSync;
function requireMoveSync() {
	if (hasRequiredMoveSync) return moveSync;
	hasRequiredMoveSync = 1;
	moveSync = { moveSync: requireMoveSync$1() };
	return moveSync;
}
var move_1;
var hasRequiredMove$1;
function requireMove$1() {
	if (hasRequiredMove$1) return move_1;
	hasRequiredMove$1 = 1;
	const fs2 = requireGracefulFs();
	const path$3 = path$1;
	const copy2 = requireCopy().copy;
	const remove2 = requireRemove().remove;
	const mkdirp = requireMkdirs().mkdirp;
	const pathExists = requirePathExists().pathExists;
	const stat2 = requireStat();
	function move2(src, dest, opts, cb) {
		if (typeof opts === "function") {
			cb = opts;
			opts = {};
		}
		const overwrite = opts.overwrite || opts.clobber || false;
		stat2.checkPaths(src, dest, "move", (err, stats) => {
			if (err) return cb(err);
			const { srcStat } = stats;
			stat2.checkParentPaths(src, srcStat, dest, "move", (err2) => {
				if (err2) return cb(err2);
				mkdirp(path$3.dirname(dest), (err3) => {
					if (err3) return cb(err3);
					return doRename(src, dest, overwrite, cb);
				});
			});
		});
	}
	function doRename(src, dest, overwrite, cb) {
		if (overwrite) return remove2(dest, (err) => {
			if (err) return cb(err);
			return rename(src, dest, overwrite, cb);
		});
		pathExists(dest, (err, destExists) => {
			if (err) return cb(err);
			if (destExists) return cb(/* @__PURE__ */ new Error("dest already exists."));
			return rename(src, dest, overwrite, cb);
		});
	}
	function rename(src, dest, overwrite, cb) {
		fs2.rename(src, dest, (err) => {
			if (!err) return cb();
			if (err.code !== "EXDEV") return cb(err);
			return moveAcrossDevice(src, dest, overwrite, cb);
		});
	}
	function moveAcrossDevice(src, dest, overwrite, cb) {
		copy2(src, dest, {
			overwrite,
			errorOnExist: true
		}, (err) => {
			if (err) return cb(err);
			return remove2(src, cb);
		});
	}
	move_1 = move2;
	return move_1;
}
var move;
var hasRequiredMove;
function requireMove() {
	if (hasRequiredMove) return move;
	hasRequiredMove = 1;
	const u = requireUniversalify().fromCallback;
	move = { move: u(requireMove$1()) };
	return move;
}
var output;
var hasRequiredOutput;
function requireOutput() {
	if (hasRequiredOutput) return output;
	hasRequiredOutput = 1;
	const u = requireUniversalify().fromCallback;
	const fs2 = requireGracefulFs();
	const path$3 = path$1;
	const mkdir = requireMkdirs();
	const pathExists = requirePathExists().pathExists;
	function outputFile(file2, data$1, encoding$1, callback) {
		if (typeof encoding$1 === "function") {
			callback = encoding$1;
			encoding$1 = "utf8";
		}
		const dir = path$3.dirname(file2);
		pathExists(dir, (err, itDoes) => {
			if (err) return callback(err);
			if (itDoes) return fs2.writeFile(file2, data$1, encoding$1, callback);
			mkdir.mkdirs(dir, (err2) => {
				if (err2) return callback(err2);
				fs2.writeFile(file2, data$1, encoding$1, callback);
			});
		});
	}
	function outputFileSync(file2, ...args) {
		const dir = path$3.dirname(file2);
		if (fs2.existsSync(dir)) return fs2.writeFileSync(file2, ...args);
		mkdir.mkdirsSync(dir);
		fs2.writeFileSync(file2, ...args);
	}
	output = {
		outputFile: u(outputFile),
		outputFileSync
	};
	return output;
}
var hasRequiredLib$1$1;
function requireLib$1$1() {
	if (hasRequiredLib$1$1) return lib$1$1.exports;
	hasRequiredLib$1$1 = 1;
	(function(module$1) {
		module$1.exports = Object.assign({}, requireFs(), requireCopySync(), requireCopy(), requireEmpty(), requireEnsure(), requireJson$1(), requireMkdirs(), requireMoveSync(), requireMove(), requireOutput(), requirePathExists(), requireRemove());
		const fs2 = fs;
		if (Object.getOwnPropertyDescriptor(fs2, "promises")) Object.defineProperty(module$1.exports, "promises", { get() {
			return fs2.promises;
		} });
	})(lib$1$1);
	return lib$1$1.exports;
}
var now;
var hasRequiredNow;
function requireNow() {
	if (hasRequiredNow) return now;
	hasRequiredNow = 1;
	now = () => /* @__PURE__ */ new Date();
	return now;
}
var fileNameFormatter;
var hasRequiredFileNameFormatter;
function requireFileNameFormatter() {
	if (hasRequiredFileNameFormatter) return fileNameFormatter;
	hasRequiredFileNameFormatter = 1;
	const debug$2 = requireBrowser$2()("streamroller:fileNameFormatter");
	const path$3 = path$1;
	const ZIP_EXT = ".gz";
	const DEFAULT_FILENAME_SEP = ".";
	fileNameFormatter = ({ file: file2, keepFileExt, needsIndex, alwaysIncludeDate, compress, fileNameSep }) => {
		let FILENAME_SEP = fileNameSep || DEFAULT_FILENAME_SEP;
		const dirAndName = path$3.join(file2.dir, file2.name);
		const ext = (f) => f + file2.ext;
		const index$1 = (f, i, d$1) => (needsIndex || !d$1) && i ? f + FILENAME_SEP + i : f;
		const date$2 = (f, i, d$1) => {
			return (i > 0 || alwaysIncludeDate) && d$1 ? f + FILENAME_SEP + d$1 : f;
		};
		const gzip = (f, i) => i && compress ? f + ZIP_EXT : f;
		const parts = keepFileExt ? [
			date$2,
			index$1,
			ext,
			gzip
		] : [
			ext,
			date$2,
			index$1,
			gzip
		];
		return ({ date: date2, index: index2 }) => {
			debug$2(`_formatFileName: date=${date2}, index=${index2}`);
			return parts.reduce((filename, part) => part(filename, index2, date2), dirAndName);
		};
	};
	return fileNameFormatter;
}
var fileNameParser;
var hasRequiredFileNameParser;
function requireFileNameParser() {
	if (hasRequiredFileNameParser) return fileNameParser;
	hasRequiredFileNameParser = 1;
	const debug$2 = requireBrowser$2()("streamroller:fileNameParser");
	const ZIP_EXT = ".gz";
	const format = requireLib$2();
	const DEFAULT_FILENAME_SEP = ".";
	fileNameParser = ({ file: file2, keepFileExt, pattern, fileNameSep }) => {
		let FILENAME_SEP = fileNameSep || DEFAULT_FILENAME_SEP;
		const zip = (f, p) => {
			if (f.endsWith(ZIP_EXT)) {
				debug$2("it is gzipped");
				p.isCompressed = true;
				return f.slice(0, -3);
			}
			return f;
		};
		const __NOT_MATCHING__ = "__NOT_MATCHING__";
		const extAtEnd = (f) => {
			if (f.startsWith(file2.name) && f.endsWith(file2.ext)) {
				debug$2("it starts and ends with the right things");
				return f.slice(file2.name.length + 1, -1 * file2.ext.length);
			}
			return __NOT_MATCHING__;
		};
		const extInMiddle = (f) => {
			if (f.startsWith(file2.base)) {
				debug$2("it starts with the right things");
				return f.slice(file2.base.length + 1);
			}
			return __NOT_MATCHING__;
		};
		const dateAndIndex = (f, p) => {
			const items = f.split(FILENAME_SEP);
			let indexStr = items[items.length - 1];
			debug$2("items: ", items, ", indexStr: ", indexStr);
			let dateStr = f;
			if (indexStr !== void 0 && indexStr.match(/^\d+$/)) {
				dateStr = f.slice(0, -1 * (indexStr.length + 1));
				debug$2(`dateStr is ${dateStr}`);
				if (pattern && !dateStr) {
					dateStr = indexStr;
					indexStr = "0";
				}
			} else indexStr = "0";
			try {
				const date$2 = format.parse(pattern, dateStr, new Date(0, 0));
				if (format.asString(pattern, date$2) !== dateStr) return f;
				p.index = parseInt(indexStr, 10);
				p.date = dateStr;
				p.timestamp = date$2.getTime();
				return "";
			} catch (e) {
				debug$2(`Problem parsing ${dateStr} as ${pattern}, error was: `, e);
				return f;
			}
		};
		const index$1 = (f, p) => {
			if (f.match(/^\d+$/)) {
				debug$2("it has an index");
				p.index = parseInt(f, 10);
				return "";
			}
			return f;
		};
		let parts = [
			zip,
			keepFileExt ? extAtEnd : extInMiddle,
			pattern ? dateAndIndex : index$1
		];
		return (filename) => {
			let result = {
				filename,
				index: 0,
				isCompressed: false
			};
			return parts.reduce((remains, part) => part(remains, result), filename) ? null : result;
		};
	};
	return fileNameParser;
}
var moveAndMaybeCompressFile_1;
var hasRequiredMoveAndMaybeCompressFile;
function requireMoveAndMaybeCompressFile() {
	if (hasRequiredMoveAndMaybeCompressFile) return moveAndMaybeCompressFile_1;
	hasRequiredMoveAndMaybeCompressFile = 1;
	const debug$2 = requireBrowser$2()("streamroller:moveAndMaybeCompressFile");
	const fs2 = requireLib$1$1();
	const zlib = require$$2;
	const _parseOption = function(rawOptions) {
		const defaultOptions = {
			mode: parseInt("0600", 8),
			compress: false
		};
		const options = Object.assign({}, defaultOptions, rawOptions);
		debug$2(`_parseOption: moveAndMaybeCompressFile called with option=${JSON.stringify(options)}`);
		return options;
	};
	const moveAndMaybeCompressFile = async (sourceFilePath, targetFilePath, options) => {
		options = _parseOption(options);
		if (sourceFilePath === targetFilePath) {
			debug$2(`moveAndMaybeCompressFile: source and target are the same, not doing anything`);
			return;
		}
		if (await fs2.pathExists(sourceFilePath)) {
			debug$2(`moveAndMaybeCompressFile: moving file from ${sourceFilePath} to ${targetFilePath} ${options.compress ? "with" : "without"} compress`);
			if (options.compress) await new Promise((resolve, reject) => {
				let isCreated = false;
				const writeStream = fs2.createWriteStream(targetFilePath, {
					mode: options.mode,
					flags: "wx"
				}).on("open", () => {
					isCreated = true;
					const readStream$1 = fs2.createReadStream(sourceFilePath).on("open", () => {
						readStream$1.pipe(zlib.createGzip()).pipe(writeStream);
					}).on("error", (e) => {
						debug$2(`moveAndMaybeCompressFile: error reading ${sourceFilePath}`, e);
						writeStream.destroy(e);
					});
				}).on("finish", () => {
					debug$2(`moveAndMaybeCompressFile: finished compressing ${targetFilePath}, deleting ${sourceFilePath}`);
					fs2.unlink(sourceFilePath).then(resolve).catch((e) => {
						debug$2(`moveAndMaybeCompressFile: error deleting ${sourceFilePath}, truncating instead`, e);
						fs2.truncate(sourceFilePath).then(resolve).catch((e2) => {
							debug$2(`moveAndMaybeCompressFile: error truncating ${sourceFilePath}`, e2);
							reject(e2);
						});
					});
				}).on("error", (e) => {
					if (!isCreated) {
						debug$2(`moveAndMaybeCompressFile: error creating ${targetFilePath}`, e);
						reject(e);
					} else {
						debug$2(`moveAndMaybeCompressFile: error writing ${targetFilePath}, deleting`, e);
						fs2.unlink(targetFilePath).then(() => {
							reject(e);
						}).catch((e2) => {
							debug$2(`moveAndMaybeCompressFile: error deleting ${targetFilePath}`, e2);
							reject(e2);
						});
					}
				});
			}).catch(() => {});
			else {
				debug$2(`moveAndMaybeCompressFile: renaming ${sourceFilePath} to ${targetFilePath}`);
				try {
					await fs2.move(sourceFilePath, targetFilePath, { overwrite: true });
				} catch (e) {
					debug$2(`moveAndMaybeCompressFile: error renaming ${sourceFilePath} to ${targetFilePath}`, e);
					if (e.code !== "ENOENT") {
						debug$2(`moveAndMaybeCompressFile: trying copy+truncate instead`);
						try {
							await fs2.copy(sourceFilePath, targetFilePath, { overwrite: true });
							await fs2.truncate(sourceFilePath);
						} catch (e2) {
							debug$2(`moveAndMaybeCompressFile: error copy+truncate`, e2);
						}
					}
				}
			}
		}
	};
	moveAndMaybeCompressFile_1 = moveAndMaybeCompressFile;
	return moveAndMaybeCompressFile_1;
}
var RollingFileWriteStream_1;
var hasRequiredRollingFileWriteStream;
function requireRollingFileWriteStream() {
	if (hasRequiredRollingFileWriteStream) return RollingFileWriteStream_1;
	hasRequiredRollingFileWriteStream = 1;
	const debug$2 = requireBrowser$2()("streamroller:RollingFileWriteStream");
	const fs2 = requireLib$1$1();
	const path$3 = path$1;
	const os$1 = require$$1$1;
	const newNow = requireNow();
	const format = requireLib$2();
	const { Writable: Writable$1 } = require$$13;
	const fileNameFormatter2 = requireFileNameFormatter();
	const fileNameParser2 = requireFileNameParser();
	const moveAndMaybeCompressFile = requireMoveAndMaybeCompressFile();
	const deleteFiles = (fileNames) => {
		debug$2(`deleteFiles: files to delete: ${fileNames}`);
		return Promise.all(fileNames.map((f) => fs2.unlink(f).catch((e) => {
			debug$2(`deleteFiles: error when unlinking ${f}, ignoring. Error was ${e}`);
		})));
	};
	class RollingFileWriteStream extends Writable$1 {
		/**
		* Create a RollingFileWriteStream
		* @constructor
		* @param {string} filePath - The file path to write.
		* @param {object} options - The extra options
		* @param {number} options.numToKeep - The max numbers of files to keep.
		* @param {number} options.maxSize - The maxSize one file can reach. Unit is Byte.
		*                                   This should be more than 1024. The default is 0.
		*                                   If not specified or 0, then no log rolling will happen.
		* @param {string} options.mode - The mode of the files. The default is '0600'. Refer to stream.writable for more.
		* @param {string} options.flags - The default is 'a'. Refer to stream.flags for more.
		* @param {boolean} options.compress - Whether to compress backup files.
		* @param {boolean} options.keepFileExt - Whether to keep the file extension.
		* @param {string} options.pattern - The date string pattern in the file name.
		* @param {boolean} options.alwaysIncludePattern - Whether to add date to the name of the first file.
		*/
		constructor(filePath, options) {
			debug$2(`constructor: creating RollingFileWriteStream. path=${filePath}`);
			if (typeof filePath !== "string" || filePath.length === 0) throw new Error(`Invalid filename: ${filePath}`);
			else if (filePath.endsWith(path$3.sep)) throw new Error(`Filename is a directory: ${filePath}`);
			else if (filePath.indexOf(`~${path$3.sep}`) === 0) filePath = filePath.replace("~", os$1.homedir());
			super(options);
			this.options = this._parseOption(options);
			this.fileObject = path$3.parse(filePath);
			if (this.fileObject.dir === "") this.fileObject = path$3.parse(path$3.join(process.cwd(), filePath));
			this.fileFormatter = fileNameFormatter2({
				file: this.fileObject,
				alwaysIncludeDate: this.options.alwaysIncludePattern,
				needsIndex: this.options.maxSize < Number.MAX_SAFE_INTEGER,
				compress: this.options.compress,
				keepFileExt: this.options.keepFileExt,
				fileNameSep: this.options.fileNameSep
			});
			this.fileNameParser = fileNameParser2({
				file: this.fileObject,
				keepFileExt: this.options.keepFileExt,
				pattern: this.options.pattern,
				fileNameSep: this.options.fileNameSep
			});
			this.state = { currentSize: 0 };
			if (this.options.pattern) this.state.currentDate = format(this.options.pattern, newNow());
			this.filename = this.fileFormatter({
				index: 0,
				date: this.state.currentDate
			});
			if ([
				"a",
				"a+",
				"as",
				"as+"
			].includes(this.options.flags)) this._setExistingSizeAndDate();
			debug$2(`constructor: create new file ${this.filename}, state=${JSON.stringify(this.state)}`);
			this._renewWriteStream();
		}
		_setExistingSizeAndDate() {
			try {
				const stats = fs2.statSync(this.filename);
				this.state.currentSize = stats.size;
				if (this.options.pattern) this.state.currentDate = format(this.options.pattern, stats.mtime);
			} catch (e) {
				return;
			}
		}
		_parseOption(rawOptions) {
			const defaultOptions = {
				maxSize: 0,
				numToKeep: Number.MAX_SAFE_INTEGER,
				encoding: "utf8",
				mode: parseInt("0600", 8),
				flags: "a",
				compress: false,
				keepFileExt: false,
				alwaysIncludePattern: false
			};
			const options = Object.assign({}, defaultOptions, rawOptions);
			if (!options.maxSize) delete options.maxSize;
			else if (options.maxSize <= 0) throw new Error(`options.maxSize (${options.maxSize}) should be > 0`);
			if (options.numBackups || options.numBackups === 0) if (options.numBackups < 0) throw new Error(`options.numBackups (${options.numBackups}) should be >= 0`);
			else if (options.numBackups >= Number.MAX_SAFE_INTEGER) throw new Error(`options.numBackups (${options.numBackups}) should be < Number.MAX_SAFE_INTEGER`);
			else options.numToKeep = options.numBackups + 1;
			else if (options.numToKeep <= 0) throw new Error(`options.numToKeep (${options.numToKeep}) should be > 0`);
			debug$2(`_parseOption: creating stream with option=${JSON.stringify(options)}`);
			return options;
		}
		_final(callback) {
			this.currentFileStream.end("", this.options.encoding, callback);
		}
		_write(chunk, encoding$1, callback) {
			this._shouldRoll().then(() => {
				debug$2(`_write: writing chunk. file=${this.currentFileStream.path} state=${JSON.stringify(this.state)} chunk=${chunk}`);
				this.currentFileStream.write(chunk, encoding$1, (e) => {
					this.state.currentSize += chunk.length;
					callback(e);
				});
			});
		}
		async _shouldRoll() {
			if (this._dateChanged() || this._tooBig()) {
				debug$2(`_shouldRoll: rolling because dateChanged? ${this._dateChanged()} or tooBig? ${this._tooBig()}`);
				await this._roll();
			}
		}
		_dateChanged() {
			return this.state.currentDate && this.state.currentDate !== format(this.options.pattern, newNow());
		}
		_tooBig() {
			return this.state.currentSize >= this.options.maxSize;
		}
		_roll() {
			debug$2(`_roll: closing the current stream`);
			return new Promise((resolve, reject) => {
				this.currentFileStream.end("", this.options.encoding, () => {
					this._moveOldFiles().then(resolve).catch(reject);
				});
			});
		}
		async _moveOldFiles() {
			const files = await this._getExistingFiles();
			const todaysFiles = this.state.currentDate ? files.filter((f) => f.date === this.state.currentDate) : files;
			for (let i = todaysFiles.length; i >= 0; i--) {
				debug$2(`_moveOldFiles: i = ${i}`);
				await moveAndMaybeCompressFile(this.fileFormatter({
					date: this.state.currentDate,
					index: i
				}), this.fileFormatter({
					date: this.state.currentDate,
					index: i + 1
				}), {
					compress: this.options.compress && i === 0,
					mode: this.options.mode
				});
			}
			this.state.currentSize = 0;
			this.state.currentDate = this.state.currentDate ? format(this.options.pattern, newNow()) : null;
			debug$2(`_moveOldFiles: finished rolling files. state=${JSON.stringify(this.state)}`);
			this._renewWriteStream();
			await new Promise((resolve, reject) => {
				this.currentFileStream.write("", "utf8", () => {
					this._clean().then(resolve).catch(reject);
				});
			});
		}
		async _getExistingFiles() {
			const files = await fs2.readdir(this.fileObject.dir).catch(
				/* istanbul ignore next: will not happen on windows */
				() => []
			);
			debug$2(`_getExistingFiles: files=${files}`);
			const existingFileDetails = files.map((n) => this.fileNameParser(n)).filter((n) => n);
			const getKey = (n) => (n.timestamp ? n.timestamp : newNow().getTime()) - n.index;
			existingFileDetails.sort((a, b) => getKey(a) - getKey(b));
			return existingFileDetails;
		}
		_renewWriteStream() {
			const filePath = this.fileFormatter({
				date: this.state.currentDate,
				index: 0
			});
			const mkdir = (dir) => {
				try {
					return fs2.mkdirSync(dir, { recursive: true });
				} catch (e) {
					if (e.code === "ENOENT") {
						mkdir(path$3.dirname(dir));
						return mkdir(dir);
					}
					if (e.code !== "EEXIST" && e.code !== "EROFS") throw e;
					else try {
						if (fs2.statSync(dir).isDirectory()) return dir;
						throw e;
					} catch (err) {
						throw e;
					}
				}
			};
			mkdir(this.fileObject.dir);
			const ops = {
				flags: this.options.flags,
				encoding: this.options.encoding,
				mode: this.options.mode
			};
			const renameKey = function(obj, oldKey, newKey) {
				obj[newKey] = obj[oldKey];
				delete obj[oldKey];
				return obj;
			};
			fs2.appendFileSync(filePath, "", renameKey({ ...ops }, "flags", "flag"));
			this.currentFileStream = fs2.createWriteStream(filePath, ops);
			this.currentFileStream.on("error", (e) => {
				this.emit("error", e);
			});
		}
		async _clean() {
			const existingFileDetails = await this._getExistingFiles();
			debug$2(`_clean: numToKeep = ${this.options.numToKeep}, existingFiles = ${existingFileDetails.length}`);
			debug$2("_clean: existing files are: ", existingFileDetails);
			if (this._tooManyFiles(existingFileDetails.length)) await deleteFiles(existingFileDetails.slice(0, existingFileDetails.length - this.options.numToKeep).map((f) => path$3.format({
				dir: this.fileObject.dir,
				base: f.filename
			})));
		}
		_tooManyFiles(numFiles) {
			return this.options.numToKeep > 0 && numFiles > this.options.numToKeep;
		}
	}
	RollingFileWriteStream_1 = RollingFileWriteStream;
	return RollingFileWriteStream_1;
}
var RollingFileStream_1;
var hasRequiredRollingFileStream;
function requireRollingFileStream() {
	if (hasRequiredRollingFileStream) return RollingFileStream_1;
	hasRequiredRollingFileStream = 1;
	const RollingFileWriteStream = requireRollingFileWriteStream();
	class RollingFileStream extends RollingFileWriteStream {
		constructor(filename, size, backups, options) {
			if (!options) options = {};
			if (size) options.maxSize = size;
			if (!options.numBackups && options.numBackups !== 0) {
				if (!backups && backups !== 0) backups = 1;
				options.numBackups = backups;
			}
			super(filename, options);
			this.backups = options.numBackups;
			this.size = this.options.maxSize;
		}
		get theStream() {
			return this.currentFileStream;
		}
	}
	RollingFileStream_1 = RollingFileStream;
	return RollingFileStream_1;
}
var DateRollingFileStream_1;
var hasRequiredDateRollingFileStream;
function requireDateRollingFileStream() {
	if (hasRequiredDateRollingFileStream) return DateRollingFileStream_1;
	hasRequiredDateRollingFileStream = 1;
	const RollingFileWriteStream = requireRollingFileWriteStream();
	class DateRollingFileStream extends RollingFileWriteStream {
		constructor(filename, pattern, options) {
			if (pattern && typeof pattern === "object") {
				options = pattern;
				pattern = null;
			}
			if (!options) options = {};
			if (!pattern) pattern = "yyyy-MM-dd";
			options.pattern = pattern;
			if (!options.numBackups && options.numBackups !== 0) {
				if (!options.daysToKeep && options.daysToKeep !== 0) options.daysToKeep = 1;
				else process.emitWarning("options.daysToKeep is deprecated due to the confusion it causes when used together with file size rolling. Please use options.numBackups instead.", "DeprecationWarning", "streamroller-DEP0001");
				options.numBackups = options.daysToKeep;
			} else options.daysToKeep = options.numBackups;
			super(filename, options);
			this.mode = this.options.mode;
		}
		get theStream() {
			return this.currentFileStream;
		}
	}
	DateRollingFileStream_1 = DateRollingFileStream;
	return DateRollingFileStream_1;
}
var lib$3;
var hasRequiredLib$3;
function requireLib$3() {
	if (hasRequiredLib$3) return lib$3;
	hasRequiredLib$3 = 1;
	lib$3 = {
		RollingFileWriteStream: requireRollingFileWriteStream(),
		RollingFileStream: requireRollingFileStream(),
		DateRollingFileStream: requireDateRollingFileStream()
	};
	return lib$3;
}
var hasRequiredFile;
function requireFile() {
	if (hasRequiredFile) return file$1;
	hasRequiredFile = 1;
	const debug$2 = requireBrowser$2()("log4js:file");
	const path$3 = path$1;
	const streams$1 = requireLib$3();
	const os$1 = require$$1$1;
	const eol = os$1.EOL;
	let mainSighupListenerStarted = false;
	const sighupListeners = /* @__PURE__ */ new Set();
	function mainSighupHandler() {
		sighupListeners.forEach((app$3) => {
			app$3.sighupHandler();
		});
	}
	function fileAppender(file2, layout, logSize, numBackups, options, timezoneOffset) {
		if (typeof file2 !== "string" || file2.length === 0) throw new Error(`Invalid filename: ${file2}`);
		else if (file2.endsWith(path$3.sep)) throw new Error(`Filename is a directory: ${file2}`);
		else if (file2.indexOf(`~${path$3.sep}`) === 0) file2 = file2.replace("~", os$1.homedir());
		file2 = path$3.normalize(file2);
		numBackups = !numBackups && numBackups !== 0 ? 5 : numBackups;
		debug$2("Creating file appender (", file2, ", ", logSize, ", ", numBackups, ", ", options, ", ", timezoneOffset, ")");
		function openTheStream(filePath, fileSize, numFiles, opt) {
			const stream = new streams$1.RollingFileStream(filePath, fileSize, numFiles, opt);
			stream.on("error", (err) => {
				console.error("log4js.fileAppender - Writing to file %s, error happened ", filePath, err);
			});
			stream.on("drain", () => {
				process.emit("log4js:pause", false);
			});
			return stream;
		}
		let writer = openTheStream(file2, logSize, numBackups, options);
		const app$3 = function(loggingEvent) {
			if (!writer.writable) return;
			if (options.removeColor === true) {
				const regex = /\x1b[[0-9;]*m/g;
				loggingEvent.data = loggingEvent.data.map((d$1) => {
					if (typeof d$1 === "string") return d$1.replace(regex, "");
					return d$1;
				});
			}
			if (!writer.write(layout(loggingEvent, timezoneOffset) + eol, "utf8")) process.emit("log4js:pause", true);
		};
		app$3.reopen = function() {
			writer.end(() => {
				writer = openTheStream(file2, logSize, numBackups, options);
			});
		};
		app$3.sighupHandler = function() {
			debug$2("SIGHUP handler called.");
			app$3.reopen();
		};
		app$3.shutdown = function(complete) {
			sighupListeners.delete(app$3);
			if (sighupListeners.size === 0 && mainSighupListenerStarted) {
				process.removeListener("SIGHUP", mainSighupHandler);
				mainSighupListenerStarted = false;
			}
			writer.end("", "utf-8", complete);
		};
		sighupListeners.add(app$3);
		if (!mainSighupListenerStarted) {
			process.on("SIGHUP", mainSighupHandler);
			mainSighupListenerStarted = true;
		}
		return app$3;
	}
	function configure2(config$2, layouts2) {
		let layout = layouts2.basicLayout;
		if (config$2.layout) layout = layouts2.layout(config$2.layout.type, config$2.layout);
		config$2.mode = config$2.mode || 384;
		return fileAppender(config$2.filename, layout, config$2.maxLogSize, config$2.backups, config$2, config$2.timezoneOffset);
	}
	file$1.configure = configure2;
	return file$1;
}
var dateFile = {};
var hasRequiredDateFile;
function requireDateFile() {
	if (hasRequiredDateFile) return dateFile;
	hasRequiredDateFile = 1;
	const streams$1 = requireLib$3();
	const eol = require$$1$1.EOL;
	function openTheStream(filename, pattern, options) {
		const stream = new streams$1.DateRollingFileStream(filename, pattern, options);
		stream.on("error", (err) => {
			console.error("log4js.dateFileAppender - Writing to file %s, error happened ", filename, err);
		});
		stream.on("drain", () => {
			process.emit("log4js:pause", false);
		});
		return stream;
	}
	function appender(filename, pattern, layout, options, timezoneOffset) {
		options.maxSize = options.maxLogSize;
		const writer = openTheStream(filename, pattern, options);
		const app$3 = function(logEvent) {
			if (!writer.writable) return;
			if (!writer.write(layout(logEvent, timezoneOffset) + eol, "utf8")) process.emit("log4js:pause", true);
		};
		app$3.shutdown = function(complete) {
			writer.end("", "utf-8", complete);
		};
		return app$3;
	}
	function configure2(config$2, layouts2) {
		let layout = layouts2.basicLayout;
		if (config$2.layout) layout = layouts2.layout(config$2.layout.type, config$2.layout);
		if (!config$2.alwaysIncludePattern) config$2.alwaysIncludePattern = false;
		config$2.mode = config$2.mode || 384;
		return appender(config$2.filename, config$2.pattern, layout, config$2, config$2.timezoneOffset);
	}
	dateFile.configure = configure2;
	return dateFile;
}
var fileSync = {};
var hasRequiredFileSync;
function requireFileSync$1() {
	if (hasRequiredFileSync) return fileSync;
	hasRequiredFileSync = 1;
	const debug$2 = requireBrowser$2()("log4js:fileSync");
	const path$3 = path$1;
	const fs2 = fs;
	const os$1 = require$$1$1;
	const eol = os$1.EOL;
	function touchFile(file2, options) {
		const mkdir = (dir) => {
			try {
				return fs2.mkdirSync(dir, { recursive: true });
			} catch (e) {
				if (e.code === "ENOENT") {
					mkdir(path$3.dirname(dir));
					return mkdir(dir);
				}
				if (e.code !== "EEXIST" && e.code !== "EROFS") throw e;
				else try {
					if (fs2.statSync(dir).isDirectory()) return dir;
					throw e;
				} catch (err) {
					throw e;
				}
			}
		};
		mkdir(path$3.dirname(file2));
		fs2.appendFileSync(file2, "", {
			mode: options.mode,
			flag: options.flags
		});
	}
	class RollingFileSync {
		constructor(filename, maxLogSize, backups, options) {
			debug$2("In RollingFileStream");
			if (maxLogSize < 0) throw new Error(`maxLogSize (${maxLogSize}) should be > 0`);
			this.filename = filename;
			this.size = maxLogSize;
			this.backups = backups;
			this.options = options;
			this.currentSize = 0;
			function currentFileSize(file2) {
				let fileSize = 0;
				try {
					fileSize = fs2.statSync(file2).size;
				} catch (e) {
					touchFile(file2, options);
				}
				return fileSize;
			}
			this.currentSize = currentFileSize(this.filename);
		}
		shouldRoll() {
			debug$2("should roll with current size %d, and max size %d", this.currentSize, this.size);
			return this.currentSize >= this.size;
		}
		roll(filename) {
			const that = this;
			const nameMatcher = /* @__PURE__ */ new RegExp(`^${path$3.basename(filename)}`);
			function justTheseFiles(item) {
				return nameMatcher.test(item);
			}
			function index$1(filename_) {
				return parseInt(filename_.slice(`${path$3.basename(filename)}.`.length), 10) || 0;
			}
			function byIndex(a, b) {
				return index$1(a) - index$1(b);
			}
			function increaseFileIndex(fileToRename) {
				const idx = index$1(fileToRename);
				debug$2(`Index of ${fileToRename} is ${idx}`);
				if (that.backups === 0) fs2.truncateSync(filename, 0);
				else if (idx < that.backups) {
					try {
						fs2.unlinkSync(`${filename}.${idx + 1}`);
					} catch (e) {}
					debug$2(`Renaming ${fileToRename} -> ${filename}.${idx + 1}`);
					fs2.renameSync(path$3.join(path$3.dirname(filename), fileToRename), `${filename}.${idx + 1}`);
				}
			}
			function renameTheFiles() {
				debug$2("Renaming the old files");
				fs2.readdirSync(path$3.dirname(filename)).filter(justTheseFiles).sort(byIndex).reverse().forEach(increaseFileIndex);
			}
			debug$2("Rolling, rolling, rolling");
			renameTheFiles();
		}
		write(chunk, encoding$1) {
			const that = this;
			function writeTheChunk() {
				debug$2("writing the chunk to the file");
				that.currentSize += chunk.length;
				fs2.appendFileSync(that.filename, chunk);
			}
			debug$2("in write");
			if (this.shouldRoll()) {
				this.currentSize = 0;
				this.roll(this.filename);
			}
			writeTheChunk();
		}
	}
	function fileAppender(file2, layout, logSize, numBackups, options, timezoneOffset) {
		if (typeof file2 !== "string" || file2.length === 0) throw new Error(`Invalid filename: ${file2}`);
		else if (file2.endsWith(path$3.sep)) throw new Error(`Filename is a directory: ${file2}`);
		else if (file2.indexOf(`~${path$3.sep}`) === 0) file2 = file2.replace("~", os$1.homedir());
		file2 = path$3.normalize(file2);
		numBackups = !numBackups && numBackups !== 0 ? 5 : numBackups;
		debug$2("Creating fileSync appender (", file2, ", ", logSize, ", ", numBackups, ", ", options, ", ", timezoneOffset, ")");
		function openTheStream(filePath, fileSize, numFiles) {
			let stream;
			if (fileSize) stream = new RollingFileSync(filePath, fileSize, numFiles, options);
			else stream = ((f) => {
				touchFile(f, options);
				return { write(data$1) {
					fs2.appendFileSync(f, data$1);
				} };
			})(filePath);
			return stream;
		}
		const logFile = openTheStream(file2, logSize, numBackups);
		return (loggingEvent) => {
			logFile.write(layout(loggingEvent, timezoneOffset) + eol);
		};
	}
	function configure2(config$2, layouts2) {
		let layout = layouts2.basicLayout;
		if (config$2.layout) layout = layouts2.layout(config$2.layout.type, config$2.layout);
		const options = {
			flags: config$2.flags || "a",
			encoding: config$2.encoding || "utf8",
			mode: config$2.mode || 384
		};
		return fileAppender(config$2.filename, layout, config$2.maxLogSize, config$2.backups, options, config$2.timezoneOffset);
	}
	fileSync.configure = configure2;
	return fileSync;
}
var tcp = {};
var hasRequiredTcp;
function requireTcp() {
	if (hasRequiredTcp) return tcp;
	hasRequiredTcp = 1;
	const debug$2 = requireBrowser$2()("log4js:tcp");
	const net = require$$1$3;
	function appender(config$2, layout) {
		let canWrite = false;
		const buffer2 = [];
		let socket;
		let shutdownAttempts = 3;
		let endMsg = "__LOG4JS__";
		function write(loggingEvent) {
			debug$2("Writing log event to socket");
			canWrite = socket.write(`${layout(loggingEvent)}${endMsg}`, "utf8");
		}
		function emptyBuffer() {
			let evt;
			debug$2("emptying buffer");
			while (evt = buffer2.shift()) write(evt);
		}
		function createSocket() {
			debug$2(`appender creating socket to ${config$2.host || "localhost"}:${config$2.port || 5e3}`);
			endMsg = `${config$2.endMsg || "__LOG4JS__"}`;
			socket = net.createConnection(config$2.port || 5e3, config$2.host || "localhost");
			socket.on("connect", () => {
				debug$2("socket connected");
				emptyBuffer();
				canWrite = true;
			});
			socket.on("drain", () => {
				debug$2("drain event received, emptying buffer");
				canWrite = true;
				emptyBuffer();
			});
			socket.on("timeout", socket.end.bind(socket));
			socket.on("error", (e) => {
				debug$2("connection error", e);
				canWrite = false;
				emptyBuffer();
			});
			socket.on("close", createSocket);
		}
		createSocket();
		function log$1(loggingEvent) {
			if (canWrite) write(loggingEvent);
			else {
				debug$2("buffering log event because it cannot write at the moment");
				buffer2.push(loggingEvent);
			}
		}
		log$1.shutdown = function(cb) {
			debug$2("shutdown called");
			if (buffer2.length && shutdownAttempts) {
				debug$2("buffer has items, waiting 100ms to empty");
				shutdownAttempts -= 1;
				setTimeout(() => {
					log$1.shutdown(cb);
				}, 100);
			} else {
				socket.removeAllListeners("close");
				socket.end(cb);
			}
		};
		return log$1;
	}
	function configure2(config$2, layouts2) {
		debug$2(`configure with config = ${config$2}`);
		let layout = function(loggingEvent) {
			return loggingEvent.serialise();
		};
		if (config$2.layout) layout = layouts2.layout(config$2.layout.type, config$2.layout);
		return appender(config$2, layout);
	}
	tcp.configure = configure2;
	return tcp;
}
var hasRequiredAppenders;
function requireAppenders() {
	if (hasRequiredAppenders) return appenders.exports;
	hasRequiredAppenders = 1;
	const path$3 = path$1;
	const debug$2 = requireBrowser$2()("log4js:appenders");
	const configuration2 = requireConfiguration();
	const clustering2 = requireClustering();
	const levels2 = requireLevels();
	const layouts2 = requireLayouts();
	const adapters2 = requireAdapters();
	const coreAppenders = /* @__PURE__ */ new Map();
	coreAppenders.set("console", requireConsole());
	coreAppenders.set("stdout", requireStdout());
	coreAppenders.set("stderr", requireStderr());
	coreAppenders.set("logLevelFilter", requireLogLevelFilter());
	coreAppenders.set("categoryFilter", requireCategoryFilter());
	coreAppenders.set("noLogFilter", requireNoLogFilter());
	coreAppenders.set("file", requireFile());
	coreAppenders.set("dateFile", requireDateFile());
	coreAppenders.set("fileSync", requireFileSync$1());
	coreAppenders.set("tcp", requireTcp());
	const appenders$1 = /* @__PURE__ */ new Map();
	const tryLoading = (modulePath, config$2) => {
		let resolvedPath;
		try {
			const modulePathCJS = `${modulePath}.cjs`;
			resolvedPath = __require.resolve(modulePathCJS);
			debug$2("Loading module from ", modulePathCJS);
		} catch (e) {
			resolvedPath = modulePath;
			debug$2("Loading module from ", modulePath);
		}
		try {
			return commonjsRequire$1(resolvedPath);
		} catch (e) {
			configuration2.throwExceptionIf(config$2, e.code !== "MODULE_NOT_FOUND", `appender "${modulePath}" could not be loaded (error was: ${e})`);
			return;
		}
	};
	const loadAppenderModule = (type$1, config$2) => coreAppenders.get(type$1) || tryLoading(`./${type$1}`, config$2) || tryLoading(type$1, config$2) || __require.main && __require.main.filename && tryLoading(path$3.join(path$3.dirname(__require.main.filename), type$1), config$2) || tryLoading(path$3.join(process.cwd(), type$1), config$2);
	const appendersLoading = /* @__PURE__ */ new Set();
	const getAppender = (name, config$2) => {
		if (appenders$1.has(name)) return appenders$1.get(name);
		if (!config$2.appenders[name]) return false;
		if (appendersLoading.has(name)) throw new Error(`Dependency loop detected for appender ${name}.`);
		appendersLoading.add(name);
		debug$2(`Creating appender ${name}`);
		const appender = createAppender(name, config$2);
		appendersLoading.delete(name);
		appenders$1.set(name, appender);
		return appender;
	};
	const createAppender = (name, config$2) => {
		const appenderConfig = config$2.appenders[name];
		const appenderModule = appenderConfig.type.configure ? appenderConfig.type : loadAppenderModule(appenderConfig.type, config$2);
		configuration2.throwExceptionIf(config$2, configuration2.not(appenderModule), `appender "${name}" is not valid (type "${appenderConfig.type}" could not be found)`);
		if (appenderModule.appender) {
			process.emitWarning(`Appender ${appenderConfig.type} exports an appender function.`, "DeprecationWarning", "log4js-node-DEP0001");
			debug$2("[log4js-node-DEP0001]", `DEPRECATION: Appender ${appenderConfig.type} exports an appender function.`);
		}
		if (appenderModule.shutdown) {
			process.emitWarning(`Appender ${appenderConfig.type} exports a shutdown function.`, "DeprecationWarning", "log4js-node-DEP0002");
			debug$2("[log4js-node-DEP0002]", `DEPRECATION: Appender ${appenderConfig.type} exports a shutdown function.`);
		}
		debug$2(`${name}: clustering.isMaster ? ${clustering2.isMaster()}`);
		debug$2(`${name}: appenderModule is ${require$$14.inspect(appenderModule)}`);
		return clustering2.onlyOnMaster(
			() => {
				debug$2(`calling appenderModule.configure for ${name} / ${appenderConfig.type}`);
				return appenderModule.configure(adapters2.modifyConfig(appenderConfig), layouts2, (appender) => getAppender(appender, config$2), levels2);
			},
			/* istanbul ignore next: fn never gets called by non-master yet needed to pass config validation */
			() => {}
		);
	};
	const setup$1 = (config$2) => {
		appenders$1.clear();
		appendersLoading.clear();
		if (!config$2) return;
		const usedAppenders = [];
		Object.values(config$2.categories).forEach((category) => {
			usedAppenders.push(...category.appenders);
		});
		Object.keys(config$2.appenders).forEach((name) => {
			if (usedAppenders.includes(name) || config$2.appenders[name].type === "tcp-server" || config$2.appenders[name].type === "multiprocess") getAppender(name, config$2);
		});
	};
	const init$1 = () => {
		setup$1();
	};
	init$1();
	configuration2.addListener((config$2) => {
		configuration2.throwExceptionIf(config$2, configuration2.not(configuration2.anObject(config$2.appenders)), "must have a property \"appenders\" of type object.");
		const appenderNames = Object.keys(config$2.appenders);
		configuration2.throwExceptionIf(config$2, configuration2.not(appenderNames.length), "must define at least one appender.");
		appenderNames.forEach((name) => {
			configuration2.throwExceptionIf(config$2, configuration2.not(config$2.appenders[name].type), `appender "${name}" is not valid (must be an object with property "type")`);
		});
	});
	configuration2.addListener(setup$1);
	appenders.exports = appenders$1;
	appenders.exports.init = init$1;
	return appenders.exports;
}
var categories = { exports: {} };
var hasRequiredCategories;
function requireCategories() {
	if (hasRequiredCategories) return categories.exports;
	hasRequiredCategories = 1;
	(function(module$1) {
		const debug$2 = requireBrowser$2()("log4js:categories");
		const configuration2 = requireConfiguration();
		const levels2 = requireLevels();
		const appenders2 = requireAppenders();
		const categories2 = /* @__PURE__ */ new Map();
		function inheritFromParent(config$2, category, categoryName) {
			if (category.inherit === false) return;
			const lastDotIndex = categoryName.lastIndexOf(".");
			if (lastDotIndex < 0) return;
			const parentCategoryName = categoryName.slice(0, lastDotIndex);
			let parentCategory = config$2.categories[parentCategoryName];
			if (!parentCategory) parentCategory = {
				inherit: true,
				appenders: []
			};
			inheritFromParent(config$2, parentCategory, parentCategoryName);
			if (!config$2.categories[parentCategoryName] && parentCategory.appenders && parentCategory.appenders.length && parentCategory.level) config$2.categories[parentCategoryName] = parentCategory;
			category.appenders = category.appenders || [];
			category.level = category.level || parentCategory.level;
			parentCategory.appenders.forEach((ap) => {
				if (!category.appenders.includes(ap)) category.appenders.push(ap);
			});
			category.parent = parentCategory;
		}
		function addCategoryInheritance(config$2) {
			if (!config$2.categories) return;
			Object.keys(config$2.categories).forEach((name) => {
				const category = config$2.categories[name];
				inheritFromParent(config$2, category, name);
			});
		}
		configuration2.addPreProcessingListener((config$2) => addCategoryInheritance(config$2));
		configuration2.addListener((config$2) => {
			configuration2.throwExceptionIf(config$2, configuration2.not(configuration2.anObject(config$2.categories)), "must have a property \"categories\" of type object.");
			const categoryNames = Object.keys(config$2.categories);
			configuration2.throwExceptionIf(config$2, configuration2.not(categoryNames.length), "must define at least one category.");
			categoryNames.forEach((name) => {
				const category = config$2.categories[name];
				configuration2.throwExceptionIf(config$2, [configuration2.not(category.appenders), configuration2.not(category.level)], `category "${name}" is not valid (must be an object with properties "appenders" and "level")`);
				configuration2.throwExceptionIf(config$2, configuration2.not(Array.isArray(category.appenders)), `category "${name}" is not valid (appenders must be an array of appender names)`);
				configuration2.throwExceptionIf(config$2, configuration2.not(category.appenders.length), `category "${name}" is not valid (appenders must contain at least one appender name)`);
				if (Object.prototype.hasOwnProperty.call(category, "enableCallStack")) configuration2.throwExceptionIf(config$2, typeof category.enableCallStack !== "boolean", `category "${name}" is not valid (enableCallStack must be boolean type)`);
				category.appenders.forEach((appender) => {
					configuration2.throwExceptionIf(config$2, configuration2.not(appenders2.get(appender)), `category "${name}" is not valid (appender "${appender}" is not defined)`);
				});
				configuration2.throwExceptionIf(config$2, configuration2.not(levels2.getLevel(category.level)), `category "${name}" is not valid (level "${category.level}" not recognised; valid levels are ${levels2.levels.join(", ")})`);
			});
			configuration2.throwExceptionIf(config$2, configuration2.not(config$2.categories.default), "must define a \"default\" category.");
		});
		const setup$1 = (config$2) => {
			categories2.clear();
			if (!config$2) return;
			Object.keys(config$2.categories).forEach((name) => {
				const category = config$2.categories[name];
				const categoryAppenders = [];
				category.appenders.forEach((appender) => {
					categoryAppenders.push(appenders2.get(appender));
					debug$2(`Creating category ${name}`);
					categories2.set(name, {
						appenders: categoryAppenders,
						level: levels2.getLevel(category.level),
						enableCallStack: category.enableCallStack || false
					});
				});
			});
		};
		const init$1 = () => {
			setup$1();
		};
		init$1();
		configuration2.addListener(setup$1);
		const configForCategory = (category) => {
			debug$2(`configForCategory: searching for config for ${category}`);
			if (categories2.has(category)) {
				debug$2(`configForCategory: ${category} exists in config, returning it`);
				return categories2.get(category);
			}
			let sourceCategoryConfig;
			if (category.indexOf(".") > 0) {
				debug$2(`configForCategory: ${category} has hierarchy, cloning from parents`);
				sourceCategoryConfig = { ...configForCategory(category.slice(0, category.lastIndexOf("."))) };
			} else {
				if (!categories2.has("default")) setup$1({ categories: { default: {
					appenders: ["out"],
					level: "OFF"
				} } });
				debug$2("configForCategory: cloning default category");
				sourceCategoryConfig = { ...categories2.get("default") };
			}
			categories2.set(category, sourceCategoryConfig);
			return sourceCategoryConfig;
		};
		const appendersForCategory = (category) => configForCategory(category).appenders;
		const getLevelForCategory = (category) => configForCategory(category).level;
		const setLevelForCategory = (category, level) => {
			configForCategory(category).level = level;
		};
		const getEnableCallStackForCategory = (category) => configForCategory(category).enableCallStack === true;
		const setEnableCallStackForCategory = (category, useCallStack) => {
			configForCategory(category).enableCallStack = useCallStack;
		};
		module$1.exports = categories2;
		module$1.exports = Object.assign(module$1.exports, {
			appendersForCategory,
			getLevelForCategory,
			setLevelForCategory,
			getEnableCallStackForCategory,
			setEnableCallStackForCategory,
			init: init$1
		});
	})(categories);
	return categories.exports;
}
var logger$2;
var hasRequiredLogger;
function requireLogger() {
	if (hasRequiredLogger) return logger$2;
	hasRequiredLogger = 1;
	const debug$2 = requireBrowser$2()("log4js:logger");
	const LoggingEvent = requireLoggingEvent();
	const levels2 = requireLevels();
	const clustering2 = requireClustering();
	const categories2 = requireCategories();
	const configuration2 = requireConfiguration();
	const stackReg = /^(?:\s*) at (?:(.+) \()?(?:([^(]+?):(\d+):(\d+))\)?$/;
	const baseCallStackSkip = 1;
	const defaultErrorCallStackSkip = 3;
	function defaultParseCallStack(data$1, skipIdx = defaultErrorCallStackSkip + baseCallStackSkip) {
		try {
			const stacklines = data$1.stack.split("\n").slice(skipIdx);
			if (!stacklines.length) return null;
			const lineMatch = stackReg.exec(stacklines[0]);
			if (lineMatch && lineMatch.length === 5) {
				let className = "";
				let functionName = "";
				let functionAlias = "";
				if (lineMatch[1] && lineMatch[1] !== "") {
					[functionName, functionAlias] = lineMatch[1].replace(/[[\]]/g, "").split(" as ");
					functionAlias = functionAlias || "";
					if (functionName.includes(".")) [className, functionName] = functionName.split(".");
				}
				return {
					fileName: lineMatch[2],
					lineNumber: parseInt(lineMatch[3], 10),
					columnNumber: parseInt(lineMatch[4], 10),
					callStack: stacklines.join("\n"),
					className,
					functionName,
					functionAlias,
					callerName: lineMatch[1] || ""
				};
			} else console.error("log4js.logger - defaultParseCallStack error");
		} catch (err) {
			console.error("log4js.logger - defaultParseCallStack error", err);
		}
		return null;
	}
	class Logger {
		constructor(name) {
			if (!name) throw new Error("No category provided.");
			this.category = name;
			this.context = {};
			this.callStackSkipIndex = 0;
			this.parseCallStack = defaultParseCallStack;
			debug$2(`Logger created (${this.category}, ${this.level})`);
		}
		get level() {
			return levels2.getLevel(categories2.getLevelForCategory(this.category), levels2.OFF);
		}
		set level(level) {
			categories2.setLevelForCategory(this.category, levels2.getLevel(level, this.level));
		}
		get useCallStack() {
			return categories2.getEnableCallStackForCategory(this.category);
		}
		set useCallStack(bool) {
			categories2.setEnableCallStackForCategory(this.category, bool === true);
		}
		get callStackLinesToSkip() {
			return this.callStackSkipIndex;
		}
		set callStackLinesToSkip(number$3) {
			if (typeof number$3 !== "number") throw new TypeError("Must be a number");
			if (number$3 < 0) throw new RangeError("Must be >= 0");
			this.callStackSkipIndex = number$3;
		}
		log(level, ...args) {
			const logLevel = levels2.getLevel(level);
			if (!logLevel) if (configuration2.validIdentifier(level) && args.length > 0) {
				this.log(levels2.WARN, "log4js:logger.log: valid log-level not found as first parameter given:", level);
				this.log(levels2.INFO, `[${level}]`, ...args);
			} else this.log(levels2.INFO, level, ...args);
			else if (this.isLevelEnabled(logLevel)) this._log(logLevel, args);
		}
		isLevelEnabled(otherLevel) {
			return this.level.isLessThanOrEqualTo(otherLevel);
		}
		_log(level, data$1) {
			debug$2(`sending log data (${level}) to appenders`);
			const error = data$1.find((item) => item instanceof Error);
			let callStack;
			if (this.useCallStack) {
				try {
					if (error) callStack = this.parseCallStack(error, this.callStackSkipIndex + baseCallStackSkip);
				} catch (_err) {}
				callStack = callStack || this.parseCallStack(/* @__PURE__ */ new Error(), this.callStackSkipIndex + defaultErrorCallStackSkip + baseCallStackSkip);
			}
			const loggingEvent = new LoggingEvent(this.category, level, data$1, this.context, callStack, error);
			clustering2.send(loggingEvent);
		}
		addContext(key, value) {
			this.context[key] = value;
		}
		removeContext(key) {
			delete this.context[key];
		}
		clearContext() {
			this.context = {};
		}
		setParseCallStackFunction(parseFunction) {
			if (typeof parseFunction === "function") this.parseCallStack = parseFunction;
			else if (typeof parseFunction === "undefined") this.parseCallStack = defaultParseCallStack;
			else throw new TypeError("Invalid type passed to setParseCallStackFunction");
		}
	}
	function addLevelMethods(target) {
		const level = levels2.getLevel(target);
		const levelMethod = level.toString().toLowerCase().replace(/_([a-z])/g, (g) => g[1].toUpperCase());
		const isLevelMethod = levelMethod[0].toUpperCase() + levelMethod.slice(1);
		Logger.prototype[`is${isLevelMethod}Enabled`] = function() {
			return this.isLevelEnabled(level);
		};
		Logger.prototype[levelMethod] = function(...args) {
			this.log(level, ...args);
		};
	}
	levels2.levels.forEach(addLevelMethods);
	configuration2.addListener(() => {
		levels2.levels.forEach(addLevelMethods);
	});
	logger$2 = Logger;
	return logger$2;
}
var connectLogger;
var hasRequiredConnectLogger;
function requireConnectLogger() {
	if (hasRequiredConnectLogger) return connectLogger;
	hasRequiredConnectLogger = 1;
	const levels2 = requireLevels();
	const DEFAULT_FORMAT = ":remote-addr - - \":method :url HTTP/:http-version\" :status :content-length \":referrer\" \":user-agent\"";
	function getUrl(req) {
		return req.originalUrl || req.url;
	}
	function assembleTokens(req, res, customTokens) {
		const arrayUniqueTokens = (array$1) => {
			const a = array$1.concat();
			for (let i = 0; i < a.length; ++i) for (let j = i + 1; j < a.length; ++j) if (a[i].token == a[j].token) a.splice(j--, 1);
			return a;
		};
		const defaultTokens = [];
		defaultTokens.push({
			token: ":url",
			replacement: getUrl(req)
		});
		defaultTokens.push({
			token: ":protocol",
			replacement: req.protocol
		});
		defaultTokens.push({
			token: ":hostname",
			replacement: req.hostname
		});
		defaultTokens.push({
			token: ":method",
			replacement: req.method
		});
		defaultTokens.push({
			token: ":status",
			replacement: res.__statusCode || res.statusCode
		});
		defaultTokens.push({
			token: ":response-time",
			replacement: res.responseTime
		});
		defaultTokens.push({
			token: ":date",
			replacement: (/* @__PURE__ */ new Date()).toUTCString()
		});
		defaultTokens.push({
			token: ":referrer",
			replacement: req.headers.referer || req.headers.referrer || ""
		});
		defaultTokens.push({
			token: ":http-version",
			replacement: `${req.httpVersionMajor}.${req.httpVersionMinor}`
		});
		defaultTokens.push({
			token: ":remote-addr",
			replacement: req.headers["x-forwarded-for"] || req.ip || req._remoteAddress || req.socket && (req.socket.remoteAddress || req.socket.socket && req.socket.socket.remoteAddress)
		});
		defaultTokens.push({
			token: ":user-agent",
			replacement: req.headers["user-agent"]
		});
		defaultTokens.push({
			token: ":content-length",
			replacement: res.getHeader("content-length") || res.__headers && res.__headers["Content-Length"] || "-"
		});
		defaultTokens.push({
			token: /:req\[([^\]]+)]/g,
			replacement(_, field) {
				return req.headers[field.toLowerCase()];
			}
		});
		defaultTokens.push({
			token: /:res\[([^\]]+)]/g,
			replacement(_, field) {
				return res.getHeader(field.toLowerCase()) || res.__headers && res.__headers[field];
			}
		});
		return arrayUniqueTokens(customTokens.concat(defaultTokens));
	}
	function format(str, tokens) {
		for (let i = 0; i < tokens.length; i++) str = str.replace(tokens[i].token, tokens[i].replacement);
		return str;
	}
	function createNoLogCondition(nolog) {
		let regexp = null;
		if (nolog instanceof RegExp) regexp = nolog;
		if (typeof nolog === "string") regexp = new RegExp(nolog);
		if (Array.isArray(nolog)) {
			const regexpsAsStrings = nolog.map((reg) => reg.source ? reg.source : reg);
			regexp = new RegExp(regexpsAsStrings.join("|"));
		}
		return regexp;
	}
	function matchRules(statusCode, currentLevel, ruleSet) {
		let level = currentLevel;
		if (ruleSet) {
			const matchedRule = ruleSet.find((rule) => {
				let ruleMatched = false;
				if (rule.from && rule.to) ruleMatched = statusCode >= rule.from && statusCode <= rule.to;
				else ruleMatched = rule.codes.indexOf(statusCode) !== -1;
				return ruleMatched;
			});
			if (matchedRule) level = levels2.getLevel(matchedRule.level, level);
		}
		return level;
	}
	connectLogger = function getLogger2(logger4js, options) {
		if (typeof options === "string" || typeof options === "function") options = { format: options };
		else options = options || {};
		const thisLogger = logger4js;
		let level = levels2.getLevel(options.level, levels2.INFO);
		const fmt = options.format || DEFAULT_FORMAT;
		return (req, res, next) => {
			if (typeof req._logging !== "undefined") return next();
			if (typeof options.nolog !== "function") {
				const nolog = createNoLogCondition(options.nolog);
				if (nolog && nolog.test(req.originalUrl)) return next();
			}
			if (thisLogger.isLevelEnabled(level) || options.level === "auto") {
				const start = /* @__PURE__ */ new Date();
				const { writeHead } = res;
				req._logging = true;
				res.writeHead = (code, headers) => {
					res.writeHead = writeHead;
					res.writeHead(code, headers);
					res.__statusCode = code;
					res.__headers = headers || {};
				};
				let finished = false;
				const handler = () => {
					if (finished) return;
					finished = true;
					if (typeof options.nolog === "function") {
						if (options.nolog(req, res) === true) {
							req._logging = false;
							return;
						}
					}
					res.responseTime = /* @__PURE__ */ new Date() - start;
					if (res.statusCode && options.level === "auto") {
						level = levels2.INFO;
						if (res.statusCode >= 300) level = levels2.WARN;
						if (res.statusCode >= 400) level = levels2.ERROR;
					}
					level = matchRules(res.statusCode, level, options.statusRules);
					const combinedTokens = assembleTokens(req, res, options.tokens || []);
					if (options.context) thisLogger.addContext("res", res);
					if (typeof fmt === "function") {
						const line = fmt(req, res, (str) => format(str, combinedTokens));
						if (line) thisLogger.log(level, line);
					} else thisLogger.log(level, format(fmt, combinedTokens));
					if (options.context) thisLogger.removeContext("res");
				};
				res.on("end", handler);
				res.on("finish", handler);
				res.on("error", handler);
				res.on("close", handler);
			}
			return next();
		};
	};
	return connectLogger;
}
var recording;
var hasRequiredRecording;
function requireRecording() {
	if (hasRequiredRecording) return recording;
	hasRequiredRecording = 1;
	const debug$2 = requireBrowser$2()("log4js:recording");
	const recordedEvents = [];
	function configure2() {
		return function(logEvent) {
			debug$2(`received logEvent, number of events now ${recordedEvents.length + 1}`);
			debug$2("log event was ", logEvent);
			recordedEvents.push(logEvent);
		};
	}
	function replay() {
		return recordedEvents.slice();
	}
	function reset() {
		recordedEvents.length = 0;
	}
	recording = {
		configure: configure2,
		replay,
		playback: replay,
		reset,
		erase: reset
	};
	return recording;
}
var log4js_1;
var hasRequiredLog4js;
function requireLog4js() {
	if (hasRequiredLog4js) return log4js_1;
	hasRequiredLog4js = 1;
	const debug$2 = requireBrowser$2()("log4js:main");
	const fs2 = fs;
	const deepClone = requireRfdc()({ proto: true });
	const configuration2 = requireConfiguration();
	const layouts2 = requireLayouts();
	const levels2 = requireLevels();
	const appenders2 = requireAppenders();
	const categories2 = requireCategories();
	const Logger = requireLogger();
	const clustering2 = requireClustering();
	const connectLogger2 = requireConnectLogger();
	const recordingModule = requireRecording();
	let enabled = false;
	function sendLogEventToAppender(logEvent) {
		if (!enabled) return;
		debug$2("Received log event ", logEvent);
		categories2.appendersForCategory(logEvent.categoryName).forEach((appender) => {
			appender(logEvent);
		});
	}
	function loadConfigurationFile(filename) {
		debug$2(`Loading configuration from ${filename}`);
		try {
			return JSON.parse(fs2.readFileSync(filename, "utf8"));
		} catch (e) {
			throw new Error(`Problem reading config from file "${filename}". Error was ${e.message}`, e);
		}
	}
	function configure2(configurationFileOrObject) {
		if (enabled) shutdown2();
		let configObject = configurationFileOrObject;
		if (typeof configObject === "string") configObject = loadConfigurationFile(configurationFileOrObject);
		debug$2(`Configuration is ${configObject}`);
		configuration2.configure(deepClone(configObject));
		clustering2.onMessage(sendLogEventToAppender);
		enabled = true;
		return log4js2;
	}
	function isConfigured2() {
		return enabled;
	}
	function recording2() {
		return recordingModule;
	}
	function shutdown2(callback = () => {}) {
		if (typeof callback !== "function") throw new TypeError("Invalid callback passed to shutdown");
		debug$2("Shutdown called. Disabling all log writing.");
		enabled = false;
		const appendersToCheck = Array.from(appenders2.values());
		appenders2.init();
		categories2.init();
		const shutdownFunctions = appendersToCheck.reduce((accum, next) => next.shutdown ? accum + 1 : accum, 0);
		if (shutdownFunctions === 0) {
			debug$2("No appenders with shutdown functions found.");
			callback();
		}
		let completed = 0;
		let error;
		debug$2(`Found ${shutdownFunctions} appenders with shutdown functions.`);
		function complete(err) {
			error = error || err;
			completed += 1;
			debug$2(`Appender shutdowns complete: ${completed} / ${shutdownFunctions}`);
			if (completed >= shutdownFunctions) {
				debug$2("All shutdown functions completed.");
				callback(error);
			}
		}
		appendersToCheck.filter((a) => a.shutdown).forEach((a) => a.shutdown(complete));
	}
	function getLogger2(category) {
		if (!enabled) configure2(process.env.LOG4JS_CONFIG || {
			appenders: { out: { type: "stdout" } },
			categories: { default: {
				appenders: ["out"],
				level: "OFF"
			} }
		});
		return new Logger(category || "default");
	}
	const log4js2 = {
		getLogger: getLogger2,
		configure: configure2,
		isConfigured: isConfigured2,
		shutdown: shutdown2,
		connectLogger: connectLogger2,
		levels: levels2,
		addLayout: layouts2.addLayout,
		recording: recording2
	};
	log4js_1 = log4js2;
	return log4js_1;
}
var log4jsExports = requireLog4js();
const log4js = /* @__PURE__ */ _mergeNamespaces$1({
	__proto__: null,
	default: log4jsExports
}, [log4jsExports]);
const addLayout = log4jsExports.addLayout;
const configure = log4jsExports.configure;
const connectLogger$1 = log4jsExports.connectLogger;
const getLogger = log4jsExports.getLogger;
const isConfigured = log4jsExports.isConfigured;
const levels$1 = log4jsExports.levels;
const recording$1 = log4jsExports.recording;
const shutdown = log4jsExports.shutdown;

//#endregion
//#region ../../node_modules/.pnpm/@karinjs+log4js@1.1.4/node_modules/@karinjs/log4js/index.js
const app$2 = log4js.default;
var log4js_default = app$2;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
	return function wrap$1() {
		return fn.apply(thisArg, arguments);
	};
}

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/utils.js
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const { iterator, toStringTag: toStringTag$1 } = Symbol;
const kindOf = ((cache) => (thing) => {
	const str = toString.call(thing);
	return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));
const kindOfTest = (type$1) => {
	type$1 = type$1.toLowerCase();
	return (thing) => kindOf(thing) === type$1;
};
const typeOfTest = (type$1) => (thing) => typeof thing === type$1;
/**
* Determine if a value is an Array
*
* @param {Object} val The value to test
*
* @returns {boolean} True if value is an Array, otherwise false
*/
const { isArray } = Array;
/**
* Determine if a value is undefined
*
* @param {*} val The value to test
*
* @returns {boolean} True if the value is undefined, otherwise false
*/
const isUndefined = typeOfTest("undefined");
/**
* Determine if a value is a Buffer
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a Buffer, otherwise false
*/
function isBuffer$1(val) {
	return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$2(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
/**
* Determine if a value is an ArrayBuffer
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is an ArrayBuffer, otherwise false
*/
const isArrayBuffer = kindOfTest("ArrayBuffer");
/**
* Determine if a value is a view on an ArrayBuffer
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
*/
function isArrayBufferView(val) {
	let result;
	if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) result = ArrayBuffer.isView(val);
	else result = val && val.buffer && isArrayBuffer(val.buffer);
	return result;
}
/**
* Determine if a value is a String
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a String, otherwise false
*/
const isString$1 = typeOfTest("string");
/**
* Determine if a value is a Function
*
* @param {*} val The value to test
* @returns {boolean} True if value is a Function, otherwise false
*/
const isFunction$2 = typeOfTest("function");
/**
* Determine if a value is a Number
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a Number, otherwise false
*/
const isNumber = typeOfTest("number");
/**
* Determine if a value is an Object
*
* @param {*} thing The value to test
*
* @returns {boolean} True if value is an Object, otherwise false
*/
const isObject$1 = (thing) => thing !== null && typeof thing === "object";
/**
* Determine if a value is a Boolean
*
* @param {*} thing The value to test
* @returns {boolean} True if value is a Boolean, otherwise false
*/
const isBoolean = (thing) => thing === true || thing === false;
/**
* Determine if a value is a plain Object
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a plain Object, otherwise false
*/
const isPlainObject$1 = (val) => {
	if (kindOf(val) !== "object") return false;
	const prototype$2 = getPrototypeOf(val);
	return (prototype$2 === null || prototype$2 === Object.prototype || Object.getPrototypeOf(prototype$2) === null) && !(toStringTag$1 in val) && !(iterator in val);
};
/**
* Determine if a value is an empty object (safely handles Buffers)
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is an empty object, otherwise false
*/
const isEmptyObject = (val) => {
	if (!isObject$1(val) || isBuffer$1(val)) return false;
	try {
		return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
	} catch (e) {
		return false;
	}
};
/**
* Determine if a value is a Date
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a Date, otherwise false
*/
const isDate = kindOfTest("Date");
/**
* Determine if a value is a File
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a File, otherwise false
*/
const isFile = kindOfTest("File");
/**
* Determine if a value is a Blob
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a Blob, otherwise false
*/
const isBlob = kindOfTest("Blob");
/**
* Determine if a value is a FileList
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a File, otherwise false
*/
const isFileList = kindOfTest("FileList");
/**
* Determine if a value is a Stream
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a Stream, otherwise false
*/
const isStream = (val) => isObject$1(val) && isFunction$2(val.pipe);
/**
* Determine if a value is a FormData
*
* @param {*} thing The value to test
*
* @returns {boolean} True if value is an FormData, otherwise false
*/
const isFormData = (thing) => {
	let kind;
	return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$2(thing.append) && ((kind = kindOf(thing)) === "formdata" || kind === "object" && isFunction$2(thing.toString) && thing.toString() === "[object FormData]"));
};
/**
* Determine if a value is a URLSearchParams object
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a URLSearchParams object, otherwise false
*/
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = [
	"ReadableStream",
	"Request",
	"Response",
	"Headers"
].map(kindOfTest);
/**
* Trim excess whitespace off the beginning and end of a string
*
* @param {String} str The String to trim
*
* @returns {String} The String freed of excess whitespace
*/
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
/**
* Iterate over an Array or an Object invoking a function for each item.
*
* If `obj` is an Array callback will be called passing
* the value, index, and complete array for each item.
*
* If 'obj' is an Object callback will be called passing
* the value, key, and complete object for each property.
*
* @param {Object|Array} obj The object to iterate
* @param {Function} fn The callback to invoke for each item
*
* @param {Boolean} [allOwnKeys = false]
* @returns {any}
*/
function forEach(obj, fn, { allOwnKeys = false } = {}) {
	if (obj === null || typeof obj === "undefined") return;
	let i;
	let l;
	if (typeof obj !== "object") obj = [obj];
	if (isArray(obj)) for (i = 0, l = obj.length; i < l; i++) fn.call(null, obj[i], i, obj);
	else {
		if (isBuffer$1(obj)) return;
		const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
		const len = keys.length;
		let key;
		for (i = 0; i < len; i++) {
			key = keys[i];
			fn.call(null, obj[key], key, obj);
		}
	}
}
function findKey(obj, key) {
	if (isBuffer$1(obj)) return null;
	key = key.toLowerCase();
	const keys = Object.keys(obj);
	let i = keys.length;
	let _key;
	while (i-- > 0) {
		_key = keys[i];
		if (key === _key.toLowerCase()) return _key;
	}
	return null;
}
const _global = (() => {
	if (typeof globalThis !== "undefined") return globalThis;
	return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
/**
* Accepts varargs expecting each argument to be an object, then
* immutably merges the properties of each object and returns result.
*
* When multiple objects contain the same key the later object in
* the arguments list will take precedence.
*
* Example:
*
* ```js
* var result = merge({foo: 123}, {foo: 456});
* console.log(result.foo); // outputs 456
* ```
*
* @param {Object} obj1 Object to merge
*
* @returns {Object} Result of all merge properties
*/
function merge$1() {
	const { caseless, skipUndefined } = isContextDefined(this) && this || {};
	const result = {};
	const assignValue = (val, key) => {
		const targetKey = caseless && findKey(result, key) || key;
		if (isPlainObject$1(result[targetKey]) && isPlainObject$1(val)) result[targetKey] = merge$1(result[targetKey], val);
		else if (isPlainObject$1(val)) result[targetKey] = merge$1({}, val);
		else if (isArray(val)) result[targetKey] = val.slice();
		else if (!skipUndefined || !isUndefined(val)) result[targetKey] = val;
	};
	for (let i = 0, l = arguments.length; i < l; i++) arguments[i] && forEach(arguments[i], assignValue);
	return result;
}
/**
* Extends object a by mutably adding to it the properties of object b.
*
* @param {Object} a The object to be extended
* @param {Object} b The object to copy properties from
* @param {Object} thisArg The object to bind function to
*
* @param {Boolean} [allOwnKeys]
* @returns {Object} The resulting value of object a
*/
const extend$1 = (a, b, thisArg, { allOwnKeys } = {}) => {
	forEach(b, (val, key) => {
		if (thisArg && isFunction$2(val)) a[key] = bind(val, thisArg);
		else a[key] = val;
	}, { allOwnKeys });
	return a;
};
/**
* Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
*
* @param {string} content with BOM
*
* @returns {string} content value without BOM
*/
const stripBOM = (content) => {
	if (content.charCodeAt(0) === 65279) content = content.slice(1);
	return content;
};
/**
* Inherit the prototype methods from one constructor into another
* @param {function} constructor
* @param {function} superConstructor
* @param {object} [props]
* @param {object} [descriptors]
*
* @returns {void}
*/
const inherits = (constructor, superConstructor, props, descriptors$1) => {
	constructor.prototype = Object.create(superConstructor.prototype, descriptors$1);
	constructor.prototype.constructor = constructor;
	Object.defineProperty(constructor, "super", { value: superConstructor.prototype });
	props && Object.assign(constructor.prototype, props);
};
/**
* Resolve object with deep prototype chain to a flat object
* @param {Object} sourceObj source object
* @param {Object} [destObj]
* @param {Function|Boolean} [filter]
* @param {Function} [propFilter]
*
* @returns {Object}
*/
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
	let props;
	let i;
	let prop;
	const merged = {};
	destObj = destObj || {};
	if (sourceObj == null) return destObj;
	do {
		props = Object.getOwnPropertyNames(sourceObj);
		i = props.length;
		while (i-- > 0) {
			prop = props[i];
			if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
				destObj[prop] = sourceObj[prop];
				merged[prop] = true;
			}
		}
		sourceObj = filter !== false && getPrototypeOf(sourceObj);
	} while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
	return destObj;
};
/**
* Determines whether a string ends with the characters of a specified string
*
* @param {String} str
* @param {String} searchString
* @param {Number} [position= 0]
*
* @returns {boolean}
*/
const endsWith = (str, searchString, position) => {
	str = String(str);
	if (position === void 0 || position > str.length) position = str.length;
	position -= searchString.length;
	const lastIndex = str.indexOf(searchString, position);
	return lastIndex !== -1 && lastIndex === position;
};
/**
* Returns new array from array like object or null if failed
*
* @param {*} [thing]
*
* @returns {?Array}
*/
const toArray = (thing) => {
	if (!thing) return null;
	if (isArray(thing)) return thing;
	let i = thing.length;
	if (!isNumber(i)) return null;
	const arr = new Array(i);
	while (i-- > 0) arr[i] = thing[i];
	return arr;
};
/**
* Checking if the Uint8Array exists and if it does, it returns a function that checks if the
* thing passed in is an instance of Uint8Array
*
* @param {TypedArray}
*
* @returns {Array}
*/
const isTypedArray = ((TypedArray$1) => {
	return (thing) => {
		return TypedArray$1 && thing instanceof TypedArray$1;
	};
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
/**
* For each entry in the object, call the function with the key and value.
*
* @param {Object<any, any>} obj - The object to iterate over.
* @param {Function} fn - The function to call for each entry.
*
* @returns {void}
*/
const forEachEntry = (obj, fn) => {
	const _iterator = (obj && obj[iterator]).call(obj);
	let result;
	while ((result = _iterator.next()) && !result.done) {
		const pair = result.value;
		fn.call(obj, pair[0], pair[1]);
	}
};
/**
* It takes a regular expression and a string, and returns an array of all the matches
*
* @param {string} regExp - The regular expression to match against.
* @param {string} str - The string to search.
*
* @returns {Array<boolean>}
*/
const matchAll = (regExp, str) => {
	let matches;
	const arr = [];
	while ((matches = regExp.exec(str)) !== null) arr.push(matches);
	return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
	return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m$1, p1, p2) {
		return p1.toUpperCase() + p2;
	});
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty$1 }) => (obj, prop) => hasOwnProperty$1.call(obj, prop))(Object.prototype);
/**
* Determine if a value is a RegExp object
*
* @param {*} val The value to test
*
* @returns {boolean} True if value is a RegExp object, otherwise false
*/
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
	const descriptors$1 = Object.getOwnPropertyDescriptors(obj);
	const reducedDescriptors = {};
	forEach(descriptors$1, (descriptor, name) => {
		let ret;
		if ((ret = reducer(descriptor, name, obj)) !== false) reducedDescriptors[name] = ret || descriptor;
	});
	Object.defineProperties(obj, reducedDescriptors);
};
/**
* Makes all methods read-only
* @param {Object} obj
*/
const freezeMethods = (obj) => {
	reduceDescriptors(obj, (descriptor, name) => {
		if (isFunction$2(obj) && [
			"arguments",
			"caller",
			"callee"
		].indexOf(name) !== -1) return false;
		const value = obj[name];
		if (!isFunction$2(value)) return;
		descriptor.enumerable = false;
		if ("writable" in descriptor) {
			descriptor.writable = false;
			return;
		}
		if (!descriptor.set) descriptor.set = () => {
			throw Error("Can not rewrite read-only method '" + name + "'");
		};
	});
};
const toObjectSet = (arrayOrString, delimiter) => {
	const obj = {};
	const define = (arr) => {
		arr.forEach((value) => {
			obj[value] = true;
		});
	};
	isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
	return obj;
};
const noop$1 = () => {};
const toFiniteNumber = (value, defaultValue) => {
	return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
/**
* If the thing is a FormData object, return true, otherwise return false.
*
* @param {unknown} thing - The thing to check.
*
* @returns {boolean}
*/
function isSpecCompliantForm(thing) {
	return !!(thing && isFunction$2(thing.append) && thing[toStringTag$1] === "FormData" && thing[iterator]);
}
const toJSONObject = (obj) => {
	const stack = new Array(10);
	const visit = (source, i) => {
		if (isObject$1(source)) {
			if (stack.indexOf(source) >= 0) return;
			if (isBuffer$1(source)) return source;
			if (!("toJSON" in source)) {
				stack[i] = source;
				const target = isArray(source) ? [] : {};
				forEach(source, (value, key) => {
					const reducedValue = visit(value, i + 1);
					!isUndefined(reducedValue) && (target[key] = reducedValue);
				});
				stack[i] = void 0;
				return target;
			}
		}
		return source;
	};
	return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject$1(thing) || isFunction$2(thing)) && isFunction$2(thing.then) && isFunction$2(thing.catch);
const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
	if (setImmediateSupported) return setImmediate;
	return postMessageSupported ? ((token, callbacks) => {
		_global.addEventListener("message", ({ source, data: data$1 }) => {
			if (source === _global && data$1 === token) callbacks.length && callbacks.shift()();
		}, false);
		return (cb) => {
			callbacks.push(cb);
			_global.postMessage(token, "*");
		};
	})(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(typeof setImmediate === "function", isFunction$2(_global.postMessage));
const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
const isIterable = (thing) => thing != null && isFunction$2(thing[iterator]);
var utils_default = {
	isArray,
	isArrayBuffer,
	isBuffer: isBuffer$1,
	isFormData,
	isArrayBufferView,
	isString: isString$1,
	isNumber,
	isBoolean,
	isObject: isObject$1,
	isPlainObject: isPlainObject$1,
	isEmptyObject,
	isReadableStream,
	isRequest,
	isResponse,
	isHeaders,
	isUndefined,
	isDate,
	isFile,
	isBlob,
	isRegExp,
	isFunction: isFunction$2,
	isStream,
	isURLSearchParams,
	isTypedArray,
	isFileList,
	forEach,
	merge: merge$1,
	extend: extend$1,
	trim,
	stripBOM,
	inherits,
	toFlatObject,
	kindOf,
	kindOfTest,
	endsWith,
	toArray,
	forEachEntry,
	matchAll,
	isHTMLForm,
	hasOwnProperty,
	hasOwnProp: hasOwnProperty,
	reduceDescriptors,
	freezeMethods,
	toObjectSet,
	toCamelCase,
	noop: noop$1,
	toFiniteNumber,
	findKey,
	global: _global,
	isContextDefined,
	isSpecCompliantForm,
	toJSONObject,
	isAsyncFn,
	isThenable,
	setImmediate: _setImmediate,
	asap,
	isIterable
};

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/core/AxiosError.js
/**
* Create an Error with the specified message, config, error code, request and response.
*
* @param {string} message The error message.
* @param {string} [code] The error code (for example, 'ECONNABORTED').
* @param {Object} [config] The config.
* @param {Object} [request] The request.
* @param {Object} [response] The response.
*
* @returns {Error} The created error.
*/
function AxiosError$2(message, code, config$2, request$2, response$2) {
	Error.call(this);
	if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
	else this.stack = (/* @__PURE__ */ new Error()).stack;
	this.message = message;
	this.name = "AxiosError";
	code && (this.code = code);
	config$2 && (this.config = config$2);
	request$2 && (this.request = request$2);
	if (response$2) {
		this.response = response$2;
		this.status = response$2.status ? response$2.status : null;
	}
}
utils_default.inherits(AxiosError$2, Error, { toJSON: function toJSON() {
	return {
		message: this.message,
		name: this.name,
		description: this.description,
		number: this.number,
		fileName: this.fileName,
		lineNumber: this.lineNumber,
		columnNumber: this.columnNumber,
		stack: this.stack,
		config: utils_default.toJSONObject(this.config),
		code: this.code,
		status: this.status
	};
} });
const prototype$1 = AxiosError$2.prototype;
const descriptors = {};
[
	"ERR_BAD_OPTION_VALUE",
	"ERR_BAD_OPTION",
	"ECONNABORTED",
	"ETIMEDOUT",
	"ERR_NETWORK",
	"ERR_FR_TOO_MANY_REDIRECTS",
	"ERR_DEPRECATED",
	"ERR_BAD_RESPONSE",
	"ERR_BAD_REQUEST",
	"ERR_CANCELED",
	"ERR_NOT_SUPPORT",
	"ERR_INVALID_URL"
].forEach((code) => {
	descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError$2, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError$2.from = (error, code, config$2, request$2, response$2, customProps) => {
	const axiosError = Object.create(prototype$1);
	utils_default.toFlatObject(error, axiosError, function filter(obj) {
		return obj !== Error.prototype;
	}, (prop) => {
		return prop !== "isAxiosError";
	});
	const msg = error && error.message ? error.message : "Error";
	const errCode = code == null && error ? error.code : code;
	AxiosError$2.call(axiosError, msg, errCode, config$2, request$2, response$2);
	if (error && axiosError.cause == null) Object.defineProperty(axiosError, "cause", {
		value: error,
		configurable: true
	});
	axiosError.name = error && error.name || "Error";
	customProps && Object.assign(axiosError, customProps);
	return axiosError;
};
var AxiosError_default = AxiosError$2;

//#endregion
//#region ../../node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js": ((exports, module) => {
	var Stream$2 = __require("stream").Stream;
	var util$3 = __require("util");
	module.exports = DelayedStream$1;
	function DelayedStream$1() {
		this.source = null;
		this.dataSize = 0;
		this.maxDataSize = 1024 * 1024;
		this.pauseStream = true;
		this._maxDataSizeExceeded = false;
		this._released = false;
		this._bufferedEvents = [];
	}
	util$3.inherits(DelayedStream$1, Stream$2);
	DelayedStream$1.create = function(source, options) {
		var delayedStream = new this();
		options = options || {};
		for (var option in options) delayedStream[option] = options[option];
		delayedStream.source = source;
		var realEmit = source.emit;
		source.emit = function() {
			delayedStream._handleEmit(arguments);
			return realEmit.apply(source, arguments);
		};
		source.on("error", function() {});
		if (delayedStream.pauseStream) source.pause();
		return delayedStream;
	};
	Object.defineProperty(DelayedStream$1.prototype, "readable", {
		configurable: true,
		enumerable: true,
		get: function() {
			return this.source.readable;
		}
	});
	DelayedStream$1.prototype.setEncoding = function() {
		return this.source.setEncoding.apply(this.source, arguments);
	};
	DelayedStream$1.prototype.resume = function() {
		if (!this._released) this.release();
		this.source.resume();
	};
	DelayedStream$1.prototype.pause = function() {
		this.source.pause();
	};
	DelayedStream$1.prototype.release = function() {
		this._released = true;
		this._bufferedEvents.forEach(function(args) {
			this.emit.apply(this, args);
		}.bind(this));
		this._bufferedEvents = [];
	};
	DelayedStream$1.prototype.pipe = function() {
		var r = Stream$2.prototype.pipe.apply(this, arguments);
		this.resume();
		return r;
	};
	DelayedStream$1.prototype._handleEmit = function(args) {
		if (this._released) {
			this.emit.apply(this, args);
			return;
		}
		if (args[0] === "data") {
			this.dataSize += args[1].length;
			this._checkIfMaxDataSizeExceeded();
		}
		this._bufferedEvents.push(args);
	};
	DelayedStream$1.prototype._checkIfMaxDataSizeExceeded = function() {
		if (this._maxDataSizeExceeded) return;
		if (this.dataSize <= this.maxDataSize) return;
		this._maxDataSizeExceeded = true;
		var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
		this.emit("error", new Error(message));
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js": ((exports, module) => {
	var util$2 = __require("util");
	var Stream$1 = __require("stream").Stream;
	var DelayedStream = require_delayed_stream();
	module.exports = CombinedStream$1;
	function CombinedStream$1() {
		this.writable = false;
		this.readable = true;
		this.dataSize = 0;
		this.maxDataSize = 2 * 1024 * 1024;
		this.pauseStreams = true;
		this._released = false;
		this._streams = [];
		this._currentStream = null;
		this._insideLoop = false;
		this._pendingNext = false;
	}
	util$2.inherits(CombinedStream$1, Stream$1);
	CombinedStream$1.create = function(options) {
		var combinedStream = new this();
		options = options || {};
		for (var option in options) combinedStream[option] = options[option];
		return combinedStream;
	};
	CombinedStream$1.isStreamLike = function(stream) {
		return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
	};
	CombinedStream$1.prototype.append = function(stream) {
		if (CombinedStream$1.isStreamLike(stream)) {
			if (!(stream instanceof DelayedStream)) {
				var newStream = DelayedStream.create(stream, {
					maxDataSize: Infinity,
					pauseStream: this.pauseStreams
				});
				stream.on("data", this._checkDataSize.bind(this));
				stream = newStream;
			}
			this._handleErrors(stream);
			if (this.pauseStreams) stream.pause();
		}
		this._streams.push(stream);
		return this;
	};
	CombinedStream$1.prototype.pipe = function(dest, options) {
		Stream$1.prototype.pipe.call(this, dest, options);
		this.resume();
		return dest;
	};
	CombinedStream$1.prototype._getNext = function() {
		this._currentStream = null;
		if (this._insideLoop) {
			this._pendingNext = true;
			return;
		}
		this._insideLoop = true;
		try {
			do {
				this._pendingNext = false;
				this._realGetNext();
			} while (this._pendingNext);
		} finally {
			this._insideLoop = false;
		}
	};
	CombinedStream$1.prototype._realGetNext = function() {
		var stream = this._streams.shift();
		if (typeof stream == "undefined") {
			this.end();
			return;
		}
		if (typeof stream !== "function") {
			this._pipeNext(stream);
			return;
		}
		stream(function(stream$1) {
			if (CombinedStream$1.isStreamLike(stream$1)) {
				stream$1.on("data", this._checkDataSize.bind(this));
				this._handleErrors(stream$1);
			}
			this._pipeNext(stream$1);
		}.bind(this));
	};
	CombinedStream$1.prototype._pipeNext = function(stream) {
		this._currentStream = stream;
		if (CombinedStream$1.isStreamLike(stream)) {
			stream.on("end", this._getNext.bind(this));
			stream.pipe(this, { end: false });
			return;
		}
		var value = stream;
		this.write(value);
		this._getNext();
	};
	CombinedStream$1.prototype._handleErrors = function(stream) {
		var self$1 = this;
		stream.on("error", function(err) {
			self$1._emitError(err);
		});
	};
	CombinedStream$1.prototype.write = function(data$1) {
		this.emit("data", data$1);
	};
	CombinedStream$1.prototype.pause = function() {
		if (!this.pauseStreams) return;
		if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
		this.emit("pause");
	};
	CombinedStream$1.prototype.resume = function() {
		if (!this._released) {
			this._released = true;
			this.writable = true;
			this._getNext();
		}
		if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
		this.emit("resume");
	};
	CombinedStream$1.prototype.end = function() {
		this._reset();
		this.emit("end");
	};
	CombinedStream$1.prototype.destroy = function() {
		this._reset();
		this.emit("close");
	};
	CombinedStream$1.prototype._reset = function() {
		this.writable = false;
		this._streams = [];
		this._currentStream = null;
	};
	CombinedStream$1.prototype._checkDataSize = function() {
		this._updateDataSize();
		if (this.dataSize <= this.maxDataSize) return;
		var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
		this._emitError(new Error(message));
	};
	CombinedStream$1.prototype._updateDataSize = function() {
		this.dataSize = 0;
		var self$1 = this;
		this._streams.forEach(function(stream) {
			if (!stream.dataSize) return;
			self$1.dataSize += stream.dataSize;
		});
		if (this._currentStream && this._currentStream.dataSize) this.dataSize += this._currentStream.dataSize;
	};
	CombinedStream$1.prototype._emitError = function(err) {
		this._reset();
		this.emit("error", err);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json
var require_db = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json": ((exports, module) => {
	module.exports = {
		"application/1d-interleaved-parityfec": { "source": "iana" },
		"application/3gpdash-qoe-report+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/3gpp-ims+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/3gpphal+json": {
			"source": "iana",
			"compressible": true
		},
		"application/3gpphalforms+json": {
			"source": "iana",
			"compressible": true
		},
		"application/a2l": { "source": "iana" },
		"application/ace+cbor": { "source": "iana" },
		"application/activemessage": { "source": "iana" },
		"application/activity+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-costmap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-costmapfilter+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-directory+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointcost+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointcostparams+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointprop+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointpropparams+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-error+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-networkmap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-networkmapfilter+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-updatestreamcontrol+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-updatestreamparams+json": {
			"source": "iana",
			"compressible": true
		},
		"application/aml": { "source": "iana" },
		"application/andrew-inset": {
			"source": "iana",
			"extensions": ["ez"]
		},
		"application/applefile": { "source": "iana" },
		"application/applixware": {
			"source": "apache",
			"extensions": ["aw"]
		},
		"application/at+jwt": { "source": "iana" },
		"application/atf": { "source": "iana" },
		"application/atfx": { "source": "iana" },
		"application/atom+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["atom"]
		},
		"application/atomcat+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["atomcat"]
		},
		"application/atomdeleted+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["atomdeleted"]
		},
		"application/atomicmail": { "source": "iana" },
		"application/atomsvc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["atomsvc"]
		},
		"application/atsc-dwd+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dwd"]
		},
		"application/atsc-dynamic-event-message": { "source": "iana" },
		"application/atsc-held+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["held"]
		},
		"application/atsc-rdt+json": {
			"source": "iana",
			"compressible": true
		},
		"application/atsc-rsat+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rsat"]
		},
		"application/atxml": { "source": "iana" },
		"application/auth-policy+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/bacnet-xdd+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/batch-smtp": { "source": "iana" },
		"application/bdoc": {
			"compressible": false,
			"extensions": ["bdoc"]
		},
		"application/beep+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/calendar+json": {
			"source": "iana",
			"compressible": true
		},
		"application/calendar+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xcs"]
		},
		"application/call-completion": { "source": "iana" },
		"application/cals-1840": { "source": "iana" },
		"application/captive+json": {
			"source": "iana",
			"compressible": true
		},
		"application/cbor": { "source": "iana" },
		"application/cbor-seq": { "source": "iana" },
		"application/cccex": { "source": "iana" },
		"application/ccmp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/ccxml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ccxml"]
		},
		"application/cdfx+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["cdfx"]
		},
		"application/cdmi-capability": {
			"source": "iana",
			"extensions": ["cdmia"]
		},
		"application/cdmi-container": {
			"source": "iana",
			"extensions": ["cdmic"]
		},
		"application/cdmi-domain": {
			"source": "iana",
			"extensions": ["cdmid"]
		},
		"application/cdmi-object": {
			"source": "iana",
			"extensions": ["cdmio"]
		},
		"application/cdmi-queue": {
			"source": "iana",
			"extensions": ["cdmiq"]
		},
		"application/cdni": { "source": "iana" },
		"application/cea": { "source": "iana" },
		"application/cea-2018+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cellml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cfw": { "source": "iana" },
		"application/city+json": {
			"source": "iana",
			"compressible": true
		},
		"application/clr": { "source": "iana" },
		"application/clue+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/clue_info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cms": { "source": "iana" },
		"application/cnrp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/coap-group+json": {
			"source": "iana",
			"compressible": true
		},
		"application/coap-payload": { "source": "iana" },
		"application/commonground": { "source": "iana" },
		"application/conference-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cose": { "source": "iana" },
		"application/cose-key": { "source": "iana" },
		"application/cose-key-set": { "source": "iana" },
		"application/cpl+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["cpl"]
		},
		"application/csrattrs": { "source": "iana" },
		"application/csta+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cstadata+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/csvm+json": {
			"source": "iana",
			"compressible": true
		},
		"application/cu-seeme": {
			"source": "apache",
			"extensions": ["cu"]
		},
		"application/cwt": { "source": "iana" },
		"application/cybercash": { "source": "iana" },
		"application/dart": { "compressible": true },
		"application/dash+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mpd"]
		},
		"application/dash-patch+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mpp"]
		},
		"application/dashdelta": { "source": "iana" },
		"application/davmount+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["davmount"]
		},
		"application/dca-rft": { "source": "iana" },
		"application/dcd": { "source": "iana" },
		"application/dec-dx": { "source": "iana" },
		"application/dialog-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/dicom": { "source": "iana" },
		"application/dicom+json": {
			"source": "iana",
			"compressible": true
		},
		"application/dicom+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/dii": { "source": "iana" },
		"application/dit": { "source": "iana" },
		"application/dns": { "source": "iana" },
		"application/dns+json": {
			"source": "iana",
			"compressible": true
		},
		"application/dns-message": { "source": "iana" },
		"application/docbook+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["dbk"]
		},
		"application/dots+cbor": { "source": "iana" },
		"application/dskpp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/dssc+der": {
			"source": "iana",
			"extensions": ["dssc"]
		},
		"application/dssc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xdssc"]
		},
		"application/dvcs": { "source": "iana" },
		"application/ecmascript": {
			"source": "iana",
			"compressible": true,
			"extensions": ["es", "ecma"]
		},
		"application/edi-consent": { "source": "iana" },
		"application/edi-x12": {
			"source": "iana",
			"compressible": false
		},
		"application/edifact": {
			"source": "iana",
			"compressible": false
		},
		"application/efi": { "source": "iana" },
		"application/elm+json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/elm+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.cap+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/emergencycalldata.comment+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.control+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.deviceinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.ecall.msd": { "source": "iana" },
		"application/emergencycalldata.providerinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.serviceinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.subscriberinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.veds+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emma+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["emma"]
		},
		"application/emotionml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["emotionml"]
		},
		"application/encaprtp": { "source": "iana" },
		"application/epp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/epub+zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["epub"]
		},
		"application/eshop": { "source": "iana" },
		"application/exi": {
			"source": "iana",
			"extensions": ["exi"]
		},
		"application/expect-ct-report+json": {
			"source": "iana",
			"compressible": true
		},
		"application/express": {
			"source": "iana",
			"extensions": ["exp"]
		},
		"application/fastinfoset": { "source": "iana" },
		"application/fastsoap": { "source": "iana" },
		"application/fdt+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["fdt"]
		},
		"application/fhir+json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/fhir+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/fido.trusted-apps+json": { "compressible": true },
		"application/fits": { "source": "iana" },
		"application/flexfec": { "source": "iana" },
		"application/font-sfnt": { "source": "iana" },
		"application/font-tdpfr": {
			"source": "iana",
			"extensions": ["pfr"]
		},
		"application/font-woff": {
			"source": "iana",
			"compressible": false
		},
		"application/framework-attributes+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/geo+json": {
			"source": "iana",
			"compressible": true,
			"extensions": ["geojson"]
		},
		"application/geo+json-seq": { "source": "iana" },
		"application/geopackage+sqlite3": { "source": "iana" },
		"application/geoxacml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/gltf-buffer": { "source": "iana" },
		"application/gml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["gml"]
		},
		"application/gpx+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["gpx"]
		},
		"application/gxf": {
			"source": "apache",
			"extensions": ["gxf"]
		},
		"application/gzip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["gz"]
		},
		"application/h224": { "source": "iana" },
		"application/held+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/hjson": { "extensions": ["hjson"] },
		"application/http": { "source": "iana" },
		"application/hyperstudio": {
			"source": "iana",
			"extensions": ["stk"]
		},
		"application/ibe-key-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/ibe-pkg-reply+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/ibe-pp-data": { "source": "iana" },
		"application/iges": { "source": "iana" },
		"application/im-iscomposing+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/index": { "source": "iana" },
		"application/index.cmd": { "source": "iana" },
		"application/index.obj": { "source": "iana" },
		"application/index.response": { "source": "iana" },
		"application/index.vnd": { "source": "iana" },
		"application/inkml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ink", "inkml"]
		},
		"application/iotp": { "source": "iana" },
		"application/ipfix": {
			"source": "iana",
			"extensions": ["ipfix"]
		},
		"application/ipp": { "source": "iana" },
		"application/isup": { "source": "iana" },
		"application/its+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["its"]
		},
		"application/java-archive": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"jar",
				"war",
				"ear"
			]
		},
		"application/java-serialized-object": {
			"source": "apache",
			"compressible": false,
			"extensions": ["ser"]
		},
		"application/java-vm": {
			"source": "apache",
			"compressible": false,
			"extensions": ["class"]
		},
		"application/javascript": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["js", "mjs"]
		},
		"application/jf2feed+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jose": { "source": "iana" },
		"application/jose+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jrd+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jscalendar+json": {
			"source": "iana",
			"compressible": true
		},
		"application/json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["json", "map"]
		},
		"application/json-patch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/json-seq": { "source": "iana" },
		"application/json5": { "extensions": ["json5"] },
		"application/jsonml+json": {
			"source": "apache",
			"compressible": true,
			"extensions": ["jsonml"]
		},
		"application/jwk+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jwk-set+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jwt": { "source": "iana" },
		"application/kpml-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/kpml-response+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/ld+json": {
			"source": "iana",
			"compressible": true,
			"extensions": ["jsonld"]
		},
		"application/lgr+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["lgr"]
		},
		"application/link-format": { "source": "iana" },
		"application/load-control+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/lost+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["lostxml"]
		},
		"application/lostsync+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/lpf+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/lxf": { "source": "iana" },
		"application/mac-binhex40": {
			"source": "iana",
			"extensions": ["hqx"]
		},
		"application/mac-compactpro": {
			"source": "apache",
			"extensions": ["cpt"]
		},
		"application/macwriteii": { "source": "iana" },
		"application/mads+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mads"]
		},
		"application/manifest+json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["webmanifest"]
		},
		"application/marc": {
			"source": "iana",
			"extensions": ["mrc"]
		},
		"application/marcxml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mrcx"]
		},
		"application/mathematica": {
			"source": "iana",
			"extensions": [
				"ma",
				"nb",
				"mb"
			]
		},
		"application/mathml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mathml"]
		},
		"application/mathml-content+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mathml-presentation+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-associated-procedure-description+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-deregister+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-envelope+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-msk+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-msk-response+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-protection-description+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-reception-report+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-register+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-register-response+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-schedule+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-user-service-description+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbox": {
			"source": "iana",
			"extensions": ["mbox"]
		},
		"application/media-policy-dataset+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mpf"]
		},
		"application/media_control+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mediaservercontrol+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mscml"]
		},
		"application/merge-patch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/metalink+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["metalink"]
		},
		"application/metalink4+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["meta4"]
		},
		"application/mets+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mets"]
		},
		"application/mf4": { "source": "iana" },
		"application/mikey": { "source": "iana" },
		"application/mipc": { "source": "iana" },
		"application/missing-blocks+cbor-seq": { "source": "iana" },
		"application/mmt-aei+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["maei"]
		},
		"application/mmt-usd+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["musd"]
		},
		"application/mods+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mods"]
		},
		"application/moss-keys": { "source": "iana" },
		"application/moss-signature": { "source": "iana" },
		"application/mosskey-data": { "source": "iana" },
		"application/mosskey-request": { "source": "iana" },
		"application/mp21": {
			"source": "iana",
			"extensions": ["m21", "mp21"]
		},
		"application/mp4": {
			"source": "iana",
			"extensions": ["mp4s", "m4p"]
		},
		"application/mpeg4-generic": { "source": "iana" },
		"application/mpeg4-iod": { "source": "iana" },
		"application/mpeg4-iod-xmt": { "source": "iana" },
		"application/mrb-consumer+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mrb-publish+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/msc-ivr+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/msc-mixer+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/msword": {
			"source": "iana",
			"compressible": false,
			"extensions": ["doc", "dot"]
		},
		"application/mud+json": {
			"source": "iana",
			"compressible": true
		},
		"application/multipart-core": { "source": "iana" },
		"application/mxf": {
			"source": "iana",
			"extensions": ["mxf"]
		},
		"application/n-quads": {
			"source": "iana",
			"extensions": ["nq"]
		},
		"application/n-triples": {
			"source": "iana",
			"extensions": ["nt"]
		},
		"application/nasdata": { "source": "iana" },
		"application/news-checkgroups": {
			"source": "iana",
			"charset": "US-ASCII"
		},
		"application/news-groupinfo": {
			"source": "iana",
			"charset": "US-ASCII"
		},
		"application/news-transmission": { "source": "iana" },
		"application/nlsml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/node": {
			"source": "iana",
			"extensions": ["cjs"]
		},
		"application/nss": { "source": "iana" },
		"application/oauth-authz-req+jwt": { "source": "iana" },
		"application/oblivious-dns-message": { "source": "iana" },
		"application/ocsp-request": { "source": "iana" },
		"application/ocsp-response": { "source": "iana" },
		"application/octet-stream": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"bin",
				"dms",
				"lrf",
				"mar",
				"so",
				"dist",
				"distz",
				"pkg",
				"bpk",
				"dump",
				"elc",
				"deploy",
				"exe",
				"dll",
				"deb",
				"dmg",
				"iso",
				"img",
				"msi",
				"msp",
				"msm",
				"buffer"
			]
		},
		"application/oda": {
			"source": "iana",
			"extensions": ["oda"]
		},
		"application/odm+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/odx": { "source": "iana" },
		"application/oebps-package+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["opf"]
		},
		"application/ogg": {
			"source": "iana",
			"compressible": false,
			"extensions": ["ogx"]
		},
		"application/omdoc+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["omdoc"]
		},
		"application/onenote": {
			"source": "apache",
			"extensions": [
				"onetoc",
				"onetoc2",
				"onetmp",
				"onepkg"
			]
		},
		"application/opc-nodeset+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/oscore": { "source": "iana" },
		"application/oxps": {
			"source": "iana",
			"extensions": ["oxps"]
		},
		"application/p21": { "source": "iana" },
		"application/p21+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/p2p-overlay+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["relo"]
		},
		"application/parityfec": { "source": "iana" },
		"application/passport": { "source": "iana" },
		"application/patch-ops-error+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xer"]
		},
		"application/pdf": {
			"source": "iana",
			"compressible": false,
			"extensions": ["pdf"]
		},
		"application/pdx": { "source": "iana" },
		"application/pem-certificate-chain": { "source": "iana" },
		"application/pgp-encrypted": {
			"source": "iana",
			"compressible": false,
			"extensions": ["pgp"]
		},
		"application/pgp-keys": {
			"source": "iana",
			"extensions": ["asc"]
		},
		"application/pgp-signature": {
			"source": "iana",
			"extensions": ["asc", "sig"]
		},
		"application/pics-rules": {
			"source": "apache",
			"extensions": ["prf"]
		},
		"application/pidf+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/pidf-diff+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/pkcs10": {
			"source": "iana",
			"extensions": ["p10"]
		},
		"application/pkcs12": { "source": "iana" },
		"application/pkcs7-mime": {
			"source": "iana",
			"extensions": ["p7m", "p7c"]
		},
		"application/pkcs7-signature": {
			"source": "iana",
			"extensions": ["p7s"]
		},
		"application/pkcs8": {
			"source": "iana",
			"extensions": ["p8"]
		},
		"application/pkcs8-encrypted": { "source": "iana" },
		"application/pkix-attr-cert": {
			"source": "iana",
			"extensions": ["ac"]
		},
		"application/pkix-cert": {
			"source": "iana",
			"extensions": ["cer"]
		},
		"application/pkix-crl": {
			"source": "iana",
			"extensions": ["crl"]
		},
		"application/pkix-pkipath": {
			"source": "iana",
			"extensions": ["pkipath"]
		},
		"application/pkixcmp": {
			"source": "iana",
			"extensions": ["pki"]
		},
		"application/pls+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["pls"]
		},
		"application/poc-settings+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/postscript": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"ai",
				"eps",
				"ps"
			]
		},
		"application/ppsp-tracker+json": {
			"source": "iana",
			"compressible": true
		},
		"application/problem+json": {
			"source": "iana",
			"compressible": true
		},
		"application/problem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/provenance+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["provx"]
		},
		"application/prs.alvestrand.titrax-sheet": { "source": "iana" },
		"application/prs.cww": {
			"source": "iana",
			"extensions": ["cww"]
		},
		"application/prs.cyn": {
			"source": "iana",
			"charset": "7-BIT"
		},
		"application/prs.hpub+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/prs.nprend": { "source": "iana" },
		"application/prs.plucker": { "source": "iana" },
		"application/prs.rdf-xml-crypt": { "source": "iana" },
		"application/prs.xsf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/pskc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["pskcxml"]
		},
		"application/pvd+json": {
			"source": "iana",
			"compressible": true
		},
		"application/qsig": { "source": "iana" },
		"application/raml+yaml": {
			"compressible": true,
			"extensions": ["raml"]
		},
		"application/raptorfec": { "source": "iana" },
		"application/rdap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/rdf+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rdf", "owl"]
		},
		"application/reginfo+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rif"]
		},
		"application/relax-ng-compact-syntax": {
			"source": "iana",
			"extensions": ["rnc"]
		},
		"application/remote-printing": { "source": "iana" },
		"application/reputon+json": {
			"source": "iana",
			"compressible": true
		},
		"application/resource-lists+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rl"]
		},
		"application/resource-lists-diff+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rld"]
		},
		"application/rfc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/riscos": { "source": "iana" },
		"application/rlmi+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/rls-services+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rs"]
		},
		"application/route-apd+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rapd"]
		},
		"application/route-s-tsid+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sls"]
		},
		"application/route-usd+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rusd"]
		},
		"application/rpki-ghostbusters": {
			"source": "iana",
			"extensions": ["gbr"]
		},
		"application/rpki-manifest": {
			"source": "iana",
			"extensions": ["mft"]
		},
		"application/rpki-publication": { "source": "iana" },
		"application/rpki-roa": {
			"source": "iana",
			"extensions": ["roa"]
		},
		"application/rpki-updown": { "source": "iana" },
		"application/rsd+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["rsd"]
		},
		"application/rss+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["rss"]
		},
		"application/rtf": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rtf"]
		},
		"application/rtploopback": { "source": "iana" },
		"application/rtx": { "source": "iana" },
		"application/samlassertion+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/samlmetadata+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sarif+json": {
			"source": "iana",
			"compressible": true
		},
		"application/sarif-external-properties+json": {
			"source": "iana",
			"compressible": true
		},
		"application/sbe": { "source": "iana" },
		"application/sbml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sbml"]
		},
		"application/scaip+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/scim+json": {
			"source": "iana",
			"compressible": true
		},
		"application/scvp-cv-request": {
			"source": "iana",
			"extensions": ["scq"]
		},
		"application/scvp-cv-response": {
			"source": "iana",
			"extensions": ["scs"]
		},
		"application/scvp-vp-request": {
			"source": "iana",
			"extensions": ["spq"]
		},
		"application/scvp-vp-response": {
			"source": "iana",
			"extensions": ["spp"]
		},
		"application/sdp": {
			"source": "iana",
			"extensions": ["sdp"]
		},
		"application/secevent+jwt": { "source": "iana" },
		"application/senml+cbor": { "source": "iana" },
		"application/senml+json": {
			"source": "iana",
			"compressible": true
		},
		"application/senml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["senmlx"]
		},
		"application/senml-etch+cbor": { "source": "iana" },
		"application/senml-etch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/senml-exi": { "source": "iana" },
		"application/sensml+cbor": { "source": "iana" },
		"application/sensml+json": {
			"source": "iana",
			"compressible": true
		},
		"application/sensml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sensmlx"]
		},
		"application/sensml-exi": { "source": "iana" },
		"application/sep+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sep-exi": { "source": "iana" },
		"application/session-info": { "source": "iana" },
		"application/set-payment": { "source": "iana" },
		"application/set-payment-initiation": {
			"source": "iana",
			"extensions": ["setpay"]
		},
		"application/set-registration": { "source": "iana" },
		"application/set-registration-initiation": {
			"source": "iana",
			"extensions": ["setreg"]
		},
		"application/sgml": { "source": "iana" },
		"application/sgml-open-catalog": { "source": "iana" },
		"application/shf+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["shf"]
		},
		"application/sieve": {
			"source": "iana",
			"extensions": ["siv", "sieve"]
		},
		"application/simple-filter+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/simple-message-summary": { "source": "iana" },
		"application/simplesymbolcontainer": { "source": "iana" },
		"application/sipc": { "source": "iana" },
		"application/slate": { "source": "iana" },
		"application/smil": { "source": "iana" },
		"application/smil+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["smi", "smil"]
		},
		"application/smpte336m": { "source": "iana" },
		"application/soap+fastinfoset": { "source": "iana" },
		"application/soap+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sparql-query": {
			"source": "iana",
			"extensions": ["rq"]
		},
		"application/sparql-results+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["srx"]
		},
		"application/spdx+json": {
			"source": "iana",
			"compressible": true
		},
		"application/spirits-event+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sql": { "source": "iana" },
		"application/srgs": {
			"source": "iana",
			"extensions": ["gram"]
		},
		"application/srgs+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["grxml"]
		},
		"application/sru+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sru"]
		},
		"application/ssdl+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["ssdl"]
		},
		"application/ssml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ssml"]
		},
		"application/stix+json": {
			"source": "iana",
			"compressible": true
		},
		"application/swid+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["swidtag"]
		},
		"application/tamp-apex-update": { "source": "iana" },
		"application/tamp-apex-update-confirm": { "source": "iana" },
		"application/tamp-community-update": { "source": "iana" },
		"application/tamp-community-update-confirm": { "source": "iana" },
		"application/tamp-error": { "source": "iana" },
		"application/tamp-sequence-adjust": { "source": "iana" },
		"application/tamp-sequence-adjust-confirm": { "source": "iana" },
		"application/tamp-status-query": { "source": "iana" },
		"application/tamp-status-response": { "source": "iana" },
		"application/tamp-update": { "source": "iana" },
		"application/tamp-update-confirm": { "source": "iana" },
		"application/tar": { "compressible": true },
		"application/taxii+json": {
			"source": "iana",
			"compressible": true
		},
		"application/td+json": {
			"source": "iana",
			"compressible": true
		},
		"application/tei+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["tei", "teicorpus"]
		},
		"application/tetra_isi": { "source": "iana" },
		"application/thraud+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["tfi"]
		},
		"application/timestamp-query": { "source": "iana" },
		"application/timestamp-reply": { "source": "iana" },
		"application/timestamped-data": {
			"source": "iana",
			"extensions": ["tsd"]
		},
		"application/tlsrpt+gzip": { "source": "iana" },
		"application/tlsrpt+json": {
			"source": "iana",
			"compressible": true
		},
		"application/tnauthlist": { "source": "iana" },
		"application/token-introspection+jwt": { "source": "iana" },
		"application/toml": {
			"compressible": true,
			"extensions": ["toml"]
		},
		"application/trickle-ice-sdpfrag": { "source": "iana" },
		"application/trig": {
			"source": "iana",
			"extensions": ["trig"]
		},
		"application/ttml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ttml"]
		},
		"application/tve-trigger": { "source": "iana" },
		"application/tzif": { "source": "iana" },
		"application/tzif-leap": { "source": "iana" },
		"application/ubjson": {
			"compressible": false,
			"extensions": ["ubj"]
		},
		"application/ulpfec": { "source": "iana" },
		"application/urc-grpsheet+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/urc-ressheet+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rsheet"]
		},
		"application/urc-targetdesc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["td"]
		},
		"application/urc-uisocketdesc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vcard+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vcard+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vemmi": { "source": "iana" },
		"application/vividence.scriptfile": { "source": "apache" },
		"application/vnd.1000minds.decision-model+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["1km"]
		},
		"application/vnd.3gpp-prose+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp-prose-pc3ch+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp-v2x-local-service-information": { "source": "iana" },
		"application/vnd.3gpp.5gnas": { "source": "iana" },
		"application/vnd.3gpp.access-transfer-events+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.bsf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.gmop+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.gtpc": { "source": "iana" },
		"application/vnd.3gpp.interworking-data": { "source": "iana" },
		"application/vnd.3gpp.lpp": { "source": "iana" },
		"application/vnd.3gpp.mc-signalling-ear": { "source": "iana" },
		"application/vnd.3gpp.mcdata-affiliation-command+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcdata-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcdata-payload": { "source": "iana" },
		"application/vnd.3gpp.mcdata-service-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcdata-signalling": { "source": "iana" },
		"application/vnd.3gpp.mcdata-ue-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcdata-user-profile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-affiliation-command+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-floor-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-location-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-service-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-signed+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-ue-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-ue-init-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-user-profile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-affiliation-command+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-affiliation-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-location-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-service-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-transmission-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-ue-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-user-profile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mid-call+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.ngap": { "source": "iana" },
		"application/vnd.3gpp.pfcp": { "source": "iana" },
		"application/vnd.3gpp.pic-bw-large": {
			"source": "iana",
			"extensions": ["plb"]
		},
		"application/vnd.3gpp.pic-bw-small": {
			"source": "iana",
			"extensions": ["psb"]
		},
		"application/vnd.3gpp.pic-bw-var": {
			"source": "iana",
			"extensions": ["pvb"]
		},
		"application/vnd.3gpp.s1ap": { "source": "iana" },
		"application/vnd.3gpp.sms": { "source": "iana" },
		"application/vnd.3gpp.sms+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.srvcc-ext+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.srvcc-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.state-and-event-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.ussd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp2.bcmcsinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp2.sms": { "source": "iana" },
		"application/vnd.3gpp2.tcap": {
			"source": "iana",
			"extensions": ["tcap"]
		},
		"application/vnd.3lightssoftware.imagescal": { "source": "iana" },
		"application/vnd.3m.post-it-notes": {
			"source": "iana",
			"extensions": ["pwn"]
		},
		"application/vnd.accpac.simply.aso": {
			"source": "iana",
			"extensions": ["aso"]
		},
		"application/vnd.accpac.simply.imp": {
			"source": "iana",
			"extensions": ["imp"]
		},
		"application/vnd.acucobol": {
			"source": "iana",
			"extensions": ["acu"]
		},
		"application/vnd.acucorp": {
			"source": "iana",
			"extensions": ["atc", "acutc"]
		},
		"application/vnd.adobe.air-application-installer-package+zip": {
			"source": "apache",
			"compressible": false,
			"extensions": ["air"]
		},
		"application/vnd.adobe.flash.movie": { "source": "iana" },
		"application/vnd.adobe.formscentral.fcdt": {
			"source": "iana",
			"extensions": ["fcdt"]
		},
		"application/vnd.adobe.fxp": {
			"source": "iana",
			"extensions": ["fxp", "fxpl"]
		},
		"application/vnd.adobe.partial-upload": { "source": "iana" },
		"application/vnd.adobe.xdp+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xdp"]
		},
		"application/vnd.adobe.xfdf": {
			"source": "iana",
			"extensions": ["xfdf"]
		},
		"application/vnd.aether.imp": { "source": "iana" },
		"application/vnd.afpc.afplinedata": { "source": "iana" },
		"application/vnd.afpc.afplinedata-pagedef": { "source": "iana" },
		"application/vnd.afpc.cmoca-cmresource": { "source": "iana" },
		"application/vnd.afpc.foca-charset": { "source": "iana" },
		"application/vnd.afpc.foca-codedfont": { "source": "iana" },
		"application/vnd.afpc.foca-codepage": { "source": "iana" },
		"application/vnd.afpc.modca": { "source": "iana" },
		"application/vnd.afpc.modca-cmtable": { "source": "iana" },
		"application/vnd.afpc.modca-formdef": { "source": "iana" },
		"application/vnd.afpc.modca-mediummap": { "source": "iana" },
		"application/vnd.afpc.modca-objectcontainer": { "source": "iana" },
		"application/vnd.afpc.modca-overlay": { "source": "iana" },
		"application/vnd.afpc.modca-pagesegment": { "source": "iana" },
		"application/vnd.age": {
			"source": "iana",
			"extensions": ["age"]
		},
		"application/vnd.ah-barcode": { "source": "iana" },
		"application/vnd.ahead.space": {
			"source": "iana",
			"extensions": ["ahead"]
		},
		"application/vnd.airzip.filesecure.azf": {
			"source": "iana",
			"extensions": ["azf"]
		},
		"application/vnd.airzip.filesecure.azs": {
			"source": "iana",
			"extensions": ["azs"]
		},
		"application/vnd.amadeus+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.amazon.ebook": {
			"source": "apache",
			"extensions": ["azw"]
		},
		"application/vnd.amazon.mobi8-ebook": { "source": "iana" },
		"application/vnd.americandynamics.acc": {
			"source": "iana",
			"extensions": ["acc"]
		},
		"application/vnd.amiga.ami": {
			"source": "iana",
			"extensions": ["ami"]
		},
		"application/vnd.amundsen.maze+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.android.ota": { "source": "iana" },
		"application/vnd.android.package-archive": {
			"source": "apache",
			"compressible": false,
			"extensions": ["apk"]
		},
		"application/vnd.anki": { "source": "iana" },
		"application/vnd.anser-web-certificate-issue-initiation": {
			"source": "iana",
			"extensions": ["cii"]
		},
		"application/vnd.anser-web-funds-transfer-initiation": {
			"source": "apache",
			"extensions": ["fti"]
		},
		"application/vnd.antix.game-component": {
			"source": "iana",
			"extensions": ["atx"]
		},
		"application/vnd.apache.arrow.file": { "source": "iana" },
		"application/vnd.apache.arrow.stream": { "source": "iana" },
		"application/vnd.apache.thrift.binary": { "source": "iana" },
		"application/vnd.apache.thrift.compact": { "source": "iana" },
		"application/vnd.apache.thrift.json": { "source": "iana" },
		"application/vnd.api+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.aplextor.warrp+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.apothekende.reservation+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.apple.installer+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mpkg"]
		},
		"application/vnd.apple.keynote": {
			"source": "iana",
			"extensions": ["key"]
		},
		"application/vnd.apple.mpegurl": {
			"source": "iana",
			"extensions": ["m3u8"]
		},
		"application/vnd.apple.numbers": {
			"source": "iana",
			"extensions": ["numbers"]
		},
		"application/vnd.apple.pages": {
			"source": "iana",
			"extensions": ["pages"]
		},
		"application/vnd.apple.pkpass": {
			"compressible": false,
			"extensions": ["pkpass"]
		},
		"application/vnd.arastra.swi": { "source": "iana" },
		"application/vnd.aristanetworks.swi": {
			"source": "iana",
			"extensions": ["swi"]
		},
		"application/vnd.artisan+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.artsquare": { "source": "iana" },
		"application/vnd.astraea-software.iota": {
			"source": "iana",
			"extensions": ["iota"]
		},
		"application/vnd.audiograph": {
			"source": "iana",
			"extensions": ["aep"]
		},
		"application/vnd.autopackage": { "source": "iana" },
		"application/vnd.avalon+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.avistar+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.balsamiq.bmml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["bmml"]
		},
		"application/vnd.balsamiq.bmpr": { "source": "iana" },
		"application/vnd.banana-accounting": { "source": "iana" },
		"application/vnd.bbf.usp.error": { "source": "iana" },
		"application/vnd.bbf.usp.msg": { "source": "iana" },
		"application/vnd.bbf.usp.msg+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.bekitzur-stech+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.bint.med-content": { "source": "iana" },
		"application/vnd.biopax.rdf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.blink-idb-value-wrapper": { "source": "iana" },
		"application/vnd.blueice.multipass": {
			"source": "iana",
			"extensions": ["mpm"]
		},
		"application/vnd.bluetooth.ep.oob": { "source": "iana" },
		"application/vnd.bluetooth.le.oob": { "source": "iana" },
		"application/vnd.bmi": {
			"source": "iana",
			"extensions": ["bmi"]
		},
		"application/vnd.bpf": { "source": "iana" },
		"application/vnd.bpf3": { "source": "iana" },
		"application/vnd.businessobjects": {
			"source": "iana",
			"extensions": ["rep"]
		},
		"application/vnd.byu.uapi+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cab-jscript": { "source": "iana" },
		"application/vnd.canon-cpdl": { "source": "iana" },
		"application/vnd.canon-lips": { "source": "iana" },
		"application/vnd.capasystems-pg+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cendio.thinlinc.clientconf": { "source": "iana" },
		"application/vnd.century-systems.tcp_stream": { "source": "iana" },
		"application/vnd.chemdraw+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["cdxml"]
		},
		"application/vnd.chess-pgn": { "source": "iana" },
		"application/vnd.chipnuts.karaoke-mmd": {
			"source": "iana",
			"extensions": ["mmd"]
		},
		"application/vnd.ciedi": { "source": "iana" },
		"application/vnd.cinderella": {
			"source": "iana",
			"extensions": ["cdy"]
		},
		"application/vnd.cirpack.isdn-ext": { "source": "iana" },
		"application/vnd.citationstyles.style+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["csl"]
		},
		"application/vnd.claymore": {
			"source": "iana",
			"extensions": ["cla"]
		},
		"application/vnd.cloanto.rp9": {
			"source": "iana",
			"extensions": ["rp9"]
		},
		"application/vnd.clonk.c4group": {
			"source": "iana",
			"extensions": [
				"c4g",
				"c4d",
				"c4f",
				"c4p",
				"c4u"
			]
		},
		"application/vnd.cluetrust.cartomobile-config": {
			"source": "iana",
			"extensions": ["c11amc"]
		},
		"application/vnd.cluetrust.cartomobile-config-pkg": {
			"source": "iana",
			"extensions": ["c11amz"]
		},
		"application/vnd.coffeescript": { "source": "iana" },
		"application/vnd.collabio.xodocuments.document": { "source": "iana" },
		"application/vnd.collabio.xodocuments.document-template": { "source": "iana" },
		"application/vnd.collabio.xodocuments.presentation": { "source": "iana" },
		"application/vnd.collabio.xodocuments.presentation-template": { "source": "iana" },
		"application/vnd.collabio.xodocuments.spreadsheet": { "source": "iana" },
		"application/vnd.collabio.xodocuments.spreadsheet-template": { "source": "iana" },
		"application/vnd.collection+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.collection.doc+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.collection.next+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.comicbook+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.comicbook-rar": { "source": "iana" },
		"application/vnd.commerce-battelle": { "source": "iana" },
		"application/vnd.commonspace": {
			"source": "iana",
			"extensions": ["csp"]
		},
		"application/vnd.contact.cmsg": {
			"source": "iana",
			"extensions": ["cdbcmsg"]
		},
		"application/vnd.coreos.ignition+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cosmocaller": {
			"source": "iana",
			"extensions": ["cmc"]
		},
		"application/vnd.crick.clicker": {
			"source": "iana",
			"extensions": ["clkx"]
		},
		"application/vnd.crick.clicker.keyboard": {
			"source": "iana",
			"extensions": ["clkk"]
		},
		"application/vnd.crick.clicker.palette": {
			"source": "iana",
			"extensions": ["clkp"]
		},
		"application/vnd.crick.clicker.template": {
			"source": "iana",
			"extensions": ["clkt"]
		},
		"application/vnd.crick.clicker.wordbank": {
			"source": "iana",
			"extensions": ["clkw"]
		},
		"application/vnd.criticaltools.wbs+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wbs"]
		},
		"application/vnd.cryptii.pipe+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.crypto-shade-file": { "source": "iana" },
		"application/vnd.cryptomator.encrypted": { "source": "iana" },
		"application/vnd.cryptomator.vault": { "source": "iana" },
		"application/vnd.ctc-posml": {
			"source": "iana",
			"extensions": ["pml"]
		},
		"application/vnd.ctct.ws+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cups-pdf": { "source": "iana" },
		"application/vnd.cups-postscript": { "source": "iana" },
		"application/vnd.cups-ppd": {
			"source": "iana",
			"extensions": ["ppd"]
		},
		"application/vnd.cups-raster": { "source": "iana" },
		"application/vnd.cups-raw": { "source": "iana" },
		"application/vnd.curl": { "source": "iana" },
		"application/vnd.curl.car": {
			"source": "apache",
			"extensions": ["car"]
		},
		"application/vnd.curl.pcurl": {
			"source": "apache",
			"extensions": ["pcurl"]
		},
		"application/vnd.cyan.dean.root+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cybank": { "source": "iana" },
		"application/vnd.cyclonedx+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cyclonedx+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.d2l.coursepackage1p0+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.d3m-dataset": { "source": "iana" },
		"application/vnd.d3m-problem": { "source": "iana" },
		"application/vnd.dart": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dart"]
		},
		"application/vnd.data-vision.rdz": {
			"source": "iana",
			"extensions": ["rdz"]
		},
		"application/vnd.datapackage+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dataresource+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dbf": {
			"source": "iana",
			"extensions": ["dbf"]
		},
		"application/vnd.debian.binary-package": { "source": "iana" },
		"application/vnd.dece.data": {
			"source": "iana",
			"extensions": [
				"uvf",
				"uvvf",
				"uvd",
				"uvvd"
			]
		},
		"application/vnd.dece.ttml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["uvt", "uvvt"]
		},
		"application/vnd.dece.unspecified": {
			"source": "iana",
			"extensions": ["uvx", "uvvx"]
		},
		"application/vnd.dece.zip": {
			"source": "iana",
			"extensions": ["uvz", "uvvz"]
		},
		"application/vnd.denovo.fcselayout-link": {
			"source": "iana",
			"extensions": ["fe_launch"]
		},
		"application/vnd.desmume.movie": { "source": "iana" },
		"application/vnd.dir-bi.plate-dl-nosuffix": { "source": "iana" },
		"application/vnd.dm.delegation+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dna": {
			"source": "iana",
			"extensions": ["dna"]
		},
		"application/vnd.document+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dolby.mlp": {
			"source": "apache",
			"extensions": ["mlp"]
		},
		"application/vnd.dolby.mobile.1": { "source": "iana" },
		"application/vnd.dolby.mobile.2": { "source": "iana" },
		"application/vnd.doremir.scorecloud-binary-document": { "source": "iana" },
		"application/vnd.dpgraph": {
			"source": "iana",
			"extensions": ["dpg"]
		},
		"application/vnd.dreamfactory": {
			"source": "iana",
			"extensions": ["dfac"]
		},
		"application/vnd.drive+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ds-keypoint": {
			"source": "apache",
			"extensions": ["kpxx"]
		},
		"application/vnd.dtg.local": { "source": "iana" },
		"application/vnd.dtg.local.flash": { "source": "iana" },
		"application/vnd.dtg.local.html": { "source": "iana" },
		"application/vnd.dvb.ait": {
			"source": "iana",
			"extensions": ["ait"]
		},
		"application/vnd.dvb.dvbisl+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.dvbj": { "source": "iana" },
		"application/vnd.dvb.esgcontainer": { "source": "iana" },
		"application/vnd.dvb.ipdcdftnotifaccess": { "source": "iana" },
		"application/vnd.dvb.ipdcesgaccess": { "source": "iana" },
		"application/vnd.dvb.ipdcesgaccess2": { "source": "iana" },
		"application/vnd.dvb.ipdcesgpdd": { "source": "iana" },
		"application/vnd.dvb.ipdcroaming": { "source": "iana" },
		"application/vnd.dvb.iptv.alfec-base": { "source": "iana" },
		"application/vnd.dvb.iptv.alfec-enhancement": { "source": "iana" },
		"application/vnd.dvb.notif-aggregate-root+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-container+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-generic+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-ia-msglist+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-ia-registration-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-ia-registration-response+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-init+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.pfr": { "source": "iana" },
		"application/vnd.dvb.service": {
			"source": "iana",
			"extensions": ["svc"]
		},
		"application/vnd.dxr": { "source": "iana" },
		"application/vnd.dynageo": {
			"source": "iana",
			"extensions": ["geo"]
		},
		"application/vnd.dzr": { "source": "iana" },
		"application/vnd.easykaraoke.cdgdownload": { "source": "iana" },
		"application/vnd.ecdis-update": { "source": "iana" },
		"application/vnd.ecip.rlp": { "source": "iana" },
		"application/vnd.eclipse.ditto+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ecowin.chart": {
			"source": "iana",
			"extensions": ["mag"]
		},
		"application/vnd.ecowin.filerequest": { "source": "iana" },
		"application/vnd.ecowin.fileupdate": { "source": "iana" },
		"application/vnd.ecowin.series": { "source": "iana" },
		"application/vnd.ecowin.seriesrequest": { "source": "iana" },
		"application/vnd.ecowin.seriesupdate": { "source": "iana" },
		"application/vnd.efi.img": { "source": "iana" },
		"application/vnd.efi.iso": { "source": "iana" },
		"application/vnd.emclient.accessrequest+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.enliven": {
			"source": "iana",
			"extensions": ["nml"]
		},
		"application/vnd.enphase.envoy": { "source": "iana" },
		"application/vnd.eprints.data+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.epson.esf": {
			"source": "iana",
			"extensions": ["esf"]
		},
		"application/vnd.epson.msf": {
			"source": "iana",
			"extensions": ["msf"]
		},
		"application/vnd.epson.quickanime": {
			"source": "iana",
			"extensions": ["qam"]
		},
		"application/vnd.epson.salt": {
			"source": "iana",
			"extensions": ["slt"]
		},
		"application/vnd.epson.ssf": {
			"source": "iana",
			"extensions": ["ssf"]
		},
		"application/vnd.ericsson.quickcall": { "source": "iana" },
		"application/vnd.espass-espass+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.eszigno3+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["es3", "et3"]
		},
		"application/vnd.etsi.aoc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.asic-e+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.etsi.asic-s+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.etsi.cug+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvcommand+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvdiscovery+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvprofile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvsad-bc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvsad-cod+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvsad-npvr+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvservice+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvsync+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvueprofile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.mcid+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.mheg5": { "source": "iana" },
		"application/vnd.etsi.overload-control-policy-dataset+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.pstn+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.sci+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.simservs+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.timestamp-token": { "source": "iana" },
		"application/vnd.etsi.tsl+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.tsl.der": { "source": "iana" },
		"application/vnd.eu.kasparian.car+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.eudora.data": { "source": "iana" },
		"application/vnd.evolv.ecig.profile": { "source": "iana" },
		"application/vnd.evolv.ecig.settings": { "source": "iana" },
		"application/vnd.evolv.ecig.theme": { "source": "iana" },
		"application/vnd.exstream-empower+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.exstream-package": { "source": "iana" },
		"application/vnd.ezpix-album": {
			"source": "iana",
			"extensions": ["ez2"]
		},
		"application/vnd.ezpix-package": {
			"source": "iana",
			"extensions": ["ez3"]
		},
		"application/vnd.f-secure.mobile": { "source": "iana" },
		"application/vnd.familysearch.gedcom+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.fastcopy-disk-image": { "source": "iana" },
		"application/vnd.fdf": {
			"source": "iana",
			"extensions": ["fdf"]
		},
		"application/vnd.fdsn.mseed": {
			"source": "iana",
			"extensions": ["mseed"]
		},
		"application/vnd.fdsn.seed": {
			"source": "iana",
			"extensions": ["seed", "dataless"]
		},
		"application/vnd.ffsns": { "source": "iana" },
		"application/vnd.ficlab.flb+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.filmit.zfc": { "source": "iana" },
		"application/vnd.fints": { "source": "iana" },
		"application/vnd.firemonkeys.cloudcell": { "source": "iana" },
		"application/vnd.flographit": {
			"source": "iana",
			"extensions": ["gph"]
		},
		"application/vnd.fluxtime.clip": {
			"source": "iana",
			"extensions": ["ftc"]
		},
		"application/vnd.font-fontforge-sfd": { "source": "iana" },
		"application/vnd.framemaker": {
			"source": "iana",
			"extensions": [
				"fm",
				"frame",
				"maker",
				"book"
			]
		},
		"application/vnd.frogans.fnc": {
			"source": "iana",
			"extensions": ["fnc"]
		},
		"application/vnd.frogans.ltf": {
			"source": "iana",
			"extensions": ["ltf"]
		},
		"application/vnd.fsc.weblaunch": {
			"source": "iana",
			"extensions": ["fsc"]
		},
		"application/vnd.fujifilm.fb.docuworks": { "source": "iana" },
		"application/vnd.fujifilm.fb.docuworks.binder": { "source": "iana" },
		"application/vnd.fujifilm.fb.docuworks.container": { "source": "iana" },
		"application/vnd.fujifilm.fb.jfi+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.fujitsu.oasys": {
			"source": "iana",
			"extensions": ["oas"]
		},
		"application/vnd.fujitsu.oasys2": {
			"source": "iana",
			"extensions": ["oa2"]
		},
		"application/vnd.fujitsu.oasys3": {
			"source": "iana",
			"extensions": ["oa3"]
		},
		"application/vnd.fujitsu.oasysgp": {
			"source": "iana",
			"extensions": ["fg5"]
		},
		"application/vnd.fujitsu.oasysprs": {
			"source": "iana",
			"extensions": ["bh2"]
		},
		"application/vnd.fujixerox.art-ex": { "source": "iana" },
		"application/vnd.fujixerox.art4": { "source": "iana" },
		"application/vnd.fujixerox.ddd": {
			"source": "iana",
			"extensions": ["ddd"]
		},
		"application/vnd.fujixerox.docuworks": {
			"source": "iana",
			"extensions": ["xdw"]
		},
		"application/vnd.fujixerox.docuworks.binder": {
			"source": "iana",
			"extensions": ["xbd"]
		},
		"application/vnd.fujixerox.docuworks.container": { "source": "iana" },
		"application/vnd.fujixerox.hbpl": { "source": "iana" },
		"application/vnd.fut-misnet": { "source": "iana" },
		"application/vnd.futoin+cbor": { "source": "iana" },
		"application/vnd.futoin+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.fuzzysheet": {
			"source": "iana",
			"extensions": ["fzs"]
		},
		"application/vnd.genomatix.tuxedo": {
			"source": "iana",
			"extensions": ["txd"]
		},
		"application/vnd.gentics.grd+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.geo+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.geocube+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.geogebra.file": {
			"source": "iana",
			"extensions": ["ggb"]
		},
		"application/vnd.geogebra.slides": { "source": "iana" },
		"application/vnd.geogebra.tool": {
			"source": "iana",
			"extensions": ["ggt"]
		},
		"application/vnd.geometry-explorer": {
			"source": "iana",
			"extensions": ["gex", "gre"]
		},
		"application/vnd.geonext": {
			"source": "iana",
			"extensions": ["gxt"]
		},
		"application/vnd.geoplan": {
			"source": "iana",
			"extensions": ["g2w"]
		},
		"application/vnd.geospace": {
			"source": "iana",
			"extensions": ["g3w"]
		},
		"application/vnd.gerber": { "source": "iana" },
		"application/vnd.globalplatform.card-content-mgt": { "source": "iana" },
		"application/vnd.globalplatform.card-content-mgt-response": { "source": "iana" },
		"application/vnd.gmx": {
			"source": "iana",
			"extensions": ["gmx"]
		},
		"application/vnd.google-apps.document": {
			"compressible": false,
			"extensions": ["gdoc"]
		},
		"application/vnd.google-apps.presentation": {
			"compressible": false,
			"extensions": ["gslides"]
		},
		"application/vnd.google-apps.spreadsheet": {
			"compressible": false,
			"extensions": ["gsheet"]
		},
		"application/vnd.google-earth.kml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["kml"]
		},
		"application/vnd.google-earth.kmz": {
			"source": "iana",
			"compressible": false,
			"extensions": ["kmz"]
		},
		"application/vnd.gov.sk.e-form+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.gov.sk.e-form+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.gov.sk.xmldatacontainer+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.grafeq": {
			"source": "iana",
			"extensions": ["gqf", "gqs"]
		},
		"application/vnd.gridmp": { "source": "iana" },
		"application/vnd.groove-account": {
			"source": "iana",
			"extensions": ["gac"]
		},
		"application/vnd.groove-help": {
			"source": "iana",
			"extensions": ["ghf"]
		},
		"application/vnd.groove-identity-message": {
			"source": "iana",
			"extensions": ["gim"]
		},
		"application/vnd.groove-injector": {
			"source": "iana",
			"extensions": ["grv"]
		},
		"application/vnd.groove-tool-message": {
			"source": "iana",
			"extensions": ["gtm"]
		},
		"application/vnd.groove-tool-template": {
			"source": "iana",
			"extensions": ["tpl"]
		},
		"application/vnd.groove-vcard": {
			"source": "iana",
			"extensions": ["vcg"]
		},
		"application/vnd.hal+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hal+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["hal"]
		},
		"application/vnd.handheld-entertainment+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["zmm"]
		},
		"application/vnd.hbci": {
			"source": "iana",
			"extensions": ["hbci"]
		},
		"application/vnd.hc+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hcl-bireports": { "source": "iana" },
		"application/vnd.hdt": { "source": "iana" },
		"application/vnd.heroku+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hhe.lesson-player": {
			"source": "iana",
			"extensions": ["les"]
		},
		"application/vnd.hl7cda+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.hl7v2+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.hp-hpgl": {
			"source": "iana",
			"extensions": ["hpgl"]
		},
		"application/vnd.hp-hpid": {
			"source": "iana",
			"extensions": ["hpid"]
		},
		"application/vnd.hp-hps": {
			"source": "iana",
			"extensions": ["hps"]
		},
		"application/vnd.hp-jlyt": {
			"source": "iana",
			"extensions": ["jlt"]
		},
		"application/vnd.hp-pcl": {
			"source": "iana",
			"extensions": ["pcl"]
		},
		"application/vnd.hp-pclxl": {
			"source": "iana",
			"extensions": ["pclxl"]
		},
		"application/vnd.httphone": { "source": "iana" },
		"application/vnd.hydrostatix.sof-data": {
			"source": "iana",
			"extensions": ["sfd-hdstx"]
		},
		"application/vnd.hyper+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hyper-item+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hyperdrive+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hzn-3d-crossword": { "source": "iana" },
		"application/vnd.ibm.afplinedata": { "source": "iana" },
		"application/vnd.ibm.electronic-media": { "source": "iana" },
		"application/vnd.ibm.minipay": {
			"source": "iana",
			"extensions": ["mpy"]
		},
		"application/vnd.ibm.modcap": {
			"source": "iana",
			"extensions": [
				"afp",
				"listafp",
				"list3820"
			]
		},
		"application/vnd.ibm.rights-management": {
			"source": "iana",
			"extensions": ["irm"]
		},
		"application/vnd.ibm.secure-container": {
			"source": "iana",
			"extensions": ["sc"]
		},
		"application/vnd.iccprofile": {
			"source": "iana",
			"extensions": ["icc", "icm"]
		},
		"application/vnd.ieee.1905": { "source": "iana" },
		"application/vnd.igloader": {
			"source": "iana",
			"extensions": ["igl"]
		},
		"application/vnd.imagemeter.folder+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.imagemeter.image+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.immervision-ivp": {
			"source": "iana",
			"extensions": ["ivp"]
		},
		"application/vnd.immervision-ivu": {
			"source": "iana",
			"extensions": ["ivu"]
		},
		"application/vnd.ims.imsccv1p1": { "source": "iana" },
		"application/vnd.ims.imsccv1p2": { "source": "iana" },
		"application/vnd.ims.imsccv1p3": { "source": "iana" },
		"application/vnd.ims.lis.v2.result+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolproxy+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolproxy.id+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolsettings+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolsettings.simple+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.informedcontrol.rms+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.informix-visionary": { "source": "iana" },
		"application/vnd.infotech.project": { "source": "iana" },
		"application/vnd.infotech.project+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.innopath.wamp.notification": { "source": "iana" },
		"application/vnd.insors.igm": {
			"source": "iana",
			"extensions": ["igm"]
		},
		"application/vnd.intercon.formnet": {
			"source": "iana",
			"extensions": ["xpw", "xpx"]
		},
		"application/vnd.intergeo": {
			"source": "iana",
			"extensions": ["i2g"]
		},
		"application/vnd.intertrust.digibox": { "source": "iana" },
		"application/vnd.intertrust.nncp": { "source": "iana" },
		"application/vnd.intu.qbo": {
			"source": "iana",
			"extensions": ["qbo"]
		},
		"application/vnd.intu.qfx": {
			"source": "iana",
			"extensions": ["qfx"]
		},
		"application/vnd.iptc.g2.catalogitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.conceptitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.knowledgeitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.newsitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.newsmessage+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.packageitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.planningitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ipunplugged.rcprofile": {
			"source": "iana",
			"extensions": ["rcprofile"]
		},
		"application/vnd.irepository.package+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["irp"]
		},
		"application/vnd.is-xpr": {
			"source": "iana",
			"extensions": ["xpr"]
		},
		"application/vnd.isac.fcs": {
			"source": "iana",
			"extensions": ["fcs"]
		},
		"application/vnd.iso11783-10+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.jam": {
			"source": "iana",
			"extensions": ["jam"]
		},
		"application/vnd.japannet-directory-service": { "source": "iana" },
		"application/vnd.japannet-jpnstore-wakeup": { "source": "iana" },
		"application/vnd.japannet-payment-wakeup": { "source": "iana" },
		"application/vnd.japannet-registration": { "source": "iana" },
		"application/vnd.japannet-registration-wakeup": { "source": "iana" },
		"application/vnd.japannet-setstore-wakeup": { "source": "iana" },
		"application/vnd.japannet-verification": { "source": "iana" },
		"application/vnd.japannet-verification-wakeup": { "source": "iana" },
		"application/vnd.jcp.javame.midlet-rms": {
			"source": "iana",
			"extensions": ["rms"]
		},
		"application/vnd.jisp": {
			"source": "iana",
			"extensions": ["jisp"]
		},
		"application/vnd.joost.joda-archive": {
			"source": "iana",
			"extensions": ["joda"]
		},
		"application/vnd.jsk.isdn-ngn": { "source": "iana" },
		"application/vnd.kahootz": {
			"source": "iana",
			"extensions": ["ktz", "ktr"]
		},
		"application/vnd.kde.karbon": {
			"source": "iana",
			"extensions": ["karbon"]
		},
		"application/vnd.kde.kchart": {
			"source": "iana",
			"extensions": ["chrt"]
		},
		"application/vnd.kde.kformula": {
			"source": "iana",
			"extensions": ["kfo"]
		},
		"application/vnd.kde.kivio": {
			"source": "iana",
			"extensions": ["flw"]
		},
		"application/vnd.kde.kontour": {
			"source": "iana",
			"extensions": ["kon"]
		},
		"application/vnd.kde.kpresenter": {
			"source": "iana",
			"extensions": ["kpr", "kpt"]
		},
		"application/vnd.kde.kspread": {
			"source": "iana",
			"extensions": ["ksp"]
		},
		"application/vnd.kde.kword": {
			"source": "iana",
			"extensions": ["kwd", "kwt"]
		},
		"application/vnd.kenameaapp": {
			"source": "iana",
			"extensions": ["htke"]
		},
		"application/vnd.kidspiration": {
			"source": "iana",
			"extensions": ["kia"]
		},
		"application/vnd.kinar": {
			"source": "iana",
			"extensions": ["kne", "knp"]
		},
		"application/vnd.koan": {
			"source": "iana",
			"extensions": [
				"skp",
				"skd",
				"skt",
				"skm"
			]
		},
		"application/vnd.kodak-descriptor": {
			"source": "iana",
			"extensions": ["sse"]
		},
		"application/vnd.las": { "source": "iana" },
		"application/vnd.las.las+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.las.las+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["lasxml"]
		},
		"application/vnd.laszip": { "source": "iana" },
		"application/vnd.leap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.liberty-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.llamagraphics.life-balance.desktop": {
			"source": "iana",
			"extensions": ["lbd"]
		},
		"application/vnd.llamagraphics.life-balance.exchange+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["lbe"]
		},
		"application/vnd.logipipe.circuit+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.loom": { "source": "iana" },
		"application/vnd.lotus-1-2-3": {
			"source": "iana",
			"extensions": ["123"]
		},
		"application/vnd.lotus-approach": {
			"source": "iana",
			"extensions": ["apr"]
		},
		"application/vnd.lotus-freelance": {
			"source": "iana",
			"extensions": ["pre"]
		},
		"application/vnd.lotus-notes": {
			"source": "iana",
			"extensions": ["nsf"]
		},
		"application/vnd.lotus-organizer": {
			"source": "iana",
			"extensions": ["org"]
		},
		"application/vnd.lotus-screencam": {
			"source": "iana",
			"extensions": ["scm"]
		},
		"application/vnd.lotus-wordpro": {
			"source": "iana",
			"extensions": ["lwp"]
		},
		"application/vnd.macports.portpkg": {
			"source": "iana",
			"extensions": ["portpkg"]
		},
		"application/vnd.mapbox-vector-tile": {
			"source": "iana",
			"extensions": ["mvt"]
		},
		"application/vnd.marlin.drm.actiontoken+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.marlin.drm.conftoken+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.marlin.drm.license+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.marlin.drm.mdcf": { "source": "iana" },
		"application/vnd.mason+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.maxar.archive.3tz+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.maxmind.maxmind-db": { "source": "iana" },
		"application/vnd.mcd": {
			"source": "iana",
			"extensions": ["mcd"]
		},
		"application/vnd.medcalcdata": {
			"source": "iana",
			"extensions": ["mc1"]
		},
		"application/vnd.mediastation.cdkey": {
			"source": "iana",
			"extensions": ["cdkey"]
		},
		"application/vnd.meridian-slingshot": { "source": "iana" },
		"application/vnd.mfer": {
			"source": "iana",
			"extensions": ["mwf"]
		},
		"application/vnd.mfmp": {
			"source": "iana",
			"extensions": ["mfm"]
		},
		"application/vnd.micro+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.micrografx.flo": {
			"source": "iana",
			"extensions": ["flo"]
		},
		"application/vnd.micrografx.igx": {
			"source": "iana",
			"extensions": ["igx"]
		},
		"application/vnd.microsoft.portable-executable": { "source": "iana" },
		"application/vnd.microsoft.windows.thumbnail-cache": { "source": "iana" },
		"application/vnd.miele+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.mif": {
			"source": "iana",
			"extensions": ["mif"]
		},
		"application/vnd.minisoft-hp3000-save": { "source": "iana" },
		"application/vnd.mitsubishi.misty-guard.trustweb": { "source": "iana" },
		"application/vnd.mobius.daf": {
			"source": "iana",
			"extensions": ["daf"]
		},
		"application/vnd.mobius.dis": {
			"source": "iana",
			"extensions": ["dis"]
		},
		"application/vnd.mobius.mbk": {
			"source": "iana",
			"extensions": ["mbk"]
		},
		"application/vnd.mobius.mqy": {
			"source": "iana",
			"extensions": ["mqy"]
		},
		"application/vnd.mobius.msl": {
			"source": "iana",
			"extensions": ["msl"]
		},
		"application/vnd.mobius.plc": {
			"source": "iana",
			"extensions": ["plc"]
		},
		"application/vnd.mobius.txf": {
			"source": "iana",
			"extensions": ["txf"]
		},
		"application/vnd.mophun.application": {
			"source": "iana",
			"extensions": ["mpn"]
		},
		"application/vnd.mophun.certificate": {
			"source": "iana",
			"extensions": ["mpc"]
		},
		"application/vnd.motorola.flexsuite": { "source": "iana" },
		"application/vnd.motorola.flexsuite.adsi": { "source": "iana" },
		"application/vnd.motorola.flexsuite.fis": { "source": "iana" },
		"application/vnd.motorola.flexsuite.gotap": { "source": "iana" },
		"application/vnd.motorola.flexsuite.kmr": { "source": "iana" },
		"application/vnd.motorola.flexsuite.ttc": { "source": "iana" },
		"application/vnd.motorola.flexsuite.wem": { "source": "iana" },
		"application/vnd.motorola.iprm": { "source": "iana" },
		"application/vnd.mozilla.xul+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xul"]
		},
		"application/vnd.ms-3mfdocument": { "source": "iana" },
		"application/vnd.ms-artgalry": {
			"source": "iana",
			"extensions": ["cil"]
		},
		"application/vnd.ms-asf": { "source": "iana" },
		"application/vnd.ms-cab-compressed": {
			"source": "iana",
			"extensions": ["cab"]
		},
		"application/vnd.ms-color.iccprofile": { "source": "apache" },
		"application/vnd.ms-excel": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"xls",
				"xlm",
				"xla",
				"xlc",
				"xlt",
				"xlw"
			]
		},
		"application/vnd.ms-excel.addin.macroenabled.12": {
			"source": "iana",
			"extensions": ["xlam"]
		},
		"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
			"source": "iana",
			"extensions": ["xlsb"]
		},
		"application/vnd.ms-excel.sheet.macroenabled.12": {
			"source": "iana",
			"extensions": ["xlsm"]
		},
		"application/vnd.ms-excel.template.macroenabled.12": {
			"source": "iana",
			"extensions": ["xltm"]
		},
		"application/vnd.ms-fontobject": {
			"source": "iana",
			"compressible": true,
			"extensions": ["eot"]
		},
		"application/vnd.ms-htmlhelp": {
			"source": "iana",
			"extensions": ["chm"]
		},
		"application/vnd.ms-ims": {
			"source": "iana",
			"extensions": ["ims"]
		},
		"application/vnd.ms-lrm": {
			"source": "iana",
			"extensions": ["lrm"]
		},
		"application/vnd.ms-office.activex+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ms-officetheme": {
			"source": "iana",
			"extensions": ["thmx"]
		},
		"application/vnd.ms-opentype": {
			"source": "apache",
			"compressible": true
		},
		"application/vnd.ms-outlook": {
			"compressible": false,
			"extensions": ["msg"]
		},
		"application/vnd.ms-package.obfuscated-opentype": { "source": "apache" },
		"application/vnd.ms-pki.seccat": {
			"source": "apache",
			"extensions": ["cat"]
		},
		"application/vnd.ms-pki.stl": {
			"source": "apache",
			"extensions": ["stl"]
		},
		"application/vnd.ms-playready.initiator+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ms-powerpoint": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"ppt",
				"pps",
				"pot"
			]
		},
		"application/vnd.ms-powerpoint.addin.macroenabled.12": {
			"source": "iana",
			"extensions": ["ppam"]
		},
		"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
			"source": "iana",
			"extensions": ["pptm"]
		},
		"application/vnd.ms-powerpoint.slide.macroenabled.12": {
			"source": "iana",
			"extensions": ["sldm"]
		},
		"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
			"source": "iana",
			"extensions": ["ppsm"]
		},
		"application/vnd.ms-powerpoint.template.macroenabled.12": {
			"source": "iana",
			"extensions": ["potm"]
		},
		"application/vnd.ms-printdevicecapabilities+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ms-printing.printticket+xml": {
			"source": "apache",
			"compressible": true
		},
		"application/vnd.ms-printschematicket+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ms-project": {
			"source": "iana",
			"extensions": ["mpp", "mpt"]
		},
		"application/vnd.ms-tnef": { "source": "iana" },
		"application/vnd.ms-windows.devicepairing": { "source": "iana" },
		"application/vnd.ms-windows.nwprinting.oob": { "source": "iana" },
		"application/vnd.ms-windows.printerpairing": { "source": "iana" },
		"application/vnd.ms-windows.wsd.oob": { "source": "iana" },
		"application/vnd.ms-wmdrm.lic-chlg-req": { "source": "iana" },
		"application/vnd.ms-wmdrm.lic-resp": { "source": "iana" },
		"application/vnd.ms-wmdrm.meter-chlg-req": { "source": "iana" },
		"application/vnd.ms-wmdrm.meter-resp": { "source": "iana" },
		"application/vnd.ms-word.document.macroenabled.12": {
			"source": "iana",
			"extensions": ["docm"]
		},
		"application/vnd.ms-word.template.macroenabled.12": {
			"source": "iana",
			"extensions": ["dotm"]
		},
		"application/vnd.ms-works": {
			"source": "iana",
			"extensions": [
				"wps",
				"wks",
				"wcm",
				"wdb"
			]
		},
		"application/vnd.ms-wpl": {
			"source": "iana",
			"extensions": ["wpl"]
		},
		"application/vnd.ms-xpsdocument": {
			"source": "iana",
			"compressible": false,
			"extensions": ["xps"]
		},
		"application/vnd.msa-disk-image": { "source": "iana" },
		"application/vnd.mseq": {
			"source": "iana",
			"extensions": ["mseq"]
		},
		"application/vnd.msign": { "source": "iana" },
		"application/vnd.multiad.creator": { "source": "iana" },
		"application/vnd.multiad.creator.cif": { "source": "iana" },
		"application/vnd.music-niff": { "source": "iana" },
		"application/vnd.musician": {
			"source": "iana",
			"extensions": ["mus"]
		},
		"application/vnd.muvee.style": {
			"source": "iana",
			"extensions": ["msty"]
		},
		"application/vnd.mynfc": {
			"source": "iana",
			"extensions": ["taglet"]
		},
		"application/vnd.nacamar.ybrid+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ncd.control": { "source": "iana" },
		"application/vnd.ncd.reference": { "source": "iana" },
		"application/vnd.nearst.inv+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nebumind.line": { "source": "iana" },
		"application/vnd.nervana": { "source": "iana" },
		"application/vnd.netfpx": { "source": "iana" },
		"application/vnd.neurolanguage.nlu": {
			"source": "iana",
			"extensions": ["nlu"]
		},
		"application/vnd.nimn": { "source": "iana" },
		"application/vnd.nintendo.nitro.rom": { "source": "iana" },
		"application/vnd.nintendo.snes.rom": { "source": "iana" },
		"application/vnd.nitf": {
			"source": "iana",
			"extensions": ["ntf", "nitf"]
		},
		"application/vnd.noblenet-directory": {
			"source": "iana",
			"extensions": ["nnd"]
		},
		"application/vnd.noblenet-sealer": {
			"source": "iana",
			"extensions": ["nns"]
		},
		"application/vnd.noblenet-web": {
			"source": "iana",
			"extensions": ["nnw"]
		},
		"application/vnd.nokia.catalogs": { "source": "iana" },
		"application/vnd.nokia.conml+wbxml": { "source": "iana" },
		"application/vnd.nokia.conml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.iptv.config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.isds-radio-presets": { "source": "iana" },
		"application/vnd.nokia.landmark+wbxml": { "source": "iana" },
		"application/vnd.nokia.landmark+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.landmarkcollection+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.n-gage.ac+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ac"]
		},
		"application/vnd.nokia.n-gage.data": {
			"source": "iana",
			"extensions": ["ngdat"]
		},
		"application/vnd.nokia.n-gage.symbian.install": {
			"source": "iana",
			"extensions": ["n-gage"]
		},
		"application/vnd.nokia.ncd": { "source": "iana" },
		"application/vnd.nokia.pcd+wbxml": { "source": "iana" },
		"application/vnd.nokia.pcd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.radio-preset": {
			"source": "iana",
			"extensions": ["rpst"]
		},
		"application/vnd.nokia.radio-presets": {
			"source": "iana",
			"extensions": ["rpss"]
		},
		"application/vnd.novadigm.edm": {
			"source": "iana",
			"extensions": ["edm"]
		},
		"application/vnd.novadigm.edx": {
			"source": "iana",
			"extensions": ["edx"]
		},
		"application/vnd.novadigm.ext": {
			"source": "iana",
			"extensions": ["ext"]
		},
		"application/vnd.ntt-local.content-share": { "source": "iana" },
		"application/vnd.ntt-local.file-transfer": { "source": "iana" },
		"application/vnd.ntt-local.ogw_remote-access": { "source": "iana" },
		"application/vnd.ntt-local.sip-ta_remote": { "source": "iana" },
		"application/vnd.ntt-local.sip-ta_tcp_stream": { "source": "iana" },
		"application/vnd.oasis.opendocument.chart": {
			"source": "iana",
			"extensions": ["odc"]
		},
		"application/vnd.oasis.opendocument.chart-template": {
			"source": "iana",
			"extensions": ["otc"]
		},
		"application/vnd.oasis.opendocument.database": {
			"source": "iana",
			"extensions": ["odb"]
		},
		"application/vnd.oasis.opendocument.formula": {
			"source": "iana",
			"extensions": ["odf"]
		},
		"application/vnd.oasis.opendocument.formula-template": {
			"source": "iana",
			"extensions": ["odft"]
		},
		"application/vnd.oasis.opendocument.graphics": {
			"source": "iana",
			"compressible": false,
			"extensions": ["odg"]
		},
		"application/vnd.oasis.opendocument.graphics-template": {
			"source": "iana",
			"extensions": ["otg"]
		},
		"application/vnd.oasis.opendocument.image": {
			"source": "iana",
			"extensions": ["odi"]
		},
		"application/vnd.oasis.opendocument.image-template": {
			"source": "iana",
			"extensions": ["oti"]
		},
		"application/vnd.oasis.opendocument.presentation": {
			"source": "iana",
			"compressible": false,
			"extensions": ["odp"]
		},
		"application/vnd.oasis.opendocument.presentation-template": {
			"source": "iana",
			"extensions": ["otp"]
		},
		"application/vnd.oasis.opendocument.spreadsheet": {
			"source": "iana",
			"compressible": false,
			"extensions": ["ods"]
		},
		"application/vnd.oasis.opendocument.spreadsheet-template": {
			"source": "iana",
			"extensions": ["ots"]
		},
		"application/vnd.oasis.opendocument.text": {
			"source": "iana",
			"compressible": false,
			"extensions": ["odt"]
		},
		"application/vnd.oasis.opendocument.text-master": {
			"source": "iana",
			"extensions": ["odm"]
		},
		"application/vnd.oasis.opendocument.text-template": {
			"source": "iana",
			"extensions": ["ott"]
		},
		"application/vnd.oasis.opendocument.text-web": {
			"source": "iana",
			"extensions": ["oth"]
		},
		"application/vnd.obn": { "source": "iana" },
		"application/vnd.ocf+cbor": { "source": "iana" },
		"application/vnd.oci.image.manifest.v1+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oftn.l10n+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.contentaccessdownload+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.contentaccessstreaming+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.cspg-hexbinary": { "source": "iana" },
		"application/vnd.oipf.dae.svg+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.dae.xhtml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.mippvcontrolmessage+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.pae.gem": { "source": "iana" },
		"application/vnd.oipf.spdiscovery+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.spdlist+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.ueprofile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.userprofile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.olpc-sugar": {
			"source": "iana",
			"extensions": ["xo"]
		},
		"application/vnd.oma-scws-config": { "source": "iana" },
		"application/vnd.oma-scws-http-request": { "source": "iana" },
		"application/vnd.oma-scws-http-response": { "source": "iana" },
		"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.drm-trigger+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.imd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.ltkm": { "source": "iana" },
		"application/vnd.oma.bcast.notification+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.provisioningtrigger": { "source": "iana" },
		"application/vnd.oma.bcast.sgboot": { "source": "iana" },
		"application/vnd.oma.bcast.sgdd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.sgdu": { "source": "iana" },
		"application/vnd.oma.bcast.simple-symbol-container": { "source": "iana" },
		"application/vnd.oma.bcast.smartcard-trigger+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.sprov+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.stkm": { "source": "iana" },
		"application/vnd.oma.cab-address-book+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.cab-feature-handler+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.cab-pcc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.cab-subs-invite+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.cab-user-prefs+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.dcd": { "source": "iana" },
		"application/vnd.oma.dcdc": { "source": "iana" },
		"application/vnd.oma.dd2+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dd2"]
		},
		"application/vnd.oma.drm.risd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.group-usage-list+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.lwm2m+cbor": { "source": "iana" },
		"application/vnd.oma.lwm2m+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.lwm2m+tlv": { "source": "iana" },
		"application/vnd.oma.pal+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.detailed-progress-report+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.final-report+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.groups+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.invocation-descriptor+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.optimized-progress-report+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.push": { "source": "iana" },
		"application/vnd.oma.scidm.messages+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.xcap-directory+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.omads-email+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.omads-file+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.omads-folder+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.omaloc-supl-init": { "source": "iana" },
		"application/vnd.onepager": { "source": "iana" },
		"application/vnd.onepagertamp": { "source": "iana" },
		"application/vnd.onepagertamx": { "source": "iana" },
		"application/vnd.onepagertat": { "source": "iana" },
		"application/vnd.onepagertatp": { "source": "iana" },
		"application/vnd.onepagertatx": { "source": "iana" },
		"application/vnd.openblox.game+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["obgx"]
		},
		"application/vnd.openblox.game-binary": { "source": "iana" },
		"application/vnd.openeye.oeb": { "source": "iana" },
		"application/vnd.openofficeorg.extension": {
			"source": "apache",
			"extensions": ["oxt"]
		},
		"application/vnd.openstreetmap.data+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["osm"]
		},
		"application/vnd.opentimestamps.ots": { "source": "iana" },
		"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawing+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
			"source": "iana",
			"compressible": false,
			"extensions": ["pptx"]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slide": {
			"source": "iana",
			"extensions": ["sldx"]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
			"source": "iana",
			"extensions": ["ppsx"]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.template": {
			"source": "iana",
			"extensions": ["potx"]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
			"source": "iana",
			"compressible": false,
			"extensions": ["xlsx"]
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
			"source": "iana",
			"extensions": ["xltx"]
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.theme+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.vmldrawing": { "source": "iana" },
		"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
			"source": "iana",
			"compressible": false,
			"extensions": ["docx"]
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
			"source": "iana",
			"extensions": ["dotx"]
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-package.core-properties+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-package.relationships+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oracle.resource+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.orange.indata": { "source": "iana" },
		"application/vnd.osa.netdeploy": { "source": "iana" },
		"application/vnd.osgeo.mapguide.package": {
			"source": "iana",
			"extensions": ["mgp"]
		},
		"application/vnd.osgi.bundle": { "source": "iana" },
		"application/vnd.osgi.dp": {
			"source": "iana",
			"extensions": ["dp"]
		},
		"application/vnd.osgi.subsystem": {
			"source": "iana",
			"extensions": ["esa"]
		},
		"application/vnd.otps.ct-kip+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oxli.countgraph": { "source": "iana" },
		"application/vnd.pagerduty+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.palm": {
			"source": "iana",
			"extensions": [
				"pdb",
				"pqa",
				"oprc"
			]
		},
		"application/vnd.panoply": { "source": "iana" },
		"application/vnd.paos.xml": { "source": "iana" },
		"application/vnd.patentdive": { "source": "iana" },
		"application/vnd.patientecommsdoc": { "source": "iana" },
		"application/vnd.pawaafile": {
			"source": "iana",
			"extensions": ["paw"]
		},
		"application/vnd.pcos": { "source": "iana" },
		"application/vnd.pg.format": {
			"source": "iana",
			"extensions": ["str"]
		},
		"application/vnd.pg.osasli": {
			"source": "iana",
			"extensions": ["ei6"]
		},
		"application/vnd.piaccess.application-licence": { "source": "iana" },
		"application/vnd.picsel": {
			"source": "iana",
			"extensions": ["efif"]
		},
		"application/vnd.pmi.widget": {
			"source": "iana",
			"extensions": ["wg"]
		},
		"application/vnd.poc.group-advertisement+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.pocketlearn": {
			"source": "iana",
			"extensions": ["plf"]
		},
		"application/vnd.powerbuilder6": {
			"source": "iana",
			"extensions": ["pbd"]
		},
		"application/vnd.powerbuilder6-s": { "source": "iana" },
		"application/vnd.powerbuilder7": { "source": "iana" },
		"application/vnd.powerbuilder7-s": { "source": "iana" },
		"application/vnd.powerbuilder75": { "source": "iana" },
		"application/vnd.powerbuilder75-s": { "source": "iana" },
		"application/vnd.preminet": { "source": "iana" },
		"application/vnd.previewsystems.box": {
			"source": "iana",
			"extensions": ["box"]
		},
		"application/vnd.proteus.magazine": {
			"source": "iana",
			"extensions": ["mgz"]
		},
		"application/vnd.psfs": { "source": "iana" },
		"application/vnd.publishare-delta-tree": {
			"source": "iana",
			"extensions": ["qps"]
		},
		"application/vnd.pvi.ptid1": {
			"source": "iana",
			"extensions": ["ptid"]
		},
		"application/vnd.pwg-multiplexed": { "source": "iana" },
		"application/vnd.pwg-xhtml-print+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.qualcomm.brew-app-res": { "source": "iana" },
		"application/vnd.quarantainenet": { "source": "iana" },
		"application/vnd.quark.quarkxpress": {
			"source": "iana",
			"extensions": [
				"qxd",
				"qxt",
				"qwd",
				"qwt",
				"qxl",
				"qxb"
			]
		},
		"application/vnd.quobject-quoxdocument": { "source": "iana" },
		"application/vnd.radisys.moml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit-conf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit-conn+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit-dialog+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit-stream+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-conf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-base+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-fax-detect+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-group+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-speech+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-transform+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.rainstor.data": { "source": "iana" },
		"application/vnd.rapid": { "source": "iana" },
		"application/vnd.rar": {
			"source": "iana",
			"extensions": ["rar"]
		},
		"application/vnd.realvnc.bed": {
			"source": "iana",
			"extensions": ["bed"]
		},
		"application/vnd.recordare.musicxml": {
			"source": "iana",
			"extensions": ["mxl"]
		},
		"application/vnd.recordare.musicxml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["musicxml"]
		},
		"application/vnd.renlearn.rlprint": { "source": "iana" },
		"application/vnd.resilient.logic": { "source": "iana" },
		"application/vnd.restful+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.rig.cryptonote": {
			"source": "iana",
			"extensions": ["cryptonote"]
		},
		"application/vnd.rim.cod": {
			"source": "apache",
			"extensions": ["cod"]
		},
		"application/vnd.rn-realmedia": {
			"source": "apache",
			"extensions": ["rm"]
		},
		"application/vnd.rn-realmedia-vbr": {
			"source": "apache",
			"extensions": ["rmvb"]
		},
		"application/vnd.route66.link66+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["link66"]
		},
		"application/vnd.rs-274x": { "source": "iana" },
		"application/vnd.ruckus.download": { "source": "iana" },
		"application/vnd.s3sms": { "source": "iana" },
		"application/vnd.sailingtracker.track": {
			"source": "iana",
			"extensions": ["st"]
		},
		"application/vnd.sar": { "source": "iana" },
		"application/vnd.sbm.cid": { "source": "iana" },
		"application/vnd.sbm.mid2": { "source": "iana" },
		"application/vnd.scribus": { "source": "iana" },
		"application/vnd.sealed.3df": { "source": "iana" },
		"application/vnd.sealed.csf": { "source": "iana" },
		"application/vnd.sealed.doc": { "source": "iana" },
		"application/vnd.sealed.eml": { "source": "iana" },
		"application/vnd.sealed.mht": { "source": "iana" },
		"application/vnd.sealed.net": { "source": "iana" },
		"application/vnd.sealed.ppt": { "source": "iana" },
		"application/vnd.sealed.tiff": { "source": "iana" },
		"application/vnd.sealed.xls": { "source": "iana" },
		"application/vnd.sealedmedia.softseal.html": { "source": "iana" },
		"application/vnd.sealedmedia.softseal.pdf": { "source": "iana" },
		"application/vnd.seemail": {
			"source": "iana",
			"extensions": ["see"]
		},
		"application/vnd.seis+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.sema": {
			"source": "iana",
			"extensions": ["sema"]
		},
		"application/vnd.semd": {
			"source": "iana",
			"extensions": ["semd"]
		},
		"application/vnd.semf": {
			"source": "iana",
			"extensions": ["semf"]
		},
		"application/vnd.shade-save-file": { "source": "iana" },
		"application/vnd.shana.informed.formdata": {
			"source": "iana",
			"extensions": ["ifm"]
		},
		"application/vnd.shana.informed.formtemplate": {
			"source": "iana",
			"extensions": ["itp"]
		},
		"application/vnd.shana.informed.interchange": {
			"source": "iana",
			"extensions": ["iif"]
		},
		"application/vnd.shana.informed.package": {
			"source": "iana",
			"extensions": ["ipk"]
		},
		"application/vnd.shootproof+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.shopkick+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.shp": { "source": "iana" },
		"application/vnd.shx": { "source": "iana" },
		"application/vnd.sigrok.session": { "source": "iana" },
		"application/vnd.simtech-mindmapper": {
			"source": "iana",
			"extensions": ["twd", "twds"]
		},
		"application/vnd.siren+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.smaf": {
			"source": "iana",
			"extensions": ["mmf"]
		},
		"application/vnd.smart.notebook": { "source": "iana" },
		"application/vnd.smart.teacher": {
			"source": "iana",
			"extensions": ["teacher"]
		},
		"application/vnd.snesdev-page-table": { "source": "iana" },
		"application/vnd.software602.filler.form+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["fo"]
		},
		"application/vnd.software602.filler.form-xml-zip": { "source": "iana" },
		"application/vnd.solent.sdkm+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sdkm", "sdkd"]
		},
		"application/vnd.spotfire.dxp": {
			"source": "iana",
			"extensions": ["dxp"]
		},
		"application/vnd.spotfire.sfs": {
			"source": "iana",
			"extensions": ["sfs"]
		},
		"application/vnd.sqlite3": { "source": "iana" },
		"application/vnd.sss-cod": { "source": "iana" },
		"application/vnd.sss-dtf": { "source": "iana" },
		"application/vnd.sss-ntf": { "source": "iana" },
		"application/vnd.stardivision.calc": {
			"source": "apache",
			"extensions": ["sdc"]
		},
		"application/vnd.stardivision.draw": {
			"source": "apache",
			"extensions": ["sda"]
		},
		"application/vnd.stardivision.impress": {
			"source": "apache",
			"extensions": ["sdd"]
		},
		"application/vnd.stardivision.math": {
			"source": "apache",
			"extensions": ["smf"]
		},
		"application/vnd.stardivision.writer": {
			"source": "apache",
			"extensions": ["sdw", "vor"]
		},
		"application/vnd.stardivision.writer-global": {
			"source": "apache",
			"extensions": ["sgl"]
		},
		"application/vnd.stepmania.package": {
			"source": "iana",
			"extensions": ["smzip"]
		},
		"application/vnd.stepmania.stepchart": {
			"source": "iana",
			"extensions": ["sm"]
		},
		"application/vnd.street-stream": { "source": "iana" },
		"application/vnd.sun.wadl+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wadl"]
		},
		"application/vnd.sun.xml.calc": {
			"source": "apache",
			"extensions": ["sxc"]
		},
		"application/vnd.sun.xml.calc.template": {
			"source": "apache",
			"extensions": ["stc"]
		},
		"application/vnd.sun.xml.draw": {
			"source": "apache",
			"extensions": ["sxd"]
		},
		"application/vnd.sun.xml.draw.template": {
			"source": "apache",
			"extensions": ["std"]
		},
		"application/vnd.sun.xml.impress": {
			"source": "apache",
			"extensions": ["sxi"]
		},
		"application/vnd.sun.xml.impress.template": {
			"source": "apache",
			"extensions": ["sti"]
		},
		"application/vnd.sun.xml.math": {
			"source": "apache",
			"extensions": ["sxm"]
		},
		"application/vnd.sun.xml.writer": {
			"source": "apache",
			"extensions": ["sxw"]
		},
		"application/vnd.sun.xml.writer.global": {
			"source": "apache",
			"extensions": ["sxg"]
		},
		"application/vnd.sun.xml.writer.template": {
			"source": "apache",
			"extensions": ["stw"]
		},
		"application/vnd.sus-calendar": {
			"source": "iana",
			"extensions": ["sus", "susp"]
		},
		"application/vnd.svd": {
			"source": "iana",
			"extensions": ["svd"]
		},
		"application/vnd.swiftview-ics": { "source": "iana" },
		"application/vnd.sycle+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.syft+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.symbian.install": {
			"source": "apache",
			"extensions": ["sis", "sisx"]
		},
		"application/vnd.syncml+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["xsm"]
		},
		"application/vnd.syncml.dm+wbxml": {
			"source": "iana",
			"charset": "UTF-8",
			"extensions": ["bdm"]
		},
		"application/vnd.syncml.dm+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["xdm"]
		},
		"application/vnd.syncml.dm.notification": { "source": "iana" },
		"application/vnd.syncml.dmddf+wbxml": { "source": "iana" },
		"application/vnd.syncml.dmddf+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["ddf"]
		},
		"application/vnd.syncml.dmtnds+wbxml": { "source": "iana" },
		"application/vnd.syncml.dmtnds+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.syncml.ds.notification": { "source": "iana" },
		"application/vnd.tableschema+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.tao.intent-module-archive": {
			"source": "iana",
			"extensions": ["tao"]
		},
		"application/vnd.tcpdump.pcap": {
			"source": "iana",
			"extensions": [
				"pcap",
				"cap",
				"dmp"
			]
		},
		"application/vnd.think-cell.ppttc+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.tmd.mediaflex.api+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.tml": { "source": "iana" },
		"application/vnd.tmobile-livetv": {
			"source": "iana",
			"extensions": ["tmo"]
		},
		"application/vnd.tri.onesource": { "source": "iana" },
		"application/vnd.trid.tpt": {
			"source": "iana",
			"extensions": ["tpt"]
		},
		"application/vnd.triscape.mxs": {
			"source": "iana",
			"extensions": ["mxs"]
		},
		"application/vnd.trueapp": {
			"source": "iana",
			"extensions": ["tra"]
		},
		"application/vnd.truedoc": { "source": "iana" },
		"application/vnd.ubisoft.webplayer": { "source": "iana" },
		"application/vnd.ufdl": {
			"source": "iana",
			"extensions": ["ufd", "ufdl"]
		},
		"application/vnd.uiq.theme": {
			"source": "iana",
			"extensions": ["utz"]
		},
		"application/vnd.umajin": {
			"source": "iana",
			"extensions": ["umj"]
		},
		"application/vnd.unity": {
			"source": "iana",
			"extensions": ["unityweb"]
		},
		"application/vnd.uoml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["uoml"]
		},
		"application/vnd.uplanet.alert": { "source": "iana" },
		"application/vnd.uplanet.alert-wbxml": { "source": "iana" },
		"application/vnd.uplanet.bearer-choice": { "source": "iana" },
		"application/vnd.uplanet.bearer-choice-wbxml": { "source": "iana" },
		"application/vnd.uplanet.cacheop": { "source": "iana" },
		"application/vnd.uplanet.cacheop-wbxml": { "source": "iana" },
		"application/vnd.uplanet.channel": { "source": "iana" },
		"application/vnd.uplanet.channel-wbxml": { "source": "iana" },
		"application/vnd.uplanet.list": { "source": "iana" },
		"application/vnd.uplanet.list-wbxml": { "source": "iana" },
		"application/vnd.uplanet.listcmd": { "source": "iana" },
		"application/vnd.uplanet.listcmd-wbxml": { "source": "iana" },
		"application/vnd.uplanet.signal": { "source": "iana" },
		"application/vnd.uri-map": { "source": "iana" },
		"application/vnd.valve.source.material": { "source": "iana" },
		"application/vnd.vcx": {
			"source": "iana",
			"extensions": ["vcx"]
		},
		"application/vnd.vd-study": { "source": "iana" },
		"application/vnd.vectorworks": { "source": "iana" },
		"application/vnd.vel+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.verimatrix.vcas": { "source": "iana" },
		"application/vnd.veritone.aion+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.veryant.thin": { "source": "iana" },
		"application/vnd.ves.encrypted": { "source": "iana" },
		"application/vnd.vidsoft.vidconference": { "source": "iana" },
		"application/vnd.visio": {
			"source": "iana",
			"extensions": [
				"vsd",
				"vst",
				"vss",
				"vsw"
			]
		},
		"application/vnd.visionary": {
			"source": "iana",
			"extensions": ["vis"]
		},
		"application/vnd.vividence.scriptfile": { "source": "iana" },
		"application/vnd.vsf": {
			"source": "iana",
			"extensions": ["vsf"]
		},
		"application/vnd.wap.sic": { "source": "iana" },
		"application/vnd.wap.slc": { "source": "iana" },
		"application/vnd.wap.wbxml": {
			"source": "iana",
			"charset": "UTF-8",
			"extensions": ["wbxml"]
		},
		"application/vnd.wap.wmlc": {
			"source": "iana",
			"extensions": ["wmlc"]
		},
		"application/vnd.wap.wmlscriptc": {
			"source": "iana",
			"extensions": ["wmlsc"]
		},
		"application/vnd.webturbo": {
			"source": "iana",
			"extensions": ["wtb"]
		},
		"application/vnd.wfa.dpp": { "source": "iana" },
		"application/vnd.wfa.p2p": { "source": "iana" },
		"application/vnd.wfa.wsc": { "source": "iana" },
		"application/vnd.windows.devicepairing": { "source": "iana" },
		"application/vnd.wmc": { "source": "iana" },
		"application/vnd.wmf.bootstrap": { "source": "iana" },
		"application/vnd.wolfram.mathematica": { "source": "iana" },
		"application/vnd.wolfram.mathematica.package": { "source": "iana" },
		"application/vnd.wolfram.player": {
			"source": "iana",
			"extensions": ["nbp"]
		},
		"application/vnd.wordperfect": {
			"source": "iana",
			"extensions": ["wpd"]
		},
		"application/vnd.wqd": {
			"source": "iana",
			"extensions": ["wqd"]
		},
		"application/vnd.wrq-hp3000-labelled": { "source": "iana" },
		"application/vnd.wt.stf": {
			"source": "iana",
			"extensions": ["stf"]
		},
		"application/vnd.wv.csp+wbxml": { "source": "iana" },
		"application/vnd.wv.csp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.wv.ssp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.xacml+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.xara": {
			"source": "iana",
			"extensions": ["xar"]
		},
		"application/vnd.xfdl": {
			"source": "iana",
			"extensions": ["xfdl"]
		},
		"application/vnd.xfdl.webform": { "source": "iana" },
		"application/vnd.xmi+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.xmpie.cpkg": { "source": "iana" },
		"application/vnd.xmpie.dpkg": { "source": "iana" },
		"application/vnd.xmpie.plan": { "source": "iana" },
		"application/vnd.xmpie.ppkg": { "source": "iana" },
		"application/vnd.xmpie.xlim": { "source": "iana" },
		"application/vnd.yamaha.hv-dic": {
			"source": "iana",
			"extensions": ["hvd"]
		},
		"application/vnd.yamaha.hv-script": {
			"source": "iana",
			"extensions": ["hvs"]
		},
		"application/vnd.yamaha.hv-voice": {
			"source": "iana",
			"extensions": ["hvp"]
		},
		"application/vnd.yamaha.openscoreformat": {
			"source": "iana",
			"extensions": ["osf"]
		},
		"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["osfpvg"]
		},
		"application/vnd.yamaha.remote-setup": { "source": "iana" },
		"application/vnd.yamaha.smaf-audio": {
			"source": "iana",
			"extensions": ["saf"]
		},
		"application/vnd.yamaha.smaf-phrase": {
			"source": "iana",
			"extensions": ["spf"]
		},
		"application/vnd.yamaha.through-ngn": { "source": "iana" },
		"application/vnd.yamaha.tunnel-udpencap": { "source": "iana" },
		"application/vnd.yaoweme": { "source": "iana" },
		"application/vnd.yellowriver-custom-menu": {
			"source": "iana",
			"extensions": ["cmp"]
		},
		"application/vnd.youtube.yt": { "source": "iana" },
		"application/vnd.zul": {
			"source": "iana",
			"extensions": ["zir", "zirz"]
		},
		"application/vnd.zzazz.deck+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["zaz"]
		},
		"application/voicexml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["vxml"]
		},
		"application/voucher-cms+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vq-rtcpxr": { "source": "iana" },
		"application/wasm": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wasm"]
		},
		"application/watcherinfo+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wif"]
		},
		"application/webpush-options+json": {
			"source": "iana",
			"compressible": true
		},
		"application/whoispp-query": { "source": "iana" },
		"application/whoispp-response": { "source": "iana" },
		"application/widget": {
			"source": "iana",
			"extensions": ["wgt"]
		},
		"application/winhlp": {
			"source": "apache",
			"extensions": ["hlp"]
		},
		"application/wita": { "source": "iana" },
		"application/wordperfect5.1": { "source": "iana" },
		"application/wsdl+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wsdl"]
		},
		"application/wspolicy+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wspolicy"]
		},
		"application/x-7z-compressed": {
			"source": "apache",
			"compressible": false,
			"extensions": ["7z"]
		},
		"application/x-abiword": {
			"source": "apache",
			"extensions": ["abw"]
		},
		"application/x-ace-compressed": {
			"source": "apache",
			"extensions": ["ace"]
		},
		"application/x-amf": { "source": "apache" },
		"application/x-apple-diskimage": {
			"source": "apache",
			"extensions": ["dmg"]
		},
		"application/x-arj": {
			"compressible": false,
			"extensions": ["arj"]
		},
		"application/x-authorware-bin": {
			"source": "apache",
			"extensions": [
				"aab",
				"x32",
				"u32",
				"vox"
			]
		},
		"application/x-authorware-map": {
			"source": "apache",
			"extensions": ["aam"]
		},
		"application/x-authorware-seg": {
			"source": "apache",
			"extensions": ["aas"]
		},
		"application/x-bcpio": {
			"source": "apache",
			"extensions": ["bcpio"]
		},
		"application/x-bdoc": {
			"compressible": false,
			"extensions": ["bdoc"]
		},
		"application/x-bittorrent": {
			"source": "apache",
			"extensions": ["torrent"]
		},
		"application/x-blorb": {
			"source": "apache",
			"extensions": ["blb", "blorb"]
		},
		"application/x-bzip": {
			"source": "apache",
			"compressible": false,
			"extensions": ["bz"]
		},
		"application/x-bzip2": {
			"source": "apache",
			"compressible": false,
			"extensions": ["bz2", "boz"]
		},
		"application/x-cbr": {
			"source": "apache",
			"extensions": [
				"cbr",
				"cba",
				"cbt",
				"cbz",
				"cb7"
			]
		},
		"application/x-cdlink": {
			"source": "apache",
			"extensions": ["vcd"]
		},
		"application/x-cfs-compressed": {
			"source": "apache",
			"extensions": ["cfs"]
		},
		"application/x-chat": {
			"source": "apache",
			"extensions": ["chat"]
		},
		"application/x-chess-pgn": {
			"source": "apache",
			"extensions": ["pgn"]
		},
		"application/x-chrome-extension": { "extensions": ["crx"] },
		"application/x-cocoa": {
			"source": "nginx",
			"extensions": ["cco"]
		},
		"application/x-compress": { "source": "apache" },
		"application/x-conference": {
			"source": "apache",
			"extensions": ["nsc"]
		},
		"application/x-cpio": {
			"source": "apache",
			"extensions": ["cpio"]
		},
		"application/x-csh": {
			"source": "apache",
			"extensions": ["csh"]
		},
		"application/x-deb": { "compressible": false },
		"application/x-debian-package": {
			"source": "apache",
			"extensions": ["deb", "udeb"]
		},
		"application/x-dgc-compressed": {
			"source": "apache",
			"extensions": ["dgc"]
		},
		"application/x-director": {
			"source": "apache",
			"extensions": [
				"dir",
				"dcr",
				"dxr",
				"cst",
				"cct",
				"cxt",
				"w3d",
				"fgd",
				"swa"
			]
		},
		"application/x-doom": {
			"source": "apache",
			"extensions": ["wad"]
		},
		"application/x-dtbncx+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["ncx"]
		},
		"application/x-dtbook+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["dtb"]
		},
		"application/x-dtbresource+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["res"]
		},
		"application/x-dvi": {
			"source": "apache",
			"compressible": false,
			"extensions": ["dvi"]
		},
		"application/x-envoy": {
			"source": "apache",
			"extensions": ["evy"]
		},
		"application/x-eva": {
			"source": "apache",
			"extensions": ["eva"]
		},
		"application/x-font-bdf": {
			"source": "apache",
			"extensions": ["bdf"]
		},
		"application/x-font-dos": { "source": "apache" },
		"application/x-font-framemaker": { "source": "apache" },
		"application/x-font-ghostscript": {
			"source": "apache",
			"extensions": ["gsf"]
		},
		"application/x-font-libgrx": { "source": "apache" },
		"application/x-font-linux-psf": {
			"source": "apache",
			"extensions": ["psf"]
		},
		"application/x-font-pcf": {
			"source": "apache",
			"extensions": ["pcf"]
		},
		"application/x-font-snf": {
			"source": "apache",
			"extensions": ["snf"]
		},
		"application/x-font-speedo": { "source": "apache" },
		"application/x-font-sunos-news": { "source": "apache" },
		"application/x-font-type1": {
			"source": "apache",
			"extensions": [
				"pfa",
				"pfb",
				"pfm",
				"afm"
			]
		},
		"application/x-font-vfont": { "source": "apache" },
		"application/x-freearc": {
			"source": "apache",
			"extensions": ["arc"]
		},
		"application/x-futuresplash": {
			"source": "apache",
			"extensions": ["spl"]
		},
		"application/x-gca-compressed": {
			"source": "apache",
			"extensions": ["gca"]
		},
		"application/x-glulx": {
			"source": "apache",
			"extensions": ["ulx"]
		},
		"application/x-gnumeric": {
			"source": "apache",
			"extensions": ["gnumeric"]
		},
		"application/x-gramps-xml": {
			"source": "apache",
			"extensions": ["gramps"]
		},
		"application/x-gtar": {
			"source": "apache",
			"extensions": ["gtar"]
		},
		"application/x-gzip": { "source": "apache" },
		"application/x-hdf": {
			"source": "apache",
			"extensions": ["hdf"]
		},
		"application/x-httpd-php": {
			"compressible": true,
			"extensions": ["php"]
		},
		"application/x-install-instructions": {
			"source": "apache",
			"extensions": ["install"]
		},
		"application/x-iso9660-image": {
			"source": "apache",
			"extensions": ["iso"]
		},
		"application/x-iwork-keynote-sffkey": { "extensions": ["key"] },
		"application/x-iwork-numbers-sffnumbers": { "extensions": ["numbers"] },
		"application/x-iwork-pages-sffpages": { "extensions": ["pages"] },
		"application/x-java-archive-diff": {
			"source": "nginx",
			"extensions": ["jardiff"]
		},
		"application/x-java-jnlp-file": {
			"source": "apache",
			"compressible": false,
			"extensions": ["jnlp"]
		},
		"application/x-javascript": { "compressible": true },
		"application/x-keepass2": { "extensions": ["kdbx"] },
		"application/x-latex": {
			"source": "apache",
			"compressible": false,
			"extensions": ["latex"]
		},
		"application/x-lua-bytecode": { "extensions": ["luac"] },
		"application/x-lzh-compressed": {
			"source": "apache",
			"extensions": ["lzh", "lha"]
		},
		"application/x-makeself": {
			"source": "nginx",
			"extensions": ["run"]
		},
		"application/x-mie": {
			"source": "apache",
			"extensions": ["mie"]
		},
		"application/x-mobipocket-ebook": {
			"source": "apache",
			"extensions": ["prc", "mobi"]
		},
		"application/x-mpegurl": { "compressible": false },
		"application/x-ms-application": {
			"source": "apache",
			"extensions": ["application"]
		},
		"application/x-ms-shortcut": {
			"source": "apache",
			"extensions": ["lnk"]
		},
		"application/x-ms-wmd": {
			"source": "apache",
			"extensions": ["wmd"]
		},
		"application/x-ms-wmz": {
			"source": "apache",
			"extensions": ["wmz"]
		},
		"application/x-ms-xbap": {
			"source": "apache",
			"extensions": ["xbap"]
		},
		"application/x-msaccess": {
			"source": "apache",
			"extensions": ["mdb"]
		},
		"application/x-msbinder": {
			"source": "apache",
			"extensions": ["obd"]
		},
		"application/x-mscardfile": {
			"source": "apache",
			"extensions": ["crd"]
		},
		"application/x-msclip": {
			"source": "apache",
			"extensions": ["clp"]
		},
		"application/x-msdos-program": { "extensions": ["exe"] },
		"application/x-msdownload": {
			"source": "apache",
			"extensions": [
				"exe",
				"dll",
				"com",
				"bat",
				"msi"
			]
		},
		"application/x-msmediaview": {
			"source": "apache",
			"extensions": [
				"mvb",
				"m13",
				"m14"
			]
		},
		"application/x-msmetafile": {
			"source": "apache",
			"extensions": [
				"wmf",
				"wmz",
				"emf",
				"emz"
			]
		},
		"application/x-msmoney": {
			"source": "apache",
			"extensions": ["mny"]
		},
		"application/x-mspublisher": {
			"source": "apache",
			"extensions": ["pub"]
		},
		"application/x-msschedule": {
			"source": "apache",
			"extensions": ["scd"]
		},
		"application/x-msterminal": {
			"source": "apache",
			"extensions": ["trm"]
		},
		"application/x-mswrite": {
			"source": "apache",
			"extensions": ["wri"]
		},
		"application/x-netcdf": {
			"source": "apache",
			"extensions": ["nc", "cdf"]
		},
		"application/x-ns-proxy-autoconfig": {
			"compressible": true,
			"extensions": ["pac"]
		},
		"application/x-nzb": {
			"source": "apache",
			"extensions": ["nzb"]
		},
		"application/x-perl": {
			"source": "nginx",
			"extensions": ["pl", "pm"]
		},
		"application/x-pilot": {
			"source": "nginx",
			"extensions": ["prc", "pdb"]
		},
		"application/x-pkcs12": {
			"source": "apache",
			"compressible": false,
			"extensions": ["p12", "pfx"]
		},
		"application/x-pkcs7-certificates": {
			"source": "apache",
			"extensions": ["p7b", "spc"]
		},
		"application/x-pkcs7-certreqresp": {
			"source": "apache",
			"extensions": ["p7r"]
		},
		"application/x-pki-message": { "source": "iana" },
		"application/x-rar-compressed": {
			"source": "apache",
			"compressible": false,
			"extensions": ["rar"]
		},
		"application/x-redhat-package-manager": {
			"source": "nginx",
			"extensions": ["rpm"]
		},
		"application/x-research-info-systems": {
			"source": "apache",
			"extensions": ["ris"]
		},
		"application/x-sea": {
			"source": "nginx",
			"extensions": ["sea"]
		},
		"application/x-sh": {
			"source": "apache",
			"compressible": true,
			"extensions": ["sh"]
		},
		"application/x-shar": {
			"source": "apache",
			"extensions": ["shar"]
		},
		"application/x-shockwave-flash": {
			"source": "apache",
			"compressible": false,
			"extensions": ["swf"]
		},
		"application/x-silverlight-app": {
			"source": "apache",
			"extensions": ["xap"]
		},
		"application/x-sql": {
			"source": "apache",
			"extensions": ["sql"]
		},
		"application/x-stuffit": {
			"source": "apache",
			"compressible": false,
			"extensions": ["sit"]
		},
		"application/x-stuffitx": {
			"source": "apache",
			"extensions": ["sitx"]
		},
		"application/x-subrip": {
			"source": "apache",
			"extensions": ["srt"]
		},
		"application/x-sv4cpio": {
			"source": "apache",
			"extensions": ["sv4cpio"]
		},
		"application/x-sv4crc": {
			"source": "apache",
			"extensions": ["sv4crc"]
		},
		"application/x-t3vm-image": {
			"source": "apache",
			"extensions": ["t3"]
		},
		"application/x-tads": {
			"source": "apache",
			"extensions": ["gam"]
		},
		"application/x-tar": {
			"source": "apache",
			"compressible": true,
			"extensions": ["tar"]
		},
		"application/x-tcl": {
			"source": "apache",
			"extensions": ["tcl", "tk"]
		},
		"application/x-tex": {
			"source": "apache",
			"extensions": ["tex"]
		},
		"application/x-tex-tfm": {
			"source": "apache",
			"extensions": ["tfm"]
		},
		"application/x-texinfo": {
			"source": "apache",
			"extensions": ["texinfo", "texi"]
		},
		"application/x-tgif": {
			"source": "apache",
			"extensions": ["obj"]
		},
		"application/x-ustar": {
			"source": "apache",
			"extensions": ["ustar"]
		},
		"application/x-virtualbox-hdd": {
			"compressible": true,
			"extensions": ["hdd"]
		},
		"application/x-virtualbox-ova": {
			"compressible": true,
			"extensions": ["ova"]
		},
		"application/x-virtualbox-ovf": {
			"compressible": true,
			"extensions": ["ovf"]
		},
		"application/x-virtualbox-vbox": {
			"compressible": true,
			"extensions": ["vbox"]
		},
		"application/x-virtualbox-vbox-extpack": {
			"compressible": false,
			"extensions": ["vbox-extpack"]
		},
		"application/x-virtualbox-vdi": {
			"compressible": true,
			"extensions": ["vdi"]
		},
		"application/x-virtualbox-vhd": {
			"compressible": true,
			"extensions": ["vhd"]
		},
		"application/x-virtualbox-vmdk": {
			"compressible": true,
			"extensions": ["vmdk"]
		},
		"application/x-wais-source": {
			"source": "apache",
			"extensions": ["src"]
		},
		"application/x-web-app-manifest+json": {
			"compressible": true,
			"extensions": ["webapp"]
		},
		"application/x-www-form-urlencoded": {
			"source": "iana",
			"compressible": true
		},
		"application/x-x509-ca-cert": {
			"source": "iana",
			"extensions": [
				"der",
				"crt",
				"pem"
			]
		},
		"application/x-x509-ca-ra-cert": { "source": "iana" },
		"application/x-x509-next-ca-cert": { "source": "iana" },
		"application/x-xfig": {
			"source": "apache",
			"extensions": ["fig"]
		},
		"application/x-xliff+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["xlf"]
		},
		"application/x-xpinstall": {
			"source": "apache",
			"compressible": false,
			"extensions": ["xpi"]
		},
		"application/x-xz": {
			"source": "apache",
			"extensions": ["xz"]
		},
		"application/x-zmachine": {
			"source": "apache",
			"extensions": [
				"z1",
				"z2",
				"z3",
				"z4",
				"z5",
				"z6",
				"z7",
				"z8"
			]
		},
		"application/x400-bp": { "source": "iana" },
		"application/xacml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xaml+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["xaml"]
		},
		"application/xcap-att+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xav"]
		},
		"application/xcap-caps+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xca"]
		},
		"application/xcap-diff+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xdf"]
		},
		"application/xcap-el+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xel"]
		},
		"application/xcap-error+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xcap-ns+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xns"]
		},
		"application/xcon-conference-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xcon-conference-info-diff+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xenc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xenc"]
		},
		"application/xhtml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xhtml", "xht"]
		},
		"application/xhtml-voice+xml": {
			"source": "apache",
			"compressible": true
		},
		"application/xliff+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xlf"]
		},
		"application/xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"xml",
				"xsl",
				"xsd",
				"rng"
			]
		},
		"application/xml-dtd": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dtd"]
		},
		"application/xml-external-parsed-entity": { "source": "iana" },
		"application/xml-patch+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xmpp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xop+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xop"]
		},
		"application/xproc+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["xpl"]
		},
		"application/xslt+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xsl", "xslt"]
		},
		"application/xspf+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["xspf"]
		},
		"application/xv+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"mxml",
				"xhvml",
				"xvml",
				"xvm"
			]
		},
		"application/yang": {
			"source": "iana",
			"extensions": ["yang"]
		},
		"application/yang-data+json": {
			"source": "iana",
			"compressible": true
		},
		"application/yang-data+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/yang-patch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/yang-patch+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/yin+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["yin"]
		},
		"application/zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["zip"]
		},
		"application/zlib": { "source": "iana" },
		"application/zstd": { "source": "iana" },
		"audio/1d-interleaved-parityfec": { "source": "iana" },
		"audio/32kadpcm": { "source": "iana" },
		"audio/3gpp": {
			"source": "iana",
			"compressible": false,
			"extensions": ["3gpp"]
		},
		"audio/3gpp2": { "source": "iana" },
		"audio/aac": { "source": "iana" },
		"audio/ac3": { "source": "iana" },
		"audio/adpcm": {
			"source": "apache",
			"extensions": ["adp"]
		},
		"audio/amr": {
			"source": "iana",
			"extensions": ["amr"]
		},
		"audio/amr-wb": { "source": "iana" },
		"audio/amr-wb+": { "source": "iana" },
		"audio/aptx": { "source": "iana" },
		"audio/asc": { "source": "iana" },
		"audio/atrac-advanced-lossless": { "source": "iana" },
		"audio/atrac-x": { "source": "iana" },
		"audio/atrac3": { "source": "iana" },
		"audio/basic": {
			"source": "iana",
			"compressible": false,
			"extensions": ["au", "snd"]
		},
		"audio/bv16": { "source": "iana" },
		"audio/bv32": { "source": "iana" },
		"audio/clearmode": { "source": "iana" },
		"audio/cn": { "source": "iana" },
		"audio/dat12": { "source": "iana" },
		"audio/dls": { "source": "iana" },
		"audio/dsr-es201108": { "source": "iana" },
		"audio/dsr-es202050": { "source": "iana" },
		"audio/dsr-es202211": { "source": "iana" },
		"audio/dsr-es202212": { "source": "iana" },
		"audio/dv": { "source": "iana" },
		"audio/dvi4": { "source": "iana" },
		"audio/eac3": { "source": "iana" },
		"audio/encaprtp": { "source": "iana" },
		"audio/evrc": { "source": "iana" },
		"audio/evrc-qcp": { "source": "iana" },
		"audio/evrc0": { "source": "iana" },
		"audio/evrc1": { "source": "iana" },
		"audio/evrcb": { "source": "iana" },
		"audio/evrcb0": { "source": "iana" },
		"audio/evrcb1": { "source": "iana" },
		"audio/evrcnw": { "source": "iana" },
		"audio/evrcnw0": { "source": "iana" },
		"audio/evrcnw1": { "source": "iana" },
		"audio/evrcwb": { "source": "iana" },
		"audio/evrcwb0": { "source": "iana" },
		"audio/evrcwb1": { "source": "iana" },
		"audio/evs": { "source": "iana" },
		"audio/flexfec": { "source": "iana" },
		"audio/fwdred": { "source": "iana" },
		"audio/g711-0": { "source": "iana" },
		"audio/g719": { "source": "iana" },
		"audio/g722": { "source": "iana" },
		"audio/g7221": { "source": "iana" },
		"audio/g723": { "source": "iana" },
		"audio/g726-16": { "source": "iana" },
		"audio/g726-24": { "source": "iana" },
		"audio/g726-32": { "source": "iana" },
		"audio/g726-40": { "source": "iana" },
		"audio/g728": { "source": "iana" },
		"audio/g729": { "source": "iana" },
		"audio/g7291": { "source": "iana" },
		"audio/g729d": { "source": "iana" },
		"audio/g729e": { "source": "iana" },
		"audio/gsm": { "source": "iana" },
		"audio/gsm-efr": { "source": "iana" },
		"audio/gsm-hr-08": { "source": "iana" },
		"audio/ilbc": { "source": "iana" },
		"audio/ip-mr_v2.5": { "source": "iana" },
		"audio/isac": { "source": "apache" },
		"audio/l16": { "source": "iana" },
		"audio/l20": { "source": "iana" },
		"audio/l24": {
			"source": "iana",
			"compressible": false
		},
		"audio/l8": { "source": "iana" },
		"audio/lpc": { "source": "iana" },
		"audio/melp": { "source": "iana" },
		"audio/melp1200": { "source": "iana" },
		"audio/melp2400": { "source": "iana" },
		"audio/melp600": { "source": "iana" },
		"audio/mhas": { "source": "iana" },
		"audio/midi": {
			"source": "apache",
			"extensions": [
				"mid",
				"midi",
				"kar",
				"rmi"
			]
		},
		"audio/mobile-xmf": {
			"source": "iana",
			"extensions": ["mxmf"]
		},
		"audio/mp3": {
			"compressible": false,
			"extensions": ["mp3"]
		},
		"audio/mp4": {
			"source": "iana",
			"compressible": false,
			"extensions": ["m4a", "mp4a"]
		},
		"audio/mp4a-latm": { "source": "iana" },
		"audio/mpa": { "source": "iana" },
		"audio/mpa-robust": { "source": "iana" },
		"audio/mpeg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"mpga",
				"mp2",
				"mp2a",
				"mp3",
				"m2a",
				"m3a"
			]
		},
		"audio/mpeg4-generic": { "source": "iana" },
		"audio/musepack": { "source": "apache" },
		"audio/ogg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"oga",
				"ogg",
				"spx",
				"opus"
			]
		},
		"audio/opus": { "source": "iana" },
		"audio/parityfec": { "source": "iana" },
		"audio/pcma": { "source": "iana" },
		"audio/pcma-wb": { "source": "iana" },
		"audio/pcmu": { "source": "iana" },
		"audio/pcmu-wb": { "source": "iana" },
		"audio/prs.sid": { "source": "iana" },
		"audio/qcelp": { "source": "iana" },
		"audio/raptorfec": { "source": "iana" },
		"audio/red": { "source": "iana" },
		"audio/rtp-enc-aescm128": { "source": "iana" },
		"audio/rtp-midi": { "source": "iana" },
		"audio/rtploopback": { "source": "iana" },
		"audio/rtx": { "source": "iana" },
		"audio/s3m": {
			"source": "apache",
			"extensions": ["s3m"]
		},
		"audio/scip": { "source": "iana" },
		"audio/silk": {
			"source": "apache",
			"extensions": ["sil"]
		},
		"audio/smv": { "source": "iana" },
		"audio/smv-qcp": { "source": "iana" },
		"audio/smv0": { "source": "iana" },
		"audio/sofa": { "source": "iana" },
		"audio/sp-midi": { "source": "iana" },
		"audio/speex": { "source": "iana" },
		"audio/t140c": { "source": "iana" },
		"audio/t38": { "source": "iana" },
		"audio/telephone-event": { "source": "iana" },
		"audio/tetra_acelp": { "source": "iana" },
		"audio/tetra_acelp_bb": { "source": "iana" },
		"audio/tone": { "source": "iana" },
		"audio/tsvcis": { "source": "iana" },
		"audio/uemclip": { "source": "iana" },
		"audio/ulpfec": { "source": "iana" },
		"audio/usac": { "source": "iana" },
		"audio/vdvi": { "source": "iana" },
		"audio/vmr-wb": { "source": "iana" },
		"audio/vnd.3gpp.iufp": { "source": "iana" },
		"audio/vnd.4sb": { "source": "iana" },
		"audio/vnd.audiokoz": { "source": "iana" },
		"audio/vnd.celp": { "source": "iana" },
		"audio/vnd.cisco.nse": { "source": "iana" },
		"audio/vnd.cmles.radio-events": { "source": "iana" },
		"audio/vnd.cns.anp1": { "source": "iana" },
		"audio/vnd.cns.inf1": { "source": "iana" },
		"audio/vnd.dece.audio": {
			"source": "iana",
			"extensions": ["uva", "uvva"]
		},
		"audio/vnd.digital-winds": {
			"source": "iana",
			"extensions": ["eol"]
		},
		"audio/vnd.dlna.adts": { "source": "iana" },
		"audio/vnd.dolby.heaac.1": { "source": "iana" },
		"audio/vnd.dolby.heaac.2": { "source": "iana" },
		"audio/vnd.dolby.mlp": { "source": "iana" },
		"audio/vnd.dolby.mps": { "source": "iana" },
		"audio/vnd.dolby.pl2": { "source": "iana" },
		"audio/vnd.dolby.pl2x": { "source": "iana" },
		"audio/vnd.dolby.pl2z": { "source": "iana" },
		"audio/vnd.dolby.pulse.1": { "source": "iana" },
		"audio/vnd.dra": {
			"source": "iana",
			"extensions": ["dra"]
		},
		"audio/vnd.dts": {
			"source": "iana",
			"extensions": ["dts"]
		},
		"audio/vnd.dts.hd": {
			"source": "iana",
			"extensions": ["dtshd"]
		},
		"audio/vnd.dts.uhd": { "source": "iana" },
		"audio/vnd.dvb.file": { "source": "iana" },
		"audio/vnd.everad.plj": { "source": "iana" },
		"audio/vnd.hns.audio": { "source": "iana" },
		"audio/vnd.lucent.voice": {
			"source": "iana",
			"extensions": ["lvp"]
		},
		"audio/vnd.ms-playready.media.pya": {
			"source": "iana",
			"extensions": ["pya"]
		},
		"audio/vnd.nokia.mobile-xmf": { "source": "iana" },
		"audio/vnd.nortel.vbk": { "source": "iana" },
		"audio/vnd.nuera.ecelp4800": {
			"source": "iana",
			"extensions": ["ecelp4800"]
		},
		"audio/vnd.nuera.ecelp7470": {
			"source": "iana",
			"extensions": ["ecelp7470"]
		},
		"audio/vnd.nuera.ecelp9600": {
			"source": "iana",
			"extensions": ["ecelp9600"]
		},
		"audio/vnd.octel.sbc": { "source": "iana" },
		"audio/vnd.presonus.multitrack": { "source": "iana" },
		"audio/vnd.qcelp": { "source": "iana" },
		"audio/vnd.rhetorex.32kadpcm": { "source": "iana" },
		"audio/vnd.rip": {
			"source": "iana",
			"extensions": ["rip"]
		},
		"audio/vnd.rn-realaudio": { "compressible": false },
		"audio/vnd.sealedmedia.softseal.mpeg": { "source": "iana" },
		"audio/vnd.vmx.cvsd": { "source": "iana" },
		"audio/vnd.wave": { "compressible": false },
		"audio/vorbis": {
			"source": "iana",
			"compressible": false
		},
		"audio/vorbis-config": { "source": "iana" },
		"audio/wav": {
			"compressible": false,
			"extensions": ["wav"]
		},
		"audio/wave": {
			"compressible": false,
			"extensions": ["wav"]
		},
		"audio/webm": {
			"source": "apache",
			"compressible": false,
			"extensions": ["weba"]
		},
		"audio/x-aac": {
			"source": "apache",
			"compressible": false,
			"extensions": ["aac"]
		},
		"audio/x-aiff": {
			"source": "apache",
			"extensions": [
				"aif",
				"aiff",
				"aifc"
			]
		},
		"audio/x-caf": {
			"source": "apache",
			"compressible": false,
			"extensions": ["caf"]
		},
		"audio/x-flac": {
			"source": "apache",
			"extensions": ["flac"]
		},
		"audio/x-m4a": {
			"source": "nginx",
			"extensions": ["m4a"]
		},
		"audio/x-matroska": {
			"source": "apache",
			"extensions": ["mka"]
		},
		"audio/x-mpegurl": {
			"source": "apache",
			"extensions": ["m3u"]
		},
		"audio/x-ms-wax": {
			"source": "apache",
			"extensions": ["wax"]
		},
		"audio/x-ms-wma": {
			"source": "apache",
			"extensions": ["wma"]
		},
		"audio/x-pn-realaudio": {
			"source": "apache",
			"extensions": ["ram", "ra"]
		},
		"audio/x-pn-realaudio-plugin": {
			"source": "apache",
			"extensions": ["rmp"]
		},
		"audio/x-realaudio": {
			"source": "nginx",
			"extensions": ["ra"]
		},
		"audio/x-tta": { "source": "apache" },
		"audio/x-wav": {
			"source": "apache",
			"extensions": ["wav"]
		},
		"audio/xm": {
			"source": "apache",
			"extensions": ["xm"]
		},
		"chemical/x-cdx": {
			"source": "apache",
			"extensions": ["cdx"]
		},
		"chemical/x-cif": {
			"source": "apache",
			"extensions": ["cif"]
		},
		"chemical/x-cmdf": {
			"source": "apache",
			"extensions": ["cmdf"]
		},
		"chemical/x-cml": {
			"source": "apache",
			"extensions": ["cml"]
		},
		"chemical/x-csml": {
			"source": "apache",
			"extensions": ["csml"]
		},
		"chemical/x-pdb": { "source": "apache" },
		"chemical/x-xyz": {
			"source": "apache",
			"extensions": ["xyz"]
		},
		"font/collection": {
			"source": "iana",
			"extensions": ["ttc"]
		},
		"font/otf": {
			"source": "iana",
			"compressible": true,
			"extensions": ["otf"]
		},
		"font/sfnt": { "source": "iana" },
		"font/ttf": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ttf"]
		},
		"font/woff": {
			"source": "iana",
			"extensions": ["woff"]
		},
		"font/woff2": {
			"source": "iana",
			"extensions": ["woff2"]
		},
		"image/aces": {
			"source": "iana",
			"extensions": ["exr"]
		},
		"image/apng": {
			"compressible": false,
			"extensions": ["apng"]
		},
		"image/avci": {
			"source": "iana",
			"extensions": ["avci"]
		},
		"image/avcs": {
			"source": "iana",
			"extensions": ["avcs"]
		},
		"image/avif": {
			"source": "iana",
			"compressible": false,
			"extensions": ["avif"]
		},
		"image/bmp": {
			"source": "iana",
			"compressible": true,
			"extensions": ["bmp"]
		},
		"image/cgm": {
			"source": "iana",
			"extensions": ["cgm"]
		},
		"image/dicom-rle": {
			"source": "iana",
			"extensions": ["drle"]
		},
		"image/emf": {
			"source": "iana",
			"extensions": ["emf"]
		},
		"image/fits": {
			"source": "iana",
			"extensions": ["fits"]
		},
		"image/g3fax": {
			"source": "iana",
			"extensions": ["g3"]
		},
		"image/gif": {
			"source": "iana",
			"compressible": false,
			"extensions": ["gif"]
		},
		"image/heic": {
			"source": "iana",
			"extensions": ["heic"]
		},
		"image/heic-sequence": {
			"source": "iana",
			"extensions": ["heics"]
		},
		"image/heif": {
			"source": "iana",
			"extensions": ["heif"]
		},
		"image/heif-sequence": {
			"source": "iana",
			"extensions": ["heifs"]
		},
		"image/hej2k": {
			"source": "iana",
			"extensions": ["hej2"]
		},
		"image/hsj2": {
			"source": "iana",
			"extensions": ["hsj2"]
		},
		"image/ief": {
			"source": "iana",
			"extensions": ["ief"]
		},
		"image/jls": {
			"source": "iana",
			"extensions": ["jls"]
		},
		"image/jp2": {
			"source": "iana",
			"compressible": false,
			"extensions": ["jp2", "jpg2"]
		},
		"image/jpeg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"jpeg",
				"jpg",
				"jpe"
			]
		},
		"image/jph": {
			"source": "iana",
			"extensions": ["jph"]
		},
		"image/jphc": {
			"source": "iana",
			"extensions": ["jhc"]
		},
		"image/jpm": {
			"source": "iana",
			"compressible": false,
			"extensions": ["jpm"]
		},
		"image/jpx": {
			"source": "iana",
			"compressible": false,
			"extensions": ["jpx", "jpf"]
		},
		"image/jxr": {
			"source": "iana",
			"extensions": ["jxr"]
		},
		"image/jxra": {
			"source": "iana",
			"extensions": ["jxra"]
		},
		"image/jxrs": {
			"source": "iana",
			"extensions": ["jxrs"]
		},
		"image/jxs": {
			"source": "iana",
			"extensions": ["jxs"]
		},
		"image/jxsc": {
			"source": "iana",
			"extensions": ["jxsc"]
		},
		"image/jxsi": {
			"source": "iana",
			"extensions": ["jxsi"]
		},
		"image/jxss": {
			"source": "iana",
			"extensions": ["jxss"]
		},
		"image/ktx": {
			"source": "iana",
			"extensions": ["ktx"]
		},
		"image/ktx2": {
			"source": "iana",
			"extensions": ["ktx2"]
		},
		"image/naplps": { "source": "iana" },
		"image/pjpeg": { "compressible": false },
		"image/png": {
			"source": "iana",
			"compressible": false,
			"extensions": ["png"]
		},
		"image/prs.btif": {
			"source": "iana",
			"extensions": ["btif"]
		},
		"image/prs.pti": {
			"source": "iana",
			"extensions": ["pti"]
		},
		"image/pwg-raster": { "source": "iana" },
		"image/sgi": {
			"source": "apache",
			"extensions": ["sgi"]
		},
		"image/svg+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["svg", "svgz"]
		},
		"image/t38": {
			"source": "iana",
			"extensions": ["t38"]
		},
		"image/tiff": {
			"source": "iana",
			"compressible": false,
			"extensions": ["tif", "tiff"]
		},
		"image/tiff-fx": {
			"source": "iana",
			"extensions": ["tfx"]
		},
		"image/vnd.adobe.photoshop": {
			"source": "iana",
			"compressible": true,
			"extensions": ["psd"]
		},
		"image/vnd.airzip.accelerator.azv": {
			"source": "iana",
			"extensions": ["azv"]
		},
		"image/vnd.cns.inf2": { "source": "iana" },
		"image/vnd.dece.graphic": {
			"source": "iana",
			"extensions": [
				"uvi",
				"uvvi",
				"uvg",
				"uvvg"
			]
		},
		"image/vnd.djvu": {
			"source": "iana",
			"extensions": ["djvu", "djv"]
		},
		"image/vnd.dvb.subtitle": {
			"source": "iana",
			"extensions": ["sub"]
		},
		"image/vnd.dwg": {
			"source": "iana",
			"extensions": ["dwg"]
		},
		"image/vnd.dxf": {
			"source": "iana",
			"extensions": ["dxf"]
		},
		"image/vnd.fastbidsheet": {
			"source": "iana",
			"extensions": ["fbs"]
		},
		"image/vnd.fpx": {
			"source": "iana",
			"extensions": ["fpx"]
		},
		"image/vnd.fst": {
			"source": "iana",
			"extensions": ["fst"]
		},
		"image/vnd.fujixerox.edmics-mmr": {
			"source": "iana",
			"extensions": ["mmr"]
		},
		"image/vnd.fujixerox.edmics-rlc": {
			"source": "iana",
			"extensions": ["rlc"]
		},
		"image/vnd.globalgraphics.pgb": { "source": "iana" },
		"image/vnd.microsoft.icon": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ico"]
		},
		"image/vnd.mix": { "source": "iana" },
		"image/vnd.mozilla.apng": { "source": "iana" },
		"image/vnd.ms-dds": {
			"compressible": true,
			"extensions": ["dds"]
		},
		"image/vnd.ms-modi": {
			"source": "iana",
			"extensions": ["mdi"]
		},
		"image/vnd.ms-photo": {
			"source": "apache",
			"extensions": ["wdp"]
		},
		"image/vnd.net-fpx": {
			"source": "iana",
			"extensions": ["npx"]
		},
		"image/vnd.pco.b16": {
			"source": "iana",
			"extensions": ["b16"]
		},
		"image/vnd.radiance": { "source": "iana" },
		"image/vnd.sealed.png": { "source": "iana" },
		"image/vnd.sealedmedia.softseal.gif": { "source": "iana" },
		"image/vnd.sealedmedia.softseal.jpg": { "source": "iana" },
		"image/vnd.svf": { "source": "iana" },
		"image/vnd.tencent.tap": {
			"source": "iana",
			"extensions": ["tap"]
		},
		"image/vnd.valve.source.texture": {
			"source": "iana",
			"extensions": ["vtf"]
		},
		"image/vnd.wap.wbmp": {
			"source": "iana",
			"extensions": ["wbmp"]
		},
		"image/vnd.xiff": {
			"source": "iana",
			"extensions": ["xif"]
		},
		"image/vnd.zbrush.pcx": {
			"source": "iana",
			"extensions": ["pcx"]
		},
		"image/webp": {
			"source": "apache",
			"extensions": ["webp"]
		},
		"image/wmf": {
			"source": "iana",
			"extensions": ["wmf"]
		},
		"image/x-3ds": {
			"source": "apache",
			"extensions": ["3ds"]
		},
		"image/x-cmu-raster": {
			"source": "apache",
			"extensions": ["ras"]
		},
		"image/x-cmx": {
			"source": "apache",
			"extensions": ["cmx"]
		},
		"image/x-freehand": {
			"source": "apache",
			"extensions": [
				"fh",
				"fhc",
				"fh4",
				"fh5",
				"fh7"
			]
		},
		"image/x-icon": {
			"source": "apache",
			"compressible": true,
			"extensions": ["ico"]
		},
		"image/x-jng": {
			"source": "nginx",
			"extensions": ["jng"]
		},
		"image/x-mrsid-image": {
			"source": "apache",
			"extensions": ["sid"]
		},
		"image/x-ms-bmp": {
			"source": "nginx",
			"compressible": true,
			"extensions": ["bmp"]
		},
		"image/x-pcx": {
			"source": "apache",
			"extensions": ["pcx"]
		},
		"image/x-pict": {
			"source": "apache",
			"extensions": ["pic", "pct"]
		},
		"image/x-portable-anymap": {
			"source": "apache",
			"extensions": ["pnm"]
		},
		"image/x-portable-bitmap": {
			"source": "apache",
			"extensions": ["pbm"]
		},
		"image/x-portable-graymap": {
			"source": "apache",
			"extensions": ["pgm"]
		},
		"image/x-portable-pixmap": {
			"source": "apache",
			"extensions": ["ppm"]
		},
		"image/x-rgb": {
			"source": "apache",
			"extensions": ["rgb"]
		},
		"image/x-tga": {
			"source": "apache",
			"extensions": ["tga"]
		},
		"image/x-xbitmap": {
			"source": "apache",
			"extensions": ["xbm"]
		},
		"image/x-xcf": { "compressible": false },
		"image/x-xpixmap": {
			"source": "apache",
			"extensions": ["xpm"]
		},
		"image/x-xwindowdump": {
			"source": "apache",
			"extensions": ["xwd"]
		},
		"message/cpim": { "source": "iana" },
		"message/delivery-status": { "source": "iana" },
		"message/disposition-notification": {
			"source": "iana",
			"extensions": ["disposition-notification"]
		},
		"message/external-body": { "source": "iana" },
		"message/feedback-report": { "source": "iana" },
		"message/global": {
			"source": "iana",
			"extensions": ["u8msg"]
		},
		"message/global-delivery-status": {
			"source": "iana",
			"extensions": ["u8dsn"]
		},
		"message/global-disposition-notification": {
			"source": "iana",
			"extensions": ["u8mdn"]
		},
		"message/global-headers": {
			"source": "iana",
			"extensions": ["u8hdr"]
		},
		"message/http": {
			"source": "iana",
			"compressible": false
		},
		"message/imdn+xml": {
			"source": "iana",
			"compressible": true
		},
		"message/news": { "source": "iana" },
		"message/partial": {
			"source": "iana",
			"compressible": false
		},
		"message/rfc822": {
			"source": "iana",
			"compressible": true,
			"extensions": ["eml", "mime"]
		},
		"message/s-http": { "source": "iana" },
		"message/sip": { "source": "iana" },
		"message/sipfrag": { "source": "iana" },
		"message/tracking-status": { "source": "iana" },
		"message/vnd.si.simp": { "source": "iana" },
		"message/vnd.wfa.wsc": {
			"source": "iana",
			"extensions": ["wsc"]
		},
		"model/3mf": {
			"source": "iana",
			"extensions": ["3mf"]
		},
		"model/e57": { "source": "iana" },
		"model/gltf+json": {
			"source": "iana",
			"compressible": true,
			"extensions": ["gltf"]
		},
		"model/gltf-binary": {
			"source": "iana",
			"compressible": true,
			"extensions": ["glb"]
		},
		"model/iges": {
			"source": "iana",
			"compressible": false,
			"extensions": ["igs", "iges"]
		},
		"model/mesh": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"msh",
				"mesh",
				"silo"
			]
		},
		"model/mtl": {
			"source": "iana",
			"extensions": ["mtl"]
		},
		"model/obj": {
			"source": "iana",
			"extensions": ["obj"]
		},
		"model/step": { "source": "iana" },
		"model/step+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["stpx"]
		},
		"model/step+zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["stpz"]
		},
		"model/step-xml+zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["stpxz"]
		},
		"model/stl": {
			"source": "iana",
			"extensions": ["stl"]
		},
		"model/vnd.collada+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dae"]
		},
		"model/vnd.dwf": {
			"source": "iana",
			"extensions": ["dwf"]
		},
		"model/vnd.flatland.3dml": { "source": "iana" },
		"model/vnd.gdl": {
			"source": "iana",
			"extensions": ["gdl"]
		},
		"model/vnd.gs-gdl": { "source": "apache" },
		"model/vnd.gs.gdl": { "source": "iana" },
		"model/vnd.gtw": {
			"source": "iana",
			"extensions": ["gtw"]
		},
		"model/vnd.moml+xml": {
			"source": "iana",
			"compressible": true
		},
		"model/vnd.mts": {
			"source": "iana",
			"extensions": ["mts"]
		},
		"model/vnd.opengex": {
			"source": "iana",
			"extensions": ["ogex"]
		},
		"model/vnd.parasolid.transmit.binary": {
			"source": "iana",
			"extensions": ["x_b"]
		},
		"model/vnd.parasolid.transmit.text": {
			"source": "iana",
			"extensions": ["x_t"]
		},
		"model/vnd.pytha.pyox": { "source": "iana" },
		"model/vnd.rosette.annotated-data-model": { "source": "iana" },
		"model/vnd.sap.vds": {
			"source": "iana",
			"extensions": ["vds"]
		},
		"model/vnd.usdz+zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["usdz"]
		},
		"model/vnd.valve.source.compiled-map": {
			"source": "iana",
			"extensions": ["bsp"]
		},
		"model/vnd.vtu": {
			"source": "iana",
			"extensions": ["vtu"]
		},
		"model/vrml": {
			"source": "iana",
			"compressible": false,
			"extensions": ["wrl", "vrml"]
		},
		"model/x3d+binary": {
			"source": "apache",
			"compressible": false,
			"extensions": ["x3db", "x3dbz"]
		},
		"model/x3d+fastinfoset": {
			"source": "iana",
			"extensions": ["x3db"]
		},
		"model/x3d+vrml": {
			"source": "apache",
			"compressible": false,
			"extensions": ["x3dv", "x3dvz"]
		},
		"model/x3d+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["x3d", "x3dz"]
		},
		"model/x3d-vrml": {
			"source": "iana",
			"extensions": ["x3dv"]
		},
		"multipart/alternative": {
			"source": "iana",
			"compressible": false
		},
		"multipart/appledouble": { "source": "iana" },
		"multipart/byteranges": { "source": "iana" },
		"multipart/digest": { "source": "iana" },
		"multipart/encrypted": {
			"source": "iana",
			"compressible": false
		},
		"multipart/form-data": {
			"source": "iana",
			"compressible": false
		},
		"multipart/header-set": { "source": "iana" },
		"multipart/mixed": { "source": "iana" },
		"multipart/multilingual": { "source": "iana" },
		"multipart/parallel": { "source": "iana" },
		"multipart/related": {
			"source": "iana",
			"compressible": false
		},
		"multipart/report": { "source": "iana" },
		"multipart/signed": {
			"source": "iana",
			"compressible": false
		},
		"multipart/vnd.bint.med-plus": { "source": "iana" },
		"multipart/voice-message": { "source": "iana" },
		"multipart/x-mixed-replace": { "source": "iana" },
		"text/1d-interleaved-parityfec": { "source": "iana" },
		"text/cache-manifest": {
			"source": "iana",
			"compressible": true,
			"extensions": ["appcache", "manifest"]
		},
		"text/calendar": {
			"source": "iana",
			"extensions": ["ics", "ifb"]
		},
		"text/calender": { "compressible": true },
		"text/cmd": { "compressible": true },
		"text/coffeescript": { "extensions": ["coffee", "litcoffee"] },
		"text/cql": { "source": "iana" },
		"text/cql-expression": { "source": "iana" },
		"text/cql-identifier": { "source": "iana" },
		"text/css": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["css"]
		},
		"text/csv": {
			"source": "iana",
			"compressible": true,
			"extensions": ["csv"]
		},
		"text/csv-schema": { "source": "iana" },
		"text/directory": { "source": "iana" },
		"text/dns": { "source": "iana" },
		"text/ecmascript": { "source": "iana" },
		"text/encaprtp": { "source": "iana" },
		"text/enriched": { "source": "iana" },
		"text/fhirpath": { "source": "iana" },
		"text/flexfec": { "source": "iana" },
		"text/fwdred": { "source": "iana" },
		"text/gff3": { "source": "iana" },
		"text/grammar-ref-list": { "source": "iana" },
		"text/html": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"html",
				"htm",
				"shtml"
			]
		},
		"text/jade": { "extensions": ["jade"] },
		"text/javascript": {
			"source": "iana",
			"compressible": true
		},
		"text/jcr-cnd": { "source": "iana" },
		"text/jsx": {
			"compressible": true,
			"extensions": ["jsx"]
		},
		"text/less": {
			"compressible": true,
			"extensions": ["less"]
		},
		"text/markdown": {
			"source": "iana",
			"compressible": true,
			"extensions": ["markdown", "md"]
		},
		"text/mathml": {
			"source": "nginx",
			"extensions": ["mml"]
		},
		"text/mdx": {
			"compressible": true,
			"extensions": ["mdx"]
		},
		"text/mizar": { "source": "iana" },
		"text/n3": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["n3"]
		},
		"text/parameters": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/parityfec": { "source": "iana" },
		"text/plain": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"txt",
				"text",
				"conf",
				"def",
				"list",
				"log",
				"in",
				"ini"
			]
		},
		"text/provenance-notation": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/prs.fallenstein.rst": { "source": "iana" },
		"text/prs.lines.tag": {
			"source": "iana",
			"extensions": ["dsc"]
		},
		"text/prs.prop.logic": { "source": "iana" },
		"text/raptorfec": { "source": "iana" },
		"text/red": { "source": "iana" },
		"text/rfc822-headers": { "source": "iana" },
		"text/richtext": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rtx"]
		},
		"text/rtf": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rtf"]
		},
		"text/rtp-enc-aescm128": { "source": "iana" },
		"text/rtploopback": { "source": "iana" },
		"text/rtx": { "source": "iana" },
		"text/sgml": {
			"source": "iana",
			"extensions": ["sgml", "sgm"]
		},
		"text/shaclc": { "source": "iana" },
		"text/shex": {
			"source": "iana",
			"extensions": ["shex"]
		},
		"text/slim": { "extensions": ["slim", "slm"] },
		"text/spdx": {
			"source": "iana",
			"extensions": ["spdx"]
		},
		"text/strings": { "source": "iana" },
		"text/stylus": { "extensions": ["stylus", "styl"] },
		"text/t140": { "source": "iana" },
		"text/tab-separated-values": {
			"source": "iana",
			"compressible": true,
			"extensions": ["tsv"]
		},
		"text/troff": {
			"source": "iana",
			"extensions": [
				"t",
				"tr",
				"roff",
				"man",
				"me",
				"ms"
			]
		},
		"text/turtle": {
			"source": "iana",
			"charset": "UTF-8",
			"extensions": ["ttl"]
		},
		"text/ulpfec": { "source": "iana" },
		"text/uri-list": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"uri",
				"uris",
				"urls"
			]
		},
		"text/vcard": {
			"source": "iana",
			"compressible": true,
			"extensions": ["vcard"]
		},
		"text/vnd.a": { "source": "iana" },
		"text/vnd.abc": { "source": "iana" },
		"text/vnd.ascii-art": { "source": "iana" },
		"text/vnd.curl": {
			"source": "iana",
			"extensions": ["curl"]
		},
		"text/vnd.curl.dcurl": {
			"source": "apache",
			"extensions": ["dcurl"]
		},
		"text/vnd.curl.mcurl": {
			"source": "apache",
			"extensions": ["mcurl"]
		},
		"text/vnd.curl.scurl": {
			"source": "apache",
			"extensions": ["scurl"]
		},
		"text/vnd.debian.copyright": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/vnd.dmclientscript": { "source": "iana" },
		"text/vnd.dvb.subtitle": {
			"source": "iana",
			"extensions": ["sub"]
		},
		"text/vnd.esmertec.theme-descriptor": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/vnd.familysearch.gedcom": {
			"source": "iana",
			"extensions": ["ged"]
		},
		"text/vnd.ficlab.flt": { "source": "iana" },
		"text/vnd.fly": {
			"source": "iana",
			"extensions": ["fly"]
		},
		"text/vnd.fmi.flexstor": {
			"source": "iana",
			"extensions": ["flx"]
		},
		"text/vnd.gml": { "source": "iana" },
		"text/vnd.graphviz": {
			"source": "iana",
			"extensions": ["gv"]
		},
		"text/vnd.hans": { "source": "iana" },
		"text/vnd.hgl": { "source": "iana" },
		"text/vnd.in3d.3dml": {
			"source": "iana",
			"extensions": ["3dml"]
		},
		"text/vnd.in3d.spot": {
			"source": "iana",
			"extensions": ["spot"]
		},
		"text/vnd.iptc.newsml": { "source": "iana" },
		"text/vnd.iptc.nitf": { "source": "iana" },
		"text/vnd.latex-z": { "source": "iana" },
		"text/vnd.motorola.reflex": { "source": "iana" },
		"text/vnd.ms-mediapackage": { "source": "iana" },
		"text/vnd.net2phone.commcenter.command": { "source": "iana" },
		"text/vnd.radisys.msml-basic-layout": { "source": "iana" },
		"text/vnd.senx.warpscript": { "source": "iana" },
		"text/vnd.si.uricatalogue": { "source": "iana" },
		"text/vnd.sosi": { "source": "iana" },
		"text/vnd.sun.j2me.app-descriptor": {
			"source": "iana",
			"charset": "UTF-8",
			"extensions": ["jad"]
		},
		"text/vnd.trolltech.linguist": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/vnd.wap.si": { "source": "iana" },
		"text/vnd.wap.sl": { "source": "iana" },
		"text/vnd.wap.wml": {
			"source": "iana",
			"extensions": ["wml"]
		},
		"text/vnd.wap.wmlscript": {
			"source": "iana",
			"extensions": ["wmls"]
		},
		"text/vtt": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["vtt"]
		},
		"text/x-asm": {
			"source": "apache",
			"extensions": ["s", "asm"]
		},
		"text/x-c": {
			"source": "apache",
			"extensions": [
				"c",
				"cc",
				"cxx",
				"cpp",
				"h",
				"hh",
				"dic"
			]
		},
		"text/x-component": {
			"source": "nginx",
			"extensions": ["htc"]
		},
		"text/x-fortran": {
			"source": "apache",
			"extensions": [
				"f",
				"for",
				"f77",
				"f90"
			]
		},
		"text/x-gwt-rpc": { "compressible": true },
		"text/x-handlebars-template": { "extensions": ["hbs"] },
		"text/x-java-source": {
			"source": "apache",
			"extensions": ["java"]
		},
		"text/x-jquery-tmpl": { "compressible": true },
		"text/x-lua": { "extensions": ["lua"] },
		"text/x-markdown": {
			"compressible": true,
			"extensions": ["mkd"]
		},
		"text/x-nfo": {
			"source": "apache",
			"extensions": ["nfo"]
		},
		"text/x-opml": {
			"source": "apache",
			"extensions": ["opml"]
		},
		"text/x-org": {
			"compressible": true,
			"extensions": ["org"]
		},
		"text/x-pascal": {
			"source": "apache",
			"extensions": ["p", "pas"]
		},
		"text/x-processing": {
			"compressible": true,
			"extensions": ["pde"]
		},
		"text/x-sass": { "extensions": ["sass"] },
		"text/x-scss": { "extensions": ["scss"] },
		"text/x-setext": {
			"source": "apache",
			"extensions": ["etx"]
		},
		"text/x-sfv": {
			"source": "apache",
			"extensions": ["sfv"]
		},
		"text/x-suse-ymp": {
			"compressible": true,
			"extensions": ["ymp"]
		},
		"text/x-uuencode": {
			"source": "apache",
			"extensions": ["uu"]
		},
		"text/x-vcalendar": {
			"source": "apache",
			"extensions": ["vcs"]
		},
		"text/x-vcard": {
			"source": "apache",
			"extensions": ["vcf"]
		},
		"text/xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xml"]
		},
		"text/xml-external-parsed-entity": { "source": "iana" },
		"text/yaml": {
			"compressible": true,
			"extensions": ["yaml", "yml"]
		},
		"video/1d-interleaved-parityfec": { "source": "iana" },
		"video/3gpp": {
			"source": "iana",
			"extensions": ["3gp", "3gpp"]
		},
		"video/3gpp-tt": { "source": "iana" },
		"video/3gpp2": {
			"source": "iana",
			"extensions": ["3g2"]
		},
		"video/av1": { "source": "iana" },
		"video/bmpeg": { "source": "iana" },
		"video/bt656": { "source": "iana" },
		"video/celb": { "source": "iana" },
		"video/dv": { "source": "iana" },
		"video/encaprtp": { "source": "iana" },
		"video/ffv1": { "source": "iana" },
		"video/flexfec": { "source": "iana" },
		"video/h261": {
			"source": "iana",
			"extensions": ["h261"]
		},
		"video/h263": {
			"source": "iana",
			"extensions": ["h263"]
		},
		"video/h263-1998": { "source": "iana" },
		"video/h263-2000": { "source": "iana" },
		"video/h264": {
			"source": "iana",
			"extensions": ["h264"]
		},
		"video/h264-rcdo": { "source": "iana" },
		"video/h264-svc": { "source": "iana" },
		"video/h265": { "source": "iana" },
		"video/iso.segment": {
			"source": "iana",
			"extensions": ["m4s"]
		},
		"video/jpeg": {
			"source": "iana",
			"extensions": ["jpgv"]
		},
		"video/jpeg2000": { "source": "iana" },
		"video/jpm": {
			"source": "apache",
			"extensions": ["jpm", "jpgm"]
		},
		"video/jxsv": { "source": "iana" },
		"video/mj2": {
			"source": "iana",
			"extensions": ["mj2", "mjp2"]
		},
		"video/mp1s": { "source": "iana" },
		"video/mp2p": { "source": "iana" },
		"video/mp2t": {
			"source": "iana",
			"extensions": ["ts"]
		},
		"video/mp4": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"mp4",
				"mp4v",
				"mpg4"
			]
		},
		"video/mp4v-es": { "source": "iana" },
		"video/mpeg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"mpeg",
				"mpg",
				"mpe",
				"m1v",
				"m2v"
			]
		},
		"video/mpeg4-generic": { "source": "iana" },
		"video/mpv": { "source": "iana" },
		"video/nv": { "source": "iana" },
		"video/ogg": {
			"source": "iana",
			"compressible": false,
			"extensions": ["ogv"]
		},
		"video/parityfec": { "source": "iana" },
		"video/pointer": { "source": "iana" },
		"video/quicktime": {
			"source": "iana",
			"compressible": false,
			"extensions": ["qt", "mov"]
		},
		"video/raptorfec": { "source": "iana" },
		"video/raw": { "source": "iana" },
		"video/rtp-enc-aescm128": { "source": "iana" },
		"video/rtploopback": { "source": "iana" },
		"video/rtx": { "source": "iana" },
		"video/scip": { "source": "iana" },
		"video/smpte291": { "source": "iana" },
		"video/smpte292m": { "source": "iana" },
		"video/ulpfec": { "source": "iana" },
		"video/vc1": { "source": "iana" },
		"video/vc2": { "source": "iana" },
		"video/vnd.cctv": { "source": "iana" },
		"video/vnd.dece.hd": {
			"source": "iana",
			"extensions": ["uvh", "uvvh"]
		},
		"video/vnd.dece.mobile": {
			"source": "iana",
			"extensions": ["uvm", "uvvm"]
		},
		"video/vnd.dece.mp4": { "source": "iana" },
		"video/vnd.dece.pd": {
			"source": "iana",
			"extensions": ["uvp", "uvvp"]
		},
		"video/vnd.dece.sd": {
			"source": "iana",
			"extensions": ["uvs", "uvvs"]
		},
		"video/vnd.dece.video": {
			"source": "iana",
			"extensions": ["uvv", "uvvv"]
		},
		"video/vnd.directv.mpeg": { "source": "iana" },
		"video/vnd.directv.mpeg-tts": { "source": "iana" },
		"video/vnd.dlna.mpeg-tts": { "source": "iana" },
		"video/vnd.dvb.file": {
			"source": "iana",
			"extensions": ["dvb"]
		},
		"video/vnd.fvt": {
			"source": "iana",
			"extensions": ["fvt"]
		},
		"video/vnd.hns.video": { "source": "iana" },
		"video/vnd.iptvforum.1dparityfec-1010": { "source": "iana" },
		"video/vnd.iptvforum.1dparityfec-2005": { "source": "iana" },
		"video/vnd.iptvforum.2dparityfec-1010": { "source": "iana" },
		"video/vnd.iptvforum.2dparityfec-2005": { "source": "iana" },
		"video/vnd.iptvforum.ttsavc": { "source": "iana" },
		"video/vnd.iptvforum.ttsmpeg2": { "source": "iana" },
		"video/vnd.motorola.video": { "source": "iana" },
		"video/vnd.motorola.videop": { "source": "iana" },
		"video/vnd.mpegurl": {
			"source": "iana",
			"extensions": ["mxu", "m4u"]
		},
		"video/vnd.ms-playready.media.pyv": {
			"source": "iana",
			"extensions": ["pyv"]
		},
		"video/vnd.nokia.interleaved-multimedia": { "source": "iana" },
		"video/vnd.nokia.mp4vr": { "source": "iana" },
		"video/vnd.nokia.videovoip": { "source": "iana" },
		"video/vnd.objectvideo": { "source": "iana" },
		"video/vnd.radgamettools.bink": { "source": "iana" },
		"video/vnd.radgamettools.smacker": { "source": "iana" },
		"video/vnd.sealed.mpeg1": { "source": "iana" },
		"video/vnd.sealed.mpeg4": { "source": "iana" },
		"video/vnd.sealed.swf": { "source": "iana" },
		"video/vnd.sealedmedia.softseal.mov": { "source": "iana" },
		"video/vnd.uvvu.mp4": {
			"source": "iana",
			"extensions": ["uvu", "uvvu"]
		},
		"video/vnd.vivo": {
			"source": "iana",
			"extensions": ["viv"]
		},
		"video/vnd.youtube.yt": { "source": "iana" },
		"video/vp8": { "source": "iana" },
		"video/vp9": { "source": "iana" },
		"video/webm": {
			"source": "apache",
			"compressible": false,
			"extensions": ["webm"]
		},
		"video/x-f4v": {
			"source": "apache",
			"extensions": ["f4v"]
		},
		"video/x-fli": {
			"source": "apache",
			"extensions": ["fli"]
		},
		"video/x-flv": {
			"source": "apache",
			"compressible": false,
			"extensions": ["flv"]
		},
		"video/x-m4v": {
			"source": "apache",
			"extensions": ["m4v"]
		},
		"video/x-matroska": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"mkv",
				"mk3d",
				"mks"
			]
		},
		"video/x-mng": {
			"source": "apache",
			"extensions": ["mng"]
		},
		"video/x-ms-asf": {
			"source": "apache",
			"extensions": ["asf", "asx"]
		},
		"video/x-ms-vob": {
			"source": "apache",
			"extensions": ["vob"]
		},
		"video/x-ms-wm": {
			"source": "apache",
			"extensions": ["wm"]
		},
		"video/x-ms-wmv": {
			"source": "apache",
			"compressible": false,
			"extensions": ["wmv"]
		},
		"video/x-ms-wmx": {
			"source": "apache",
			"extensions": ["wmx"]
		},
		"video/x-ms-wvx": {
			"source": "apache",
			"extensions": ["wvx"]
		},
		"video/x-msvideo": {
			"source": "apache",
			"extensions": ["avi"]
		},
		"video/x-sgi-movie": {
			"source": "apache",
			"extensions": ["movie"]
		},
		"video/x-smv": {
			"source": "apache",
			"extensions": ["smv"]
		},
		"x-conference/x-cooltalk": {
			"source": "apache",
			"extensions": ["ice"]
		},
		"x-shader/x-fragment": { "compressible": true },
		"x-shader/x-vertex": { "compressible": true }
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js
var require_mime_db = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js": ((exports, module) => {
	/*!
	* mime-db
	* Copyright(c) 2014 Jonathan Ong
	* Copyright(c) 2015-2022 Douglas Christopher Wilson
	* MIT Licensed
	*/
	/**
	* Module exports.
	*/
	module.exports = require_db();
}) });

//#endregion
//#region ../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js
var require_mime_types = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js": ((exports) => {
	/**
	* Module dependencies.
	* @private
	*/
	var db$1 = require_mime_db();
	var extname = __require("path").extname;
	/**
	* Module variables.
	* @private
	*/
	var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
	var TEXT_TYPE_REGEXP = /^text\//i;
	/**
	* Module exports.
	* @public
	*/
	exports.charset = charset$1;
	exports.charsets = { lookup: charset$1 };
	exports.contentType = contentType$1;
	exports.extension = extension;
	exports.extensions = Object.create(null);
	exports.lookup = lookup;
	exports.types = Object.create(null);
	populateMaps(exports.extensions, exports.types);
	/**
	* Get the default charset for a MIME type.
	*
	* @param {string} type
	* @return {boolean|string}
	*/
	function charset$1(type$1) {
		if (!type$1 || typeof type$1 !== "string") return false;
		var match = EXTRACT_TYPE_REGEXP.exec(type$1);
		var mime$1 = match && db$1[match[1].toLowerCase()];
		if (mime$1 && mime$1.charset) return mime$1.charset;
		if (match && TEXT_TYPE_REGEXP.test(match[1])) return "UTF-8";
		return false;
	}
	/**
	* Create a full Content-Type header given a MIME type or extension.
	*
	* @param {string} str
	* @return {boolean|string}
	*/
	function contentType$1(str) {
		if (!str || typeof str !== "string") return false;
		var mime$1 = str.indexOf("/") === -1 ? exports.lookup(str) : str;
		if (!mime$1) return false;
		if (mime$1.indexOf("charset") === -1) {
			var charset$2 = exports.charset(mime$1);
			if (charset$2) mime$1 += "; charset=" + charset$2.toLowerCase();
		}
		return mime$1;
	}
	/**
	* Get the default extension for a MIME type.
	*
	* @param {string} type
	* @return {boolean|string}
	*/
	function extension(type$1) {
		if (!type$1 || typeof type$1 !== "string") return false;
		var match = EXTRACT_TYPE_REGEXP.exec(type$1);
		var exts = match && exports.extensions[match[1].toLowerCase()];
		if (!exts || !exts.length) return false;
		return exts[0];
	}
	/**
	* Lookup the MIME type for a file path/extension.
	*
	* @param {string} path
	* @return {boolean|string}
	*/
	function lookup(path$3) {
		if (!path$3 || typeof path$3 !== "string") return false;
		var extension$1 = extname("x." + path$3).toLowerCase().substr(1);
		if (!extension$1) return false;
		return exports.types[extension$1] || false;
	}
	/**
	* Populate the extensions and types maps.
	* @private
	*/
	function populateMaps(extensions, types) {
		var preference = [
			"nginx",
			"apache",
			void 0,
			"iana"
		];
		Object.keys(db$1).forEach(function forEachMimeType(type$1) {
			var mime$1 = db$1[type$1];
			var exts = mime$1.extensions;
			if (!exts || !exts.length) return;
			extensions[type$1] = exts;
			for (var i = 0; i < exts.length; i++) {
				var extension$1 = exts[i];
				if (types[extension$1]) {
					var from = preference.indexOf(db$1[types[extension$1]].source);
					var to = preference.indexOf(mime$1.source);
					if (types[extension$1] !== "application/octet-stream" && (from > to || from === to && types[extension$1].substr(0, 12) === "application/")) continue;
				}
				types[extension$1] = type$1;
			}
		});
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js
var require_defer = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js": ((exports, module) => {
	module.exports = defer$1;
	/**
	* Runs provided function on next iteration of the event loop
	*
	* @param {function} fn - function to run
	*/
	function defer$1(fn) {
		var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
		if (nextTick) nextTick(fn);
		else setTimeout(fn, 0);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js
var require_async = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js": ((exports, module) => {
	var defer = require_defer();
	module.exports = async$2;
	/**
	* Runs provided callback asynchronously
	* even if callback itself is not
	*
	* @param   {function} callback - callback to invoke
	* @returns {function} - augmented callback
	*/
	function async$2(callback) {
		var isAsync = false;
		defer(function() {
			isAsync = true;
		});
		return function async_callback(err, result) {
			if (isAsync) callback(err, result);
			else defer(function nextTick_callback() {
				callback(err, result);
			});
		};
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js
var require_abort = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js": ((exports, module) => {
	module.exports = abort$2;
	/**
	* Aborts leftover active jobs
	*
	* @param {object} state - current state object
	*/
	function abort$2(state$1) {
		Object.keys(state$1.jobs).forEach(clean.bind(state$1));
		state$1.jobs = {};
	}
	/**
	* Cleans up leftover job by invoking abort function for the provided job id
	*
	* @this  state
	* @param {string|number} key - job id to abort
	*/
	function clean(key) {
		if (typeof this.jobs[key] == "function") this.jobs[key]();
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js
var require_iterate = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js": ((exports, module) => {
	var async$1 = require_async(), abort$1 = require_abort();
	module.exports = iterate$2;
	/**
	* Iterates over each job object
	*
	* @param {array|object} list - array or object (named list) to iterate over
	* @param {function} iterator - iterator to run
	* @param {object} state - current job status
	* @param {function} callback - invoked when all elements processed
	*/
	function iterate$2(list, iterator$1, state$1, callback) {
		var key = state$1["keyedList"] ? state$1["keyedList"][state$1.index] : state$1.index;
		state$1.jobs[key] = runJob(iterator$1, key, list[key], function(error, output$1) {
			if (!(key in state$1.jobs)) return;
			delete state$1.jobs[key];
			if (error) abort$1(state$1);
			else state$1.results[key] = output$1;
			callback(error, state$1.results);
		});
	}
	/**
	* Runs iterator over provided job element
	*
	* @param   {function} iterator - iterator to invoke
	* @param   {string|number} key - key/index of the element in the list of jobs
	* @param   {mixed} item - job description
	* @param   {function} callback - invoked after iterator is done with the job
	* @returns {function|mixed} - job abort function or something else
	*/
	function runJob(iterator$1, key, item, callback) {
		var aborter;
		if (iterator$1.length == 2) aborter = iterator$1(item, async$1(callback));
		else aborter = iterator$1(item, key, async$1(callback));
		return aborter;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js
var require_state = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js": ((exports, module) => {
	module.exports = state;
	/**
	* Creates initial state object
	* for iteration over list
	*
	* @param   {array|object} list - list to iterate over
	* @param   {function|null} sortMethod - function to use for keys sort,
	*                                     or `null` to keep them as is
	* @returns {object} - initial state object
	*/
	function state(list, sortMethod) {
		var isNamedList = !Array.isArray(list), initState$2 = {
			index: 0,
			keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
			jobs: {},
			results: isNamedList ? {} : [],
			size: isNamedList ? Object.keys(list).length : list.length
		};
		if (sortMethod) initState$2.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
			return sortMethod(list[a], list[b]);
		});
		return initState$2;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js
var require_terminator = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js": ((exports, module) => {
	var abort = require_abort(), async = require_async();
	module.exports = terminator$2;
	/**
	* Terminates jobs in the attached state context
	*
	* @this  AsyncKitState#
	* @param {function} callback - final callback to invoke after termination
	*/
	function terminator$2(callback) {
		if (!Object.keys(this.jobs).length) return;
		this.index = this.size;
		abort(this);
		async(callback)(null, this.results);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js
var require_parallel = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js": ((exports, module) => {
	var iterate$1 = require_iterate(), initState$1 = require_state(), terminator$1 = require_terminator();
	module.exports = parallel;
	/**
	* Runs iterator over provided array elements in parallel
	*
	* @param   {array|object} list - array or object (named list) to iterate over
	* @param   {function} iterator - iterator to run
	* @param   {function} callback - invoked when all elements processed
	* @returns {function} - jobs terminator
	*/
	function parallel(list, iterator$1, callback) {
		var state$1 = initState$1(list);
		while (state$1.index < (state$1["keyedList"] || list).length) {
			iterate$1(list, iterator$1, state$1, function(error, result) {
				if (error) {
					callback(error, result);
					return;
				}
				if (Object.keys(state$1.jobs).length === 0) {
					callback(null, state$1.results);
					return;
				}
			});
			state$1.index++;
		}
		return terminator$1.bind(state$1, callback);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js
var require_serialOrdered = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js": ((exports, module) => {
	var iterate = require_iterate(), initState = require_state(), terminator = require_terminator();
	module.exports = serialOrdered$1;
	module.exports.ascending = ascending;
	module.exports.descending = descending;
	/**
	* Runs iterator over provided sorted array elements in series
	*
	* @param   {array|object} list - array or object (named list) to iterate over
	* @param   {function} iterator - iterator to run
	* @param   {function} sortMethod - custom sort function
	* @param   {function} callback - invoked when all elements processed
	* @returns {function} - jobs terminator
	*/
	function serialOrdered$1(list, iterator$1, sortMethod, callback) {
		var state$1 = initState(list, sortMethod);
		iterate(list, iterator$1, state$1, function iteratorHandler(error, result) {
			if (error) {
				callback(error, result);
				return;
			}
			state$1.index++;
			if (state$1.index < (state$1["keyedList"] || list).length) {
				iterate(list, iterator$1, state$1, iteratorHandler);
				return;
			}
			callback(null, state$1.results);
		});
		return terminator.bind(state$1, callback);
	}
	/**
	* sort helper to sort array elements in ascending order
	*
	* @param   {mixed} a - an item to compare
	* @param   {mixed} b - an item to compare
	* @returns {number} - comparison result
	*/
	function ascending(a, b) {
		return a < b ? -1 : a > b ? 1 : 0;
	}
	/**
	* sort helper to sort array elements in descending order
	*
	* @param   {mixed} a - an item to compare
	* @param   {mixed} b - an item to compare
	* @returns {number} - comparison result
	*/
	function descending(a, b) {
		return -1 * ascending(a, b);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js
var require_serial = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js": ((exports, module) => {
	var serialOrdered = require_serialOrdered();
	module.exports = serial;
	/**
	* Runs iterator over provided array elements in series
	*
	* @param   {array|object} list - array or object (named list) to iterate over
	* @param   {function} iterator - iterator to run
	* @param   {function} callback - invoked when all elements processed
	* @returns {function} - jobs terminator
	*/
	function serial(list, iterator$1, callback) {
		return serialOrdered(list, iterator$1, null, callback);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js
var require_asynckit = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js": ((exports, module) => {
	module.exports = {
		parallel: require_parallel(),
		serial: require_serial(),
		serialOrdered: require_serialOrdered()
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js
var require_es_object_atoms = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js": ((exports, module) => {
	/** @type {import('.')} */
	module.exports = Object;
}) });

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js
var require_es_errors = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js": ((exports, module) => {
	/** @type {import('.')} */
	module.exports = Error;
}) });

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js
var require_eval$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js": ((exports, module) => {
	/** @type {import('./eval')} */
	module.exports = EvalError;
}) });

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js
var require_range = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js": ((exports, module) => {
	/** @type {import('./range')} */
	module.exports = RangeError;
}) });

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js
var require_ref = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js": ((exports, module) => {
	/** @type {import('./ref')} */
	module.exports = ReferenceError;
}) });

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js
var require_syntax = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js": ((exports, module) => {
	/** @type {import('./syntax')} */
	module.exports = SyntaxError;
}) });

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js
var require_type = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js": ((exports, module) => {
	/** @type {import('./type')} */
	module.exports = TypeError;
}) });

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js
var require_uri = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js": ((exports, module) => {
	/** @type {import('./uri')} */
	module.exports = URIError;
}) });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js
var require_abs = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js": ((exports, module) => {
	/** @type {import('./abs')} */
	module.exports = Math.abs;
}) });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js
var require_floor = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js": ((exports, module) => {
	/** @type {import('./floor')} */
	module.exports = Math.floor;
}) });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js
var require_max = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js": ((exports, module) => {
	/** @type {import('./max')} */
	module.exports = Math.max;
}) });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js
var require_min = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js": ((exports, module) => {
	/** @type {import('./min')} */
	module.exports = Math.min;
}) });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js
var require_pow = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js": ((exports, module) => {
	/** @type {import('./pow')} */
	module.exports = Math.pow;
}) });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js
var require_round = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js": ((exports, module) => {
	/** @type {import('./round')} */
	module.exports = Math.round;
}) });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js
var require_isNaN$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js": ((exports, module) => {
	/** @type {import('./isNaN')} */
	module.exports = Number.isNaN || function isNaN$1(a) {
		return a !== a;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js
var require_sign = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js": ((exports, module) => {
	var $isNaN = require_isNaN$1();
	/** @type {import('./sign')} */
	module.exports = function sign$2(number$3) {
		if ($isNaN(number$3) || number$3 === 0) return number$3;
		return number$3 < 0 ? -1 : 1;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js
var require_gOPD = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js": ((exports, module) => {
	/** @type {import('./gOPD')} */
	module.exports = Object.getOwnPropertyDescriptor;
}) });

//#endregion
//#region ../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js
var require_gopd = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js": ((exports, module) => {
	/** @type {import('.')} */
	var $gOPD$1 = require_gOPD();
	if ($gOPD$1) try {
		$gOPD$1([], "length");
	} catch (e) {
		$gOPD$1 = null;
	}
	module.exports = $gOPD$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js
var require_es_define_property = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js": ((exports, module) => {
	/** @type {import('.')} */
	var $defineProperty$2 = Object.defineProperty || false;
	if ($defineProperty$2) try {
		$defineProperty$2({}, "a", { value: 1 });
	} catch (e) {
		$defineProperty$2 = false;
	}
	module.exports = $defineProperty$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js
var require_shams$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js": ((exports, module) => {
	/** @type {import('./shams')} */
	module.exports = function hasSymbols$3() {
		if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") return false;
		if (typeof Symbol.iterator === "symbol") return true;
		/** @type {{ [k in symbol]?: unknown }} */
		var obj = {};
		var sym = Symbol("test");
		var symObj = Object(sym);
		if (typeof sym === "string") return false;
		if (Object.prototype.toString.call(sym) !== "[object Symbol]") return false;
		if (Object.prototype.toString.call(symObj) !== "[object Symbol]") return false;
		var symVal = 42;
		obj[sym] = symVal;
		for (var _ in obj) return false;
		if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) return false;
		if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) return false;
		var syms = Object.getOwnPropertySymbols(obj);
		if (syms.length !== 1 || syms[0] !== sym) return false;
		if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) return false;
		if (typeof Object.getOwnPropertyDescriptor === "function") {
			var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
			if (descriptor.value !== symVal || descriptor.enumerable !== true) return false;
		}
		return true;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js
var require_has_symbols = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js": ((exports, module) => {
	var origSymbol = typeof Symbol !== "undefined" && Symbol;
	var hasSymbolSham = require_shams$1();
	/** @type {import('.')} */
	module.exports = function hasNativeSymbols() {
		if (typeof origSymbol !== "function") return false;
		if (typeof Symbol !== "function") return false;
		if (typeof origSymbol("foo") !== "symbol") return false;
		if (typeof Symbol("bar") !== "symbol") return false;
		return hasSymbolSham();
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js": ((exports, module) => {
	/** @type {import('./Reflect.getPrototypeOf')} */
	module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
}) });

//#endregion
//#region ../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js": ((exports, module) => {
	var $Object$2 = require_es_object_atoms();
	/** @type {import('./Object.getPrototypeOf')} */
	module.exports = $Object$2.getPrototypeOf || null;
}) });

//#endregion
//#region ../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js
var require_implementation = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js": ((exports, module) => {
	var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
	var toStr = Object.prototype.toString;
	var max$2 = Math.max;
	var funcType = "[object Function]";
	var concatty = function concatty$1(a, b) {
		var arr = [];
		for (var i = 0; i < a.length; i += 1) arr[i] = a[i];
		for (var j = 0; j < b.length; j += 1) arr[j + a.length] = b[j];
		return arr;
	};
	var slicy = function slicy$1(arrLike, offset) {
		var arr = [];
		for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) arr[j] = arrLike[i];
		return arr;
	};
	var joiny = function(arr, joiner) {
		var str = "";
		for (var i = 0; i < arr.length; i += 1) {
			str += arr[i];
			if (i + 1 < arr.length) str += joiner;
		}
		return str;
	};
	module.exports = function bind$5(that) {
		var target = this;
		if (typeof target !== "function" || toStr.apply(target) !== funcType) throw new TypeError(ERROR_MESSAGE + target);
		var args = slicy(arguments, 1);
		var bound;
		var binder = function() {
			if (this instanceof bound) {
				var result = target.apply(this, concatty(args, arguments));
				if (Object(result) === result) return result;
				return this;
			}
			return target.apply(that, concatty(args, arguments));
		};
		var boundLength = max$2(0, target.length - args.length);
		var boundArgs = [];
		for (var i = 0; i < boundLength; i++) boundArgs[i] = "$" + i;
		bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
		if (target.prototype) {
			var Empty = function Empty$1() {};
			Empty.prototype = target.prototype;
			bound.prototype = new Empty();
			Empty.prototype = null;
		}
		return bound;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js
var require_function_bind = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js": ((exports, module) => {
	var implementation$1 = require_implementation();
	module.exports = Function.prototype.bind || implementation$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js": ((exports, module) => {
	/** @type {import('./functionCall')} */
	module.exports = Function.prototype.call;
}) });

//#endregion
//#region ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js": ((exports, module) => {
	/** @type {import('./functionApply')} */
	module.exports = Function.prototype.apply;
}) });

//#endregion
//#region ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js": ((exports, module) => {
	/** @type {import('./reflectApply')} */
	module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
}) });

//#endregion
//#region ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js": ((exports, module) => {
	var bind$4 = require_function_bind();
	var $apply$1 = require_functionApply();
	var $call$2 = require_functionCall();
	var $reflectApply = require_reflectApply();
	/** @type {import('./actualApply')} */
	module.exports = $reflectApply || bind$4.call($call$2, $apply$1);
}) });

//#endregion
//#region ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js": ((exports, module) => {
	var bind$3 = require_function_bind();
	var $TypeError$2 = require_type();
	var $call$1 = require_functionCall();
	var $actualApply = require_actualApply();
	/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
	module.exports = function callBindBasic(args) {
		if (args.length < 1 || typeof args[0] !== "function") throw new $TypeError$2("a function is required");
		return $actualApply(bind$3, $call$1, args);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js
var require_get = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js": ((exports, module) => {
	var callBind = require_call_bind_apply_helpers();
	var gOPD$1 = require_gopd();
	var hasProtoAccessor;
	try {
		hasProtoAccessor = [].__proto__ === Array.prototype;
	} catch (e) {
		if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") throw e;
	}
	var desc = !!hasProtoAccessor && gOPD$1 && gOPD$1(Object.prototype, "__proto__");
	var $Object$1 = Object;
	var $getPrototypeOf = $Object$1.getPrototypeOf;
	/** @type {import('./get')} */
	module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? function getDunder(value) {
		return $getPrototypeOf(value == null ? value : $Object$1(value));
	} : false;
}) });

//#endregion
//#region ../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js
var require_get_proto = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js": ((exports, module) => {
	var reflectGetProto = require_Reflect_getPrototypeOf();
	var originalGetProto = require_Object_getPrototypeOf();
	var getDunderProto = require_get();
	/** @type {import('.')} */
	module.exports = reflectGetProto ? function getProto$2(O) {
		return reflectGetProto(O);
	} : originalGetProto ? function getProto$2(O) {
		if (!O || typeof O !== "object" && typeof O !== "function") throw new TypeError("getProto: not an object");
		return originalGetProto(O);
	} : getDunderProto ? function getProto$2(O) {
		return getDunderProto(O);
	} : null;
}) });

//#endregion
//#region ../../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js
var require_hasown = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js": ((exports, module) => {
	var call = Function.prototype.call;
	var $hasOwn = Object.prototype.hasOwnProperty;
	var bind$2 = require_function_bind();
	/** @type {import('.')} */
	module.exports = bind$2.call(call, $hasOwn);
}) });

//#endregion
//#region ../../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js
var require_get_intrinsic = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js": ((exports, module) => {
	var undefined$1;
	var $Object = require_es_object_atoms();
	var $Error = require_es_errors();
	var $EvalError = require_eval$1();
	var $RangeError = require_range();
	var $ReferenceError = require_ref();
	var $SyntaxError = require_syntax();
	var $TypeError$1 = require_type();
	var $URIError = require_uri();
	var abs$1 = require_abs();
	var floor$1 = require_floor();
	var max$1 = require_max();
	var min$1 = require_min();
	var pow$1 = require_pow();
	var round$1 = require_round();
	var sign$1 = require_sign();
	var $Function = Function;
	var getEvalledConstructor = function(expressionSyntax) {
		try {
			return $Function("\"use strict\"; return (" + expressionSyntax + ").constructor;")();
		} catch (e) {}
	};
	var $gOPD = require_gopd();
	var $defineProperty$1 = require_es_define_property();
	var throwTypeError = function() {
		throw new $TypeError$1();
	};
	var ThrowTypeError = $gOPD ? function() {
		try {
			arguments.callee;
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				return $gOPD(arguments, "callee").get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}() : throwTypeError;
	var hasSymbols$2 = require_has_symbols()();
	var getProto$1 = require_get_proto();
	var $ObjectGPO = require_Object_getPrototypeOf();
	var $ReflectGPO = require_Reflect_getPrototypeOf();
	var $apply = require_functionApply();
	var $call = require_functionCall();
	var needsEval = {};
	var TypedArray = typeof Uint8Array === "undefined" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array);
	var INTRINSICS = {
		__proto__: null,
		"%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
		"%Array%": Array,
		"%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
		"%ArrayIteratorPrototype%": hasSymbols$2 && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
		"%AsyncFromSyncIteratorPrototype%": undefined$1,
		"%AsyncFunction%": needsEval,
		"%AsyncGenerator%": needsEval,
		"%AsyncGeneratorFunction%": needsEval,
		"%AsyncIteratorPrototype%": needsEval,
		"%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
		"%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
		"%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
		"%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
		"%Boolean%": Boolean,
		"%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
		"%Date%": Date,
		"%decodeURI%": decodeURI,
		"%decodeURIComponent%": decodeURIComponent,
		"%encodeURI%": encodeURI,
		"%encodeURIComponent%": encodeURIComponent,
		"%Error%": $Error,
		"%eval%": eval,
		"%EvalError%": $EvalError,
		"%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
		"%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
		"%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
		"%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
		"%Function%": $Function,
		"%GeneratorFunction%": needsEval,
		"%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
		"%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
		"%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
		"%isFinite%": isFinite,
		"%isNaN%": isNaN,
		"%IteratorPrototype%": hasSymbols$2 && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
		"%JSON%": typeof JSON === "object" ? JSON : undefined$1,
		"%Map%": typeof Map === "undefined" ? undefined$1 : Map,
		"%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$2 || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
		"%Math%": Math,
		"%Number%": Number,
		"%Object%": $Object,
		"%Object.getOwnPropertyDescriptor%": $gOPD,
		"%parseFloat%": parseFloat,
		"%parseInt%": parseInt,
		"%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
		"%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
		"%RangeError%": $RangeError,
		"%ReferenceError%": $ReferenceError,
		"%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
		"%RegExp%": RegExp,
		"%Set%": typeof Set === "undefined" ? undefined$1 : Set,
		"%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$2 || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
		"%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
		"%String%": String,
		"%StringIteratorPrototype%": hasSymbols$2 && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
		"%Symbol%": hasSymbols$2 ? Symbol : undefined$1,
		"%SyntaxError%": $SyntaxError,
		"%ThrowTypeError%": ThrowTypeError,
		"%TypedArray%": TypedArray,
		"%TypeError%": $TypeError$1,
		"%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
		"%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
		"%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
		"%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
		"%URIError%": $URIError,
		"%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
		"%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
		"%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
		"%Function.prototype.call%": $call,
		"%Function.prototype.apply%": $apply,
		"%Object.defineProperty%": $defineProperty$1,
		"%Object.getPrototypeOf%": $ObjectGPO,
		"%Math.abs%": abs$1,
		"%Math.floor%": floor$1,
		"%Math.max%": max$1,
		"%Math.min%": min$1,
		"%Math.pow%": pow$1,
		"%Math.round%": round$1,
		"%Math.sign%": sign$1,
		"%Reflect.getPrototypeOf%": $ReflectGPO
	};
	if (getProto$1) try {
		null.error;
	} catch (e) {
		INTRINSICS["%Error.prototype%"] = getProto$1(getProto$1(e));
	}
	var doEval = function doEval$1(name) {
		var value;
		if (name === "%AsyncFunction%") value = getEvalledConstructor("async function () {}");
		else if (name === "%GeneratorFunction%") value = getEvalledConstructor("function* () {}");
		else if (name === "%AsyncGeneratorFunction%") value = getEvalledConstructor("async function* () {}");
		else if (name === "%AsyncGenerator%") {
			var fn = doEval$1("%AsyncGeneratorFunction%");
			if (fn) value = fn.prototype;
		} else if (name === "%AsyncIteratorPrototype%") {
			var gen = doEval$1("%AsyncGenerator%");
			if (gen && getProto$1) value = getProto$1(gen.prototype);
		}
		INTRINSICS[name] = value;
		return value;
	};
	var LEGACY_ALIASES = {
		__proto__: null,
		"%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
		"%ArrayPrototype%": ["Array", "prototype"],
		"%ArrayProto_entries%": [
			"Array",
			"prototype",
			"entries"
		],
		"%ArrayProto_forEach%": [
			"Array",
			"prototype",
			"forEach"
		],
		"%ArrayProto_keys%": [
			"Array",
			"prototype",
			"keys"
		],
		"%ArrayProto_values%": [
			"Array",
			"prototype",
			"values"
		],
		"%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
		"%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
		"%AsyncGeneratorPrototype%": [
			"AsyncGeneratorFunction",
			"prototype",
			"prototype"
		],
		"%BooleanPrototype%": ["Boolean", "prototype"],
		"%DataViewPrototype%": ["DataView", "prototype"],
		"%DatePrototype%": ["Date", "prototype"],
		"%ErrorPrototype%": ["Error", "prototype"],
		"%EvalErrorPrototype%": ["EvalError", "prototype"],
		"%Float32ArrayPrototype%": ["Float32Array", "prototype"],
		"%Float64ArrayPrototype%": ["Float64Array", "prototype"],
		"%FunctionPrototype%": ["Function", "prototype"],
		"%Generator%": ["GeneratorFunction", "prototype"],
		"%GeneratorPrototype%": [
			"GeneratorFunction",
			"prototype",
			"prototype"
		],
		"%Int8ArrayPrototype%": ["Int8Array", "prototype"],
		"%Int16ArrayPrototype%": ["Int16Array", "prototype"],
		"%Int32ArrayPrototype%": ["Int32Array", "prototype"],
		"%JSONParse%": ["JSON", "parse"],
		"%JSONStringify%": ["JSON", "stringify"],
		"%MapPrototype%": ["Map", "prototype"],
		"%NumberPrototype%": ["Number", "prototype"],
		"%ObjectPrototype%": ["Object", "prototype"],
		"%ObjProto_toString%": [
			"Object",
			"prototype",
			"toString"
		],
		"%ObjProto_valueOf%": [
			"Object",
			"prototype",
			"valueOf"
		],
		"%PromisePrototype%": ["Promise", "prototype"],
		"%PromiseProto_then%": [
			"Promise",
			"prototype",
			"then"
		],
		"%Promise_all%": ["Promise", "all"],
		"%Promise_reject%": ["Promise", "reject"],
		"%Promise_resolve%": ["Promise", "resolve"],
		"%RangeErrorPrototype%": ["RangeError", "prototype"],
		"%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
		"%RegExpPrototype%": ["RegExp", "prototype"],
		"%SetPrototype%": ["Set", "prototype"],
		"%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
		"%StringPrototype%": ["String", "prototype"],
		"%SymbolPrototype%": ["Symbol", "prototype"],
		"%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
		"%TypedArrayPrototype%": ["TypedArray", "prototype"],
		"%TypeErrorPrototype%": ["TypeError", "prototype"],
		"%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
		"%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
		"%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
		"%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
		"%URIErrorPrototype%": ["URIError", "prototype"],
		"%WeakMapPrototype%": ["WeakMap", "prototype"],
		"%WeakSetPrototype%": ["WeakSet", "prototype"]
	};
	var bind$1 = require_function_bind();
	var hasOwn$2 = require_hasown();
	var $concat = bind$1.call($call, Array.prototype.concat);
	var $spliceApply = bind$1.call($apply, Array.prototype.splice);
	var $replace = bind$1.call($call, String.prototype.replace);
	var $strSlice = bind$1.call($call, String.prototype.slice);
	var $exec = bind$1.call($call, RegExp.prototype.exec);
	var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
	var reEscapeChar = /\\(\\)?/g;
	var stringToPath = function stringToPath$1(string$2) {
		var first = $strSlice(string$2, 0, 1);
		var last = $strSlice(string$2, -1);
		if (first === "%" && last !== "%") throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
		else if (last === "%" && first !== "%") throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
		var result = [];
		$replace(string$2, rePropName, function(match, number$3, quote, subString) {
			result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number$3 || match;
		});
		return result;
	};
	var getBaseIntrinsic = function getBaseIntrinsic$1(name, allowMissing) {
		var intrinsicName = name;
		var alias;
		if (hasOwn$2(LEGACY_ALIASES, intrinsicName)) {
			alias = LEGACY_ALIASES[intrinsicName];
			intrinsicName = "%" + alias[0] + "%";
		}
		if (hasOwn$2(INTRINSICS, intrinsicName)) {
			var value = INTRINSICS[intrinsicName];
			if (value === needsEval) value = doEval(intrinsicName);
			if (typeof value === "undefined" && !allowMissing) throw new $TypeError$1("intrinsic " + name + " exists, but is not available. Please file an issue!");
			return {
				alias,
				name: intrinsicName,
				value
			};
		}
		throw new $SyntaxError("intrinsic " + name + " does not exist!");
	};
	module.exports = function GetIntrinsic(name, allowMissing) {
		if (typeof name !== "string" || name.length === 0) throw new $TypeError$1("intrinsic name must be a non-empty string");
		if (arguments.length > 1 && typeof allowMissing !== "boolean") throw new $TypeError$1("\"allowMissing\" argument must be a boolean");
		if ($exec(/^%?[^%]*%?$/, name) === null) throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
		var parts = stringToPath(name);
		var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
		var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
		var intrinsicRealName = intrinsic.name;
		var value = intrinsic.value;
		var skipFurtherCaching = false;
		var alias = intrinsic.alias;
		if (alias) {
			intrinsicBaseName = alias[0];
			$spliceApply(parts, $concat([0, 1], alias));
		}
		for (var i = 1, isOwn = true; i < parts.length; i += 1) {
			var part = parts[i];
			var first = $strSlice(part, 0, 1);
			var last = $strSlice(part, -1);
			if ((first === "\"" || first === "'" || first === "`" || last === "\"" || last === "'" || last === "`") && first !== last) throw new $SyntaxError("property names with quotes must have matching quotes");
			if (part === "constructor" || !isOwn) skipFurtherCaching = true;
			intrinsicBaseName += "." + part;
			intrinsicRealName = "%" + intrinsicBaseName + "%";
			if (hasOwn$2(INTRINSICS, intrinsicRealName)) value = INTRINSICS[intrinsicRealName];
			else if (value != null) {
				if (!(part in value)) {
					if (!allowMissing) throw new $TypeError$1("base intrinsic for " + name + " exists, but the property is not available.");
					return;
				}
				if ($gOPD && i + 1 >= parts.length) {
					var desc$1 = $gOPD(value, part);
					isOwn = !!desc$1;
					if (isOwn && "get" in desc$1 && !("originalValue" in desc$1.get)) value = desc$1.get;
					else value = value[part];
				} else {
					isOwn = hasOwn$2(value, part);
					value = value[part];
				}
				if (isOwn && !skipFurtherCaching) INTRINSICS[intrinsicRealName] = value;
			}
		}
		return value;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js
var require_shams = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js": ((exports, module) => {
	var hasSymbols$1 = require_shams$1();
	/** @type {import('.')} */
	module.exports = function hasToStringTagShams() {
		return hasSymbols$1() && !!Symbol.toStringTag;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/es-set-tostringtag@2.1.0/node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/es-set-tostringtag@2.1.0/node_modules/es-set-tostringtag/index.js": ((exports, module) => {
	var $defineProperty = require_get_intrinsic()("%Object.defineProperty%", true);
	var hasToStringTag = require_shams()();
	var hasOwn$1 = require_hasown();
	var $TypeError = require_type();
	var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
	/** @type {import('.')} */
	module.exports = function setToStringTag$1(object$1, value) {
		var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
		var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
		if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
		if (toStringTag && (overrideIfSet || !hasOwn$1(object$1, toStringTag))) if ($defineProperty) $defineProperty(object$1, toStringTag, {
			configurable: !nonConfigurable,
			enumerable: false,
			value,
			writable: false
		});
		else object$1[toStringTag] = value;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/form-data@4.0.4/node_modules/form-data/lib/populate.js
var require_populate = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/form-data@4.0.4/node_modules/form-data/lib/populate.js": ((exports, module) => {
	module.exports = function(dst, src) {
		Object.keys(src).forEach(function(prop) {
			dst[prop] = dst[prop] || src[prop];
		});
		return dst;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/form-data@4.0.4/node_modules/form-data/lib/form_data.js
var require_form_data = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/form-data@4.0.4/node_modules/form-data/lib/form_data.js": ((exports, module) => {
	var CombinedStream = require_combined_stream();
	var util$1 = __require("util");
	var path$2 = __require("path");
	var http$2 = __require("http");
	var https$2 = __require("https");
	var parseUrl$2 = __require("url").parse;
	var fs$2 = __require("fs");
	var Stream = __require("stream").Stream;
	var crypto$1 = __require("crypto");
	var mime = require_mime_types();
	var asynckit = require_asynckit();
	var setToStringTag = require_es_set_tostringtag();
	var hasOwn = require_hasown();
	var populate = require_populate();
	/**
	* Create readable "multipart/form-data" streams.
	* Can be used to submit forms
	* and file uploads to other web applications.
	*
	* @constructor
	* @param {object} options - Properties to be added/overriden for FormData and CombinedStream
	*/
	function FormData$2(options) {
		if (!(this instanceof FormData$2)) return new FormData$2(options);
		this._overheadLength = 0;
		this._valueLength = 0;
		this._valuesToMeasure = [];
		CombinedStream.call(this);
		options = options || {};
		for (var option in options) this[option] = options[option];
	}
	util$1.inherits(FormData$2, CombinedStream);
	FormData$2.LINE_BREAK = "\r\n";
	FormData$2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
	FormData$2.prototype.append = function(field, value, options) {
		options = options || {};
		if (typeof options === "string") options = { filename: options };
		var append = CombinedStream.prototype.append.bind(this);
		if (typeof value === "number" || value == null) value = String(value);
		if (Array.isArray(value)) {
			this._error(/* @__PURE__ */ new Error("Arrays are not supported."));
			return;
		}
		var header = this._multiPartHeader(field, value, options);
		var footer = this._multiPartFooter();
		append(header);
		append(value);
		append(footer);
		this._trackLength(header, value, options);
	};
	FormData$2.prototype._trackLength = function(header, value, options) {
		var valueLength = 0;
		if (options.knownLength != null) valueLength += Number(options.knownLength);
		else if (Buffer.isBuffer(value)) valueLength = value.length;
		else if (typeof value === "string") valueLength = Buffer.byteLength(value);
		this._valueLength += valueLength;
		this._overheadLength += Buffer.byteLength(header) + FormData$2.LINE_BREAK.length;
		if (!value || !value.path && !(value.readable && hasOwn(value, "httpVersion")) && !(value instanceof Stream)) return;
		if (!options.knownLength) this._valuesToMeasure.push(value);
	};
	FormData$2.prototype._lengthRetriever = function(value, callback) {
		if (hasOwn(value, "fd")) if (value.end != void 0 && value.end != Infinity && value.start != void 0) callback(null, value.end + 1 - (value.start ? value.start : 0));
		else fs$2.stat(value.path, function(err, stat$1) {
			if (err) {
				callback(err);
				return;
			}
			callback(null, stat$1.size - (value.start ? value.start : 0));
		});
		else if (hasOwn(value, "httpVersion")) callback(null, Number(value.headers["content-length"]));
		else if (hasOwn(value, "httpModule")) {
			value.on("response", function(response$2) {
				value.pause();
				callback(null, Number(response$2.headers["content-length"]));
			});
			value.resume();
		} else callback("Unknown stream");
	};
	FormData$2.prototype._multiPartHeader = function(field, value, options) {
		if (typeof options.header === "string") return options.header;
		var contentDisposition$1 = this._getContentDisposition(value, options);
		var contentType$2 = this._getContentType(value, options);
		var contents = "";
		var headers = {
			"Content-Disposition": ["form-data", "name=\"" + field + "\""].concat(contentDisposition$1 || []),
			"Content-Type": [].concat(contentType$2 || [])
		};
		if (typeof options.header === "object") populate(headers, options.header);
		var header;
		for (var prop in headers) if (hasOwn(headers, prop)) {
			header = headers[prop];
			if (header == null) continue;
			if (!Array.isArray(header)) header = [header];
			if (header.length) contents += prop + ": " + header.join("; ") + FormData$2.LINE_BREAK;
		}
		return "--" + this.getBoundary() + FormData$2.LINE_BREAK + contents + FormData$2.LINE_BREAK;
	};
	FormData$2.prototype._getContentDisposition = function(value, options) {
		var filename;
		if (typeof options.filepath === "string") filename = path$2.normalize(options.filepath).replace(/\\/g, "/");
		else if (options.filename || value && (value.name || value.path)) filename = path$2.basename(options.filename || value && (value.name || value.path));
		else if (value && value.readable && hasOwn(value, "httpVersion")) filename = path$2.basename(value.client._httpMessage.path || "");
		if (filename) return "filename=\"" + filename + "\"";
	};
	FormData$2.prototype._getContentType = function(value, options) {
		var contentType$2 = options.contentType;
		if (!contentType$2 && value && value.name) contentType$2 = mime.lookup(value.name);
		if (!contentType$2 && value && value.path) contentType$2 = mime.lookup(value.path);
		if (!contentType$2 && value && value.readable && hasOwn(value, "httpVersion")) contentType$2 = value.headers["content-type"];
		if (!contentType$2 && (options.filepath || options.filename)) contentType$2 = mime.lookup(options.filepath || options.filename);
		if (!contentType$2 && value && typeof value === "object") contentType$2 = FormData$2.DEFAULT_CONTENT_TYPE;
		return contentType$2;
	};
	FormData$2.prototype._multiPartFooter = function() {
		return function(next) {
			var footer = FormData$2.LINE_BREAK;
			if (this._streams.length === 0) footer += this._lastBoundary();
			next(footer);
		}.bind(this);
	};
	FormData$2.prototype._lastBoundary = function() {
		return "--" + this.getBoundary() + "--" + FormData$2.LINE_BREAK;
	};
	FormData$2.prototype.getHeaders = function(userHeaders) {
		var header;
		var formHeaders = { "content-type": "multipart/form-data; boundary=" + this.getBoundary() };
		for (header in userHeaders) if (hasOwn(userHeaders, header)) formHeaders[header.toLowerCase()] = userHeaders[header];
		return formHeaders;
	};
	FormData$2.prototype.setBoundary = function(boundary) {
		if (typeof boundary !== "string") throw new TypeError("FormData boundary must be a string");
		this._boundary = boundary;
	};
	FormData$2.prototype.getBoundary = function() {
		if (!this._boundary) this._generateBoundary();
		return this._boundary;
	};
	FormData$2.prototype.getBuffer = function() {
		var dataBuffer = new Buffer.alloc(0);
		var boundary = this.getBoundary();
		for (var i = 0, len = this._streams.length; i < len; i++) if (typeof this._streams[i] !== "function") {
			if (Buffer.isBuffer(this._streams[i])) dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
			else dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
			if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData$2.LINE_BREAK)]);
		}
		return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
	};
	FormData$2.prototype._generateBoundary = function() {
		this._boundary = "--------------------------" + crypto$1.randomBytes(12).toString("hex");
	};
	FormData$2.prototype.getLengthSync = function() {
		var knownLength = this._overheadLength + this._valueLength;
		if (this._streams.length) knownLength += this._lastBoundary().length;
		if (!this.hasKnownLength()) this._error(/* @__PURE__ */ new Error("Cannot calculate proper length in synchronous way."));
		return knownLength;
	};
	FormData$2.prototype.hasKnownLength = function() {
		var hasKnownLength = true;
		if (this._valuesToMeasure.length) hasKnownLength = false;
		return hasKnownLength;
	};
	FormData$2.prototype.getLength = function(cb) {
		var knownLength = this._overheadLength + this._valueLength;
		if (this._streams.length) knownLength += this._lastBoundary().length;
		if (!this._valuesToMeasure.length) {
			process.nextTick(cb.bind(this, null, knownLength));
			return;
		}
		asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
			if (err) {
				cb(err);
				return;
			}
			values.forEach(function(length) {
				knownLength += length;
			});
			cb(null, knownLength);
		});
	};
	FormData$2.prototype.submit = function(params, cb) {
		var request$2;
		var options;
		var defaults$1 = { method: "post" };
		if (typeof params === "string") {
			params = parseUrl$2(params);
			options = populate({
				port: params.port,
				path: params.pathname,
				host: params.hostname,
				protocol: params.protocol
			}, defaults$1);
		} else {
			options = populate(params, defaults$1);
			if (!options.port) options.port = options.protocol === "https:" ? 443 : 80;
		}
		options.headers = this.getHeaders(params.headers);
		if (options.protocol === "https:") request$2 = https$2.request(options);
		else request$2 = http$2.request(options);
		this.getLength(function(err, length) {
			if (err && err !== "Unknown stream") {
				this._error(err);
				return;
			}
			if (length) request$2.setHeader("Content-Length", length);
			this.pipe(request$2);
			if (cb) {
				var onResponse;
				var callback = function(error, responce) {
					request$2.removeListener("error", callback);
					request$2.removeListener("response", onResponse);
					return cb.call(this, error, responce);
				};
				onResponse = callback.bind(this, null);
				request$2.on("error", callback);
				request$2.on("response", onResponse);
			}
		}.bind(this));
		return request$2;
	};
	FormData$2.prototype._error = function(err) {
		if (!this.error) {
			this.error = err;
			this.pause();
			this.emit("error", err);
		}
	};
	FormData$2.prototype.toString = function() {
		return "[object FormData]";
	};
	setToStringTag(FormData$2, "FormData");
	module.exports = FormData$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/platform/node/classes/FormData.js
var import_form_data = /* @__PURE__ */ __toESM(require_form_data(), 1);
var FormData_default = import_form_data.default;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/toFormData.js
/**
* Determines if the given thing is a array or js object.
*
* @param {string} thing - The object or array to be visited.
*
* @returns {boolean}
*/
function isVisitable(thing) {
	return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
/**
* It removes the brackets from the end of a string
*
* @param {string} key - The key of the parameter.
*
* @returns {string} the key without the brackets.
*/
function removeBrackets(key) {
	return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
/**
* It takes a path, a key, and a boolean, and returns a string
*
* @param {string} path - The path to the current key.
* @param {string} key - The key of the current object being iterated over.
* @param {string} dots - If true, the key will be rendered with dots instead of brackets.
*
* @returns {string} The path to the current key.
*/
function renderKey(path$3, key, dots) {
	if (!path$3) return key;
	return path$3.concat(key).map(function each(token, i) {
		token = removeBrackets(token);
		return !dots && i ? "[" + token + "]" : token;
	}).join(dots ? "." : "");
}
/**
* If the array is an array and none of its elements are visitable, then it's a flat array.
*
* @param {Array<any>} arr - The array to check
*
* @returns {boolean}
*/
function isFlatArray(arr) {
	return utils_default.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
	return /^is[A-Z]/.test(prop);
});
/**
* Convert a data object to FormData
*
* @param {Object} obj
* @param {?Object} [formData]
* @param {?Object} [options]
* @param {Function} [options.visitor]
* @param {Boolean} [options.metaTokens = true]
* @param {Boolean} [options.dots = false]
* @param {?Boolean} [options.indexes = false]
*
* @returns {Object}
**/
/**
* It converts an object into a FormData object
*
* @param {Object<any, any>} obj - The object to convert to form data.
* @param {string} formData - The FormData object to append to.
* @param {Object<string, any>} options
*
* @returns
*/
function toFormData$1(obj, formData, options) {
	if (!utils_default.isObject(obj)) throw new TypeError("target must be an object");
	formData = formData || new (FormData_default || FormData)();
	options = utils_default.toFlatObject(options, {
		metaTokens: true,
		dots: false,
		indexes: false
	}, false, function defined(option, source) {
		return !utils_default.isUndefined(source[option]);
	});
	const metaTokens = options.metaTokens;
	const visitor = options.visitor || defaultVisitor;
	const dots = options.dots;
	const indexes = options.indexes;
	const useBlob = (options.Blob || typeof Blob !== "undefined" && Blob) && utils_default.isSpecCompliantForm(formData);
	if (!utils_default.isFunction(visitor)) throw new TypeError("visitor must be a function");
	function convertValue(value) {
		if (value === null) return "";
		if (utils_default.isDate(value)) return value.toISOString();
		if (utils_default.isBoolean(value)) return value.toString();
		if (!useBlob && utils_default.isBlob(value)) throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
		if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
		return value;
	}
	/**
	* Default visitor.
	*
	* @param {*} value
	* @param {String|Number} key
	* @param {Array<String|Number>} path
	* @this {FormData}
	*
	* @returns {boolean} return true to visit the each prop of the value recursively
	*/
	function defaultVisitor(value, key, path$3) {
		let arr = value;
		if (value && !path$3 && typeof value === "object") {
			if (utils_default.endsWith(key, "{}")) {
				key = metaTokens ? key : key.slice(0, -2);
				value = JSON.stringify(value);
			} else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
				key = removeBrackets(key);
				arr.forEach(function each(el, index$1) {
					!(utils_default.isUndefined(el) || el === null) && formData.append(indexes === true ? renderKey([key], index$1, dots) : indexes === null ? key : key + "[]", convertValue(el));
				});
				return false;
			}
		}
		if (isVisitable(value)) return true;
		formData.append(renderKey(path$3, key, dots), convertValue(value));
		return false;
	}
	const stack = [];
	const exposedHelpers = Object.assign(predicates, {
		defaultVisitor,
		convertValue,
		isVisitable
	});
	function build(value, path$3) {
		if (utils_default.isUndefined(value)) return;
		if (stack.indexOf(value) !== -1) throw Error("Circular reference detected in " + path$3.join("."));
		stack.push(value);
		utils_default.forEach(value, function each(el, key) {
			if ((!(utils_default.isUndefined(el) || el === null) && visitor.call(formData, el, utils_default.isString(key) ? key.trim() : key, path$3, exposedHelpers)) === true) build(el, path$3 ? path$3.concat(key) : [key]);
		});
		stack.pop();
	}
	if (!utils_default.isObject(obj)) throw new TypeError("data must be an object");
	build(obj);
	return formData;
}
var toFormData_default = toFormData$1;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/AxiosURLSearchParams.js
/**
* It encodes a string by replacing all characters that are not in the unreserved set with
* their percent-encoded equivalents
*
* @param {string} str - The string to encode.
*
* @returns {string} The encoded string.
*/
function encode$3(str) {
	const charMap = {
		"!": "%21",
		"'": "%27",
		"(": "%28",
		")": "%29",
		"~": "%7E",
		"%20": "+",
		"%00": "\0"
	};
	return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
		return charMap[match];
	});
}
/**
* It takes a params object and converts it to a FormData object
*
* @param {Object<string, any>} params - The parameters to be converted to a FormData object.
* @param {Object<string, any>} options - The options object passed to the Axios constructor.
*
* @returns {void}
*/
function AxiosURLSearchParams(params, options) {
	this._pairs = [];
	params && toFormData_default(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
	this._pairs.push([name, value]);
};
prototype.toString = function toString$1(encoder) {
	const _encode$1 = encoder ? function(value) {
		return encoder.call(this, value, encode$3);
	} : encode$3;
	return this._pairs.map(function each(pair) {
		return _encode$1(pair[0]) + "=" + _encode$1(pair[1]);
	}, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/buildURL.js
/**
* It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
* URI encoded counterparts
*
* @param {string} val The value to be encoded.
*
* @returns {string} The encoded value.
*/
function encode$2(val) {
	return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
/**
* Build a URL by appending params to the end
*
* @param {string} url The base of the url (e.g., http://www.google.com)
* @param {object} [params] The params to be appended
* @param {?(object|Function)} options
*
* @returns {string} The formatted url
*/
function buildURL(url$1, params, options) {
	if (!params) return url$1;
	const _encode$1 = options && options.encode || encode$2;
	if (utils_default.isFunction(options)) options = { serialize: options };
	const serializeFn = options && options.serialize;
	let serializedParams;
	if (serializeFn) serializedParams = serializeFn(params, options);
	else serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode$1);
	if (serializedParams) {
		const hashmarkIndex = url$1.indexOf("#");
		if (hashmarkIndex !== -1) url$1 = url$1.slice(0, hashmarkIndex);
		url$1 += (url$1.indexOf("?") === -1 ? "?" : "&") + serializedParams;
	}
	return url$1;
}

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
	constructor() {
		this.handlers = [];
	}
	/**
	* Add a new interceptor to the stack
	*
	* @param {Function} fulfilled The function to handle `then` for a `Promise`
	* @param {Function} rejected The function to handle `reject` for a `Promise`
	*
	* @return {Number} An ID used to remove interceptor later
	*/
	use(fulfilled, rejected, options) {
		this.handlers.push({
			fulfilled,
			rejected,
			synchronous: options ? options.synchronous : false,
			runWhen: options ? options.runWhen : null
		});
		return this.handlers.length - 1;
	}
	/**
	* Remove an interceptor from the stack
	*
	* @param {Number} id The ID that was returned by `use`
	*
	* @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
	*/
	eject(id) {
		if (this.handlers[id]) this.handlers[id] = null;
	}
	/**
	* Clear all interceptors from the stack
	*
	* @returns {void}
	*/
	clear() {
		if (this.handlers) this.handlers = [];
	}
	/**
	* Iterate over all the registered interceptors
	*
	* This method is particularly useful for skipping over any
	* interceptors that may have become `null` calling `eject`.
	*
	* @param {Function} fn The function to call for each interceptor
	*
	* @returns {void}
	*/
	forEach(fn) {
		utils_default.forEach(this.handlers, function forEachHandler(h$1) {
			if (h$1 !== null) fn(h$1);
		});
	}
};
var InterceptorManager_default = InterceptorManager;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
	silentJSONParsing: true,
	forcedJSONParsing: true,
	clarifyTimeoutError: false
};

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/platform/node/classes/URLSearchParams.js
var URLSearchParams_default = URL2.URLSearchParams;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/platform/node/index.js
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
	DIGIT,
	ALPHA,
	ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
	let str = "";
	const { length } = alphabet;
	const randomValues = new Uint32Array(size);
	crypto.randomFillSync(randomValues);
	for (let i = 0; i < size; i++) str += alphabet[randomValues[i] % length];
	return str;
};
var node_default = {
	isNode: true,
	classes: {
		URLSearchParams: URLSearchParams_default,
		FormData: FormData_default,
		Blob: typeof Blob !== "undefined" && Blob || null
	},
	ALPHABET,
	generateString,
	protocols: [
		"http",
		"https",
		"file",
		"data"
	]
};

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/platform/common/utils.js
var utils_exports = /* @__PURE__ */ __export({
	hasBrowserEnv: () => hasBrowserEnv,
	hasStandardBrowserEnv: () => hasStandardBrowserEnv,
	hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
	navigator: () => _navigator,
	origin: () => origin
});
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const _navigator = typeof navigator === "object" && navigator || void 0;
/**
* Determine if we're running in a standard browser environment
*
* This allows axios to run in a web worker, and react-native.
* Both environments support XMLHttpRequest, but not fully standard globals.
*
* web workers:
*  typeof window -> undefined
*  typeof document -> undefined
*
* react-native:
*  navigator.product -> 'ReactNative'
* nativescript
*  navigator.product -> 'NativeScript' or 'NS'
*
* @returns {boolean}
*/
const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || [
	"ReactNative",
	"NativeScript",
	"NS"
].indexOf(_navigator.product) < 0);
/**
* Determine if we're running in a standard browser webWorker environment
*
* Although the `isStandardBrowserEnv` method indicates that
* `allows axios to run in a web worker`, the WebWorker will still be
* filtered out due to its judgment standard
* `typeof window !== 'undefined' && typeof document !== 'undefined'`.
* This leads to a problem when axios post `FormData` in webWorker
*/
const hasStandardBrowserWebWorkerEnv = (() => {
	return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/platform/index.js
var platform_default = {
	...utils_exports,
	...node_default
};

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data$1, options) {
	return toFormData_default(data$1, new platform_default.classes.URLSearchParams(), {
		visitor: function(value, key, path$3, helpers) {
			if (platform_default.isNode && utils_default.isBuffer(value)) {
				this.append(key, value.toString("base64"));
				return false;
			}
			return helpers.defaultVisitor.apply(this, arguments);
		},
		...options
	});
}

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/formDataToJSON.js
/**
* It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
*
* @param {string} name - The name of the property to get.
*
* @returns An array of strings.
*/
function parsePropPath(name) {
	return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
		return match[0] === "[]" ? "" : match[1] || match[0];
	});
}
/**
* Convert an array to an object.
*
* @param {Array<any>} arr - The array to convert to an object.
*
* @returns An object with the same keys and values as the array.
*/
function arrayToObject(arr) {
	const obj = {};
	const keys = Object.keys(arr);
	let i;
	const len = keys.length;
	let key;
	for (i = 0; i < len; i++) {
		key = keys[i];
		obj[key] = arr[key];
	}
	return obj;
}
/**
* It takes a FormData object and returns a JavaScript object
*
* @param {string} formData The FormData object to convert to JSON.
*
* @returns {Object<string, any> | null} The converted object.
*/
function formDataToJSON(formData) {
	function buildPath(path$3, value, target, index$1) {
		let name = path$3[index$1++];
		if (name === "__proto__") return true;
		const isNumericKey = Number.isFinite(+name);
		const isLast = index$1 >= path$3.length;
		name = !name && utils_default.isArray(target) ? target.length : name;
		if (isLast) {
			if (utils_default.hasOwnProp(target, name)) target[name] = [target[name], value];
			else target[name] = value;
			return !isNumericKey;
		}
		if (!target[name] || !utils_default.isObject(target[name])) target[name] = [];
		if (buildPath(path$3, value, target[name], index$1) && utils_default.isArray(target[name])) target[name] = arrayToObject(target[name]);
		return !isNumericKey;
	}
	if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
		const obj = {};
		utils_default.forEachEntry(formData, (name, value) => {
			buildPath(parsePropPath(name), value, obj, 0);
		});
		return obj;
	}
	return null;
}
var formDataToJSON_default = formDataToJSON;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/defaults/index.js
/**
* It takes a string, tries to parse it, and if it fails, it returns the stringified version
* of the input
*
* @param {any} rawValue - The value to be stringified.
* @param {Function} parser - A function that parses a string into a JavaScript object.
* @param {Function} encoder - A function that takes a value and returns a string.
*
* @returns {string} A stringified version of the rawValue.
*/
function stringifySafely(rawValue, parser, encoder) {
	if (utils_default.isString(rawValue)) try {
		(parser || JSON.parse)(rawValue);
		return utils_default.trim(rawValue);
	} catch (e) {
		if (e.name !== "SyntaxError") throw e;
	}
	return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
	transitional: transitional_default,
	adapter: [
		"xhr",
		"http",
		"fetch"
	],
	transformRequest: [function transformRequest(data$1, headers) {
		const contentType$2 = headers.getContentType() || "";
		const hasJSONContentType = contentType$2.indexOf("application/json") > -1;
		const isObjectPayload = utils_default.isObject(data$1);
		if (isObjectPayload && utils_default.isHTMLForm(data$1)) data$1 = new FormData(data$1);
		if (utils_default.isFormData(data$1)) return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data$1)) : data$1;
		if (utils_default.isArrayBuffer(data$1) || utils_default.isBuffer(data$1) || utils_default.isStream(data$1) || utils_default.isFile(data$1) || utils_default.isBlob(data$1) || utils_default.isReadableStream(data$1)) return data$1;
		if (utils_default.isArrayBufferView(data$1)) return data$1.buffer;
		if (utils_default.isURLSearchParams(data$1)) {
			headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
			return data$1.toString();
		}
		let isFileList$1;
		if (isObjectPayload) {
			if (contentType$2.indexOf("application/x-www-form-urlencoded") > -1) return toURLEncodedForm(data$1, this.formSerializer).toString();
			if ((isFileList$1 = utils_default.isFileList(data$1)) || contentType$2.indexOf("multipart/form-data") > -1) {
				const _FormData = this.env && this.env.FormData;
				return toFormData_default(isFileList$1 ? { "files[]": data$1 } : data$1, _FormData && new _FormData(), this.formSerializer);
			}
		}
		if (isObjectPayload || hasJSONContentType) {
			headers.setContentType("application/json", false);
			return stringifySafely(data$1);
		}
		return data$1;
	}],
	transformResponse: [function transformResponse(data$1) {
		const transitional = this.transitional || defaults.transitional;
		const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
		const JSONRequested = this.responseType === "json";
		if (utils_default.isResponse(data$1) || utils_default.isReadableStream(data$1)) return data$1;
		if (data$1 && utils_default.isString(data$1) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
			const strictJSONParsing = !(transitional && transitional.silentJSONParsing) && JSONRequested;
			try {
				return JSON.parse(data$1, this.parseReviver);
			} catch (e) {
				if (strictJSONParsing) {
					if (e.name === "SyntaxError") throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
					throw e;
				}
			}
		}
		return data$1;
	}],
	timeout: 0,
	xsrfCookieName: "XSRF-TOKEN",
	xsrfHeaderName: "X-XSRF-TOKEN",
	maxContentLength: -1,
	maxBodyLength: -1,
	env: {
		FormData: platform_default.classes.FormData,
		Blob: platform_default.classes.Blob
	},
	validateStatus: function validateStatus(status) {
		return status >= 200 && status < 300;
	},
	headers: { common: {
		"Accept": "application/json, text/plain, */*",
		"Content-Type": void 0
	} }
};
utils_default.forEach([
	"delete",
	"get",
	"head",
	"post",
	"put",
	"patch"
], (method) => {
	defaults.headers[method] = {};
});
var defaults_default = defaults;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/parseHeaders.js
const ignoreDuplicateOf = utils_default.toObjectSet([
	"age",
	"authorization",
	"content-length",
	"content-type",
	"etag",
	"expires",
	"from",
	"host",
	"if-modified-since",
	"if-unmodified-since",
	"last-modified",
	"location",
	"max-forwards",
	"proxy-authorization",
	"referer",
	"retry-after",
	"user-agent"
]);
/**
* Parse headers into an object
*
* ```
* Date: Wed, 27 Aug 2014 08:58:49 GMT
* Content-Type: application/json
* Connection: keep-alive
* Transfer-Encoding: chunked
* ```
*
* @param {String} rawHeaders Headers needing to be parsed
*
* @returns {Object} Headers parsed into an object
*/
var parseHeaders_default = (rawHeaders) => {
	const parsed = {};
	let key;
	let val;
	let i;
	rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
		i = line.indexOf(":");
		key = line.substring(0, i).trim().toLowerCase();
		val = line.substring(i + 1).trim();
		if (!key || parsed[key] && ignoreDuplicateOf[key]) return;
		if (key === "set-cookie") if (parsed[key]) parsed[key].push(val);
		else parsed[key] = [val];
		else parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
	});
	return parsed;
};

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/core/AxiosHeaders.js
const $internals = Symbol("internals");
function normalizeHeader(header) {
	return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
	if (value === false || value == null) return value;
	return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
	const tokens = Object.create(null);
	const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
	let match;
	while (match = tokensRE.exec(str)) tokens[match[1]] = match[2];
	return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
	if (utils_default.isFunction(filter)) return filter.call(this, value, header);
	if (isHeaderNameFilter) value = header;
	if (!utils_default.isString(value)) return;
	if (utils_default.isString(filter)) return value.indexOf(filter) !== -1;
	if (utils_default.isRegExp(filter)) return filter.test(value);
}
function formatHeader(header) {
	return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w$1, char, str) => {
		return char.toUpperCase() + str;
	});
}
function buildAccessors(obj, header) {
	const accessorName = utils_default.toCamelCase(" " + header);
	[
		"get",
		"set",
		"has"
	].forEach((methodName) => {
		Object.defineProperty(obj, methodName + accessorName, {
			value: function(arg1, arg2, arg3) {
				return this[methodName].call(this, header, arg1, arg2, arg3);
			},
			configurable: true
		});
	});
}
var AxiosHeaders$1 = class {
	constructor(headers) {
		headers && this.set(headers);
	}
	set(header, valueOrRewrite, rewrite) {
		const self$1 = this;
		function setHeader(_value, _header, _rewrite) {
			const lHeader = normalizeHeader(_header);
			if (!lHeader) throw new Error("header name must be a non-empty string");
			const key = utils_default.findKey(self$1, lHeader);
			if (!key || self$1[key] === void 0 || _rewrite === true || _rewrite === void 0 && self$1[key] !== false) self$1[key || _header] = normalizeValue(_value);
		}
		const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
		if (utils_default.isPlainObject(header) || header instanceof this.constructor) setHeaders(header, valueOrRewrite);
		else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) setHeaders(parseHeaders_default(header), valueOrRewrite);
		else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
			let obj = {}, dest, key;
			for (const entry of header) {
				if (!utils_default.isArray(entry)) throw TypeError("Object iterator must return a key-value pair");
				obj[key = entry[0]] = (dest = obj[key]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
			}
			setHeaders(obj, valueOrRewrite);
		} else header != null && setHeader(valueOrRewrite, header, rewrite);
		return this;
	}
	get(header, parser) {
		header = normalizeHeader(header);
		if (header) {
			const key = utils_default.findKey(this, header);
			if (key) {
				const value = this[key];
				if (!parser) return value;
				if (parser === true) return parseTokens(value);
				if (utils_default.isFunction(parser)) return parser.call(this, value, key);
				if (utils_default.isRegExp(parser)) return parser.exec(value);
				throw new TypeError("parser must be boolean|regexp|function");
			}
		}
	}
	has(header, matcher) {
		header = normalizeHeader(header);
		if (header) {
			const key = utils_default.findKey(this, header);
			return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
		}
		return false;
	}
	delete(header, matcher) {
		const self$1 = this;
		let deleted = false;
		function deleteHeader(_header) {
			_header = normalizeHeader(_header);
			if (_header) {
				const key = utils_default.findKey(self$1, _header);
				if (key && (!matcher || matchHeaderValue(self$1, self$1[key], key, matcher))) {
					delete self$1[key];
					deleted = true;
				}
			}
		}
		if (utils_default.isArray(header)) header.forEach(deleteHeader);
		else deleteHeader(header);
		return deleted;
	}
	clear(matcher) {
		const keys = Object.keys(this);
		let i = keys.length;
		let deleted = false;
		while (i--) {
			const key = keys[i];
			if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
				delete this[key];
				deleted = true;
			}
		}
		return deleted;
	}
	normalize(format) {
		const self$1 = this;
		const headers = {};
		utils_default.forEach(this, (value, header) => {
			const key = utils_default.findKey(headers, header);
			if (key) {
				self$1[key] = normalizeValue(value);
				delete self$1[header];
				return;
			}
			const normalized = format ? formatHeader(header) : String(header).trim();
			if (normalized !== header) delete self$1[header];
			self$1[normalized] = normalizeValue(value);
			headers[normalized] = true;
		});
		return this;
	}
	concat(...targets) {
		return this.constructor.concat(this, ...targets);
	}
	toJSON(asStrings) {
		const obj = Object.create(null);
		utils_default.forEach(this, (value, header) => {
			value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
		});
		return obj;
	}
	[Symbol.iterator]() {
		return Object.entries(this.toJSON())[Symbol.iterator]();
	}
	toString() {
		return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
	}
	getSetCookie() {
		return this.get("set-cookie") || [];
	}
	get [Symbol.toStringTag]() {
		return "AxiosHeaders";
	}
	static from(thing) {
		return thing instanceof this ? thing : new this(thing);
	}
	static concat(first, ...targets) {
		const computed = new this(first);
		targets.forEach((target) => computed.set(target));
		return computed;
	}
	static accessor(header) {
		const accessors = (this[$internals] = this[$internals] = { accessors: {} }).accessors;
		const prototype$2 = this.prototype;
		function defineAccessor(_header) {
			const lHeader = normalizeHeader(_header);
			if (!accessors[lHeader]) {
				buildAccessors(prototype$2, _header);
				accessors[lHeader] = true;
			}
		}
		utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
		return this;
	}
};
AxiosHeaders$1.accessor([
	"Content-Type",
	"Content-Length",
	"Accept",
	"Accept-Encoding",
	"User-Agent",
	"Authorization"
]);
utils_default.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key) => {
	let mapped = key[0].toUpperCase() + key.slice(1);
	return {
		get: () => value,
		set(headerValue) {
			this[mapped] = headerValue;
		}
	};
});
utils_default.freezeMethods(AxiosHeaders$1);
var AxiosHeaders_default = AxiosHeaders$1;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/core/transformData.js
/**
* Transform the data for a request or a response
*
* @param {Array|Function} fns A single function or Array of functions
* @param {?Object} response The response object
*
* @returns {*} The resulting transformed data
*/
function transformData(fns, response$2) {
	const config$2 = this || defaults_default;
	const context = response$2 || config$2;
	const headers = AxiosHeaders_default.from(context.headers);
	let data$1 = context.data;
	utils_default.forEach(fns, function transform$1(fn) {
		data$1 = fn.call(config$2, data$1, headers.normalize(), response$2 ? response$2.status : void 0);
	});
	headers.normalize();
	return data$1;
}

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/cancel/isCancel.js
function isCancel$1(value) {
	return !!(value && value.__CANCEL__);
}

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/cancel/CanceledError.js
/**
* A `CanceledError` is an object that is thrown when an operation is canceled.
*
* @param {string=} message The message.
* @param {Object=} config The config.
* @param {Object=} request The request.
*
* @returns {CanceledError} The created error.
*/
function CanceledError$1(message, config$2, request$2) {
	AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config$2, request$2);
	this.name = "CanceledError";
}
utils_default.inherits(CanceledError$1, AxiosError_default, { __CANCEL__: true });
var CanceledError_default = CanceledError$1;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/core/settle.js
/**
* Resolve or reject a Promise based on response status.
*
* @param {Function} resolve A function that resolves the promise.
* @param {Function} reject A function that rejects the promise.
* @param {object} response The response.
*
* @returns {object} The response.
*/
function settle(resolve, reject, response$2) {
	const validateStatus = response$2.config.validateStatus;
	if (!response$2.status || !validateStatus || validateStatus(response$2.status)) resolve(response$2);
	else reject(new AxiosError_default("Request failed with status code " + response$2.status, [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response$2.status / 100) - 4], response$2.config, response$2.request, response$2));
}

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/isAbsoluteURL.js
/**
* Determines whether the specified URL is absolute
*
* @param {string} url The URL to test
*
* @returns {boolean} True if the specified URL is absolute, otherwise false
*/
function isAbsoluteURL(url$1) {
	return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url$1);
}

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/combineURLs.js
/**
* Creates a new URL by combining the specified URLs
*
* @param {string} baseURL The base URL
* @param {string} relativeURL The relative URL
*
* @returns {string} The combined URL
*/
function combineURLs(baseURL, relativeURL) {
	return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/core/buildFullPath.js
/**
* Creates a new URL by combining the baseURL with the requestedURL,
* only when the requestedURL is not already an absolute URL.
* If the requestURL is absolute, this function returns the requestedURL untouched.
*
* @param {string} baseURL The base URL
* @param {string} requestedURL Absolute or relative URL to combine
*
* @returns {string} The combined full path
*/
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
	let isRelativeUrl = !isAbsoluteURL(requestedURL);
	if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) return combineURLs(baseURL, requestedURL);
	return requestedURL;
}

//#endregion
//#region ../../node_modules/.pnpm/proxy-from-env@1.1.0/node_modules/proxy-from-env/index.js
var require_proxy_from_env = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/proxy-from-env@1.1.0/node_modules/proxy-from-env/index.js": ((exports) => {
	var parseUrl$1 = __require("url").parse;
	var DEFAULT_PORTS = {
		ftp: 21,
		gopher: 70,
		http: 80,
		https: 443,
		ws: 80,
		wss: 443
	};
	var stringEndsWith = String.prototype.endsWith || function(s$1) {
		return s$1.length <= this.length && this.indexOf(s$1, this.length - s$1.length) !== -1;
	};
	/**
	* @param {string|object} url - The URL, or the result from url.parse.
	* @return {string} The URL of the proxy that should handle the request to the
	*  given URL. If no proxy is set, this will be an empty string.
	*/
	function getProxyForUrl(url$1) {
		var parsedUrl = typeof url$1 === "string" ? parseUrl$1(url$1) : url$1 || {};
		var proto = parsedUrl.protocol;
		var hostname$1 = parsedUrl.host;
		var port = parsedUrl.port;
		if (typeof hostname$1 !== "string" || !hostname$1 || typeof proto !== "string") return "";
		proto = proto.split(":", 1)[0];
		hostname$1 = hostname$1.replace(/:\d*$/, "");
		port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
		if (!shouldProxy(hostname$1, port)) return "";
		var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
		if (proxy && proxy.indexOf("://") === -1) proxy = proto + "://" + proxy;
		return proxy;
	}
	/**
	* Determines whether a given URL should be proxied.
	*
	* @param {string} hostname - The host name of the URL.
	* @param {number} port - The effective port of the URL.
	* @returns {boolean} Whether the given URL should be proxied.
	* @private
	*/
	function shouldProxy(hostname$1, port) {
		var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
		if (!NO_PROXY) return true;
		if (NO_PROXY === "*") return false;
		return NO_PROXY.split(/[,\s]/).every(function(proxy) {
			if (!proxy) return true;
			var parsedProxy = proxy.match(/^(.+):(\d+)$/);
			var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
			var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
			if (parsedProxyPort && parsedProxyPort !== port) return true;
			if (!/^[.*]/.test(parsedProxyHostname)) return hostname$1 !== parsedProxyHostname;
			if (parsedProxyHostname.charAt(0) === "*") parsedProxyHostname = parsedProxyHostname.slice(1);
			return !stringEndsWith.call(hostname$1, parsedProxyHostname);
		});
	}
	/**
	* Get the value for an environment variable.
	*
	* @param {string} key - The name of the environment variable.
	* @return {string} The value of the environment variable.
	* @private
	*/
	function getEnv(key) {
		return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
	}
	exports.getProxyForUrl = getProxyForUrl;
}) });

//#endregion
//#region ../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js": ((exports, module) => {
	/**
	* Helpers.
	*/
	var s = 1e3;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	module.exports = function(val, options) {
		options = options || {};
		var type$1 = typeof val;
		if (type$1 === "string" && val.length > 0) return parse$3(val);
		else if (type$1 === "number" && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse$3(str) {
		str = String(str);
		if (str.length > 100) return;
		var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
		if (!match) return;
		var n = parseFloat(match[1]);
		switch ((match[2] || "ms").toLowerCase()) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n * y;
			case "weeks":
			case "week":
			case "w": return n * w;
			case "days":
			case "day":
			case "d": return n * d;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n * h;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n * m;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n * s;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n;
			default: return;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort(ms$2) {
		var msAbs = Math.abs(ms$2);
		if (msAbs >= d) return Math.round(ms$2 / d) + "d";
		if (msAbs >= h) return Math.round(ms$2 / h) + "h";
		if (msAbs >= m) return Math.round(ms$2 / m) + "m";
		if (msAbs >= s) return Math.round(ms$2 / s) + "s";
		return ms$2 + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong(ms$2) {
		var msAbs = Math.abs(ms$2);
		if (msAbs >= d) return plural(ms$2, msAbs, d, "day");
		if (msAbs >= h) return plural(ms$2, msAbs, h, "hour");
		if (msAbs >= m) return plural(ms$2, msAbs, m, "minute");
		if (msAbs >= s) return plural(ms$2, msAbs, s, "second");
		return ms$2 + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural(ms$2, msAbs, n, name) {
		var isPlural = msAbs >= n * 1.5;
		return Math.round(ms$2 / n) + " " + name + (isPlural ? "s" : "");
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/common.js
var require_common = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/common.js": ((exports, module) => {
	/**
	* This is the common logic for both the Node.js and web browser
	* implementations of `debug()`.
	*/
	function setup(env$1) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = require_ms();
		createDebug.destroy = destroy$1;
		Object.keys(env$1).forEach((key) => {
			createDebug[key] = env$1[key];
		});
		/**
		* The currently active debug mode names, and names to skip.
		*/
		createDebug.names = [];
		createDebug.skips = [];
		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};
		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;
			for (let i = 0; i < namespace.length; i++) {
				hash = (hash << 5) - hash + namespace.charCodeAt(i);
				hash |= 0;
			}
			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;
		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;
			function debug$2(...args) {
				if (!debug$2.enabled) return;
				const self$1 = debug$2;
				const curr = Number(/* @__PURE__ */ new Date());
				self$1.diff = curr - (prevTime || curr);
				self$1.prev = prevTime;
				self$1.curr = curr;
				prevTime = curr;
				args[0] = createDebug.coerce(args[0]);
				if (typeof args[0] !== "string") args.unshift("%O");
				let index$1 = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					if (match === "%%") return "%";
					index$1++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === "function") {
						const val = args[index$1];
						match = formatter.call(self$1, val);
						args.splice(index$1, 1);
						index$1--;
					}
					return match;
				});
				createDebug.formatArgs.call(self$1, args);
				(self$1.log || createDebug.log).apply(self$1, args);
			}
			debug$2.namespace = namespace;
			debug$2.useColors = createDebug.useColors();
			debug$2.color = createDebug.selectColor(namespace);
			debug$2.extend = extend$2;
			debug$2.destroy = createDebug.destroy;
			Object.defineProperty(debug$2, "enabled", {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) return enableOverride;
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}
					return enabledCache;
				},
				set: (v) => {
					enableOverride = v;
				}
			});
			if (typeof createDebug.init === "function") createDebug.init(debug$2);
			return debug$2;
		}
		function extend$2(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}
		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;
			createDebug.names = [];
			createDebug.skips = [];
			const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
			for (const ns of split) if (ns[0] === "-") createDebug.skips.push(ns.slice(1));
			else createDebug.names.push(ns);
		}
		/**
		* Checks if the given string matches a namespace template, honoring
		* asterisks as wildcards.
		*
		* @param {String} search
		* @param {String} template
		* @return {Boolean}
		*/
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;
			while (searchIndex < search.length) if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) if (template[templateIndex] === "*") {
				starIndex = templateIndex;
				matchIndex = searchIndex;
				templateIndex++;
			} else {
				searchIndex++;
				templateIndex++;
			}
			else if (starIndex !== -1) {
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else return false;
			while (templateIndex < template.length && template[templateIndex] === "*") templateIndex++;
			return templateIndex === template.length;
		}
		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [...createDebug.names, ...createDebug.skips.map((namespace) => "-" + namespace)].join(",");
			createDebug.enable("");
			return namespaces;
		}
		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			for (const skip of createDebug.skips) if (matchesTemplate(name, skip)) return false;
			for (const ns of createDebug.names) if (matchesTemplate(name, ns)) return true;
			return false;
		}
		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) return val.stack || val.message;
			return val;
		}
		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy$1() {
			console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
		}
		createDebug.enable(createDebug.load());
		return createDebug;
	}
	module.exports = setup;
}) });

//#endregion
//#region ../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/browser.js
var require_browser = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/browser.js": ((exports, module) => {
	/**
	* This is the web browser implementation of `debug()`.
	*/
	exports.formatArgs = formatArgs$1;
	exports.save = save$1;
	exports.load = load$1;
	exports.useColors = useColors$1;
	exports.storage = localstorage();
	exports.destroy = (() => {
		let warned = false;
		return () => {
			if (!warned) {
				warned = true;
				console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
			}
		};
	})();
	/**
	* Colors.
	*/
	exports.colors = [
		"#0000CC",
		"#0000FF",
		"#0033CC",
		"#0033FF",
		"#0066CC",
		"#0066FF",
		"#0099CC",
		"#0099FF",
		"#00CC00",
		"#00CC33",
		"#00CC66",
		"#00CC99",
		"#00CCCC",
		"#00CCFF",
		"#3300CC",
		"#3300FF",
		"#3333CC",
		"#3333FF",
		"#3366CC",
		"#3366FF",
		"#3399CC",
		"#3399FF",
		"#33CC00",
		"#33CC33",
		"#33CC66",
		"#33CC99",
		"#33CCCC",
		"#33CCFF",
		"#6600CC",
		"#6600FF",
		"#6633CC",
		"#6633FF",
		"#66CC00",
		"#66CC33",
		"#9900CC",
		"#9900FF",
		"#9933CC",
		"#9933FF",
		"#99CC00",
		"#99CC33",
		"#CC0000",
		"#CC0033",
		"#CC0066",
		"#CC0099",
		"#CC00CC",
		"#CC00FF",
		"#CC3300",
		"#CC3333",
		"#CC3366",
		"#CC3399",
		"#CC33CC",
		"#CC33FF",
		"#CC6600",
		"#CC6633",
		"#CC9900",
		"#CC9933",
		"#CCCC00",
		"#CCCC33",
		"#FF0000",
		"#FF0033",
		"#FF0066",
		"#FF0099",
		"#FF00CC",
		"#FF00FF",
		"#FF3300",
		"#FF3333",
		"#FF3366",
		"#FF3399",
		"#FF33CC",
		"#FF33FF",
		"#FF6600",
		"#FF6633",
		"#FF9900",
		"#FF9933",
		"#FFCC00",
		"#FFCC33"
	];
	/**
	* Currently only WebKit-based Web Inspectors, Firefox >= v31,
	* and the Firebug extension (any Firefox version) are known
	* to support "%c" CSS customizations.
	*
	* TODO: add a `localStorage` variable to explicitly enable/disable colors
	*/
	function useColors$1() {
		if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
		if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
		let m$1;
		return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m$1 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m$1[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	/**
	* Colorize log arguments if enabled.
	*
	* @api public
	*/
	function formatArgs$1(args) {
		args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
		if (!this.useColors) return;
		const c = "color: " + this.color;
		args.splice(1, 0, c, "color: inherit");
		let index$1 = 0;
		let lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, (match) => {
			if (match === "%%") return;
			index$1++;
			if (match === "%c") lastC = index$1;
		});
		args.splice(lastC, 0, c);
	}
	/**
	* Invokes `console.debug()` when available.
	* No-op when `console.debug` is not a "function".
	* If `console.debug` is not available, falls back
	* to `console.log`.
	*
	* @api public
	*/
	exports.log = console.debug || console.log || (() => {});
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save$1(namespaces) {
		try {
			if (namespaces) exports.storage.setItem("debug", namespaces);
			else exports.storage.removeItem("debug");
		} catch (error) {}
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load$1() {
		let r;
		try {
			r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
		} catch (error) {}
		if (!r && typeof process !== "undefined" && "env" in process) r = process.env.DEBUG;
		return r;
	}
	/**
	* Localstorage attempts to return the localstorage.
	*
	* This is necessary because safari throws
	* when a user disables cookies/localstorage
	* and you attempt to access it.
	*
	* @return {LocalStorage}
	* @api private
	*/
	function localstorage() {
		try {
			return localStorage;
		} catch (error) {}
	}
	module.exports = require_common()(exports);
	const { formatters: formatters$1 } = module.exports;
	/**
	* Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	*/
	formatters$1.j = function(v) {
		try {
			return JSON.stringify(v);
		} catch (error) {
			return "[UnexpectedJSONParseError]: " + error.message;
		}
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js": ((exports, module) => {
	module.exports = (flag, argv = process.argv) => {
		const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
		const position = argv.indexOf(prefix + flag);
		const terminatorPosition = argv.indexOf("--");
		return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/supports-color@8.1.1/node_modules/supports-color/index.js
var require_supports_color = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/supports-color@8.1.1/node_modules/supports-color/index.js": ((exports, module) => {
	const os = __require("os");
	const tty$1 = __require("tty");
	const hasFlag = require_has_flag();
	const { env } = process;
	let flagForceColor;
	if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) flagForceColor = 0;
	else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) flagForceColor = 1;
	function envForceColor() {
		if ("FORCE_COLOR" in env) {
			if (env.FORCE_COLOR === "true") return 1;
			if (env.FORCE_COLOR === "false") return 0;
			return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
		}
	}
	function translateLevel(level) {
		if (level === 0) return false;
		return {
			level,
			hasBasic: true,
			has256: level >= 2,
			has16m: level >= 3
		};
	}
	function supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
		const noFlagForceColor = envForceColor();
		if (noFlagForceColor !== void 0) flagForceColor = noFlagForceColor;
		const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
		if (forceColor === 0) return 0;
		if (sniffFlags) {
			if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) return 3;
			if (hasFlag("color=256")) return 2;
		}
		if (haveStream && !streamIsTTY && forceColor === void 0) return 0;
		const min$2 = forceColor || 0;
		if (env.TERM === "dumb") return min$2;
		if (process.platform === "win32") {
			const osRelease = os.release().split(".");
			if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) return Number(osRelease[2]) >= 14931 ? 3 : 2;
			return 1;
		}
		if ("CI" in env) {
			if ([
				"TRAVIS",
				"CIRCLECI",
				"APPVEYOR",
				"GITLAB_CI",
				"GITHUB_ACTIONS",
				"BUILDKITE",
				"DRONE"
			].some((sign$2) => sign$2 in env) || env.CI_NAME === "codeship") return 1;
			return min$2;
		}
		if ("TEAMCITY_VERSION" in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
		if (env.COLORTERM === "truecolor") return 3;
		if ("TERM_PROGRAM" in env) {
			const version$1 = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
			switch (env.TERM_PROGRAM) {
				case "iTerm.app": return version$1 >= 3 ? 3 : 2;
				case "Apple_Terminal": return 2;
			}
		}
		if (/-256(color)?$/i.test(env.TERM)) return 2;
		if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) return 1;
		if ("COLORTERM" in env) return 1;
		return min$2;
	}
	function getSupportLevel(stream, options = {}) {
		return translateLevel(supportsColor(stream, {
			streamIsTTY: stream && stream.isTTY,
			...options
		}));
	}
	module.exports = {
		supportsColor: getSupportLevel,
		stdout: getSupportLevel({ isTTY: tty$1.isatty(1) }),
		stderr: getSupportLevel({ isTTY: tty$1.isatty(2) })
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/node.js
var require_node = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/node.js": ((exports, module) => {
	/**
	* Module dependencies.
	*/
	const tty = __require("tty");
	const util = __require("util");
	/**
	* This is the Node.js implementation of `debug()`.
	*/
	exports.init = init;
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.destroy = util.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
	/**
	* Colors.
	*/
	exports.colors = [
		6,
		2,
		3,
		4,
		5,
		1
	];
	try {
		const supportsColor$1 = require_supports_color();
		if (supportsColor$1 && (supportsColor$1.stderr || supportsColor$1).level >= 2) exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	} catch (error) {}
	/**
	* Build up the default `inspectOpts` object from the environment variables.
	*
	*   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
	*/
	exports.inspectOpts = Object.keys(process.env).filter((key) => {
		return /^debug_/i.test(key);
	}).reduce((obj, key) => {
		const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});
		let val = process.env[key];
		if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
		else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
		else if (val === "null") val = null;
		else val = Number(val);
		obj[prop] = val;
		return obj;
	}, {});
	/**
	* Is stdout a TTY? Colored output is enabled when `true`.
	*/
	function useColors() {
		return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
	}
	/**
	* Adds ANSI color escape codes if enabled.
	*
	* @api public
	*/
	function formatArgs(args) {
		const { namespace: name, useColors: useColors$2 } = this;
		if (useColors$2) {
			const c = this.color;
			const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
			const prefix = `  ${colorCode};1m${name} \u001B[0m`;
			args[0] = prefix + args[0].split("\n").join("\n" + prefix);
			args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
		} else args[0] = getDate() + name + " " + args[0];
	}
	function getDate() {
		if (exports.inspectOpts.hideDate) return "";
		return (/* @__PURE__ */ new Date()).toISOString() + " ";
	}
	/**
	* Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
	*/
	function log(...args) {
		return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + "\n");
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save(namespaces) {
		if (namespaces) process.env.DEBUG = namespaces;
		else delete process.env.DEBUG;
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load() {
		return process.env.DEBUG;
	}
	/**
	* Init logic for `debug` instances.
	*
	* Create a new `inspectOpts` object in case `useColors` is set
	* differently for a particular `debug` instance.
	*/
	function init(debug$2) {
		debug$2.inspectOpts = {};
		const keys = Object.keys(exports.inspectOpts);
		for (let i = 0; i < keys.length; i++) debug$2.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
	module.exports = require_common()(exports);
	const { formatters } = module.exports;
	/**
	* Map %o to `util.inspect()`, all on a single line.
	*/
	formatters.o = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
	};
	/**
	* Map %O to `util.inspect()`, allowing multiple lines if needed.
	*/
	formatters.O = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util.inspect(v, this.inspectOpts);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/index.js
var require_src = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/index.js": ((exports, module) => {
	/**
	* Detect Electron renderer / nwjs process, which is node, but we should
	* treat as a browser.
	*/
	if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) module.exports = require_browser();
	else module.exports = require_node();
}) });

//#endregion
//#region ../../node_modules/.pnpm/follow-redirects@1.15.11_debug@4.4.1/node_modules/follow-redirects/debug.js
var require_debug = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/follow-redirects@1.15.11_debug@4.4.1/node_modules/follow-redirects/debug.js": ((exports, module) => {
	var debug$1;
	module.exports = function() {
		if (!debug$1) {
			try {
				debug$1 = require_src()("follow-redirects");
			} catch (error) {}
			if (typeof debug$1 !== "function") debug$1 = function() {};
		}
		debug$1.apply(null, arguments);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/follow-redirects@1.15.11_debug@4.4.1/node_modules/follow-redirects/index.js
var require_follow_redirects = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/follow-redirects@1.15.11_debug@4.4.1/node_modules/follow-redirects/index.js": ((exports, module) => {
	var url = __require("url");
	var URL$1 = url.URL;
	var http$1 = __require("http");
	var https$1 = __require("https");
	var Writable = __require("stream").Writable;
	var assert = __require("assert");
	var debug = require_debug();
	// istanbul ignore next
	(function detectUnsupportedEnvironment() {
		var looksLikeNode = typeof process !== "undefined";
		var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
		var looksLikeV8 = isFunction$1(Error.captureStackTrace);
		if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) console.warn("The follow-redirects package should be excluded from browser builds.");
	})();
	var useNativeURL = false;
	try {
		assert(new URL$1(""));
	} catch (error) {
		useNativeURL = error.code === "ERR_INVALID_URL";
	}
	var preservedUrlFields = [
		"auth",
		"host",
		"hostname",
		"href",
		"path",
		"pathname",
		"port",
		"protocol",
		"query",
		"search",
		"hash"
	];
	var events = [
		"abort",
		"aborted",
		"connect",
		"error",
		"socket",
		"timeout"
	];
	var eventHandlers = Object.create(null);
	events.forEach(function(event) {
		eventHandlers[event] = function(arg1, arg2, arg3) {
			this._redirectable.emit(event, arg1, arg2, arg3);
		};
	});
	var InvalidUrlError = createErrorType("ERR_INVALID_URL", "Invalid URL", TypeError);
	var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
	var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded", RedirectionError);
	var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
	var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
	// istanbul ignore next
	var destroy = Writable.prototype.destroy || noop;
	function RedirectableRequest(options, responseCallback) {
		Writable.call(this);
		this._sanitizeOptions(options);
		this._options = options;
		this._ended = false;
		this._ending = false;
		this._redirectCount = 0;
		this._redirects = [];
		this._requestBodyLength = 0;
		this._requestBodyBuffers = [];
		if (responseCallback) this.on("response", responseCallback);
		var self$1 = this;
		this._onNativeResponse = function(response$2) {
			try {
				self$1._processResponse(response$2);
			} catch (cause) {
				self$1.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
			}
		};
		this._performRequest();
	}
	RedirectableRequest.prototype = Object.create(Writable.prototype);
	RedirectableRequest.prototype.abort = function() {
		destroyRequest(this._currentRequest);
		this._currentRequest.abort();
		this.emit("abort");
	};
	RedirectableRequest.prototype.destroy = function(error) {
		destroyRequest(this._currentRequest, error);
		destroy.call(this, error);
		return this;
	};
	RedirectableRequest.prototype.write = function(data$1, encoding$1, callback) {
		if (this._ending) throw new WriteAfterEndError();
		if (!isString(data$1) && !isBuffer(data$1)) throw new TypeError("data should be a string, Buffer or Uint8Array");
		if (isFunction$1(encoding$1)) {
			callback = encoding$1;
			encoding$1 = null;
		}
		if (data$1.length === 0) {
			if (callback) callback();
			return;
		}
		if (this._requestBodyLength + data$1.length <= this._options.maxBodyLength) {
			this._requestBodyLength += data$1.length;
			this._requestBodyBuffers.push({
				data: data$1,
				encoding: encoding$1
			});
			this._currentRequest.write(data$1, encoding$1, callback);
		} else {
			this.emit("error", new MaxBodyLengthExceededError());
			this.abort();
		}
	};
	RedirectableRequest.prototype.end = function(data$1, encoding$1, callback) {
		if (isFunction$1(data$1)) {
			callback = data$1;
			data$1 = encoding$1 = null;
		} else if (isFunction$1(encoding$1)) {
			callback = encoding$1;
			encoding$1 = null;
		}
		if (!data$1) {
			this._ended = this._ending = true;
			this._currentRequest.end(null, null, callback);
		} else {
			var self$1 = this;
			var currentRequest = this._currentRequest;
			this.write(data$1, encoding$1, function() {
				self$1._ended = true;
				currentRequest.end(null, null, callback);
			});
			this._ending = true;
		}
	};
	RedirectableRequest.prototype.setHeader = function(name, value) {
		this._options.headers[name] = value;
		this._currentRequest.setHeader(name, value);
	};
	RedirectableRequest.prototype.removeHeader = function(name) {
		delete this._options.headers[name];
		this._currentRequest.removeHeader(name);
	};
	RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
		var self$1 = this;
		function destroyOnTimeout(socket) {
			socket.setTimeout(msecs);
			socket.removeListener("timeout", socket.destroy);
			socket.addListener("timeout", socket.destroy);
		}
		function startTimer(socket) {
			if (self$1._timeout) clearTimeout(self$1._timeout);
			self$1._timeout = setTimeout(function() {
				self$1.emit("timeout");
				clearTimer();
			}, msecs);
			destroyOnTimeout(socket);
		}
		function clearTimer() {
			if (self$1._timeout) {
				clearTimeout(self$1._timeout);
				self$1._timeout = null;
			}
			self$1.removeListener("abort", clearTimer);
			self$1.removeListener("error", clearTimer);
			self$1.removeListener("response", clearTimer);
			self$1.removeListener("close", clearTimer);
			if (callback) self$1.removeListener("timeout", callback);
			if (!self$1.socket) self$1._currentRequest.removeListener("socket", startTimer);
		}
		if (callback) this.on("timeout", callback);
		if (this.socket) startTimer(this.socket);
		else this._currentRequest.once("socket", startTimer);
		this.on("socket", destroyOnTimeout);
		this.on("abort", clearTimer);
		this.on("error", clearTimer);
		this.on("response", clearTimer);
		this.on("close", clearTimer);
		return this;
	};
	[
		"flushHeaders",
		"getHeader",
		"setNoDelay",
		"setSocketKeepAlive"
	].forEach(function(method) {
		RedirectableRequest.prototype[method] = function(a, b) {
			return this._currentRequest[method](a, b);
		};
	});
	[
		"aborted",
		"connection",
		"socket"
	].forEach(function(property) {
		Object.defineProperty(RedirectableRequest.prototype, property, { get: function() {
			return this._currentRequest[property];
		} });
	});
	RedirectableRequest.prototype._sanitizeOptions = function(options) {
		if (!options.headers) options.headers = {};
		if (options.host) {
			if (!options.hostname) options.hostname = options.host;
			delete options.host;
		}
		if (!options.pathname && options.path) {
			var searchPos = options.path.indexOf("?");
			if (searchPos < 0) options.pathname = options.path;
			else {
				options.pathname = options.path.substring(0, searchPos);
				options.search = options.path.substring(searchPos);
			}
		}
	};
	RedirectableRequest.prototype._performRequest = function() {
		var protocol = this._options.protocol;
		var nativeProtocol = this._options.nativeProtocols[protocol];
		if (!nativeProtocol) throw new TypeError("Unsupported protocol " + protocol);
		if (this._options.agents) {
			var scheme = protocol.slice(0, -1);
			this._options.agent = this._options.agents[scheme];
		}
		var request$2 = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
		request$2._redirectable = this;
		for (var event of events) request$2.on(event, eventHandlers[event]);
		this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : this._options.path;
		if (this._isRedirect) {
			var i = 0;
			var self$1 = this;
			var buffers = this._requestBodyBuffers;
			(function writeNext(error) {
				// istanbul ignore else
				if (request$2 === self$1._currentRequest) {
					// istanbul ignore if
					if (error) self$1.emit("error", error);
					else if (i < buffers.length) {
						var buffer$1 = buffers[i++];
						// istanbul ignore else
						if (!request$2.finished) request$2.write(buffer$1.data, buffer$1.encoding, writeNext);
					} else if (self$1._ended) request$2.end();
				}
			})();
		}
	};
	RedirectableRequest.prototype._processResponse = function(response$2) {
		var statusCode = response$2.statusCode;
		if (this._options.trackRedirects) this._redirects.push({
			url: this._currentUrl,
			headers: response$2.headers,
			statusCode
		});
		var location = response$2.headers.location;
		if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
			response$2.responseUrl = this._currentUrl;
			response$2.redirects = this._redirects;
			this.emit("response", response$2);
			this._requestBodyBuffers = [];
			return;
		}
		destroyRequest(this._currentRequest);
		response$2.destroy();
		if (++this._redirectCount > this._options.maxRedirects) throw new TooManyRedirectsError();
		var requestHeaders;
		var beforeRedirect = this._options.beforeRedirect;
		if (beforeRedirect) requestHeaders = Object.assign({ Host: response$2.req.getHeader("host") }, this._options.headers);
		var method = this._options.method;
		if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
			this._options.method = "GET";
			this._requestBodyBuffers = [];
			removeMatchingHeaders(/^content-/i, this._options.headers);
		}
		var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
		var currentUrlParts = parseUrl(this._currentUrl);
		var currentHost = currentHostHeader || currentUrlParts.host;
		var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
		var redirectUrl = resolveUrl(location, currentUrl);
		debug("redirecting to", redirectUrl.href);
		this._isRedirect = true;
		spreadUrlObject(redirectUrl, this._options);
		if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
		if (isFunction$1(beforeRedirect)) {
			var responseDetails = {
				headers: response$2.headers,
				statusCode
			};
			var requestDetails = {
				url: currentUrl,
				method,
				headers: requestHeaders
			};
			beforeRedirect(this._options, responseDetails, requestDetails);
			this._sanitizeOptions(this._options);
		}
		this._performRequest();
	};
	function wrap(protocols) {
		var exports$1 = {
			maxRedirects: 21,
			maxBodyLength: 10 * 1024 * 1024
		};
		var nativeProtocols = {};
		Object.keys(protocols).forEach(function(scheme) {
			var protocol = scheme + ":";
			var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
			var wrappedProtocol = exports$1[scheme] = Object.create(nativeProtocol);
			function request$2(input, options, callback) {
				if (isURL(input)) input = spreadUrlObject(input);
				else if (isString(input)) input = spreadUrlObject(parseUrl(input));
				else {
					callback = options;
					options = validateUrl(input);
					input = { protocol };
				}
				if (isFunction$1(options)) {
					callback = options;
					options = null;
				}
				options = Object.assign({
					maxRedirects: exports$1.maxRedirects,
					maxBodyLength: exports$1.maxBodyLength
				}, input, options);
				options.nativeProtocols = nativeProtocols;
				if (!isString(options.host) && !isString(options.hostname)) options.hostname = "::1";
				assert.equal(options.protocol, protocol, "protocol mismatch");
				debug("options", options);
				return new RedirectableRequest(options, callback);
			}
			function get$1(input, options, callback) {
				var wrappedRequest = wrappedProtocol.request(input, options, callback);
				wrappedRequest.end();
				return wrappedRequest;
			}
			Object.defineProperties(wrappedProtocol, {
				request: {
					value: request$2,
					configurable: true,
					enumerable: true,
					writable: true
				},
				get: {
					value: get$1,
					configurable: true,
					enumerable: true,
					writable: true
				}
			});
		});
		return exports$1;
	}
	function noop() {}
	function parseUrl(input) {
		var parsed;
		// istanbul ignore else
		if (useNativeURL) parsed = new URL$1(input);
		else {
			parsed = validateUrl(url.parse(input));
			if (!isString(parsed.protocol)) throw new InvalidUrlError({ input });
		}
		return parsed;
	}
	function resolveUrl(relative, base) {
		// istanbul ignore next
		return useNativeURL ? new URL$1(relative, base) : parseUrl(url.resolve(base, relative));
	}
	function validateUrl(input) {
		if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) throw new InvalidUrlError({ input: input.href || input });
		if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) throw new InvalidUrlError({ input: input.href || input });
		return input;
	}
	function spreadUrlObject(urlObject, target) {
		var spread$2 = target || {};
		for (var key of preservedUrlFields) spread$2[key] = urlObject[key];
		if (spread$2.hostname.startsWith("[")) spread$2.hostname = spread$2.hostname.slice(1, -1);
		if (spread$2.port !== "") spread$2.port = Number(spread$2.port);
		spread$2.path = spread$2.search ? spread$2.pathname + spread$2.search : spread$2.pathname;
		return spread$2;
	}
	function removeMatchingHeaders(regex, headers) {
		var lastValue;
		for (var header in headers) if (regex.test(header)) {
			lastValue = headers[header];
			delete headers[header];
		}
		return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
	}
	function createErrorType(code, message, baseClass) {
		function CustomError(properties) {
			// istanbul ignore else
			if (isFunction$1(Error.captureStackTrace)) Error.captureStackTrace(this, this.constructor);
			Object.assign(this, properties || {});
			this.code = code;
			this.message = this.cause ? message + ": " + this.cause.message : message;
		}
		CustomError.prototype = new (baseClass || Error)();
		Object.defineProperties(CustomError.prototype, {
			constructor: {
				value: CustomError,
				enumerable: false
			},
			name: {
				value: "Error [" + code + "]",
				enumerable: false
			}
		});
		return CustomError;
	}
	function destroyRequest(request$2, error) {
		for (var event of events) request$2.removeListener(event, eventHandlers[event]);
		request$2.on("error", noop);
		request$2.destroy(error);
	}
	function isSubdomain(subdomain, domain) {
		assert(isString(subdomain) && isString(domain));
		var dot = subdomain.length - domain.length - 1;
		return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
	}
	function isString(value) {
		return typeof value === "string" || value instanceof String;
	}
	function isFunction$1(value) {
		return typeof value === "function";
	}
	function isBuffer(value) {
		return typeof value === "object" && "length" in value;
	}
	function isURL(value) {
		return URL$1 && value instanceof URL$1;
	}
	module.exports = wrap({
		http: http$1,
		https: https$1
	});
	module.exports.wrap = wrap;
}) });

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/env/data.js
const VERSION$1 = "1.12.2";

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url$1) {
	const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url$1);
	return match && match[1] || "";
}

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/fromDataURI.js
const DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
/**
* Parse data uri to a Buffer or Blob
*
* @param {String} uri
* @param {?Boolean} asBlob
* @param {?Object} options
* @param {?Function} options.Blob
*
* @returns {Buffer|Blob}
*/
function fromDataURI(uri$1, asBlob, options) {
	const _Blob = options && options.Blob || platform_default.classes.Blob;
	const protocol = parseProtocol(uri$1);
	if (asBlob === void 0 && _Blob) asBlob = true;
	if (protocol === "data") {
		uri$1 = protocol.length ? uri$1.slice(protocol.length + 1) : uri$1;
		const match = DATA_URL_PATTERN.exec(uri$1);
		if (!match) throw new AxiosError_default("Invalid URL", AxiosError_default.ERR_INVALID_URL);
		const mime$1 = match[1];
		const isBase64 = match[2];
		const body = match[3];
		const buffer$1 = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
		if (asBlob) {
			if (!_Blob) throw new AxiosError_default("Blob is not supported", AxiosError_default.ERR_NOT_SUPPORT);
			return new _Blob([buffer$1], { type: mime$1 });
		}
		return buffer$1;
	}
	throw new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_NOT_SUPPORT);
}

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/AxiosTransformStream.js
const kInternals = Symbol("internals");
var AxiosTransformStream = class extends require$$13.Transform {
	constructor(options) {
		options = utils_default.toFlatObject(options, {
			maxRate: 0,
			chunkSize: 64 * 1024,
			minChunkSize: 100,
			timeWindow: 500,
			ticksRate: 2,
			samplesCount: 15
		}, null, (prop, source) => {
			return !utils_default.isUndefined(source[prop]);
		});
		super({ readableHighWaterMark: options.chunkSize });
		const internals = this[kInternals] = {
			timeWindow: options.timeWindow,
			chunkSize: options.chunkSize,
			maxRate: options.maxRate,
			minChunkSize: options.minChunkSize,
			bytesSeen: 0,
			isCaptured: false,
			notifiedBytesLoaded: 0,
			ts: Date.now(),
			bytes: 0,
			onReadCallback: null
		};
		this.on("newListener", (event) => {
			if (event === "progress") {
				if (!internals.isCaptured) internals.isCaptured = true;
			}
		});
	}
	_read(size) {
		const internals = this[kInternals];
		if (internals.onReadCallback) internals.onReadCallback();
		return super._read(size);
	}
	_transform(chunk, encoding$1, callback) {
		const internals = this[kInternals];
		const maxRate = internals.maxRate;
		const readableHighWaterMark = this.readableHighWaterMark;
		const timeWindow = internals.timeWindow;
		const bytesThreshold = maxRate / (1e3 / timeWindow);
		const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * .01) : 0;
		const pushChunk = (_chunk, _callback) => {
			const bytes$1 = Buffer.byteLength(_chunk);
			internals.bytesSeen += bytes$1;
			internals.bytes += bytes$1;
			internals.isCaptured && this.emit("progress", internals.bytesSeen);
			if (this.push(_chunk)) process.nextTick(_callback);
			else internals.onReadCallback = () => {
				internals.onReadCallback = null;
				process.nextTick(_callback);
			};
		};
		const transformChunk = (_chunk, _callback) => {
			const chunkSize = Buffer.byteLength(_chunk);
			let chunkRemainder = null;
			let maxChunkSize = readableHighWaterMark;
			let bytesLeft;
			let passed = 0;
			if (maxRate) {
				const now$1 = Date.now();
				if (!internals.ts || (passed = now$1 - internals.ts) >= timeWindow) {
					internals.ts = now$1;
					bytesLeft = bytesThreshold - internals.bytes;
					internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
					passed = 0;
				}
				bytesLeft = bytesThreshold - internals.bytes;
			}
			if (maxRate) {
				if (bytesLeft <= 0) return setTimeout(() => {
					_callback(null, _chunk);
				}, timeWindow - passed);
				if (bytesLeft < maxChunkSize) maxChunkSize = bytesLeft;
			}
			if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
				chunkRemainder = _chunk.subarray(maxChunkSize);
				_chunk = _chunk.subarray(0, maxChunkSize);
			}
			pushChunk(_chunk, chunkRemainder ? () => {
				process.nextTick(_callback, null, chunkRemainder);
			} : _callback);
		};
		transformChunk(chunk, function transformNextChunk(err, _chunk) {
			if (err) return callback(err);
			if (_chunk) transformChunk(_chunk, transformNextChunk);
			else callback(null);
		});
	}
};
var AxiosTransformStream_default = AxiosTransformStream;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/readBlob.js
const { asyncIterator } = Symbol;
const readBlob = async function* (blob) {
	if (blob.stream) yield* blob.stream();
	else if (blob.arrayBuffer) yield await blob.arrayBuffer();
	else if (blob[asyncIterator]) yield* blob[asyncIterator]();
	else yield blob;
};
var readBlob_default = readBlob;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/formDataToStream.js
const BOUNDARY_ALPHABET = platform_default.ALPHABET.ALPHA_DIGIT + "-_";
const textEncoder = typeof TextEncoder === "function" ? new TextEncoder() : new require$$14.TextEncoder();
const CRLF = "\r\n";
const CRLF_BYTES = textEncoder.encode(CRLF);
const CRLF_BYTES_COUNT = 2;
var FormDataPart = class {
	constructor(name, value) {
		const { escapeName } = this.constructor;
		const isStringValue = utils_default.isString(value);
		let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
		if (isStringValue) value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
		else headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
		this.headers = textEncoder.encode(headers + CRLF);
		this.contentLength = isStringValue ? value.byteLength : value.size;
		this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
		this.name = name;
		this.value = value;
	}
	async *encode() {
		yield this.headers;
		const { value } = this;
		if (utils_default.isTypedArray(value)) yield value;
		else yield* readBlob_default(value);
		yield CRLF_BYTES;
	}
	static escapeName(name) {
		return String(name).replace(/[\r\n"]/g, (match) => ({
			"\r": "%0D",
			"\n": "%0A",
			"\"": "%22"
		})[match]);
	}
};
const formDataToStream = (form, headersHandler, options) => {
	const { tag = "form-data-boundary", size = 25, boundary = tag + "-" + platform_default.generateString(size, BOUNDARY_ALPHABET) } = options || {};
	if (!utils_default.isFormData(form)) throw TypeError("FormData instance required");
	if (boundary.length < 1 || boundary.length > 70) throw Error("boundary must be 10-70 characters long");
	const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
	const footerBytes = textEncoder.encode("--" + boundary + "--\r\n");
	let contentLength = footerBytes.byteLength;
	const parts = Array.from(form.entries()).map(([name, value]) => {
		const part = new FormDataPart(name, value);
		contentLength += part.size;
		return part;
	});
	contentLength += boundaryBytes.byteLength * parts.length;
	contentLength = utils_default.toFiniteNumber(contentLength);
	const computedHeaders = { "Content-Type": `multipart/form-data; boundary=${boundary}` };
	if (Number.isFinite(contentLength)) computedHeaders["Content-Length"] = contentLength;
	headersHandler && headersHandler(computedHeaders);
	return Readable.from((async function* () {
		for (const part of parts) {
			yield boundaryBytes;
			yield* part.encode();
		}
		yield footerBytes;
	})());
};
var formDataToStream_default = formDataToStream;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js
var ZlibHeaderTransformStream = class extends require$$13.Transform {
	__transform(chunk, encoding$1, callback) {
		this.push(chunk);
		callback();
	}
	_transform(chunk, encoding$1, callback) {
		if (chunk.length !== 0) {
			this._transform = this.__transform;
			if (chunk[0] !== 120) {
				const header = Buffer.alloc(2);
				header[0] = 120;
				header[1] = 156;
				this.push(header, encoding$1);
			}
		}
		this.__transform(chunk, encoding$1, callback);
	}
};
var ZlibHeaderTransformStream_default = ZlibHeaderTransformStream;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/callbackify.js
const callbackify = (fn, reducer) => {
	return utils_default.isAsyncFn(fn) ? function(...args) {
		const cb = args.pop();
		fn.apply(this, args).then((value) => {
			try {
				reducer ? cb(null, ...reducer(value)) : cb(null, value);
			} catch (err) {
				cb(err);
			}
		}, cb);
	} : fn;
};
var callbackify_default = callbackify;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/speedometer.js
/**
* Calculate data maxRate
* @param {Number} [samplesCount= 10]
* @param {Number} [min= 1000]
* @returns {Function}
*/
function speedometer(samplesCount, min$2) {
	samplesCount = samplesCount || 10;
	const bytes$1 = new Array(samplesCount);
	const timestamps = new Array(samplesCount);
	let head = 0;
	let tail = 0;
	let firstSampleTS;
	min$2 = min$2 !== void 0 ? min$2 : 1e3;
	return function push(chunkLength) {
		const now$1 = Date.now();
		const startedAt = timestamps[tail];
		if (!firstSampleTS) firstSampleTS = now$1;
		bytes$1[head] = chunkLength;
		timestamps[head] = now$1;
		let i = tail;
		let bytesCount = 0;
		while (i !== head) {
			bytesCount += bytes$1[i++];
			i = i % samplesCount;
		}
		head = (head + 1) % samplesCount;
		if (head === tail) tail = (tail + 1) % samplesCount;
		if (now$1 - firstSampleTS < min$2) return;
		const passed = startedAt && now$1 - startedAt;
		return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
	};
}
var speedometer_default = speedometer;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/throttle.js
/**
* Throttle decorator
* @param {Function} fn
* @param {Number} freq
* @return {Function}
*/
function throttle(fn, freq) {
	let timestamp = 0;
	let threshold = 1e3 / freq;
	let lastArgs;
	let timer;
	const invoke = (args, now$1 = Date.now()) => {
		timestamp = now$1;
		lastArgs = null;
		if (timer) {
			clearTimeout(timer);
			timer = null;
		}
		fn(...args);
	};
	const throttled = (...args) => {
		const now$1 = Date.now();
		const passed = now$1 - timestamp;
		if (passed >= threshold) invoke(args, now$1);
		else {
			lastArgs = args;
			if (!timer) timer = setTimeout(() => {
				timer = null;
				invoke(lastArgs);
			}, threshold - passed);
		}
	};
	const flush = () => lastArgs && invoke(lastArgs);
	return [throttled, flush];
}
var throttle_default = throttle;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/progressEventReducer.js
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
	let bytesNotified = 0;
	const _speedometer = speedometer_default(50, 250);
	return throttle_default((e) => {
		const loaded = e.loaded;
		const total = e.lengthComputable ? e.total : void 0;
		const progressBytes = loaded - bytesNotified;
		const rate = _speedometer(progressBytes);
		const inRange = loaded <= total;
		bytesNotified = loaded;
		listener({
			loaded,
			total,
			progress: total ? loaded / total : void 0,
			bytes: progressBytes,
			rate: rate ? rate : void 0,
			estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
			event: e,
			lengthComputable: total != null,
			[isDownloadStream ? "download" : "upload"]: true
		});
	}, freq);
};
const progressEventDecorator = (total, throttled) => {
	const lengthComputable = total != null;
	return [(loaded) => throttled[0]({
		lengthComputable,
		total,
		loaded
	}), throttled[1]];
};
const asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/estimateDataURLDecodedBytes.js
/**
* Estimate decoded byte length of a data:// URL *without* allocating large buffers.
* - For base64: compute exact decoded size using length and padding;
*               handle %XX at the character-count level (no string allocation).
* - For non-base64: use UTF-8 byteLength of the encoded body as a safe upper bound.
*
* @param {string} url
* @returns {number}
*/
function estimateDataURLDecodedBytes(url$1) {
	if (!url$1 || typeof url$1 !== "string") return 0;
	if (!url$1.startsWith("data:")) return 0;
	const comma = url$1.indexOf(",");
	if (comma < 0) return 0;
	const meta = url$1.slice(5, comma);
	const body = url$1.slice(comma + 1);
	if (/;base64/i.test(meta)) {
		let effectiveLen = body.length;
		const len = body.length;
		for (let i = 0; i < len; i++) if (body.charCodeAt(i) === 37 && i + 2 < len) {
			const a = body.charCodeAt(i + 1);
			const b = body.charCodeAt(i + 2);
			if ((a >= 48 && a <= 57 || a >= 65 && a <= 70 || a >= 97 && a <= 102) && (b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102)) {
				effectiveLen -= 2;
				i += 2;
			}
		}
		let pad = 0;
		let idx = len - 1;
		const tailIsPct3D = (j) => j >= 2 && body.charCodeAt(j - 2) === 37 && body.charCodeAt(j - 1) === 51 && (body.charCodeAt(j) === 68 || body.charCodeAt(j) === 100);
		if (idx >= 0) {
			if (body.charCodeAt(idx) === 61) {
				pad++;
				idx--;
			} else if (tailIsPct3D(idx)) {
				pad++;
				idx -= 3;
			}
		}
		if (pad === 1 && idx >= 0) {
			if (body.charCodeAt(idx) === 61) pad++;
			else if (tailIsPct3D(idx)) pad++;
		}
		const bytes$1 = Math.floor(effectiveLen / 4) * 3 - (pad || 0);
		return bytes$1 > 0 ? bytes$1 : 0;
	}
	return Buffer.byteLength(body, "utf8");
}

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/adapters/http.js
var import_proxy_from_env = /* @__PURE__ */ __toESM(require_proxy_from_env(), 1);
var import_follow_redirects = /* @__PURE__ */ __toESM(require_follow_redirects(), 1);
const zlibOptions = {
	flush: require$$2.constants.Z_SYNC_FLUSH,
	finishFlush: require$$2.constants.Z_SYNC_FLUSH
};
const brotliOptions = {
	flush: require$$2.constants.BROTLI_OPERATION_FLUSH,
	finishFlush: require$$2.constants.BROTLI_OPERATION_FLUSH
};
const isBrotliSupported = utils_default.isFunction(require$$2.createBrotliDecompress);
const { http: httpFollow, https: httpsFollow } = import_follow_redirects.default;
const isHttps = /https:?/;
const supportedProtocols = platform_default.protocols.map((protocol) => {
	return protocol + ":";
});
const flushOnFinish = (stream, [throttled, flush]) => {
	stream.on("end", flush).on("error", flush);
	return throttled;
};
/**
* If the proxy or config beforeRedirects functions are defined, call them with the options
* object.
*
* @param {Object<string, any>} options - The options object that was passed to the request.
*
* @returns {Object<string, any>}
*/
function dispatchBeforeRedirect(options, responseDetails) {
	if (options.beforeRedirects.proxy) options.beforeRedirects.proxy(options);
	if (options.beforeRedirects.config) options.beforeRedirects.config(options, responseDetails);
}
/**
* If the proxy or config afterRedirects functions are defined, call them with the options
*
* @param {http.ClientRequestArgs} options
* @param {AxiosProxyConfig} configProxy configuration from Axios options object
* @param {string} location
*
* @returns {http.ClientRequestArgs}
*/
function setProxy(options, configProxy, location) {
	let proxy = configProxy;
	if (!proxy && proxy !== false) {
		const proxyUrl = import_proxy_from_env.getProxyForUrl(location);
		if (proxyUrl) proxy = new URL(proxyUrl);
	}
	if (proxy) {
		if (proxy.username) proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
		if (proxy.auth) {
			if (proxy.auth.username || proxy.auth.password) proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
			const base64$1 = Buffer.from(proxy.auth, "utf8").toString("base64");
			options.headers["Proxy-Authorization"] = "Basic " + base64$1;
		}
		options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
		const proxyHost = proxy.hostname || proxy.host;
		options.hostname = proxyHost;
		options.host = proxyHost;
		options.port = proxy.port;
		options.path = location;
		if (proxy.protocol) options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
	}
	options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
		setProxy(redirectOptions, configProxy, redirectOptions.href);
	};
}
const isHttpAdapterSupported = typeof process !== "undefined" && utils_default.kindOf(process) === "process";
const wrapAsync = (asyncExecutor) => {
	return new Promise((resolve, reject) => {
		let onDone;
		let isDone;
		const done = (value, isRejected) => {
			if (isDone) return;
			isDone = true;
			onDone && onDone(value, isRejected);
		};
		const _resolve = (value) => {
			done(value);
			resolve(value);
		};
		const _reject = (reason) => {
			done(reason, true);
			reject(reason);
		};
		asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
	});
};
const resolveFamily = ({ address, family }) => {
	if (!utils_default.isString(address)) throw TypeError("address must be a string");
	return {
		address,
		family: family || (address.indexOf(".") < 0 ? 6 : 4)
	};
};
const buildAddressEntry = (address, family) => resolveFamily(utils_default.isObject(address) ? address : {
	address,
	family
});
var http_default = isHttpAdapterSupported && function httpAdapter(config$2) {
	return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
		let { data: data$1, lookup: lookup$1, family } = config$2;
		const { responseType, responseEncoding } = config$2;
		const method = config$2.method.toUpperCase();
		let isDone;
		let rejected = false;
		let req;
		if (lookup$1) {
			const _lookup = callbackify_default(lookup$1, (value) => utils_default.isArray(value) ? value : [value]);
			lookup$1 = (hostname$1, opt, cb) => {
				_lookup(hostname$1, opt, (err, arg0, arg1) => {
					if (err) return cb(err);
					const addresses = utils_default.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
					opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
				});
			};
		}
		const emitter = new EventEmitter();
		const onFinished$1 = () => {
			if (config$2.cancelToken) config$2.cancelToken.unsubscribe(abort$3);
			if (config$2.signal) config$2.signal.removeEventListener("abort", abort$3);
			emitter.removeAllListeners();
		};
		onDone((value, isRejected) => {
			isDone = true;
			if (isRejected) {
				rejected = true;
				onFinished$1();
			}
		});
		function abort$3(reason) {
			emitter.emit("abort", !reason || reason.type ? new CanceledError_default(null, config$2, req) : reason);
		}
		emitter.once("abort", reject);
		if (config$2.cancelToken || config$2.signal) {
			config$2.cancelToken && config$2.cancelToken.subscribe(abort$3);
			if (config$2.signal) config$2.signal.aborted ? abort$3() : config$2.signal.addEventListener("abort", abort$3);
		}
		const fullPath = buildFullPath(config$2.baseURL, config$2.url, config$2.allowAbsoluteUrls);
		const parsed = new URL(fullPath, platform_default.hasBrowserEnv ? platform_default.origin : void 0);
		const protocol = parsed.protocol || supportedProtocols[0];
		if (protocol === "data:") {
			if (config$2.maxContentLength > -1) {
				if (estimateDataURLDecodedBytes(String(config$2.url || fullPath || "")) > config$2.maxContentLength) return reject(new AxiosError_default("maxContentLength size of " + config$2.maxContentLength + " exceeded", AxiosError_default.ERR_BAD_RESPONSE, config$2));
			}
			let convertedData;
			if (method !== "GET") return settle(resolve, reject, {
				status: 405,
				statusText: "method not allowed",
				headers: {},
				config: config$2
			});
			try {
				convertedData = fromDataURI(config$2.url, responseType === "blob", { Blob: config$2.env && config$2.env.Blob });
			} catch (err) {
				throw AxiosError_default.from(err, AxiosError_default.ERR_BAD_REQUEST, config$2);
			}
			if (responseType === "text") {
				convertedData = convertedData.toString(responseEncoding);
				if (!responseEncoding || responseEncoding === "utf8") convertedData = utils_default.stripBOM(convertedData);
			} else if (responseType === "stream") convertedData = require$$13.Readable.from(convertedData);
			return settle(resolve, reject, {
				data: convertedData,
				status: 200,
				statusText: "OK",
				headers: new AxiosHeaders_default(),
				config: config$2
			});
		}
		if (supportedProtocols.indexOf(protocol) === -1) return reject(new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_BAD_REQUEST, config$2));
		const headers = AxiosHeaders_default.from(config$2.headers).normalize();
		headers.set("User-Agent", "axios/" + VERSION$1, false);
		const { onUploadProgress, onDownloadProgress } = config$2;
		const maxRate = config$2.maxRate;
		let maxUploadRate = void 0;
		let maxDownloadRate = void 0;
		if (utils_default.isSpecCompliantForm(data$1)) {
			const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
			data$1 = formDataToStream_default(data$1, (formHeaders) => {
				headers.set(formHeaders);
			}, {
				tag: `axios-${VERSION$1}-boundary`,
				boundary: userBoundary && userBoundary[1] || void 0
			});
		} else if (utils_default.isFormData(data$1) && utils_default.isFunction(data$1.getHeaders)) {
			headers.set(data$1.getHeaders());
			if (!headers.hasContentLength()) try {
				const knownLength = await require$$14.promisify(data$1.getLength).call(data$1);
				Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
			} catch (e) {}
		} else if (utils_default.isBlob(data$1) || utils_default.isFile(data$1)) {
			data$1.size && headers.setContentType(data$1.type || "application/octet-stream");
			headers.setContentLength(data$1.size || 0);
			data$1 = require$$13.Readable.from(readBlob_default(data$1));
		} else if (data$1 && !utils_default.isStream(data$1)) {
			if (Buffer.isBuffer(data$1)) {} else if (utils_default.isArrayBuffer(data$1)) data$1 = Buffer.from(new Uint8Array(data$1));
			else if (utils_default.isString(data$1)) data$1 = Buffer.from(data$1, "utf-8");
			else return reject(new AxiosError_default("Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream", AxiosError_default.ERR_BAD_REQUEST, config$2));
			headers.setContentLength(data$1.length, false);
			if (config$2.maxBodyLength > -1 && data$1.length > config$2.maxBodyLength) return reject(new AxiosError_default("Request body larger than maxBodyLength limit", AxiosError_default.ERR_BAD_REQUEST, config$2));
		}
		const contentLength = utils_default.toFiniteNumber(headers.getContentLength());
		if (utils_default.isArray(maxRate)) {
			maxUploadRate = maxRate[0];
			maxDownloadRate = maxRate[1];
		} else maxUploadRate = maxDownloadRate = maxRate;
		if (data$1 && (onUploadProgress || maxUploadRate)) {
			if (!utils_default.isStream(data$1)) data$1 = require$$13.Readable.from(data$1, { objectMode: false });
			data$1 = require$$13.pipeline([data$1, new AxiosTransformStream_default({ maxRate: utils_default.toFiniteNumber(maxUploadRate) })], utils_default.noop);
			onUploadProgress && data$1.on("progress", flushOnFinish(data$1, progressEventDecorator(contentLength, progressEventReducer(asyncDecorator(onUploadProgress), false, 3))));
		}
		let auth = void 0;
		if (config$2.auth) {
			const username = config$2.auth.username || "";
			const password = config$2.auth.password || "";
			auth = username + ":" + password;
		}
		if (!auth && parsed.username) {
			const urlUsername = parsed.username;
			const urlPassword = parsed.password;
			auth = urlUsername + ":" + urlPassword;
		}
		auth && headers.delete("authorization");
		let path$3;
		try {
			path$3 = buildURL(parsed.pathname + parsed.search, config$2.params, config$2.paramsSerializer).replace(/^\?/, "");
		} catch (err) {
			const customErr = new Error(err.message);
			customErr.config = config$2;
			customErr.url = config$2.url;
			customErr.exists = true;
			return reject(customErr);
		}
		headers.set("Accept-Encoding", "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""), false);
		const options = {
			path: path$3,
			method,
			headers: headers.toJSON(),
			agents: {
				http: config$2.httpAgent,
				https: config$2.httpsAgent
			},
			auth,
			protocol,
			family,
			beforeRedirect: dispatchBeforeRedirect,
			beforeRedirects: {}
		};
		!utils_default.isUndefined(lookup$1) && (options.lookup = lookup$1);
		if (config$2.socketPath) options.socketPath = config$2.socketPath;
		else {
			options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
			options.port = parsed.port;
			setProxy(options, config$2.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
		}
		let transport;
		const isHttpsRequest = isHttps.test(options.protocol);
		options.agent = isHttpsRequest ? config$2.httpsAgent : config$2.httpAgent;
		if (config$2.transport) transport = config$2.transport;
		else if (config$2.maxRedirects === 0) transport = isHttpsRequest ? https : http;
		else {
			if (config$2.maxRedirects) options.maxRedirects = config$2.maxRedirects;
			if (config$2.beforeRedirect) options.beforeRedirects.config = config$2.beforeRedirect;
			transport = isHttpsRequest ? httpsFollow : httpFollow;
		}
		if (config$2.maxBodyLength > -1) options.maxBodyLength = config$2.maxBodyLength;
		else options.maxBodyLength = Infinity;
		if (config$2.insecureHTTPParser) options.insecureHTTPParser = config$2.insecureHTTPParser;
		req = transport.request(options, function handleResponse(res) {
			if (req.destroyed) return;
			const streams$1 = [res];
			const responseLength = +res.headers["content-length"];
			if (onDownloadProgress || maxDownloadRate) {
				const transformStream = new AxiosTransformStream_default({ maxRate: utils_default.toFiniteNumber(maxDownloadRate) });
				onDownloadProgress && transformStream.on("progress", flushOnFinish(transformStream, progressEventDecorator(responseLength, progressEventReducer(asyncDecorator(onDownloadProgress), true, 3))));
				streams$1.push(transformStream);
			}
			let responseStream = res;
			const lastRequest = res.req || req;
			if (config$2.decompress !== false && res.headers["content-encoding"]) {
				if (method === "HEAD" || res.statusCode === 204) delete res.headers["content-encoding"];
				switch ((res.headers["content-encoding"] || "").toLowerCase()) {
					case "gzip":
					case "x-gzip":
					case "compress":
					case "x-compress":
						streams$1.push(require$$2.createUnzip(zlibOptions));
						delete res.headers["content-encoding"];
						break;
					case "deflate":
						streams$1.push(new ZlibHeaderTransformStream_default());
						streams$1.push(require$$2.createUnzip(zlibOptions));
						delete res.headers["content-encoding"];
						break;
					case "br": if (isBrotliSupported) {
						streams$1.push(require$$2.createBrotliDecompress(brotliOptions));
						delete res.headers["content-encoding"];
					}
				}
			}
			responseStream = streams$1.length > 1 ? require$$13.pipeline(streams$1, utils_default.noop) : streams$1[0];
			const offListeners = require$$13.finished(responseStream, () => {
				offListeners();
				onFinished$1();
			});
			const response$2 = {
				status: res.statusCode,
				statusText: res.statusMessage,
				headers: new AxiosHeaders_default(res.headers),
				config: config$2,
				request: lastRequest
			};
			if (responseType === "stream") {
				response$2.data = responseStream;
				settle(resolve, reject, response$2);
			} else {
				const responseBuffer = [];
				let totalResponseBytes = 0;
				responseStream.on("data", function handleStreamData(chunk) {
					responseBuffer.push(chunk);
					totalResponseBytes += chunk.length;
					if (config$2.maxContentLength > -1 && totalResponseBytes > config$2.maxContentLength) {
						rejected = true;
						responseStream.destroy();
						reject(new AxiosError_default("maxContentLength size of " + config$2.maxContentLength + " exceeded", AxiosError_default.ERR_BAD_RESPONSE, config$2, lastRequest));
					}
				});
				responseStream.on("aborted", function handlerStreamAborted() {
					if (rejected) return;
					const err = new AxiosError_default("stream has been aborted", AxiosError_default.ERR_BAD_RESPONSE, config$2, lastRequest);
					responseStream.destroy(err);
					reject(err);
				});
				responseStream.on("error", function handleStreamError(err) {
					if (req.destroyed) return;
					reject(AxiosError_default.from(err, null, config$2, lastRequest));
				});
				responseStream.on("end", function handleStreamEnd() {
					try {
						let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
						if (responseType !== "arraybuffer") {
							responseData = responseData.toString(responseEncoding);
							if (!responseEncoding || responseEncoding === "utf8") responseData = utils_default.stripBOM(responseData);
						}
						response$2.data = responseData;
					} catch (err) {
						return reject(AxiosError_default.from(err, null, config$2, response$2.request, response$2));
					}
					settle(resolve, reject, response$2);
				});
			}
			emitter.once("abort", (err) => {
				if (!responseStream.destroyed) {
					responseStream.emit("error", err);
					responseStream.destroy();
				}
			});
		});
		emitter.once("abort", (err) => {
			reject(err);
			req.destroy(err);
		});
		req.on("error", function handleRequestError(err) {
			reject(AxiosError_default.from(err, null, config$2, req));
		});
		req.on("socket", function handleRequestSocket(socket) {
			socket.setKeepAlive(true, 1e3 * 60);
		});
		if (config$2.timeout) {
			const timeout = parseInt(config$2.timeout, 10);
			if (Number.isNaN(timeout)) {
				reject(new AxiosError_default("error trying to parse `config.timeout` to int", AxiosError_default.ERR_BAD_OPTION_VALUE, config$2, req));
				return;
			}
			req.setTimeout(timeout, function handleRequestTimeout() {
				if (isDone) return;
				let timeoutErrorMessage = config$2.timeout ? "timeout of " + config$2.timeout + "ms exceeded" : "timeout exceeded";
				const transitional = config$2.transitional || transitional_default;
				if (config$2.timeoutErrorMessage) timeoutErrorMessage = config$2.timeoutErrorMessage;
				reject(new AxiosError_default(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED, config$2, req));
				abort$3();
			});
		}
		if (utils_default.isStream(data$1)) {
			let ended = false;
			let errored = false;
			data$1.on("end", () => {
				ended = true;
			});
			data$1.once("error", (err) => {
				errored = true;
				req.destroy(err);
			});
			data$1.on("close", () => {
				if (!ended && !errored) abort$3(new CanceledError_default("Request stream has been aborted", config$2, req));
			});
			data$1.pipe(req);
		} else req.end(data$1);
	});
};

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? ((origin$1, isMSIE) => (url$1) => {
	url$1 = new URL(url$1, platform_default.origin);
	return origin$1.protocol === url$1.protocol && origin$1.host === url$1.host && (isMSIE || origin$1.port === url$1.port);
})(new URL(platform_default.origin), platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)) : () => true;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? {
	write(name, value, expires, path$3, domain, secure) {
		const cookie$1 = [name + "=" + encodeURIComponent(value)];
		utils_default.isNumber(expires) && cookie$1.push("expires=" + new Date(expires).toGMTString());
		utils_default.isString(path$3) && cookie$1.push("path=" + path$3);
		utils_default.isString(domain) && cookie$1.push("domain=" + domain);
		secure === true && cookie$1.push("secure");
		document.cookie = cookie$1.join("; ");
	},
	read(name) {
		const match = document.cookie.match(/* @__PURE__ */ new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
		return match ? decodeURIComponent(match[3]) : null;
	},
	remove(name) {
		this.write(name, "", Date.now() - 864e5);
	}
} : {
	write() {},
	read() {
		return null;
	},
	remove() {}
};

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/core/mergeConfig.js
const headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
/**
* Config-specific merge-function which creates a new config-object
* by merging two configuration objects together.
*
* @param {Object} config1
* @param {Object} config2
*
* @returns {Object} New object resulting from merging config2 to config1
*/
function mergeConfig$1(config1, config2) {
	config2 = config2 || {};
	const config$2 = {};
	function getMergedValue(target, source, prop, caseless) {
		if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) return utils_default.merge.call({ caseless }, target, source);
		else if (utils_default.isPlainObject(source)) return utils_default.merge({}, source);
		else if (utils_default.isArray(source)) return source.slice();
		return source;
	}
	function mergeDeepProperties(a, b, prop, caseless) {
		if (!utils_default.isUndefined(b)) return getMergedValue(a, b, prop, caseless);
		else if (!utils_default.isUndefined(a)) return getMergedValue(void 0, a, prop, caseless);
	}
	function valueFromConfig2(a, b) {
		if (!utils_default.isUndefined(b)) return getMergedValue(void 0, b);
	}
	function defaultToConfig2(a, b) {
		if (!utils_default.isUndefined(b)) return getMergedValue(void 0, b);
		else if (!utils_default.isUndefined(a)) return getMergedValue(void 0, a);
	}
	function mergeDirectKeys(a, b, prop) {
		if (prop in config2) return getMergedValue(a, b);
		else if (prop in config1) return getMergedValue(void 0, a);
	}
	const mergeMap = {
		url: valueFromConfig2,
		method: valueFromConfig2,
		data: valueFromConfig2,
		baseURL: defaultToConfig2,
		transformRequest: defaultToConfig2,
		transformResponse: defaultToConfig2,
		paramsSerializer: defaultToConfig2,
		timeout: defaultToConfig2,
		timeoutMessage: defaultToConfig2,
		withCredentials: defaultToConfig2,
		withXSRFToken: defaultToConfig2,
		adapter: defaultToConfig2,
		responseType: defaultToConfig2,
		xsrfCookieName: defaultToConfig2,
		xsrfHeaderName: defaultToConfig2,
		onUploadProgress: defaultToConfig2,
		onDownloadProgress: defaultToConfig2,
		decompress: defaultToConfig2,
		maxContentLength: defaultToConfig2,
		maxBodyLength: defaultToConfig2,
		beforeRedirect: defaultToConfig2,
		transport: defaultToConfig2,
		httpAgent: defaultToConfig2,
		httpsAgent: defaultToConfig2,
		cancelToken: defaultToConfig2,
		socketPath: defaultToConfig2,
		responseEncoding: defaultToConfig2,
		validateStatus: mergeDirectKeys,
		headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
	};
	utils_default.forEach(Object.keys({
		...config1,
		...config2
	}), function computeConfigValue(prop) {
		const merge$2 = mergeMap[prop] || mergeDeepProperties;
		const configValue = merge$2(config1[prop], config2[prop], prop);
		utils_default.isUndefined(configValue) && merge$2 !== mergeDirectKeys || (config$2[prop] = configValue);
	});
	return config$2;
}

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config$2) => {
	const newConfig = mergeConfig$1({}, config$2);
	let { data: data$1, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
	newConfig.headers = headers = AxiosHeaders_default.from(headers);
	newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config$2.params, config$2.paramsSerializer);
	if (auth) headers.set("Authorization", "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : "")));
	if (utils_default.isFormData(data$1)) {
		if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) headers.setContentType(void 0);
		else if (utils_default.isFunction(data$1.getHeaders)) {
			const formHeaders = data$1.getHeaders();
			const allowedHeaders = ["content-type", "content-length"];
			Object.entries(formHeaders).forEach(([key, val]) => {
				if (allowedHeaders.includes(key.toLowerCase())) headers.set(key, val);
			});
		}
	}
	if (platform_default.hasStandardBrowserEnv) {
		withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
		if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
			const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
			if (xsrfValue) headers.set(xsrfHeaderName, xsrfValue);
		}
	}
	return newConfig;
};

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/adapters/xhr.js
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config$2) {
	return new Promise(function dispatchXhrRequest(resolve, reject) {
		const _config = resolveConfig_default(config$2);
		let requestData = _config.data;
		const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
		let { responseType, onUploadProgress, onDownloadProgress } = _config;
		let onCanceled;
		let uploadThrottled, downloadThrottled;
		let flushUpload, flushDownload;
		function done() {
			flushUpload && flushUpload();
			flushDownload && flushDownload();
			_config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
			_config.signal && _config.signal.removeEventListener("abort", onCanceled);
		}
		let request$2 = new XMLHttpRequest();
		request$2.open(_config.method.toUpperCase(), _config.url, true);
		request$2.timeout = _config.timeout;
		function onloadend() {
			if (!request$2) return;
			const responseHeaders = AxiosHeaders_default.from("getAllResponseHeaders" in request$2 && request$2.getAllResponseHeaders());
			settle(function _resolve(value) {
				resolve(value);
				done();
			}, function _reject(err) {
				reject(err);
				done();
			}, {
				data: !responseType || responseType === "text" || responseType === "json" ? request$2.responseText : request$2.response,
				status: request$2.status,
				statusText: request$2.statusText,
				headers: responseHeaders,
				config: config$2,
				request: request$2
			});
			request$2 = null;
		}
		if ("onloadend" in request$2) request$2.onloadend = onloadend;
		else request$2.onreadystatechange = function handleLoad() {
			if (!request$2 || request$2.readyState !== 4) return;
			if (request$2.status === 0 && !(request$2.responseURL && request$2.responseURL.indexOf("file:") === 0)) return;
			setTimeout(onloadend);
		};
		request$2.onabort = function handleAbort() {
			if (!request$2) return;
			reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config$2, request$2));
			request$2 = null;
		};
		request$2.onerror = function handleError$1(event) {
			const err = new AxiosError_default(event && event.message ? event.message : "Network Error", AxiosError_default.ERR_NETWORK, config$2, request$2);
			err.event = event || null;
			reject(err);
			request$2 = null;
		};
		request$2.ontimeout = function handleTimeout() {
			let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
			const transitional = _config.transitional || transitional_default;
			if (_config.timeoutErrorMessage) timeoutErrorMessage = _config.timeoutErrorMessage;
			reject(new AxiosError_default(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED, config$2, request$2));
			request$2 = null;
		};
		requestData === void 0 && requestHeaders.setContentType(null);
		if ("setRequestHeader" in request$2) utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
			request$2.setRequestHeader(key, val);
		});
		if (!utils_default.isUndefined(_config.withCredentials)) request$2.withCredentials = !!_config.withCredentials;
		if (responseType && responseType !== "json") request$2.responseType = _config.responseType;
		if (onDownloadProgress) {
			[downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
			request$2.addEventListener("progress", downloadThrottled);
		}
		if (onUploadProgress && request$2.upload) {
			[uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
			request$2.upload.addEventListener("progress", uploadThrottled);
			request$2.upload.addEventListener("loadend", flushUpload);
		}
		if (_config.cancelToken || _config.signal) {
			onCanceled = (cancel) => {
				if (!request$2) return;
				reject(!cancel || cancel.type ? new CanceledError_default(null, config$2, request$2) : cancel);
				request$2.abort();
				request$2 = null;
			};
			_config.cancelToken && _config.cancelToken.subscribe(onCanceled);
			if (_config.signal) _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
		}
		const protocol = parseProtocol(_config.url);
		if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
			reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config$2));
			return;
		}
		request$2.send(requestData || null);
	});
};

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/composeSignals.js
const composeSignals = (signals, timeout) => {
	const { length } = signals = signals ? signals.filter(Boolean) : [];
	if (timeout || length) {
		let controller = new AbortController();
		let aborted$1;
		const onabort = function(reason) {
			if (!aborted$1) {
				aborted$1 = true;
				unsubscribe();
				const err = reason instanceof Error ? reason : this.reason;
				controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
			}
		};
		let timer = timeout && setTimeout(() => {
			timer = null;
			onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
		}, timeout);
		const unsubscribe = () => {
			if (signals) {
				timer && clearTimeout(timer);
				timer = null;
				signals.forEach((signal$1) => {
					signal$1.unsubscribe ? signal$1.unsubscribe(onabort) : signal$1.removeEventListener("abort", onabort);
				});
				signals = null;
			}
		};
		signals.forEach((signal$1) => signal$1.addEventListener("abort", onabort));
		const { signal } = controller;
		signal.unsubscribe = () => utils_default.asap(unsubscribe);
		return signal;
	}
};
var composeSignals_default = composeSignals;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/trackStream.js
const streamChunk = function* (chunk, chunkSize) {
	let len = chunk.byteLength;
	if (!chunkSize || len < chunkSize) {
		yield chunk;
		return;
	}
	let pos = 0;
	let end;
	while (pos < len) {
		end = pos + chunkSize;
		yield chunk.slice(pos, end);
		pos = end;
	}
};
const readBytes = async function* (iterable, chunkSize) {
	for await (const chunk of readStream(iterable)) yield* streamChunk(chunk, chunkSize);
};
const readStream = async function* (stream) {
	if (stream[Symbol.asyncIterator]) {
		yield* stream;
		return;
	}
	const reader = stream.getReader();
	try {
		for (;;) {
			const { done, value } = await reader.read();
			if (done) break;
			yield value;
		}
	} finally {
		await reader.cancel();
	}
};
const trackStream = (stream, chunkSize, onProgress, onFinish) => {
	const iterator$1 = readBytes(stream, chunkSize);
	let bytes$1 = 0;
	let done;
	let _onFinish = (e) => {
		if (!done) {
			done = true;
			onFinish && onFinish(e);
		}
	};
	return new ReadableStream({
		async pull(controller) {
			try {
				const { done: done$1, value } = await iterator$1.next();
				if (done$1) {
					_onFinish();
					controller.close();
					return;
				}
				let len = value.byteLength;
				if (onProgress) onProgress(bytes$1 += len);
				controller.enqueue(new Uint8Array(value));
			} catch (err) {
				_onFinish(err);
				throw err;
			}
		},
		cancel(reason) {
			_onFinish(reason);
			return iterator$1.return();
		}
	}, { highWaterMark: 2 });
};

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/adapters/fetch.js
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const { isFunction } = utils_default;
const globalFetchAPI = (({ Request, Response }) => ({
	Request,
	Response
}))(utils_default.global);
const { ReadableStream: ReadableStream$1, TextEncoder: TextEncoder$1 } = utils_default.global;
const test = (fn, ...args) => {
	try {
		return !!fn(...args);
	} catch (e) {
		return false;
	}
};
const factory = (env$1) => {
	env$1 = utils_default.merge.call({ skipUndefined: true }, globalFetchAPI, env$1);
	const { fetch: envFetch, Request, Response } = env$1;
	const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === "function";
	const isRequestSupported = isFunction(Request);
	const isResponseSupported = isFunction(Response);
	if (!isFetchSupported) return false;
	const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream$1);
	const encodeText = isFetchSupported && (typeof TextEncoder$1 === "function" ? ((encoder) => (str) => encoder.encode(str))(new TextEncoder$1()) : async (str) => new Uint8Array(await new Request(str).arrayBuffer()));
	const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
		let duplexAccessed = false;
		const hasContentType = new Request(platform_default.origin, {
			body: new ReadableStream$1(),
			method: "POST",
			get duplex() {
				duplexAccessed = true;
				return "half";
			}
		}).headers.has("Content-Type");
		return duplexAccessed && !hasContentType;
	});
	const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
	const resolvers = { stream: supportsResponseStream && ((res) => res.body) };
	isFetchSupported && [
		"text",
		"arrayBuffer",
		"blob",
		"formData",
		"stream"
	].forEach((type$1) => {
		!resolvers[type$1] && (resolvers[type$1] = (res, config$2) => {
			let method = res && res[type$1];
			if (method) return method.call(res);
			throw new AxiosError_default(`Response type '${type$1}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config$2);
		});
	});
	const getBodyLength = async (body) => {
		if (body == null) return 0;
		if (utils_default.isBlob(body)) return body.size;
		if (utils_default.isSpecCompliantForm(body)) return (await new Request(platform_default.origin, {
			method: "POST",
			body
		}).arrayBuffer()).byteLength;
		if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) return body.byteLength;
		if (utils_default.isURLSearchParams(body)) body = body + "";
		if (utils_default.isString(body)) return (await encodeText(body)).byteLength;
	};
	const resolveBodyLength = async (headers, body) => {
		const length = utils_default.toFiniteNumber(headers.getContentLength());
		return length == null ? getBodyLength(body) : length;
	};
	return async (config$2) => {
		let { url: url$1, method, data: data$1, signal, cancelToken, timeout, onDownloadProgress, onUploadProgress, responseType, headers, withCredentials = "same-origin", fetchOptions } = resolveConfig_default(config$2);
		let _fetch = envFetch || fetch;
		responseType = responseType ? (responseType + "").toLowerCase() : "text";
		let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
		let request$2 = null;
		const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
			composedSignal.unsubscribe();
		});
		let requestContentLength;
		try {
			if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data$1)) !== 0) {
				let _request = new Request(url$1, {
					method: "POST",
					body: data$1,
					duplex: "half"
				});
				let contentTypeHeader;
				if (utils_default.isFormData(data$1) && (contentTypeHeader = _request.headers.get("content-type"))) headers.setContentType(contentTypeHeader);
				if (_request.body) {
					const [onProgress, flush] = progressEventDecorator(requestContentLength, progressEventReducer(asyncDecorator(onUploadProgress)));
					data$1 = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
				}
			}
			if (!utils_default.isString(withCredentials)) withCredentials = withCredentials ? "include" : "omit";
			const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
			const resolvedOptions = {
				...fetchOptions,
				signal: composedSignal,
				method: method.toUpperCase(),
				headers: headers.normalize().toJSON(),
				body: data$1,
				duplex: "half",
				credentials: isCredentialsSupported ? withCredentials : void 0
			};
			request$2 = isRequestSupported && new Request(url$1, resolvedOptions);
			let response$2 = await (isRequestSupported ? _fetch(request$2, fetchOptions) : _fetch(url$1, resolvedOptions));
			const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
			if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
				const options = {};
				[
					"status",
					"statusText",
					"headers"
				].forEach((prop) => {
					options[prop] = response$2[prop];
				});
				const responseContentLength = utils_default.toFiniteNumber(response$2.headers.get("content-length"));
				const [onProgress, flush] = onDownloadProgress && progressEventDecorator(responseContentLength, progressEventReducer(asyncDecorator(onDownloadProgress), true)) || [];
				response$2 = new Response(trackStream(response$2.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
					flush && flush();
					unsubscribe && unsubscribe();
				}), options);
			}
			responseType = responseType || "text";
			let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response$2, config$2);
			!isStreamResponse && unsubscribe && unsubscribe();
			return await new Promise((resolve, reject) => {
				settle(resolve, reject, {
					data: responseData,
					headers: AxiosHeaders_default.from(response$2.headers),
					status: response$2.status,
					statusText: response$2.statusText,
					config: config$2,
					request: request$2
				});
			});
		} catch (err) {
			unsubscribe && unsubscribe();
			if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) throw Object.assign(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config$2, request$2), { cause: err.cause || err });
			throw AxiosError_default.from(err, err && err.code, config$2, request$2);
		}
	};
};
const seedCache = /* @__PURE__ */ new Map();
const getFetch = (config$2) => {
	let env$1 = config$2 ? config$2.env : {};
	const { fetch: fetch$1, Request, Response } = env$1;
	const seeds = [
		Request,
		Response,
		fetch$1
	];
	let i = seeds.length, seed, target, map = seedCache;
	while (i--) {
		seed = seeds[i];
		target = map.get(seed);
		target === void 0 && map.set(seed, target = i ? /* @__PURE__ */ new Map() : factory(env$1));
		map = target;
	}
	return target;
};
const adapter = getFetch();

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/adapters/adapters.js
const knownAdapters = {
	http: http_default,
	xhr: xhr_default,
	fetch: { get: getFetch }
};
utils_default.forEach(knownAdapters, (fn, value) => {
	if (fn) {
		try {
			Object.defineProperty(fn, "name", { value });
		} catch (e) {}
		Object.defineProperty(fn, "adapterName", { value });
	}
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter$1) => utils_default.isFunction(adapter$1) || adapter$1 === null || adapter$1 === false;
var adapters_default = {
	getAdapter: (adapters$1, config$2) => {
		adapters$1 = utils_default.isArray(adapters$1) ? adapters$1 : [adapters$1];
		const { length } = adapters$1;
		let nameOrAdapter;
		let adapter$1;
		const rejectedReasons = {};
		for (let i = 0; i < length; i++) {
			nameOrAdapter = adapters$1[i];
			let id;
			adapter$1 = nameOrAdapter;
			if (!isResolvedHandle(nameOrAdapter)) {
				adapter$1 = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
				if (adapter$1 === void 0) throw new AxiosError_default(`Unknown adapter '${id}'`);
			}
			if (adapter$1 && (utils_default.isFunction(adapter$1) || (adapter$1 = adapter$1.get(config$2)))) break;
			rejectedReasons[id || "#" + i] = adapter$1;
		}
		if (!adapter$1) {
			const reasons = Object.entries(rejectedReasons).map(([id, state$1]) => `adapter ${id} ` + (state$1 === false ? "is not supported by the environment" : "is not available in the build"));
			throw new AxiosError_default(`There is no suitable adapter to dispatch the request ` + (length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified"), "ERR_NOT_SUPPORT");
		}
		return adapter$1;
	},
	adapters: knownAdapters
};

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/core/dispatchRequest.js
/**
* Throws a `CanceledError` if cancellation has been requested.
*
* @param {Object} config The config that is to be used for the request
*
* @returns {void}
*/
function throwIfCancellationRequested(config$2) {
	if (config$2.cancelToken) config$2.cancelToken.throwIfRequested();
	if (config$2.signal && config$2.signal.aborted) throw new CanceledError_default(null, config$2);
}
/**
* Dispatch a request to the server using the configured adapter.
*
* @param {object} config The config that is to be used for the request
*
* @returns {Promise} The Promise to be fulfilled
*/
function dispatchRequest(config$2) {
	throwIfCancellationRequested(config$2);
	config$2.headers = AxiosHeaders_default.from(config$2.headers);
	config$2.data = transformData.call(config$2, config$2.transformRequest);
	if ([
		"post",
		"put",
		"patch"
	].indexOf(config$2.method) !== -1) config$2.headers.setContentType("application/x-www-form-urlencoded", false);
	return adapters_default.getAdapter(config$2.adapter || defaults_default.adapter, config$2)(config$2).then(function onAdapterResolution(response$2) {
		throwIfCancellationRequested(config$2);
		response$2.data = transformData.call(config$2, config$2.transformResponse, response$2);
		response$2.headers = AxiosHeaders_default.from(response$2.headers);
		return response$2;
	}, function onAdapterRejection(reason) {
		if (!isCancel$1(reason)) {
			throwIfCancellationRequested(config$2);
			if (reason && reason.response) {
				reason.response.data = transformData.call(config$2, config$2.transformResponse, reason.response);
				reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
			}
		}
		return Promise.reject(reason);
	});
}

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/validator.js
const validators$1 = {};
[
	"object",
	"boolean",
	"number",
	"function",
	"string",
	"symbol"
].forEach((type$1, i) => {
	validators$1[type$1] = function validator(thing) {
		return typeof thing === type$1 || "a" + (i < 1 ? "n " : " ") + type$1;
	};
});
const deprecatedWarnings = {};
/**
* Transitional option validator
*
* @param {function|boolean?} validator - set to false if the transitional option has been removed
* @param {string?} version - deprecated version / removed since version
* @param {string?} message - some message with additional info
*
* @returns {function}
*/
validators$1.transitional = function transitional(validator, version$1, message) {
	function formatMessage(opt, desc$1) {
		return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc$1 + (message ? ". " + message : "");
	}
	return (value, opt, opts) => {
		if (validator === false) throw new AxiosError_default(formatMessage(opt, " has been removed" + (version$1 ? " in " + version$1 : "")), AxiosError_default.ERR_DEPRECATED);
		if (version$1 && !deprecatedWarnings[opt]) {
			deprecatedWarnings[opt] = true;
			console.warn(formatMessage(opt, " has been deprecated since v" + version$1 + " and will be removed in the near future"));
		}
		return validator ? validator(value, opt, opts) : true;
	};
};
validators$1.spelling = function spelling(correctSpelling) {
	return (value, opt) => {
		console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
		return true;
	};
};
/**
* Assert object's properties type
*
* @param {object} options
* @param {object} schema
* @param {boolean?} allowUnknown
*
* @returns {object}
*/
function assertOptions(options, schema, allowUnknown) {
	if (typeof options !== "object") throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
	const keys = Object.keys(options);
	let i = keys.length;
	while (i-- > 0) {
		const opt = keys[i];
		const validator = schema[opt];
		if (validator) {
			const value = options[opt];
			const result = value === void 0 || validator(value, opt, options);
			if (result !== true) throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
			continue;
		}
		if (allowUnknown !== true) throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
	}
}
var validator_default = {
	assertOptions,
	validators: validators$1
};

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/core/Axios.js
const validators = validator_default.validators;
/**
* Create a new instance of Axios
*
* @param {Object} instanceConfig The default config for the instance
*
* @return {Axios} A new instance of Axios
*/
var Axios$1 = class {
	constructor(instanceConfig) {
		this.defaults = instanceConfig || {};
		this.interceptors = {
			request: new InterceptorManager_default(),
			response: new InterceptorManager_default()
		};
	}
	/**
	* Dispatch a request
	*
	* @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
	* @param {?Object} config
	*
	* @returns {Promise} The Promise to be fulfilled
	*/
	async request(configOrUrl, config$2) {
		try {
			return await this._request(configOrUrl, config$2);
		} catch (err) {
			if (err instanceof Error) {
				let dummy = {};
				Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = /* @__PURE__ */ new Error();
				const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
				try {
					if (!err.stack) err.stack = stack;
					else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) err.stack += "\n" + stack;
				} catch (e) {}
			}
			throw err;
		}
	}
	_request(configOrUrl, config$2) {
		if (typeof configOrUrl === "string") {
			config$2 = config$2 || {};
			config$2.url = configOrUrl;
		} else config$2 = configOrUrl || {};
		config$2 = mergeConfig$1(this.defaults, config$2);
		const { transitional, paramsSerializer, headers } = config$2;
		if (transitional !== void 0) validator_default.assertOptions(transitional, {
			silentJSONParsing: validators.transitional(validators.boolean),
			forcedJSONParsing: validators.transitional(validators.boolean),
			clarifyTimeoutError: validators.transitional(validators.boolean)
		}, false);
		if (paramsSerializer != null) if (utils_default.isFunction(paramsSerializer)) config$2.paramsSerializer = { serialize: paramsSerializer };
		else validator_default.assertOptions(paramsSerializer, {
			encode: validators.function,
			serialize: validators.function
		}, true);
		if (config$2.allowAbsoluteUrls !== void 0) {} else if (this.defaults.allowAbsoluteUrls !== void 0) config$2.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
		else config$2.allowAbsoluteUrls = true;
		validator_default.assertOptions(config$2, {
			baseUrl: validators.spelling("baseURL"),
			withXsrfToken: validators.spelling("withXSRFToken")
		}, true);
		config$2.method = (config$2.method || this.defaults.method || "get").toLowerCase();
		let contextHeaders = headers && utils_default.merge(headers.common, headers[config$2.method]);
		headers && utils_default.forEach([
			"delete",
			"get",
			"head",
			"post",
			"put",
			"patch",
			"common"
		], (method) => {
			delete headers[method];
		});
		config$2.headers = AxiosHeaders_default.concat(contextHeaders, headers);
		const requestInterceptorChain = [];
		let synchronousRequestInterceptors = true;
		this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
			if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config$2) === false) return;
			synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
			requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
		});
		const responseInterceptorChain = [];
		this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
			responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
		});
		let promise;
		let i = 0;
		let len;
		if (!synchronousRequestInterceptors) {
			const chain = [dispatchRequest.bind(this), void 0];
			chain.unshift(...requestInterceptorChain);
			chain.push(...responseInterceptorChain);
			len = chain.length;
			promise = Promise.resolve(config$2);
			while (i < len) promise = promise.then(chain[i++], chain[i++]);
			return promise;
		}
		len = requestInterceptorChain.length;
		let newConfig = config$2;
		while (i < len) {
			const onFulfilled = requestInterceptorChain[i++];
			const onRejected = requestInterceptorChain[i++];
			try {
				newConfig = onFulfilled(newConfig);
			} catch (error) {
				onRejected.call(this, error);
				break;
			}
		}
		try {
			promise = dispatchRequest.call(this, newConfig);
		} catch (error) {
			return Promise.reject(error);
		}
		i = 0;
		len = responseInterceptorChain.length;
		while (i < len) promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
		return promise;
	}
	getUri(config$2) {
		config$2 = mergeConfig$1(this.defaults, config$2);
		return buildURL(buildFullPath(config$2.baseURL, config$2.url, config$2.allowAbsoluteUrls), config$2.params, config$2.paramsSerializer);
	}
};
utils_default.forEach([
	"delete",
	"get",
	"head",
	"options"
], function forEachMethodNoData(method) {
	Axios$1.prototype[method] = function(url$1, config$2) {
		return this.request(mergeConfig$1(config$2 || {}, {
			method,
			url: url$1,
			data: (config$2 || {}).data
		}));
	};
});
utils_default.forEach([
	"post",
	"put",
	"patch"
], function forEachMethodWithData(method) {
	function generateHTTPMethod(isForm) {
		return function httpMethod(url$1, data$1, config$2) {
			return this.request(mergeConfig$1(config$2 || {}, {
				method,
				headers: isForm ? { "Content-Type": "multipart/form-data" } : {},
				url: url$1,
				data: data$1
			}));
		};
	}
	Axios$1.prototype[method] = generateHTTPMethod();
	Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios$1;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/cancel/CancelToken.js
/**
* A `CancelToken` is an object that can be used to request cancellation of an operation.
*
* @param {Function} executor The executor function.
*
* @returns {CancelToken}
*/
var CancelToken$1 = class CancelToken$1 {
	constructor(executor) {
		if (typeof executor !== "function") throw new TypeError("executor must be a function.");
		let resolvePromise;
		this.promise = new Promise(function promiseExecutor(resolve) {
			resolvePromise = resolve;
		});
		const token = this;
		this.promise.then((cancel) => {
			if (!token._listeners) return;
			let i = token._listeners.length;
			while (i-- > 0) token._listeners[i](cancel);
			token._listeners = null;
		});
		this.promise.then = (onfulfilled) => {
			let _resolve;
			const promise = new Promise((resolve) => {
				token.subscribe(resolve);
				_resolve = resolve;
			}).then(onfulfilled);
			promise.cancel = function reject() {
				token.unsubscribe(_resolve);
			};
			return promise;
		};
		executor(function cancel(message, config$2, request$2) {
			if (token.reason) return;
			token.reason = new CanceledError_default(message, config$2, request$2);
			resolvePromise(token.reason);
		});
	}
	/**
	* Throws a `CanceledError` if cancellation has been requested.
	*/
	throwIfRequested() {
		if (this.reason) throw this.reason;
	}
	/**
	* Subscribe to the cancel signal
	*/
	subscribe(listener) {
		if (this.reason) {
			listener(this.reason);
			return;
		}
		if (this._listeners) this._listeners.push(listener);
		else this._listeners = [listener];
	}
	/**
	* Unsubscribe from the cancel signal
	*/
	unsubscribe(listener) {
		if (!this._listeners) return;
		const index$1 = this._listeners.indexOf(listener);
		if (index$1 !== -1) this._listeners.splice(index$1, 1);
	}
	toAbortSignal() {
		const controller = new AbortController();
		const abort$3 = (err) => {
			controller.abort(err);
		};
		this.subscribe(abort$3);
		controller.signal.unsubscribe = () => this.unsubscribe(abort$3);
		return controller.signal;
	}
	/**
	* Returns an object that contains a new `CancelToken` and a function that, when called,
	* cancels the `CancelToken`.
	*/
	static source() {
		let cancel;
		return {
			token: new CancelToken$1(function executor(c) {
				cancel = c;
			}),
			cancel
		};
	}
};
var CancelToken_default = CancelToken$1;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/spread.js
/**
* Syntactic sugar for invoking a function and expanding an array for arguments.
*
* Common use case would be to use `Function.prototype.apply`.
*
*  ```js
*  function f(x, y, z) {}
*  var args = [1, 2, 3];
*  f.apply(null, args);
*  ```
*
* With `spread` this example can be re-written.
*
*  ```js
*  spread(function(x, y, z) {})([1, 2, 3]);
*  ```
*
* @param {Function} callback
*
* @returns {Function}
*/
function spread$1(callback) {
	return function wrap$1(arr) {
		return callback.apply(null, arr);
	};
}

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/isAxiosError.js
/**
* Determines whether the payload is an error thrown by Axios
*
* @param {*} payload The value to test
*
* @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
*/
function isAxiosError$1(payload) {
	return utils_default.isObject(payload) && payload.isAxiosError === true;
}

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/helpers/HttpStatusCode.js
const HttpStatusCode$1 = {
	Continue: 100,
	SwitchingProtocols: 101,
	Processing: 102,
	EarlyHints: 103,
	Ok: 200,
	Created: 201,
	Accepted: 202,
	NonAuthoritativeInformation: 203,
	NoContent: 204,
	ResetContent: 205,
	PartialContent: 206,
	MultiStatus: 207,
	AlreadyReported: 208,
	ImUsed: 226,
	MultipleChoices: 300,
	MovedPermanently: 301,
	Found: 302,
	SeeOther: 303,
	NotModified: 304,
	UseProxy: 305,
	Unused: 306,
	TemporaryRedirect: 307,
	PermanentRedirect: 308,
	BadRequest: 400,
	Unauthorized: 401,
	PaymentRequired: 402,
	Forbidden: 403,
	NotFound: 404,
	MethodNotAllowed: 405,
	NotAcceptable: 406,
	ProxyAuthenticationRequired: 407,
	RequestTimeout: 408,
	Conflict: 409,
	Gone: 410,
	LengthRequired: 411,
	PreconditionFailed: 412,
	PayloadTooLarge: 413,
	UriTooLong: 414,
	UnsupportedMediaType: 415,
	RangeNotSatisfiable: 416,
	ExpectationFailed: 417,
	ImATeapot: 418,
	MisdirectedRequest: 421,
	UnprocessableEntity: 422,
	Locked: 423,
	FailedDependency: 424,
	TooEarly: 425,
	UpgradeRequired: 426,
	PreconditionRequired: 428,
	TooManyRequests: 429,
	RequestHeaderFieldsTooLarge: 431,
	UnavailableForLegalReasons: 451,
	InternalServerError: 500,
	NotImplemented: 501,
	BadGateway: 502,
	ServiceUnavailable: 503,
	GatewayTimeout: 504,
	HttpVersionNotSupported: 505,
	VariantAlsoNegotiates: 506,
	InsufficientStorage: 507,
	LoopDetected: 508,
	NotExtended: 510,
	NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
	HttpStatusCode$1[value] = key;
});
var HttpStatusCode_default = HttpStatusCode$1;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/lib/axios.js
/**
* Create an instance of Axios
*
* @param {Object} defaultConfig The default config for the instance
*
* @returns {Axios} A new instance of Axios
*/
function createInstance(defaultConfig) {
	const context = new Axios_default(defaultConfig);
	const instance = bind(Axios_default.prototype.request, context);
	utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
	utils_default.extend(instance, context, null, { allOwnKeys: true });
	instance.create = function create(instanceConfig) {
		return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
	};
	return instance;
}
const axios$1 = createInstance(defaults_default);
axios$1.Axios = Axios_default;
axios$1.CanceledError = CanceledError_default;
axios$1.CancelToken = CancelToken_default;
axios$1.isCancel = isCancel$1;
axios$1.VERSION = VERSION$1;
axios$1.toFormData = toFormData_default;
axios$1.AxiosError = AxiosError_default;
axios$1.Cancel = axios$1.CanceledError;
axios$1.all = function all$1(promises) {
	return Promise.all(promises);
};
axios$1.spread = spread$1;
axios$1.isAxiosError = isAxiosError$1;
axios$1.mergeConfig = mergeConfig$1;
axios$1.AxiosHeaders = AxiosHeaders_default;
axios$1.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios$1.getAdapter = adapters_default.getAdapter;
axios$1.HttpStatusCode = HttpStatusCode_default;
axios$1.default = axios$1;
var axios_default = axios$1;

//#endregion
//#region ../../node_modules/.pnpm/axios@1.12.2_debug@4.4.1/node_modules/axios/index.js
const { Axios, AxiosError: AxiosError$1, CanceledError, isCancel, CancelToken, VERSION, all, Cancel, isAxiosError, spread, toFormData, AxiosHeaders, HttpStatusCode, formToJSON, getAdapter, mergeConfig } = axios_default;

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/core.js
/** A special constant with type `never` */
const NEVER = Object.freeze({ status: "aborted" });
function $constructor(name, initializer$2, params) {
	function init$1(inst, def) {
		var _a;
		Object.defineProperty(inst, "_zod", {
			value: inst._zod ?? {},
			enumerable: false
		});
		(_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set());
		inst._zod.traits.add(name);
		initializer$2(inst, def);
		for (const k in _.prototype) if (!(k in inst)) Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
		inst._zod.constr = _;
		inst._zod.def = def;
	}
	const Parent = params?.Parent ?? Object;
	class Definition extends Parent {}
	Object.defineProperty(Definition, "name", { value: name });
	function _(def) {
		var _a;
		const inst = params?.Parent ? new Definition() : this;
		init$1(inst, def);
		(_a = inst._zod).deferred ?? (_a.deferred = []);
		for (const fn of inst._zod.deferred) fn();
		return inst;
	}
	Object.defineProperty(_, "init", { value: init$1 });
	Object.defineProperty(_, Symbol.hasInstance, { value: (inst) => {
		if (params?.Parent && inst instanceof params.Parent) return true;
		return inst?._zod?.traits?.has(name);
	} });
	Object.defineProperty(_, "name", { value: name });
	return _;
}
const $brand = Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
	constructor() {
		super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
	}
};
var $ZodEncodeError = class extends Error {
	constructor(name) {
		super(`Encountered unidirectional transform during encode: ${name}`);
		this.name = "ZodEncodeError";
	}
};
const globalConfig = {};
function config$1(newConfig) {
	if (newConfig) Object.assign(globalConfig, newConfig);
	return globalConfig;
}

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/util.js
function getEnumValues(entries) {
	const numericValues = Object.values(entries).filter((v) => typeof v === "number");
	return Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
}
function jsonStringifyReplacer(_, value) {
	if (typeof value === "bigint") return value.toString();
	return value;
}
function cached(getter) {
	return { get value() {
		{
			const value = getter();
			Object.defineProperty(this, "value", { value });
			return value;
		}
		throw new Error("cached value already set");
	} };
}
function nullish(input) {
	return input === null || input === void 0;
}
function cleanRegex(source) {
	const start = source.startsWith("^") ? 1 : 0;
	const end = source.endsWith("$") ? source.length - 1 : source.length;
	return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
	const valDecCount = (val.toString().split(".")[1] || "").length;
	const stepString = step.toString();
	let stepDecCount = (stepString.split(".")[1] || "").length;
	if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
		const match = stepString.match(/\d?e-(\d?)/);
		if (match?.[1]) stepDecCount = Number.parseInt(match[1]);
	}
	const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
	return Number.parseInt(val.toFixed(decCount).replace(".", "")) % Number.parseInt(step.toFixed(decCount).replace(".", "")) / 10 ** decCount;
}
const EVALUATING = Symbol("evaluating");
function defineLazy(object$1, key, getter) {
	let value = void 0;
	Object.defineProperty(object$1, key, {
		get() {
			if (value === EVALUATING) return;
			if (value === void 0) {
				value = EVALUATING;
				value = getter();
			}
			return value;
		},
		set(v) {
			Object.defineProperty(object$1, key, { value: v });
		},
		configurable: true
	});
}
function assignProp(target, prop, value) {
	Object.defineProperty(target, prop, {
		value,
		writable: true,
		enumerable: true,
		configurable: true
	});
}
function mergeDefs(...defs) {
	const mergedDescriptors = {};
	for (const def of defs) {
		const descriptors$1 = Object.getOwnPropertyDescriptors(def);
		Object.assign(mergedDescriptors, descriptors$1);
	}
	return Object.defineProperties({}, mergedDescriptors);
}
function esc(str) {
	return JSON.stringify(str);
}
const captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};
function isObject(data$1) {
	return typeof data$1 === "object" && data$1 !== null && !Array.isArray(data$1);
}
const allowsEval = cached(() => {
	if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) return false;
	try {
		new Function("");
		return true;
	} catch (_) {
		return false;
	}
});
function isPlainObject(o) {
	if (isObject(o) === false) return false;
	const ctor = o.constructor;
	if (ctor === void 0) return true;
	const prot = ctor.prototype;
	if (isObject(prot) === false) return false;
	if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) return false;
	return true;
}
function shallowClone(o) {
	if (isPlainObject(o)) return { ...o };
	if (Array.isArray(o)) return [...o];
	return o;
}
const propertyKeyTypes = new Set([
	"string",
	"number",
	"symbol"
]);
function escapeRegex(str) {
	return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
	const cl = new inst._zod.constr(def ?? inst._zod.def);
	if (!def || params?.parent) cl._zod.parent = inst;
	return cl;
}
function normalizeParams(_params) {
	const params = _params;
	if (!params) return {};
	if (typeof params === "string") return { error: () => params };
	if (params?.message !== void 0) {
		if (params?.error !== void 0) throw new Error("Cannot specify both `message` and `error` params");
		params.error = params.message;
	}
	delete params.message;
	if (typeof params.error === "string") return {
		...params,
		error: () => params.error
	};
	return params;
}
function optionalKeys(shape) {
	return Object.keys(shape).filter((k) => {
		return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
	});
}
const NUMBER_FORMAT_RANGES = {
	safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
	int32: [-2147483648, 2147483647],
	uint32: [0, 4294967295],
	float32: [-34028234663852886e22, 34028234663852886e22],
	float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function pick(schema, mask) {
	const currDef = schema._zod.def;
	return clone(schema, mergeDefs(schema._zod.def, {
		get shape() {
			const newShape = {};
			for (const key in mask) {
				if (!(key in currDef.shape)) throw new Error(`Unrecognized key: "${key}"`);
				if (!mask[key]) continue;
				newShape[key] = currDef.shape[key];
			}
			assignProp(this, "shape", newShape);
			return newShape;
		},
		checks: []
	}));
}
function omit(schema, mask) {
	const currDef = schema._zod.def;
	return clone(schema, mergeDefs(schema._zod.def, {
		get shape() {
			const newShape = { ...schema._zod.def.shape };
			for (const key in mask) {
				if (!(key in currDef.shape)) throw new Error(`Unrecognized key: "${key}"`);
				if (!mask[key]) continue;
				delete newShape[key];
			}
			assignProp(this, "shape", newShape);
			return newShape;
		},
		checks: []
	}));
}
function extend(schema, shape) {
	if (!isPlainObject(shape)) throw new Error("Invalid input to extend: expected a plain object");
	const checks = schema._zod.def.checks;
	if (checks && checks.length > 0) throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
	return clone(schema, mergeDefs(schema._zod.def, {
		get shape() {
			const _shape = {
				...schema._zod.def.shape,
				...shape
			};
			assignProp(this, "shape", _shape);
			return _shape;
		},
		checks: []
	}));
}
function safeExtend(schema, shape) {
	if (!isPlainObject(shape)) throw new Error("Invalid input to safeExtend: expected a plain object");
	return clone(schema, {
		...schema._zod.def,
		get shape() {
			const _shape = {
				...schema._zod.def.shape,
				...shape
			};
			assignProp(this, "shape", _shape);
			return _shape;
		},
		checks: schema._zod.def.checks
	});
}
function merge(a, b) {
	return clone(a, mergeDefs(a._zod.def, {
		get shape() {
			const _shape = {
				...a._zod.def.shape,
				...b._zod.def.shape
			};
			assignProp(this, "shape", _shape);
			return _shape;
		},
		get catchall() {
			return b._zod.def.catchall;
		},
		checks: []
	}));
}
function partial(Class, schema, mask) {
	return clone(schema, mergeDefs(schema._zod.def, {
		get shape() {
			const oldShape = schema._zod.def.shape;
			const shape = { ...oldShape };
			if (mask) for (const key in mask) {
				if (!(key in oldShape)) throw new Error(`Unrecognized key: "${key}"`);
				if (!mask[key]) continue;
				shape[key] = Class ? new Class({
					type: "optional",
					innerType: oldShape[key]
				}) : oldShape[key];
			}
			else for (const key in oldShape) shape[key] = Class ? new Class({
				type: "optional",
				innerType: oldShape[key]
			}) : oldShape[key];
			assignProp(this, "shape", shape);
			return shape;
		},
		checks: []
	}));
}
function required(Class, schema, mask) {
	return clone(schema, mergeDefs(schema._zod.def, {
		get shape() {
			const oldShape = schema._zod.def.shape;
			const shape = { ...oldShape };
			if (mask) for (const key in mask) {
				if (!(key in shape)) throw new Error(`Unrecognized key: "${key}"`);
				if (!mask[key]) continue;
				shape[key] = new Class({
					type: "nonoptional",
					innerType: oldShape[key]
				});
			}
			else for (const key in oldShape) shape[key] = new Class({
				type: "nonoptional",
				innerType: oldShape[key]
			});
			assignProp(this, "shape", shape);
			return shape;
		},
		checks: []
	}));
}
function aborted(x, startIndex = 0) {
	if (x.aborted === true) return true;
	for (let i = startIndex; i < x.issues.length; i++) if (x.issues[i]?.continue !== true) return true;
	return false;
}
function prefixIssues(path$3, issues) {
	return issues.map((iss) => {
		var _a;
		(_a = iss).path ?? (_a.path = []);
		iss.path.unshift(path$3);
		return iss;
	});
}
function unwrapMessage(message) {
	return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config$2) {
	const full = {
		...iss,
		path: iss.path ?? []
	};
	if (!iss.message) full.message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config$2.customError?.(iss)) ?? unwrapMessage(config$2.localeError?.(iss)) ?? "Invalid input";
	delete full.inst;
	delete full.continue;
	if (!ctx?.reportInput) delete full.input;
	return full;
}
function getLengthableOrigin(input) {
	if (Array.isArray(input)) return "array";
	if (typeof input === "string") return "string";
	return "unknown";
}
function issue(...args) {
	const [iss, input, inst] = args;
	if (typeof iss === "string") return {
		message: iss,
		code: "custom",
		input,
		inst
	};
	return { ...iss };
}

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/errors.js
const initializer$1 = (inst, def) => {
	inst.name = "$ZodError";
	Object.defineProperty(inst, "_zod", {
		value: inst._zod,
		enumerable: false
	});
	Object.defineProperty(inst, "issues", {
		value: def,
		enumerable: false
	});
	inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
	Object.defineProperty(inst, "toString", {
		value: () => inst.message,
		enumerable: false
	});
};
const $ZodError = $constructor("$ZodError", initializer$1);
const $ZodRealError = $constructor("$ZodError", initializer$1, { Parent: Error });
function flattenError(error, mapper = (issue$1) => issue$1.message) {
	const fieldErrors = {};
	const formErrors = [];
	for (const sub of error.issues) if (sub.path.length > 0) {
		fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
		fieldErrors[sub.path[0]].push(mapper(sub));
	} else formErrors.push(mapper(sub));
	return {
		formErrors,
		fieldErrors
	};
}
function formatError(error, mapper = (issue$1) => issue$1.message) {
	const fieldErrors = { _errors: [] };
	const processError = (error$1) => {
		for (const issue$1 of error$1.issues) if (issue$1.code === "invalid_union" && issue$1.errors.length) issue$1.errors.map((issues) => processError({ issues }));
		else if (issue$1.code === "invalid_key") processError({ issues: issue$1.issues });
		else if (issue$1.code === "invalid_element") processError({ issues: issue$1.issues });
		else if (issue$1.path.length === 0) fieldErrors._errors.push(mapper(issue$1));
		else {
			let curr = fieldErrors;
			let i = 0;
			while (i < issue$1.path.length) {
				const el = issue$1.path[i];
				if (!(i === issue$1.path.length - 1)) curr[el] = curr[el] || { _errors: [] };
				else {
					curr[el] = curr[el] || { _errors: [] };
					curr[el]._errors.push(mapper(issue$1));
				}
				curr = curr[el];
				i++;
			}
		}
	};
	processError(error);
	return fieldErrors;
}

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/parse.js
const _parse = (_Err) => (schema, value, _ctx, _params) => {
	const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
	const result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) throw new $ZodAsyncError();
	if (result.issues.length) {
		const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config$1())));
		captureStackTrace(e, _params?.callee);
		throw e;
	}
	return result.value;
};
const parse$2 = /* @__PURE__ */ _parse($ZodRealError);
const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
	const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
	let result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) result = await result;
	if (result.issues.length) {
		const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config$1())));
		captureStackTrace(e, params?.callee);
		throw e;
	}
	return result.value;
};
const parseAsync$1 = /* @__PURE__ */ _parseAsync($ZodRealError);
const _safeParse = (_Err) => (schema, value, _ctx) => {
	const ctx = _ctx ? {
		..._ctx,
		async: false
	} : { async: false };
	const result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) throw new $ZodAsyncError();
	return result.issues.length ? {
		success: false,
		error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config$1())))
	} : {
		success: true,
		data: result.value
	};
};
const safeParse$1 = /* @__PURE__ */ _safeParse($ZodRealError);
const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
	let result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) result = await result;
	return result.issues.length ? {
		success: false,
		error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config$1())))
	} : {
		success: true,
		data: result.value
	};
};
const safeParseAsync$1 = /* @__PURE__ */ _safeParseAsync($ZodRealError);
const _encode = (_Err) => (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _parse(_Err)(schema, value, ctx);
};
const encode$1 = /* @__PURE__ */ _encode($ZodRealError);
const _decode = (_Err) => (schema, value, _ctx) => {
	return _parse(_Err)(schema, value, _ctx);
};
const decode$1 = /* @__PURE__ */ _decode($ZodRealError);
const _encodeAsync = (_Err) => async (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _parseAsync(_Err)(schema, value, ctx);
};
const encodeAsync$1 = /* @__PURE__ */ _encodeAsync($ZodRealError);
const _decodeAsync = (_Err) => async (schema, value, _ctx) => {
	return _parseAsync(_Err)(schema, value, _ctx);
};
const decodeAsync$1 = /* @__PURE__ */ _decodeAsync($ZodRealError);
const _safeEncode = (_Err) => (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _safeParse(_Err)(schema, value, ctx);
};
const safeEncode$1 = /* @__PURE__ */ _safeEncode($ZodRealError);
const _safeDecode = (_Err) => (schema, value, _ctx) => {
	return _safeParse(_Err)(schema, value, _ctx);
};
const safeDecode$1 = /* @__PURE__ */ _safeDecode($ZodRealError);
const _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _safeParseAsync(_Err)(schema, value, ctx);
};
const safeEncodeAsync$1 = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
const _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
	return _safeParseAsync(_Err)(schema, value, _ctx);
};
const safeDecodeAsync$1 = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/regexes.js
const cuid = /^[cC][^\s-]{8,}$/;
const cuid2 = /^[0-9a-z]+$/;
const ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
const xid = /^[0-9a-vA-V]{20}$/;
const ksuid = /^[A-Za-z0-9]{27}$/;
const nanoid = /^[a-zA-Z0-9_-]{21}$/;
/** ISO 8601-1 duration regex. Does not support the 8601-2 extensions like negative durations or fractional/negative components. */
const duration$1 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
/** A regex for any UUID-like identifier: 8-4-4-4-12 hex pattern */
const guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
/** Returns a regex for validating an RFC 9562/4122 UUID.
*
* @param version Optionally specify a version 1-8. If no version is specified, all versions are supported. */
const uuid = (version$1) => {
	if (!version$1) return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
	return /* @__PURE__ */ new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version$1}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
/** Practical email validation */
const email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
const _emoji$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
	return new RegExp(_emoji$1, "u");
}
const ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
const cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
const cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
const base64url = /^[A-Za-z0-9_-]*$/;
const hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
const e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
const dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
const date$1 = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
	const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
	return typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function time$1(args) {
	return /* @__PURE__ */ new RegExp(`^${timeSource(args)}$`);
}
function datetime$1(args) {
	const time$2 = timeSource({ precision: args.precision });
	const opts = ["Z"];
	if (args.local) opts.push("");
	if (args.offset) opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
	const timeRegex = `${time$2}(?:${opts.join("|")})`;
	return /* @__PURE__ */ new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
const string$1 = (params) => {
	const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
	return /* @__PURE__ */ new RegExp(`^${regex}$`);
};
const integer = /^-?\d+$/;
const number$2 = /^-?\d+(?:\.\d+)?/;
const lowercase = /^[^A-Z]*$/;
const uppercase = /^[^a-z]*$/;

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/checks.js
const $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
	var _a;
	inst._zod ?? (inst._zod = {});
	inst._zod.def = def;
	(_a = inst._zod).onattach ?? (_a.onattach = []);
});
const numericOriginMap = {
	number: "number",
	bigint: "bigint",
	object: "date"
};
const $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
	$ZodCheck.init(inst, def);
	const origin$1 = numericOriginMap[typeof def.value];
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
		if (def.value < curr) if (def.inclusive) bag.maximum = def.value;
		else bag.exclusiveMaximum = def.value;
	});
	inst._zod.check = (payload) => {
		if (def.inclusive ? payload.value <= def.value : payload.value < def.value) return;
		payload.issues.push({
			origin: origin$1,
			code: "too_big",
			maximum: def.value,
			input: payload.value,
			inclusive: def.inclusive,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
	$ZodCheck.init(inst, def);
	const origin$1 = numericOriginMap[typeof def.value];
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
		if (def.value > curr) if (def.inclusive) bag.minimum = def.value;
		else bag.exclusiveMinimum = def.value;
	});
	inst._zod.check = (payload) => {
		if (def.inclusive ? payload.value >= def.value : payload.value > def.value) return;
		payload.issues.push({
			origin: origin$1,
			code: "too_small",
			minimum: def.value,
			input: payload.value,
			inclusive: def.inclusive,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
	$ZodCheck.init(inst, def);
	inst._zod.onattach.push((inst$1) => {
		var _a;
		(_a = inst$1._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
	});
	inst._zod.check = (payload) => {
		if (typeof payload.value !== typeof def.value) throw new Error("Cannot mix number and bigint in multiple_of check.");
		if (typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0) return;
		payload.issues.push({
			origin: typeof payload.value,
			code: "not_multiple_of",
			divisor: def.value,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
	$ZodCheck.init(inst, def);
	def.format = def.format || "float64";
	const isInt = def.format?.includes("int");
	const origin$1 = isInt ? "int" : "number";
	const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.format = def.format;
		bag.minimum = minimum;
		bag.maximum = maximum;
		if (isInt) bag.pattern = integer;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		if (isInt) {
			if (!Number.isInteger(input)) {
				payload.issues.push({
					expected: origin$1,
					format: def.format,
					code: "invalid_type",
					continue: false,
					input,
					inst
				});
				return;
			}
			if (!Number.isSafeInteger(input)) {
				if (input > 0) payload.issues.push({
					input,
					code: "too_big",
					maximum: Number.MAX_SAFE_INTEGER,
					note: "Integers must be within the safe integer range.",
					inst,
					origin: origin$1,
					continue: !def.abort
				});
				else payload.issues.push({
					input,
					code: "too_small",
					minimum: Number.MIN_SAFE_INTEGER,
					note: "Integers must be within the safe integer range.",
					inst,
					origin: origin$1,
					continue: !def.abort
				});
				return;
			}
		}
		if (input < minimum) payload.issues.push({
			origin: "number",
			input,
			code: "too_small",
			minimum,
			inclusive: true,
			inst,
			continue: !def.abort
		});
		if (input > maximum) payload.issues.push({
			origin: "number",
			input,
			code: "too_big",
			maximum,
			inst
		});
	};
});
const $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
	var _a;
	$ZodCheck.init(inst, def);
	(_a = inst._zod.def).when ?? (_a.when = (payload) => {
		const val = payload.value;
		return !nullish(val) && val.length !== void 0;
	});
	inst._zod.onattach.push((inst$1) => {
		const curr = inst$1._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
		if (def.maximum < curr) inst$1._zod.bag.maximum = def.maximum;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		if (input.length <= def.maximum) return;
		const origin$1 = getLengthableOrigin(input);
		payload.issues.push({
			origin: origin$1,
			code: "too_big",
			maximum: def.maximum,
			inclusive: true,
			input,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
	var _a;
	$ZodCheck.init(inst, def);
	(_a = inst._zod.def).when ?? (_a.when = (payload) => {
		const val = payload.value;
		return !nullish(val) && val.length !== void 0;
	});
	inst._zod.onattach.push((inst$1) => {
		const curr = inst$1._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
		if (def.minimum > curr) inst$1._zod.bag.minimum = def.minimum;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		if (input.length >= def.minimum) return;
		const origin$1 = getLengthableOrigin(input);
		payload.issues.push({
			origin: origin$1,
			code: "too_small",
			minimum: def.minimum,
			inclusive: true,
			input,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
	var _a;
	$ZodCheck.init(inst, def);
	(_a = inst._zod.def).when ?? (_a.when = (payload) => {
		const val = payload.value;
		return !nullish(val) && val.length !== void 0;
	});
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.minimum = def.length;
		bag.maximum = def.length;
		bag.length = def.length;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		const length = input.length;
		if (length === def.length) return;
		const origin$1 = getLengthableOrigin(input);
		const tooBig = length > def.length;
		payload.issues.push({
			origin: origin$1,
			...tooBig ? {
				code: "too_big",
				maximum: def.length
			} : {
				code: "too_small",
				minimum: def.length
			},
			inclusive: true,
			exact: true,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
	var _a, _b;
	$ZodCheck.init(inst, def);
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.format = def.format;
		if (def.pattern) {
			bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
			bag.patterns.add(def.pattern);
		}
	});
	if (def.pattern) (_a = inst._zod).check ?? (_a.check = (payload) => {
		def.pattern.lastIndex = 0;
		if (def.pattern.test(payload.value)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: def.format,
			input: payload.value,
			...def.pattern ? { pattern: def.pattern.toString() } : {},
			inst,
			continue: !def.abort
		});
	});
	else (_b = inst._zod).check ?? (_b.check = () => {});
});
const $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
	$ZodCheckStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		def.pattern.lastIndex = 0;
		if (def.pattern.test(payload.value)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "regex",
			input: payload.value,
			pattern: def.pattern.toString(),
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
	def.pattern ?? (def.pattern = lowercase);
	$ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
	def.pattern ?? (def.pattern = uppercase);
	$ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
	$ZodCheck.init(inst, def);
	const escapedRegex = escapeRegex(def.includes);
	const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
	def.pattern = pattern;
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
		bag.patterns.add(pattern);
	});
	inst._zod.check = (payload) => {
		if (payload.value.includes(def.includes, def.position)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "includes",
			includes: def.includes,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
	$ZodCheck.init(inst, def);
	const pattern = /* @__PURE__ */ new RegExp(`^${escapeRegex(def.prefix)}.*`);
	def.pattern ?? (def.pattern = pattern);
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
		bag.patterns.add(pattern);
	});
	inst._zod.check = (payload) => {
		if (payload.value.startsWith(def.prefix)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "starts_with",
			prefix: def.prefix,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
	$ZodCheck.init(inst, def);
	const pattern = /* @__PURE__ */ new RegExp(`.*${escapeRegex(def.suffix)}$`);
	def.pattern ?? (def.pattern = pattern);
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
		bag.patterns.add(pattern);
	});
	inst._zod.check = (payload) => {
		if (payload.value.endsWith(def.suffix)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "ends_with",
			suffix: def.suffix,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
	$ZodCheck.init(inst, def);
	inst._zod.check = (payload) => {
		payload.value = def.tx(payload.value);
	};
});

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/doc.js
var Doc = class {
	constructor(args = []) {
		this.content = [];
		this.indent = 0;
		if (this) this.args = args;
	}
	indented(fn) {
		this.indent += 1;
		fn(this);
		this.indent -= 1;
	}
	write(arg) {
		if (typeof arg === "function") {
			arg(this, { execution: "sync" });
			arg(this, { execution: "async" });
			return;
		}
		const lines = arg.split("\n").filter((x) => x);
		const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
		const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
		for (const line of dedented) this.content.push(line);
	}
	compile() {
		const F = Function;
		const args = this?.args;
		const lines = [...(this?.content ?? [``]).map((x) => `  ${x}`)];
		return new F(...args, lines.join("\n"));
	}
};

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/versions.js
const version = {
	major: 4,
	minor: 1,
	patch: 12
};

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/schemas.js
const $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
	var _a;
	inst ?? (inst = {});
	inst._zod.def = def;
	inst._zod.bag = inst._zod.bag || {};
	inst._zod.version = version;
	const checks = [...inst._zod.def.checks ?? []];
	if (inst._zod.traits.has("$ZodCheck")) checks.unshift(inst);
	for (const ch of checks) for (const fn of ch._zod.onattach) fn(inst);
	if (checks.length === 0) {
		(_a = inst._zod).deferred ?? (_a.deferred = []);
		inst._zod.deferred?.push(() => {
			inst._zod.run = inst._zod.parse;
		});
	} else {
		const runChecks = (payload, checks$1, ctx) => {
			let isAborted = aborted(payload);
			let asyncResult;
			for (const ch of checks$1) {
				if (ch._zod.def.when) {
					if (!ch._zod.def.when(payload)) continue;
				} else if (isAborted) continue;
				const currLen = payload.issues.length;
				const _ = ch._zod.check(payload);
				if (_ instanceof Promise && ctx?.async === false) throw new $ZodAsyncError();
				if (asyncResult || _ instanceof Promise) asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
					await _;
					if (payload.issues.length === currLen) return;
					if (!isAborted) isAborted = aborted(payload, currLen);
				});
				else {
					if (payload.issues.length === currLen) continue;
					if (!isAborted) isAborted = aborted(payload, currLen);
				}
			}
			if (asyncResult) return asyncResult.then(() => {
				return payload;
			});
			return payload;
		};
		const handleCanaryResult = (canary, payload, ctx) => {
			if (aborted(canary)) {
				canary.aborted = true;
				return canary;
			}
			const checkResult = runChecks(payload, checks, ctx);
			if (checkResult instanceof Promise) {
				if (ctx.async === false) throw new $ZodAsyncError();
				return checkResult.then((checkResult$1) => inst._zod.parse(checkResult$1, ctx));
			}
			return inst._zod.parse(checkResult, ctx);
		};
		inst._zod.run = (payload, ctx) => {
			if (ctx.skipChecks) return inst._zod.parse(payload, ctx);
			if (ctx.direction === "backward") {
				const canary = inst._zod.parse({
					value: payload.value,
					issues: []
				}, {
					...ctx,
					skipChecks: true
				});
				if (canary instanceof Promise) return canary.then((canary$1) => {
					return handleCanaryResult(canary$1, payload, ctx);
				});
				return handleCanaryResult(canary, payload, ctx);
			}
			const result = inst._zod.parse(payload, ctx);
			if (result instanceof Promise) {
				if (ctx.async === false) throw new $ZodAsyncError();
				return result.then((result$1) => runChecks(result$1, checks, ctx));
			}
			return runChecks(result, checks, ctx);
		};
	}
	inst["~standard"] = {
		validate: (value) => {
			try {
				const r = safeParse$1(inst, value);
				return r.success ? { value: r.data } : { issues: r.error?.issues };
			} catch (_) {
				return safeParseAsync$1(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
			}
		},
		vendor: "zod",
		version: 1
	};
});
const $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string$1(inst._zod.bag);
	inst._zod.parse = (payload, _) => {
		if (def.coerce) try {
			payload.value = String(payload.value);
		} catch (_$1) {}
		if (typeof payload.value === "string") return payload;
		payload.issues.push({
			expected: "string",
			code: "invalid_type",
			input: payload.value,
			inst
		});
		return payload;
	};
});
const $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
	$ZodCheckStringFormat.init(inst, def);
	$ZodString.init(inst, def);
});
const $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
	def.pattern ?? (def.pattern = guid);
	$ZodStringFormat.init(inst, def);
});
const $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
	if (def.version) {
		const v = {
			v1: 1,
			v2: 2,
			v3: 3,
			v4: 4,
			v5: 5,
			v6: 6,
			v7: 7,
			v8: 8
		}[def.version];
		if (v === void 0) throw new Error(`Invalid UUID version: "${def.version}"`);
		def.pattern ?? (def.pattern = uuid(v));
	} else def.pattern ?? (def.pattern = uuid());
	$ZodStringFormat.init(inst, def);
});
const $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
	def.pattern ?? (def.pattern = email);
	$ZodStringFormat.init(inst, def);
});
const $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
	$ZodStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		try {
			const trimmed = payload.value.trim();
			const url$1 = new URL(trimmed);
			if (def.hostname) {
				def.hostname.lastIndex = 0;
				if (!def.hostname.test(url$1.hostname)) payload.issues.push({
					code: "invalid_format",
					format: "url",
					note: "Invalid hostname",
					pattern: hostname.source,
					input: payload.value,
					inst,
					continue: !def.abort
				});
			}
			if (def.protocol) {
				def.protocol.lastIndex = 0;
				if (!def.protocol.test(url$1.protocol.endsWith(":") ? url$1.protocol.slice(0, -1) : url$1.protocol)) payload.issues.push({
					code: "invalid_format",
					format: "url",
					note: "Invalid protocol",
					pattern: def.protocol.source,
					input: payload.value,
					inst,
					continue: !def.abort
				});
			}
			if (def.normalize) payload.value = url$1.href;
			else payload.value = trimmed;
			return;
		} catch (_) {
			payload.issues.push({
				code: "invalid_format",
				format: "url",
				input: payload.value,
				inst,
				continue: !def.abort
			});
		}
	};
});
const $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
	def.pattern ?? (def.pattern = emoji());
	$ZodStringFormat.init(inst, def);
});
const $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
	def.pattern ?? (def.pattern = nanoid);
	$ZodStringFormat.init(inst, def);
});
const $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
	def.pattern ?? (def.pattern = cuid);
	$ZodStringFormat.init(inst, def);
});
const $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
	def.pattern ?? (def.pattern = cuid2);
	$ZodStringFormat.init(inst, def);
});
const $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
	def.pattern ?? (def.pattern = ulid);
	$ZodStringFormat.init(inst, def);
});
const $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
	def.pattern ?? (def.pattern = xid);
	$ZodStringFormat.init(inst, def);
});
const $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
	def.pattern ?? (def.pattern = ksuid);
	$ZodStringFormat.init(inst, def);
});
const $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
	def.pattern ?? (def.pattern = datetime$1(def));
	$ZodStringFormat.init(inst, def);
});
const $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
	def.pattern ?? (def.pattern = date$1);
	$ZodStringFormat.init(inst, def);
});
const $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
	def.pattern ?? (def.pattern = time$1(def));
	$ZodStringFormat.init(inst, def);
});
const $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
	def.pattern ?? (def.pattern = duration$1);
	$ZodStringFormat.init(inst, def);
});
const $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
	def.pattern ?? (def.pattern = ipv4);
	$ZodStringFormat.init(inst, def);
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.format = `ipv4`;
	});
});
const $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
	def.pattern ?? (def.pattern = ipv6);
	$ZodStringFormat.init(inst, def);
	inst._zod.onattach.push((inst$1) => {
		const bag = inst$1._zod.bag;
		bag.format = `ipv6`;
	});
	inst._zod.check = (payload) => {
		try {
			new URL(`http://[${payload.value}]`);
		} catch {
			payload.issues.push({
				code: "invalid_format",
				format: "ipv6",
				input: payload.value,
				inst,
				continue: !def.abort
			});
		}
	};
});
const $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
	def.pattern ?? (def.pattern = cidrv4);
	$ZodStringFormat.init(inst, def);
});
const $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
	def.pattern ?? (def.pattern = cidrv6);
	$ZodStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		const parts = payload.value.split("/");
		try {
			if (parts.length !== 2) throw new Error();
			const [address, prefix] = parts;
			if (!prefix) throw new Error();
			const prefixNum = Number(prefix);
			if (`${prefixNum}` !== prefix) throw new Error();
			if (prefixNum < 0 || prefixNum > 128) throw new Error();
			new URL(`http://[${address}]`);
		} catch {
			payload.issues.push({
				code: "invalid_format",
				format: "cidrv6",
				input: payload.value,
				inst,
				continue: !def.abort
			});
		}
	};
});
function isValidBase64(data$1) {
	if (data$1 === "") return true;
	if (data$1.length % 4 !== 0) return false;
	try {
		atob(data$1);
		return true;
	} catch {
		return false;
	}
}
const $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
	def.pattern ?? (def.pattern = base64);
	$ZodStringFormat.init(inst, def);
	inst._zod.onattach.push((inst$1) => {
		inst$1._zod.bag.contentEncoding = "base64";
	});
	inst._zod.check = (payload) => {
		if (isValidBase64(payload.value)) return;
		payload.issues.push({
			code: "invalid_format",
			format: "base64",
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
function isValidBase64URL(data$1) {
	if (!base64url.test(data$1)) return false;
	const base64$1 = data$1.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
	return isValidBase64(base64$1.padEnd(Math.ceil(base64$1.length / 4) * 4, "="));
}
const $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
	def.pattern ?? (def.pattern = base64url);
	$ZodStringFormat.init(inst, def);
	inst._zod.onattach.push((inst$1) => {
		inst$1._zod.bag.contentEncoding = "base64url";
	});
	inst._zod.check = (payload) => {
		if (isValidBase64URL(payload.value)) return;
		payload.issues.push({
			code: "invalid_format",
			format: "base64url",
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
	def.pattern ?? (def.pattern = e164);
	$ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
	try {
		const tokensParts = token.split(".");
		if (tokensParts.length !== 3) return false;
		const [header] = tokensParts;
		if (!header) return false;
		const parsedHeader = JSON.parse(atob(header));
		if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT") return false;
		if (!parsedHeader.alg) return false;
		if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm)) return false;
		return true;
	} catch {
		return false;
	}
}
const $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
	$ZodStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		if (isValidJWT(payload.value, def.alg)) return;
		payload.issues.push({
			code: "invalid_format",
			format: "jwt",
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = inst._zod.bag.pattern ?? number$2;
	inst._zod.parse = (payload, _ctx) => {
		if (def.coerce) try {
			payload.value = Number(payload.value);
		} catch (_) {}
		const input = payload.value;
		if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) return payload;
		const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
		payload.issues.push({
			expected: "number",
			code: "invalid_type",
			input,
			inst,
			...received ? { received } : {}
		});
		return payload;
	};
});
const $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
	$ZodCheckNumberFormat.init(inst, def);
	$ZodNumber.init(inst, def);
});
const $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload) => payload;
});
const $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _ctx) => {
		payload.issues.push({
			expected: "never",
			code: "invalid_type",
			input: payload.value,
			inst
		});
		return payload;
	};
});
function handleArrayResult(result, final, index$1) {
	if (result.issues.length) final.issues.push(...prefixIssues(index$1, result.issues));
	final.value[index$1] = result.value;
}
const $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!Array.isArray(input)) {
			payload.issues.push({
				expected: "array",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		payload.value = Array(input.length);
		const proms = [];
		for (let i = 0; i < input.length; i++) {
			const item = input[i];
			const result = def.element._zod.run({
				value: item,
				issues: []
			}, ctx);
			if (result instanceof Promise) proms.push(result.then((result$1) => handleArrayResult(result$1, payload, i)));
			else handleArrayResult(result, payload, i);
		}
		if (proms.length) return Promise.all(proms).then(() => payload);
		return payload;
	};
});
function handlePropertyResult(result, final, key, input) {
	if (result.issues.length) final.issues.push(...prefixIssues(key, result.issues));
	if (result.value === void 0) {
		if (key in input) final.value[key] = void 0;
	} else final.value[key] = result.value;
}
function normalizeDef(def) {
	const keys = Object.keys(def.shape);
	for (const k of keys) if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
	const okeys = optionalKeys(def.shape);
	return {
		...def,
		keys,
		keySet: new Set(keys),
		numKeys: keys.length,
		optionalKeys: new Set(okeys)
	};
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
	const unrecognized = [];
	const keySet = def.keySet;
	const _catchall = def.catchall._zod;
	const t = _catchall.def.type;
	for (const key of Object.keys(input)) {
		if (keySet.has(key)) continue;
		if (t === "never") {
			unrecognized.push(key);
			continue;
		}
		const r = _catchall.run({
			value: input[key],
			issues: []
		}, ctx);
		if (r instanceof Promise) proms.push(r.then((r$1) => handlePropertyResult(r$1, payload, key, input)));
		else handlePropertyResult(r, payload, key, input);
	}
	if (unrecognized.length) payload.issues.push({
		code: "unrecognized_keys",
		keys: unrecognized,
		input,
		inst
	});
	if (!proms.length) return payload;
	return Promise.all(proms).then(() => {
		return payload;
	});
}
const $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
	$ZodType.init(inst, def);
	if (!Object.getOwnPropertyDescriptor(def, "shape")?.get) {
		const sh = def.shape;
		Object.defineProperty(def, "shape", { get: () => {
			const newSh = { ...sh };
			Object.defineProperty(def, "shape", { value: newSh });
			return newSh;
		} });
	}
	const _normalized = cached(() => normalizeDef(def));
	defineLazy(inst._zod, "propValues", () => {
		const shape = def.shape;
		const propValues = {};
		for (const key in shape) {
			const field = shape[key]._zod;
			if (field.values) {
				propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
				for (const v of field.values) propValues[key].add(v);
			}
		}
		return propValues;
	});
	const isObject$2 = isObject;
	const catchall = def.catchall;
	let value;
	inst._zod.parse = (payload, ctx) => {
		value ?? (value = _normalized.value);
		const input = payload.value;
		if (!isObject$2(input)) {
			payload.issues.push({
				expected: "object",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		payload.value = {};
		const proms = [];
		const shape = value.shape;
		for (const key of value.keys) {
			const r = shape[key]._zod.run({
				value: input[key],
				issues: []
			}, ctx);
			if (r instanceof Promise) proms.push(r.then((r$1) => handlePropertyResult(r$1, payload, key, input)));
			else handlePropertyResult(r, payload, key, input);
		}
		if (!catchall) return proms.length ? Promise.all(proms).then(() => payload) : payload;
		return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
	};
});
const $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
	$ZodObject.init(inst, def);
	const superParse = inst._zod.parse;
	const _normalized = cached(() => normalizeDef(def));
	const generateFastpass = (shape) => {
		const doc = new Doc([
			"shape",
			"payload",
			"ctx"
		]);
		const normalized = _normalized.value;
		const parseStr = (key) => {
			const k = esc(key);
			return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
		};
		doc.write(`const input = payload.value;`);
		const ids = Object.create(null);
		let counter = 0;
		for (const key of normalized.keys) ids[key] = `key_${counter++}`;
		doc.write(`const newResult = {};`);
		for (const key of normalized.keys) {
			const id = ids[key];
			const k = esc(key);
			doc.write(`const ${id} = ${parseStr(key)};`);
			doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
		}
		doc.write(`payload.value = newResult;`);
		doc.write(`return payload;`);
		const fn = doc.compile();
		return (payload, ctx) => fn(shape, payload, ctx);
	};
	let fastpass;
	const isObject$2 = isObject;
	const jit = !globalConfig.jitless;
	const allowsEval$1 = allowsEval;
	const fastEnabled = jit && allowsEval$1.value;
	const catchall = def.catchall;
	let value;
	inst._zod.parse = (payload, ctx) => {
		value ?? (value = _normalized.value);
		const input = payload.value;
		if (!isObject$2(input)) {
			payload.issues.push({
				expected: "object",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
			if (!fastpass) fastpass = generateFastpass(def.shape);
			payload = fastpass(payload, ctx);
			if (!catchall) return payload;
			return handleCatchall([], input, payload, ctx, value, inst);
		}
		return superParse(payload, ctx);
	};
});
function handleUnionResults(results, final, inst, ctx) {
	for (const result of results) if (result.issues.length === 0) {
		final.value = result.value;
		return final;
	}
	const nonaborted = results.filter((r) => !aborted(r));
	if (nonaborted.length === 1) {
		final.value = nonaborted[0].value;
		return nonaborted[0];
	}
	final.issues.push({
		code: "invalid_union",
		input: final.value,
		inst,
		errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config$1())))
	});
	return final;
}
const $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
	defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
	defineLazy(inst._zod, "values", () => {
		if (def.options.every((o) => o._zod.values)) return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
	});
	defineLazy(inst._zod, "pattern", () => {
		if (def.options.every((o) => o._zod.pattern)) {
			const patterns = def.options.map((o) => o._zod.pattern);
			return /* @__PURE__ */ new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
		}
	});
	const single = def.options.length === 1;
	const first = def.options[0]._zod.run;
	inst._zod.parse = (payload, ctx) => {
		if (single) return first(payload, ctx);
		let async$3 = false;
		const results = [];
		for (const option of def.options) {
			const result = option._zod.run({
				value: payload.value,
				issues: []
			}, ctx);
			if (result instanceof Promise) {
				results.push(result);
				async$3 = true;
			} else {
				if (result.issues.length === 0) return result;
				results.push(result);
			}
		}
		if (!async$3) return handleUnionResults(results, payload, inst, ctx);
		return Promise.all(results).then((results$1) => {
			return handleUnionResults(results$1, payload, inst, ctx);
		});
	};
});
const $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		const left = def.left._zod.run({
			value: input,
			issues: []
		}, ctx);
		const right = def.right._zod.run({
			value: input,
			issues: []
		}, ctx);
		if (left instanceof Promise || right instanceof Promise) return Promise.all([left, right]).then(([left$1, right$1]) => {
			return handleIntersectionResults(payload, left$1, right$1);
		});
		return handleIntersectionResults(payload, left, right);
	};
});
function mergeValues(a, b) {
	if (a === b) return {
		valid: true,
		data: a
	};
	if (a instanceof Date && b instanceof Date && +a === +b) return {
		valid: true,
		data: a
	};
	if (isPlainObject(a) && isPlainObject(b)) {
		const bKeys = Object.keys(b);
		const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
		const newObj = {
			...a,
			...b
		};
		for (const key of sharedKeys) {
			const sharedValue = mergeValues(a[key], b[key]);
			if (!sharedValue.valid) return {
				valid: false,
				mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
			};
			newObj[key] = sharedValue.data;
		}
		return {
			valid: true,
			data: newObj
		};
	}
	if (Array.isArray(a) && Array.isArray(b)) {
		if (a.length !== b.length) return {
			valid: false,
			mergeErrorPath: []
		};
		const newArray = [];
		for (let index$1 = 0; index$1 < a.length; index$1++) {
			const itemA = a[index$1];
			const itemB = b[index$1];
			const sharedValue = mergeValues(itemA, itemB);
			if (!sharedValue.valid) return {
				valid: false,
				mergeErrorPath: [index$1, ...sharedValue.mergeErrorPath]
			};
			newArray.push(sharedValue.data);
		}
		return {
			valid: true,
			data: newArray
		};
	}
	return {
		valid: false,
		mergeErrorPath: []
	};
}
function handleIntersectionResults(result, left, right) {
	if (left.issues.length) result.issues.push(...left.issues);
	if (right.issues.length) result.issues.push(...right.issues);
	if (aborted(result)) return result;
	const merged = mergeValues(left.value, right.value);
	if (!merged.valid) throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
	result.value = merged.data;
	return result;
}
const $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
	$ZodType.init(inst, def);
	const values = getEnumValues(def.entries);
	const valuesSet = new Set(values);
	inst._zod.values = valuesSet;
	inst._zod.pattern = /* @__PURE__ */ new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (valuesSet.has(input)) return payload;
		payload.issues.push({
			code: "invalid_value",
			values,
			input,
			inst
		});
		return payload;
	};
});
const $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
	$ZodType.init(inst, def);
	if (def.values.length === 0) throw new Error("Cannot create literal schema with no valid values");
	inst._zod.values = new Set(def.values);
	inst._zod.pattern = /* @__PURE__ */ new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (inst._zod.values.has(input)) return payload;
		payload.issues.push({
			code: "invalid_value",
			values: def.values,
			input,
			inst
		});
		return payload;
	};
});
const $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") throw new $ZodEncodeError(inst.constructor.name);
		const _out = def.transform(payload.value, payload);
		if (ctx.async) return (_out instanceof Promise ? _out : Promise.resolve(_out)).then((output$1) => {
			payload.value = output$1;
			return payload;
		});
		if (_out instanceof Promise) throw new $ZodAsyncError();
		payload.value = _out;
		return payload;
	};
});
function handleOptionalResult(result, input) {
	if (result.issues.length && input === void 0) return {
		issues: [],
		value: void 0
	};
	return result;
}
const $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.optin = "optional";
	inst._zod.optout = "optional";
	defineLazy(inst._zod, "values", () => {
		return def.innerType._zod.values ? new Set([...def.innerType._zod.values, void 0]) : void 0;
	});
	defineLazy(inst._zod, "pattern", () => {
		const pattern = def.innerType._zod.pattern;
		return pattern ? /* @__PURE__ */ new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
	});
	inst._zod.parse = (payload, ctx) => {
		if (def.innerType._zod.optin === "optional") {
			const result = def.innerType._zod.run(payload, ctx);
			if (result instanceof Promise) return result.then((r) => handleOptionalResult(r, payload.value));
			return handleOptionalResult(result, payload.value);
		}
		if (payload.value === void 0) return payload;
		return def.innerType._zod.run(payload, ctx);
	};
});
const $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
	defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
	defineLazy(inst._zod, "pattern", () => {
		const pattern = def.innerType._zod.pattern;
		return pattern ? /* @__PURE__ */ new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
	});
	defineLazy(inst._zod, "values", () => {
		return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : void 0;
	});
	inst._zod.parse = (payload, ctx) => {
		if (payload.value === null) return payload;
		return def.innerType._zod.run(payload, ctx);
	};
});
const $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.optin = "optional";
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") return def.innerType._zod.run(payload, ctx);
		if (payload.value === void 0) {
			payload.value = def.defaultValue;
			/**
			* $ZodDefault returns the default value immediately in forward direction.
			* It doesn't pass the default value into the validator ("prefault"). There's no reason to pass the default value through validation. The validity of the default is enforced by TypeScript statically. Otherwise, it's the responsibility of the user to ensure the default is valid. In the case of pipes with divergent in/out types, you can specify the default on the `in` schema of your ZodPipe to set a "prefault" for the pipe.   */
			return payload;
		}
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) return result.then((result$1) => handleDefaultResult(result$1, def));
		return handleDefaultResult(result, def);
	};
});
function handleDefaultResult(payload, def) {
	if (payload.value === void 0) payload.value = def.defaultValue;
	return payload;
}
const $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.optin = "optional";
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") return def.innerType._zod.run(payload, ctx);
		if (payload.value === void 0) payload.value = def.defaultValue;
		return def.innerType._zod.run(payload, ctx);
	};
});
const $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "values", () => {
		const v = def.innerType._zod.values;
		return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
	});
	inst._zod.parse = (payload, ctx) => {
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) return result.then((result$1) => handleNonOptionalResult(result$1, inst));
		return handleNonOptionalResult(result, inst);
	};
});
function handleNonOptionalResult(payload, inst) {
	if (!payload.issues.length && payload.value === void 0) payload.issues.push({
		code: "invalid_type",
		expected: "nonoptional",
		input: payload.value,
		inst
	});
	return payload;
}
const $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
	defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") return def.innerType._zod.run(payload, ctx);
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) return result.then((result$1) => {
			payload.value = result$1.value;
			if (result$1.issues.length) {
				payload.value = def.catchValue({
					...payload,
					error: { issues: result$1.issues.map((iss) => finalizeIssue(iss, ctx, config$1())) },
					input: payload.value
				});
				payload.issues = [];
			}
			return payload;
		});
		payload.value = result.value;
		if (result.issues.length) {
			payload.value = def.catchValue({
				...payload,
				error: { issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config$1())) },
				input: payload.value
			});
			payload.issues = [];
		}
		return payload;
	};
});
const $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "values", () => def.in._zod.values);
	defineLazy(inst._zod, "optin", () => def.in._zod.optin);
	defineLazy(inst._zod, "optout", () => def.out._zod.optout);
	defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") {
			const right = def.out._zod.run(payload, ctx);
			if (right instanceof Promise) return right.then((right$1) => handlePipeResult(right$1, def.in, ctx));
			return handlePipeResult(right, def.in, ctx);
		}
		const left = def.in._zod.run(payload, ctx);
		if (left instanceof Promise) return left.then((left$1) => handlePipeResult(left$1, def.out, ctx));
		return handlePipeResult(left, def.out, ctx);
	};
});
function handlePipeResult(left, next, ctx) {
	if (left.issues.length) {
		left.aborted = true;
		return left;
	}
	return next._zod.run({
		value: left.value,
		issues: left.issues
	}, ctx);
}
const $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
	defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") return def.innerType._zod.run(payload, ctx);
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) return result.then(handleReadonlyResult);
		return handleReadonlyResult(result);
	};
});
function handleReadonlyResult(payload) {
	payload.value = Object.freeze(payload.value);
	return payload;
}
const $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
	$ZodCheck.init(inst, def);
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _) => {
		return payload;
	};
	inst._zod.check = (payload) => {
		const input = payload.value;
		const r = def.fn(input);
		if (r instanceof Promise) return r.then((r$1) => handleRefineResult(r$1, payload, input, inst));
		handleRefineResult(r, payload, input, inst);
	};
});
function handleRefineResult(result, payload, input, inst) {
	if (!result) {
		const _iss = {
			code: "custom",
			input,
			inst,
			path: [...inst._zod.def.path ?? []],
			continue: !inst._zod.def.abort
		};
		if (inst._zod.def.params) _iss.params = inst._zod.def.params;
		payload.issues.push(issue(_iss));
	}
}

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/registries.js
const $output = Symbol("ZodOutput");
const $input = Symbol("ZodInput");
var $ZodRegistry = class {
	constructor() {
		this._map = /* @__PURE__ */ new WeakMap();
		this._idmap = /* @__PURE__ */ new Map();
	}
	add(schema, ..._meta) {
		const meta = _meta[0];
		this._map.set(schema, meta);
		if (meta && typeof meta === "object" && "id" in meta) {
			if (this._idmap.has(meta.id)) throw new Error(`ID ${meta.id} already exists in the registry`);
			this._idmap.set(meta.id, schema);
		}
		return this;
	}
	clear() {
		this._map = /* @__PURE__ */ new WeakMap();
		this._idmap = /* @__PURE__ */ new Map();
		return this;
	}
	remove(schema) {
		const meta = this._map.get(schema);
		if (meta && typeof meta === "object" && "id" in meta) this._idmap.delete(meta.id);
		this._map.delete(schema);
		return this;
	}
	get(schema) {
		const p = schema._zod.parent;
		if (p) {
			const pm = { ...this.get(p) ?? {} };
			delete pm.id;
			const f = {
				...pm,
				...this._map.get(schema)
			};
			return Object.keys(f).length ? f : void 0;
		}
		return this._map.get(schema);
	}
	has(schema) {
		return this._map.has(schema);
	}
};
function registry() {
	return new $ZodRegistry();
}
const globalRegistry = /* @__PURE__ */ registry();

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/api.js
function _string(Class, params) {
	return new Class({
		type: "string",
		...normalizeParams(params)
	});
}
function _email(Class, params) {
	return new Class({
		type: "string",
		format: "email",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _guid(Class, params) {
	return new Class({
		type: "string",
		format: "guid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _uuid(Class, params) {
	return new Class({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _uuidv4(Class, params) {
	return new Class({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		version: "v4",
		...normalizeParams(params)
	});
}
function _uuidv6(Class, params) {
	return new Class({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		version: "v6",
		...normalizeParams(params)
	});
}
function _uuidv7(Class, params) {
	return new Class({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		version: "v7",
		...normalizeParams(params)
	});
}
function _url(Class, params) {
	return new Class({
		type: "string",
		format: "url",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _emoji(Class, params) {
	return new Class({
		type: "string",
		format: "emoji",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _nanoid(Class, params) {
	return new Class({
		type: "string",
		format: "nanoid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _cuid(Class, params) {
	return new Class({
		type: "string",
		format: "cuid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _cuid2(Class, params) {
	return new Class({
		type: "string",
		format: "cuid2",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _ulid(Class, params) {
	return new Class({
		type: "string",
		format: "ulid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _xid(Class, params) {
	return new Class({
		type: "string",
		format: "xid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _ksuid(Class, params) {
	return new Class({
		type: "string",
		format: "ksuid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _ipv4(Class, params) {
	return new Class({
		type: "string",
		format: "ipv4",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _ipv6(Class, params) {
	return new Class({
		type: "string",
		format: "ipv6",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _cidrv4(Class, params) {
	return new Class({
		type: "string",
		format: "cidrv4",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _cidrv6(Class, params) {
	return new Class({
		type: "string",
		format: "cidrv6",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _base64(Class, params) {
	return new Class({
		type: "string",
		format: "base64",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _base64url(Class, params) {
	return new Class({
		type: "string",
		format: "base64url",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _e164(Class, params) {
	return new Class({
		type: "string",
		format: "e164",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _jwt(Class, params) {
	return new Class({
		type: "string",
		format: "jwt",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
function _isoDateTime(Class, params) {
	return new Class({
		type: "string",
		format: "datetime",
		check: "string_format",
		offset: false,
		local: false,
		precision: null,
		...normalizeParams(params)
	});
}
function _isoDate(Class, params) {
	return new Class({
		type: "string",
		format: "date",
		check: "string_format",
		...normalizeParams(params)
	});
}
function _isoTime(Class, params) {
	return new Class({
		type: "string",
		format: "time",
		check: "string_format",
		precision: null,
		...normalizeParams(params)
	});
}
function _isoDuration(Class, params) {
	return new Class({
		type: "string",
		format: "duration",
		check: "string_format",
		...normalizeParams(params)
	});
}
function _number(Class, params) {
	return new Class({
		type: "number",
		checks: [],
		...normalizeParams(params)
	});
}
function _coercedNumber(Class, params) {
	return new Class({
		type: "number",
		coerce: true,
		checks: [],
		...normalizeParams(params)
	});
}
function _int(Class, params) {
	return new Class({
		type: "number",
		check: "number_format",
		abort: false,
		format: "safeint",
		...normalizeParams(params)
	});
}
function _unknown(Class) {
	return new Class({ type: "unknown" });
}
function _never(Class, params) {
	return new Class({
		type: "never",
		...normalizeParams(params)
	});
}
function _lt(value, params) {
	return new $ZodCheckLessThan({
		check: "less_than",
		...normalizeParams(params),
		value,
		inclusive: false
	});
}
function _lte(value, params) {
	return new $ZodCheckLessThan({
		check: "less_than",
		...normalizeParams(params),
		value,
		inclusive: true
	});
}
function _gt(value, params) {
	return new $ZodCheckGreaterThan({
		check: "greater_than",
		...normalizeParams(params),
		value,
		inclusive: false
	});
}
function _gte(value, params) {
	return new $ZodCheckGreaterThan({
		check: "greater_than",
		...normalizeParams(params),
		value,
		inclusive: true
	});
}
function _multipleOf(value, params) {
	return new $ZodCheckMultipleOf({
		check: "multiple_of",
		...normalizeParams(params),
		value
	});
}
function _maxLength(maximum, params) {
	return new $ZodCheckMaxLength({
		check: "max_length",
		...normalizeParams(params),
		maximum
	});
}
function _minLength(minimum, params) {
	return new $ZodCheckMinLength({
		check: "min_length",
		...normalizeParams(params),
		minimum
	});
}
function _length(length, params) {
	return new $ZodCheckLengthEquals({
		check: "length_equals",
		...normalizeParams(params),
		length
	});
}
function _regex(pattern, params) {
	return new $ZodCheckRegex({
		check: "string_format",
		format: "regex",
		...normalizeParams(params),
		pattern
	});
}
function _lowercase(params) {
	return new $ZodCheckLowerCase({
		check: "string_format",
		format: "lowercase",
		...normalizeParams(params)
	});
}
function _uppercase(params) {
	return new $ZodCheckUpperCase({
		check: "string_format",
		format: "uppercase",
		...normalizeParams(params)
	});
}
function _includes(includes, params) {
	return new $ZodCheckIncludes({
		check: "string_format",
		format: "includes",
		...normalizeParams(params),
		includes
	});
}
function _startsWith(prefix, params) {
	return new $ZodCheckStartsWith({
		check: "string_format",
		format: "starts_with",
		...normalizeParams(params),
		prefix
	});
}
function _endsWith(suffix, params) {
	return new $ZodCheckEndsWith({
		check: "string_format",
		format: "ends_with",
		...normalizeParams(params),
		suffix
	});
}
function _overwrite(tx) {
	return new $ZodCheckOverwrite({
		check: "overwrite",
		tx
	});
}
function _normalize(form) {
	return _overwrite((input) => input.normalize(form));
}
function _trim() {
	return _overwrite((input) => input.trim());
}
function _toLowerCase() {
	return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
	return _overwrite((input) => input.toUpperCase());
}
function _array(Class, element, params) {
	return new Class({
		type: "array",
		element,
		...normalizeParams(params)
	});
}
function _refine(Class, fn, _params) {
	return new Class({
		type: "custom",
		check: "custom",
		fn,
		...normalizeParams(_params)
	});
}
function _superRefine(fn) {
	const ch = _check((payload) => {
		payload.addIssue = (issue$1) => {
			if (typeof issue$1 === "string") payload.issues.push(issue(issue$1, payload.value, ch._zod.def));
			else {
				const _issue = issue$1;
				if (_issue.fatal) _issue.continue = false;
				_issue.code ?? (_issue.code = "custom");
				_issue.input ?? (_issue.input = payload.value);
				_issue.inst ?? (_issue.inst = ch);
				_issue.continue ?? (_issue.continue = !ch._zod.def.abort);
				payload.issues.push(issue(_issue));
			}
		};
		return fn(payload.value, payload);
	});
	return ch;
}
function _check(fn, params) {
	const ch = new $ZodCheck({
		check: "custom",
		...normalizeParams(params)
	});
	ch._zod.check = fn;
	return ch;
}

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/iso.js
const ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
	$ZodISODateTime.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function datetime(params) {
	return _isoDateTime(ZodISODateTime, params);
}
const ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
	$ZodISODate.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function date(params) {
	return _isoDate(ZodISODate, params);
}
const ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
	$ZodISOTime.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function time(params) {
	return _isoTime(ZodISOTime, params);
}
const ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
	$ZodISODuration.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function duration(params) {
	return _isoDuration(ZodISODuration, params);
}

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/errors.js
const initializer = (inst, issues) => {
	$ZodError.init(inst, issues);
	inst.name = "ZodError";
	Object.defineProperties(inst, {
		format: { value: (mapper) => formatError(inst, mapper) },
		flatten: { value: (mapper) => flattenError(inst, mapper) },
		addIssue: { value: (issue$1) => {
			inst.issues.push(issue$1);
			inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
		} },
		addIssues: { value: (issues$1) => {
			inst.issues.push(...issues$1);
			inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
		} },
		isEmpty: { get() {
			return inst.issues.length === 0;
		} }
	});
};
const ZodError = $constructor("ZodError", initializer);
const ZodRealError = $constructor("ZodError", initializer, { Parent: Error });

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/parse.js
const parse$1 = /* @__PURE__ */ _parse(ZodRealError);
const parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
const safeParse = /* @__PURE__ */ _safeParse(ZodRealError);
const safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError);
const encode = /* @__PURE__ */ _encode(ZodRealError);
const decode = /* @__PURE__ */ _decode(ZodRealError);
const encodeAsync = /* @__PURE__ */ _encodeAsync(ZodRealError);
const decodeAsync = /* @__PURE__ */ _decodeAsync(ZodRealError);
const safeEncode = /* @__PURE__ */ _safeEncode(ZodRealError);
const safeDecode = /* @__PURE__ */ _safeDecode(ZodRealError);
const safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
const safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/schemas.js
const ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
	$ZodType.init(inst, def);
	inst.def = def;
	inst.type = def.type;
	Object.defineProperty(inst, "_def", { value: def });
	inst.check = (...checks) => {
		return inst.clone(mergeDefs(def, { checks: [...def.checks ?? [], ...checks.map((ch) => typeof ch === "function" ? { _zod: {
			check: ch,
			def: { check: "custom" },
			onattach: []
		} } : ch)] }));
	};
	inst.clone = (def$1, params) => clone(inst, def$1, params);
	inst.brand = () => inst;
	inst.register = ((reg, meta) => {
		reg.add(inst, meta);
		return inst;
	});
	inst.parse = (data$1, params) => parse$1(inst, data$1, params, { callee: inst.parse });
	inst.safeParse = (data$1, params) => safeParse(inst, data$1, params);
	inst.parseAsync = async (data$1, params) => parseAsync(inst, data$1, params, { callee: inst.parseAsync });
	inst.safeParseAsync = async (data$1, params) => safeParseAsync(inst, data$1, params);
	inst.spa = inst.safeParseAsync;
	inst.encode = (data$1, params) => encode(inst, data$1, params);
	inst.decode = (data$1, params) => decode(inst, data$1, params);
	inst.encodeAsync = async (data$1, params) => encodeAsync(inst, data$1, params);
	inst.decodeAsync = async (data$1, params) => decodeAsync(inst, data$1, params);
	inst.safeEncode = (data$1, params) => safeEncode(inst, data$1, params);
	inst.safeDecode = (data$1, params) => safeDecode(inst, data$1, params);
	inst.safeEncodeAsync = async (data$1, params) => safeEncodeAsync(inst, data$1, params);
	inst.safeDecodeAsync = async (data$1, params) => safeDecodeAsync(inst, data$1, params);
	inst.refine = (check, params) => inst.check(refine(check, params));
	inst.superRefine = (refinement) => inst.check(superRefine(refinement));
	inst.overwrite = (fn) => inst.check(_overwrite(fn));
	inst.optional = () => optional(inst);
	inst.nullable = () => nullable(inst);
	inst.nullish = () => optional(nullable(inst));
	inst.nonoptional = (params) => nonoptional(inst, params);
	inst.array = () => array(inst);
	inst.or = (arg) => union([inst, arg]);
	inst.and = (arg) => intersection(inst, arg);
	inst.transform = (tx) => pipe(inst, transform(tx));
	inst.default = (def$1) => _default(inst, def$1);
	inst.prefault = (def$1) => prefault(inst, def$1);
	inst.catch = (params) => _catch(inst, params);
	inst.pipe = (target) => pipe(inst, target);
	inst.readonly = () => readonly(inst);
	inst.describe = (description) => {
		const cl = inst.clone();
		globalRegistry.add(cl, { description });
		return cl;
	};
	Object.defineProperty(inst, "description", {
		get() {
			return globalRegistry.get(inst)?.description;
		},
		configurable: true
	});
	inst.meta = (...args) => {
		if (args.length === 0) return globalRegistry.get(inst);
		const cl = inst.clone();
		globalRegistry.add(cl, args[0]);
		return cl;
	};
	inst.isOptional = () => inst.safeParse(void 0).success;
	inst.isNullable = () => inst.safeParse(null).success;
	return inst;
});
/** @internal */
const _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
	$ZodString.init(inst, def);
	ZodType.init(inst, def);
	const bag = inst._zod.bag;
	inst.format = bag.format ?? null;
	inst.minLength = bag.minimum ?? null;
	inst.maxLength = bag.maximum ?? null;
	inst.regex = (...args) => inst.check(_regex(...args));
	inst.includes = (...args) => inst.check(_includes(...args));
	inst.startsWith = (...args) => inst.check(_startsWith(...args));
	inst.endsWith = (...args) => inst.check(_endsWith(...args));
	inst.min = (...args) => inst.check(_minLength(...args));
	inst.max = (...args) => inst.check(_maxLength(...args));
	inst.length = (...args) => inst.check(_length(...args));
	inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
	inst.lowercase = (params) => inst.check(_lowercase(params));
	inst.uppercase = (params) => inst.check(_uppercase(params));
	inst.trim = () => inst.check(_trim());
	inst.normalize = (...args) => inst.check(_normalize(...args));
	inst.toLowerCase = () => inst.check(_toLowerCase());
	inst.toUpperCase = () => inst.check(_toUpperCase());
});
const ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
	$ZodString.init(inst, def);
	_ZodString.init(inst, def);
	inst.email = (params) => inst.check(_email(ZodEmail, params));
	inst.url = (params) => inst.check(_url(ZodURL, params));
	inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
	inst.emoji = (params) => inst.check(_emoji(ZodEmoji, params));
	inst.guid = (params) => inst.check(_guid(ZodGUID, params));
	inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
	inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
	inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
	inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
	inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
	inst.guid = (params) => inst.check(_guid(ZodGUID, params));
	inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
	inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
	inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
	inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
	inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
	inst.xid = (params) => inst.check(_xid(ZodXID, params));
	inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
	inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
	inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
	inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
	inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
	inst.e164 = (params) => inst.check(_e164(ZodE164, params));
	inst.datetime = (params) => inst.check(datetime(params));
	inst.date = (params) => inst.check(date(params));
	inst.time = (params) => inst.check(time(params));
	inst.duration = (params) => inst.check(duration(params));
});
function string(params) {
	return _string(ZodString, params);
}
const ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
	$ZodStringFormat.init(inst, def);
	_ZodString.init(inst, def);
});
const ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
	$ZodEmail.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
	$ZodGUID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
	$ZodUUID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
	$ZodURL.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
	$ZodEmoji.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
	$ZodNanoID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
	$ZodCUID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
	$ZodCUID2.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
	$ZodULID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
	$ZodXID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
	$ZodKSUID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
	$ZodIPv4.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
	$ZodIPv6.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
	$ZodCIDRv4.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
	$ZodCIDRv6.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
	$ZodBase64.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
	$ZodBase64URL.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
	$ZodE164.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
	$ZodJWT.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
	$ZodNumber.init(inst, def);
	ZodType.init(inst, def);
	inst.gt = (value, params) => inst.check(_gt(value, params));
	inst.gte = (value, params) => inst.check(_gte(value, params));
	inst.min = (value, params) => inst.check(_gte(value, params));
	inst.lt = (value, params) => inst.check(_lt(value, params));
	inst.lte = (value, params) => inst.check(_lte(value, params));
	inst.max = (value, params) => inst.check(_lte(value, params));
	inst.int = (params) => inst.check(int(params));
	inst.safe = (params) => inst.check(int(params));
	inst.positive = (params) => inst.check(_gt(0, params));
	inst.nonnegative = (params) => inst.check(_gte(0, params));
	inst.negative = (params) => inst.check(_lt(0, params));
	inst.nonpositive = (params) => inst.check(_lte(0, params));
	inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
	inst.step = (value, params) => inst.check(_multipleOf(value, params));
	inst.finite = () => inst;
	const bag = inst._zod.bag;
	inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
	inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
	inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? .5);
	inst.isFinite = true;
	inst.format = bag.format ?? null;
});
function number$1(params) {
	return _number(ZodNumber, params);
}
const ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
	$ZodNumberFormat.init(inst, def);
	ZodNumber.init(inst, def);
});
function int(params) {
	return _int(ZodNumberFormat, params);
}
const ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
	$ZodUnknown.init(inst, def);
	ZodType.init(inst, def);
});
function unknown() {
	return _unknown(ZodUnknown);
}
const ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
	$ZodNever.init(inst, def);
	ZodType.init(inst, def);
});
function never(params) {
	return _never(ZodNever, params);
}
const ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
	$ZodArray.init(inst, def);
	ZodType.init(inst, def);
	inst.element = def.element;
	inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
	inst.nonempty = (params) => inst.check(_minLength(1, params));
	inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
	inst.length = (len, params) => inst.check(_length(len, params));
	inst.unwrap = () => inst.element;
});
function array(element, params) {
	return _array(ZodArray, element, params);
}
const ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
	$ZodObjectJIT.init(inst, def);
	ZodType.init(inst, def);
	defineLazy(inst, "shape", () => {
		return def.shape;
	});
	inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
	inst.catchall = (catchall) => inst.clone({
		...inst._zod.def,
		catchall
	});
	inst.passthrough = () => inst.clone({
		...inst._zod.def,
		catchall: unknown()
	});
	inst.loose = () => inst.clone({
		...inst._zod.def,
		catchall: unknown()
	});
	inst.strict = () => inst.clone({
		...inst._zod.def,
		catchall: never()
	});
	inst.strip = () => inst.clone({
		...inst._zod.def,
		catchall: void 0
	});
	inst.extend = (incoming) => {
		return extend(inst, incoming);
	};
	inst.safeExtend = (incoming) => {
		return safeExtend(inst, incoming);
	};
	inst.merge = (other) => merge(inst, other);
	inst.pick = (mask) => pick(inst, mask);
	inst.omit = (mask) => omit(inst, mask);
	inst.partial = (...args) => partial(ZodOptional, inst, args[0]);
	inst.required = (...args) => required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
	return new ZodObject({
		type: "object",
		shape: shape ?? {},
		...normalizeParams(params)
	});
}
const ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
	$ZodUnion.init(inst, def);
	ZodType.init(inst, def);
	inst.options = def.options;
});
function union(options, params) {
	return new ZodUnion({
		type: "union",
		options,
		...normalizeParams(params)
	});
}
const ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
	$ZodIntersection.init(inst, def);
	ZodType.init(inst, def);
});
function intersection(left, right) {
	return new ZodIntersection({
		type: "intersection",
		left,
		right
	});
}
const ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
	$ZodEnum.init(inst, def);
	ZodType.init(inst, def);
	inst.enum = def.entries;
	inst.options = Object.values(def.entries);
	const keys = new Set(Object.keys(def.entries));
	inst.extract = (values, params) => {
		const newEntries = {};
		for (const value of values) if (keys.has(value)) newEntries[value] = def.entries[value];
		else throw new Error(`Key ${value} not found in enum`);
		return new ZodEnum({
			...def,
			checks: [],
			...normalizeParams(params),
			entries: newEntries
		});
	};
	inst.exclude = (values, params) => {
		const newEntries = { ...def.entries };
		for (const value of values) if (keys.has(value)) delete newEntries[value];
		else throw new Error(`Key ${value} not found in enum`);
		return new ZodEnum({
			...def,
			checks: [],
			...normalizeParams(params),
			entries: newEntries
		});
	};
});
function _enum(values, params) {
	return new ZodEnum({
		type: "enum",
		entries: Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values,
		...normalizeParams(params)
	});
}
const ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
	$ZodLiteral.init(inst, def);
	ZodType.init(inst, def);
	inst.values = new Set(def.values);
	Object.defineProperty(inst, "value", { get() {
		if (def.values.length > 1) throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
		return def.values[0];
	} });
});
function literal(value, params) {
	return new ZodLiteral({
		type: "literal",
		values: Array.isArray(value) ? value : [value],
		...normalizeParams(params)
	});
}
const ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
	$ZodTransform.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.parse = (payload, _ctx) => {
		if (_ctx.direction === "backward") throw new $ZodEncodeError(inst.constructor.name);
		payload.addIssue = (issue$1) => {
			if (typeof issue$1 === "string") payload.issues.push(issue(issue$1, payload.value, def));
			else {
				const _issue = issue$1;
				if (_issue.fatal) _issue.continue = false;
				_issue.code ?? (_issue.code = "custom");
				_issue.input ?? (_issue.input = payload.value);
				_issue.inst ?? (_issue.inst = inst);
				payload.issues.push(issue(_issue));
			}
		};
		const output$1 = def.transform(payload.value, payload);
		if (output$1 instanceof Promise) return output$1.then((output$2) => {
			payload.value = output$2;
			return payload;
		});
		payload.value = output$1;
		return payload;
	};
});
function transform(fn) {
	return new ZodTransform({
		type: "transform",
		transform: fn
	});
}
const ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
	$ZodOptional.init(inst, def);
	ZodType.init(inst, def);
	inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
	return new ZodOptional({
		type: "optional",
		innerType
	});
}
const ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
	$ZodNullable.init(inst, def);
	ZodType.init(inst, def);
	inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
	return new ZodNullable({
		type: "nullable",
		innerType
	});
}
const ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
	$ZodDefault.init(inst, def);
	ZodType.init(inst, def);
	inst.unwrap = () => inst._zod.def.innerType;
	inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
	return new ZodDefault({
		type: "default",
		innerType,
		get defaultValue() {
			return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
		}
	});
}
const ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
	$ZodPrefault.init(inst, def);
	ZodType.init(inst, def);
	inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
	return new ZodPrefault({
		type: "prefault",
		innerType,
		get defaultValue() {
			return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
		}
	});
}
const ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
	$ZodNonOptional.init(inst, def);
	ZodType.init(inst, def);
	inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
	return new ZodNonOptional({
		type: "nonoptional",
		innerType,
		...normalizeParams(params)
	});
}
const ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
	$ZodCatch.init(inst, def);
	ZodType.init(inst, def);
	inst.unwrap = () => inst._zod.def.innerType;
	inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
	return new ZodCatch({
		type: "catch",
		innerType,
		catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
	});
}
const ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
	$ZodPipe.init(inst, def);
	ZodType.init(inst, def);
	inst.in = def.in;
	inst.out = def.out;
});
function pipe(in_, out) {
	return new ZodPipe({
		type: "pipe",
		in: in_,
		out
	});
}
const ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
	$ZodReadonly.init(inst, def);
	ZodType.init(inst, def);
	inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
	return new ZodReadonly({
		type: "readonly",
		innerType
	});
}
const ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
	$ZodCustom.init(inst, def);
	ZodType.init(inst, def);
});
function refine(fn, _params = {}) {
	return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
	return _superRefine(fn);
}

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/coerce.js
function number(params) {
	return _coercedNumber(ZodNumber, params);
}

//#endregion
//#region ../../node_modules/.pnpm/@ikenxuan+xhshow-ts@1.0.0/node_modules/@ikenxuan/xhshow-ts/dist/esm/index.mjs
/*! 
* xhshow-ts
* XHS API signature generator
* MIT Licensed
*/
var CryptoConfig = class {
	MAX_32BIT = 4294967295;
	MAX_SIGNED_32BIT = 2147483647;
	BASE58_ALPHABET = "NOPQRStuvwxWXYZabcyz012DEFTKLMdefghijkl4563GHIJBC7mnop89+/AUVqrsOPQefghijkABCDEFGuvwz0123456789xy";
	STANDARD_BASE64_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	CUSTOM_BASE64_ALPHABET = "ZmserbBoHQtNP+wOcza/LpngG8yJq42KWYj0DSfdikx3VT16IlUAFM97hECvuRX5";
	BASE58_BASE = 58;
	BYTE_SIZE = 256;
	HEX_KEY = "af572b95ca65b2d9ec76bb5d2e97cb653299cc663399cc663399cce673399cce6733190c06030100000000008040209048241289c4e271381c0e0703018040a05028148ac56231180c0683c16030984c2693c964b259ac56abd5eaf5fafd7e3f9f4f279349a4d2e9743a9d4e279349a4d2e9f47a3d1e8f47239148a4d269341a8d4623110884422190c86432994ca6d3e974baddee773b1d8e47a35128148ac5623198cce6f3f97c3e1f8f47a3d168b45aad562b158ac5e2f1f87c3e9f4f279349a4d269b45aad56";
	TIMESTAMP_XOR_KEY = 41;
	STARTUP_TIME_OFFSET_MIN = 1e3;
	STARTUP_TIME_OFFSET_MAX = 4e3;
	EXPECTED_HEX_LENGTH = 32;
	OUTPUT_BYTE_COUNT = 8;
	HEX_CHUNK_SIZE = 2;
	VERSION_BYTES = [
		119,
		104,
		96,
		41
	];
	FIXED_INT_VALUE_1 = 15;
	FIXED_INT_VALUE_2 = 1291;
	ENV_STATIC_BYTES = [
		1,
		249,
		83,
		102,
		103,
		201,
		181,
		131,
		99,
		94,
		7,
		68,
		250,
		132,
		21
	];
	SIGNATURE_DATA_TEMPLATE = {
		"x0": "4.2.2",
		"x1": "xhs-pc-web",
		"x2": "Windows",
		"x3": "",
		"x4": "object"
	};
	X3_PREFIX = "mns0101_";
	XYS_PREFIX = "XYS_";
};
var BitOperations = class {
	config;
	constructor() {
		this.config = new CryptoConfig();
	}
	normalizeTo32bit(value) {
		return value & this.config.MAX_32BIT;
	}
	toSigned32bit(unsignedValue) {
		if (unsignedValue > this.config.MAX_SIGNED_32BIT) return unsignedValue - 4294967296;
		return unsignedValue;
	}
	computeSeedValue(seed32bit) {
		const normalizedSeed = this.normalizeTo32bit(seed32bit);
		const shift15Bits = normalizedSeed >> 15;
		const shift13Bits = normalizedSeed >> 13;
		const shift12Bits = normalizedSeed >> 12;
		const shift10Bits = normalizedSeed >> 10;
		const shiftedResult = ((shift15Bits & ~shift13Bits | shift13Bits & ~shift15Bits) ^ shift12Bits ^ shift10Bits) << 31 & this.config.MAX_32BIT;
		return this.toSigned32bit(shiftedResult);
	}
	xorTransformArray(sourceIntegers) {
		const result = new Uint8Array(sourceIntegers.length);
		const keyBuffer = Buffer.from(this.config.HEX_KEY, "hex");
		for (let i = 0; i < sourceIntegers.length; i++) result[i] = (sourceIntegers[i] ^ keyBuffer[i % keyBuffer.length]) & 255;
		return result;
	}
};
var Base58Encoder = class {
	config;
	constructor() {
		this.config = new CryptoConfig();
	}
	encodeToB58(inputBytes) {
		let numberAccumulator = 0n;
		for (const byte of inputBytes) numberAccumulator = numberAccumulator * BigInt(this.config.BYTE_SIZE) + BigInt(byte);
		let leadingZerosCount = 0;
		for (const byte of inputBytes) if (byte === 0) leadingZerosCount++;
		else break;
		const encodedCharacters = [];
		while (numberAccumulator > 0n) {
			const remainder = Number(numberAccumulator % BigInt(this.config.BASE58_BASE));
			numberAccumulator = numberAccumulator / BigInt(this.config.BASE58_BASE);
			encodedCharacters.push(this.config.BASE58_ALPHABET[remainder]);
		}
		encodedCharacters.reverse();
		encodedCharacters.unshift(...Array(leadingZerosCount).fill(this.config.BASE58_ALPHABET[0]));
		return encodedCharacters.join("");
	}
};
var Base64Encoder = class {
	config;
	constructor() {
		this.config = new CryptoConfig();
	}
	encodeToB64(dataToEncode) {
		const standardEncoded = Buffer.from(dataToEncode, "utf8").toString("base64");
		let result = "";
		for (const char of standardEncoded) if (char === "=") result += char;
		else {
			const index$1 = this.config.STANDARD_BASE64_ALPHABET.indexOf(char);
			result += this.config.CUSTOM_BASE64_ALPHABET[index$1];
		}
		return result;
	}
};
var HexProcessor = class {
	config;
	constructor() {
		this.config = new CryptoConfig();
	}
	hexStringToBytes(hexString) {
		const byteValues = [];
		for (let i = 0; i < hexString.length; i += this.config.HEX_CHUNK_SIZE) {
			const hexChunk = hexString.slice(i, i + this.config.HEX_CHUNK_SIZE);
			byteValues.push(parseInt(hexChunk, 16));
		}
		return byteValues;
	}
	processHexParameter(hexString, xorKey) {
		if (hexString.length !== this.config.EXPECTED_HEX_LENGTH) throw new Error(`hex parameter must be ${this.config.EXPECTED_HEX_LENGTH} characters`);
		return this.hexStringToBytes(hexString).map((byteVal) => byteVal ^ xorKey).slice(0, this.config.OUTPUT_BYTE_COUNT);
	}
};
var RandomGenerator = class {
	config;
	constructor() {
		this.config = new CryptoConfig();
	}
	generateRandomBytes(byteCount) {
		return Array.from({ length: byteCount }, () => Math.floor(Math.random() * this.config.BYTE_SIZE));
	}
	generateRandomByteInRange(minVal, maxVal) {
		return Math.floor(Math.random() * (maxVal - minVal + 1)) + minVal;
	}
	generateRandomInt() {
		return Math.floor(Math.random() * (this.config.MAX_32BIT + 1));
	}
};
var CryptoProcessor = class {
	config;
	bitOps;
	b58encoder;
	b64encoder;
	hexProcessor;
	randomGen;
	constructor() {
		this.config = new CryptoConfig();
		this.bitOps = new BitOperations();
		this.b58encoder = new Base58Encoder();
		this.b64encoder = new Base64Encoder();
		this.hexProcessor = new HexProcessor();
		this.randomGen = new RandomGenerator();
	}
	encodeTimestamp(ts, randomizeFirst = true) {
		const key = Array(8).fill(this.config.TIMESTAMP_XOR_KEY);
		const encoded = this.intToLeBytes(ts, 8).map((a, i) => a ^ key[i]);
		if (randomizeFirst) encoded[0] = this.randomGen.generateRandomByteInRange(0, 255);
		return encoded;
	}
	intToLeBytes(val, length = 4) {
		const arr = [];
		for (let i = 0; i < length; i++) {
			arr.push(val & 255);
			val = Math.floor(val / 256);
		}
		return arr;
	}
	strToLenPrefixedBytes(s$1) {
		const buf = Buffer.from(s$1, "utf8");
		return [buf.length, ...Array.from(buf)];
	}
	buildPayloadArray(hexParameter, a1Value, appIdentifier = "xhs-pc-web", stringParam = "") {
		const randNum = this.randomGen.generateRandomInt();
		const ts = Date.now();
		const startupTs = ts - (this.config.STARTUP_TIME_OFFSET_MIN + this.randomGen.generateRandomByteInRange(0, this.config.STARTUP_TIME_OFFSET_MAX - this.config.STARTUP_TIME_OFFSET_MIN));
		const arr = [];
		arr.push(...this.config.VERSION_BYTES);
		const randBytes = this.intToLeBytes(randNum, 4);
		arr.push(...randBytes);
		const xorKey = randBytes[0];
		arr.push(...this.encodeTimestamp(ts, true));
		arr.push(...this.intToLeBytes(startupTs, 8));
		arr.push(...this.intToLeBytes(this.config.FIXED_INT_VALUE_1));
		arr.push(...this.intToLeBytes(this.config.FIXED_INT_VALUE_2));
		const stringParamLength = Buffer.from(stringParam, "utf8").length;
		arr.push(...this.intToLeBytes(stringParamLength));
		const md5Bytes = Buffer.from(hexParameter, "hex");
		const xorMd5Bytes = Array.from(md5Bytes).map((b) => b ^ xorKey);
		arr.push(...xorMd5Bytes.slice(0, 8));
		arr.push(...this.strToLenPrefixedBytes(a1Value));
		arr.push(...this.strToLenPrefixedBytes(appIdentifier));
		arr.push(this.config.ENV_STATIC_BYTES[0], this.randomGen.generateRandomByteInRange(0, 255), ...this.config.ENV_STATIC_BYTES.slice(1));
		return arr;
	}
};
var methodSchema = _enum(["GET", "POST"], { message: " \"GET\"  \"POST\"" });
var uriSchema = string({ message: "URI " }).min(1, "URI ");
var a1ValueSchema = string({ message: "a1Value " });
var signatureParamsSchema = object({
	method: methodSchema,
	uri: uriSchema,
	a1Value: a1ValueSchema
});
var getSignatureParamsSchema = object({
	uri: uriSchema,
	a1Value: a1ValueSchema
});
var postSignatureParamsSchema = object({
	uri: uriSchema,
	a1Value: a1ValueSchema
});
function validateSignatureParams(method, uri$1, a1Value) {
	try {
		signatureParamsSchema.parse({
			method,
			uri: uri$1,
			a1Value
		});
	} catch (error) {
		if (error instanceof ZodError) {
			const firstError = error.issues[0];
			throw new TypeError(firstError.message);
		}
		throw error;
	}
}
function validateGetSignatureParams(uri$1, a1Value) {
	try {
		getSignatureParamsSchema.parse({
			uri: uri$1,
			a1Value
		});
	} catch (error) {
		if (error instanceof ZodError) {
			const firstError = error.issues[0];
			throw new TypeError(firstError.message);
		}
		throw error;
	}
}
function validatePostSignatureParams(uri$1, a1Value) {
	try {
		postSignatureParamsSchema.parse({
			uri: uri$1,
			a1Value
		});
	} catch (error) {
		if (error instanceof ZodError) {
			const firstError = error.issues[0];
			throw new TypeError(firstError.message);
		}
		throw error;
	}
}
var Xhshow = class {
	cryptoProcessor;
	constructor() {
		this.cryptoProcessor = new CryptoProcessor();
	}
	buildContentString(method, uri$1, payload = null) {
		const normalizedPayload = payload || {};
		if (method.toUpperCase() === "POST") return uri$1 + JSON.stringify(normalizedPayload, null, 0).replace(/, /g, ",").replace(/: /g, ":");
		else {
			if (Object.keys(normalizedPayload).length === 0) return uri$1;
			return `${uri$1}?${Object.entries(normalizedPayload).map(([key, value]) => {
				let valStr = "";
				if (Array.isArray(value) || value instanceof Array) valStr = value.map((v) => String(v)).join(",");
				else valStr = value !== null ? String(value) : "";
				return `${key}=${valStr}`;
			}).join("&")}`;
		}
	}
	generateDValue(content) {
		return createHash("md5").update(content, "utf8").digest("hex");
	}
	buildSignature(dValue, a1Value, xsecAppid = "xhs-pc-web", stringParam = "") {
		const payloadArray = this.cryptoProcessor.buildPayloadArray(dValue, a1Value, xsecAppid, stringParam);
		const xorResult = this.cryptoProcessor.bitOps.xorTransformArray(payloadArray);
		return this.cryptoProcessor.b58encoder.encodeToB58(xorResult);
	}
	signXs(method, uri$1, a1Value, xsecAppid = "xhs-pc-web", payload = null) {
		validateSignatureParams(method, uri$1, a1Value);
		const signatureData = { ...this.cryptoProcessor.config.SIGNATURE_DATA_TEMPLATE };
		const contentString = this.buildContentString(method, uri$1, payload);
		const dValue = this.generateDValue(contentString);
		signatureData.x3 = this.cryptoProcessor.config.X3_PREFIX + this.buildSignature(dValue, a1Value, xsecAppid, contentString);
		const jsonStr = JSON.stringify(signatureData, null, 0).replace(/, /g, ",").replace(/: /g, ":");
		return this.cryptoProcessor.config.XYS_PREFIX + this.cryptoProcessor.b64encoder.encodeToB64(jsonStr);
	}
	signXsGet(uri$1, a1Value, xsecAppid = "xhs-pc-web", params = null) {
		validateGetSignatureParams(uri$1, a1Value);
		return this.signXs("GET", uri$1, a1Value, xsecAppid, params);
	}
	signXsPost(uri$1, a1Value, xsecAppid = "xhs-pc-web", payload = null) {
		validatePostSignatureParams(uri$1, a1Value);
		return this.signXs("POST", uri$1, a1Value, xsecAppid, payload);
	}
};

//#endregion
//#region ../../node_modules/.pnpm/@karinjs+express@1.0.3/node_modules/@karinjs/express/dist/express.js
function _mergeNamespaces(n, m$1) {
	for (var i = 0; i < m$1.length; i++) {
		const e = m$1[i];
		if (typeof e !== "string" && !Array.isArray(e)) {
			for (const k in e) if (k !== "default" && !(k in n)) {
				const d$1 = Object.getOwnPropertyDescriptor(e, k);
				if (d$1) Object.defineProperty(n, k, d$1.get ? d$1 : {
					enumerable: true,
					get: () => e[k]
				});
			}
		}
	}
	return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n) {
	if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
	var f = n.default;
	if (typeof f == "function") {
		var a = function a2() {
			if (this instanceof a2) return Reflect.construct(f, arguments, this.constructor);
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
	} else a = {};
	Object.defineProperty(a, "__esModule", { value: true });
	Object.keys(n).forEach(function(k) {
		var d$1 = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d$1.get ? d$1 : {
			enumerable: true,
			get: function() {
				return n[k];
			}
		});
	});
	return a;
}
var express$1 = { exports: {} };
var bodyParser = { exports: {} };
var httpErrors = { exports: {} };
/*!
* depd
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var browser$1;
var hasRequiredBrowser$1;
function requireBrowser$1() {
	if (hasRequiredBrowser$1) return browser$1;
	hasRequiredBrowser$1 = 1;
	browser$1 = depd;
	function depd(namespace) {
		if (!namespace) throw new TypeError("argument namespace is required");
		function deprecate(message) {}
		deprecate._file = void 0;
		deprecate._ignored = true;
		deprecate._namespace = namespace;
		deprecate._traced = false;
		deprecate._warned = /* @__PURE__ */ Object.create(null);
		deprecate.function = wrapfunction;
		deprecate.property = wrapproperty;
		return deprecate;
	}
	function wrapfunction(fn, message) {
		if (typeof fn !== "function") throw new TypeError("argument fn must be a function");
		return fn;
	}
	function wrapproperty(obj, prop, message) {
		if (!obj || typeof obj !== "object" && typeof obj !== "function") throw new TypeError("argument obj must be object");
		var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
		if (!descriptor) throw new TypeError("must call property on owner object");
		if (!descriptor.configurable) throw new TypeError("property must be configurable");
	}
	return browser$1;
}
var setprototypeof;
var hasRequiredSetprototypeof;
function requireSetprototypeof() {
	if (hasRequiredSetprototypeof) return setprototypeof;
	hasRequiredSetprototypeof = 1;
	setprototypeof = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
	function setProtoOf(obj, proto) {
		obj.__proto__ = proto;
		return obj;
	}
	function mixinProperties(obj, proto) {
		for (var prop in proto) if (!Object.prototype.hasOwnProperty.call(obj, prop)) obj[prop] = proto[prop];
		return obj;
	}
	return setprototypeof;
}
const require$$0$3 = {
	"100": "Continue",
	"101": "Switching Protocols",
	"102": "Processing",
	"103": "Early Hints",
	"200": "OK",
	"201": "Created",
	"202": "Accepted",
	"203": "Non-Authoritative Information",
	"204": "No Content",
	"205": "Reset Content",
	"206": "Partial Content",
	"207": "Multi-Status",
	"208": "Already Reported",
	"226": "IM Used",
	"300": "Multiple Choices",
	"301": "Moved Permanently",
	"302": "Found",
	"303": "See Other",
	"304": "Not Modified",
	"305": "Use Proxy",
	"307": "Temporary Redirect",
	"308": "Permanent Redirect",
	"400": "Bad Request",
	"401": "Unauthorized",
	"402": "Payment Required",
	"403": "Forbidden",
	"404": "Not Found",
	"405": "Method Not Allowed",
	"406": "Not Acceptable",
	"407": "Proxy Authentication Required",
	"408": "Request Timeout",
	"409": "Conflict",
	"410": "Gone",
	"411": "Length Required",
	"412": "Precondition Failed",
	"413": "Payload Too Large",
	"414": "URI Too Long",
	"415": "Unsupported Media Type",
	"416": "Range Not Satisfiable",
	"417": "Expectation Failed",
	"418": "I'm a Teapot",
	"421": "Misdirected Request",
	"422": "Unprocessable Entity",
	"423": "Locked",
	"424": "Failed Dependency",
	"425": "Too Early",
	"426": "Upgrade Required",
	"428": "Precondition Required",
	"429": "Too Many Requests",
	"431": "Request Header Fields Too Large",
	"451": "Unavailable For Legal Reasons",
	"500": "Internal Server Error",
	"501": "Not Implemented",
	"502": "Bad Gateway",
	"503": "Service Unavailable",
	"504": "Gateway Timeout",
	"505": "HTTP Version Not Supported",
	"506": "Variant Also Negotiates",
	"507": "Insufficient Storage",
	"508": "Loop Detected",
	"509": "Bandwidth Limit Exceeded",
	"510": "Not Extended",
	"511": "Network Authentication Required"
};
/*!
* statuses
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2016 Douglas Christopher Wilson
* MIT Licensed
*/
var statuses;
var hasRequiredStatuses;
function requireStatuses() {
	if (hasRequiredStatuses) return statuses;
	hasRequiredStatuses = 1;
	var codes = require$$0$3;
	statuses = status;
	status.message = codes;
	status.code = createMessageToStatusCodeMap(codes);
	status.codes = createStatusCodeList(codes);
	status.redirect = {
		300: true,
		301: true,
		302: true,
		303: true,
		305: true,
		307: true,
		308: true
	};
	status.empty = {
		204: true,
		205: true,
		304: true
	};
	status.retry = {
		502: true,
		503: true,
		504: true
	};
	function createMessageToStatusCodeMap(codes2) {
		var map = {};
		Object.keys(codes2).forEach(function forEachCode(code) {
			var message = codes2[code];
			var status2 = Number(code);
			map[message.toLowerCase()] = status2;
		});
		return map;
	}
	function createStatusCodeList(codes2) {
		return Object.keys(codes2).map(function mapCode(code) {
			return Number(code);
		});
	}
	function getStatusCode(message) {
		var msg = message.toLowerCase();
		if (!Object.prototype.hasOwnProperty.call(status.code, msg)) throw new Error("invalid status message: \"" + message + "\"");
		return status.code[msg];
	}
	function getStatusMessage(code) {
		if (!Object.prototype.hasOwnProperty.call(status.message, code)) throw new Error("invalid status code: " + code);
		return status.message[code];
	}
	function status(code) {
		if (typeof code === "number") return getStatusMessage(code);
		if (typeof code !== "string") throw new TypeError("code must be a number or string");
		var n = parseInt(code, 10);
		if (!isNaN(n)) return getStatusMessage(n);
		return getStatusCode(code);
	}
	return statuses;
}
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
	if (hasRequiredInherits_browser) return inherits_browser.exports;
	hasRequiredInherits_browser = 1;
	if (typeof Object.create === "function") inherits_browser.exports = function inherits$1(ctor, superCtor) {
		if (superCtor) {
			ctor.super_ = superCtor;
			ctor.prototype = Object.create(superCtor.prototype, { constructor: {
				value: ctor,
				enumerable: false,
				writable: true,
				configurable: true
			} });
		}
	};
	else inherits_browser.exports = function inherits$1(ctor, superCtor) {
		if (superCtor) {
			ctor.super_ = superCtor;
			var TempCtor = function() {};
			TempCtor.prototype = superCtor.prototype;
			ctor.prototype = new TempCtor();
			ctor.prototype.constructor = ctor;
		}
	};
	return inherits_browser.exports;
}
/*!
* toidentifier
* Copyright(c) 2016 Douglas Christopher Wilson
* MIT Licensed
*/
var toidentifier;
var hasRequiredToidentifier;
function requireToidentifier() {
	if (hasRequiredToidentifier) return toidentifier;
	hasRequiredToidentifier = 1;
	toidentifier = toIdentifier;
	function toIdentifier(str) {
		return str.split(" ").map(function(token) {
			return token.slice(0, 1).toUpperCase() + token.slice(1);
		}).join("").replace(/[^ _0-9a-z]/gi, "");
	}
	return toidentifier;
}
/*!
* http-errors
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2016 Douglas Christopher Wilson
* MIT Licensed
*/
var hasRequiredHttpErrors;
function requireHttpErrors() {
	if (hasRequiredHttpErrors) return httpErrors.exports;
	hasRequiredHttpErrors = 1;
	(function(module$1) {
		var deprecate = requireBrowser$1()("http-errors");
		var setPrototypeOf = requireSetprototypeof();
		var statuses2 = requireStatuses();
		var inherits$1 = requireInherits_browser();
		var toIdentifier = requireToidentifier();
		module$1.exports = createError;
		module$1.exports.HttpError = createHttpErrorConstructor();
		module$1.exports.isHttpError = createIsHttpErrorFunction(module$1.exports.HttpError);
		populateConstructorExports(module$1.exports, statuses2.codes, module$1.exports.HttpError);
		function codeClass(status) {
			return Number(String(status).charAt(0) + "00");
		}
		function createError() {
			var err;
			var msg;
			var status = 500;
			var props = {};
			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				var type2 = typeof arg;
				if (type2 === "object" && arg instanceof Error) {
					err = arg;
					status = err.status || err.statusCode || status;
				} else if (type2 === "number" && i === 0) status = arg;
				else if (type2 === "string") msg = arg;
				else if (type2 === "object") props = arg;
				else throw new TypeError("argument #" + (i + 1) + " unsupported type " + type2);
			}
			if (typeof status === "number" && (status < 400 || status >= 600)) deprecate("non-error status code; use only 4xx or 5xx status codes");
			if (typeof status !== "number" || !statuses2.message[status] && (status < 400 || status >= 600)) status = 500;
			var HttpError = createError[status] || createError[codeClass(status)];
			if (!err) {
				err = HttpError ? new HttpError(msg) : new Error(msg || statuses2.message[status]);
				Error.captureStackTrace(err, createError);
			}
			if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
				err.expose = status < 500;
				err.status = err.statusCode = status;
			}
			for (var key in props) if (key !== "status" && key !== "statusCode") err[key] = props[key];
			return err;
		}
		function createHttpErrorConstructor() {
			function HttpError() {
				throw new TypeError("cannot construct abstract class");
			}
			inherits$1(HttpError, Error);
			return HttpError;
		}
		function createClientErrorConstructor(HttpError, name, code) {
			var className = toClassName(name);
			function ClientError(message) {
				var msg = message != null ? message : statuses2.message[code];
				var err = new Error(msg);
				Error.captureStackTrace(err, ClientError);
				setPrototypeOf(err, ClientError.prototype);
				Object.defineProperty(err, "message", {
					enumerable: true,
					configurable: true,
					value: msg,
					writable: true
				});
				Object.defineProperty(err, "name", {
					enumerable: false,
					configurable: true,
					value: className,
					writable: true
				});
				return err;
			}
			inherits$1(ClientError, HttpError);
			nameFunc(ClientError, className);
			ClientError.prototype.status = code;
			ClientError.prototype.statusCode = code;
			ClientError.prototype.expose = true;
			return ClientError;
		}
		function createIsHttpErrorFunction(HttpError) {
			return function isHttpError(val) {
				if (!val || typeof val !== "object") return false;
				if (val instanceof HttpError) return true;
				return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
			};
		}
		function createServerErrorConstructor(HttpError, name, code) {
			var className = toClassName(name);
			function ServerError(message) {
				var msg = message != null ? message : statuses2.message[code];
				var err = new Error(msg);
				Error.captureStackTrace(err, ServerError);
				setPrototypeOf(err, ServerError.prototype);
				Object.defineProperty(err, "message", {
					enumerable: true,
					configurable: true,
					value: msg,
					writable: true
				});
				Object.defineProperty(err, "name", {
					enumerable: false,
					configurable: true,
					value: className,
					writable: true
				});
				return err;
			}
			inherits$1(ServerError, HttpError);
			nameFunc(ServerError, className);
			ServerError.prototype.status = code;
			ServerError.prototype.statusCode = code;
			ServerError.prototype.expose = false;
			return ServerError;
		}
		function nameFunc(func, name) {
			var desc$1 = Object.getOwnPropertyDescriptor(func, "name");
			if (desc$1 && desc$1.configurable) {
				desc$1.value = name;
				Object.defineProperty(func, "name", desc$1);
			}
		}
		function populateConstructorExports(exports$1, codes, HttpError) {
			codes.forEach(function forEachCode(code) {
				var CodeError;
				var name = toIdentifier(statuses2.message[code]);
				switch (codeClass(code)) {
					case 400:
						CodeError = createClientErrorConstructor(HttpError, name, code);
						break;
					case 500:
						CodeError = createServerErrorConstructor(HttpError, name, code);
						break;
				}
				if (CodeError) {
					exports$1[code] = CodeError;
					exports$1[name] = CodeError;
				}
			});
		}
		function toClassName(name) {
			return name.substr(-5) !== "Error" ? name + "Error" : name;
		}
	})(httpErrors);
	return httpErrors.exports;
}
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
	if (hasRequiredMs) return ms;
	hasRequiredMs = 1;
	var s$1 = 1e3;
	var m$1 = s$1 * 60;
	var h$1 = m$1 * 60;
	var d$1 = h$1 * 24;
	var w$1 = d$1 * 7;
	var y$1 = d$1 * 365.25;
	ms = function(val, options) {
		options = options || {};
		var type2 = typeof val;
		if (type2 === "string" && val.length > 0) return parse2(val);
		else if (type2 === "number" && isFinite(val)) return options.long ? fmtLong$1(val) : fmtShort$1(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	function parse2(str) {
		str = String(str);
		if (str.length > 100) return;
		var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
		if (!match) return;
		var n = parseFloat(match[1]);
		switch ((match[2] || "ms").toLowerCase()) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n * y$1;
			case "weeks":
			case "week":
			case "w": return n * w$1;
			case "days":
			case "day":
			case "d": return n * d$1;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n * h$1;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n * m$1;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n * s$1;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n;
			default: return;
		}
	}
	function fmtShort$1(ms2) {
		var msAbs = Math.abs(ms2);
		if (msAbs >= d$1) return Math.round(ms2 / d$1) + "d";
		if (msAbs >= h$1) return Math.round(ms2 / h$1) + "h";
		if (msAbs >= m$1) return Math.round(ms2 / m$1) + "m";
		if (msAbs >= s$1) return Math.round(ms2 / s$1) + "s";
		return ms2 + "ms";
	}
	function fmtLong$1(ms2) {
		var msAbs = Math.abs(ms2);
		if (msAbs >= d$1) return plural$1(ms2, msAbs, d$1, "day");
		if (msAbs >= h$1) return plural$1(ms2, msAbs, h$1, "hour");
		if (msAbs >= m$1) return plural$1(ms2, msAbs, m$1, "minute");
		if (msAbs >= s$1) return plural$1(ms2, msAbs, s$1, "second");
		return ms2 + " ms";
	}
	function plural$1(ms2, msAbs, n, name) {
		var isPlural = msAbs >= n * 1.5;
		return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
	}
	return ms;
}
var common$1;
var hasRequiredCommon;
function requireCommon() {
	if (hasRequiredCommon) return common$1;
	hasRequiredCommon = 1;
	function setup$1(env$1) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = requireMs();
		createDebug.destroy = destroy$1;
		Object.keys(env$1).forEach((key) => {
			createDebug[key] = env$1[key];
		});
		createDebug.names = [];
		createDebug.skips = [];
		createDebug.formatters = {};
		function selectColor(namespace) {
			let hash = 0;
			for (let i = 0; i < namespace.length; i++) {
				hash = (hash << 5) - hash + namespace.charCodeAt(i);
				hash |= 0;
			}
			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;
			function debug$2(...args) {
				if (!debug$2.enabled) return;
				const self2 = debug$2;
				const curr = Number(/* @__PURE__ */ new Date());
				self2.diff = curr - (prevTime || curr);
				self2.prev = prevTime;
				self2.curr = curr;
				prevTime = curr;
				args[0] = createDebug.coerce(args[0]);
				if (typeof args[0] !== "string") args.unshift("%O");
				let index2 = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					if (match === "%%") return "%";
					index2++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === "function") {
						const val = args[index2];
						match = formatter.call(self2, val);
						args.splice(index2, 1);
						index2--;
					}
					return match;
				});
				createDebug.formatArgs.call(self2, args);
				(self2.log || createDebug.log).apply(self2, args);
			}
			debug$2.namespace = namespace;
			debug$2.useColors = createDebug.useColors();
			debug$2.color = createDebug.selectColor(namespace);
			debug$2.extend = extend$2;
			debug$2.destroy = createDebug.destroy;
			Object.defineProperty(debug$2, "enabled", {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) return enableOverride;
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}
					return enabledCache;
				},
				set: (v) => {
					enableOverride = v;
				}
			});
			if (typeof createDebug.init === "function") createDebug.init(debug$2);
			return debug$2;
		}
		function extend$2(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;
			createDebug.names = [];
			createDebug.skips = [];
			const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
			for (const ns of split) if (ns[0] === "-") createDebug.skips.push(ns.slice(1));
			else createDebug.names.push(ns);
		}
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;
			while (searchIndex < search.length) if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) if (template[templateIndex] === "*") {
				starIndex = templateIndex;
				matchIndex = searchIndex;
				templateIndex++;
			} else {
				searchIndex++;
				templateIndex++;
			}
			else if (starIndex !== -1) {
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else return false;
			while (templateIndex < template.length && template[templateIndex] === "*") templateIndex++;
			return templateIndex === template.length;
		}
		function disable() {
			const namespaces = [...createDebug.names, ...createDebug.skips.map((namespace) => "-" + namespace)].join(",");
			createDebug.enable("");
			return namespaces;
		}
		function enabled(name) {
			for (const skip of createDebug.skips) if (matchesTemplate(name, skip)) return false;
			for (const ns of createDebug.names) if (matchesTemplate(name, ns)) return true;
			return false;
		}
		function coerce(val) {
			if (val instanceof Error) return val.stack || val.message;
			return val;
		}
		function destroy$1() {
			console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
		}
		createDebug.enable(createDebug.load());
		return createDebug;
	}
	common$1 = setup$1;
	return common$1;
}
var hasRequiredBrowser;
function requireBrowser() {
	if (hasRequiredBrowser) return browser.exports;
	hasRequiredBrowser = 1;
	(function(module$1, exports$1) {
		exports$1.formatArgs = formatArgs$2;
		exports$1.save = save$2;
		exports$1.load = load$2;
		exports$1.useColors = useColors$2;
		exports$1.storage = localstorage$1();
		exports$1.destroy = /* @__PURE__ */ (() => {
			let warned = false;
			return () => {
				if (!warned) {
					warned = true;
					console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
				}
			};
		})();
		exports$1.colors = [
			"#0000CC",
			"#0000FF",
			"#0033CC",
			"#0033FF",
			"#0066CC",
			"#0066FF",
			"#0099CC",
			"#0099FF",
			"#00CC00",
			"#00CC33",
			"#00CC66",
			"#00CC99",
			"#00CCCC",
			"#00CCFF",
			"#3300CC",
			"#3300FF",
			"#3333CC",
			"#3333FF",
			"#3366CC",
			"#3366FF",
			"#3399CC",
			"#3399FF",
			"#33CC00",
			"#33CC33",
			"#33CC66",
			"#33CC99",
			"#33CCCC",
			"#33CCFF",
			"#6600CC",
			"#6600FF",
			"#6633CC",
			"#6633FF",
			"#66CC00",
			"#66CC33",
			"#9900CC",
			"#9900FF",
			"#9933CC",
			"#9933FF",
			"#99CC00",
			"#99CC33",
			"#CC0000",
			"#CC0033",
			"#CC0066",
			"#CC0099",
			"#CC00CC",
			"#CC00FF",
			"#CC3300",
			"#CC3333",
			"#CC3366",
			"#CC3399",
			"#CC33CC",
			"#CC33FF",
			"#CC6600",
			"#CC6633",
			"#CC9900",
			"#CC9933",
			"#CCCC00",
			"#CCCC33",
			"#FF0000",
			"#FF0033",
			"#FF0066",
			"#FF0099",
			"#FF00CC",
			"#FF00FF",
			"#FF3300",
			"#FF3333",
			"#FF3366",
			"#FF3399",
			"#FF33CC",
			"#FF33FF",
			"#FF6600",
			"#FF6633",
			"#FF9900",
			"#FF9933",
			"#FFCC00",
			"#FFCC33"
		];
		function useColors$2() {
			if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
			if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
			let m$1;
			return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m$1 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m$1[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
		}
		function formatArgs$2(args) {
			args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module$1.exports.humanize(this.diff);
			if (!this.useColors) return;
			const c = "color: " + this.color;
			args.splice(1, 0, c, "color: inherit");
			let index2 = 0;
			let lastC = 0;
			args[0].replace(/%[a-zA-Z%]/g, (match) => {
				if (match === "%%") return;
				index2++;
				if (match === "%c") lastC = index2;
			});
			args.splice(lastC, 0, c);
		}
		exports$1.log = console.debug || console.log || (() => {});
		function save$2(namespaces) {
			try {
				if (namespaces) exports$1.storage.setItem("debug", namespaces);
				else exports$1.storage.removeItem("debug");
			} catch (error) {}
		}
		function load$2() {
			let r;
			try {
				r = exports$1.storage.getItem("debug");
			} catch (error) {}
			if (!r && typeof process !== "undefined" && "env" in process) r = process.env.DEBUG;
			return r;
		}
		function localstorage$1() {
			try {
				return localStorage;
			} catch (error) {}
		}
		module$1.exports = requireCommon()(exports$1);
		const { formatters: formatters$2 } = module$1.exports;
		formatters$2.j = function(v) {
			try {
				return JSON.stringify(v);
			} catch (error) {
				return "[UnexpectedJSONParseError]: " + error.message;
			}
		};
	})(browser, browser.exports);
	return browser.exports;
}
var onFinished = { exports: {} };
/*!
* ee-first
* Copyright(c) 2014 Jonathan Ong
* MIT Licensed
*/
var eeFirst;
var hasRequiredEeFirst;
function requireEeFirst() {
	if (hasRequiredEeFirst) return eeFirst;
	hasRequiredEeFirst = 1;
	eeFirst = first;
	function first(stuff, done) {
		if (!Array.isArray(stuff)) throw new TypeError("arg must be an array of [ee, events...] arrays");
		var cleanups = [];
		for (var i = 0; i < stuff.length; i++) {
			var arr = stuff[i];
			if (!Array.isArray(arr) || arr.length < 2) throw new TypeError("each array member must be [ee, events...]");
			var ee = arr[0];
			for (var j = 1; j < arr.length; j++) {
				var event = arr[j];
				var fn = listener(event, callback);
				ee.on(event, fn);
				cleanups.push({
					ee,
					event,
					fn
				});
			}
		}
		function callback() {
			cleanup();
			done.apply(null, arguments);
		}
		function cleanup() {
			var x;
			for (var i2 = 0; i2 < cleanups.length; i2++) {
				x = cleanups[i2];
				x.ee.removeListener(x.event, x.fn);
			}
		}
		function thunk(fn2) {
			done = fn2;
		}
		thunk.cancel = cleanup;
		return thunk;
	}
	function listener(event, done) {
		return function onevent(arg1) {
			var args = new Array(arguments.length);
			var ee = this;
			var err = event === "error" ? arg1 : null;
			for (var i = 0; i < args.length; i++) args[i] = arguments[i];
			done(err, ee, event, args);
		};
	}
	return eeFirst;
}
/*!
* on-finished
* Copyright(c) 2013 Jonathan Ong
* Copyright(c) 2014 Douglas Christopher Wilson
* MIT Licensed
*/
var hasRequiredOnFinished;
function requireOnFinished() {
	if (hasRequiredOnFinished) return onFinished.exports;
	hasRequiredOnFinished = 1;
	onFinished.exports = onFinished$1;
	onFinished.exports.isFinished = isFinished;
	var asyncHooks = tryRequireAsyncHooks();
	var first = requireEeFirst();
	var defer$2 = typeof setImmediate === "function" ? setImmediate : function(fn) {
		process.nextTick(fn.bind.apply(fn, arguments));
	};
	function onFinished$1(msg, listener) {
		if (isFinished(msg) !== false) {
			defer$2(listener, null, msg);
			return msg;
		}
		attachListener(msg, wrap$1(listener));
		return msg;
	}
	function isFinished(msg) {
		var socket = msg.socket;
		if (typeof msg.finished === "boolean") return Boolean(msg.finished || socket && !socket.writable);
		if (typeof msg.complete === "boolean") return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
	}
	function attachFinishedListener(msg, callback) {
		var eeMsg;
		var eeSocket;
		var finished = false;
		function onFinish(error) {
			eeMsg.cancel();
			eeSocket.cancel();
			finished = true;
			callback(error);
		}
		eeMsg = eeSocket = first([[
			msg,
			"end",
			"finish"
		]], onFinish);
		function onSocket(socket) {
			msg.removeListener("socket", onSocket);
			if (finished) return;
			if (eeMsg !== eeSocket) return;
			eeSocket = first([[
				socket,
				"error",
				"close"
			]], onFinish);
		}
		if (msg.socket) {
			onSocket(msg.socket);
			return;
		}
		msg.on("socket", onSocket);
		if (msg.socket === void 0) patchAssignSocket(msg, onSocket);
	}
	function attachListener(msg, listener) {
		var attached = msg.__onFinished;
		if (!attached || !attached.queue) {
			attached = msg.__onFinished = createListener(msg);
			attachFinishedListener(msg, attached);
		}
		attached.queue.push(listener);
	}
	function createListener(msg) {
		function listener(err) {
			if (msg.__onFinished === listener) msg.__onFinished = null;
			if (!listener.queue) return;
			var queue = listener.queue;
			listener.queue = null;
			for (var i = 0; i < queue.length; i++) queue[i](err, msg);
		}
		listener.queue = [];
		return listener;
	}
	function patchAssignSocket(res, callback) {
		var assignSocket = res.assignSocket;
		if (typeof assignSocket !== "function") return;
		res.assignSocket = function _assignSocket(socket) {
			assignSocket.call(this, socket);
			callback(socket);
		};
	}
	function tryRequireAsyncHooks() {
		try {
			return __require("async_hooks");
		} catch (e) {
			return {};
		}
	}
	function wrap$1(fn) {
		var res;
		if (asyncHooks.AsyncResource) res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
		if (!res || !res.runInAsyncScope) return fn;
		return res.runInAsyncScope.bind(res, fn, null);
	}
	return onFinished.exports;
}
var bytes = { exports: {} };
/*!
* bytes
* Copyright(c) 2012-2014 TJ Holowaychuk
* Copyright(c) 2015 Jed Watson
* MIT Licensed
*/
var hasRequiredBytes;
function requireBytes() {
	if (hasRequiredBytes) return bytes.exports;
	hasRequiredBytes = 1;
	bytes.exports = bytes$1;
	bytes.exports.format = format;
	bytes.exports.parse = parse2;
	var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
	var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
	var map = {
		b: 1,
		kb: 1024,
		mb: 1 << 20,
		gb: 1 << 30,
		tb: Math.pow(1024, 4),
		pb: Math.pow(1024, 5)
	};
	var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
	function bytes$1(value, options) {
		if (typeof value === "string") return parse2(value);
		if (typeof value === "number") return format(value, options);
		return null;
	}
	function format(value, options) {
		if (!Number.isFinite(value)) return null;
		var mag = Math.abs(value);
		var thousandsSeparator = options && options.thousandsSeparator || "";
		var unitSeparator = options && options.unitSeparator || "";
		var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
		var fixedDecimals = Boolean(options && options.fixedDecimals);
		var unit = options && options.unit || "";
		if (!unit || !map[unit.toLowerCase()]) if (mag >= map.pb) unit = "PB";
		else if (mag >= map.tb) unit = "TB";
		else if (mag >= map.gb) unit = "GB";
		else if (mag >= map.mb) unit = "MB";
		else if (mag >= map.kb) unit = "KB";
		else unit = "B";
		var str = (value / map[unit.toLowerCase()]).toFixed(decimalPlaces);
		if (!fixedDecimals) str = str.replace(formatDecimalsRegExp, "$1");
		if (thousandsSeparator) str = str.split(".").map(function(s$1, i) {
			return i === 0 ? s$1.replace(formatThousandsRegExp, thousandsSeparator) : s$1;
		}).join(".");
		return str + unitSeparator + unit;
	}
	function parse2(val) {
		if (typeof val === "number" && !isNaN(val)) return val;
		if (typeof val !== "string") return null;
		var results = parseRegExp.exec(val);
		var floatValue;
		var unit = "b";
		if (!results) {
			floatValue = parseInt(val, 10);
			unit = "b";
		} else {
			floatValue = parseFloat(results[1]);
			unit = results[4].toLowerCase();
		}
		if (isNaN(floatValue)) return null;
		return Math.floor(map[unit] * floatValue);
	}
	return bytes.exports;
}
var lib$1 = { exports: {} };
var safer_1;
var hasRequiredSafer;
function requireSafer() {
	if (hasRequiredSafer) return safer_1;
	hasRequiredSafer = 1;
	var buffer$1 = require$$0$4;
	var Buffer2 = buffer$1.Buffer;
	var safer = {};
	var key;
	for (key in buffer$1) {
		if (!buffer$1.hasOwnProperty(key)) continue;
		if (key === "SlowBuffer" || key === "Buffer") continue;
		safer[key] = buffer$1[key];
	}
	var Safer = safer.Buffer = {};
	for (key in Buffer2) {
		if (!Buffer2.hasOwnProperty(key)) continue;
		if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
		Safer[key] = Buffer2[key];
	}
	safer.Buffer.prototype = Buffer2.prototype;
	if (!Safer.from || Safer.from === Uint8Array.from) Safer.from = function(value, encodingOrOffset, length) {
		if (typeof value === "number") throw new TypeError("The \"value\" argument must not be of type number. Received type " + typeof value);
		if (value && typeof value.length === "undefined") throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
		return Buffer2(value, encodingOrOffset, length);
	};
	if (!Safer.alloc) Safer.alloc = function(size, fill, encoding2) {
		if (typeof size !== "number") throw new TypeError("The \"size\" argument must be of type number. Received type " + typeof size);
		if (size < 0 || size >= 2 * (1 << 30)) throw new RangeError("The value \"" + size + "\" is invalid for option \"size\"");
		var buf = Buffer2(size);
		if (!fill || fill.length === 0) buf.fill(0);
		else if (typeof encoding2 === "string") buf.fill(fill, encoding2);
		else buf.fill(fill);
		return buf;
	};
	if (!safer.kStringMaxLength) try {
		safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
	} catch (e) {}
	if (!safer.constants) {
		safer.constants = { MAX_LENGTH: safer.kMaxLength };
		if (safer.kStringMaxLength) safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
	}
	safer_1 = safer;
	return safer_1;
}
var bomHandling = {};
var hasRequiredBomHandling;
function requireBomHandling() {
	if (hasRequiredBomHandling) return bomHandling;
	hasRequiredBomHandling = 1;
	var BOMChar = "";
	bomHandling.PrependBOM = PrependBOMWrapper;
	function PrependBOMWrapper(encoder, options) {
		this.encoder = encoder;
		this.addBOM = true;
	}
	PrependBOMWrapper.prototype.write = function(str) {
		if (this.addBOM) {
			str = BOMChar + str;
			this.addBOM = false;
		}
		return this.encoder.write(str);
	};
	PrependBOMWrapper.prototype.end = function() {
		return this.encoder.end();
	};
	bomHandling.StripBOM = StripBOMWrapper;
	function StripBOMWrapper(decoder, options) {
		this.decoder = decoder;
		this.pass = false;
		this.options = options || {};
	}
	StripBOMWrapper.prototype.write = function(buf) {
		var res = this.decoder.write(buf);
		if (this.pass || !res) return res;
		if (res[0] === BOMChar) {
			res = res.slice(1);
			if (typeof this.options.stripBOM === "function") this.options.stripBOM();
		}
		this.pass = true;
		return res;
	};
	StripBOMWrapper.prototype.end = function() {
		return this.decoder.end();
	};
	return bomHandling;
}
var encodings = {};
var internal;
var hasRequiredInternal;
function requireInternal() {
	if (hasRequiredInternal) return internal;
	hasRequiredInternal = 1;
	var Buffer2 = requireSafer().Buffer;
	internal = {
		utf8: {
			type: "_internal",
			bomAware: true
		},
		cesu8: {
			type: "_internal",
			bomAware: true
		},
		unicode11utf8: "utf8",
		ucs2: {
			type: "_internal",
			bomAware: true
		},
		utf16le: "ucs2",
		binary: { type: "_internal" },
		base64: { type: "_internal" },
		hex: { type: "_internal" },
		_internal: InternalCodec
	};
	function InternalCodec(codecOptions, iconv) {
		this.enc = codecOptions.encodingName;
		this.bomAware = codecOptions.bomAware;
		if (this.enc === "base64") this.encoder = InternalEncoderBase64;
		else if (this.enc === "cesu8") {
			this.enc = "utf8";
			this.encoder = InternalEncoderCesu8;
			if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "") {
				this.decoder = InternalDecoderCesu8;
				this.defaultCharUnicode = iconv.defaultCharUnicode;
			}
		}
	}
	InternalCodec.prototype.encoder = InternalEncoder;
	InternalCodec.prototype.decoder = InternalDecoder;
	var StringDecoder = require$$1$1$1.StringDecoder;
	if (!StringDecoder.prototype.end) StringDecoder.prototype.end = function() {};
	function InternalDecoder(options, codec) {
		this.decoder = new StringDecoder(codec.enc);
	}
	InternalDecoder.prototype.write = function(buf) {
		if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
		return this.decoder.write(buf);
	};
	InternalDecoder.prototype.end = function() {
		return this.decoder.end();
	};
	function InternalEncoder(options, codec) {
		this.enc = codec.enc;
	}
	InternalEncoder.prototype.write = function(str) {
		return Buffer2.from(str, this.enc);
	};
	InternalEncoder.prototype.end = function() {};
	function InternalEncoderBase64(options, codec) {
		this.prevStr = "";
	}
	InternalEncoderBase64.prototype.write = function(str) {
		str = this.prevStr + str;
		var completeQuads = str.length - str.length % 4;
		this.prevStr = str.slice(completeQuads);
		str = str.slice(0, completeQuads);
		return Buffer2.from(str, "base64");
	};
	InternalEncoderBase64.prototype.end = function() {
		return Buffer2.from(this.prevStr, "base64");
	};
	function InternalEncoderCesu8(options, codec) {}
	InternalEncoderCesu8.prototype.write = function(str) {
		var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
		for (var i = 0; i < str.length; i++) {
			var charCode = str.charCodeAt(i);
			if (charCode < 128) buf[bufIdx++] = charCode;
			else if (charCode < 2048) {
				buf[bufIdx++] = 192 + (charCode >>> 6);
				buf[bufIdx++] = 128 + (charCode & 63);
			} else {
				buf[bufIdx++] = 224 + (charCode >>> 12);
				buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
				buf[bufIdx++] = 128 + (charCode & 63);
			}
		}
		return buf.slice(0, bufIdx);
	};
	InternalEncoderCesu8.prototype.end = function() {};
	function InternalDecoderCesu8(options, codec) {
		this.acc = 0;
		this.contBytes = 0;
		this.accBytes = 0;
		this.defaultCharUnicode = codec.defaultCharUnicode;
	}
	InternalDecoderCesu8.prototype.write = function(buf) {
		var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
		for (var i = 0; i < buf.length; i++) {
			var curByte = buf[i];
			if ((curByte & 192) !== 128) {
				if (contBytes > 0) {
					res += this.defaultCharUnicode;
					contBytes = 0;
				}
				if (curByte < 128) res += String.fromCharCode(curByte);
				else if (curByte < 224) {
					acc = curByte & 31;
					contBytes = 1;
					accBytes = 1;
				} else if (curByte < 240) {
					acc = curByte & 15;
					contBytes = 2;
					accBytes = 1;
				} else res += this.defaultCharUnicode;
			} else if (contBytes > 0) {
				acc = acc << 6 | curByte & 63;
				contBytes--;
				accBytes++;
				if (contBytes === 0) if (accBytes === 2 && acc < 128 && acc > 0) res += this.defaultCharUnicode;
				else if (accBytes === 3 && acc < 2048) res += this.defaultCharUnicode;
				else res += String.fromCharCode(acc);
			} else res += this.defaultCharUnicode;
		}
		this.acc = acc;
		this.contBytes = contBytes;
		this.accBytes = accBytes;
		return res;
	};
	InternalDecoderCesu8.prototype.end = function() {
		var res = 0;
		if (this.contBytes > 0) res += this.defaultCharUnicode;
		return res;
	};
	return internal;
}
var utf32 = {};
var hasRequiredUtf32;
function requireUtf32() {
	if (hasRequiredUtf32) return utf32;
	hasRequiredUtf32 = 1;
	var Buffer2 = requireSafer().Buffer;
	utf32._utf32 = Utf32Codec;
	function Utf32Codec(codecOptions, iconv) {
		this.iconv = iconv;
		this.bomAware = true;
		this.isLE = codecOptions.isLE;
	}
	utf32.utf32le = {
		type: "_utf32",
		isLE: true
	};
	utf32.utf32be = {
		type: "_utf32",
		isLE: false
	};
	utf32.ucs4le = "utf32le";
	utf32.ucs4be = "utf32be";
	Utf32Codec.prototype.encoder = Utf32Encoder;
	Utf32Codec.prototype.decoder = Utf32Decoder;
	function Utf32Encoder(options, codec) {
		this.isLE = codec.isLE;
		this.highSurrogate = 0;
	}
	Utf32Encoder.prototype.write = function(str) {
		var src = Buffer2.from(str, "ucs2");
		var dst = Buffer2.alloc(src.length * 2);
		var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
		var offset = 0;
		for (var i = 0; i < src.length; i += 2) {
			var code = src.readUInt16LE(i);
			var isHighSurrogate = 55296 <= code && code < 56320;
			var isLowSurrogate = 56320 <= code && code < 57344;
			if (this.highSurrogate) if (isHighSurrogate || !isLowSurrogate) {
				write32.call(dst, this.highSurrogate, offset);
				offset += 4;
			} else {
				var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
				write32.call(dst, codepoint, offset);
				offset += 4;
				this.highSurrogate = 0;
				continue;
			}
			if (isHighSurrogate) this.highSurrogate = code;
			else {
				write32.call(dst, code, offset);
				offset += 4;
				this.highSurrogate = 0;
			}
		}
		if (offset < dst.length) dst = dst.slice(0, offset);
		return dst;
	};
	Utf32Encoder.prototype.end = function() {
		if (!this.highSurrogate) return;
		var buf = Buffer2.alloc(4);
		if (this.isLE) buf.writeUInt32LE(this.highSurrogate, 0);
		else buf.writeUInt32BE(this.highSurrogate, 0);
		this.highSurrogate = 0;
		return buf;
	};
	function Utf32Decoder(options, codec) {
		this.isLE = codec.isLE;
		this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
		this.overflow = [];
	}
	Utf32Decoder.prototype.write = function(src) {
		if (src.length === 0) return "";
		var i = 0;
		var codepoint = 0;
		var dst = Buffer2.alloc(src.length + 4);
		var offset = 0;
		var isLE = this.isLE;
		var overflow = this.overflow;
		var badChar = this.badChar;
		if (overflow.length > 0) {
			for (; i < src.length && overflow.length < 4; i++) overflow.push(src[i]);
			if (overflow.length === 4) {
				if (isLE) codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
				else codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
				overflow.length = 0;
				offset = _writeCodepoint(dst, offset, codepoint, badChar);
			}
		}
		for (; i < src.length - 3; i += 4) {
			if (isLE) codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;
			else codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;
			offset = _writeCodepoint(dst, offset, codepoint, badChar);
		}
		for (; i < src.length; i++) overflow.push(src[i]);
		return dst.slice(0, offset).toString("ucs2");
	};
	function _writeCodepoint(dst, offset, codepoint, badChar) {
		if (codepoint < 0 || codepoint > 1114111) codepoint = badChar;
		if (codepoint >= 65536) {
			codepoint -= 65536;
			var high = 55296 | codepoint >> 10;
			dst[offset++] = high & 255;
			dst[offset++] = high >> 8;
			var codepoint = 56320 | codepoint & 1023;
		}
		dst[offset++] = codepoint & 255;
		dst[offset++] = codepoint >> 8;
		return offset;
	}
	Utf32Decoder.prototype.end = function() {
		this.overflow.length = 0;
	};
	utf32.utf32 = Utf32AutoCodec;
	utf32.ucs4 = "utf32";
	function Utf32AutoCodec(options, iconv) {
		this.iconv = iconv;
	}
	Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
	Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
	function Utf32AutoEncoder(options, codec) {
		options = options || {};
		if (options.addBOM === void 0) options.addBOM = true;
		this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
	}
	Utf32AutoEncoder.prototype.write = function(str) {
		return this.encoder.write(str);
	};
	Utf32AutoEncoder.prototype.end = function() {
		return this.encoder.end();
	};
	function Utf32AutoDecoder(options, codec) {
		this.decoder = null;
		this.initialBufs = [];
		this.initialBufsLen = 0;
		this.options = options || {};
		this.iconv = codec.iconv;
	}
	Utf32AutoDecoder.prototype.write = function(buf) {
		if (!this.decoder) {
			this.initialBufs.push(buf);
			this.initialBufsLen += buf.length;
			if (this.initialBufsLen < 32) return "";
			var encoding2 = detectEncoding(this.initialBufs, this.options.defaultEncoding);
			this.decoder = this.iconv.getDecoder(encoding2, this.options);
			var resStr = "";
			for (var i = 0; i < this.initialBufs.length; i++) resStr += this.decoder.write(this.initialBufs[i]);
			this.initialBufs.length = this.initialBufsLen = 0;
			return resStr;
		}
		return this.decoder.write(buf);
	};
	Utf32AutoDecoder.prototype.end = function() {
		if (!this.decoder) {
			var encoding2 = detectEncoding(this.initialBufs, this.options.defaultEncoding);
			this.decoder = this.iconv.getDecoder(encoding2, this.options);
			var resStr = "";
			for (var i = 0; i < this.initialBufs.length; i++) resStr += this.decoder.write(this.initialBufs[i]);
			var trail = this.decoder.end();
			if (trail) resStr += trail;
			this.initialBufs.length = this.initialBufsLen = 0;
			return resStr;
		}
		return this.decoder.end();
	};
	function detectEncoding(bufs, defaultEncoding) {
		var b = [];
		var charsProcessed = 0;
		var invalidLE = 0, invalidBE = 0;
		var bmpCharsLE = 0, bmpCharsBE = 0;
		outer_loop: for (var i = 0; i < bufs.length; i++) {
			var buf = bufs[i];
			for (var j = 0; j < buf.length; j++) {
				b.push(buf[j]);
				if (b.length === 4) {
					if (charsProcessed === 0) {
						if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) return "utf-32le";
						if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) return "utf-32be";
					}
					if (b[0] !== 0 || b[1] > 16) invalidBE++;
					if (b[3] !== 0 || b[2] > 16) invalidLE++;
					if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
					if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;
					b.length = 0;
					charsProcessed++;
					if (charsProcessed >= 100) break outer_loop;
				}
			}
		}
		if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be";
		if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le";
		return defaultEncoding || "utf-32le";
	}
	return utf32;
}
var utf16 = {};
var hasRequiredUtf16;
function requireUtf16() {
	if (hasRequiredUtf16) return utf16;
	hasRequiredUtf16 = 1;
	var Buffer2 = requireSafer().Buffer;
	utf16.utf16be = Utf16BECodec;
	function Utf16BECodec() {}
	Utf16BECodec.prototype.encoder = Utf16BEEncoder;
	Utf16BECodec.prototype.decoder = Utf16BEDecoder;
	Utf16BECodec.prototype.bomAware = true;
	function Utf16BEEncoder() {}
	Utf16BEEncoder.prototype.write = function(str) {
		var buf = Buffer2.from(str, "ucs2");
		for (var i = 0; i < buf.length; i += 2) {
			var tmp = buf[i];
			buf[i] = buf[i + 1];
			buf[i + 1] = tmp;
		}
		return buf;
	};
	Utf16BEEncoder.prototype.end = function() {};
	function Utf16BEDecoder() {
		this.overflowByte = -1;
	}
	Utf16BEDecoder.prototype.write = function(buf) {
		if (buf.length == 0) return "";
		var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
		if (this.overflowByte !== -1) {
			buf2[0] = buf[0];
			buf2[1] = this.overflowByte;
			i = 1;
			j = 2;
		}
		for (; i < buf.length - 1; i += 2, j += 2) {
			buf2[j] = buf[i + 1];
			buf2[j + 1] = buf[i];
		}
		this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
		return buf2.slice(0, j).toString("ucs2");
	};
	Utf16BEDecoder.prototype.end = function() {
		this.overflowByte = -1;
	};
	utf16.utf16 = Utf16Codec;
	function Utf16Codec(codecOptions, iconv) {
		this.iconv = iconv;
	}
	Utf16Codec.prototype.encoder = Utf16Encoder;
	Utf16Codec.prototype.decoder = Utf16Decoder;
	function Utf16Encoder(options, codec) {
		options = options || {};
		if (options.addBOM === void 0) options.addBOM = true;
		this.encoder = codec.iconv.getEncoder("utf-16le", options);
	}
	Utf16Encoder.prototype.write = function(str) {
		return this.encoder.write(str);
	};
	Utf16Encoder.prototype.end = function() {
		return this.encoder.end();
	};
	function Utf16Decoder(options, codec) {
		this.decoder = null;
		this.initialBufs = [];
		this.initialBufsLen = 0;
		this.options = options || {};
		this.iconv = codec.iconv;
	}
	Utf16Decoder.prototype.write = function(buf) {
		if (!this.decoder) {
			this.initialBufs.push(buf);
			this.initialBufsLen += buf.length;
			if (this.initialBufsLen < 16) return "";
			var encoding2 = detectEncoding(this.initialBufs, this.options.defaultEncoding);
			this.decoder = this.iconv.getDecoder(encoding2, this.options);
			var resStr = "";
			for (var i = 0; i < this.initialBufs.length; i++) resStr += this.decoder.write(this.initialBufs[i]);
			this.initialBufs.length = this.initialBufsLen = 0;
			return resStr;
		}
		return this.decoder.write(buf);
	};
	Utf16Decoder.prototype.end = function() {
		if (!this.decoder) {
			var encoding2 = detectEncoding(this.initialBufs, this.options.defaultEncoding);
			this.decoder = this.iconv.getDecoder(encoding2, this.options);
			var resStr = "";
			for (var i = 0; i < this.initialBufs.length; i++) resStr += this.decoder.write(this.initialBufs[i]);
			var trail = this.decoder.end();
			if (trail) resStr += trail;
			this.initialBufs.length = this.initialBufsLen = 0;
			return resStr;
		}
		return this.decoder.end();
	};
	function detectEncoding(bufs, defaultEncoding) {
		var b = [];
		var charsProcessed = 0;
		var asciiCharsLE = 0, asciiCharsBE = 0;
		outer_loop: for (var i = 0; i < bufs.length; i++) {
			var buf = bufs[i];
			for (var j = 0; j < buf.length; j++) {
				b.push(buf[j]);
				if (b.length === 2) {
					if (charsProcessed === 0) {
						if (b[0] === 255 && b[1] === 254) return "utf-16le";
						if (b[0] === 254 && b[1] === 255) return "utf-16be";
					}
					if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
					if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
					b.length = 0;
					charsProcessed++;
					if (charsProcessed >= 100) break outer_loop;
				}
			}
		}
		if (asciiCharsBE > asciiCharsLE) return "utf-16be";
		if (asciiCharsBE < asciiCharsLE) return "utf-16le";
		return defaultEncoding || "utf-16le";
	}
	return utf16;
}
var utf7 = {};
var hasRequiredUtf7;
function requireUtf7() {
	if (hasRequiredUtf7) return utf7;
	hasRequiredUtf7 = 1;
	var Buffer2 = requireSafer().Buffer;
	utf7.utf7 = Utf7Codec;
	utf7.unicode11utf7 = "utf7";
	function Utf7Codec(codecOptions, iconv) {
		this.iconv = iconv;
	}
	Utf7Codec.prototype.encoder = Utf7Encoder;
	Utf7Codec.prototype.decoder = Utf7Decoder;
	Utf7Codec.prototype.bomAware = true;
	var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
	function Utf7Encoder(options, codec) {
		this.iconv = codec.iconv;
	}
	Utf7Encoder.prototype.write = function(str) {
		return Buffer2.from(str.replace(nonDirectChars, function(chunk) {
			return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
		}.bind(this)));
	};
	Utf7Encoder.prototype.end = function() {};
	function Utf7Decoder(options, codec) {
		this.iconv = codec.iconv;
		this.inBase64 = false;
		this.base64Accum = "";
	}
	var base64Regex = /[A-Za-z0-9\/+]/;
	var base64Chars = [];
	for (var i = 0; i < 256; i++) base64Chars[i] = base64Regex.test(String.fromCharCode(i));
	var plusChar = "+".charCodeAt(0), minusChar = "-".charCodeAt(0), andChar = "&".charCodeAt(0);
	Utf7Decoder.prototype.write = function(buf) {
		var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
		for (var i2 = 0; i2 < buf.length; i2++) if (!inBase64) {
			if (buf[i2] == plusChar) {
				res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
				lastI = i2 + 1;
				inBase64 = true;
			}
		} else if (!base64Chars[buf[i2]]) {
			if (i2 == lastI && buf[i2] == minusChar) res += "+";
			else {
				var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii");
				res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
			}
			if (buf[i2] != minusChar) i2--;
			lastI = i2 + 1;
			inBase64 = false;
			base64Accum = "";
		}
		if (!inBase64) res += this.iconv.decode(buf.slice(lastI), "ascii");
		else {
			var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
			var canBeDecoded = b64str.length - b64str.length % 8;
			base64Accum = b64str.slice(canBeDecoded);
			b64str = b64str.slice(0, canBeDecoded);
			res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
		}
		this.inBase64 = inBase64;
		this.base64Accum = base64Accum;
		return res;
	};
	Utf7Decoder.prototype.end = function() {
		var res = "";
		if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
		this.inBase64 = false;
		this.base64Accum = "";
		return res;
	};
	utf7.utf7imap = Utf7IMAPCodec;
	function Utf7IMAPCodec(codecOptions, iconv) {
		this.iconv = iconv;
	}
	Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
	Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
	Utf7IMAPCodec.prototype.bomAware = true;
	function Utf7IMAPEncoder(options, codec) {
		this.iconv = codec.iconv;
		this.inBase64 = false;
		this.base64Accum = Buffer2.alloc(6);
		this.base64AccumIdx = 0;
	}
	Utf7IMAPEncoder.prototype.write = function(str) {
		var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
		for (var i2 = 0; i2 < str.length; i2++) {
			var uChar = str.charCodeAt(i2);
			if (32 <= uChar && uChar <= 126) {
				if (inBase64) {
					if (base64AccumIdx > 0) {
						bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
						base64AccumIdx = 0;
					}
					buf[bufIdx++] = minusChar;
					inBase64 = false;
				}
				if (!inBase64) {
					buf[bufIdx++] = uChar;
					if (uChar === andChar) buf[bufIdx++] = minusChar;
				}
			} else {
				if (!inBase64) {
					buf[bufIdx++] = andChar;
					inBase64 = true;
				}
				if (inBase64) {
					base64Accum[base64AccumIdx++] = uChar >> 8;
					base64Accum[base64AccumIdx++] = uChar & 255;
					if (base64AccumIdx == base64Accum.length) {
						bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
						base64AccumIdx = 0;
					}
				}
			}
		}
		this.inBase64 = inBase64;
		this.base64AccumIdx = base64AccumIdx;
		return buf.slice(0, bufIdx);
	};
	Utf7IMAPEncoder.prototype.end = function() {
		var buf = Buffer2.alloc(10), bufIdx = 0;
		if (this.inBase64) {
			if (this.base64AccumIdx > 0) {
				bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
				this.base64AccumIdx = 0;
			}
			buf[bufIdx++] = minusChar;
			this.inBase64 = false;
		}
		return buf.slice(0, bufIdx);
	};
	function Utf7IMAPDecoder(options, codec) {
		this.iconv = codec.iconv;
		this.inBase64 = false;
		this.base64Accum = "";
	}
	var base64IMAPChars = base64Chars.slice();
	base64IMAPChars[",".charCodeAt(0)] = true;
	Utf7IMAPDecoder.prototype.write = function(buf) {
		var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
		for (var i2 = 0; i2 < buf.length; i2++) if (!inBase64) {
			if (buf[i2] == andChar) {
				res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
				lastI = i2 + 1;
				inBase64 = true;
			}
		} else if (!base64IMAPChars[buf[i2]]) {
			if (i2 == lastI && buf[i2] == minusChar) res += "&";
			else {
				var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii").replace(/,/g, "/");
				res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
			}
			if (buf[i2] != minusChar) i2--;
			lastI = i2 + 1;
			inBase64 = false;
			base64Accum = "";
		}
		if (!inBase64) res += this.iconv.decode(buf.slice(lastI), "ascii");
		else {
			var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
			var canBeDecoded = b64str.length - b64str.length % 8;
			base64Accum = b64str.slice(canBeDecoded);
			b64str = b64str.slice(0, canBeDecoded);
			res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
		}
		this.inBase64 = inBase64;
		this.base64Accum = base64Accum;
		return res;
	};
	Utf7IMAPDecoder.prototype.end = function() {
		var res = "";
		if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
		this.inBase64 = false;
		this.base64Accum = "";
		return res;
	};
	return utf7;
}
var sbcsCodec = {};
var hasRequiredSbcsCodec;
function requireSbcsCodec() {
	if (hasRequiredSbcsCodec) return sbcsCodec;
	hasRequiredSbcsCodec = 1;
	var Buffer2 = requireSafer().Buffer;
	sbcsCodec._sbcs = SBCSCodec;
	function SBCSCodec(codecOptions, iconv) {
		if (!codecOptions) throw new Error("SBCS codec is called without the data.");
		if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
		if (codecOptions.chars.length === 128) {
			var asciiString = "";
			for (var i = 0; i < 128; i++) asciiString += String.fromCharCode(i);
			codecOptions.chars = asciiString + codecOptions.chars;
		}
		this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
		var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
		for (var i = 0; i < codecOptions.chars.length; i++) encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
		this.encodeBuf = encodeBuf;
	}
	SBCSCodec.prototype.encoder = SBCSEncoder;
	SBCSCodec.prototype.decoder = SBCSDecoder;
	function SBCSEncoder(options, codec) {
		this.encodeBuf = codec.encodeBuf;
	}
	SBCSEncoder.prototype.write = function(str) {
		var buf = Buffer2.alloc(str.length);
		for (var i = 0; i < str.length; i++) buf[i] = this.encodeBuf[str.charCodeAt(i)];
		return buf;
	};
	SBCSEncoder.prototype.end = function() {};
	function SBCSDecoder(options, codec) {
		this.decodeBuf = codec.decodeBuf;
	}
	SBCSDecoder.prototype.write = function(buf) {
		var decodeBuf = this.decodeBuf;
		var newBuf = Buffer2.alloc(buf.length * 2);
		var idx1 = 0, idx2 = 0;
		for (var i = 0; i < buf.length; i++) {
			idx1 = buf[i] * 2;
			idx2 = i * 2;
			newBuf[idx2] = decodeBuf[idx1];
			newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
		}
		return newBuf.toString("ucs2");
	};
	SBCSDecoder.prototype.end = function() {};
	return sbcsCodec;
}
var sbcsData;
var hasRequiredSbcsData;
function requireSbcsData() {
	if (hasRequiredSbcsData) return sbcsData;
	hasRequiredSbcsData = 1;
	sbcsData = {
		"10029": "maccenteuro",
		"maccenteuro": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"808": "cp808",
		"ibm808": "cp808",
		"cp808": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"mik": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp720": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ascii8bit": "ascii",
		"usascii": "ascii",
		"ansix34": "ascii",
		"ansix341968": "ascii",
		"ansix341986": "ascii",
		"csascii": "ascii",
		"cp367": "ascii",
		"ibm367": "ascii",
		"isoir6": "ascii",
		"iso646us": "ascii",
		"iso646irv": "ascii",
		"us": "ascii",
		"latin1": "iso88591",
		"latin2": "iso88592",
		"latin3": "iso88593",
		"latin4": "iso88594",
		"latin5": "iso88599",
		"latin6": "iso885910",
		"latin7": "iso885913",
		"latin8": "iso885914",
		"latin9": "iso885915",
		"latin10": "iso885916",
		"csisolatin1": "iso88591",
		"csisolatin2": "iso88592",
		"csisolatin3": "iso88593",
		"csisolatin4": "iso88594",
		"csisolatincyrillic": "iso88595",
		"csisolatinarabic": "iso88596",
		"csisolatingreek": "iso88597",
		"csisolatinhebrew": "iso88598",
		"csisolatin5": "iso88599",
		"csisolatin6": "iso885910",
		"l1": "iso88591",
		"l2": "iso88592",
		"l3": "iso88593",
		"l4": "iso88594",
		"l5": "iso88599",
		"l6": "iso885910",
		"l7": "iso885913",
		"l8": "iso885914",
		"l9": "iso885915",
		"l10": "iso885916",
		"isoir14": "iso646jp",
		"isoir57": "iso646cn",
		"isoir100": "iso88591",
		"isoir101": "iso88592",
		"isoir109": "iso88593",
		"isoir110": "iso88594",
		"isoir144": "iso88595",
		"isoir127": "iso88596",
		"isoir126": "iso88597",
		"isoir138": "iso88598",
		"isoir148": "iso88599",
		"isoir157": "iso885910",
		"isoir166": "tis620",
		"isoir179": "iso885913",
		"isoir199": "iso885914",
		"isoir203": "iso885915",
		"isoir226": "iso885916",
		"cp819": "iso88591",
		"ibm819": "iso88591",
		"cyrillic": "iso88595",
		"arabic": "iso88596",
		"arabic8": "iso88596",
		"ecma114": "iso88596",
		"asmo708": "iso88596",
		"greek": "iso88597",
		"greek8": "iso88597",
		"ecma118": "iso88597",
		"elot928": "iso88597",
		"hebrew": "iso88598",
		"hebrew8": "iso88598",
		"turkish": "iso88599",
		"turkish8": "iso88599",
		"thai": "iso885911",
		"thai8": "iso885911",
		"celtic": "iso885914",
		"celtic8": "iso885914",
		"isoceltic": "iso885914",
		"tis6200": "tis620",
		"tis62025291": "tis620",
		"tis62025330": "tis620",
		"10000": "macroman",
		"10006": "macgreek",
		"10007": "maccyrillic",
		"10079": "maciceland",
		"10081": "macturkish",
		"cspc8codepage437": "cp437",
		"cspc775baltic": "cp775",
		"cspc850multilingual": "cp850",
		"cspcp852": "cp852",
		"cspc862latinhebrew": "cp862",
		"cpgr": "cp869",
		"msee": "cp1250",
		"mscyrl": "cp1251",
		"msansi": "cp1252",
		"msgreek": "cp1253",
		"msturk": "cp1254",
		"mshebr": "cp1255",
		"msarab": "cp1256",
		"winbaltrim": "cp1257",
		"cp20866": "koi8r",
		"20866": "koi8r",
		"ibm878": "koi8r",
		"cskoi8r": "koi8r",
		"cp21866": "koi8u",
		"21866": "koi8u",
		"ibm1168": "koi8u",
		"strk10482002": "rk1048",
		"tcvn5712": "tcvn",
		"tcvn57121": "tcvn",
		"gb198880": "iso646cn",
		"cn": "iso646cn",
		"csiso14jisc6220ro": "iso646jp",
		"jisc62201969ro": "iso646jp",
		"jp": "iso646jp",
		"cshproman8": "hproman8",
		"r8": "hproman8",
		"roman8": "hproman8",
		"xroman8": "hproman8",
		"ibm1051": "hproman8",
		"mac": "macintosh",
		"csmacintosh": "macintosh"
	};
	return sbcsData;
}
var sbcsDataGenerated;
var hasRequiredSbcsDataGenerated;
function requireSbcsDataGenerated() {
	if (hasRequiredSbcsDataGenerated) return sbcsDataGenerated;
	hasRequiredSbcsDataGenerated = 1;
	sbcsDataGenerated = {
		"437": "cp437",
		"737": "cp737",
		"775": "cp775",
		"850": "cp850",
		"852": "cp852",
		"855": "cp855",
		"856": "cp856",
		"857": "cp857",
		"858": "cp858",
		"860": "cp860",
		"861": "cp861",
		"862": "cp862",
		"863": "cp863",
		"864": "cp864",
		"865": "cp865",
		"866": "cp866",
		"869": "cp869",
		"874": "windows874",
		"922": "cp922",
		"1046": "cp1046",
		"1124": "cp1124",
		"1125": "cp1125",
		"1129": "cp1129",
		"1133": "cp1133",
		"1161": "cp1161",
		"1162": "cp1162",
		"1163": "cp1163",
		"1250": "windows1250",
		"1251": "windows1251",
		"1252": "windows1252",
		"1253": "windows1253",
		"1254": "windows1254",
		"1255": "windows1255",
		"1256": "windows1256",
		"1257": "windows1257",
		"1258": "windows1258",
		"28591": "iso88591",
		"28592": "iso88592",
		"28593": "iso88593",
		"28594": "iso88594",
		"28595": "iso88595",
		"28596": "iso88596",
		"28597": "iso88597",
		"28598": "iso88598",
		"28599": "iso88599",
		"28600": "iso885910",
		"28601": "iso885911",
		"28603": "iso885913",
		"28604": "iso885914",
		"28605": "iso885915",
		"28606": "iso885916",
		"windows874": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win874": "windows874",
		"cp874": "windows874",
		"windows1250": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1250": "windows1250",
		"cp1250": "windows1250",
		"windows1251": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1251": "windows1251",
		"cp1251": "windows1251",
		"windows1252": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1252": "windows1252",
		"cp1252": "windows1252",
		"windows1253": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1253": "windows1253",
		"cp1253": "windows1253",
		"windows1254": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1254": "windows1254",
		"cp1254": "windows1254",
		"windows1255": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1255": "windows1255",
		"cp1255": "windows1255",
		"windows1256": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1256": "windows1256",
		"cp1256": "windows1256",
		"windows1257": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1257": "windows1257",
		"cp1257": "windows1257",
		"windows1258": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1258": "windows1258",
		"cp1258": "windows1258",
		"iso88591": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28591": "iso88591",
		"iso88592": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28592": "iso88592",
		"iso88593": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28593": "iso88593",
		"iso88594": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28594": "iso88594",
		"iso88595": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28595": "iso88595",
		"iso88596": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28596": "iso88596",
		"iso88597": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28597": "iso88597",
		"iso88598": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28598": "iso88598",
		"iso88599": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28599": "iso88599",
		"iso885910": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28600": "iso885910",
		"iso885911": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28601": "iso885911",
		"iso885913": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28603": "iso885913",
		"iso885914": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28604": "iso885914",
		"iso885915": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28605": "iso885915",
		"iso885916": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28606": "iso885916",
		"cp437": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm437": "cp437",
		"csibm437": "cp437",
		"cp737": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm737": "cp737",
		"csibm737": "cp737",
		"cp775": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm775": "cp775",
		"csibm775": "cp775",
		"cp850": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm850": "cp850",
		"csibm850": "cp850",
		"cp852": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm852": "cp852",
		"csibm852": "cp852",
		"cp855": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm855": "cp855",
		"csibm855": "cp855",
		"cp856": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm856": "cp856",
		"csibm856": "cp856",
		"cp857": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm857": "cp857",
		"csibm857": "cp857",
		"cp858": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm858": "cp858",
		"csibm858": "cp858",
		"cp860": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm860": "cp860",
		"csibm860": "cp860",
		"cp861": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm861": "cp861",
		"csibm861": "cp861",
		"cp862": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm862": "cp862",
		"csibm862": "cp862",
		"cp863": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm863": "cp863",
		"csibm863": "cp863",
		"cp864": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\xA0"
		},
		"ibm864": "cp864",
		"csibm864": "cp864",
		"cp865": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm865": "cp865",
		"csibm865": "cp865",
		"cp866": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm866": "cp866",
		"csibm866": "cp866",
		"cp869": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm869": "cp869",
		"csibm869": "cp869",
		"cp922": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm922": "cp922",
		"csibm922": "cp922",
		"cp1046": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1046": "cp1046",
		"csibm1046": "cp1046",
		"cp1124": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1124": "cp1124",
		"csibm1124": "cp1124",
		"cp1125": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1125": "cp1125",
		"csibm1125": "cp1125",
		"cp1129": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1129": "cp1129",
		"csibm1129": "cp1129",
		"cp1133": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1133": "cp1133",
		"csibm1133": "cp1133",
		"cp1161": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1161": "cp1161",
		"csibm1161": "cp1161",
		"cp1162": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1162": "cp1162",
		"csibm1162": "cp1162",
		"cp1163": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1163": "cp1163",
		"csibm1163": "cp1163",
		"maccroatian": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"maccyrillic": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macgreek": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"maciceland": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macroman": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macromania": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macthai": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macturkish": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macukraine": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8r": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8u": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8ru": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8t": {
			"type": "_sbcs",
			"chars": ""
		},
		"armscii8": {
			"type": "_sbcs",
			"chars": "\xA0)(.,-"
		},
		"rk1048": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"tcvn": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\xA0"
		},
		"georgianacademy": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"georgianps": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"pt154": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"viscii": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
		},
		"iso646cn": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
		},
		"iso646jp": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
		},
		"hproman8": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macintosh": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ascii": {
			"type": "_sbcs",
			"chars": ""
		},
		"tis620": {
			"type": "_sbcs",
			"chars": ""
		}
	};
	return sbcsDataGenerated;
}
var dbcsCodec = {};
var hasRequiredDbcsCodec;
function requireDbcsCodec() {
	if (hasRequiredDbcsCodec) return dbcsCodec;
	hasRequiredDbcsCodec = 1;
	var Buffer2 = requireSafer().Buffer;
	dbcsCodec._dbcs = DBCSCodec;
	var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
	for (var i = 0; i < 256; i++) UNASSIGNED_NODE[i] = UNASSIGNED;
	function DBCSCodec(codecOptions, iconv) {
		this.encodingName = codecOptions.encodingName;
		if (!codecOptions) throw new Error("DBCS codec is called without the data.");
		if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");
		var mappingTable = codecOptions.table();
		this.decodeTables = [];
		this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
		this.decodeTableSeq = [];
		for (var i2 = 0; i2 < mappingTable.length; i2++) this._addDecodeChunk(mappingTable[i2]);
		if (typeof codecOptions.gb18030 === "function") {
			this.gb18030 = codecOptions.gb18030();
			var commonThirdByteNodeIdx = this.decodeTables.length;
			this.decodeTables.push(UNASSIGNED_NODE.slice(0));
			var commonFourthByteNodeIdx = this.decodeTables.length;
			this.decodeTables.push(UNASSIGNED_NODE.slice(0));
			var firstByteNode = this.decodeTables[0];
			for (var i2 = 129; i2 <= 254; i2++) {
				var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i2]];
				for (var j = 48; j <= 57; j++) {
					if (secondByteNode[j] === UNASSIGNED) secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
					else if (secondByteNode[j] > NODE_START) throw new Error("gb18030 decode tables conflict at byte 2");
					var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
					for (var k = 129; k <= 254; k++) {
						if (thirdByteNode[k] === UNASSIGNED) thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
						else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) continue;
						else if (thirdByteNode[k] > NODE_START) throw new Error("gb18030 decode tables conflict at byte 3");
						var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
						for (var l = 48; l <= 57; l++) if (fourthByteNode[l] === UNASSIGNED) fourthByteNode[l] = GB18030_CODE;
					}
				}
			}
		}
		this.defaultCharUnicode = iconv.defaultCharUnicode;
		this.encodeTable = [];
		this.encodeTableSeq = [];
		var skipEncodeChars = {};
		if (codecOptions.encodeSkipVals) for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
			var val = codecOptions.encodeSkipVals[i2];
			if (typeof val === "number") skipEncodeChars[val] = true;
			else for (var j = val.from; j <= val.to; j++) skipEncodeChars[j] = true;
		}
		this._fillEncodeTable(0, 0, skipEncodeChars);
		if (codecOptions.encodeAdd) {
			for (var uChar in codecOptions.encodeAdd) if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
		}
		this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
		if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
		if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
	}
	DBCSCodec.prototype.encoder = DBCSEncoder;
	DBCSCodec.prototype.decoder = DBCSDecoder;
	DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
		var bytes2 = [];
		for (; addr > 0; addr >>>= 8) bytes2.push(addr & 255);
		if (bytes2.length == 0) bytes2.push(0);
		var node = this.decodeTables[0];
		for (var i2 = bytes2.length - 1; i2 > 0; i2--) {
			var val = node[bytes2[i2]];
			if (val == UNASSIGNED) {
				node[bytes2[i2]] = NODE_START - this.decodeTables.length;
				this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
			} else if (val <= NODE_START) node = this.decodeTables[NODE_START - val];
			else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
		}
		return node;
	};
	DBCSCodec.prototype._addDecodeChunk = function(chunk) {
		var curAddr = parseInt(chunk[0], 16);
		var writeTable = this._getDecodeTrieNode(curAddr);
		curAddr = curAddr & 255;
		for (var k = 1; k < chunk.length; k++) {
			var part = chunk[k];
			if (typeof part === "string") for (var l = 0; l < part.length;) {
				var code = part.charCodeAt(l++);
				if (55296 <= code && code < 56320) {
					var codeTrail = part.charCodeAt(l++);
					if (56320 <= codeTrail && codeTrail < 57344) writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
					else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
				} else if (4080 < code && code <= 4095) {
					var len = 4095 - code + 2;
					var seq = [];
					for (var m$1 = 0; m$1 < len; m$1++) seq.push(part.charCodeAt(l++));
					writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
					this.decodeTableSeq.push(seq);
				} else writeTable[curAddr++] = code;
			}
			else if (typeof part === "number") {
				var charCode = writeTable[curAddr - 1] + 1;
				for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;
			} else throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
		}
		if (curAddr > 255) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
	};
	DBCSCodec.prototype._getEncodeBucket = function(uCode) {
		var high = uCode >> 8;
		if (this.encodeTable[high] === void 0) this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
		return this.encodeTable[high];
	};
	DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
		var bucket = this._getEncodeBucket(uCode);
		var low = uCode & 255;
		if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
		else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
	};
	DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
		var uCode = seq[0];
		var bucket = this._getEncodeBucket(uCode);
		var low = uCode & 255;
		var node;
		if (bucket[low] <= SEQ_START) node = this.encodeTableSeq[SEQ_START - bucket[low]];
		else {
			node = {};
			if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
			bucket[low] = SEQ_START - this.encodeTableSeq.length;
			this.encodeTableSeq.push(node);
		}
		for (var j = 1; j < seq.length - 1; j++) {
			var oldVal = node[uCode];
			if (typeof oldVal === "object") node = oldVal;
			else {
				node = node[uCode] = {};
				if (oldVal !== void 0) node[DEF_CHAR] = oldVal;
			}
		}
		uCode = seq[seq.length - 1];
		node[uCode] = dbcsCode;
	};
	DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
		var node = this.decodeTables[nodeIdx];
		var hasValues = false;
		var subNodeEmpty = {};
		for (var i2 = 0; i2 < 256; i2++) {
			var uCode = node[i2];
			var mbCode = prefix + i2;
			if (skipEncodeChars[mbCode]) continue;
			if (uCode >= 0) {
				this._setEncodeChar(uCode, mbCode);
				hasValues = true;
			} else if (uCode <= NODE_START) {
				var subNodeIdx = NODE_START - uCode;
				if (!subNodeEmpty[subNodeIdx]) {
					var newPrefix = mbCode << 8 >>> 0;
					if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars)) hasValues = true;
					else subNodeEmpty[subNodeIdx] = true;
				}
			} else if (uCode <= SEQ_START) {
				this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
				hasValues = true;
			}
		}
		return hasValues;
	};
	function DBCSEncoder(options, codec) {
		this.leadSurrogate = -1;
		this.seqObj = void 0;
		this.encodeTable = codec.encodeTable;
		this.encodeTableSeq = codec.encodeTableSeq;
		this.defaultCharSingleByte = codec.defCharSB;
		this.gb18030 = codec.gb18030;
	}
	DBCSEncoder.prototype.write = function(str) {
		var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
		while (true) {
			if (nextChar === -1) {
				if (i2 == str.length) break;
				var uCode = str.charCodeAt(i2++);
			} else {
				var uCode = nextChar;
				nextChar = -1;
			}
			if (55296 <= uCode && uCode < 57344) if (uCode < 56320) if (leadSurrogate === -1) {
				leadSurrogate = uCode;
				continue;
			} else {
				leadSurrogate = uCode;
				uCode = UNASSIGNED;
			}
			else if (leadSurrogate !== -1) {
				uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
				leadSurrogate = -1;
			} else uCode = UNASSIGNED;
			else if (leadSurrogate !== -1) {
				nextChar = uCode;
				uCode = UNASSIGNED;
				leadSurrogate = -1;
			}
			var dbcsCode = UNASSIGNED;
			if (seqObj !== void 0 && uCode != UNASSIGNED) {
				var resCode = seqObj[uCode];
				if (typeof resCode === "object") {
					seqObj = resCode;
					continue;
				} else if (typeof resCode == "number") dbcsCode = resCode;
				else if (resCode == void 0) {
					resCode = seqObj[DEF_CHAR];
					if (resCode !== void 0) {
						dbcsCode = resCode;
						nextChar = uCode;
					}
				}
				seqObj = void 0;
			} else if (uCode >= 0) {
				var subtable = this.encodeTable[uCode >> 8];
				if (subtable !== void 0) dbcsCode = subtable[uCode & 255];
				if (dbcsCode <= SEQ_START) {
					seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
					continue;
				}
				if (dbcsCode == UNASSIGNED && this.gb18030) {
					var idx = findIdx(this.gb18030.uChars, uCode);
					if (idx != -1) {
						var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
						newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
						dbcsCode = dbcsCode % 12600;
						newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
						dbcsCode = dbcsCode % 1260;
						newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
						dbcsCode = dbcsCode % 10;
						newBuf[j++] = 48 + dbcsCode;
						continue;
					}
				}
			}
			if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
			if (dbcsCode < 256) newBuf[j++] = dbcsCode;
			else if (dbcsCode < 65536) {
				newBuf[j++] = dbcsCode >> 8;
				newBuf[j++] = dbcsCode & 255;
			} else if (dbcsCode < 16777216) {
				newBuf[j++] = dbcsCode >> 16;
				newBuf[j++] = dbcsCode >> 8 & 255;
				newBuf[j++] = dbcsCode & 255;
			} else {
				newBuf[j++] = dbcsCode >>> 24;
				newBuf[j++] = dbcsCode >>> 16 & 255;
				newBuf[j++] = dbcsCode >>> 8 & 255;
				newBuf[j++] = dbcsCode & 255;
			}
		}
		this.seqObj = seqObj;
		this.leadSurrogate = leadSurrogate;
		return newBuf.slice(0, j);
	};
	DBCSEncoder.prototype.end = function() {
		if (this.leadSurrogate === -1 && this.seqObj === void 0) return;
		var newBuf = Buffer2.alloc(10), j = 0;
		if (this.seqObj) {
			var dbcsCode = this.seqObj[DEF_CHAR];
			if (dbcsCode !== void 0) if (dbcsCode < 256) newBuf[j++] = dbcsCode;
			else {
				newBuf[j++] = dbcsCode >> 8;
				newBuf[j++] = dbcsCode & 255;
			}
			this.seqObj = void 0;
		}
		if (this.leadSurrogate !== -1) {
			newBuf[j++] = this.defaultCharSingleByte;
			this.leadSurrogate = -1;
		}
		return newBuf.slice(0, j);
	};
	DBCSEncoder.prototype.findIdx = findIdx;
	function DBCSDecoder(options, codec) {
		this.nodeIdx = 0;
		this.prevBytes = [];
		this.decodeTables = codec.decodeTables;
		this.decodeTableSeq = codec.decodeTableSeq;
		this.defaultCharUnicode = codec.defaultCharUnicode;
		this.gb18030 = codec.gb18030;
	}
	DBCSDecoder.prototype.write = function(buf) {
		var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBytes = this.prevBytes, prevOffset = this.prevBytes.length, seqStart = -this.prevBytes.length, uCode;
		for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
			var curByte = i2 >= 0 ? buf[i2] : prevBytes[i2 + prevOffset];
			var uCode = this.decodeTables[nodeIdx][curByte];
			if (uCode >= 0);
			else if (uCode === UNASSIGNED) {
				uCode = this.defaultCharUnicode.charCodeAt(0);
				i2 = seqStart;
			} else if (uCode === GB18030_CODE) {
				if (i2 >= 3) var ptr = (buf[i2 - 3] - 129) * 12600 + (buf[i2 - 2] - 48) * 1260 + (buf[i2 - 1] - 129) * 10 + (curByte - 48);
				else var ptr = (prevBytes[i2 - 3 + prevOffset] - 129) * 12600 + ((i2 - 2 >= 0 ? buf[i2 - 2] : prevBytes[i2 - 2 + prevOffset]) - 48) * 1260 + ((i2 - 1 >= 0 ? buf[i2 - 1] : prevBytes[i2 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
				var idx = findIdx(this.gb18030.gbChars, ptr);
				uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
			} else if (uCode <= NODE_START) {
				nodeIdx = NODE_START - uCode;
				continue;
			} else if (uCode <= SEQ_START) {
				var seq = this.decodeTableSeq[SEQ_START - uCode];
				for (var k = 0; k < seq.length - 1; k++) {
					uCode = seq[k];
					newBuf[j++] = uCode & 255;
					newBuf[j++] = uCode >> 8;
				}
				uCode = seq[seq.length - 1];
			} else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
			if (uCode >= 65536) {
				uCode -= 65536;
				var uCodeLead = 55296 | uCode >> 10;
				newBuf[j++] = uCodeLead & 255;
				newBuf[j++] = uCodeLead >> 8;
				uCode = 56320 | uCode & 1023;
			}
			newBuf[j++] = uCode & 255;
			newBuf[j++] = uCode >> 8;
			nodeIdx = 0;
			seqStart = i2 + 1;
		}
		this.nodeIdx = nodeIdx;
		this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
		return newBuf.slice(0, j).toString("ucs2");
	};
	DBCSDecoder.prototype.end = function() {
		var ret = "";
		while (this.prevBytes.length > 0) {
			ret += this.defaultCharUnicode;
			var bytesArr = this.prevBytes.slice(1);
			this.prevBytes = [];
			this.nodeIdx = 0;
			if (bytesArr.length > 0) ret += this.write(bytesArr);
		}
		this.prevBytes = [];
		this.nodeIdx = 0;
		return ret;
	};
	function findIdx(table, val) {
		if (table[0] > val) return -1;
		var l = 0, r = table.length;
		while (l < r - 1) {
			var mid = l + (r - l + 1 >> 1);
			if (table[mid] <= val) l = mid;
			else r = mid;
		}
		return l;
	}
	return dbcsCodec;
}
const require$$0$2 = [
	[
		"0",
		"\0",
		128
	],
	[
		"a1",
		"",
		62
	],
	[
		"8140",
		"",
		9,
		""
	],
	["8180", ""],
	["81b8", ""],
	["81c8", ""],
	["81da", ""],
	["81f0", ""],
	["81fc", ""],
	[
		"824f",
		"",
		9
	],
	[
		"8260",
		"",
		25
	],
	[
		"8281",
		"",
		25
	],
	[
		"829f",
		"",
		82
	],
	[
		"8340",
		"",
		62
	],
	[
		"8380",
		"",
		22
	],
	[
		"839f",
		"",
		16,
		"",
		6
	],
	[
		"83bf",
		"",
		16,
		"",
		6
	],
	[
		"8440",
		"",
		5,
		"",
		25
	],
	[
		"8470",
		"",
		5,
		"",
		7
	],
	[
		"8480",
		"",
		17
	],
	["849f", ""],
	[
		"8740",
		"",
		19,
		"",
		9
	],
	["875f", ""],
	["877e", ""],
	[
		"8780",
		"",
		4,
		""
	],
	["889f", ""],
	["8940", ""],
	["8980", ""],
	["8a40", ""],
	["8a80", ""],
	["8b40", ""],
	["8b80", ""],
	["8c40", ""],
	["8c80", ""],
	["8d40", ""],
	["8d80", ""],
	["8e40", ""],
	["8e80", ""],
	["8f40", ""],
	["8f80", ""],
	["9040", ""],
	["9080", ""],
	["9140", ""],
	["9180", ""],
	["9240", ""],
	["9280", ""],
	["9340", ""],
	["9380", ""],
	["9440", ""],
	["9480", ""],
	["9540", ""],
	["9580", ""],
	["9640", ""],
	["9680", ""],
	["9740", ""],
	["9780", ""],
	["9840", ""],
	["989f", ""],
	["9940", ""],
	["9980", ""],
	["9a40", ""],
	["9a80", ""],
	["9b40", ""],
	["9b80", ""],
	["9c40", ""],
	["9c80", ""],
	["9d40", ""],
	["9d80", ""],
	["9e40", ""],
	["9e80", ""],
	["9f40", ""],
	["9f80", ""],
	["e040", ""],
	["e080", ""],
	["e140", ""],
	["e180", ""],
	["e240", ""],
	["e280", ""],
	["e340", ""],
	["e380", ""],
	["e440", ""],
	["e480", ""],
	["e540", ""],
	["e580", ""],
	["e640", ""],
	["e680", ""],
	["e740", ""],
	["e780", ""],
	["e840", ""],
	["e880", ""],
	["e940", ""],
	["e980", ""],
	["ea40", ""],
	["ea80", ""],
	["ed40", ""],
	["ed80", ""],
	["ee40", ""],
	["ee80", ""],
	[
		"eeef",
		"",
		9,
		""
	],
	[
		"f040",
		"",
		62
	],
	[
		"f080",
		"",
		124
	],
	[
		"f140",
		"",
		62
	],
	[
		"f180",
		"",
		124
	],
	[
		"f240",
		"",
		62
	],
	[
		"f280",
		"",
		124
	],
	[
		"f340",
		"",
		62
	],
	[
		"f380",
		"",
		124
	],
	[
		"f440",
		"",
		62
	],
	[
		"f480",
		"",
		124
	],
	[
		"f540",
		"",
		62
	],
	[
		"f580",
		"",
		124
	],
	[
		"f640",
		"",
		62
	],
	[
		"f680",
		"",
		124
	],
	[
		"f740",
		"",
		62
	],
	[
		"f780",
		"",
		124
	],
	[
		"f840",
		"",
		62
	],
	[
		"f880",
		"",
		124
	],
	["f940", ""],
	[
		"fa40",
		"",
		9,
		"",
		9,
		""
	],
	["fa80", ""],
	["fb40", ""],
	["fb80", ""],
	["fc40", ""]
];
const require$$1 = /* @__PURE__ */ JSON.parse("[[\"0\",\"\\u0000\",127],[\"8ea1\",\"\",62],[\"a1a1\",\"\",9,\"\"],[\"a2a1\",\"\"],[\"a2ba\",\"\"],[\"a2ca\",\"\"],[\"a2dc\",\"\"],[\"a2f2\",\"\"],[\"a2fe\",\"\"],[\"a3b0\",\"\",9],[\"a3c1\",\"\",25],[\"a3e1\",\"\",25],[\"a4a1\",\"\",82],[\"a5a1\",\"\",85],[\"a6a1\",\"\",16,\"\",6],[\"a6c1\",\"\",16,\"\",6],[\"a7a1\",\"\",5,\"\",25],[\"a7d1\",\"\",5,\"\",25],[\"a8a1\",\"\"],[\"ada1\",\"\",19,\"\",9],[\"adc0\",\"\"],[\"addf\",\"\",4,\"\"],[\"b0a1\",\"\"],[\"b1a1\",\"\"],[\"b2a1\",\"\"],[\"b3a1\",\"\"],[\"b4a1\",\"\"],[\"b5a1\",\"\"],[\"b6a1\",\"\"],[\"b7a1\",\"\"],[\"b8a1\",\"\"],[\"b9a1\",\"\"],[\"baa1\",\"\"],[\"bba1\",\"\"],[\"bca1\",\"\"],[\"bda1\",\"\"],[\"bea1\",\"\"],[\"bfa1\",\"\"],[\"c0a1\",\"\"],[\"c1a1\",\"\"],[\"c2a1\",\"\"],[\"c3a1\",\"\"],[\"c4a1\",\"\"],[\"c5a1\",\"\"],[\"c6a1\",\"\"],[\"c7a1\",\"\"],[\"c8a1\",\"\"],[\"c9a1\",\"\"],[\"caa1\",\"\"],[\"cba1\",\"\"],[\"cca1\",\"\"],[\"cda1\",\"\"],[\"cea1\",\"\"],[\"cfa1\",\"\"],[\"d0a1\",\"\"],[\"d1a1\",\"\"],[\"d2a1\",\"\"],[\"d3a1\",\"\"],[\"d4a1\",\"\"],[\"d5a1\",\"\"],[\"d6a1\",\"\"],[\"d7a1\",\"\"],[\"d8a1\",\"\"],[\"d9a1\",\"\"],[\"daa1\",\"\"],[\"dba1\",\"\"],[\"dca1\",\"\"],[\"dda1\",\"\"],[\"dea1\",\"\"],[\"dfa1\",\"\"],[\"e0a1\",\"\"],[\"e1a1\",\"\"],[\"e2a1\",\"\"],[\"e3a1\",\"\"],[\"e4a1\",\"\"],[\"e5a1\",\"\"],[\"e6a1\",\"\"],[\"e7a1\",\"\"],[\"e8a1\",\"\"],[\"e9a1\",\"\"],[\"eaa1\",\"\"],[\"eba1\",\"\"],[\"eca1\",\"\"],[\"eda1\",\"\"],[\"eea1\",\"\"],[\"efa1\",\"\"],[\"f0a1\",\"\"],[\"f1a1\",\"\"],[\"f2a1\",\"\"],[\"f3a1\",\"\"],[\"f4a1\",\"\"],[\"f9a1\",\"\"],[\"faa1\",\"\"],[\"fba1\",\"\"],[\"fca1\",\"\"],[\"fcf1\",\"\",9,\"\"],[\"8fa2af\",\"\"],[\"8fa2c2\",\"\"],[\"8fa2eb\",\"\"],[\"8fa6e1\",\"\"],[\"8fa6e7\",\"\"],[\"8fa6e9\",\"\"],[\"8fa6ec\",\"\"],[\"8fa6f1\",\"\"],[\"8fa7c2\",\"\",10,\"\"],[\"8fa7f2\",\"\",10,\"\"],[\"8fa9a1\",\"\"],[\"8fa9a4\",\"\"],[\"8fa9a6\",\"\"],[\"8fa9a8\",\"\"],[\"8fa9ab\",\"\"],[\"8fa9af\",\"\"],[\"8fa9c1\",\"\"],[\"8faaa1\",\"\"],[\"8faaba\",\"\"],[\"8faba1\",\"\"],[\"8fabbd\",\"\"],[\"8fabc5\",\"\"],[\"8fb0a1\",\"\"],[\"8fb1a1\",\"\"],[\"8fb2a1\",\"\",4,\"\"],[\"8fb3a1\",\"\"],[\"8fb4a1\",\"\"],[\"8fb5a1\",\"\"],[\"8fb6a1\",\"\",5,\"\",4,\"\"],[\"8fb7a1\",\"\",4,\"\"],[\"8fb8a1\",\"\"],[\"8fb9a1\",\"\"],[\"8fbaa1\",\"\",4,\"\"],[\"8fbba1\",\"\"],[\"8fbca1\",\"\",4,\"\"],[\"8fbda1\",\"\",4,\"\"],[\"8fbea1\",\"\",4,\"\"],[\"8fbfa1\",\"\"],[\"8fc0a1\",\"\"],[\"8fc1a1\",\"\"],[\"8fc2a1\",\"\"],[\"8fc3a1\",\"\",4,\"\"],[\"8fc4a1\",\"\"],[\"8fc5a1\",\"\"],[\"8fc6a1\",\"\"],[\"8fc7a1\",\"\"],[\"8fc8a1\",\"\"],[\"8fc9a1\",\"\",4,\"\",4,\"\"],[\"8fcaa1\",\"\"],[\"8fcba1\",\"\"],[\"8fcca1\",\"\",9,\"\"],[\"8fcda1\",\"\",5,\"\"],[\"8fcea1\",\"\",6,\"\"],[\"8fcfa1\",\"\"],[\"8fd0a1\",\"\"],[\"8fd1a1\",\"\"],[\"8fd2a1\",\"\",5],[\"8fd3a1\",\"\"],[\"8fd4a1\",\"\",4,\"\"],[\"8fd5a1\",\"\"],[\"8fd6a1\",\"\"],[\"8fd7a1\",\"\"],[\"8fd8a1\",\"\"],[\"8fd9a1\",\"\",4,\"\",6,\"\"],[\"8fdaa1\",\"\",4,\"\"],[\"8fdba1\",\"\",6,\"\"],[\"8fdca1\",\"\",4,\"\"],[\"8fdda1\",\"\",4,\"\"],[\"8fdea1\",\"\",4,\"\"],[\"8fdfa1\",\"\"],[\"8fe0a1\",\"\"],[\"8fe1a1\",\"\",4,\"\"],[\"8fe2a1\",\"\"],[\"8fe3a1\",\"\",5,\"\",4,\"\"],[\"8fe4a1\",\"\",4,\"\"],[\"8fe5a1\",\"\",4,\"\"],[\"8fe6a1\",\"\"],[\"8fe7a1\",\"\"],[\"8fe8a1\",\"\",4,\"\"],[\"8fe9a1\",\"\",4],[\"8feaa1\",\"\",4,\"\"],[\"8feba1\",\"\",4,\"\"],[\"8feca1\",\"\"],[\"8feda1\",\"\",4,\"\",4,\"\"]]");
const require$$2$1 = /* @__PURE__ */ JSON.parse("[[\"0\",\"\\u0000\",127,\"\"],[\"8140\",\"\",5,\"\",9,\"\",6,\"\"],[\"8180\",\"\",6,\"\",4,\"\",4,\"\",5,\"\"],[\"8240\",\"\",4,\"\",8,\"\",4,\"\",11],[\"8280\",\"\",10,\"\",4,\"\",7,\"\",5,\"\",8,\"\",20,\"\",4,\"\",6,\"\"],[\"8340\",\"\",17,\"\",5,\"\",10,\"\",4,\"\",9,\"\"],[\"8380\",\"\",5,\"\",13,\"\",28,\"\",4,\"\",4,\"\",5],[\"8440\",\"\",5,\"\",5,\"\"],[\"8480\",\"\",9,\"\",4,\"\",6,\"\",6,\"\",9,\"\",5,\"\",10,\"\",7,\"\"],[\"8540\",\"\",9,\"\"],[\"8580\",\"\",4,\"\",6,\"\",4,\"\",4,\"\",7,\"\"],[\"8640\",\"\",4,\"\",5,\"\",4,\"\",5,\"\"],[\"8680\",\"\",4,\"\",4,\"\",5,\"\",6,\"\",8,\"\",4,\"\",4,\"\",4,\"\"],[\"8740\",\"\",7,\"\",11,\"\",4,\"\",4],[\"8780\",\"\",7,\"\",6,\"\",14,\"\",10,\"\",6,\"\",12,\"\",8,\"\",5,\"\",6],[\"8840\",\"\",9,\"\",4,\"\",4,\"\"],[\"8880\",\"\",4,\"\",6,\"\",8,\"\",6,\"\",7,\"\",4,\"\",4,\"\",7],[\"8940\",\"\",5,\"\",6,\"\",4,\"\",5,\"\",4,\"\",16,\"\"],[\"8980\",\"\",4,\"\",4,\"\",7,\"\",17,\"\",10,\"\",13,\"\",5,\"\",7,\"\",4,\"\"],[\"8a40\",\"\",4,\"\",12,\"\"],[\"8a80\",\"\",5,\"\",6,\"\",4,\"\",11,\"\",6,\"\",4,\"\",4,\"\",9,\"\",5],[\"8b40\",\"\",8,\"\",17,\"\",6,\"\",13,\"\"],[\"8b80\",\"\",4,\"\",4,\"\",5,\"\",4,\"\",4,\"\",22,\"\",11,\"\",25,\"\",7,\"\",6],[\"8c40\",\"\",7,\"\"],[\"8c80\",\"\",8,\"\",4,\"\",6,\"\",6,\"\",6,\"\",4,\"\",4,\"\",4],[\"8d40\",\"\",5,\"\",5,\"\",5,\"\",6,\"\",9,\"\",4],[\"8d80\",\"\",5,\"\",4,\"\",4,\"\",4,\"\",7,\"\",7,\"\",10,\"\",10,\"\",12,\"\",21,\"\"],[\"8e40\",\"\",21,\"\",12,\"\",6,\"\",12,\"\"],[\"8e80\",\"\",4,\"\",7,\"\",4,\"\",4,\"\",5,\"\",6,\"\",4,\"\",14,\"\",4,\"\",4,\"\",6],[\"8f40\",\"\",5,\"\",11,\"\",8,\"\"],[\"8f80\",\"\",6,\"\",14,\"\",5,\"\",5,\"\",4,\"\"],[\"9040\",\"\",4,\"\",4,\"\",6,\"\"],[\"9080\",\"\",7,\"\",4,\"\",4,\"\",4,\"\",4,\"\",18,\"\",6],[\"9140\",\"\",6,\"\",6,\"\",18,\"\",4,\"\"],[\"9180\",\"\",6,\"\",8,\"\",9,\"\",5,\"\",4,\"\",4,\"\",16,\"\",13,\"\",8,\"\",5,\"\",4,\"\"],[\"9240\",\"\",6,\"\",5,\"\"],[\"9280\",\"\",5,\"\",7,\"\",6,\"\"],[\"9340\",\"\",6,\"\",4,\"\",4,\"\",5,\"\"],[\"9380\",\"\",5,\"\",4,\"\",6,\"\",4,\"\",7,\"\",9,\"\",6,\"\",8,\"\",4,\"\",6,\"\"],[\"9440\",\"\",24,\"\",7,\"\",7,\"\",4,\"\",8],[\"9480\",\"\",4,\"\",4,\"\",14,\"\",7,\"\",7,\"\"],[\"9540\",\"\",4,\"\",4,\"\",6,\"\"],[\"9580\",\"\",4,\"\",4,\"\",8,\"\",4,\"\",4,\"\",25,\"\",7,\"\",5,\"\"],[\"9640\",\"\",5,\"\",4,\"\"],[\"9680\",\"\",7,\"\",9,\"\",7,\"\",4,\"\",6,\"\",6,\"\",5],[\"9740\",\"\",7,\"\",8,\"\",7,\"\",9,\"\"],[\"9780\",\"\",6,\"\",5,\"\",4,\"\",9,\"\",4,\"\",11,\"\",7,\"\",16,\"\"],[\"9840\",\"\",4,\"\",5,\"\",9,\"\"],[\"9880\",\"\",7,\"\",5,\"\",11,\"\",9,\"\",9,\"\",11,\"\",5,\"\",5,\"\",6,\"\",4,\"\",7,\"\",6,\"\"],[\"9940\",\"\",4,\"\",10,\"\",6,\"\",8,\"\",4,\"\",7,\"\",5],[\"9980\",\"\",114,\"\",6],[\"9a40\",\"\",11,\"\",7,\"\",13,\"\"],[\"9a80\",\"\",4,\"\",7,\"\",7,\"\",6,\"\",4,\"\",4,\"\",7,\"\",6,\"\",4,\"\",4,\"\"],[\"9b40\",\"\",4,\"\"],[\"9b80\",\"\",5,\"\",4,\"\",4,\"\",5,\"\"],[\"9c40\",\"\",7,\"\"],[\"9c80\",\"\",7,\"\",7,\"\",10,\"\",14,\"\",4,\"\",6,\"\",5],[\"9d40\",\"\",7,\"\",4,\"\",9,\"\",6,\"\"],[\"9d80\",\"\",9,\"\",5,\"\",6,\"\",12,\"\",4,\"\",10,\"\",5,\"\",5,\"\",6,\"\",10,\"\"],[\"9e40\",\"\",7,\"\",32,\"\",7,\"\",6,\"\",6],[\"9e80\",\"\",9,\"\",17,\"\",13,\"\",11,\"\",12,\"\",12,\"\"],[\"9f40\",\"\",6,\"\",10,\"\",4,\"\",10,\"\",7,\"\"],[\"9f80\",\"\",13,\"\",12,\"\",4,\"\",4,\"\",5,\"\",4,\"\",4,\"\",6,\"\",5,\"\",8,\"\",9,\"\",4],[\"a040\",\"\",9,\"\",5,\"\",9,\"\",11,\"\",19],[\"a080\",\"\",9,\"\",6,\"\",4,\"\",11,\"\",11,\"\",6,\"\"],[\"a1a1\",\"\",7,\"\"],[\"a2a1\",\"\",9],[\"a2b1\",\"\",19,\"\",19,\"\",9],[\"a2e5\",\"\",9],[\"a2f1\",\"\",11],[\"a3a1\",\"\",88,\"\"],[\"a4a1\",\"\",82],[\"a5a1\",\"\",85],[\"a6a1\",\"\",16,\"\",6],[\"a6c1\",\"\",16,\"\",6],[\"a6e0\",\"\"],[\"a6ee\",\"\"],[\"a6f4\",\"\"],[\"a7a1\",\"\",5,\"\",25],[\"a7d1\",\"\",5,\"\",25],[\"a840\",\"\",35,\"\",6],[\"a880\",\"\",7,\"\"],[\"a8a1\",\"\"],[\"a8bd\",\"\"],[\"a8c0\",\"\"],[\"a8c5\",\"\",36],[\"a940\",\"\",8,\"\"],[\"a959\",\"\"],[\"a95c\",\"\"],[\"a960\",\"\",9,\"\",8],[\"a980\",\"\",4,\"\"],[\"a996\",\"\"],[\"a9a4\",\"\",75],[\"aa40\",\"\",5,\"\",5,\"\",8],[\"aa80\",\"\",7,\"\",10,\"\"],[\"ab40\",\"\",11,\"\",4,\"\",5,\"\",4],[\"ab80\",\"\",6,\"\",4],[\"ac40\",\"\",10,\"\",8,\"\",5,\"\",4,\"\",11],[\"ac80\",\"\",6,\"\",12,\"\",4,\"\"],[\"ad40\",\"\",10,\"\",7,\"\",15,\"\",12],[\"ad80\",\"\",9,\"\",8,\"\",6,\"\"],[\"ae40\",\"\",6,\"\",7,\"\",4,\"\"],[\"ae80\",\"\",7,\"\",6,\"\",4,\"\"],[\"af40\",\"\",4,\"\"],[\"af80\",\"\"],[\"b040\",\"\",6,\"\",5,\"\",4,\"\",6,\"\",7,\"\"],[\"b080\",\"\",7,\"\",8,\"\",9,\"\"],[\"b140\",\"\",4,\"\",7,\"\",10,\"\"],[\"b180\",\"\",4,\"\",7,\"\",7,\"\"],[\"b240\",\"\",11,\"\",5,\"\",11,\"\",4],[\"b280\",\"\",12,\"\",8,\"\",4,\"\"],[\"b340\",\"\",5,\"\"],[\"b380\",\"\",11,\"\",7,\"\",6,\"\"],[\"b440\",\"\",7,\"\",9],[\"b480\",\"\",4,\"\",5,\"\",6,\"\"],[\"b540\",\"\",5,\"\",9,\"\",4,\"\",14,\"\",4,\"\",8,\"\"],[\"b580\",\"\",6,\"\",4,\"\"],[\"b640\",\"\",6,\"\",11,\"\",10,\"\",4,\"\",5,\"\"],[\"b680\",\"\",6,\"\",4,\"\"],[\"b740\",\"\",14,\"\",5,\"\",9,\"\",4,\"\",16],[\"b780\",\"\",6,\"\"],[\"b840\",\"\",4,\"\",10,\"\",10,\"\",9,\"\",5,\"\"],[\"b880\",\"\",4,\"\"],[\"b940\",\"\",5,\"\",10,\"\",6,\"\"],[\"b980\",\"\",7,\"\"],[\"ba40\",\"\",4,\"\",4,\"\",7,\"\",5,\"\"],[\"ba80\",\"\",4,\"\",5,\"\",12,\"\",5,\"\"],[\"bb40\",\"\",9,\"\",36,\"\",5,\"\",9],[\"bb80\",\"\",6,\"\",4,\"\"],[\"bc40\",\"\",6,\"\",6,\"\",5,\"\",7,\"\",13,\"\",5],[\"bc80\",\"\",14,\"\",6,\"\"],[\"bd40\",\"\",54,\"\",7],[\"bd80\",\"\",32,\"\"],[\"be40\",\"\",12,\"\",6,\"\",42],[\"be80\",\"\",32,\"\"],[\"bf40\",\"\",62],[\"bf80\",\"\",4,\"\",4,\"\",21,\"\"],[\"c040\",\"\",35,\"\",23,\"\"],[\"c080\",\"\",6,\"\",9,\"\"],[\"c140\",\"\",4,\"\",7,\"\",4,\"\",4,\"\",6,\"\"],[\"c180\",\"\",4,\"\",4,\"\",5,\"\"],[\"c240\",\"\",6,\"\",5,\"\"],[\"c280\",\"\",13,\"\",5,\"\",11,\"\"],[\"c340\",\"\",5,\"\",4,\"\",6,\"\"],[\"c380\",\"\",12,\"\",4,\"\"],[\"c440\",\"\",5,\"\",4,\"\",4,\"\",5,\"\",4,\"\"],[\"c480\",\"\",7,\"\",5,\"\",6,\"\"],[\"c540\",\"\",14,\"\",4,\"\",5,\"\",4,\"\",5,\"\"],[\"c580\",\"\",7,\"\",7,\"\"],[\"c640\",\"\"],[\"c680\",\"\",4,\"\",9,\"\"],[\"c740\",\"\",4,\"\",4,\"\",6,\"\",6,\"\",6,\"\"],[\"c780\",\"\"],[\"c840\",\"\",4,\"\",5,\"\",5,\"\",7,\"\",5,\"\",7,\"\"],[\"c880\",\"\",6,\"\",4,\"\",4,\"\"],[\"c940\",\"\",4,\"\",7,\"\",12,\"\"],[\"c980\",\"\",4,\"\",4,\"\",10,\"\"],[\"ca40\",\"\",8,\"\",8,\"\",9,\"\",4,\"\",10],[\"ca80\",\"\",4,\"\",8,\"\"],[\"cb40\",\"\",6,\"\",10,\"\",6,\"\",5,\"\",6,\"\",6,\"\",4,\"\"],[\"cb80\",\"\",5,\"\",6,\"\",14,\"\"],[\"cc40\",\"\",4,\"\",10,\"\",15,\"\",13,\"\"],[\"cc80\",\"\",11,\"\",4,\"\",7,\"\"],[\"cd40\",\"\",6,\"\",6,\"\",4,\"\",5,\"\",4,\"\",4,\"\"],[\"cd80\",\"\"],[\"ce40\",\"\",6,\"\",5,\"\",7,\"\"],[\"ce80\",\"\",4,\"\",6,\"\",4,\"\"],[\"cf40\",\"\",4,\"\",4,\"\",6,\"\",9],[\"cf80\",\"\",5,\"\",7,\"\",4,\"\"],[\"d040\",\"\",13,\"\",5,\"\",5,\"\",5,\"\",6,\"\"],[\"d080\",\"\",4,\"\",4,\"\",5,\"\"],[\"d140\",\"\",4,\"\",4,\"\",6,\"\",5],[\"d180\",\"\",4,\"\",4,\"\",4,\"\"],[\"d240\",\"\",8,\"\",24,\"\",5,\"\",19,\"\"],[\"d280\",\"\",26,\"\"],[\"d340\",\"\",30,\"\",6],[\"d380\",\"\",4,\"\",5,\"\",21,\"\"],[\"d440\",\"\",31,\"\",8,\"\",21],[\"d480\",\"\",25,\"\",6,\"\"],[\"d540\",\"\",7,\"\",7,\"\",46],[\"d580\",\"\",32,\"\"],[\"d640\",\"\",34,\"\",27],[\"d680\",\"\",30,\"\"],[\"d740\",\"\",31,\"\",4,\"\",25],[\"d780\",\"\",24,\"\"],[\"d840\",\"\",8,\"\",7,\"\",5,\"\",6,\"\",6,\"\",6,\"\"],[\"d880\",\"\",6,\"\",20,\"\"],[\"d940\",\"\",62],[\"d980\",\"\",32,\"\"],[\"da40\",\"\",14,\"\",8,\"\",4,\"\",9,\"\"],[\"da80\",\"\",12,\"\"],[\"db40\",\"\",6,\"\",7,\"\",4,\"\"],[\"db80\",\"\",4,\"\",5,\"\",11,\"\"],[\"dc40\",\"\",4,\"\",6,\"\",6,\"\",11,\"\",6,\"\",7],[\"dc80\",\"\",10,\"\",21,\"\"],[\"dd40\",\"\",62],[\"dd80\",\"\",32,\"\"],[\"de40\",\"\",32,\"\"],[\"de80\",\"\",4,\"\"],[\"df40\",\"\",5,\"\",4,\"\",4,\"\",5,\"\",4,\"\",6,\"\"],[\"df80\",\"\",4,\"\"],[\"e040\",\"\",19,\"\"],[\"e080\",\"\",10,\"\",6,\"\",8,\"\"],[\"e140\",\"\",4,\"\",6,\"\",5,\"\",5,\"\"],[\"e180\",\"\",10,\"\",9,\"\",8,\"\"],[\"e240\",\"\",62],[\"e280\",\"\",32,\"\",5,\"\"],[\"e340\",\"\",45,\"\",16],[\"e380\",\"\",7,\"\",24,\"\"],[\"e440\",\"\",5,\"\",24,\"\",31],[\"e480\",\"\",32,\"\"],[\"e540\",\"\",51,\"\",10],[\"e580\",\"\",31,\"\"],[\"e640\",\"\",34,\"\",27],[\"e680\",\"\",29,\"\"],[\"e740\",\"\",7,\"\",54],[\"e780\",\"\",32,\"\",6,\"\",4,\"\"],[\"e840\",\"\",14,\"\",43,\"\"],[\"e880\",\"\",20,\"\"],[\"e940\",\"\",7,\"\",42],[\"e980\",\"\",32,\"\"],[\"ea40\",\"\",27,\"\",6,\"\"],[\"ea80\",\"\",4,\"\",12,\"\"],[\"eb40\",\"\",9,\"\",7,\"\",9,\"\",6,\"\"],[\"eb80\",\"\",4,\"\"],[\"ec40\",\"\",8,\"\",4,\"\",18,\"\",7],[\"ec80\",\"\",4,\"\",7,\"\",4,\"\",4,\"\"],[\"ed40\",\"\",6,\"\",46],[\"ed80\",\"\",4,\"\",23,\"\"],[\"ee40\",\"\",62],[\"ee80\",\"\",32,\"\",4,\"\",6,\"\"],[\"ef40\",\"\",5,\"\",37,\"\",4],[\"ef80\",\"\",30,\"\",4,\"\",8,\"\"],[\"f040\",\"\",4,\"\",28,\"\",26],[\"f080\",\"\",9,\"\",12,\"\",4,\"\",6,\"\"],[\"f140\",\"\",10,\"\",47],[\"f180\",\"\",32,\"\"],[\"f240\",\"\",62],[\"f280\",\"\",32,\"\"],[\"f340\",\"\",17,\"\",6,\"\",4,\"\"],[\"f380\",\"\",8,\"\",6,\"\"],[\"f440\",\"\",5,\"\",10,\"\",10,\"\",7,\"\",5],[\"f480\",\"\",32,\"\"],[\"f540\",\"\",62],[\"f580\",\"\",32,\"\"],[\"f640\",\"\",62],[\"f680\",\"\",32,\"\",5,\"\",5,\"\",4,\"\",7,\"\"],[\"f740\",\"\",62],[\"f780\",\"\",4,\"\",4,\"\"],[\"f840\",\"\",62],[\"f880\",\"\",32],[\"f940\",\"\",62],[\"f980\",\"\",32],[\"fa40\",\"\",62],[\"fa80\",\"\",32],[\"fb40\",\"\",27,\"\",9,\"\"],[\"fb80\",\"\",5,\"\",8,\"\",5,\"\"],[\"fc40\",\"\",8,\"\",4,\"\",8,\"\",6],[\"fc80\",\"\",4,\"\",5,\"\",8,\"\"],[\"fd40\",\"\",4,\"\",4,\"\",10,\"\",38],[\"fd80\",\"\",5,\"\",11,\"\",4,\"\"],[\"fe40\",\"\"]]");
const require$$3 = [
	[
		"a140",
		"",
		62
	],
	[
		"a180",
		"",
		32
	],
	[
		"a240",
		"",
		62
	],
	[
		"a280",
		"",
		32
	],
	[
		"a2ab",
		"",
		5
	],
	["a2e3", ""],
	["a2ef", ""],
	["a2fd", ""],
	[
		"a340",
		"",
		62
	],
	[
		"a380",
		"",
		31,
		""
	],
	[
		"a440",
		"",
		62
	],
	[
		"a480",
		"",
		32
	],
	[
		"a4f4",
		"",
		10
	],
	[
		"a540",
		"",
		62
	],
	[
		"a580",
		"",
		32
	],
	[
		"a5f7",
		"",
		7
	],
	[
		"a640",
		"",
		62
	],
	[
		"a680",
		"",
		32
	],
	[
		"a6b9",
		"",
		7
	],
	[
		"a6d9",
		"",
		6
	],
	["a6ec", ""],
	["a6f3", ""],
	[
		"a6f6",
		"",
		8
	],
	[
		"a740",
		"",
		62
	],
	[
		"a780",
		"",
		32
	],
	[
		"a7c2",
		"",
		14
	],
	[
		"a7f2",
		"",
		12
	],
	[
		"a896",
		"",
		10
	],
	["a8bc", ""],
	["a8bf", ""],
	["a8c1", ""],
	[
		"a8ea",
		"",
		20
	],
	["a958", ""],
	["a95b", ""],
	["a95d", ""],
	[
		"a989",
		"",
		11
	],
	[
		"a997",
		"",
		12
	],
	[
		"a9f0",
		"",
		14
	],
	[
		"aaa1",
		"",
		93
	],
	[
		"aba1",
		"",
		93
	],
	[
		"aca1",
		"",
		93
	],
	[
		"ada1",
		"",
		93
	],
	[
		"aea1",
		"",
		93
	],
	[
		"afa1",
		"",
		93
	],
	[
		"d7fa",
		"",
		4
	],
	[
		"f8a1",
		"",
		93
	],
	[
		"f9a1",
		"",
		93
	],
	[
		"faa1",
		"",
		93
	],
	[
		"fba1",
		"",
		93
	],
	[
		"fca1",
		"",
		93
	],
	[
		"fda1",
		"",
		93
	],
	["fe50", ""],
	[
		"fe80",
		"",
		6,
		"",
		93
	],
	["8135f437", ""]
];
const require$$4 = {
	uChars: [
		128,
		165,
		169,
		178,
		184,
		216,
		226,
		235,
		238,
		244,
		248,
		251,
		253,
		258,
		276,
		284,
		300,
		325,
		329,
		334,
		364,
		463,
		465,
		467,
		469,
		471,
		473,
		475,
		477,
		506,
		594,
		610,
		712,
		716,
		730,
		930,
		938,
		962,
		970,
		1026,
		1104,
		1106,
		8209,
		8215,
		8218,
		8222,
		8231,
		8241,
		8244,
		8246,
		8252,
		8365,
		8452,
		8454,
		8458,
		8471,
		8482,
		8556,
		8570,
		8596,
		8602,
		8713,
		8720,
		8722,
		8726,
		8731,
		8737,
		8740,
		8742,
		8748,
		8751,
		8760,
		8766,
		8777,
		8781,
		8787,
		8802,
		8808,
		8816,
		8854,
		8858,
		8870,
		8896,
		8979,
		9322,
		9372,
		9548,
		9588,
		9616,
		9622,
		9634,
		9652,
		9662,
		9672,
		9676,
		9680,
		9702,
		9735,
		9738,
		9793,
		9795,
		11906,
		11909,
		11913,
		11917,
		11928,
		11944,
		11947,
		11951,
		11956,
		11960,
		11964,
		11979,
		12284,
		12292,
		12312,
		12319,
		12330,
		12351,
		12436,
		12447,
		12535,
		12543,
		12586,
		12842,
		12850,
		12964,
		13200,
		13215,
		13218,
		13253,
		13263,
		13267,
		13270,
		13384,
		13428,
		13727,
		13839,
		13851,
		14617,
		14703,
		14801,
		14816,
		14964,
		15183,
		15471,
		15585,
		16471,
		16736,
		17208,
		17325,
		17330,
		17374,
		17623,
		17997,
		18018,
		18212,
		18218,
		18301,
		18318,
		18760,
		18811,
		18814,
		18820,
		18823,
		18844,
		18848,
		18872,
		19576,
		19620,
		19738,
		19887,
		40870,
		59244,
		59336,
		59367,
		59413,
		59417,
		59423,
		59431,
		59437,
		59443,
		59452,
		59460,
		59478,
		59493,
		63789,
		63866,
		63894,
		63976,
		63986,
		64016,
		64018,
		64021,
		64025,
		64034,
		64037,
		64042,
		65074,
		65093,
		65107,
		65112,
		65127,
		65132,
		65375,
		65510,
		65536
	],
	gbChars: [
		0,
		36,
		38,
		45,
		50,
		81,
		89,
		95,
		96,
		100,
		103,
		104,
		105,
		109,
		126,
		133,
		148,
		172,
		175,
		179,
		208,
		306,
		307,
		308,
		309,
		310,
		311,
		312,
		313,
		341,
		428,
		443,
		544,
		545,
		558,
		741,
		742,
		749,
		750,
		805,
		819,
		820,
		7922,
		7924,
		7925,
		7927,
		7934,
		7943,
		7944,
		7945,
		7950,
		8062,
		8148,
		8149,
		8152,
		8164,
		8174,
		8236,
		8240,
		8262,
		8264,
		8374,
		8380,
		8381,
		8384,
		8388,
		8390,
		8392,
		8393,
		8394,
		8396,
		8401,
		8406,
		8416,
		8419,
		8424,
		8437,
		8439,
		8445,
		8482,
		8485,
		8496,
		8521,
		8603,
		8936,
		8946,
		9046,
		9050,
		9063,
		9066,
		9076,
		9092,
		9100,
		9108,
		9111,
		9113,
		9131,
		9162,
		9164,
		9218,
		9219,
		11329,
		11331,
		11334,
		11336,
		11346,
		11361,
		11363,
		11366,
		11370,
		11372,
		11375,
		11389,
		11682,
		11686,
		11687,
		11692,
		11694,
		11714,
		11716,
		11723,
		11725,
		11730,
		11736,
		11982,
		11989,
		12102,
		12336,
		12348,
		12350,
		12384,
		12393,
		12395,
		12397,
		12510,
		12553,
		12851,
		12962,
		12973,
		13738,
		13823,
		13919,
		13933,
		14080,
		14298,
		14585,
		14698,
		15583,
		15847,
		16318,
		16434,
		16438,
		16481,
		16729,
		17102,
		17122,
		17315,
		17320,
		17402,
		17418,
		17859,
		17909,
		17911,
		17915,
		17916,
		17936,
		17939,
		17961,
		18664,
		18703,
		18814,
		18962,
		19043,
		33469,
		33470,
		33471,
		33484,
		33485,
		33490,
		33497,
		33501,
		33505,
		33513,
		33520,
		33536,
		33550,
		37845,
		37921,
		37948,
		38029,
		38038,
		38064,
		38065,
		38066,
		38069,
		38075,
		38076,
		38078,
		39108,
		39109,
		39113,
		39114,
		39115,
		39116,
		39265,
		39394,
		189e3
	]
};
const require$$5$1 = /* @__PURE__ */ JSON.parse("[[\"0\",\"\\u0000\",127],[\"8141\",\"\",4,\"\",6,\"\"],[\"8161\",\"\",9,\"\",5,\"\"],[\"8181\",\"\",18,\"\",4,\"\",6,\"\",5,\"\",6,\"\",7,\"\",7,\"\",4,\"\",4,\"\"],[\"8241\",\"\",7,\"\",5],[\"8261\",\"\",6,\"\",5,\"\"],[\"8281\",\"\",7,\"\",7,\"\",4,\"\",10,\"\",5,\"\",17,\"\",7,\"\",6,\"\",7,\"\",18],[\"8341\",\"\",5,\"\",5,\"\",7],[\"8361\",\"\",18,\"\"],[\"8381\",\"\",4,\"\",6,\"\",5,\"\",5,\"\",46,\"\",6,\"\",5,\"\",8],[\"8441\",\"\",5,\"\",8],[\"8461\",\"\",18],[\"8481\",\"\",7,\"\",6,\"\",5,\"\",10,\"\",5,\"\",18,\"\",5,\"\",6,\"\",5,\"\",26,\"\"],[\"8541\",\"\",5,\"\",4,\"\",6,\"\",4],[\"8561\",\"\",5,\"\",5,\"\",6,\"\"],[\"8581\",\"\",6,\"\",6,\"\",9,\"\",26,\"\",29,\"\",6,\"\",5,\"\"],[\"8641\",\"\",6,\"\",5,\"\"],[\"8661\",\"\",6,\"\",10],[\"8681\",\"\",22,\"\",4,\"\",6,\"\",5,\"\",6,\"\",22,\"\",4,\"\"],[\"8741\",\"\",9,\"\",15],[\"8761\",\"\",18,\"\"],[\"8781\",\"\",5,\"\",7,\"\",7,\"\",5,\"\",6,\"\",5,\"\",18,\"\",6,\"\",26,\"\",6,\"\",4],[\"8841\",\"\",4,\"\",5,\"\",6,\"\",4],[\"8861\",\"\",4,\"\"],[\"8881\",\"\",15,\"\",4,\"\",6,\"\",5,\"\",54,\"\"],[\"8941\",\"\",6,\"\",5,\"\"],[\"8961\",\"\",10,\"\",5,\"\"],[\"8981\",\"\",21,\"\",18,\"\",18,\"\",6,\"\",6,\"\",7,\"\",15],[\"8a41\",\"\",10,\"\",6,\"\"],[\"8a61\",\"\",4,\"\",18,\"\"],[\"8a81\",\"\",4,\"\",19,\"\",5,\"\",7,\"\",5,\"\",6,\"\",5,\"\",4,\"\",5,\"\",26,\"\"],[\"8b41\",\"\",5,\"\",4,\"\",6,\"\"],[\"8b61\",\"\",6,\"\",8],[\"8b81\",\"\",52,\"\",4,\"\",6,\"\",5,\"\",18,\"\",18],[\"8c41\",\"\",15,\"\",4],[\"8c61\",\"\",6,\"\",5,\"\",6,\"\",5],[\"8c81\",\"\",12,\"\",26,\"\",50,\"\",5,\"\",16],[\"8d41\",\"\",16,\"\",8],[\"8d61\",\"\",17,\"\"],[\"8d81\",\"\",4,\"\",33,\"\",6,\"\",7,\"\",6,\"\",9,\"\",6,\"\",5,\"\",6,\"\"],[\"8e41\",\"\",6,\"\",5,\"\",8],[\"8e61\",\"\",4,\"\",19],[\"8e81\",\"\",13,\"\",6,\"\",4,\"\",6,\"\",5,\"\",6,\"\",5,\"\",11,\"\",7,\"\",6,\"\",5,\"\",7],[\"8f41\",\"\",7,\"\",17],[\"8f61\",\"\",7,\"\",6,\"\",4],[\"8f81\",\"\",5,\"\",7,\"\",5,\"\",6,\"\",5,\"\",18,\"\",6,\"\",26,\"\",6,\"\",5],[\"9041\",\"\",6,\"\",5,\"\"],[\"9061\",\"\",5,\"\",15],[\"9081\",\"\",12,\"\",6,\"\",5,\"\",4,\"\",6,\"\",4,\"\",5,\"\",11,\"\",33,\"\"],[\"9141\",\"\",6,\"\",5],[\"9161\",\"\",9,\"\",5],[\"9181\",\"\",20,\"\",4,\"\",5,\"\",14,\"\",33,\"\",7,\"\",5,\"\",6],[\"9241\",\"\",7,\"\",4,\"\"],[\"9261\",\"\",7,\"\",7,\"\",4],[\"9281\",\"\",21,\"\",18,\"\",6,\"\",7,\"\",6,\"\",35,\"\"],[\"9341\",\"\",4,\"\"],[\"9361\",\"\",6,\"\",8],[\"9381\",\"\",37,\"\",4,\"\",4,\"\",6,\"\",5,\"\",7,\"\",22,\"\"],[\"9441\",\"\",5,\"\",5,\"\",8],[\"9461\",\"\",5,\"\",6,\"\",12],[\"9481\",\"\",5,\"\",6,\"\",6,\"\",9,\"\",22,\"\",4,\"\",6,\"\",10,\"\",6,\"\",24],[\"9541\",\"\",11,\"\",5,\"\"],[\"9561\",\"\",6,\"\",5,\"\"],[\"9581\",\"\",6,\"\",35,\"\",4,\"\",4,\"\",4,\"\",6,\"\",5,\"\",13,\"\",14],[\"9641\",\"\",23,\"\"],[\"9661\",\"\",6,\"\",5,\"\",8],[\"9681\",\"\",10,\"\",5,\"\",13,\"\",33,\"\",6,\"\",44],[\"9741\",\"\",16,\"\",8],[\"9761\",\"\",17,\"\",7],[\"9781\",\"\",11,\"\",5,\"\",6,\"\",89,\"\"],[\"9841\",\"\",16,\"\",5,\"\"],[\"9861\",\"\",6,\"\",15],[\"9881\",\"\",21,\"\",6,\"\",5,\"\",4,\"\",6,\"\",5,\"\",6,\"\",5,\"\",6,\"\",5,\"\"],[\"9941\",\"\",6,\"\",5,\"\"],[\"9961\",\"\",6,\"\",5,\"\"],[\"9981\",\"\",8,\"\",5,\"\",4,\"\",11,\"\",5,\"\",6,\"\",6,\"\",6,\"\",7,\"\",6,\"\",5,\"\"],[\"9a41\",\"\",16],[\"9a61\",\"\",6,\"\",6,\"\"],[\"9a81\",\"\",4,\"\",6,\"\",5,\"\",5,\"\",6,\"\",5,\"\",5,\"\",33,\"\",5,\"\",6,\"\"],[\"9b41\",\"\",6,\"\",8],[\"9b61\",\"\",17,\"\",7],[\"9b81\",\"\",25,\"\",4,\"\",5,\"\",50,\"\",22,\"\"],[\"9c41\",\"\",4,\"\",5,\"\",5],[\"9c61\",\"\",8,\"\",6,\"\",9],[\"9c81\",\"\",8,\"\",6,\"\",6,\"\",9,\"\",26,\"\",6,\"\",5,\"\",18,\"\",6,\"\",12],[\"9d41\",\"\",13,\"\",8],[\"9d61\",\"\",25],[\"9d81\",\"\",8,\"\",5,\"\",9,\"\",6,\"\",10,\"\",6,\"\",5,\"\",6,\"\",5,\"\"],[\"9e41\",\"\",7,\"\",9,\"\"],[\"9e61\",\"\",4,\"\",6,\"\"],[\"9e81\",\"\",6,\"\",6,\"\",6,\"\",5,\"\",10,\"\",5,\"\",6,\"\",5,\"\",6,\"\"],[\"9f41\",\"\",5,\"\",4,\"\",5,\"\"],[\"9f61\",\"\",6,\"\",5,\"\"],[\"9f81\",\"\",4,\"\",5,\"\",6,\"\",5,\"\",6,\"\",4,\"\",6,\"\",7,\"\",4,\"\",4,\"\"],[\"a041\",\"\",5,\"\",6,\"\"],[\"a061\",\"\",5,\"\",13],[\"a081\",\"\",4,\"\",4,\"\",4,\"\",6,\"\",5,\"\",6,\"\",5,\"\",26,\"\",4,\"\",5,\"\",7,\"\"],[\"a141\",\"\",18,\"\"],[\"a161\",\"\",6,\"\",5,\"\"],[\"a181\",\"\",14,\"\",5,\"\",4,\"\",9,\"\"],[\"a241\",\"\",5,\"\",18],[\"a261\",\"\",6,\"\",18],[\"a281\",\"\",7,\"\",6,\"\",7,\"\"],[\"a341\",\"\",6,\"\",10,\"\"],[\"a361\",\"\",6,\"\",16],[\"a381\",\"\",16,\"\",4,\"\",58,\"\",32,\"\"],[\"a441\",\"\",5,\"\"],[\"a461\",\"\",5,\"\",12],[\"a481\",\"\",28,\"\",93],[\"a541\",\"\",4,\"\",6,\"\",5,\"\"],[\"a561\",\"\",17,\"\",5,\"\"],[\"a581\",\"\",16,\"\",14,\"\",9],[\"a5b0\",\"\",9],[\"a5c1\",\"\",16,\"\",6],[\"a5e1\",\"\",16,\"\",6],[\"a641\",\"\",19,\"\"],[\"a661\",\"\",5,\"\",5,\"\",6],[\"a681\",\"\",6,\"\",18,\"\",7],[\"a741\",\"\",4,\"\",6,\"\",7],[\"a761\",\"\",22,\"\"],[\"a781\",\"\",6,\"\",5,\"\",7,\"\",9,\"\",9,\"\",4,\"\",5,\"\",4,\"\"],[\"a841\",\"\",10,\"\",14],[\"a861\",\"\",18,\"\",6],[\"a881\",\"\",19,\"\",11,\"\"],[\"a8a6\",\"\"],[\"a8a8\",\"\"],[\"a8b1\",\"\",27,\"\",25,\"\",14,\"\"],[\"a941\",\"\",14,\"\",10],[\"a961\",\"\",18],[\"a981\",\"\",14,\"\",6,\"\",27,\"\",25,\"\",14,\"\"],[\"aa41\",\"\",6,\"\",4,\"\"],[\"aa61\",\"\",4,\"\",5,\"\",6,\"\"],[\"aa81\",\"\",29,\"\",82],[\"ab41\",\"\",6,\"\",5,\"\"],[\"ab61\",\"\",6,\"\",5,\"\",5],[\"ab81\",\"\",8,\"\",6,\"\",12,\"\",85],[\"ac41\",\"\",5,\"\",6,\"\"],[\"ac61\",\"\",11,\"\",4],[\"ac81\",\"\",28,\"\",5,\"\",25],[\"acd1\",\"\",5,\"\",25],[\"ad41\",\"\",6,\"\",5,\"\",7],[\"ad61\",\"\",6,\"\",10,\"\"],[\"ad81\",\"\",5,\"\",18,\"\"],[\"ae41\",\"\",5,\"\",16],[\"ae61\",\"\",5,\"\",6,\"\",4],[\"ae81\",\"\",6,\"\",5,\"\"],[\"af41\",\"\",19],[\"af61\",\"\",13,\"\",5,\"\"],[\"af81\",\"\",5,\"\",6,\"\",5,\"\"],[\"b041\",\"\",5,\"\",5,\"\",12],[\"b061\",\"\",5,\"\",19],[\"b081\",\"\",13,\"\",6,\"\",5,\"\",7,\"\",4,\"\"],[\"b141\",\"\",6,\"\",5,\"\"],[\"b161\",\"\",6,\"\",5,\"\",11],[\"b181\",\"\",14,\"\",6,\"\"],[\"b241\",\"\",6,\"\",5,\"\"],[\"b261\",\"\",18,\"\",5,\"\"],[\"b281\",\"\",5,\"\",18,\"\",6,\"\"],[\"b341\",\"\",19,\"\"],[\"b361\",\"\",5,\"\",5,\"\",5],[\"b381\",\"\",5,\"\",5,\"\",19,\"\",4,\"\"],[\"b441\",\"\",5,\"\",6,\"\",5],[\"b461\",\"\",6,\"\",10,\"\"],[\"b481\",\"\",6,\"\",18,\"\",4,\"\",4,\"\"],[\"b541\",\"\",14,\"\",5],[\"b561\",\"\",5,\"\",5,\"\",4],[\"b581\",\"\",6,\"\",5,\"\",11,\"\"],[\"b641\",\"\",7,\"\",17],[\"b661\",\"\",15,\"\"],[\"b681\",\"\",5,\"\",6,\"\",5,\"\"],[\"b741\",\"\",13,\"\",6,\"\"],[\"b761\",\"\",20,\"\"],[\"b781\",\"\",6,\"\",14,\"\"],[\"b841\",\"\",7,\"\",17],[\"b861\",\"\",8,\"\",13],[\"b881\",\"\",5,\"\",24,\"\",4,\"\"],[\"b941\",\"\",6,\"\",5,\"\"],[\"b961\",\"\",14,\"\",6,\"\"],[\"b981\",\"\",22,\"\",4,\"\",4,\"\"],[\"ba41\",\"\",5,\"\",6,\"\"],[\"ba61\",\"\",5,\"\",4,\"\",5],[\"ba81\",\"\",6,\"\",9,\"\"],[\"bb41\",\"\",4,\"\",5,\"\",4,\"\"],[\"bb61\",\"\",6,\"\",5,\"\"],[\"bb81\",\"\",31,\"\"],[\"bc41\",\"\",17,\"\"],[\"bc61\",\"\",5,\"\",6,\"\"],[\"bc81\",\"\",4,\"\",6,\"\",5,\"\",5,\"\",4,\"\"],[\"bd41\",\"\",7,\"\",7,\"\"],[\"bd61\",\"\",5,\"\",13],[\"bd81\",\"\",5,\"\",25,\"\"],[\"be41\",\"\",7,\"\",14],[\"be61\",\"\",7,\"\",7,\"\"],[\"be81\",\"\",4,\"\",4,\"\",5,\"\",8,\"\",6,\"\"],[\"bf41\",\"\",10,\"\",14],[\"bf61\",\"\",18,\"\"],[\"bf81\",\"\",5,\"\",7,\"\",6,\"\",5,\"\"],[\"c041\",\"\",5,\"\",6,\"\",5],[\"c061\",\"\",25],[\"c081\",\"\",6,\"\",5,\"\",7,\"\"],[\"c141\",\"\",5,\"\",6,\"\"],[\"c161\",\"\",19,\"\"],[\"c181\",\"\",31,\"\"],[\"c241\",\"\",4,\"\",5,\"\"],[\"c261\",\"\",4,\"\",5,\"\",6,\"\"],[\"c281\",\"\",5,\"\",7,\"\",9,\"\"],[\"c341\",\"\",4],[\"c361\",\"\",4,\"\",5,\"\",11],[\"c381\",\"\",5,\"\",7,\"\",5,\"\"],[\"c441\",\"\",7,\"\",7,\"\"],[\"c461\",\"\",5,\"\",4],[\"c481\",\"\",5,\"\",11,\"\"],[\"c541\",\"\",6,\"\",5,\"\"],[\"c561\",\"\",6,\"\",5,\"\",4],[\"c581\",\"\",6,\"\",5,\"\"],[\"c641\",\"\",6,\"\",5],[\"c6a1\",\"\"],[\"c7a1\",\"\"],[\"c8a1\",\"\"],[\"caa1\",\"\"],[\"cba1\",\"\"],[\"cca1\",\"\"],[\"cda1\",\"\"],[\"cea1\",\"\"],[\"cfa1\",\"\"],[\"d0a1\",\"\"],[\"d1a1\",\"\",5,\"\",4,\"\"],[\"d2a1\",\"\",4,\"\",5,\"\",10,\"\",7,\"\",5,\"\"],[\"d3a1\",\"\"],[\"d4a1\",\"\"],[\"d5a1\",\"\"],[\"d6a1\",\"\"],[\"d7a1\",\"\"],[\"d8a1\",\"\"],[\"d9a1\",\"\"],[\"daa1\",\"\"],[\"dba1\",\"\"],[\"dca1\",\"\"],[\"dda1\",\"\"],[\"dea1\",\"\"],[\"dfa1\",\"\"],[\"e0a1\",\"\"],[\"e1a1\",\"\"],[\"e2a1\",\"\"],[\"e3a1\",\"\"],[\"e4a1\",\"\"],[\"e5a1\",\"\"],[\"e6a1\",\"\"],[\"e7a1\",\"\"],[\"e8a1\",\"\"],[\"e9a1\",\"\"],[\"eaa1\",\"\"],[\"eba1\",\"\"],[\"eca1\",\"\"],[\"eda1\",\"\"],[\"eea1\",\"\"],[\"efa1\",\"\"],[\"f0a1\",\"\"],[\"f1a1\",\"\"],[\"f2a1\",\"\"],[\"f3a1\",\"\"],[\"f4a1\",\"\"],[\"f5a1\",\"\"],[\"f6a1\",\"\"],[\"f7a1\",\"\"],[\"f8a1\",\"\"],[\"f9a1\",\"\"],[\"faa1\",\"\"],[\"fba1\",\"\"],[\"fca1\",\"\"],[\"fda1\",\"\"]]");
const require$$6 = /* @__PURE__ */ JSON.parse("[[\"0\",\"\\u0000\",127],[\"a140\",\"\"],[\"a1a1\",\"\",4,\"\"],[\"a240\",\"\",7,\"\"],[\"a2a1\",\"\",9,\"\",9,\"\",8,\"\",25,\"\",21],[\"a340\",\"\",16,\"\",6,\"\",16,\"\",6,\"\",10],[\"a3a1\",\"\",25,\"\"],[\"a3e1\",\"\"],[\"a440\",\"\"],[\"a4a1\",\"\"],[\"a540\",\"\"],[\"a5a1\",\"\"],[\"a640\",\"\"],[\"a6a1\",\"\"],[\"a740\",\"\"],[\"a7a1\",\"\"],[\"a840\",\"\"],[\"a8a1\",\"\"],[\"a940\",\"\"],[\"a9a1\",\"\"],[\"aa40\",\"\"],[\"aaa1\",\"\"],[\"ab40\",\"\"],[\"aba1\",\"\"],[\"ac40\",\"\"],[\"aca1\",\"\"],[\"ad40\",\"\"],[\"ada1\",\"\"],[\"ae40\",\"\"],[\"aea1\",\"\"],[\"af40\",\"\"],[\"afa1\",\"\"],[\"b040\",\"\"],[\"b0a1\",\"\"],[\"b140\",\"\"],[\"b1a1\",\"\"],[\"b240\",\"\"],[\"b2a1\",\"\"],[\"b340\",\"\"],[\"b3a1\",\"\"],[\"b440\",\"\"],[\"b4a1\",\"\"],[\"b540\",\"\"],[\"b5a1\",\"\"],[\"b640\",\"\"],[\"b6a1\",\"\"],[\"b740\",\"\"],[\"b7a1\",\"\"],[\"b840\",\"\"],[\"b8a1\",\"\"],[\"b940\",\"\"],[\"b9a1\",\"\"],[\"ba40\",\"\"],[\"baa1\",\"\"],[\"bb40\",\"\"],[\"bba1\",\"\"],[\"bc40\",\"\"],[\"bca1\",\"\"],[\"bd40\",\"\"],[\"bda1\",\"\"],[\"be40\",\"\"],[\"bea1\",\"\"],[\"bf40\",\"\"],[\"bfa1\",\"\"],[\"c040\",\"\"],[\"c0a1\",\"\"],[\"c140\",\"\"],[\"c1a1\",\"\"],[\"c240\",\"\"],[\"c2a1\",\"\"],[\"c340\",\"\"],[\"c3a1\",\"\"],[\"c440\",\"\"],[\"c4a1\",\"\"],[\"c540\",\"\"],[\"c5a1\",\"\"],[\"c640\",\"\"],[\"c940\",\"\"],[\"c9a1\",\"\"],[\"ca40\",\"\"],[\"caa1\",\"\"],[\"cb40\",\"\"],[\"cba1\",\"\"],[\"cc40\",\"\"],[\"cca1\",\"\"],[\"cd40\",\"\"],[\"cda1\",\"\"],[\"ce40\",\"\"],[\"cea1\",\"\"],[\"cf40\",\"\"],[\"cfa1\",\"\"],[\"d040\",\"\"],[\"d0a1\",\"\"],[\"d140\",\"\"],[\"d1a1\",\"\"],[\"d240\",\"\"],[\"d2a1\",\"\"],[\"d340\",\"\"],[\"d3a1\",\"\"],[\"d440\",\"\"],[\"d4a1\",\"\"],[\"d540\",\"\"],[\"d5a1\",\"\"],[\"d640\",\"\"],[\"d6a1\",\"\"],[\"d740\",\"\"],[\"d7a1\",\"\"],[\"d840\",\"\"],[\"d8a1\",\"\"],[\"d940\",\"\"],[\"d9a1\",\"\"],[\"da40\",\"\"],[\"daa1\",\"\"],[\"db40\",\"\"],[\"dba1\",\"\"],[\"dc40\",\"\"],[\"dca1\",\"\"],[\"dd40\",\"\"],[\"dda1\",\"\"],[\"de40\",\"\"],[\"dea1\",\"\"],[\"df40\",\"\"],[\"dfa1\",\"\"],[\"e040\",\"\"],[\"e0a1\",\"\"],[\"e140\",\"\"],[\"e1a1\",\"\"],[\"e240\",\"\"],[\"e2a1\",\"\"],[\"e340\",\"\"],[\"e3a1\",\"\"],[\"e440\",\"\"],[\"e4a1\",\"\"],[\"e540\",\"\"],[\"e5a1\",\"\"],[\"e640\",\"\"],[\"e6a1\",\"\"],[\"e740\",\"\"],[\"e7a1\",\"\"],[\"e840\",\"\"],[\"e8a1\",\"\"],[\"e940\",\"\"],[\"e9a1\",\"\"],[\"ea40\",\"\"],[\"eaa1\",\"\"],[\"eb40\",\"\"],[\"eba1\",\"\"],[\"ec40\",\"\"],[\"eca1\",\"\"],[\"ed40\",\"\"],[\"eda1\",\"\"],[\"ee40\",\"\"],[\"eea1\",\"\"],[\"ef40\",\"\"],[\"efa1\",\"\"],[\"f040\",\"\"],[\"f0a1\",\"\"],[\"f140\",\"\"],[\"f1a1\",\"\"],[\"f240\",\"\"],[\"f2a1\",\"\"],[\"f340\",\"\"],[\"f3a1\",\"\"],[\"f440\",\"\"],[\"f4a1\",\"\"],[\"f540\",\"\"],[\"f5a1\",\"\"],[\"f640\",\"\"],[\"f6a1\",\"\"],[\"f740\",\"\"],[\"f7a1\",\"\"],[\"f840\",\"\"],[\"f8a1\",\"\"],[\"f940\",\"\"],[\"f9a1\",\"\"]]");
const require$$7 = [
	["8740", ""],
	["8767", ""],
	["87a1", ""],
	[
		"8840",
		"",
		4,
		""
	],
	["88a1", ""],
	["8940", ""],
	["8943", ""],
	["8946", ""],
	["894c", ""],
	["89a1", ""],
	["89ab", ""],
	["89b0", ""],
	["89b5", ""],
	["89c1", ""],
	["89c5", ""],
	["8a40", ""],
	["8a43", ""],
	["8a64", ""],
	["8a76", ""],
	["8aa1", ""],
	["8aac", ""],
	["8ab2", ""],
	["8abb", ""],
	["8ac9", ""],
	["8ace", ""],
	["8adf", ""],
	["8af6", ""],
	["8b40", ""],
	["8b55", ""],
	["8ba1", ""],
	["8bde", ""],
	["8c40", ""],
	["8ca1", ""],
	["8ca7", ""],
	["8cc9", ""],
	["8cce", ""],
	["8ce6", ""],
	["8d40", ""],
	["8d42", ""],
	["8da1", ""],
	["8e40", ""],
	["8ea1", ""],
	["8f40", ""],
	["8fa1", ""],
	["9040", ""],
	["90a1", ""],
	["9140", ""],
	["91a1", ""],
	["9240", ""],
	["92a1", ""],
	["9340", ""],
	["93a1", ""],
	["9440", ""],
	["94a1", ""],
	["9540", ""],
	["95a1", ""],
	["9640", ""],
	["96a1", ""],
	["9740", ""],
	["97a1", ""],
	["9840", ""],
	["98a1", ""],
	["9940", ""],
	["99a1", ""],
	["9a40", ""],
	["9aa1", ""],
	["9b40", ""],
	["9b62", ""],
	["9ba1", ""],
	["9c40", ""],
	["9ca1", ""],
	["9d40", ""],
	["9da1", ""],
	["9e40", ""],
	["9ea1", ""],
	["9ead", ""],
	["9ec5", ""],
	["9ef5", ""],
	["9f40", ""],
	["9f4f", ""],
	["9fa1", ""],
	["9fae", ""],
	["9fb2", ""],
	["9fc1", ""],
	["9fc9", ""],
	["9fdb", ""],
	["9fe7", ""],
	["9feb", ""],
	["9ff0", ""],
	["a040", ""],
	["a055", ""],
	["a058", ""],
	["a05b", ""],
	["a063", ""],
	["a073", ""],
	["a0a1", ""],
	["a0a6", ""],
	["a0ae", ""],
	["a0b0", ""],
	["a0d4", ""],
	["a0e2", ""],
	[
		"a3c0",
		"",
		31,
		""
	],
	[
		"c6a1",
		"",
		9,
		"",
		9,
		"",
		9,
		"",
		23
	],
	[
		"c740",
		"",
		58,
		""
	],
	[
		"c7a1",
		"",
		81,
		"",
		5,
		"",
		4
	],
	[
		"c840",
		"",
		26,
		"",
		25,
		""
	],
	["c8a1", ""],
	["c8cd", ""],
	["c8f5", ""],
	["f9fe", ""],
	["fa40", ""],
	["faa1", ""],
	["fb40", ""],
	["fba1", ""],
	["fc40", ""],
	["fca1", ""],
	["fd40", ""],
	["fda1", ""],
	["fe40", ""],
	["fea1", ""]
];
var dbcsData;
var hasRequiredDbcsData;
function requireDbcsData() {
	if (hasRequiredDbcsData) return dbcsData;
	hasRequiredDbcsData = 1;
	dbcsData = {
		"shiftjis": {
			type: "_dbcs",
			table: function() {
				return require$$0$2;
			},
			encodeAdd: {
				"": 92,
				"": 126
			},
			encodeSkipVals: [{
				from: 60736,
				to: 63808
			}]
		},
		"csshiftjis": "shiftjis",
		"mskanji": "shiftjis",
		"sjis": "shiftjis",
		"windows31j": "shiftjis",
		"ms31j": "shiftjis",
		"xsjis": "shiftjis",
		"windows932": "shiftjis",
		"ms932": "shiftjis",
		"932": "shiftjis",
		"cp932": "shiftjis",
		"eucjp": {
			type: "_dbcs",
			table: function() {
				return require$$1;
			},
			encodeAdd: {
				"": 92,
				"": 126
			}
		},
		"gb2312": "cp936",
		"gb231280": "cp936",
		"gb23121980": "cp936",
		"csgb2312": "cp936",
		"csiso58gb231280": "cp936",
		"euccn": "cp936",
		"windows936": "cp936",
		"ms936": "cp936",
		"936": "cp936",
		"cp936": {
			type: "_dbcs",
			table: function() {
				return require$$2$1;
			}
		},
		"gbk": {
			type: "_dbcs",
			table: function() {
				return require$$2$1.concat(require$$3);
			}
		},
		"xgbk": "gbk",
		"isoir58": "gbk",
		"gb18030": {
			type: "_dbcs",
			table: function() {
				return require$$2$1.concat(require$$3);
			},
			gb18030: function() {
				return require$$4;
			},
			encodeSkipVals: [128],
			encodeAdd: { "": 41699 }
		},
		"chinese": "gb18030",
		"windows949": "cp949",
		"ms949": "cp949",
		"949": "cp949",
		"cp949": {
			type: "_dbcs",
			table: function() {
				return require$$5$1;
			}
		},
		"cseuckr": "cp949",
		"csksc56011987": "cp949",
		"euckr": "cp949",
		"isoir149": "cp949",
		"korean": "cp949",
		"ksc56011987": "cp949",
		"ksc56011989": "cp949",
		"ksc5601": "cp949",
		"windows950": "cp950",
		"ms950": "cp950",
		"950": "cp950",
		"cp950": {
			type: "_dbcs",
			table: function() {
				return require$$6;
			}
		},
		"big5": "big5hkscs",
		"big5hkscs": {
			type: "_dbcs",
			table: function() {
				return require$$6.concat(require$$7);
			},
			encodeSkipVals: [
				36457,
				36463,
				36478,
				36523,
				36532,
				36557,
				36560,
				36695,
				36713,
				36718,
				36811,
				36862,
				36973,
				36986,
				37060,
				37084,
				37105,
				37311,
				37551,
				37552,
				37553,
				37554,
				37585,
				37959,
				38090,
				38361,
				38652,
				39285,
				39798,
				39800,
				39803,
				39878,
				39902,
				39916,
				39926,
				40002,
				40019,
				40034,
				40040,
				40043,
				40055,
				40124,
				40125,
				40144,
				40279,
				40282,
				40388,
				40431,
				40443,
				40617,
				40687,
				40701,
				40800,
				40907,
				41079,
				41180,
				41183,
				36812,
				37576,
				38468,
				38637,
				41636,
				41637,
				41639,
				41638,
				41676,
				41678
			]
		},
		"cnbig5": "big5hkscs",
		"csbig5": "big5hkscs",
		"xxbig5": "big5hkscs"
	};
	return dbcsData;
}
var hasRequiredEncodings;
function requireEncodings() {
	if (hasRequiredEncodings) return encodings;
	hasRequiredEncodings = 1;
	(function(exports$1) {
		var modules = [
			requireInternal(),
			requireUtf32(),
			requireUtf16(),
			requireUtf7(),
			requireSbcsCodec(),
			requireSbcsData(),
			requireSbcsDataGenerated(),
			requireDbcsCodec(),
			requireDbcsData()
		];
		for (var i = 0; i < modules.length; i++) {
			var module$1 = modules[i];
			for (var enc in module$1) if (Object.prototype.hasOwnProperty.call(module$1, enc)) exports$1[enc] = module$1[enc];
		}
	})(encodings);
	return encodings;
}
var streams;
var hasRequiredStreams;
function requireStreams() {
	if (hasRequiredStreams) return streams;
	hasRequiredStreams = 1;
	var Buffer2 = requireSafer().Buffer;
	streams = function(stream_module) {
		var Transform = stream_module.Transform;
		function IconvLiteEncoderStream(conv, options) {
			this.conv = conv;
			options = options || {};
			options.decodeStrings = false;
			Transform.call(this, options);
		}
		IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, { constructor: { value: IconvLiteEncoderStream } });
		IconvLiteEncoderStream.prototype._transform = function(chunk, encoding2, done) {
			if (typeof chunk != "string") return done(/* @__PURE__ */ new Error("Iconv encoding stream needs strings as its input."));
			try {
				var res = this.conv.write(chunk);
				if (res && res.length) this.push(res);
				done();
			} catch (e) {
				done(e);
			}
		};
		IconvLiteEncoderStream.prototype._flush = function(done) {
			try {
				var res = this.conv.end();
				if (res && res.length) this.push(res);
				done();
			} catch (e) {
				done(e);
			}
		};
		IconvLiteEncoderStream.prototype.collect = function(cb) {
			var chunks = [];
			this.on("error", cb);
			this.on("data", function(chunk) {
				chunks.push(chunk);
			});
			this.on("end", function() {
				cb(null, Buffer2.concat(chunks));
			});
			return this;
		};
		function IconvLiteDecoderStream(conv, options) {
			this.conv = conv;
			options = options || {};
			options.encoding = this.encoding = "utf8";
			Transform.call(this, options);
		}
		IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, { constructor: { value: IconvLiteDecoderStream } });
		IconvLiteDecoderStream.prototype._transform = function(chunk, encoding2, done) {
			if (!Buffer2.isBuffer(chunk) && !(chunk instanceof Uint8Array)) return done(/* @__PURE__ */ new Error("Iconv decoding stream needs buffers as its input."));
			try {
				var res = this.conv.write(chunk);
				if (res && res.length) this.push(res, this.encoding);
				done();
			} catch (e) {
				done(e);
			}
		};
		IconvLiteDecoderStream.prototype._flush = function(done) {
			try {
				var res = this.conv.end();
				if (res && res.length) this.push(res, this.encoding);
				done();
			} catch (e) {
				done(e);
			}
		};
		IconvLiteDecoderStream.prototype.collect = function(cb) {
			var res = "";
			this.on("error", cb);
			this.on("data", function(chunk) {
				res += chunk;
			});
			this.on("end", function() {
				cb(null, res);
			});
			return this;
		};
		return {
			IconvLiteEncoderStream,
			IconvLiteDecoderStream
		};
	};
	return streams;
}
var hasRequiredLib$1;
function requireLib$1() {
	if (hasRequiredLib$1) return lib$1.exports;
	hasRequiredLib$1 = 1;
	(function(module$1) {
		var Buffer2 = requireSafer().Buffer;
		var bomHandling2 = requireBomHandling(), iconv = module$1.exports;
		iconv.encodings = null;
		iconv.defaultCharUnicode = "";
		iconv.defaultCharSingleByte = "?";
		iconv.encode = function encode$4(str, encoding2, options) {
			str = "" + (str || "");
			var encoder = iconv.getEncoder(encoding2, options);
			var res = encoder.write(str);
			var trail = encoder.end();
			return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
		};
		iconv.decode = function decode$2(buf, encoding2, options) {
			if (typeof buf === "string") {
				if (!iconv.skipDecodeWarning) {
					console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
					iconv.skipDecodeWarning = true;
				}
				buf = Buffer2.from("" + (buf || ""), "binary");
			}
			var decoder = iconv.getDecoder(encoding2, options);
			var res = decoder.write(buf);
			var trail = decoder.end();
			return trail ? res + trail : res;
		};
		iconv.encodingExists = function encodingExists(enc) {
			try {
				iconv.getCodec(enc);
				return true;
			} catch (e) {
				return false;
			}
		};
		iconv.toEncoding = iconv.encode;
		iconv.fromEncoding = iconv.decode;
		iconv._codecDataCache = {};
		iconv.getCodec = function getCodec(encoding2) {
			if (!iconv.encodings) iconv.encodings = requireEncodings();
			var enc = iconv._canonicalizeEncoding(encoding2);
			var codecOptions = {};
			while (true) {
				var codec = iconv._codecDataCache[enc];
				if (codec) return codec;
				var codecDef = iconv.encodings[enc];
				switch (typeof codecDef) {
					case "string":
						enc = codecDef;
						break;
					case "object":
						for (var key in codecDef) codecOptions[key] = codecDef[key];
						if (!codecOptions.encodingName) codecOptions.encodingName = enc;
						enc = codecDef.type;
						break;
					case "function":
						if (!codecOptions.encodingName) codecOptions.encodingName = enc;
						codec = new codecDef(codecOptions, iconv);
						iconv._codecDataCache[codecOptions.encodingName] = codec;
						return codec;
					default: throw new Error("Encoding not recognized: '" + encoding2 + "' (searched as: '" + enc + "')");
				}
			}
		};
		iconv._canonicalizeEncoding = function(encoding2) {
			return ("" + encoding2).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
		};
		iconv.getEncoder = function getEncoder(encoding2, options) {
			var codec = iconv.getCodec(encoding2), encoder = new codec.encoder(options, codec);
			if (codec.bomAware && options && options.addBOM) encoder = new bomHandling2.PrependBOM(encoder, options);
			return encoder;
		};
		iconv.getDecoder = function getDecoder(encoding2, options) {
			var codec = iconv.getCodec(encoding2), decoder = new codec.decoder(options, codec);
			if (codec.bomAware && !(options && options.stripBOM === false)) decoder = new bomHandling2.StripBOM(decoder, options);
			return decoder;
		};
		iconv.enableStreamingAPI = function enableStreamingAPI(stream_module2) {
			if (iconv.supportsStreams) return;
			var streams2 = requireStreams()(stream_module2);
			iconv.IconvLiteEncoderStream = streams2.IconvLiteEncoderStream;
			iconv.IconvLiteDecoderStream = streams2.IconvLiteDecoderStream;
			iconv.encodeStream = function encodeStream(encoding2, options) {
				return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding2, options), options);
			};
			iconv.decodeStream = function decodeStream(encoding2, options) {
				return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding2, options), options);
			};
			iconv.supportsStreams = true;
		};
		var stream_module;
		try {
			stream_module = __require("stream");
		} catch (e) {}
		if (stream_module && stream_module.Transform) iconv.enableStreamingAPI(stream_module);
		else iconv.encodeStream = iconv.decodeStream = function() {
			throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
		};
	})(lib$1);
	return lib$1.exports;
}
/*!
* unpipe
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var unpipe_1;
var hasRequiredUnpipe;
function requireUnpipe() {
	if (hasRequiredUnpipe) return unpipe_1;
	hasRequiredUnpipe = 1;
	unpipe_1 = unpipe;
	function hasPipeDataListeners(stream) {
		var listeners = stream.listeners("data");
		for (var i = 0; i < listeners.length; i++) if (listeners[i].name === "ondata") return true;
		return false;
	}
	function unpipe(stream) {
		if (!stream) throw new TypeError("argument stream is required");
		if (typeof stream.unpipe === "function") {
			stream.unpipe();
			return;
		}
		if (!hasPipeDataListeners(stream)) return;
		var listener;
		var listeners = stream.listeners("close");
		for (var i = 0; i < listeners.length; i++) {
			listener = listeners[i];
			if (listener.name !== "cleanup" && listener.name !== "onclose") continue;
			listener.call(stream);
		}
	}
	return unpipe_1;
}
/*!
* raw-body
* Copyright(c) 2013-2014 Jonathan Ong
* Copyright(c) 2014-2022 Douglas Christopher Wilson
* MIT Licensed
*/
var rawBody;
var hasRequiredRawBody;
function requireRawBody() {
	if (hasRequiredRawBody) return rawBody;
	hasRequiredRawBody = 1;
	var asyncHooks = tryRequireAsyncHooks();
	var bytes2 = requireBytes();
	var createError = requireHttpErrors();
	var iconv = requireLib$1();
	var unpipe = requireUnpipe();
	rawBody = getRawBody;
	var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
	function getDecoder(encoding2) {
		if (!encoding2) return null;
		try {
			return iconv.getDecoder(encoding2);
		} catch (e) {
			if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e;
			throw createError(415, "specified encoding unsupported", {
				encoding: encoding2,
				type: "encoding.unsupported"
			});
		}
	}
	function getRawBody(stream, options, callback) {
		var done = callback;
		var opts = options || {};
		if (stream === void 0) throw new TypeError("argument stream is required");
		else if (typeof stream !== "object" || stream === null || typeof stream.on !== "function") throw new TypeError("argument stream must be a stream");
		if (options === true || typeof options === "string") opts = { encoding: options };
		if (typeof options === "function") {
			done = options;
			opts = {};
		}
		if (done !== void 0 && typeof done !== "function") throw new TypeError("argument callback must be a function");
		if (!done && !commonjsGlobal.Promise) throw new TypeError("argument callback is required");
		var encoding2 = opts.encoding !== true ? opts.encoding : "utf-8";
		var limit = bytes2.parse(opts.limit);
		var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
		if (done) return readStream$1(stream, encoding2, length, limit, wrap$1(done));
		return new Promise(function executor(resolve, reject) {
			readStream$1(stream, encoding2, length, limit, function onRead(err, buf) {
				if (err) return reject(err);
				resolve(buf);
			});
		});
	}
	function halt(stream) {
		unpipe(stream);
		if (typeof stream.pause === "function") stream.pause();
	}
	function readStream$1(stream, encoding2, length, limit, callback) {
		var complete = false;
		var sync = true;
		if (limit !== null && length !== null && length > limit) return done(createError(413, "request entity too large", {
			expected: length,
			length,
			limit,
			type: "entity.too.large"
		}));
		var state$1 = stream._readableState;
		if (stream._decoder || state$1 && (state$1.encoding || state$1.decoder)) return done(createError(500, "stream encoding should not be set", { type: "stream.encoding.set" }));
		if (typeof stream.readable !== "undefined" && !stream.readable) return done(createError(500, "stream is not readable", { type: "stream.not.readable" }));
		var received = 0;
		var decoder;
		try {
			decoder = getDecoder(encoding2);
		} catch (err) {
			return done(err);
		}
		var buffer$1 = decoder ? "" : [];
		stream.on("aborted", onAborted);
		stream.on("close", cleanup);
		stream.on("data", onData);
		stream.on("end", onEnd);
		stream.on("error", onEnd);
		sync = false;
		function done() {
			var args = new Array(arguments.length);
			for (var i = 0; i < args.length; i++) args[i] = arguments[i];
			complete = true;
			if (sync) process.nextTick(invokeCallback);
			else invokeCallback();
			function invokeCallback() {
				cleanup();
				if (args[0]) halt(stream);
				callback.apply(null, args);
			}
		}
		function onAborted() {
			if (complete) return;
			done(createError(400, "request aborted", {
				code: "ECONNABORTED",
				expected: length,
				length,
				received,
				type: "request.aborted"
			}));
		}
		function onData(chunk) {
			if (complete) return;
			received += chunk.length;
			if (limit !== null && received > limit) done(createError(413, "request entity too large", {
				limit,
				received,
				type: "entity.too.large"
			}));
			else if (decoder) buffer$1 += decoder.write(chunk);
			else buffer$1.push(chunk);
		}
		function onEnd(err) {
			if (complete) return;
			if (err) return done(err);
			if (length !== null && received !== length) done(createError(400, "request size did not match content length", {
				expected: length,
				length,
				received,
				type: "request.size.invalid"
			}));
			else done(null, decoder ? buffer$1 + (decoder.end() || "") : Buffer.concat(buffer$1));
		}
		function cleanup() {
			buffer$1 = null;
			stream.removeListener("aborted", onAborted);
			stream.removeListener("data", onData);
			stream.removeListener("end", onEnd);
			stream.removeListener("error", onEnd);
			stream.removeListener("close", cleanup);
		}
	}
	function tryRequireAsyncHooks() {
		try {
			return __require("async_hooks");
		} catch (e) {
			return {};
		}
	}
	function wrap$1(fn) {
		var res;
		if (asyncHooks.AsyncResource) res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
		if (!res || !res.runInAsyncScope) return fn;
		return res.runInAsyncScope.bind(res, fn, null);
	}
	return rawBody;
}
/*!
* body-parser
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var read_1;
var hasRequiredRead;
function requireRead() {
	if (hasRequiredRead) return read_1;
	hasRequiredRead = 1;
	var createError = requireHttpErrors();
	var getBody = requireRawBody();
	var iconv = requireLib$1();
	var onFinished2 = requireOnFinished();
	var zlib = require$$4$1;
	read_1 = read;
	function read(req, res, next, parse2, debug$2, options) {
		var length;
		var opts = options;
		var stream;
		var encoding2 = opts.encoding !== null ? opts.encoding : null;
		var verify = opts.verify;
		try {
			stream = contentstream(req, debug$2, opts.inflate);
			length = stream.length;
			stream.length = void 0;
		} catch (err) {
			return next(err);
		}
		opts.length = length;
		opts.encoding = verify ? null : encoding2;
		if (opts.encoding === null && encoding2 !== null && !iconv.encodingExists(encoding2)) return next(createError(415, "unsupported charset \"" + encoding2.toUpperCase() + "\"", {
			charset: encoding2.toLowerCase(),
			type: "charset.unsupported"
		}));
		debug$2("read body");
		getBody(stream, opts, function(error, body) {
			if (error) {
				var _error;
				if (error.type === "encoding.unsupported") _error = createError(415, "unsupported charset \"" + encoding2.toUpperCase() + "\"", {
					charset: encoding2.toLowerCase(),
					type: "charset.unsupported"
				});
				else _error = createError(400, error);
				if (stream !== req) {
					req.unpipe();
					stream.destroy();
				}
				dump(req, function onfinished() {
					next(createError(400, _error));
				});
				return;
			}
			if (verify) try {
				debug$2("verify body");
				verify(req, res, body, encoding2);
			} catch (err) {
				next(createError(403, err, {
					body,
					type: err.type || "entity.verify.failed"
				}));
				return;
			}
			var str = body;
			try {
				debug$2("parse body");
				str = typeof body !== "string" && encoding2 !== null ? iconv.decode(body, encoding2) : body;
				req.body = parse2(str, encoding2);
			} catch (err) {
				next(createError(400, err, {
					body: str,
					type: err.type || "entity.parse.failed"
				}));
				return;
			}
			next();
		});
	}
	function contentstream(req, debug$2, inflate) {
		var encoding2 = (req.headers["content-encoding"] || "identity").toLowerCase();
		var length = req.headers["content-length"];
		debug$2("content-encoding \"%s\"", encoding2);
		if (inflate === false && encoding2 !== "identity") throw createError(415, "content encoding unsupported", {
			encoding: encoding2,
			type: "encoding.unsupported"
		});
		if (encoding2 === "identity") {
			req.length = length;
			return req;
		}
		var stream = createDecompressionStream(encoding2, debug$2);
		req.pipe(stream);
		return stream;
	}
	function createDecompressionStream(encoding2, debug$2) {
		switch (encoding2) {
			case "deflate":
				debug$2("inflate body");
				return zlib.createInflate();
			case "gzip":
				debug$2("gunzip body");
				return zlib.createGunzip();
			case "br":
				debug$2("brotli decompress body");
				return zlib.createBrotliDecompress();
			default: throw createError(415, "unsupported content encoding \"" + encoding2 + "\"", {
				encoding: encoding2,
				type: "encoding.unsupported"
			});
		}
	}
	function dump(req, callback) {
		if (onFinished2.isFinished(req)) callback(null);
		else {
			onFinished2(req, callback);
			req.resume();
		}
	}
	return read_1;
}
var typeIs = { exports: {} };
var contentType = {};
/*!
* content-type
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var hasRequiredContentType;
function requireContentType() {
	if (hasRequiredContentType) return contentType;
	hasRequiredContentType = 1;
	var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
	var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
	var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
	var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
	var QUOTE_REGEXP = /([\\"])/g;
	var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
	contentType.format = format;
	contentType.parse = parse2;
	function format(obj) {
		if (!obj || typeof obj !== "object") throw new TypeError("argument obj is required");
		var parameters = obj.parameters;
		var type2 = obj.type;
		if (!type2 || !TYPE_REGEXP.test(type2)) throw new TypeError("invalid type");
		var string$2 = type2;
		if (parameters && typeof parameters === "object") {
			var param;
			var params = Object.keys(parameters).sort();
			for (var i = 0; i < params.length; i++) {
				param = params[i];
				if (!TOKEN_REGEXP.test(param)) throw new TypeError("invalid parameter name");
				string$2 += "; " + param + "=" + qstring(parameters[param]);
			}
		}
		return string$2;
	}
	function parse2(string$2) {
		if (!string$2) throw new TypeError("argument string is required");
		var header = typeof string$2 === "object" ? getcontenttype(string$2) : string$2;
		if (typeof header !== "string") throw new TypeError("argument string is required to be a string");
		var index2 = header.indexOf(";");
		var type2 = index2 !== -1 ? header.slice(0, index2).trim() : header.trim();
		if (!TYPE_REGEXP.test(type2)) throw new TypeError("invalid media type");
		var obj = new ContentType(type2.toLowerCase());
		if (index2 !== -1) {
			var key;
			var match;
			var value;
			PARAM_REGEXP.lastIndex = index2;
			while (match = PARAM_REGEXP.exec(header)) {
				if (match.index !== index2) throw new TypeError("invalid parameter format");
				index2 += match[0].length;
				key = match[1].toLowerCase();
				value = match[2];
				if (value.charCodeAt(0) === 34) {
					value = value.slice(1, -1);
					if (value.indexOf("\\") !== -1) value = value.replace(QESC_REGEXP, "$1");
				}
				obj.parameters[key] = value;
			}
			if (index2 !== header.length) throw new TypeError("invalid parameter format");
		}
		return obj;
	}
	function getcontenttype(obj) {
		var header;
		if (typeof obj.getHeader === "function") header = obj.getHeader("content-type");
		else if (typeof obj.headers === "object") header = obj.headers && obj.headers["content-type"];
		if (typeof header !== "string") throw new TypeError("content-type header is missing from object");
		return header;
	}
	function qstring(val) {
		var str = String(val);
		if (TOKEN_REGEXP.test(str)) return str;
		if (str.length > 0 && !TEXT_REGEXP.test(str)) throw new TypeError("invalid parameter value");
		return "\"" + str.replace(QUOTE_REGEXP, "\\$1") + "\"";
	}
	function ContentType(type2) {
		this.parameters = /* @__PURE__ */ Object.create(null);
		this.type = type2;
	}
	return contentType;
}
var mimeTypes = {};
const require$$0$1$1 = {
	"application/1d-interleaved-parityfec": { "source": "iana" },
	"application/3gpdash-qoe-report+xml": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true
	},
	"application/3gpp-ims+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/3gpphal+json": {
		"source": "iana",
		"compressible": true
	},
	"application/3gpphalforms+json": {
		"source": "iana",
		"compressible": true
	},
	"application/a2l": { "source": "iana" },
	"application/ace+cbor": { "source": "iana" },
	"application/ace+json": {
		"source": "iana",
		"compressible": true
	},
	"application/ace-groupcomm+cbor": { "source": "iana" },
	"application/ace-trl+cbor": { "source": "iana" },
	"application/activemessage": { "source": "iana" },
	"application/activity+json": {
		"source": "iana",
		"compressible": true
	},
	"application/aif+cbor": { "source": "iana" },
	"application/aif+json": {
		"source": "iana",
		"compressible": true
	},
	"application/alto-cdni+json": {
		"source": "iana",
		"compressible": true
	},
	"application/alto-cdnifilter+json": {
		"source": "iana",
		"compressible": true
	},
	"application/alto-costmap+json": {
		"source": "iana",
		"compressible": true
	},
	"application/alto-costmapfilter+json": {
		"source": "iana",
		"compressible": true
	},
	"application/alto-directory+json": {
		"source": "iana",
		"compressible": true
	},
	"application/alto-endpointcost+json": {
		"source": "iana",
		"compressible": true
	},
	"application/alto-endpointcostparams+json": {
		"source": "iana",
		"compressible": true
	},
	"application/alto-endpointprop+json": {
		"source": "iana",
		"compressible": true
	},
	"application/alto-endpointpropparams+json": {
		"source": "iana",
		"compressible": true
	},
	"application/alto-error+json": {
		"source": "iana",
		"compressible": true
	},
	"application/alto-networkmap+json": {
		"source": "iana",
		"compressible": true
	},
	"application/alto-networkmapfilter+json": {
		"source": "iana",
		"compressible": true
	},
	"application/alto-propmap+json": {
		"source": "iana",
		"compressible": true
	},
	"application/alto-propmapparams+json": {
		"source": "iana",
		"compressible": true
	},
	"application/alto-tips+json": {
		"source": "iana",
		"compressible": true
	},
	"application/alto-tipsparams+json": {
		"source": "iana",
		"compressible": true
	},
	"application/alto-updatestreamcontrol+json": {
		"source": "iana",
		"compressible": true
	},
	"application/alto-updatestreamparams+json": {
		"source": "iana",
		"compressible": true
	},
	"application/aml": { "source": "iana" },
	"application/andrew-inset": {
		"source": "iana",
		"extensions": ["ez"]
	},
	"application/appinstaller": {
		"compressible": false,
		"extensions": ["appinstaller"]
	},
	"application/applefile": { "source": "iana" },
	"application/applixware": {
		"source": "apache",
		"extensions": ["aw"]
	},
	"application/appx": {
		"compressible": false,
		"extensions": ["appx"]
	},
	"application/appxbundle": {
		"compressible": false,
		"extensions": ["appxbundle"]
	},
	"application/at+jwt": { "source": "iana" },
	"application/atf": { "source": "iana" },
	"application/atfx": { "source": "iana" },
	"application/atom+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["atom"]
	},
	"application/atomcat+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["atomcat"]
	},
	"application/atomdeleted+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["atomdeleted"]
	},
	"application/atomicmail": { "source": "iana" },
	"application/atomsvc+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["atomsvc"]
	},
	"application/atsc-dwd+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["dwd"]
	},
	"application/atsc-dynamic-event-message": { "source": "iana" },
	"application/atsc-held+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["held"]
	},
	"application/atsc-rdt+json": {
		"source": "iana",
		"compressible": true
	},
	"application/atsc-rsat+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["rsat"]
	},
	"application/atxml": { "source": "iana" },
	"application/auth-policy+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/automationml-aml+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["aml"]
	},
	"application/automationml-amlx+zip": {
		"source": "iana",
		"compressible": false,
		"extensions": ["amlx"]
	},
	"application/bacnet-xdd+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/batch-smtp": { "source": "iana" },
	"application/bdoc": {
		"compressible": false,
		"extensions": ["bdoc"]
	},
	"application/beep+xml": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true
	},
	"application/bufr": { "source": "iana" },
	"application/c2pa": { "source": "iana" },
	"application/calendar+json": {
		"source": "iana",
		"compressible": true
	},
	"application/calendar+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["xcs"]
	},
	"application/call-completion": { "source": "iana" },
	"application/cals-1840": { "source": "iana" },
	"application/captive+json": {
		"source": "iana",
		"compressible": true
	},
	"application/cbor": { "source": "iana" },
	"application/cbor-seq": { "source": "iana" },
	"application/cccex": { "source": "iana" },
	"application/ccmp+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/ccxml+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["ccxml"]
	},
	"application/cda+xml": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true
	},
	"application/cdfx+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["cdfx"]
	},
	"application/cdmi-capability": {
		"source": "iana",
		"extensions": ["cdmia"]
	},
	"application/cdmi-container": {
		"source": "iana",
		"extensions": ["cdmic"]
	},
	"application/cdmi-domain": {
		"source": "iana",
		"extensions": ["cdmid"]
	},
	"application/cdmi-object": {
		"source": "iana",
		"extensions": ["cdmio"]
	},
	"application/cdmi-queue": {
		"source": "iana",
		"extensions": ["cdmiq"]
	},
	"application/cdni": { "source": "iana" },
	"application/ce+cbor": { "source": "iana" },
	"application/cea": { "source": "iana" },
	"application/cea-2018+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/cellml+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/cfw": { "source": "iana" },
	"application/cid-edhoc+cbor-seq": { "source": "iana" },
	"application/city+json": {
		"source": "iana",
		"compressible": true
	},
	"application/city+json-seq": { "source": "iana" },
	"application/clr": { "source": "iana" },
	"application/clue+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/clue_info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/cms": { "source": "iana" },
	"application/cnrp+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/coap-eap": { "source": "iana" },
	"application/coap-group+json": {
		"source": "iana",
		"compressible": true
	},
	"application/coap-payload": { "source": "iana" },
	"application/commonground": { "source": "iana" },
	"application/concise-problem-details+cbor": { "source": "iana" },
	"application/conference-info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/cose": { "source": "iana" },
	"application/cose-key": { "source": "iana" },
	"application/cose-key-set": { "source": "iana" },
	"application/cose-x509": { "source": "iana" },
	"application/cpl+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["cpl"]
	},
	"application/csrattrs": { "source": "iana" },
	"application/csta+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/cstadata+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/csvm+json": {
		"source": "iana",
		"compressible": true
	},
	"application/cu-seeme": {
		"source": "apache",
		"extensions": ["cu"]
	},
	"application/cwl": {
		"source": "iana",
		"extensions": ["cwl"]
	},
	"application/cwl+json": {
		"source": "iana",
		"compressible": true
	},
	"application/cwl+yaml": { "source": "iana" },
	"application/cwt": { "source": "iana" },
	"application/cybercash": { "source": "iana" },
	"application/dart": { "compressible": true },
	"application/dash+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["mpd"]
	},
	"application/dash-patch+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["mpp"]
	},
	"application/dashdelta": { "source": "iana" },
	"application/davmount+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["davmount"]
	},
	"application/dca-rft": { "source": "iana" },
	"application/dcd": { "source": "iana" },
	"application/dec-dx": { "source": "iana" },
	"application/dialog-info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/dicom": {
		"source": "iana",
		"extensions": ["dcm"]
	},
	"application/dicom+json": {
		"source": "iana",
		"compressible": true
	},
	"application/dicom+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/dii": { "source": "iana" },
	"application/dit": { "source": "iana" },
	"application/dns": { "source": "iana" },
	"application/dns+json": {
		"source": "iana",
		"compressible": true
	},
	"application/dns-message": { "source": "iana" },
	"application/docbook+xml": {
		"source": "apache",
		"compressible": true,
		"extensions": ["dbk"]
	},
	"application/dots+cbor": { "source": "iana" },
	"application/dpop+jwt": { "source": "iana" },
	"application/dskpp+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/dssc+der": {
		"source": "iana",
		"extensions": ["dssc"]
	},
	"application/dssc+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["xdssc"]
	},
	"application/dvcs": { "source": "iana" },
	"application/eat+cwt": { "source": "iana" },
	"application/eat+jwt": { "source": "iana" },
	"application/eat-bun+cbor": { "source": "iana" },
	"application/eat-bun+json": {
		"source": "iana",
		"compressible": true
	},
	"application/eat-ucs+cbor": { "source": "iana" },
	"application/eat-ucs+json": {
		"source": "iana",
		"compressible": true
	},
	"application/ecmascript": {
		"source": "apache",
		"compressible": true,
		"extensions": ["ecma"]
	},
	"application/edhoc+cbor-seq": { "source": "iana" },
	"application/edi-consent": { "source": "iana" },
	"application/edi-x12": {
		"source": "iana",
		"compressible": false
	},
	"application/edifact": {
		"source": "iana",
		"compressible": false
	},
	"application/efi": { "source": "iana" },
	"application/elm+json": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true
	},
	"application/elm+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/emergencycalldata.cap+xml": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true
	},
	"application/emergencycalldata.comment+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/emergencycalldata.control+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/emergencycalldata.deviceinfo+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/emergencycalldata.ecall.msd": { "source": "iana" },
	"application/emergencycalldata.legacyesn+json": {
		"source": "iana",
		"compressible": true
	},
	"application/emergencycalldata.providerinfo+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/emergencycalldata.serviceinfo+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/emergencycalldata.subscriberinfo+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/emergencycalldata.veds+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/emma+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["emma"]
	},
	"application/emotionml+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["emotionml"]
	},
	"application/encaprtp": { "source": "iana" },
	"application/entity-statement+jwt": { "source": "iana" },
	"application/epp+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/epub+zip": {
		"source": "iana",
		"compressible": false,
		"extensions": ["epub"]
	},
	"application/eshop": { "source": "iana" },
	"application/exi": {
		"source": "iana",
		"extensions": ["exi"]
	},
	"application/expect-ct-report+json": {
		"source": "iana",
		"compressible": true
	},
	"application/express": {
		"source": "iana",
		"extensions": ["exp"]
	},
	"application/fastinfoset": { "source": "iana" },
	"application/fastsoap": { "source": "iana" },
	"application/fdf": {
		"source": "iana",
		"extensions": ["fdf"]
	},
	"application/fdt+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["fdt"]
	},
	"application/fhir+json": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true
	},
	"application/fhir+xml": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true
	},
	"application/fido.trusted-apps+json": { "compressible": true },
	"application/fits": { "source": "iana" },
	"application/flexfec": { "source": "iana" },
	"application/font-sfnt": { "source": "iana" },
	"application/font-tdpfr": {
		"source": "iana",
		"extensions": ["pfr"]
	},
	"application/font-woff": {
		"source": "iana",
		"compressible": false
	},
	"application/framework-attributes+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/geo+json": {
		"source": "iana",
		"compressible": true,
		"extensions": ["geojson"]
	},
	"application/geo+json-seq": { "source": "iana" },
	"application/geopackage+sqlite3": { "source": "iana" },
	"application/geopose+json": {
		"source": "iana",
		"compressible": true
	},
	"application/geoxacml+json": {
		"source": "iana",
		"compressible": true
	},
	"application/geoxacml+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/gltf-buffer": { "source": "iana" },
	"application/gml+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["gml"]
	},
	"application/gnap-binding-jws": { "source": "iana" },
	"application/gnap-binding-jwsd": { "source": "iana" },
	"application/gnap-binding-rotation-jws": { "source": "iana" },
	"application/gnap-binding-rotation-jwsd": { "source": "iana" },
	"application/gpx+xml": {
		"source": "apache",
		"compressible": true,
		"extensions": ["gpx"]
	},
	"application/grib": { "source": "iana" },
	"application/gxf": {
		"source": "apache",
		"extensions": ["gxf"]
	},
	"application/gzip": {
		"source": "iana",
		"compressible": false,
		"extensions": ["gz"]
	},
	"application/h224": { "source": "iana" },
	"application/held+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/hjson": { "extensions": ["hjson"] },
	"application/hl7v2+xml": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true
	},
	"application/http": { "source": "iana" },
	"application/hyperstudio": {
		"source": "iana",
		"extensions": ["stk"]
	},
	"application/ibe-key-request+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/ibe-pkg-reply+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/ibe-pp-data": { "source": "iana" },
	"application/iges": { "source": "iana" },
	"application/im-iscomposing+xml": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true
	},
	"application/index": { "source": "iana" },
	"application/index.cmd": { "source": "iana" },
	"application/index.obj": { "source": "iana" },
	"application/index.response": { "source": "iana" },
	"application/index.vnd": { "source": "iana" },
	"application/inkml+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["ink", "inkml"]
	},
	"application/iotp": { "source": "iana" },
	"application/ipfix": {
		"source": "iana",
		"extensions": ["ipfix"]
	},
	"application/ipp": { "source": "iana" },
	"application/isup": { "source": "iana" },
	"application/its+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["its"]
	},
	"application/java-archive": {
		"source": "iana",
		"compressible": false,
		"extensions": [
			"jar",
			"war",
			"ear"
		]
	},
	"application/java-serialized-object": {
		"source": "apache",
		"compressible": false,
		"extensions": ["ser"]
	},
	"application/java-vm": {
		"source": "apache",
		"compressible": false,
		"extensions": ["class"]
	},
	"application/javascript": {
		"source": "apache",
		"charset": "UTF-8",
		"compressible": true,
		"extensions": ["js"]
	},
	"application/jf2feed+json": {
		"source": "iana",
		"compressible": true
	},
	"application/jose": { "source": "iana" },
	"application/jose+json": {
		"source": "iana",
		"compressible": true
	},
	"application/jrd+json": {
		"source": "iana",
		"compressible": true
	},
	"application/jscalendar+json": {
		"source": "iana",
		"compressible": true
	},
	"application/jscontact+json": {
		"source": "iana",
		"compressible": true
	},
	"application/json": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true,
		"extensions": ["json", "map"]
	},
	"application/json-patch+json": {
		"source": "iana",
		"compressible": true
	},
	"application/json-seq": { "source": "iana" },
	"application/json5": { "extensions": ["json5"] },
	"application/jsonml+json": {
		"source": "apache",
		"compressible": true,
		"extensions": ["jsonml"]
	},
	"application/jsonpath": { "source": "iana" },
	"application/jwk+json": {
		"source": "iana",
		"compressible": true
	},
	"application/jwk-set+json": {
		"source": "iana",
		"compressible": true
	},
	"application/jwk-set+jwt": { "source": "iana" },
	"application/jwt": { "source": "iana" },
	"application/kpml-request+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/kpml-response+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/ld+json": {
		"source": "iana",
		"compressible": true,
		"extensions": ["jsonld"]
	},
	"application/lgr+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["lgr"]
	},
	"application/link-format": { "source": "iana" },
	"application/linkset": { "source": "iana" },
	"application/linkset+json": {
		"source": "iana",
		"compressible": true
	},
	"application/load-control+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/logout+jwt": { "source": "iana" },
	"application/lost+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["lostxml"]
	},
	"application/lostsync+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/lpf+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/lxf": { "source": "iana" },
	"application/mac-binhex40": {
		"source": "iana",
		"extensions": ["hqx"]
	},
	"application/mac-compactpro": {
		"source": "apache",
		"extensions": ["cpt"]
	},
	"application/macwriteii": { "source": "iana" },
	"application/mads+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["mads"]
	},
	"application/manifest+json": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true,
		"extensions": ["webmanifest"]
	},
	"application/marc": {
		"source": "iana",
		"extensions": ["mrc"]
	},
	"application/marcxml+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["mrcx"]
	},
	"application/mathematica": {
		"source": "iana",
		"extensions": [
			"ma",
			"nb",
			"mb"
		]
	},
	"application/mathml+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["mathml"]
	},
	"application/mathml-content+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/mathml-presentation+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/mbms-associated-procedure-description+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/mbms-deregister+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/mbms-envelope+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/mbms-msk+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/mbms-msk-response+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/mbms-protection-description+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/mbms-reception-report+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/mbms-register+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/mbms-register-response+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/mbms-schedule+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/mbms-user-service-description+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/mbox": {
		"source": "iana",
		"extensions": ["mbox"]
	},
	"application/media-policy-dataset+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["mpf"]
	},
	"application/media_control+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/mediaservercontrol+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["mscml"]
	},
	"application/merge-patch+json": {
		"source": "iana",
		"compressible": true
	},
	"application/metalink+xml": {
		"source": "apache",
		"compressible": true,
		"extensions": ["metalink"]
	},
	"application/metalink4+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["meta4"]
	},
	"application/mets+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["mets"]
	},
	"application/mf4": { "source": "iana" },
	"application/mikey": { "source": "iana" },
	"application/mipc": { "source": "iana" },
	"application/missing-blocks+cbor-seq": { "source": "iana" },
	"application/mmt-aei+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["maei"]
	},
	"application/mmt-usd+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["musd"]
	},
	"application/mods+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["mods"]
	},
	"application/moss-keys": { "source": "iana" },
	"application/moss-signature": { "source": "iana" },
	"application/mosskey-data": { "source": "iana" },
	"application/mosskey-request": { "source": "iana" },
	"application/mp21": {
		"source": "iana",
		"extensions": ["m21", "mp21"]
	},
	"application/mp4": {
		"source": "iana",
		"extensions": [
			"mp4",
			"mpg4",
			"mp4s",
			"m4p"
		]
	},
	"application/mpeg4-generic": { "source": "iana" },
	"application/mpeg4-iod": { "source": "iana" },
	"application/mpeg4-iod-xmt": { "source": "iana" },
	"application/mrb-consumer+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/mrb-publish+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/msc-ivr+xml": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true
	},
	"application/msc-mixer+xml": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true
	},
	"application/msix": {
		"compressible": false,
		"extensions": ["msix"]
	},
	"application/msixbundle": {
		"compressible": false,
		"extensions": ["msixbundle"]
	},
	"application/msword": {
		"source": "iana",
		"compressible": false,
		"extensions": ["doc", "dot"]
	},
	"application/mud+json": {
		"source": "iana",
		"compressible": true
	},
	"application/multipart-core": { "source": "iana" },
	"application/mxf": {
		"source": "iana",
		"extensions": ["mxf"]
	},
	"application/n-quads": {
		"source": "iana",
		"extensions": ["nq"]
	},
	"application/n-triples": {
		"source": "iana",
		"extensions": ["nt"]
	},
	"application/nasdata": { "source": "iana" },
	"application/news-checkgroups": {
		"source": "iana",
		"charset": "US-ASCII"
	},
	"application/news-groupinfo": {
		"source": "iana",
		"charset": "US-ASCII"
	},
	"application/news-transmission": { "source": "iana" },
	"application/nlsml+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/node": {
		"source": "iana",
		"extensions": ["cjs"]
	},
	"application/nss": { "source": "iana" },
	"application/oauth-authz-req+jwt": { "source": "iana" },
	"application/oblivious-dns-message": { "source": "iana" },
	"application/ocsp-request": { "source": "iana" },
	"application/ocsp-response": { "source": "iana" },
	"application/octet-stream": {
		"source": "iana",
		"compressible": true,
		"extensions": [
			"bin",
			"dms",
			"lrf",
			"mar",
			"so",
			"dist",
			"distz",
			"pkg",
			"bpk",
			"dump",
			"elc",
			"deploy",
			"exe",
			"dll",
			"deb",
			"dmg",
			"iso",
			"img",
			"msi",
			"msp",
			"msm",
			"buffer"
		]
	},
	"application/oda": {
		"source": "iana",
		"extensions": ["oda"]
	},
	"application/odm+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/odx": { "source": "iana" },
	"application/oebps-package+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["opf"]
	},
	"application/ogg": {
		"source": "iana",
		"compressible": false,
		"extensions": ["ogx"]
	},
	"application/ohttp-keys": { "source": "iana" },
	"application/omdoc+xml": {
		"source": "apache",
		"compressible": true,
		"extensions": ["omdoc"]
	},
	"application/onenote": {
		"source": "apache",
		"extensions": [
			"onetoc",
			"onetoc2",
			"onetmp",
			"onepkg",
			"one",
			"onea"
		]
	},
	"application/opc-nodeset+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/oscore": { "source": "iana" },
	"application/oxps": {
		"source": "iana",
		"extensions": ["oxps"]
	},
	"application/p21": { "source": "iana" },
	"application/p21+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/p2p-overlay+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["relo"]
	},
	"application/parityfec": { "source": "iana" },
	"application/passport": { "source": "iana" },
	"application/patch-ops-error+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["xer"]
	},
	"application/pdf": {
		"source": "iana",
		"compressible": false,
		"extensions": ["pdf"]
	},
	"application/pdx": { "source": "iana" },
	"application/pem-certificate-chain": { "source": "iana" },
	"application/pgp-encrypted": {
		"source": "iana",
		"compressible": false,
		"extensions": ["pgp"]
	},
	"application/pgp-keys": {
		"source": "iana",
		"extensions": ["asc"]
	},
	"application/pgp-signature": {
		"source": "iana",
		"extensions": ["sig", "asc"]
	},
	"application/pics-rules": {
		"source": "apache",
		"extensions": ["prf"]
	},
	"application/pidf+xml": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true
	},
	"application/pidf-diff+xml": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true
	},
	"application/pkcs10": {
		"source": "iana",
		"extensions": ["p10"]
	},
	"application/pkcs12": { "source": "iana" },
	"application/pkcs7-mime": {
		"source": "iana",
		"extensions": ["p7m", "p7c"]
	},
	"application/pkcs7-signature": {
		"source": "iana",
		"extensions": ["p7s"]
	},
	"application/pkcs8": {
		"source": "iana",
		"extensions": ["p8"]
	},
	"application/pkcs8-encrypted": { "source": "iana" },
	"application/pkix-attr-cert": {
		"source": "iana",
		"extensions": ["ac"]
	},
	"application/pkix-cert": {
		"source": "iana",
		"extensions": ["cer"]
	},
	"application/pkix-crl": {
		"source": "iana",
		"extensions": ["crl"]
	},
	"application/pkix-pkipath": {
		"source": "iana",
		"extensions": ["pkipath"]
	},
	"application/pkixcmp": {
		"source": "iana",
		"extensions": ["pki"]
	},
	"application/pls+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["pls"]
	},
	"application/poc-settings+xml": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true
	},
	"application/postscript": {
		"source": "iana",
		"compressible": true,
		"extensions": [
			"ai",
			"eps",
			"ps"
		]
	},
	"application/ppsp-tracker+json": {
		"source": "iana",
		"compressible": true
	},
	"application/private-token-issuer-directory": { "source": "iana" },
	"application/private-token-request": { "source": "iana" },
	"application/private-token-response": { "source": "iana" },
	"application/problem+json": {
		"source": "iana",
		"compressible": true
	},
	"application/problem+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/provenance+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["provx"]
	},
	"application/provided-claims+jwt": { "source": "iana" },
	"application/prs.alvestrand.titrax-sheet": { "source": "iana" },
	"application/prs.cww": {
		"source": "iana",
		"extensions": ["cww"]
	},
	"application/prs.cyn": {
		"source": "iana",
		"charset": "7-BIT"
	},
	"application/prs.hpub+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/prs.implied-document+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/prs.implied-executable": { "source": "iana" },
	"application/prs.implied-object+json": {
		"source": "iana",
		"compressible": true
	},
	"application/prs.implied-object+json-seq": { "source": "iana" },
	"application/prs.implied-object+yaml": { "source": "iana" },
	"application/prs.implied-structure": { "source": "iana" },
	"application/prs.mayfile": { "source": "iana" },
	"application/prs.nprend": { "source": "iana" },
	"application/prs.plucker": { "source": "iana" },
	"application/prs.rdf-xml-crypt": { "source": "iana" },
	"application/prs.vcfbzip2": { "source": "iana" },
	"application/prs.xsf+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["xsf"]
	},
	"application/pskc+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["pskcxml"]
	},
	"application/pvd+json": {
		"source": "iana",
		"compressible": true
	},
	"application/qsig": { "source": "iana" },
	"application/raml+yaml": {
		"compressible": true,
		"extensions": ["raml"]
	},
	"application/raptorfec": { "source": "iana" },
	"application/rdap+json": {
		"source": "iana",
		"compressible": true
	},
	"application/rdf+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["rdf", "owl"]
	},
	"application/reginfo+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["rif"]
	},
	"application/relax-ng-compact-syntax": {
		"source": "iana",
		"extensions": ["rnc"]
	},
	"application/remote-printing": { "source": "apache" },
	"application/reputon+json": {
		"source": "iana",
		"compressible": true
	},
	"application/resolve-response+jwt": { "source": "iana" },
	"application/resource-lists+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["rl"]
	},
	"application/resource-lists-diff+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["rld"]
	},
	"application/rfc+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/riscos": { "source": "iana" },
	"application/rlmi+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/rls-services+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["rs"]
	},
	"application/route-apd+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["rapd"]
	},
	"application/route-s-tsid+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["sls"]
	},
	"application/route-usd+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["rusd"]
	},
	"application/rpki-checklist": { "source": "iana" },
	"application/rpki-ghostbusters": {
		"source": "iana",
		"extensions": ["gbr"]
	},
	"application/rpki-manifest": {
		"source": "iana",
		"extensions": ["mft"]
	},
	"application/rpki-publication": { "source": "iana" },
	"application/rpki-roa": {
		"source": "iana",
		"extensions": ["roa"]
	},
	"application/rpki-signed-tal": { "source": "iana" },
	"application/rpki-updown": { "source": "iana" },
	"application/rsd+xml": {
		"source": "apache",
		"compressible": true,
		"extensions": ["rsd"]
	},
	"application/rss+xml": {
		"source": "apache",
		"compressible": true,
		"extensions": ["rss"]
	},
	"application/rtf": {
		"source": "iana",
		"compressible": true,
		"extensions": ["rtf"]
	},
	"application/rtploopback": { "source": "iana" },
	"application/rtx": { "source": "iana" },
	"application/samlassertion+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/samlmetadata+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/sarif+json": {
		"source": "iana",
		"compressible": true
	},
	"application/sarif-external-properties+json": {
		"source": "iana",
		"compressible": true
	},
	"application/sbe": { "source": "iana" },
	"application/sbml+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["sbml"]
	},
	"application/scaip+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/scim+json": {
		"source": "iana",
		"compressible": true
	},
	"application/scvp-cv-request": {
		"source": "iana",
		"extensions": ["scq"]
	},
	"application/scvp-cv-response": {
		"source": "iana",
		"extensions": ["scs"]
	},
	"application/scvp-vp-request": {
		"source": "iana",
		"extensions": ["spq"]
	},
	"application/scvp-vp-response": {
		"source": "iana",
		"extensions": ["spp"]
	},
	"application/sdp": {
		"source": "iana",
		"extensions": ["sdp"]
	},
	"application/secevent+jwt": { "source": "iana" },
	"application/senml+cbor": { "source": "iana" },
	"application/senml+json": {
		"source": "iana",
		"compressible": true
	},
	"application/senml+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["senmlx"]
	},
	"application/senml-etch+cbor": { "source": "iana" },
	"application/senml-etch+json": {
		"source": "iana",
		"compressible": true
	},
	"application/senml-exi": { "source": "iana" },
	"application/sensml+cbor": { "source": "iana" },
	"application/sensml+json": {
		"source": "iana",
		"compressible": true
	},
	"application/sensml+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["sensmlx"]
	},
	"application/sensml-exi": { "source": "iana" },
	"application/sep+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/sep-exi": { "source": "iana" },
	"application/session-info": { "source": "iana" },
	"application/set-payment": { "source": "iana" },
	"application/set-payment-initiation": {
		"source": "iana",
		"extensions": ["setpay"]
	},
	"application/set-registration": { "source": "iana" },
	"application/set-registration-initiation": {
		"source": "iana",
		"extensions": ["setreg"]
	},
	"application/sgml": { "source": "iana" },
	"application/sgml-open-catalog": { "source": "iana" },
	"application/shf+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["shf"]
	},
	"application/sieve": {
		"source": "iana",
		"extensions": ["siv", "sieve"]
	},
	"application/simple-filter+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/simple-message-summary": { "source": "iana" },
	"application/simplesymbolcontainer": { "source": "iana" },
	"application/sipc": { "source": "iana" },
	"application/slate": { "source": "iana" },
	"application/smil": { "source": "apache" },
	"application/smil+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["smi", "smil"]
	},
	"application/smpte336m": { "source": "iana" },
	"application/soap+fastinfoset": { "source": "iana" },
	"application/soap+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/sparql-query": {
		"source": "iana",
		"extensions": ["rq"]
	},
	"application/sparql-results+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["srx"]
	},
	"application/spdx+json": {
		"source": "iana",
		"compressible": true
	},
	"application/spirits-event+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/sql": {
		"source": "iana",
		"extensions": ["sql"]
	},
	"application/srgs": {
		"source": "iana",
		"extensions": ["gram"]
	},
	"application/srgs+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["grxml"]
	},
	"application/sru+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["sru"]
	},
	"application/ssdl+xml": {
		"source": "apache",
		"compressible": true,
		"extensions": ["ssdl"]
	},
	"application/sslkeylogfile": { "source": "iana" },
	"application/ssml+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["ssml"]
	},
	"application/st2110-41": { "source": "iana" },
	"application/stix+json": {
		"source": "iana",
		"compressible": true
	},
	"application/stratum": { "source": "iana" },
	"application/swid+cbor": { "source": "iana" },
	"application/swid+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["swidtag"]
	},
	"application/tamp-apex-update": { "source": "iana" },
	"application/tamp-apex-update-confirm": { "source": "iana" },
	"application/tamp-community-update": { "source": "iana" },
	"application/tamp-community-update-confirm": { "source": "iana" },
	"application/tamp-error": { "source": "iana" },
	"application/tamp-sequence-adjust": { "source": "iana" },
	"application/tamp-sequence-adjust-confirm": { "source": "iana" },
	"application/tamp-status-query": { "source": "iana" },
	"application/tamp-status-response": { "source": "iana" },
	"application/tamp-update": { "source": "iana" },
	"application/tamp-update-confirm": { "source": "iana" },
	"application/tar": { "compressible": true },
	"application/taxii+json": {
		"source": "iana",
		"compressible": true
	},
	"application/td+json": {
		"source": "iana",
		"compressible": true
	},
	"application/tei+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["tei", "teicorpus"]
	},
	"application/tetra_isi": { "source": "iana" },
	"application/thraud+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["tfi"]
	},
	"application/timestamp-query": { "source": "iana" },
	"application/timestamp-reply": { "source": "iana" },
	"application/timestamped-data": {
		"source": "iana",
		"extensions": ["tsd"]
	},
	"application/tlsrpt+gzip": { "source": "iana" },
	"application/tlsrpt+json": {
		"source": "iana",
		"compressible": true
	},
	"application/tm+json": {
		"source": "iana",
		"compressible": true
	},
	"application/tnauthlist": { "source": "iana" },
	"application/toc+cbor": { "source": "iana" },
	"application/token-introspection+jwt": { "source": "iana" },
	"application/toml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["toml"]
	},
	"application/trickle-ice-sdpfrag": { "source": "iana" },
	"application/trig": {
		"source": "iana",
		"extensions": ["trig"]
	},
	"application/trust-chain+json": {
		"source": "iana",
		"compressible": true
	},
	"application/trust-mark+jwt": { "source": "iana" },
	"application/trust-mark-delegation+jwt": { "source": "iana" },
	"application/ttml+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["ttml"]
	},
	"application/tve-trigger": { "source": "iana" },
	"application/tzif": { "source": "iana" },
	"application/tzif-leap": { "source": "iana" },
	"application/ubjson": {
		"compressible": false,
		"extensions": ["ubj"]
	},
	"application/uccs+cbor": { "source": "iana" },
	"application/ujcs+json": {
		"source": "iana",
		"compressible": true
	},
	"application/ulpfec": { "source": "iana" },
	"application/urc-grpsheet+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/urc-ressheet+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["rsheet"]
	},
	"application/urc-targetdesc+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["td"]
	},
	"application/urc-uisocketdesc+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vc": { "source": "iana" },
	"application/vc+cose": { "source": "iana" },
	"application/vc+jwt": { "source": "iana" },
	"application/vcard+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vcard+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vemmi": { "source": "iana" },
	"application/vividence.scriptfile": { "source": "apache" },
	"application/vnd.1000minds.decision-model+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["1km"]
	},
	"application/vnd.1ob": { "source": "iana" },
	"application/vnd.3gpp-prose+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp-prose-pc3a+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp-prose-pc3ach+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp-prose-pc3ch+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp-prose-pc8+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp-v2x-local-service-information": { "source": "iana" },
	"application/vnd.3gpp.5gnas": { "source": "iana" },
	"application/vnd.3gpp.5gsa2x": { "source": "iana" },
	"application/vnd.3gpp.5gsa2x-local-service-information": { "source": "iana" },
	"application/vnd.3gpp.5gsv2x": { "source": "iana" },
	"application/vnd.3gpp.5gsv2x-local-service-information": { "source": "iana" },
	"application/vnd.3gpp.access-transfer-events+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.bsf+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.crs+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.current-location-discovery+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.gmop+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.gtpc": { "source": "iana" },
	"application/vnd.3gpp.interworking-data": { "source": "iana" },
	"application/vnd.3gpp.lpp": { "source": "iana" },
	"application/vnd.3gpp.mc-signalling-ear": { "source": "iana" },
	"application/vnd.3gpp.mcdata-affiliation-command+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcdata-info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcdata-msgstore-ctrl-request+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcdata-payload": { "source": "iana" },
	"application/vnd.3gpp.mcdata-regroup+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcdata-service-config+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcdata-signalling": { "source": "iana" },
	"application/vnd.3gpp.mcdata-ue-config+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcdata-user-profile+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcptt-affiliation-command+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcptt-floor-request+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcptt-info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcptt-location-info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcptt-regroup+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcptt-service-config+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcptt-signed+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcptt-ue-config+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcptt-ue-init-config+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcptt-user-profile+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcvideo-affiliation-command+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcvideo-info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcvideo-location-info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcvideo-regroup+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcvideo-service-config+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcvideo-transmission-request+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcvideo-ue-config+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mcvideo-user-profile+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.mid-call+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.ngap": { "source": "iana" },
	"application/vnd.3gpp.pfcp": { "source": "iana" },
	"application/vnd.3gpp.pic-bw-large": {
		"source": "iana",
		"extensions": ["plb"]
	},
	"application/vnd.3gpp.pic-bw-small": {
		"source": "iana",
		"extensions": ["psb"]
	},
	"application/vnd.3gpp.pic-bw-var": {
		"source": "iana",
		"extensions": ["pvb"]
	},
	"application/vnd.3gpp.pinapp-info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.s1ap": { "source": "iana" },
	"application/vnd.3gpp.seal-group-doc+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.seal-info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.seal-location-info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.seal-mbms-usage-info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.seal-network-qos-management-info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.seal-ue-config-info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.seal-unicast-info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.seal-user-profile-info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.sms": { "source": "iana" },
	"application/vnd.3gpp.sms+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.srvcc-ext+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.srvcc-info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.state-and-event-info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.ussd+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp.v2x": { "source": "iana" },
	"application/vnd.3gpp.vae-info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp2.bcmcsinfo+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.3gpp2.sms": { "source": "iana" },
	"application/vnd.3gpp2.tcap": {
		"source": "iana",
		"extensions": ["tcap"]
	},
	"application/vnd.3lightssoftware.imagescal": { "source": "iana" },
	"application/vnd.3m.post-it-notes": {
		"source": "iana",
		"extensions": ["pwn"]
	},
	"application/vnd.accpac.simply.aso": {
		"source": "iana",
		"extensions": ["aso"]
	},
	"application/vnd.accpac.simply.imp": {
		"source": "iana",
		"extensions": ["imp"]
	},
	"application/vnd.acm.addressxfer+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.acm.chatbot+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.acucobol": {
		"source": "iana",
		"extensions": ["acu"]
	},
	"application/vnd.acucorp": {
		"source": "iana",
		"extensions": ["atc", "acutc"]
	},
	"application/vnd.adobe.air-application-installer-package+zip": {
		"source": "apache",
		"compressible": false,
		"extensions": ["air"]
	},
	"application/vnd.adobe.flash.movie": { "source": "iana" },
	"application/vnd.adobe.formscentral.fcdt": {
		"source": "iana",
		"extensions": ["fcdt"]
	},
	"application/vnd.adobe.fxp": {
		"source": "iana",
		"extensions": ["fxp", "fxpl"]
	},
	"application/vnd.adobe.partial-upload": { "source": "iana" },
	"application/vnd.adobe.xdp+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["xdp"]
	},
	"application/vnd.adobe.xfdf": {
		"source": "apache",
		"extensions": ["xfdf"]
	},
	"application/vnd.aether.imp": { "source": "iana" },
	"application/vnd.afpc.afplinedata": { "source": "iana" },
	"application/vnd.afpc.afplinedata-pagedef": { "source": "iana" },
	"application/vnd.afpc.cmoca-cmresource": { "source": "iana" },
	"application/vnd.afpc.foca-charset": { "source": "iana" },
	"application/vnd.afpc.foca-codedfont": { "source": "iana" },
	"application/vnd.afpc.foca-codepage": { "source": "iana" },
	"application/vnd.afpc.modca": { "source": "iana" },
	"application/vnd.afpc.modca-cmtable": { "source": "iana" },
	"application/vnd.afpc.modca-formdef": { "source": "iana" },
	"application/vnd.afpc.modca-mediummap": { "source": "iana" },
	"application/vnd.afpc.modca-objectcontainer": { "source": "iana" },
	"application/vnd.afpc.modca-overlay": { "source": "iana" },
	"application/vnd.afpc.modca-pagesegment": { "source": "iana" },
	"application/vnd.age": {
		"source": "iana",
		"extensions": ["age"]
	},
	"application/vnd.ah-barcode": { "source": "apache" },
	"application/vnd.ahead.space": {
		"source": "iana",
		"extensions": ["ahead"]
	},
	"application/vnd.airzip.filesecure.azf": {
		"source": "iana",
		"extensions": ["azf"]
	},
	"application/vnd.airzip.filesecure.azs": {
		"source": "iana",
		"extensions": ["azs"]
	},
	"application/vnd.amadeus+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.amazon.ebook": {
		"source": "apache",
		"extensions": ["azw"]
	},
	"application/vnd.amazon.mobi8-ebook": { "source": "iana" },
	"application/vnd.americandynamics.acc": {
		"source": "iana",
		"extensions": ["acc"]
	},
	"application/vnd.amiga.ami": {
		"source": "iana",
		"extensions": ["ami"]
	},
	"application/vnd.amundsen.maze+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.android.ota": { "source": "iana" },
	"application/vnd.android.package-archive": {
		"source": "apache",
		"compressible": false,
		"extensions": ["apk"]
	},
	"application/vnd.anki": { "source": "iana" },
	"application/vnd.anser-web-certificate-issue-initiation": {
		"source": "iana",
		"extensions": ["cii"]
	},
	"application/vnd.anser-web-funds-transfer-initiation": {
		"source": "apache",
		"extensions": ["fti"]
	},
	"application/vnd.antix.game-component": {
		"source": "iana",
		"extensions": ["atx"]
	},
	"application/vnd.apache.arrow.file": { "source": "iana" },
	"application/vnd.apache.arrow.stream": { "source": "iana" },
	"application/vnd.apache.parquet": { "source": "iana" },
	"application/vnd.apache.thrift.binary": { "source": "iana" },
	"application/vnd.apache.thrift.compact": { "source": "iana" },
	"application/vnd.apache.thrift.json": { "source": "iana" },
	"application/vnd.apexlang": { "source": "iana" },
	"application/vnd.api+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.aplextor.warrp+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.apothekende.reservation+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.apple.installer+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["mpkg"]
	},
	"application/vnd.apple.keynote": {
		"source": "iana",
		"extensions": ["key"]
	},
	"application/vnd.apple.mpegurl": {
		"source": "iana",
		"extensions": ["m3u8"]
	},
	"application/vnd.apple.numbers": {
		"source": "iana",
		"extensions": ["numbers"]
	},
	"application/vnd.apple.pages": {
		"source": "iana",
		"extensions": ["pages"]
	},
	"application/vnd.apple.pkpass": {
		"compressible": false,
		"extensions": ["pkpass"]
	},
	"application/vnd.arastra.swi": { "source": "apache" },
	"application/vnd.aristanetworks.swi": {
		"source": "iana",
		"extensions": ["swi"]
	},
	"application/vnd.artisan+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.artsquare": { "source": "iana" },
	"application/vnd.astraea-software.iota": {
		"source": "iana",
		"extensions": ["iota"]
	},
	"application/vnd.audiograph": {
		"source": "iana",
		"extensions": ["aep"]
	},
	"application/vnd.autodesk.fbx": { "extensions": ["fbx"] },
	"application/vnd.autopackage": { "source": "iana" },
	"application/vnd.avalon+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.avistar+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.balsamiq.bmml+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["bmml"]
	},
	"application/vnd.balsamiq.bmpr": { "source": "iana" },
	"application/vnd.banana-accounting": { "source": "iana" },
	"application/vnd.bbf.usp.error": { "source": "iana" },
	"application/vnd.bbf.usp.msg": { "source": "iana" },
	"application/vnd.bbf.usp.msg+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.bekitzur-stech+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.belightsoft.lhzd+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/vnd.belightsoft.lhzl+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/vnd.bint.med-content": { "source": "iana" },
	"application/vnd.biopax.rdf+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.blink-idb-value-wrapper": { "source": "iana" },
	"application/vnd.blueice.multipass": {
		"source": "iana",
		"extensions": ["mpm"]
	},
	"application/vnd.bluetooth.ep.oob": { "source": "iana" },
	"application/vnd.bluetooth.le.oob": { "source": "iana" },
	"application/vnd.bmi": {
		"source": "iana",
		"extensions": ["bmi"]
	},
	"application/vnd.bpf": { "source": "iana" },
	"application/vnd.bpf3": { "source": "iana" },
	"application/vnd.businessobjects": {
		"source": "iana",
		"extensions": ["rep"]
	},
	"application/vnd.byu.uapi+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.bzip3": { "source": "iana" },
	"application/vnd.c3voc.schedule+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.cab-jscript": { "source": "iana" },
	"application/vnd.canon-cpdl": { "source": "iana" },
	"application/vnd.canon-lips": { "source": "iana" },
	"application/vnd.capasystems-pg+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.cendio.thinlinc.clientconf": { "source": "iana" },
	"application/vnd.century-systems.tcp_stream": { "source": "iana" },
	"application/vnd.chemdraw+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["cdxml"]
	},
	"application/vnd.chess-pgn": { "source": "iana" },
	"application/vnd.chipnuts.karaoke-mmd": {
		"source": "iana",
		"extensions": ["mmd"]
	},
	"application/vnd.ciedi": { "source": "iana" },
	"application/vnd.cinderella": {
		"source": "iana",
		"extensions": ["cdy"]
	},
	"application/vnd.cirpack.isdn-ext": { "source": "iana" },
	"application/vnd.citationstyles.style+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["csl"]
	},
	"application/vnd.claymore": {
		"source": "iana",
		"extensions": ["cla"]
	},
	"application/vnd.cloanto.rp9": {
		"source": "iana",
		"extensions": ["rp9"]
	},
	"application/vnd.clonk.c4group": {
		"source": "iana",
		"extensions": [
			"c4g",
			"c4d",
			"c4f",
			"c4p",
			"c4u"
		]
	},
	"application/vnd.cluetrust.cartomobile-config": {
		"source": "iana",
		"extensions": ["c11amc"]
	},
	"application/vnd.cluetrust.cartomobile-config-pkg": {
		"source": "iana",
		"extensions": ["c11amz"]
	},
	"application/vnd.cncf.helm.chart.content.v1.tar+gzip": { "source": "iana" },
	"application/vnd.cncf.helm.chart.provenance.v1.prov": { "source": "iana" },
	"application/vnd.cncf.helm.config.v1+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.coffeescript": { "source": "iana" },
	"application/vnd.collabio.xodocuments.document": { "source": "iana" },
	"application/vnd.collabio.xodocuments.document-template": { "source": "iana" },
	"application/vnd.collabio.xodocuments.presentation": { "source": "iana" },
	"application/vnd.collabio.xodocuments.presentation-template": { "source": "iana" },
	"application/vnd.collabio.xodocuments.spreadsheet": { "source": "iana" },
	"application/vnd.collabio.xodocuments.spreadsheet-template": { "source": "iana" },
	"application/vnd.collection+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.collection.doc+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.collection.next+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.comicbook+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/vnd.comicbook-rar": { "source": "iana" },
	"application/vnd.commerce-battelle": { "source": "iana" },
	"application/vnd.commonspace": {
		"source": "iana",
		"extensions": ["csp"]
	},
	"application/vnd.contact.cmsg": {
		"source": "iana",
		"extensions": ["cdbcmsg"]
	},
	"application/vnd.coreos.ignition+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.cosmocaller": {
		"source": "iana",
		"extensions": ["cmc"]
	},
	"application/vnd.crick.clicker": {
		"source": "iana",
		"extensions": ["clkx"]
	},
	"application/vnd.crick.clicker.keyboard": {
		"source": "iana",
		"extensions": ["clkk"]
	},
	"application/vnd.crick.clicker.palette": {
		"source": "iana",
		"extensions": ["clkp"]
	},
	"application/vnd.crick.clicker.template": {
		"source": "iana",
		"extensions": ["clkt"]
	},
	"application/vnd.crick.clicker.wordbank": {
		"source": "iana",
		"extensions": ["clkw"]
	},
	"application/vnd.criticaltools.wbs+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["wbs"]
	},
	"application/vnd.cryptii.pipe+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.crypto-shade-file": { "source": "iana" },
	"application/vnd.cryptomator.encrypted": { "source": "iana" },
	"application/vnd.cryptomator.vault": { "source": "iana" },
	"application/vnd.ctc-posml": {
		"source": "iana",
		"extensions": ["pml"]
	},
	"application/vnd.ctct.ws+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.cups-pdf": { "source": "iana" },
	"application/vnd.cups-postscript": { "source": "iana" },
	"application/vnd.cups-ppd": {
		"source": "iana",
		"extensions": ["ppd"]
	},
	"application/vnd.cups-raster": { "source": "iana" },
	"application/vnd.cups-raw": { "source": "iana" },
	"application/vnd.curl": { "source": "iana" },
	"application/vnd.curl.car": {
		"source": "apache",
		"extensions": ["car"]
	},
	"application/vnd.curl.pcurl": {
		"source": "apache",
		"extensions": ["pcurl"]
	},
	"application/vnd.cyan.dean.root+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.cybank": { "source": "iana" },
	"application/vnd.cyclonedx+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.cyclonedx+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.d2l.coursepackage1p0+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/vnd.d3m-dataset": { "source": "iana" },
	"application/vnd.d3m-problem": { "source": "iana" },
	"application/vnd.dart": {
		"source": "iana",
		"compressible": true,
		"extensions": ["dart"]
	},
	"application/vnd.data-vision.rdz": {
		"source": "iana",
		"extensions": ["rdz"]
	},
	"application/vnd.datalog": { "source": "iana" },
	"application/vnd.datapackage+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.dataresource+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.dbf": {
		"source": "iana",
		"extensions": ["dbf"]
	},
	"application/vnd.dcmp+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["dcmp"]
	},
	"application/vnd.debian.binary-package": { "source": "iana" },
	"application/vnd.dece.data": {
		"source": "iana",
		"extensions": [
			"uvf",
			"uvvf",
			"uvd",
			"uvvd"
		]
	},
	"application/vnd.dece.ttml+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["uvt", "uvvt"]
	},
	"application/vnd.dece.unspecified": {
		"source": "iana",
		"extensions": ["uvx", "uvvx"]
	},
	"application/vnd.dece.zip": {
		"source": "iana",
		"extensions": ["uvz", "uvvz"]
	},
	"application/vnd.denovo.fcselayout-link": {
		"source": "iana",
		"extensions": ["fe_launch"]
	},
	"application/vnd.desmume.movie": { "source": "iana" },
	"application/vnd.dir-bi.plate-dl-nosuffix": { "source": "iana" },
	"application/vnd.dm.delegation+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.dna": {
		"source": "iana",
		"extensions": ["dna"]
	},
	"application/vnd.document+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.dolby.mlp": {
		"source": "apache",
		"extensions": ["mlp"]
	},
	"application/vnd.dolby.mobile.1": { "source": "iana" },
	"application/vnd.dolby.mobile.2": { "source": "iana" },
	"application/vnd.doremir.scorecloud-binary-document": { "source": "iana" },
	"application/vnd.dpgraph": {
		"source": "iana",
		"extensions": ["dpg"]
	},
	"application/vnd.dreamfactory": {
		"source": "iana",
		"extensions": ["dfac"]
	},
	"application/vnd.drive+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.ds-keypoint": {
		"source": "apache",
		"extensions": ["kpxx"]
	},
	"application/vnd.dtg.local": { "source": "iana" },
	"application/vnd.dtg.local.flash": { "source": "iana" },
	"application/vnd.dtg.local.html": { "source": "iana" },
	"application/vnd.dvb.ait": {
		"source": "iana",
		"extensions": ["ait"]
	},
	"application/vnd.dvb.dvbisl+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.dvb.dvbj": { "source": "iana" },
	"application/vnd.dvb.esgcontainer": { "source": "iana" },
	"application/vnd.dvb.ipdcdftnotifaccess": { "source": "iana" },
	"application/vnd.dvb.ipdcesgaccess": { "source": "iana" },
	"application/vnd.dvb.ipdcesgaccess2": { "source": "iana" },
	"application/vnd.dvb.ipdcesgpdd": { "source": "iana" },
	"application/vnd.dvb.ipdcroaming": { "source": "iana" },
	"application/vnd.dvb.iptv.alfec-base": { "source": "iana" },
	"application/vnd.dvb.iptv.alfec-enhancement": { "source": "iana" },
	"application/vnd.dvb.notif-aggregate-root+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.dvb.notif-container+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.dvb.notif-generic+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.dvb.notif-ia-msglist+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.dvb.notif-ia-registration-request+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.dvb.notif-ia-registration-response+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.dvb.notif-init+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.dvb.pfr": { "source": "iana" },
	"application/vnd.dvb.service": {
		"source": "iana",
		"extensions": ["svc"]
	},
	"application/vnd.dxr": { "source": "iana" },
	"application/vnd.dynageo": {
		"source": "iana",
		"extensions": ["geo"]
	},
	"application/vnd.dzr": { "source": "iana" },
	"application/vnd.easykaraoke.cdgdownload": { "source": "iana" },
	"application/vnd.ecdis-update": { "source": "iana" },
	"application/vnd.ecip.rlp": { "source": "iana" },
	"application/vnd.eclipse.ditto+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.ecowin.chart": {
		"source": "iana",
		"extensions": ["mag"]
	},
	"application/vnd.ecowin.filerequest": { "source": "iana" },
	"application/vnd.ecowin.fileupdate": { "source": "iana" },
	"application/vnd.ecowin.series": { "source": "iana" },
	"application/vnd.ecowin.seriesrequest": { "source": "iana" },
	"application/vnd.ecowin.seriesupdate": { "source": "iana" },
	"application/vnd.efi.img": { "source": "iana" },
	"application/vnd.efi.iso": { "source": "iana" },
	"application/vnd.eln+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/vnd.emclient.accessrequest+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.enliven": {
		"source": "iana",
		"extensions": ["nml"]
	},
	"application/vnd.enphase.envoy": { "source": "iana" },
	"application/vnd.eprints.data+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.epson.esf": {
		"source": "iana",
		"extensions": ["esf"]
	},
	"application/vnd.epson.msf": {
		"source": "iana",
		"extensions": ["msf"]
	},
	"application/vnd.epson.quickanime": {
		"source": "iana",
		"extensions": ["qam"]
	},
	"application/vnd.epson.salt": {
		"source": "iana",
		"extensions": ["slt"]
	},
	"application/vnd.epson.ssf": {
		"source": "iana",
		"extensions": ["ssf"]
	},
	"application/vnd.ericsson.quickcall": { "source": "iana" },
	"application/vnd.erofs": { "source": "iana" },
	"application/vnd.espass-espass+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/vnd.eszigno3+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["es3", "et3"]
	},
	"application/vnd.etsi.aoc+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.etsi.asic-e+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/vnd.etsi.asic-s+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/vnd.etsi.cug+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.etsi.iptvcommand+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.etsi.iptvdiscovery+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.etsi.iptvprofile+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.etsi.iptvsad-bc+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.etsi.iptvsad-cod+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.etsi.iptvsad-npvr+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.etsi.iptvservice+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.etsi.iptvsync+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.etsi.iptvueprofile+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.etsi.mcid+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.etsi.mheg5": { "source": "iana" },
	"application/vnd.etsi.overload-control-policy-dataset+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.etsi.pstn+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.etsi.sci+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.etsi.simservs+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.etsi.timestamp-token": { "source": "iana" },
	"application/vnd.etsi.tsl+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.etsi.tsl.der": { "source": "iana" },
	"application/vnd.eu.kasparian.car+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.eudora.data": { "source": "iana" },
	"application/vnd.evolv.ecig.profile": { "source": "iana" },
	"application/vnd.evolv.ecig.settings": { "source": "iana" },
	"application/vnd.evolv.ecig.theme": { "source": "iana" },
	"application/vnd.exstream-empower+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/vnd.exstream-package": { "source": "iana" },
	"application/vnd.ezpix-album": {
		"source": "iana",
		"extensions": ["ez2"]
	},
	"application/vnd.ezpix-package": {
		"source": "iana",
		"extensions": ["ez3"]
	},
	"application/vnd.f-secure.mobile": { "source": "iana" },
	"application/vnd.familysearch.gedcom+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/vnd.fastcopy-disk-image": { "source": "iana" },
	"application/vnd.fdf": {
		"source": "apache",
		"extensions": ["fdf"]
	},
	"application/vnd.fdsn.mseed": {
		"source": "iana",
		"extensions": ["mseed"]
	},
	"application/vnd.fdsn.seed": {
		"source": "iana",
		"extensions": ["seed", "dataless"]
	},
	"application/vnd.fdsn.stationxml+xml": {
		"source": "iana",
		"charset": "XML-BASED",
		"compressible": true
	},
	"application/vnd.ffsns": { "source": "iana" },
	"application/vnd.ficlab.flb+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/vnd.filmit.zfc": { "source": "iana" },
	"application/vnd.fints": { "source": "iana" },
	"application/vnd.firemonkeys.cloudcell": { "source": "iana" },
	"application/vnd.flographit": {
		"source": "iana",
		"extensions": ["gph"]
	},
	"application/vnd.fluxtime.clip": {
		"source": "iana",
		"extensions": ["ftc"]
	},
	"application/vnd.font-fontforge-sfd": { "source": "iana" },
	"application/vnd.framemaker": {
		"source": "iana",
		"extensions": [
			"fm",
			"frame",
			"maker",
			"book"
		]
	},
	"application/vnd.freelog.comic": { "source": "iana" },
	"application/vnd.frogans.fnc": {
		"source": "apache",
		"extensions": ["fnc"]
	},
	"application/vnd.frogans.ltf": {
		"source": "apache",
		"extensions": ["ltf"]
	},
	"application/vnd.fsc.weblaunch": {
		"source": "iana",
		"extensions": ["fsc"]
	},
	"application/vnd.fujifilm.fb.docuworks": { "source": "iana" },
	"application/vnd.fujifilm.fb.docuworks.binder": { "source": "iana" },
	"application/vnd.fujifilm.fb.docuworks.container": { "source": "iana" },
	"application/vnd.fujifilm.fb.jfi+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.fujitsu.oasys": {
		"source": "iana",
		"extensions": ["oas"]
	},
	"application/vnd.fujitsu.oasys2": {
		"source": "iana",
		"extensions": ["oa2"]
	},
	"application/vnd.fujitsu.oasys3": {
		"source": "iana",
		"extensions": ["oa3"]
	},
	"application/vnd.fujitsu.oasysgp": {
		"source": "iana",
		"extensions": ["fg5"]
	},
	"application/vnd.fujitsu.oasysprs": {
		"source": "iana",
		"extensions": ["bh2"]
	},
	"application/vnd.fujixerox.art-ex": { "source": "iana" },
	"application/vnd.fujixerox.art4": { "source": "iana" },
	"application/vnd.fujixerox.ddd": {
		"source": "iana",
		"extensions": ["ddd"]
	},
	"application/vnd.fujixerox.docuworks": {
		"source": "iana",
		"extensions": ["xdw"]
	},
	"application/vnd.fujixerox.docuworks.binder": {
		"source": "iana",
		"extensions": ["xbd"]
	},
	"application/vnd.fujixerox.docuworks.container": { "source": "iana" },
	"application/vnd.fujixerox.hbpl": { "source": "iana" },
	"application/vnd.fut-misnet": { "source": "iana" },
	"application/vnd.futoin+cbor": { "source": "iana" },
	"application/vnd.futoin+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.fuzzysheet": {
		"source": "iana",
		"extensions": ["fzs"]
	},
	"application/vnd.ga4gh.passport+jwt": { "source": "iana" },
	"application/vnd.genomatix.tuxedo": {
		"source": "iana",
		"extensions": ["txd"]
	},
	"application/vnd.genozip": { "source": "iana" },
	"application/vnd.gentics.grd+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.gentoo.catmetadata+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.gentoo.ebuild": { "source": "iana" },
	"application/vnd.gentoo.eclass": { "source": "iana" },
	"application/vnd.gentoo.gpkg": { "source": "iana" },
	"application/vnd.gentoo.manifest": { "source": "iana" },
	"application/vnd.gentoo.pkgmetadata+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.gentoo.xpak": { "source": "iana" },
	"application/vnd.geo+json": {
		"source": "apache",
		"compressible": true
	},
	"application/vnd.geocube+xml": {
		"source": "apache",
		"compressible": true
	},
	"application/vnd.geogebra.file": {
		"source": "iana",
		"extensions": ["ggb"]
	},
	"application/vnd.geogebra.pinboard": { "source": "iana" },
	"application/vnd.geogebra.slides": {
		"source": "iana",
		"extensions": ["ggs"]
	},
	"application/vnd.geogebra.tool": {
		"source": "iana",
		"extensions": ["ggt"]
	},
	"application/vnd.geometry-explorer": {
		"source": "iana",
		"extensions": ["gex", "gre"]
	},
	"application/vnd.geonext": {
		"source": "iana",
		"extensions": ["gxt"]
	},
	"application/vnd.geoplan": {
		"source": "iana",
		"extensions": ["g2w"]
	},
	"application/vnd.geospace": {
		"source": "iana",
		"extensions": ["g3w"]
	},
	"application/vnd.gerber": { "source": "iana" },
	"application/vnd.globalplatform.card-content-mgt": { "source": "iana" },
	"application/vnd.globalplatform.card-content-mgt-response": { "source": "iana" },
	"application/vnd.gmx": {
		"source": "iana",
		"extensions": ["gmx"]
	},
	"application/vnd.gnu.taler.exchange+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.gnu.taler.merchant+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.google-apps.audio": {},
	"application/vnd.google-apps.document": {
		"compressible": false,
		"extensions": ["gdoc"]
	},
	"application/vnd.google-apps.drawing": {
		"compressible": false,
		"extensions": ["gdraw"]
	},
	"application/vnd.google-apps.drive-sdk": { "compressible": false },
	"application/vnd.google-apps.file": {},
	"application/vnd.google-apps.folder": { "compressible": false },
	"application/vnd.google-apps.form": {
		"compressible": false,
		"extensions": ["gform"]
	},
	"application/vnd.google-apps.fusiontable": {},
	"application/vnd.google-apps.jam": {
		"compressible": false,
		"extensions": ["gjam"]
	},
	"application/vnd.google-apps.mail-layout": {},
	"application/vnd.google-apps.map": {
		"compressible": false,
		"extensions": ["gmap"]
	},
	"application/vnd.google-apps.photo": {},
	"application/vnd.google-apps.presentation": {
		"compressible": false,
		"extensions": ["gslides"]
	},
	"application/vnd.google-apps.script": {
		"compressible": false,
		"extensions": ["gscript"]
	},
	"application/vnd.google-apps.shortcut": {},
	"application/vnd.google-apps.site": {
		"compressible": false,
		"extensions": ["gsite"]
	},
	"application/vnd.google-apps.spreadsheet": {
		"compressible": false,
		"extensions": ["gsheet"]
	},
	"application/vnd.google-apps.unknown": {},
	"application/vnd.google-apps.video": {},
	"application/vnd.google-earth.kml+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["kml"]
	},
	"application/vnd.google-earth.kmz": {
		"source": "iana",
		"compressible": false,
		"extensions": ["kmz"]
	},
	"application/vnd.gov.sk.e-form+xml": {
		"source": "apache",
		"compressible": true
	},
	"application/vnd.gov.sk.e-form+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/vnd.gov.sk.xmldatacontainer+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["xdcf"]
	},
	"application/vnd.gpxsee.map+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.grafeq": {
		"source": "iana",
		"extensions": ["gqf", "gqs"]
	},
	"application/vnd.gridmp": { "source": "iana" },
	"application/vnd.groove-account": {
		"source": "iana",
		"extensions": ["gac"]
	},
	"application/vnd.groove-help": {
		"source": "iana",
		"extensions": ["ghf"]
	},
	"application/vnd.groove-identity-message": {
		"source": "iana",
		"extensions": ["gim"]
	},
	"application/vnd.groove-injector": {
		"source": "iana",
		"extensions": ["grv"]
	},
	"application/vnd.groove-tool-message": {
		"source": "iana",
		"extensions": ["gtm"]
	},
	"application/vnd.groove-tool-template": {
		"source": "iana",
		"extensions": ["tpl"]
	},
	"application/vnd.groove-vcard": {
		"source": "iana",
		"extensions": ["vcg"]
	},
	"application/vnd.hal+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.hal+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["hal"]
	},
	"application/vnd.handheld-entertainment+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["zmm"]
	},
	"application/vnd.hbci": {
		"source": "iana",
		"extensions": ["hbci"]
	},
	"application/vnd.hc+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.hcl-bireports": { "source": "iana" },
	"application/vnd.hdt": { "source": "iana" },
	"application/vnd.heroku+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.hhe.lesson-player": {
		"source": "iana",
		"extensions": ["les"]
	},
	"application/vnd.hp-hpgl": {
		"source": "iana",
		"extensions": ["hpgl"]
	},
	"application/vnd.hp-hpid": {
		"source": "iana",
		"extensions": ["hpid"]
	},
	"application/vnd.hp-hps": {
		"source": "iana",
		"extensions": ["hps"]
	},
	"application/vnd.hp-jlyt": {
		"source": "iana",
		"extensions": ["jlt"]
	},
	"application/vnd.hp-pcl": {
		"source": "iana",
		"extensions": ["pcl"]
	},
	"application/vnd.hp-pclxl": {
		"source": "iana",
		"extensions": ["pclxl"]
	},
	"application/vnd.hsl": { "source": "iana" },
	"application/vnd.httphone": { "source": "iana" },
	"application/vnd.hydrostatix.sof-data": {
		"source": "iana",
		"extensions": ["sfd-hdstx"]
	},
	"application/vnd.hyper+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.hyper-item+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.hyperdrive+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.hzn-3d-crossword": { "source": "iana" },
	"application/vnd.ibm.afplinedata": { "source": "apache" },
	"application/vnd.ibm.electronic-media": { "source": "iana" },
	"application/vnd.ibm.minipay": {
		"source": "iana",
		"extensions": ["mpy"]
	},
	"application/vnd.ibm.modcap": {
		"source": "apache",
		"extensions": [
			"afp",
			"listafp",
			"list3820"
		]
	},
	"application/vnd.ibm.rights-management": {
		"source": "iana",
		"extensions": ["irm"]
	},
	"application/vnd.ibm.secure-container": {
		"source": "iana",
		"extensions": ["sc"]
	},
	"application/vnd.iccprofile": {
		"source": "iana",
		"extensions": ["icc", "icm"]
	},
	"application/vnd.ieee.1905": { "source": "iana" },
	"application/vnd.igloader": {
		"source": "iana",
		"extensions": ["igl"]
	},
	"application/vnd.imagemeter.folder+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/vnd.imagemeter.image+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/vnd.immervision-ivp": {
		"source": "iana",
		"extensions": ["ivp"]
	},
	"application/vnd.immervision-ivu": {
		"source": "iana",
		"extensions": ["ivu"]
	},
	"application/vnd.ims.imsccv1p1": { "source": "iana" },
	"application/vnd.ims.imsccv1p2": { "source": "iana" },
	"application/vnd.ims.imsccv1p3": { "source": "iana" },
	"application/vnd.ims.lis.v2.result+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.ims.lti.v2.toolproxy+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.ims.lti.v2.toolproxy.id+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.ims.lti.v2.toolsettings+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.ims.lti.v2.toolsettings.simple+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.informedcontrol.rms+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.informix-visionary": { "source": "apache" },
	"application/vnd.infotech.project": { "source": "iana" },
	"application/vnd.infotech.project+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.innopath.wamp.notification": { "source": "iana" },
	"application/vnd.insors.igm": {
		"source": "iana",
		"extensions": ["igm"]
	},
	"application/vnd.intercon.formnet": {
		"source": "iana",
		"extensions": ["xpw", "xpx"]
	},
	"application/vnd.intergeo": {
		"source": "iana",
		"extensions": ["i2g"]
	},
	"application/vnd.intertrust.digibox": { "source": "iana" },
	"application/vnd.intertrust.nncp": { "source": "iana" },
	"application/vnd.intu.qbo": {
		"source": "iana",
		"extensions": ["qbo"]
	},
	"application/vnd.intu.qfx": {
		"source": "iana",
		"extensions": ["qfx"]
	},
	"application/vnd.ipfs.ipns-record": { "source": "iana" },
	"application/vnd.ipld.car": { "source": "iana" },
	"application/vnd.ipld.dag-cbor": { "source": "iana" },
	"application/vnd.ipld.dag-json": { "source": "iana" },
	"application/vnd.ipld.raw": { "source": "iana" },
	"application/vnd.iptc.g2.catalogitem+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.iptc.g2.conceptitem+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.iptc.g2.knowledgeitem+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.iptc.g2.newsitem+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.iptc.g2.newsmessage+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.iptc.g2.packageitem+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.iptc.g2.planningitem+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.ipunplugged.rcprofile": {
		"source": "iana",
		"extensions": ["rcprofile"]
	},
	"application/vnd.irepository.package+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["irp"]
	},
	"application/vnd.is-xpr": {
		"source": "iana",
		"extensions": ["xpr"]
	},
	"application/vnd.isac.fcs": {
		"source": "iana",
		"extensions": ["fcs"]
	},
	"application/vnd.iso11783-10+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/vnd.jam": {
		"source": "iana",
		"extensions": ["jam"]
	},
	"application/vnd.japannet-directory-service": { "source": "iana" },
	"application/vnd.japannet-jpnstore-wakeup": { "source": "iana" },
	"application/vnd.japannet-payment-wakeup": { "source": "iana" },
	"application/vnd.japannet-registration": { "source": "iana" },
	"application/vnd.japannet-registration-wakeup": { "source": "iana" },
	"application/vnd.japannet-setstore-wakeup": { "source": "iana" },
	"application/vnd.japannet-verification": { "source": "iana" },
	"application/vnd.japannet-verification-wakeup": { "source": "iana" },
	"application/vnd.jcp.javame.midlet-rms": {
		"source": "iana",
		"extensions": ["rms"]
	},
	"application/vnd.jisp": {
		"source": "iana",
		"extensions": ["jisp"]
	},
	"application/vnd.joost.joda-archive": {
		"source": "iana",
		"extensions": ["joda"]
	},
	"application/vnd.jsk.isdn-ngn": { "source": "iana" },
	"application/vnd.kahootz": {
		"source": "iana",
		"extensions": ["ktz", "ktr"]
	},
	"application/vnd.kde.karbon": {
		"source": "iana",
		"extensions": ["karbon"]
	},
	"application/vnd.kde.kchart": {
		"source": "iana",
		"extensions": ["chrt"]
	},
	"application/vnd.kde.kformula": {
		"source": "iana",
		"extensions": ["kfo"]
	},
	"application/vnd.kde.kivio": {
		"source": "iana",
		"extensions": ["flw"]
	},
	"application/vnd.kde.kontour": {
		"source": "iana",
		"extensions": ["kon"]
	},
	"application/vnd.kde.kpresenter": {
		"source": "iana",
		"extensions": ["kpr", "kpt"]
	},
	"application/vnd.kde.kspread": {
		"source": "iana",
		"extensions": ["ksp"]
	},
	"application/vnd.kde.kword": {
		"source": "iana",
		"extensions": ["kwd", "kwt"]
	},
	"application/vnd.kdl": { "source": "iana" },
	"application/vnd.kenameaapp": {
		"source": "iana",
		"extensions": ["htke"]
	},
	"application/vnd.keyman.kmp+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/vnd.keyman.kmx": { "source": "iana" },
	"application/vnd.kidspiration": {
		"source": "iana",
		"extensions": ["kia"]
	},
	"application/vnd.kinar": {
		"source": "iana",
		"extensions": ["kne", "knp"]
	},
	"application/vnd.koan": {
		"source": "iana",
		"extensions": [
			"skp",
			"skd",
			"skt",
			"skm"
		]
	},
	"application/vnd.kodak-descriptor": {
		"source": "iana",
		"extensions": ["sse"]
	},
	"application/vnd.las": { "source": "iana" },
	"application/vnd.las.las+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.las.las+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["lasxml"]
	},
	"application/vnd.laszip": { "source": "iana" },
	"application/vnd.ldev.productlicensing": { "source": "iana" },
	"application/vnd.leap+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.liberty-request+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.llamagraphics.life-balance.desktop": {
		"source": "iana",
		"extensions": ["lbd"]
	},
	"application/vnd.llamagraphics.life-balance.exchange+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["lbe"]
	},
	"application/vnd.logipipe.circuit+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/vnd.loom": { "source": "iana" },
	"application/vnd.lotus-1-2-3": {
		"source": "iana",
		"extensions": ["123"]
	},
	"application/vnd.lotus-approach": {
		"source": "iana",
		"extensions": ["apr"]
	},
	"application/vnd.lotus-freelance": {
		"source": "iana",
		"extensions": ["pre"]
	},
	"application/vnd.lotus-notes": {
		"source": "iana",
		"extensions": ["nsf"]
	},
	"application/vnd.lotus-organizer": {
		"source": "iana",
		"extensions": ["org"]
	},
	"application/vnd.lotus-screencam": {
		"source": "iana",
		"extensions": ["scm"]
	},
	"application/vnd.lotus-wordpro": {
		"source": "iana",
		"extensions": ["lwp"]
	},
	"application/vnd.macports.portpkg": {
		"source": "iana",
		"extensions": ["portpkg"]
	},
	"application/vnd.mapbox-vector-tile": {
		"source": "iana",
		"extensions": ["mvt"]
	},
	"application/vnd.marlin.drm.actiontoken+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.marlin.drm.conftoken+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.marlin.drm.license+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.marlin.drm.mdcf": { "source": "iana" },
	"application/vnd.mason+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.maxar.archive.3tz+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/vnd.maxmind.maxmind-db": { "source": "iana" },
	"application/vnd.mcd": {
		"source": "iana",
		"extensions": ["mcd"]
	},
	"application/vnd.mdl": { "source": "iana" },
	"application/vnd.mdl-mbsdf": { "source": "iana" },
	"application/vnd.medcalcdata": {
		"source": "iana",
		"extensions": ["mc1"]
	},
	"application/vnd.mediastation.cdkey": {
		"source": "iana",
		"extensions": ["cdkey"]
	},
	"application/vnd.medicalholodeck.recordxr": { "source": "iana" },
	"application/vnd.meridian-slingshot": { "source": "iana" },
	"application/vnd.mermaid": { "source": "iana" },
	"application/vnd.mfer": {
		"source": "iana",
		"extensions": ["mwf"]
	},
	"application/vnd.mfmp": {
		"source": "iana",
		"extensions": ["mfm"]
	},
	"application/vnd.micro+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.micrografx.flo": {
		"source": "iana",
		"extensions": ["flo"]
	},
	"application/vnd.micrografx.igx": {
		"source": "iana",
		"extensions": ["igx"]
	},
	"application/vnd.microsoft.portable-executable": { "source": "iana" },
	"application/vnd.microsoft.windows.thumbnail-cache": { "source": "iana" },
	"application/vnd.miele+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.mif": {
		"source": "iana",
		"extensions": ["mif"]
	},
	"application/vnd.minisoft-hp3000-save": { "source": "iana" },
	"application/vnd.mitsubishi.misty-guard.trustweb": { "source": "iana" },
	"application/vnd.mobius.daf": {
		"source": "iana",
		"extensions": ["daf"]
	},
	"application/vnd.mobius.dis": {
		"source": "iana",
		"extensions": ["dis"]
	},
	"application/vnd.mobius.mbk": {
		"source": "iana",
		"extensions": ["mbk"]
	},
	"application/vnd.mobius.mqy": {
		"source": "iana",
		"extensions": ["mqy"]
	},
	"application/vnd.mobius.msl": {
		"source": "iana",
		"extensions": ["msl"]
	},
	"application/vnd.mobius.plc": {
		"source": "iana",
		"extensions": ["plc"]
	},
	"application/vnd.mobius.txf": {
		"source": "iana",
		"extensions": ["txf"]
	},
	"application/vnd.modl": { "source": "iana" },
	"application/vnd.mophun.application": {
		"source": "iana",
		"extensions": ["mpn"]
	},
	"application/vnd.mophun.certificate": {
		"source": "iana",
		"extensions": ["mpc"]
	},
	"application/vnd.motorola.flexsuite": { "source": "iana" },
	"application/vnd.motorola.flexsuite.adsi": { "source": "iana" },
	"application/vnd.motorola.flexsuite.fis": { "source": "iana" },
	"application/vnd.motorola.flexsuite.gotap": { "source": "iana" },
	"application/vnd.motorola.flexsuite.kmr": { "source": "iana" },
	"application/vnd.motorola.flexsuite.ttc": { "source": "iana" },
	"application/vnd.motorola.flexsuite.wem": { "source": "iana" },
	"application/vnd.motorola.iprm": { "source": "iana" },
	"application/vnd.mozilla.xul+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["xul"]
	},
	"application/vnd.ms-3mfdocument": { "source": "iana" },
	"application/vnd.ms-artgalry": {
		"source": "iana",
		"extensions": ["cil"]
	},
	"application/vnd.ms-asf": { "source": "iana" },
	"application/vnd.ms-cab-compressed": {
		"source": "iana",
		"extensions": ["cab"]
	},
	"application/vnd.ms-color.iccprofile": { "source": "apache" },
	"application/vnd.ms-excel": {
		"source": "iana",
		"compressible": false,
		"extensions": [
			"xls",
			"xlm",
			"xla",
			"xlc",
			"xlt",
			"xlw"
		]
	},
	"application/vnd.ms-excel.addin.macroenabled.12": {
		"source": "iana",
		"extensions": ["xlam"]
	},
	"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
		"source": "iana",
		"extensions": ["xlsb"]
	},
	"application/vnd.ms-excel.sheet.macroenabled.12": {
		"source": "iana",
		"extensions": ["xlsm"]
	},
	"application/vnd.ms-excel.template.macroenabled.12": {
		"source": "iana",
		"extensions": ["xltm"]
	},
	"application/vnd.ms-fontobject": {
		"source": "iana",
		"compressible": true,
		"extensions": ["eot"]
	},
	"application/vnd.ms-htmlhelp": {
		"source": "iana",
		"extensions": ["chm"]
	},
	"application/vnd.ms-ims": {
		"source": "iana",
		"extensions": ["ims"]
	},
	"application/vnd.ms-lrm": {
		"source": "iana",
		"extensions": ["lrm"]
	},
	"application/vnd.ms-office.activex+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.ms-officetheme": {
		"source": "iana",
		"extensions": ["thmx"]
	},
	"application/vnd.ms-opentype": {
		"source": "apache",
		"compressible": true
	},
	"application/vnd.ms-outlook": {
		"compressible": false,
		"extensions": ["msg"]
	},
	"application/vnd.ms-package.obfuscated-opentype": { "source": "apache" },
	"application/vnd.ms-pki.seccat": {
		"source": "apache",
		"extensions": ["cat"]
	},
	"application/vnd.ms-pki.stl": {
		"source": "apache",
		"extensions": ["stl"]
	},
	"application/vnd.ms-playready.initiator+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.ms-powerpoint": {
		"source": "iana",
		"compressible": false,
		"extensions": [
			"ppt",
			"pps",
			"pot"
		]
	},
	"application/vnd.ms-powerpoint.addin.macroenabled.12": {
		"source": "iana",
		"extensions": ["ppam"]
	},
	"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
		"source": "iana",
		"extensions": ["pptm"]
	},
	"application/vnd.ms-powerpoint.slide.macroenabled.12": {
		"source": "iana",
		"extensions": ["sldm"]
	},
	"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
		"source": "iana",
		"extensions": ["ppsm"]
	},
	"application/vnd.ms-powerpoint.template.macroenabled.12": {
		"source": "iana",
		"extensions": ["potm"]
	},
	"application/vnd.ms-printdevicecapabilities+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.ms-printing.printticket+xml": {
		"source": "apache",
		"compressible": true
	},
	"application/vnd.ms-printschematicket+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.ms-project": {
		"source": "iana",
		"extensions": ["mpp", "mpt"]
	},
	"application/vnd.ms-tnef": { "source": "iana" },
	"application/vnd.ms-visio.viewer": { "extensions": ["vdx"] },
	"application/vnd.ms-windows.devicepairing": { "source": "iana" },
	"application/vnd.ms-windows.nwprinting.oob": { "source": "iana" },
	"application/vnd.ms-windows.printerpairing": { "source": "iana" },
	"application/vnd.ms-windows.wsd.oob": { "source": "iana" },
	"application/vnd.ms-wmdrm.lic-chlg-req": { "source": "iana" },
	"application/vnd.ms-wmdrm.lic-resp": { "source": "iana" },
	"application/vnd.ms-wmdrm.meter-chlg-req": { "source": "iana" },
	"application/vnd.ms-wmdrm.meter-resp": { "source": "iana" },
	"application/vnd.ms-word.document.macroenabled.12": {
		"source": "iana",
		"extensions": ["docm"]
	},
	"application/vnd.ms-word.template.macroenabled.12": {
		"source": "iana",
		"extensions": ["dotm"]
	},
	"application/vnd.ms-works": {
		"source": "iana",
		"extensions": [
			"wps",
			"wks",
			"wcm",
			"wdb"
		]
	},
	"application/vnd.ms-wpl": {
		"source": "iana",
		"extensions": ["wpl"]
	},
	"application/vnd.ms-xpsdocument": {
		"source": "iana",
		"compressible": false,
		"extensions": ["xps"]
	},
	"application/vnd.msa-disk-image": { "source": "iana" },
	"application/vnd.mseq": {
		"source": "iana",
		"extensions": ["mseq"]
	},
	"application/vnd.msgpack": { "source": "iana" },
	"application/vnd.msign": { "source": "iana" },
	"application/vnd.multiad.creator": { "source": "iana" },
	"application/vnd.multiad.creator.cif": { "source": "iana" },
	"application/vnd.music-niff": { "source": "iana" },
	"application/vnd.musician": {
		"source": "iana",
		"extensions": ["mus"]
	},
	"application/vnd.muvee.style": {
		"source": "iana",
		"extensions": ["msty"]
	},
	"application/vnd.mynfc": {
		"source": "iana",
		"extensions": ["taglet"]
	},
	"application/vnd.nacamar.ybrid+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.nato.bindingdataobject+cbor": { "source": "iana" },
	"application/vnd.nato.bindingdataobject+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.nato.bindingdataobject+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["bdo"]
	},
	"application/vnd.nato.openxmlformats-package.iepd+zip": {
		"source": "iana",
		"compressible": false
	},
	"application/vnd.ncd.control": { "source": "iana" },
	"application/vnd.ncd.reference": { "source": "iana" },
	"application/vnd.nearst.inv+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.nebumind.line": { "source": "iana" },
	"application/vnd.nervana": { "source": "iana" },
	"application/vnd.netfpx": { "source": "iana" },
	"application/vnd.neurolanguage.nlu": {
		"source": "iana",
		"extensions": ["nlu"]
	},
	"application/vnd.nimn": { "source": "iana" },
	"application/vnd.nintendo.nitro.rom": { "source": "iana" },
	"application/vnd.nintendo.snes.rom": { "source": "iana" },
	"application/vnd.nitf": {
		"source": "iana",
		"extensions": ["ntf", "nitf"]
	},
	"application/vnd.noblenet-directory": {
		"source": "iana",
		"extensions": ["nnd"]
	},
	"application/vnd.noblenet-sealer": {
		"source": "iana",
		"extensions": ["nns"]
	},
	"application/vnd.noblenet-web": {
		"source": "iana",
		"extensions": ["nnw"]
	},
	"application/vnd.nokia.catalogs": { "source": "iana" },
	"application/vnd.nokia.conml+wbxml": { "source": "iana" },
	"application/vnd.nokia.conml+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.nokia.iptv.config+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.nokia.isds-radio-presets": { "source": "iana" },
	"application/vnd.nokia.landmark+wbxml": { "source": "iana" },
	"application/vnd.nokia.landmark+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.nokia.landmarkcollection+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.nokia.n-gage.ac+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["ac"]
	},
	"application/vnd.nokia.n-gage.data": {
		"source": "iana",
		"extensions": ["ngdat"]
	},
	"application/vnd.nokia.n-gage.symbian.install": {
		"source": "apache",
		"extensions": ["n-gage"]
	},
	"application/vnd.nokia.ncd": { "source": "iana" },
	"application/vnd.nokia.pcd+wbxml": { "source": "iana" },
	"application/vnd.nokia.pcd+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.nokia.radio-preset": {
		"source": "iana",
		"extensions": ["rpst"]
	},
	"application/vnd.nokia.radio-presets": {
		"source": "iana",
		"extensions": ["rpss"]
	},
	"application/vnd.novadigm.edm": {
		"source": "iana",
		"extensions": ["edm"]
	},
	"application/vnd.novadigm.edx": {
		"source": "iana",
		"extensions": ["edx"]
	},
	"application/vnd.novadigm.ext": {
		"source": "iana",
		"extensions": ["ext"]
	},
	"application/vnd.ntt-local.content-share": { "source": "iana" },
	"application/vnd.ntt-local.file-transfer": { "source": "iana" },
	"application/vnd.ntt-local.ogw_remote-access": { "source": "iana" },
	"application/vnd.ntt-local.sip-ta_remote": { "source": "iana" },
	"application/vnd.ntt-local.sip-ta_tcp_stream": { "source": "iana" },
	"application/vnd.oai.workflows": { "source": "iana" },
	"application/vnd.oai.workflows+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oai.workflows+yaml": { "source": "iana" },
	"application/vnd.oasis.opendocument.base": { "source": "iana" },
	"application/vnd.oasis.opendocument.chart": {
		"source": "iana",
		"extensions": ["odc"]
	},
	"application/vnd.oasis.opendocument.chart-template": {
		"source": "iana",
		"extensions": ["otc"]
	},
	"application/vnd.oasis.opendocument.database": {
		"source": "apache",
		"extensions": ["odb"]
	},
	"application/vnd.oasis.opendocument.formula": {
		"source": "iana",
		"extensions": ["odf"]
	},
	"application/vnd.oasis.opendocument.formula-template": {
		"source": "iana",
		"extensions": ["odft"]
	},
	"application/vnd.oasis.opendocument.graphics": {
		"source": "iana",
		"compressible": false,
		"extensions": ["odg"]
	},
	"application/vnd.oasis.opendocument.graphics-template": {
		"source": "iana",
		"extensions": ["otg"]
	},
	"application/vnd.oasis.opendocument.image": {
		"source": "iana",
		"extensions": ["odi"]
	},
	"application/vnd.oasis.opendocument.image-template": {
		"source": "iana",
		"extensions": ["oti"]
	},
	"application/vnd.oasis.opendocument.presentation": {
		"source": "iana",
		"compressible": false,
		"extensions": ["odp"]
	},
	"application/vnd.oasis.opendocument.presentation-template": {
		"source": "iana",
		"extensions": ["otp"]
	},
	"application/vnd.oasis.opendocument.spreadsheet": {
		"source": "iana",
		"compressible": false,
		"extensions": ["ods"]
	},
	"application/vnd.oasis.opendocument.spreadsheet-template": {
		"source": "iana",
		"extensions": ["ots"]
	},
	"application/vnd.oasis.opendocument.text": {
		"source": "iana",
		"compressible": false,
		"extensions": ["odt"]
	},
	"application/vnd.oasis.opendocument.text-master": {
		"source": "iana",
		"extensions": ["odm"]
	},
	"application/vnd.oasis.opendocument.text-master-template": { "source": "iana" },
	"application/vnd.oasis.opendocument.text-template": {
		"source": "iana",
		"extensions": ["ott"]
	},
	"application/vnd.oasis.opendocument.text-web": {
		"source": "iana",
		"extensions": ["oth"]
	},
	"application/vnd.obn": { "source": "iana" },
	"application/vnd.ocf+cbor": { "source": "iana" },
	"application/vnd.oci.image.manifest.v1+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oftn.l10n+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oipf.contentaccessdownload+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oipf.contentaccessstreaming+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oipf.cspg-hexbinary": { "source": "iana" },
	"application/vnd.oipf.dae.svg+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oipf.dae.xhtml+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oipf.mippvcontrolmessage+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oipf.pae.gem": { "source": "iana" },
	"application/vnd.oipf.spdiscovery+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oipf.spdlist+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oipf.ueprofile+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oipf.userprofile+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.olpc-sugar": {
		"source": "iana",
		"extensions": ["xo"]
	},
	"application/vnd.oma-scws-config": { "source": "iana" },
	"application/vnd.oma-scws-http-request": { "source": "iana" },
	"application/vnd.oma-scws-http-response": { "source": "iana" },
	"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oma.bcast.drm-trigger+xml": {
		"source": "apache",
		"compressible": true
	},
	"application/vnd.oma.bcast.imd+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oma.bcast.ltkm": { "source": "iana" },
	"application/vnd.oma.bcast.notification+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oma.bcast.provisioningtrigger": { "source": "iana" },
	"application/vnd.oma.bcast.sgboot": { "source": "iana" },
	"application/vnd.oma.bcast.sgdd+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oma.bcast.sgdu": { "source": "iana" },
	"application/vnd.oma.bcast.simple-symbol-container": { "source": "iana" },
	"application/vnd.oma.bcast.smartcard-trigger+xml": {
		"source": "apache",
		"compressible": true
	},
	"application/vnd.oma.bcast.sprov+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oma.bcast.stkm": { "source": "iana" },
	"application/vnd.oma.cab-address-book+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oma.cab-feature-handler+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oma.cab-pcc+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oma.cab-subs-invite+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oma.cab-user-prefs+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oma.dcd": { "source": "iana" },
	"application/vnd.oma.dcdc": { "source": "iana" },
	"application/vnd.oma.dd2+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["dd2"]
	},
	"application/vnd.oma.drm.risd+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oma.group-usage-list+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oma.lwm2m+cbor": { "source": "iana" },
	"application/vnd.oma.lwm2m+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oma.lwm2m+tlv": { "source": "iana" },
	"application/vnd.oma.pal+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oma.poc.detailed-progress-report+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oma.poc.final-report+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oma.poc.groups+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oma.poc.invocation-descriptor+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oma.poc.optimized-progress-report+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oma.push": { "source": "iana" },
	"application/vnd.oma.scidm.messages+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oma.xcap-directory+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.omads-email+xml": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true
	},
	"application/vnd.omads-file+xml": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true
	},
	"application/vnd.omads-folder+xml": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true
	},
	"application/vnd.omaloc-supl-init": { "source": "iana" },
	"application/vnd.onepager": { "source": "iana" },
	"application/vnd.onepagertamp": { "source": "iana" },
	"application/vnd.onepagertamx": { "source": "iana" },
	"application/vnd.onepagertat": { "source": "iana" },
	"application/vnd.onepagertatp": { "source": "iana" },
	"application/vnd.onepagertatx": { "source": "iana" },
	"application/vnd.onvif.metadata": { "source": "iana" },
	"application/vnd.openblox.game+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["obgx"]
	},
	"application/vnd.openblox.game-binary": { "source": "iana" },
	"application/vnd.openeye.oeb": { "source": "iana" },
	"application/vnd.openofficeorg.extension": {
		"source": "apache",
		"extensions": ["oxt"]
	},
	"application/vnd.openstreetmap.data+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["osm"]
	},
	"application/vnd.opentimestamps.ots": { "source": "iana" },
	"application/vnd.openvpi.dspx+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.drawing+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
		"source": "iana",
		"compressible": false,
		"extensions": ["pptx"]
	},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.presentationml.slide": {
		"source": "iana",
		"extensions": ["sldx"]
	},
	"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
		"source": "iana",
		"extensions": ["ppsx"]
	},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.presentationml.template": {
		"source": "iana",
		"extensions": ["potx"]
	},
	"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
		"source": "iana",
		"compressible": false,
		"extensions": ["xlsx"]
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
		"source": "iana",
		"extensions": ["xltx"]
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.theme+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.vmldrawing": { "source": "iana" },
	"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
		"source": "iana",
		"compressible": false,
		"extensions": ["docx"]
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
		"source": "iana",
		"extensions": ["dotx"]
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-package.core-properties+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.openxmlformats-package.relationships+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oracle.resource+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.orange.indata": { "source": "iana" },
	"application/vnd.osa.netdeploy": { "source": "iana" },
	"application/vnd.osgeo.mapguide.package": {
		"source": "iana",
		"extensions": ["mgp"]
	},
	"application/vnd.osgi.bundle": { "source": "iana" },
	"application/vnd.osgi.dp": {
		"source": "iana",
		"extensions": ["dp"]
	},
	"application/vnd.osgi.subsystem": {
		"source": "iana",
		"extensions": ["esa"]
	},
	"application/vnd.otps.ct-kip+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.oxli.countgraph": { "source": "iana" },
	"application/vnd.pagerduty+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.palm": {
		"source": "iana",
		"extensions": [
			"pdb",
			"pqa",
			"oprc"
		]
	},
	"application/vnd.panoply": { "source": "iana" },
	"application/vnd.paos.xml": { "source": "iana" },
	"application/vnd.patentdive": { "source": "iana" },
	"application/vnd.patientecommsdoc": { "source": "iana" },
	"application/vnd.pawaafile": {
		"source": "iana",
		"extensions": ["paw"]
	},
	"application/vnd.pcos": { "source": "iana" },
	"application/vnd.pg.format": {
		"source": "iana",
		"extensions": ["str"]
	},
	"application/vnd.pg.osasli": {
		"source": "iana",
		"extensions": ["ei6"]
	},
	"application/vnd.piaccess.application-licence": { "source": "iana" },
	"application/vnd.picsel": {
		"source": "iana",
		"extensions": ["efif"]
	},
	"application/vnd.pmi.widget": {
		"source": "iana",
		"extensions": ["wg"]
	},
	"application/vnd.poc.group-advertisement+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.pocketlearn": {
		"source": "iana",
		"extensions": ["plf"]
	},
	"application/vnd.powerbuilder6": {
		"source": "iana",
		"extensions": ["pbd"]
	},
	"application/vnd.powerbuilder6-s": { "source": "iana" },
	"application/vnd.powerbuilder7": { "source": "iana" },
	"application/vnd.powerbuilder7-s": { "source": "iana" },
	"application/vnd.powerbuilder75": { "source": "iana" },
	"application/vnd.powerbuilder75-s": { "source": "iana" },
	"application/vnd.preminet": { "source": "iana" },
	"application/vnd.previewsystems.box": {
		"source": "iana",
		"extensions": ["box"]
	},
	"application/vnd.procrate.brushset": { "extensions": ["brushset"] },
	"application/vnd.procreate.brush": { "extensions": ["brush"] },
	"application/vnd.procreate.dream": { "extensions": ["drm"] },
	"application/vnd.proteus.magazine": {
		"source": "iana",
		"extensions": ["mgz"]
	},
	"application/vnd.psfs": { "source": "iana" },
	"application/vnd.pt.mundusmundi": { "source": "iana" },
	"application/vnd.publishare-delta-tree": {
		"source": "iana",
		"extensions": ["qps"]
	},
	"application/vnd.pvi.ptid1": {
		"source": "iana",
		"extensions": ["ptid"]
	},
	"application/vnd.pwg-multiplexed": { "source": "iana" },
	"application/vnd.pwg-xhtml-print+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["xhtm"]
	},
	"application/vnd.qualcomm.brew-app-res": { "source": "iana" },
	"application/vnd.quarantainenet": { "source": "iana" },
	"application/vnd.quark.quarkxpress": {
		"source": "iana",
		"extensions": [
			"qxd",
			"qxt",
			"qwd",
			"qwt",
			"qxl",
			"qxb"
		]
	},
	"application/vnd.quobject-quoxdocument": { "source": "iana" },
	"application/vnd.radisys.moml+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.radisys.msml+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.radisys.msml-audit+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.radisys.msml-audit-conf+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.radisys.msml-audit-conn+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.radisys.msml-audit-dialog+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.radisys.msml-audit-stream+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.radisys.msml-conf+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.radisys.msml-dialog+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.radisys.msml-dialog-base+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.radisys.msml-dialog-fax-detect+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.radisys.msml-dialog-group+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.radisys.msml-dialog-speech+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.radisys.msml-dialog-transform+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.rainstor.data": { "source": "iana" },
	"application/vnd.rapid": { "source": "iana" },
	"application/vnd.rar": {
		"source": "iana",
		"extensions": ["rar"]
	},
	"application/vnd.realvnc.bed": {
		"source": "iana",
		"extensions": ["bed"]
	},
	"application/vnd.recordare.musicxml": {
		"source": "iana",
		"extensions": ["mxl"]
	},
	"application/vnd.recordare.musicxml+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["musicxml"]
	},
	"application/vnd.relpipe": { "source": "iana" },
	"application/vnd.renlearn.rlprint": { "source": "iana" },
	"application/vnd.resilient.logic": { "source": "iana" },
	"application/vnd.restful+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.rig.cryptonote": {
		"source": "iana",
		"extensions": ["cryptonote"]
	},
	"application/vnd.rim.cod": {
		"source": "apache",
		"extensions": ["cod"]
	},
	"application/vnd.rn-realmedia": {
		"source": "apache",
		"extensions": ["rm"]
	},
	"application/vnd.rn-realmedia-vbr": {
		"source": "apache",
		"extensions": ["rmvb"]
	},
	"application/vnd.route66.link66+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["link66"]
	},
	"application/vnd.rs-274x": { "source": "iana" },
	"application/vnd.ruckus.download": { "source": "iana" },
	"application/vnd.s3sms": { "source": "iana" },
	"application/vnd.sailingtracker.track": {
		"source": "iana",
		"extensions": ["st"]
	},
	"application/vnd.sar": { "source": "iana" },
	"application/vnd.sbm.cid": { "source": "iana" },
	"application/vnd.sbm.mid2": { "source": "iana" },
	"application/vnd.scribus": { "source": "iana" },
	"application/vnd.sealed.3df": { "source": "iana" },
	"application/vnd.sealed.csf": { "source": "iana" },
	"application/vnd.sealed.doc": { "source": "iana" },
	"application/vnd.sealed.eml": { "source": "iana" },
	"application/vnd.sealed.mht": { "source": "iana" },
	"application/vnd.sealed.net": { "source": "iana" },
	"application/vnd.sealed.ppt": { "source": "iana" },
	"application/vnd.sealed.tiff": { "source": "iana" },
	"application/vnd.sealed.xls": { "source": "iana" },
	"application/vnd.sealedmedia.softseal.html": { "source": "iana" },
	"application/vnd.sealedmedia.softseal.pdf": { "source": "iana" },
	"application/vnd.seemail": {
		"source": "iana",
		"extensions": ["see"]
	},
	"application/vnd.seis+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.sema": {
		"source": "iana",
		"extensions": ["sema"]
	},
	"application/vnd.semd": {
		"source": "iana",
		"extensions": ["semd"]
	},
	"application/vnd.semf": {
		"source": "iana",
		"extensions": ["semf"]
	},
	"application/vnd.shade-save-file": { "source": "iana" },
	"application/vnd.shana.informed.formdata": {
		"source": "iana",
		"extensions": ["ifm"]
	},
	"application/vnd.shana.informed.formtemplate": {
		"source": "iana",
		"extensions": ["itp"]
	},
	"application/vnd.shana.informed.interchange": {
		"source": "iana",
		"extensions": ["iif"]
	},
	"application/vnd.shana.informed.package": {
		"source": "iana",
		"extensions": ["ipk"]
	},
	"application/vnd.shootproof+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.shopkick+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.shp": { "source": "iana" },
	"application/vnd.shx": { "source": "iana" },
	"application/vnd.sigrok.session": { "source": "iana" },
	"application/vnd.simtech-mindmapper": {
		"source": "iana",
		"extensions": ["twd", "twds"]
	},
	"application/vnd.siren+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.sketchometry": { "source": "iana" },
	"application/vnd.smaf": {
		"source": "iana",
		"extensions": ["mmf"]
	},
	"application/vnd.smart.notebook": { "source": "iana" },
	"application/vnd.smart.teacher": {
		"source": "iana",
		"extensions": ["teacher"]
	},
	"application/vnd.smintio.portals.archive": { "source": "iana" },
	"application/vnd.snesdev-page-table": { "source": "iana" },
	"application/vnd.software602.filler.form+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["fo"]
	},
	"application/vnd.software602.filler.form-xml-zip": { "source": "iana" },
	"application/vnd.solent.sdkm+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["sdkm", "sdkd"]
	},
	"application/vnd.spotfire.dxp": {
		"source": "iana",
		"extensions": ["dxp"]
	},
	"application/vnd.spotfire.sfs": {
		"source": "iana",
		"extensions": ["sfs"]
	},
	"application/vnd.sqlite3": { "source": "iana" },
	"application/vnd.sss-cod": { "source": "iana" },
	"application/vnd.sss-dtf": { "source": "iana" },
	"application/vnd.sss-ntf": { "source": "iana" },
	"application/vnd.stardivision.calc": {
		"source": "apache",
		"extensions": ["sdc"]
	},
	"application/vnd.stardivision.draw": {
		"source": "apache",
		"extensions": ["sda"]
	},
	"application/vnd.stardivision.impress": {
		"source": "apache",
		"extensions": ["sdd"]
	},
	"application/vnd.stardivision.math": {
		"source": "apache",
		"extensions": ["smf"]
	},
	"application/vnd.stardivision.writer": {
		"source": "apache",
		"extensions": ["sdw", "vor"]
	},
	"application/vnd.stardivision.writer-global": {
		"source": "apache",
		"extensions": ["sgl"]
	},
	"application/vnd.stepmania.package": {
		"source": "iana",
		"extensions": ["smzip"]
	},
	"application/vnd.stepmania.stepchart": {
		"source": "iana",
		"extensions": ["sm"]
	},
	"application/vnd.street-stream": { "source": "iana" },
	"application/vnd.sun.wadl+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["wadl"]
	},
	"application/vnd.sun.xml.calc": {
		"source": "apache",
		"extensions": ["sxc"]
	},
	"application/vnd.sun.xml.calc.template": {
		"source": "apache",
		"extensions": ["stc"]
	},
	"application/vnd.sun.xml.draw": {
		"source": "apache",
		"extensions": ["sxd"]
	},
	"application/vnd.sun.xml.draw.template": {
		"source": "apache",
		"extensions": ["std"]
	},
	"application/vnd.sun.xml.impress": {
		"source": "apache",
		"extensions": ["sxi"]
	},
	"application/vnd.sun.xml.impress.template": {
		"source": "apache",
		"extensions": ["sti"]
	},
	"application/vnd.sun.xml.math": {
		"source": "apache",
		"extensions": ["sxm"]
	},
	"application/vnd.sun.xml.writer": {
		"source": "apache",
		"extensions": ["sxw"]
	},
	"application/vnd.sun.xml.writer.global": {
		"source": "apache",
		"extensions": ["sxg"]
	},
	"application/vnd.sun.xml.writer.template": {
		"source": "apache",
		"extensions": ["stw"]
	},
	"application/vnd.sus-calendar": {
		"source": "iana",
		"extensions": ["sus", "susp"]
	},
	"application/vnd.svd": {
		"source": "iana",
		"extensions": ["svd"]
	},
	"application/vnd.swiftview-ics": { "source": "iana" },
	"application/vnd.sybyl.mol2": { "source": "iana" },
	"application/vnd.sycle+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.syft+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.symbian.install": {
		"source": "apache",
		"extensions": ["sis", "sisx"]
	},
	"application/vnd.syncml+xml": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true,
		"extensions": ["xsm"]
	},
	"application/vnd.syncml.dm+wbxml": {
		"source": "iana",
		"charset": "UTF-8",
		"extensions": ["bdm"]
	},
	"application/vnd.syncml.dm+xml": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true,
		"extensions": ["xdm"]
	},
	"application/vnd.syncml.dm.notification": { "source": "iana" },
	"application/vnd.syncml.dmddf+wbxml": { "source": "iana" },
	"application/vnd.syncml.dmddf+xml": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true,
		"extensions": ["ddf"]
	},
	"application/vnd.syncml.dmtnds+wbxml": { "source": "iana" },
	"application/vnd.syncml.dmtnds+xml": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true
	},
	"application/vnd.syncml.ds.notification": { "source": "iana" },
	"application/vnd.tableschema+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.tao.intent-module-archive": {
		"source": "iana",
		"extensions": ["tao"]
	},
	"application/vnd.tcpdump.pcap": {
		"source": "iana",
		"extensions": [
			"pcap",
			"cap",
			"dmp"
		]
	},
	"application/vnd.think-cell.ppttc+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.tmd.mediaflex.api+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.tml": { "source": "iana" },
	"application/vnd.tmobile-livetv": {
		"source": "iana",
		"extensions": ["tmo"]
	},
	"application/vnd.tri.onesource": { "source": "iana" },
	"application/vnd.trid.tpt": {
		"source": "iana",
		"extensions": ["tpt"]
	},
	"application/vnd.triscape.mxs": {
		"source": "iana",
		"extensions": ["mxs"]
	},
	"application/vnd.trueapp": {
		"source": "iana",
		"extensions": ["tra"]
	},
	"application/vnd.truedoc": { "source": "iana" },
	"application/vnd.ubisoft.webplayer": { "source": "iana" },
	"application/vnd.ufdl": {
		"source": "iana",
		"extensions": ["ufd", "ufdl"]
	},
	"application/vnd.uic.osdm+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.uiq.theme": {
		"source": "iana",
		"extensions": ["utz"]
	},
	"application/vnd.umajin": {
		"source": "iana",
		"extensions": ["umj"]
	},
	"application/vnd.unity": {
		"source": "iana",
		"extensions": ["unityweb"]
	},
	"application/vnd.uoml+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["uoml", "uo"]
	},
	"application/vnd.uplanet.alert": { "source": "iana" },
	"application/vnd.uplanet.alert-wbxml": { "source": "iana" },
	"application/vnd.uplanet.bearer-choice": { "source": "iana" },
	"application/vnd.uplanet.bearer-choice-wbxml": { "source": "iana" },
	"application/vnd.uplanet.cacheop": { "source": "iana" },
	"application/vnd.uplanet.cacheop-wbxml": { "source": "iana" },
	"application/vnd.uplanet.channel": { "source": "iana" },
	"application/vnd.uplanet.channel-wbxml": { "source": "iana" },
	"application/vnd.uplanet.list": { "source": "iana" },
	"application/vnd.uplanet.list-wbxml": { "source": "iana" },
	"application/vnd.uplanet.listcmd": { "source": "iana" },
	"application/vnd.uplanet.listcmd-wbxml": { "source": "iana" },
	"application/vnd.uplanet.signal": { "source": "iana" },
	"application/vnd.uri-map": { "source": "iana" },
	"application/vnd.valve.source.material": { "source": "iana" },
	"application/vnd.vcx": {
		"source": "iana",
		"extensions": ["vcx"]
	},
	"application/vnd.vd-study": { "source": "iana" },
	"application/vnd.vectorworks": { "source": "iana" },
	"application/vnd.vel+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.veraison.tsm-report+cbor": { "source": "iana" },
	"application/vnd.veraison.tsm-report+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.verimatrix.vcas": { "source": "iana" },
	"application/vnd.veritone.aion+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.veryant.thin": { "source": "iana" },
	"application/vnd.ves.encrypted": { "source": "iana" },
	"application/vnd.vidsoft.vidconference": { "source": "iana" },
	"application/vnd.visio": {
		"source": "iana",
		"extensions": [
			"vsd",
			"vst",
			"vss",
			"vsw",
			"vsdx",
			"vtx"
		]
	},
	"application/vnd.visionary": {
		"source": "iana",
		"extensions": ["vis"]
	},
	"application/vnd.vividence.scriptfile": { "source": "iana" },
	"application/vnd.vocalshaper.vsp4": { "source": "iana" },
	"application/vnd.vsf": {
		"source": "iana",
		"extensions": ["vsf"]
	},
	"application/vnd.wap.sic": { "source": "iana" },
	"application/vnd.wap.slc": { "source": "iana" },
	"application/vnd.wap.wbxml": {
		"source": "iana",
		"charset": "UTF-8",
		"extensions": ["wbxml"]
	},
	"application/vnd.wap.wmlc": {
		"source": "iana",
		"extensions": ["wmlc"]
	},
	"application/vnd.wap.wmlscriptc": {
		"source": "iana",
		"extensions": ["wmlsc"]
	},
	"application/vnd.wasmflow.wafl": { "source": "iana" },
	"application/vnd.webturbo": {
		"source": "iana",
		"extensions": ["wtb"]
	},
	"application/vnd.wfa.dpp": { "source": "iana" },
	"application/vnd.wfa.p2p": { "source": "iana" },
	"application/vnd.wfa.wsc": { "source": "iana" },
	"application/vnd.windows.devicepairing": { "source": "iana" },
	"application/vnd.wmc": { "source": "iana" },
	"application/vnd.wmf.bootstrap": { "source": "iana" },
	"application/vnd.wolfram.mathematica": { "source": "iana" },
	"application/vnd.wolfram.mathematica.package": { "source": "iana" },
	"application/vnd.wolfram.player": {
		"source": "iana",
		"extensions": ["nbp"]
	},
	"application/vnd.wordlift": { "source": "iana" },
	"application/vnd.wordperfect": {
		"source": "iana",
		"extensions": ["wpd"]
	},
	"application/vnd.wqd": {
		"source": "iana",
		"extensions": ["wqd"]
	},
	"application/vnd.wrq-hp3000-labelled": { "source": "iana" },
	"application/vnd.wt.stf": {
		"source": "iana",
		"extensions": ["stf"]
	},
	"application/vnd.wv.csp+wbxml": { "source": "iana" },
	"application/vnd.wv.csp+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.wv.ssp+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.xacml+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.xara": {
		"source": "iana",
		"extensions": ["xar"]
	},
	"application/vnd.xarin.cpj": { "source": "iana" },
	"application/vnd.xecrets-encrypted": { "source": "iana" },
	"application/vnd.xfdl": {
		"source": "iana",
		"extensions": ["xfdl"]
	},
	"application/vnd.xfdl.webform": { "source": "iana" },
	"application/vnd.xmi+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/vnd.xmpie.cpkg": { "source": "iana" },
	"application/vnd.xmpie.dpkg": { "source": "iana" },
	"application/vnd.xmpie.plan": { "source": "iana" },
	"application/vnd.xmpie.ppkg": { "source": "iana" },
	"application/vnd.xmpie.xlim": { "source": "iana" },
	"application/vnd.yamaha.hv-dic": {
		"source": "iana",
		"extensions": ["hvd"]
	},
	"application/vnd.yamaha.hv-script": {
		"source": "iana",
		"extensions": ["hvs"]
	},
	"application/vnd.yamaha.hv-voice": {
		"source": "iana",
		"extensions": ["hvp"]
	},
	"application/vnd.yamaha.openscoreformat": {
		"source": "iana",
		"extensions": ["osf"]
	},
	"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["osfpvg"]
	},
	"application/vnd.yamaha.remote-setup": { "source": "iana" },
	"application/vnd.yamaha.smaf-audio": {
		"source": "iana",
		"extensions": ["saf"]
	},
	"application/vnd.yamaha.smaf-phrase": {
		"source": "iana",
		"extensions": ["spf"]
	},
	"application/vnd.yamaha.through-ngn": { "source": "iana" },
	"application/vnd.yamaha.tunnel-udpencap": { "source": "iana" },
	"application/vnd.yaoweme": { "source": "iana" },
	"application/vnd.yellowriver-custom-menu": {
		"source": "iana",
		"extensions": ["cmp"]
	},
	"application/vnd.zul": {
		"source": "iana",
		"extensions": ["zir", "zirz"]
	},
	"application/vnd.zzazz.deck+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["zaz"]
	},
	"application/voicexml+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["vxml"]
	},
	"application/voucher-cms+json": {
		"source": "iana",
		"compressible": true
	},
	"application/voucher-jws+json": {
		"source": "iana",
		"compressible": true
	},
	"application/vp": { "source": "iana" },
	"application/vp+cose": { "source": "iana" },
	"application/vp+jwt": { "source": "iana" },
	"application/vq-rtcpxr": { "source": "iana" },
	"application/wasm": {
		"source": "iana",
		"compressible": true,
		"extensions": ["wasm"]
	},
	"application/watcherinfo+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["wif"]
	},
	"application/webpush-options+json": {
		"source": "iana",
		"compressible": true
	},
	"application/whoispp-query": { "source": "iana" },
	"application/whoispp-response": { "source": "iana" },
	"application/widget": {
		"source": "iana",
		"extensions": ["wgt"]
	},
	"application/winhlp": {
		"source": "apache",
		"extensions": ["hlp"]
	},
	"application/wita": { "source": "iana" },
	"application/wordperfect5.1": { "source": "iana" },
	"application/wsdl+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["wsdl"]
	},
	"application/wspolicy+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["wspolicy"]
	},
	"application/x-7z-compressed": {
		"source": "apache",
		"compressible": false,
		"extensions": ["7z"]
	},
	"application/x-abiword": {
		"source": "apache",
		"extensions": ["abw"]
	},
	"application/x-ace-compressed": {
		"source": "apache",
		"extensions": ["ace"]
	},
	"application/x-amf": { "source": "apache" },
	"application/x-apple-diskimage": {
		"source": "apache",
		"extensions": ["dmg"]
	},
	"application/x-arj": {
		"compressible": false,
		"extensions": ["arj"]
	},
	"application/x-authorware-bin": {
		"source": "apache",
		"extensions": [
			"aab",
			"x32",
			"u32",
			"vox"
		]
	},
	"application/x-authorware-map": {
		"source": "apache",
		"extensions": ["aam"]
	},
	"application/x-authorware-seg": {
		"source": "apache",
		"extensions": ["aas"]
	},
	"application/x-bcpio": {
		"source": "apache",
		"extensions": ["bcpio"]
	},
	"application/x-bdoc": {
		"compressible": false,
		"extensions": ["bdoc"]
	},
	"application/x-bittorrent": {
		"source": "apache",
		"extensions": ["torrent"]
	},
	"application/x-blender": { "extensions": ["blend"] },
	"application/x-blorb": {
		"source": "apache",
		"extensions": ["blb", "blorb"]
	},
	"application/x-bzip": {
		"source": "apache",
		"compressible": false,
		"extensions": ["bz"]
	},
	"application/x-bzip2": {
		"source": "apache",
		"compressible": false,
		"extensions": ["bz2", "boz"]
	},
	"application/x-cbr": {
		"source": "apache",
		"extensions": [
			"cbr",
			"cba",
			"cbt",
			"cbz",
			"cb7"
		]
	},
	"application/x-cdlink": {
		"source": "apache",
		"extensions": ["vcd"]
	},
	"application/x-cfs-compressed": {
		"source": "apache",
		"extensions": ["cfs"]
	},
	"application/x-chat": {
		"source": "apache",
		"extensions": ["chat"]
	},
	"application/x-chess-pgn": {
		"source": "apache",
		"extensions": ["pgn"]
	},
	"application/x-chrome-extension": { "extensions": ["crx"] },
	"application/x-cocoa": {
		"source": "nginx",
		"extensions": ["cco"]
	},
	"application/x-compress": { "source": "apache" },
	"application/x-compressed": { "extensions": ["rar"] },
	"application/x-conference": {
		"source": "apache",
		"extensions": ["nsc"]
	},
	"application/x-cpio": {
		"source": "apache",
		"extensions": ["cpio"]
	},
	"application/x-csh": {
		"source": "apache",
		"extensions": ["csh"]
	},
	"application/x-deb": { "compressible": false },
	"application/x-debian-package": {
		"source": "apache",
		"extensions": ["deb", "udeb"]
	},
	"application/x-dgc-compressed": {
		"source": "apache",
		"extensions": ["dgc"]
	},
	"application/x-director": {
		"source": "apache",
		"extensions": [
			"dir",
			"dcr",
			"dxr",
			"cst",
			"cct",
			"cxt",
			"w3d",
			"fgd",
			"swa"
		]
	},
	"application/x-doom": {
		"source": "apache",
		"extensions": ["wad"]
	},
	"application/x-dtbncx+xml": {
		"source": "apache",
		"compressible": true,
		"extensions": ["ncx"]
	},
	"application/x-dtbook+xml": {
		"source": "apache",
		"compressible": true,
		"extensions": ["dtb"]
	},
	"application/x-dtbresource+xml": {
		"source": "apache",
		"compressible": true,
		"extensions": ["res"]
	},
	"application/x-dvi": {
		"source": "apache",
		"compressible": false,
		"extensions": ["dvi"]
	},
	"application/x-envoy": {
		"source": "apache",
		"extensions": ["evy"]
	},
	"application/x-eva": {
		"source": "apache",
		"extensions": ["eva"]
	},
	"application/x-font-bdf": {
		"source": "apache",
		"extensions": ["bdf"]
	},
	"application/x-font-dos": { "source": "apache" },
	"application/x-font-framemaker": { "source": "apache" },
	"application/x-font-ghostscript": {
		"source": "apache",
		"extensions": ["gsf"]
	},
	"application/x-font-libgrx": { "source": "apache" },
	"application/x-font-linux-psf": {
		"source": "apache",
		"extensions": ["psf"]
	},
	"application/x-font-pcf": {
		"source": "apache",
		"extensions": ["pcf"]
	},
	"application/x-font-snf": {
		"source": "apache",
		"extensions": ["snf"]
	},
	"application/x-font-speedo": { "source": "apache" },
	"application/x-font-sunos-news": { "source": "apache" },
	"application/x-font-type1": {
		"source": "apache",
		"extensions": [
			"pfa",
			"pfb",
			"pfm",
			"afm"
		]
	},
	"application/x-font-vfont": { "source": "apache" },
	"application/x-freearc": {
		"source": "apache",
		"extensions": ["arc"]
	},
	"application/x-futuresplash": {
		"source": "apache",
		"extensions": ["spl"]
	},
	"application/x-gca-compressed": {
		"source": "apache",
		"extensions": ["gca"]
	},
	"application/x-glulx": {
		"source": "apache",
		"extensions": ["ulx"]
	},
	"application/x-gnumeric": {
		"source": "apache",
		"extensions": ["gnumeric"]
	},
	"application/x-gramps-xml": {
		"source": "apache",
		"extensions": ["gramps"]
	},
	"application/x-gtar": {
		"source": "apache",
		"extensions": ["gtar"]
	},
	"application/x-gzip": { "source": "apache" },
	"application/x-hdf": {
		"source": "apache",
		"extensions": ["hdf"]
	},
	"application/x-httpd-php": {
		"compressible": true,
		"extensions": ["php"]
	},
	"application/x-install-instructions": {
		"source": "apache",
		"extensions": ["install"]
	},
	"application/x-ipynb+json": {
		"compressible": true,
		"extensions": ["ipynb"]
	},
	"application/x-iso9660-image": {
		"source": "apache",
		"extensions": ["iso"]
	},
	"application/x-iwork-keynote-sffkey": { "extensions": ["key"] },
	"application/x-iwork-numbers-sffnumbers": { "extensions": ["numbers"] },
	"application/x-iwork-pages-sffpages": { "extensions": ["pages"] },
	"application/x-java-archive-diff": {
		"source": "nginx",
		"extensions": ["jardiff"]
	},
	"application/x-java-jnlp-file": {
		"source": "apache",
		"compressible": false,
		"extensions": ["jnlp"]
	},
	"application/x-javascript": { "compressible": true },
	"application/x-keepass2": { "extensions": ["kdbx"] },
	"application/x-latex": {
		"source": "apache",
		"compressible": false,
		"extensions": ["latex"]
	},
	"application/x-lua-bytecode": { "extensions": ["luac"] },
	"application/x-lzh-compressed": {
		"source": "apache",
		"extensions": ["lzh", "lha"]
	},
	"application/x-makeself": {
		"source": "nginx",
		"extensions": ["run"]
	},
	"application/x-mie": {
		"source": "apache",
		"extensions": ["mie"]
	},
	"application/x-mobipocket-ebook": {
		"source": "apache",
		"extensions": ["prc", "mobi"]
	},
	"application/x-mpegurl": { "compressible": false },
	"application/x-ms-application": {
		"source": "apache",
		"extensions": ["application"]
	},
	"application/x-ms-shortcut": {
		"source": "apache",
		"extensions": ["lnk"]
	},
	"application/x-ms-wmd": {
		"source": "apache",
		"extensions": ["wmd"]
	},
	"application/x-ms-wmz": {
		"source": "apache",
		"extensions": ["wmz"]
	},
	"application/x-ms-xbap": {
		"source": "apache",
		"extensions": ["xbap"]
	},
	"application/x-msaccess": {
		"source": "apache",
		"extensions": ["mdb"]
	},
	"application/x-msbinder": {
		"source": "apache",
		"extensions": ["obd"]
	},
	"application/x-mscardfile": {
		"source": "apache",
		"extensions": ["crd"]
	},
	"application/x-msclip": {
		"source": "apache",
		"extensions": ["clp"]
	},
	"application/x-msdos-program": { "extensions": ["exe"] },
	"application/x-msdownload": {
		"source": "apache",
		"extensions": [
			"exe",
			"dll",
			"com",
			"bat",
			"msi"
		]
	},
	"application/x-msmediaview": {
		"source": "apache",
		"extensions": [
			"mvb",
			"m13",
			"m14"
		]
	},
	"application/x-msmetafile": {
		"source": "apache",
		"extensions": [
			"wmf",
			"wmz",
			"emf",
			"emz"
		]
	},
	"application/x-msmoney": {
		"source": "apache",
		"extensions": ["mny"]
	},
	"application/x-mspublisher": {
		"source": "apache",
		"extensions": ["pub"]
	},
	"application/x-msschedule": {
		"source": "apache",
		"extensions": ["scd"]
	},
	"application/x-msterminal": {
		"source": "apache",
		"extensions": ["trm"]
	},
	"application/x-mswrite": {
		"source": "apache",
		"extensions": ["wri"]
	},
	"application/x-netcdf": {
		"source": "apache",
		"extensions": ["nc", "cdf"]
	},
	"application/x-ns-proxy-autoconfig": {
		"compressible": true,
		"extensions": ["pac"]
	},
	"application/x-nzb": {
		"source": "apache",
		"extensions": ["nzb"]
	},
	"application/x-perl": {
		"source": "nginx",
		"extensions": ["pl", "pm"]
	},
	"application/x-pilot": {
		"source": "nginx",
		"extensions": ["prc", "pdb"]
	},
	"application/x-pkcs12": {
		"source": "apache",
		"compressible": false,
		"extensions": ["p12", "pfx"]
	},
	"application/x-pkcs7-certificates": {
		"source": "apache",
		"extensions": ["p7b", "spc"]
	},
	"application/x-pkcs7-certreqresp": {
		"source": "apache",
		"extensions": ["p7r"]
	},
	"application/x-pki-message": { "source": "iana" },
	"application/x-rar-compressed": {
		"source": "apache",
		"compressible": false,
		"extensions": ["rar"]
	},
	"application/x-redhat-package-manager": {
		"source": "nginx",
		"extensions": ["rpm"]
	},
	"application/x-research-info-systems": {
		"source": "apache",
		"extensions": ["ris"]
	},
	"application/x-sea": {
		"source": "nginx",
		"extensions": ["sea"]
	},
	"application/x-sh": {
		"source": "apache",
		"compressible": true,
		"extensions": ["sh"]
	},
	"application/x-shar": {
		"source": "apache",
		"extensions": ["shar"]
	},
	"application/x-shockwave-flash": {
		"source": "apache",
		"compressible": false,
		"extensions": ["swf"]
	},
	"application/x-silverlight-app": {
		"source": "apache",
		"extensions": ["xap"]
	},
	"application/x-sql": {
		"source": "apache",
		"extensions": ["sql"]
	},
	"application/x-stuffit": {
		"source": "apache",
		"compressible": false,
		"extensions": ["sit"]
	},
	"application/x-stuffitx": {
		"source": "apache",
		"extensions": ["sitx"]
	},
	"application/x-subrip": {
		"source": "apache",
		"extensions": ["srt"]
	},
	"application/x-sv4cpio": {
		"source": "apache",
		"extensions": ["sv4cpio"]
	},
	"application/x-sv4crc": {
		"source": "apache",
		"extensions": ["sv4crc"]
	},
	"application/x-t3vm-image": {
		"source": "apache",
		"extensions": ["t3"]
	},
	"application/x-tads": {
		"source": "apache",
		"extensions": ["gam"]
	},
	"application/x-tar": {
		"source": "apache",
		"compressible": true,
		"extensions": ["tar"]
	},
	"application/x-tcl": {
		"source": "apache",
		"extensions": ["tcl", "tk"]
	},
	"application/x-tex": {
		"source": "apache",
		"extensions": ["tex"]
	},
	"application/x-tex-tfm": {
		"source": "apache",
		"extensions": ["tfm"]
	},
	"application/x-texinfo": {
		"source": "apache",
		"extensions": ["texinfo", "texi"]
	},
	"application/x-tgif": {
		"source": "apache",
		"extensions": ["obj"]
	},
	"application/x-ustar": {
		"source": "apache",
		"extensions": ["ustar"]
	},
	"application/x-virtualbox-hdd": {
		"compressible": true,
		"extensions": ["hdd"]
	},
	"application/x-virtualbox-ova": {
		"compressible": true,
		"extensions": ["ova"]
	},
	"application/x-virtualbox-ovf": {
		"compressible": true,
		"extensions": ["ovf"]
	},
	"application/x-virtualbox-vbox": {
		"compressible": true,
		"extensions": ["vbox"]
	},
	"application/x-virtualbox-vbox-extpack": {
		"compressible": false,
		"extensions": ["vbox-extpack"]
	},
	"application/x-virtualbox-vdi": {
		"compressible": true,
		"extensions": ["vdi"]
	},
	"application/x-virtualbox-vhd": {
		"compressible": true,
		"extensions": ["vhd"]
	},
	"application/x-virtualbox-vmdk": {
		"compressible": true,
		"extensions": ["vmdk"]
	},
	"application/x-wais-source": {
		"source": "apache",
		"extensions": ["src"]
	},
	"application/x-web-app-manifest+json": {
		"compressible": true,
		"extensions": ["webapp"]
	},
	"application/x-www-form-urlencoded": {
		"source": "iana",
		"compressible": true
	},
	"application/x-x509-ca-cert": {
		"source": "iana",
		"extensions": [
			"der",
			"crt",
			"pem"
		]
	},
	"application/x-x509-ca-ra-cert": { "source": "iana" },
	"application/x-x509-next-ca-cert": { "source": "iana" },
	"application/x-xfig": {
		"source": "apache",
		"extensions": ["fig"]
	},
	"application/x-xliff+xml": {
		"source": "apache",
		"compressible": true,
		"extensions": ["xlf"]
	},
	"application/x-xpinstall": {
		"source": "apache",
		"compressible": false,
		"extensions": ["xpi"]
	},
	"application/x-xz": {
		"source": "apache",
		"extensions": ["xz"]
	},
	"application/x-zip-compressed": { "extensions": ["zip"] },
	"application/x-zmachine": {
		"source": "apache",
		"extensions": [
			"z1",
			"z2",
			"z3",
			"z4",
			"z5",
			"z6",
			"z7",
			"z8"
		]
	},
	"application/x400-bp": { "source": "iana" },
	"application/xacml+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/xaml+xml": {
		"source": "apache",
		"compressible": true,
		"extensions": ["xaml"]
	},
	"application/xcap-att+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["xav"]
	},
	"application/xcap-caps+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["xca"]
	},
	"application/xcap-diff+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["xdf"]
	},
	"application/xcap-el+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["xel"]
	},
	"application/xcap-error+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/xcap-ns+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["xns"]
	},
	"application/xcon-conference-info+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/xcon-conference-info-diff+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/xenc+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["xenc"]
	},
	"application/xfdf": {
		"source": "iana",
		"extensions": ["xfdf"]
	},
	"application/xhtml+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["xhtml", "xht"]
	},
	"application/xhtml-voice+xml": {
		"source": "apache",
		"compressible": true
	},
	"application/xliff+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["xlf"]
	},
	"application/xml": {
		"source": "iana",
		"compressible": true,
		"extensions": [
			"xml",
			"xsl",
			"xsd",
			"rng"
		]
	},
	"application/xml-dtd": {
		"source": "iana",
		"compressible": true,
		"extensions": ["dtd"]
	},
	"application/xml-external-parsed-entity": { "source": "iana" },
	"application/xml-patch+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/xmpp+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/xop+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["xop"]
	},
	"application/xproc+xml": {
		"source": "apache",
		"compressible": true,
		"extensions": ["xpl"]
	},
	"application/xslt+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["xsl", "xslt"]
	},
	"application/xspf+xml": {
		"source": "apache",
		"compressible": true,
		"extensions": ["xspf"]
	},
	"application/xv+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": [
			"mxml",
			"xhvml",
			"xvml",
			"xvm"
		]
	},
	"application/yaml": { "source": "iana" },
	"application/yang": {
		"source": "iana",
		"extensions": ["yang"]
	},
	"application/yang-data+cbor": { "source": "iana" },
	"application/yang-data+json": {
		"source": "iana",
		"compressible": true
	},
	"application/yang-data+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/yang-patch+json": {
		"source": "iana",
		"compressible": true
	},
	"application/yang-patch+xml": {
		"source": "iana",
		"compressible": true
	},
	"application/yang-sid+json": {
		"source": "iana",
		"compressible": true
	},
	"application/yin+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["yin"]
	},
	"application/zip": {
		"source": "iana",
		"compressible": false,
		"extensions": ["zip"]
	},
	"application/zip+dotlottie": { "extensions": ["lottie"] },
	"application/zlib": { "source": "iana" },
	"application/zstd": { "source": "iana" },
	"audio/1d-interleaved-parityfec": { "source": "iana" },
	"audio/32kadpcm": { "source": "iana" },
	"audio/3gpp": {
		"source": "iana",
		"compressible": false,
		"extensions": ["3gpp"]
	},
	"audio/3gpp2": { "source": "iana" },
	"audio/aac": {
		"source": "iana",
		"extensions": ["adts", "aac"]
	},
	"audio/ac3": { "source": "iana" },
	"audio/adpcm": {
		"source": "apache",
		"extensions": ["adp"]
	},
	"audio/amr": {
		"source": "iana",
		"extensions": ["amr"]
	},
	"audio/amr-wb": { "source": "iana" },
	"audio/amr-wb+": { "source": "iana" },
	"audio/aptx": { "source": "iana" },
	"audio/asc": { "source": "iana" },
	"audio/atrac-advanced-lossless": { "source": "iana" },
	"audio/atrac-x": { "source": "iana" },
	"audio/atrac3": { "source": "iana" },
	"audio/basic": {
		"source": "iana",
		"compressible": false,
		"extensions": ["au", "snd"]
	},
	"audio/bv16": { "source": "iana" },
	"audio/bv32": { "source": "iana" },
	"audio/clearmode": { "source": "iana" },
	"audio/cn": { "source": "iana" },
	"audio/dat12": { "source": "iana" },
	"audio/dls": { "source": "iana" },
	"audio/dsr-es201108": { "source": "iana" },
	"audio/dsr-es202050": { "source": "iana" },
	"audio/dsr-es202211": { "source": "iana" },
	"audio/dsr-es202212": { "source": "iana" },
	"audio/dv": { "source": "iana" },
	"audio/dvi4": { "source": "iana" },
	"audio/eac3": { "source": "iana" },
	"audio/encaprtp": { "source": "iana" },
	"audio/evrc": { "source": "iana" },
	"audio/evrc-qcp": { "source": "iana" },
	"audio/evrc0": { "source": "iana" },
	"audio/evrc1": { "source": "iana" },
	"audio/evrcb": { "source": "iana" },
	"audio/evrcb0": { "source": "iana" },
	"audio/evrcb1": { "source": "iana" },
	"audio/evrcnw": { "source": "iana" },
	"audio/evrcnw0": { "source": "iana" },
	"audio/evrcnw1": { "source": "iana" },
	"audio/evrcwb": { "source": "iana" },
	"audio/evrcwb0": { "source": "iana" },
	"audio/evrcwb1": { "source": "iana" },
	"audio/evs": { "source": "iana" },
	"audio/flac": { "source": "iana" },
	"audio/flexfec": { "source": "iana" },
	"audio/fwdred": { "source": "iana" },
	"audio/g711-0": { "source": "iana" },
	"audio/g719": { "source": "iana" },
	"audio/g722": { "source": "iana" },
	"audio/g7221": { "source": "iana" },
	"audio/g723": { "source": "iana" },
	"audio/g726-16": { "source": "iana" },
	"audio/g726-24": { "source": "iana" },
	"audio/g726-32": { "source": "iana" },
	"audio/g726-40": { "source": "iana" },
	"audio/g728": { "source": "iana" },
	"audio/g729": { "source": "iana" },
	"audio/g7291": { "source": "iana" },
	"audio/g729d": { "source": "iana" },
	"audio/g729e": { "source": "iana" },
	"audio/gsm": { "source": "iana" },
	"audio/gsm-efr": { "source": "iana" },
	"audio/gsm-hr-08": { "source": "iana" },
	"audio/ilbc": { "source": "iana" },
	"audio/ip-mr_v2.5": { "source": "iana" },
	"audio/isac": { "source": "apache" },
	"audio/l16": { "source": "iana" },
	"audio/l20": { "source": "iana" },
	"audio/l24": {
		"source": "iana",
		"compressible": false
	},
	"audio/l8": { "source": "iana" },
	"audio/lpc": { "source": "iana" },
	"audio/matroska": { "source": "iana" },
	"audio/melp": { "source": "iana" },
	"audio/melp1200": { "source": "iana" },
	"audio/melp2400": { "source": "iana" },
	"audio/melp600": { "source": "iana" },
	"audio/mhas": { "source": "iana" },
	"audio/midi": {
		"source": "apache",
		"extensions": [
			"mid",
			"midi",
			"kar",
			"rmi"
		]
	},
	"audio/midi-clip": { "source": "iana" },
	"audio/mobile-xmf": {
		"source": "iana",
		"extensions": ["mxmf"]
	},
	"audio/mp3": {
		"compressible": false,
		"extensions": ["mp3"]
	},
	"audio/mp4": {
		"source": "iana",
		"compressible": false,
		"extensions": [
			"m4a",
			"mp4a",
			"m4b"
		]
	},
	"audio/mp4a-latm": { "source": "iana" },
	"audio/mpa": { "source": "iana" },
	"audio/mpa-robust": { "source": "iana" },
	"audio/mpeg": {
		"source": "iana",
		"compressible": false,
		"extensions": [
			"mpga",
			"mp2",
			"mp2a",
			"mp3",
			"m2a",
			"m3a"
		]
	},
	"audio/mpeg4-generic": { "source": "iana" },
	"audio/musepack": { "source": "apache" },
	"audio/ogg": {
		"source": "iana",
		"compressible": false,
		"extensions": [
			"oga",
			"ogg",
			"spx",
			"opus"
		]
	},
	"audio/opus": { "source": "iana" },
	"audio/parityfec": { "source": "iana" },
	"audio/pcma": { "source": "iana" },
	"audio/pcma-wb": { "source": "iana" },
	"audio/pcmu": { "source": "iana" },
	"audio/pcmu-wb": { "source": "iana" },
	"audio/prs.sid": { "source": "iana" },
	"audio/qcelp": { "source": "iana" },
	"audio/raptorfec": { "source": "iana" },
	"audio/red": { "source": "iana" },
	"audio/rtp-enc-aescm128": { "source": "iana" },
	"audio/rtp-midi": { "source": "iana" },
	"audio/rtploopback": { "source": "iana" },
	"audio/rtx": { "source": "iana" },
	"audio/s3m": {
		"source": "apache",
		"extensions": ["s3m"]
	},
	"audio/scip": { "source": "iana" },
	"audio/silk": {
		"source": "apache",
		"extensions": ["sil"]
	},
	"audio/smv": { "source": "iana" },
	"audio/smv-qcp": { "source": "iana" },
	"audio/smv0": { "source": "iana" },
	"audio/sofa": { "source": "iana" },
	"audio/sp-midi": { "source": "iana" },
	"audio/speex": { "source": "iana" },
	"audio/t140c": { "source": "iana" },
	"audio/t38": { "source": "iana" },
	"audio/telephone-event": { "source": "iana" },
	"audio/tetra_acelp": { "source": "iana" },
	"audio/tetra_acelp_bb": { "source": "iana" },
	"audio/tone": { "source": "iana" },
	"audio/tsvcis": { "source": "iana" },
	"audio/uemclip": { "source": "iana" },
	"audio/ulpfec": { "source": "iana" },
	"audio/usac": { "source": "iana" },
	"audio/vdvi": { "source": "iana" },
	"audio/vmr-wb": { "source": "iana" },
	"audio/vnd.3gpp.iufp": { "source": "iana" },
	"audio/vnd.4sb": { "source": "iana" },
	"audio/vnd.audiokoz": { "source": "iana" },
	"audio/vnd.celp": { "source": "iana" },
	"audio/vnd.cisco.nse": { "source": "iana" },
	"audio/vnd.cmles.radio-events": { "source": "iana" },
	"audio/vnd.cns.anp1": { "source": "iana" },
	"audio/vnd.cns.inf1": { "source": "iana" },
	"audio/vnd.dece.audio": {
		"source": "iana",
		"extensions": ["uva", "uvva"]
	},
	"audio/vnd.digital-winds": {
		"source": "iana",
		"extensions": ["eol"]
	},
	"audio/vnd.dlna.adts": { "source": "iana" },
	"audio/vnd.dolby.heaac.1": { "source": "iana" },
	"audio/vnd.dolby.heaac.2": { "source": "iana" },
	"audio/vnd.dolby.mlp": { "source": "iana" },
	"audio/vnd.dolby.mps": { "source": "iana" },
	"audio/vnd.dolby.pl2": { "source": "iana" },
	"audio/vnd.dolby.pl2x": { "source": "iana" },
	"audio/vnd.dolby.pl2z": { "source": "iana" },
	"audio/vnd.dolby.pulse.1": { "source": "iana" },
	"audio/vnd.dra": {
		"source": "iana",
		"extensions": ["dra"]
	},
	"audio/vnd.dts": {
		"source": "iana",
		"extensions": ["dts"]
	},
	"audio/vnd.dts.hd": {
		"source": "iana",
		"extensions": ["dtshd"]
	},
	"audio/vnd.dts.uhd": { "source": "iana" },
	"audio/vnd.dvb.file": { "source": "iana" },
	"audio/vnd.everad.plj": { "source": "iana" },
	"audio/vnd.hns.audio": { "source": "iana" },
	"audio/vnd.lucent.voice": {
		"source": "iana",
		"extensions": ["lvp"]
	},
	"audio/vnd.ms-playready.media.pya": {
		"source": "iana",
		"extensions": ["pya"]
	},
	"audio/vnd.nokia.mobile-xmf": { "source": "iana" },
	"audio/vnd.nortel.vbk": { "source": "iana" },
	"audio/vnd.nuera.ecelp4800": {
		"source": "iana",
		"extensions": ["ecelp4800"]
	},
	"audio/vnd.nuera.ecelp7470": {
		"source": "iana",
		"extensions": ["ecelp7470"]
	},
	"audio/vnd.nuera.ecelp9600": {
		"source": "iana",
		"extensions": ["ecelp9600"]
	},
	"audio/vnd.octel.sbc": { "source": "iana" },
	"audio/vnd.presonus.multitrack": { "source": "iana" },
	"audio/vnd.qcelp": { "source": "apache" },
	"audio/vnd.rhetorex.32kadpcm": { "source": "iana" },
	"audio/vnd.rip": {
		"source": "iana",
		"extensions": ["rip"]
	},
	"audio/vnd.rn-realaudio": { "compressible": false },
	"audio/vnd.sealedmedia.softseal.mpeg": { "source": "iana" },
	"audio/vnd.vmx.cvsd": { "source": "iana" },
	"audio/vnd.wave": { "compressible": false },
	"audio/vorbis": {
		"source": "iana",
		"compressible": false
	},
	"audio/vorbis-config": { "source": "iana" },
	"audio/wav": {
		"compressible": false,
		"extensions": ["wav"]
	},
	"audio/wave": {
		"compressible": false,
		"extensions": ["wav"]
	},
	"audio/webm": {
		"source": "apache",
		"compressible": false,
		"extensions": ["weba"]
	},
	"audio/x-aac": {
		"source": "apache",
		"compressible": false,
		"extensions": ["aac"]
	},
	"audio/x-aiff": {
		"source": "apache",
		"extensions": [
			"aif",
			"aiff",
			"aifc"
		]
	},
	"audio/x-caf": {
		"source": "apache",
		"compressible": false,
		"extensions": ["caf"]
	},
	"audio/x-flac": {
		"source": "apache",
		"extensions": ["flac"]
	},
	"audio/x-m4a": {
		"source": "nginx",
		"extensions": ["m4a"]
	},
	"audio/x-matroska": {
		"source": "apache",
		"extensions": ["mka"]
	},
	"audio/x-mpegurl": {
		"source": "apache",
		"extensions": ["m3u"]
	},
	"audio/x-ms-wax": {
		"source": "apache",
		"extensions": ["wax"]
	},
	"audio/x-ms-wma": {
		"source": "apache",
		"extensions": ["wma"]
	},
	"audio/x-pn-realaudio": {
		"source": "apache",
		"extensions": ["ram", "ra"]
	},
	"audio/x-pn-realaudio-plugin": {
		"source": "apache",
		"extensions": ["rmp"]
	},
	"audio/x-realaudio": {
		"source": "nginx",
		"extensions": ["ra"]
	},
	"audio/x-tta": { "source": "apache" },
	"audio/x-wav": {
		"source": "apache",
		"extensions": ["wav"]
	},
	"audio/xm": {
		"source": "apache",
		"extensions": ["xm"]
	},
	"chemical/x-cdx": {
		"source": "apache",
		"extensions": ["cdx"]
	},
	"chemical/x-cif": {
		"source": "apache",
		"extensions": ["cif"]
	},
	"chemical/x-cmdf": {
		"source": "apache",
		"extensions": ["cmdf"]
	},
	"chemical/x-cml": {
		"source": "apache",
		"extensions": ["cml"]
	},
	"chemical/x-csml": {
		"source": "apache",
		"extensions": ["csml"]
	},
	"chemical/x-pdb": { "source": "apache" },
	"chemical/x-xyz": {
		"source": "apache",
		"extensions": ["xyz"]
	},
	"font/collection": {
		"source": "iana",
		"extensions": ["ttc"]
	},
	"font/otf": {
		"source": "iana",
		"compressible": true,
		"extensions": ["otf"]
	},
	"font/sfnt": { "source": "iana" },
	"font/ttf": {
		"source": "iana",
		"compressible": true,
		"extensions": ["ttf"]
	},
	"font/woff": {
		"source": "iana",
		"extensions": ["woff"]
	},
	"font/woff2": {
		"source": "iana",
		"extensions": ["woff2"]
	},
	"image/aces": {
		"source": "iana",
		"extensions": ["exr"]
	},
	"image/apng": {
		"source": "iana",
		"compressible": false,
		"extensions": ["apng"]
	},
	"image/avci": {
		"source": "iana",
		"extensions": ["avci"]
	},
	"image/avcs": {
		"source": "iana",
		"extensions": ["avcs"]
	},
	"image/avif": {
		"source": "iana",
		"compressible": false,
		"extensions": ["avif"]
	},
	"image/bmp": {
		"source": "iana",
		"compressible": true,
		"extensions": ["bmp", "dib"]
	},
	"image/cgm": {
		"source": "iana",
		"extensions": ["cgm"]
	},
	"image/dicom-rle": {
		"source": "iana",
		"extensions": ["drle"]
	},
	"image/dpx": {
		"source": "iana",
		"extensions": ["dpx"]
	},
	"image/emf": {
		"source": "iana",
		"extensions": ["emf"]
	},
	"image/fits": {
		"source": "iana",
		"extensions": ["fits"]
	},
	"image/g3fax": {
		"source": "iana",
		"extensions": ["g3"]
	},
	"image/gif": {
		"source": "iana",
		"compressible": false,
		"extensions": ["gif"]
	},
	"image/heic": {
		"source": "iana",
		"extensions": ["heic"]
	},
	"image/heic-sequence": {
		"source": "iana",
		"extensions": ["heics"]
	},
	"image/heif": {
		"source": "iana",
		"extensions": ["heif"]
	},
	"image/heif-sequence": {
		"source": "iana",
		"extensions": ["heifs"]
	},
	"image/hej2k": {
		"source": "iana",
		"extensions": ["hej2"]
	},
	"image/ief": {
		"source": "iana",
		"extensions": ["ief"]
	},
	"image/j2c": { "source": "iana" },
	"image/jaii": {
		"source": "iana",
		"extensions": ["jaii"]
	},
	"image/jais": {
		"source": "iana",
		"extensions": ["jais"]
	},
	"image/jls": {
		"source": "iana",
		"extensions": ["jls"]
	},
	"image/jp2": {
		"source": "iana",
		"compressible": false,
		"extensions": ["jp2", "jpg2"]
	},
	"image/jpeg": {
		"source": "iana",
		"compressible": false,
		"extensions": [
			"jpg",
			"jpeg",
			"jpe"
		]
	},
	"image/jph": {
		"source": "iana",
		"extensions": ["jph"]
	},
	"image/jphc": {
		"source": "iana",
		"extensions": ["jhc"]
	},
	"image/jpm": {
		"source": "iana",
		"compressible": false,
		"extensions": ["jpm", "jpgm"]
	},
	"image/jpx": {
		"source": "iana",
		"compressible": false,
		"extensions": ["jpx", "jpf"]
	},
	"image/jxl": {
		"source": "iana",
		"extensions": ["jxl"]
	},
	"image/jxr": {
		"source": "iana",
		"extensions": ["jxr"]
	},
	"image/jxra": {
		"source": "iana",
		"extensions": ["jxra"]
	},
	"image/jxrs": {
		"source": "iana",
		"extensions": ["jxrs"]
	},
	"image/jxs": {
		"source": "iana",
		"extensions": ["jxs"]
	},
	"image/jxsc": {
		"source": "iana",
		"extensions": ["jxsc"]
	},
	"image/jxsi": {
		"source": "iana",
		"extensions": ["jxsi"]
	},
	"image/jxss": {
		"source": "iana",
		"extensions": ["jxss"]
	},
	"image/ktx": {
		"source": "iana",
		"extensions": ["ktx"]
	},
	"image/ktx2": {
		"source": "iana",
		"extensions": ["ktx2"]
	},
	"image/naplps": { "source": "iana" },
	"image/pjpeg": {
		"compressible": false,
		"extensions": ["jfif"]
	},
	"image/png": {
		"source": "iana",
		"compressible": false,
		"extensions": ["png"]
	},
	"image/prs.btif": {
		"source": "iana",
		"extensions": ["btif", "btf"]
	},
	"image/prs.pti": {
		"source": "iana",
		"extensions": ["pti"]
	},
	"image/pwg-raster": { "source": "iana" },
	"image/sgi": {
		"source": "apache",
		"extensions": ["sgi"]
	},
	"image/svg+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["svg", "svgz"]
	},
	"image/t38": {
		"source": "iana",
		"extensions": ["t38"]
	},
	"image/tiff": {
		"source": "iana",
		"compressible": false,
		"extensions": ["tif", "tiff"]
	},
	"image/tiff-fx": {
		"source": "iana",
		"extensions": ["tfx"]
	},
	"image/vnd.adobe.photoshop": {
		"source": "iana",
		"compressible": true,
		"extensions": ["psd"]
	},
	"image/vnd.airzip.accelerator.azv": {
		"source": "iana",
		"extensions": ["azv"]
	},
	"image/vnd.clip": { "source": "iana" },
	"image/vnd.cns.inf2": { "source": "iana" },
	"image/vnd.dece.graphic": {
		"source": "iana",
		"extensions": [
			"uvi",
			"uvvi",
			"uvg",
			"uvvg"
		]
	},
	"image/vnd.djvu": {
		"source": "iana",
		"extensions": ["djvu", "djv"]
	},
	"image/vnd.dvb.subtitle": {
		"source": "iana",
		"extensions": ["sub"]
	},
	"image/vnd.dwg": {
		"source": "iana",
		"extensions": ["dwg"]
	},
	"image/vnd.dxf": {
		"source": "iana",
		"extensions": ["dxf"]
	},
	"image/vnd.fastbidsheet": {
		"source": "iana",
		"extensions": ["fbs"]
	},
	"image/vnd.fpx": {
		"source": "iana",
		"extensions": ["fpx"]
	},
	"image/vnd.fst": {
		"source": "iana",
		"extensions": ["fst"]
	},
	"image/vnd.fujixerox.edmics-mmr": {
		"source": "iana",
		"extensions": ["mmr"]
	},
	"image/vnd.fujixerox.edmics-rlc": {
		"source": "iana",
		"extensions": ["rlc"]
	},
	"image/vnd.globalgraphics.pgb": { "source": "iana" },
	"image/vnd.microsoft.icon": {
		"source": "iana",
		"compressible": true,
		"extensions": ["ico"]
	},
	"image/vnd.mix": { "source": "iana" },
	"image/vnd.mozilla.apng": { "source": "iana" },
	"image/vnd.ms-dds": {
		"compressible": true,
		"extensions": ["dds"]
	},
	"image/vnd.ms-modi": {
		"source": "iana",
		"extensions": ["mdi"]
	},
	"image/vnd.ms-photo": {
		"source": "apache",
		"extensions": ["wdp"]
	},
	"image/vnd.net-fpx": {
		"source": "iana",
		"extensions": ["npx"]
	},
	"image/vnd.pco.b16": {
		"source": "iana",
		"extensions": ["b16"]
	},
	"image/vnd.radiance": { "source": "iana" },
	"image/vnd.sealed.png": { "source": "iana" },
	"image/vnd.sealedmedia.softseal.gif": { "source": "iana" },
	"image/vnd.sealedmedia.softseal.jpg": { "source": "iana" },
	"image/vnd.svf": { "source": "iana" },
	"image/vnd.tencent.tap": {
		"source": "iana",
		"extensions": ["tap"]
	},
	"image/vnd.valve.source.texture": {
		"source": "iana",
		"extensions": ["vtf"]
	},
	"image/vnd.wap.wbmp": {
		"source": "iana",
		"extensions": ["wbmp"]
	},
	"image/vnd.xiff": {
		"source": "iana",
		"extensions": ["xif"]
	},
	"image/vnd.zbrush.pcx": {
		"source": "iana",
		"extensions": ["pcx"]
	},
	"image/webp": {
		"source": "iana",
		"extensions": ["webp"]
	},
	"image/wmf": {
		"source": "iana",
		"extensions": ["wmf"]
	},
	"image/x-3ds": {
		"source": "apache",
		"extensions": ["3ds"]
	},
	"image/x-adobe-dng": { "extensions": ["dng"] },
	"image/x-cmu-raster": {
		"source": "apache",
		"extensions": ["ras"]
	},
	"image/x-cmx": {
		"source": "apache",
		"extensions": ["cmx"]
	},
	"image/x-emf": { "source": "iana" },
	"image/x-freehand": {
		"source": "apache",
		"extensions": [
			"fh",
			"fhc",
			"fh4",
			"fh5",
			"fh7"
		]
	},
	"image/x-icon": {
		"source": "apache",
		"compressible": true,
		"extensions": ["ico"]
	},
	"image/x-jng": {
		"source": "nginx",
		"extensions": ["jng"]
	},
	"image/x-mrsid-image": {
		"source": "apache",
		"extensions": ["sid"]
	},
	"image/x-ms-bmp": {
		"source": "nginx",
		"compressible": true,
		"extensions": ["bmp"]
	},
	"image/x-pcx": {
		"source": "apache",
		"extensions": ["pcx"]
	},
	"image/x-pict": {
		"source": "apache",
		"extensions": ["pic", "pct"]
	},
	"image/x-portable-anymap": {
		"source": "apache",
		"extensions": ["pnm"]
	},
	"image/x-portable-bitmap": {
		"source": "apache",
		"extensions": ["pbm"]
	},
	"image/x-portable-graymap": {
		"source": "apache",
		"extensions": ["pgm"]
	},
	"image/x-portable-pixmap": {
		"source": "apache",
		"extensions": ["ppm"]
	},
	"image/x-rgb": {
		"source": "apache",
		"extensions": ["rgb"]
	},
	"image/x-tga": {
		"source": "apache",
		"extensions": ["tga"]
	},
	"image/x-wmf": { "source": "iana" },
	"image/x-xbitmap": {
		"source": "apache",
		"extensions": ["xbm"]
	},
	"image/x-xcf": { "compressible": false },
	"image/x-xpixmap": {
		"source": "apache",
		"extensions": ["xpm"]
	},
	"image/x-xwindowdump": {
		"source": "apache",
		"extensions": ["xwd"]
	},
	"message/bhttp": { "source": "iana" },
	"message/cpim": { "source": "iana" },
	"message/delivery-status": { "source": "iana" },
	"message/disposition-notification": {
		"source": "iana",
		"extensions": ["disposition-notification"]
	},
	"message/external-body": { "source": "iana" },
	"message/feedback-report": { "source": "iana" },
	"message/global": {
		"source": "iana",
		"extensions": ["u8msg"]
	},
	"message/global-delivery-status": {
		"source": "iana",
		"extensions": ["u8dsn"]
	},
	"message/global-disposition-notification": {
		"source": "iana",
		"extensions": ["u8mdn"]
	},
	"message/global-headers": {
		"source": "iana",
		"extensions": ["u8hdr"]
	},
	"message/http": {
		"source": "iana",
		"compressible": false
	},
	"message/imdn+xml": {
		"source": "iana",
		"compressible": true
	},
	"message/mls": { "source": "iana" },
	"message/news": { "source": "apache" },
	"message/ohttp-req": { "source": "iana" },
	"message/ohttp-res": { "source": "iana" },
	"message/partial": {
		"source": "iana",
		"compressible": false
	},
	"message/rfc822": {
		"source": "iana",
		"compressible": true,
		"extensions": [
			"eml",
			"mime",
			"mht",
			"mhtml"
		]
	},
	"message/s-http": { "source": "apache" },
	"message/sip": { "source": "iana" },
	"message/sipfrag": { "source": "iana" },
	"message/tracking-status": { "source": "iana" },
	"message/vnd.si.simp": { "source": "apache" },
	"message/vnd.wfa.wsc": {
		"source": "iana",
		"extensions": ["wsc"]
	},
	"model/3mf": {
		"source": "iana",
		"extensions": ["3mf"]
	},
	"model/e57": { "source": "iana" },
	"model/gltf+json": {
		"source": "iana",
		"compressible": true,
		"extensions": ["gltf"]
	},
	"model/gltf-binary": {
		"source": "iana",
		"compressible": true,
		"extensions": ["glb"]
	},
	"model/iges": {
		"source": "iana",
		"compressible": false,
		"extensions": ["igs", "iges"]
	},
	"model/jt": {
		"source": "iana",
		"extensions": ["jt"]
	},
	"model/mesh": {
		"source": "iana",
		"compressible": false,
		"extensions": [
			"msh",
			"mesh",
			"silo"
		]
	},
	"model/mtl": {
		"source": "iana",
		"extensions": ["mtl"]
	},
	"model/obj": {
		"source": "iana",
		"extensions": ["obj"]
	},
	"model/prc": {
		"source": "iana",
		"extensions": ["prc"]
	},
	"model/step": {
		"source": "iana",
		"extensions": [
			"step",
			"stp",
			"stpnc",
			"p21",
			"210"
		]
	},
	"model/step+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["stpx"]
	},
	"model/step+zip": {
		"source": "iana",
		"compressible": false,
		"extensions": ["stpz"]
	},
	"model/step-xml+zip": {
		"source": "iana",
		"compressible": false,
		"extensions": ["stpxz"]
	},
	"model/stl": {
		"source": "iana",
		"extensions": ["stl"]
	},
	"model/u3d": {
		"source": "iana",
		"extensions": ["u3d"]
	},
	"model/vnd.bary": {
		"source": "iana",
		"extensions": ["bary"]
	},
	"model/vnd.cld": {
		"source": "iana",
		"extensions": ["cld"]
	},
	"model/vnd.collada+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["dae"]
	},
	"model/vnd.dwf": {
		"source": "iana",
		"extensions": ["dwf"]
	},
	"model/vnd.flatland.3dml": { "source": "iana" },
	"model/vnd.gdl": {
		"source": "iana",
		"extensions": ["gdl"]
	},
	"model/vnd.gs-gdl": { "source": "apache" },
	"model/vnd.gs.gdl": { "source": "iana" },
	"model/vnd.gtw": {
		"source": "iana",
		"extensions": ["gtw"]
	},
	"model/vnd.moml+xml": {
		"source": "iana",
		"compressible": true
	},
	"model/vnd.mts": {
		"source": "iana",
		"extensions": ["mts"]
	},
	"model/vnd.opengex": {
		"source": "iana",
		"extensions": ["ogex"]
	},
	"model/vnd.parasolid.transmit.binary": {
		"source": "iana",
		"extensions": ["x_b"]
	},
	"model/vnd.parasolid.transmit.text": {
		"source": "iana",
		"extensions": ["x_t"]
	},
	"model/vnd.pytha.pyox": {
		"source": "iana",
		"extensions": ["pyo", "pyox"]
	},
	"model/vnd.rosette.annotated-data-model": { "source": "iana" },
	"model/vnd.sap.vds": {
		"source": "iana",
		"extensions": ["vds"]
	},
	"model/vnd.usda": {
		"source": "iana",
		"extensions": ["usda"]
	},
	"model/vnd.usdz+zip": {
		"source": "iana",
		"compressible": false,
		"extensions": ["usdz"]
	},
	"model/vnd.valve.source.compiled-map": {
		"source": "iana",
		"extensions": ["bsp"]
	},
	"model/vnd.vtu": {
		"source": "iana",
		"extensions": ["vtu"]
	},
	"model/vrml": {
		"source": "iana",
		"compressible": false,
		"extensions": ["wrl", "vrml"]
	},
	"model/x3d+binary": {
		"source": "apache",
		"compressible": false,
		"extensions": ["x3db", "x3dbz"]
	},
	"model/x3d+fastinfoset": {
		"source": "iana",
		"extensions": ["x3db"]
	},
	"model/x3d+vrml": {
		"source": "apache",
		"compressible": false,
		"extensions": ["x3dv", "x3dvz"]
	},
	"model/x3d+xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["x3d", "x3dz"]
	},
	"model/x3d-vrml": {
		"source": "iana",
		"extensions": ["x3dv"]
	},
	"multipart/alternative": {
		"source": "iana",
		"compressible": false
	},
	"multipart/appledouble": { "source": "iana" },
	"multipart/byteranges": { "source": "iana" },
	"multipart/digest": { "source": "iana" },
	"multipart/encrypted": {
		"source": "iana",
		"compressible": false
	},
	"multipart/form-data": {
		"source": "iana",
		"compressible": false
	},
	"multipart/header-set": { "source": "iana" },
	"multipart/mixed": { "source": "iana" },
	"multipart/multilingual": { "source": "iana" },
	"multipart/parallel": { "source": "iana" },
	"multipart/related": {
		"source": "iana",
		"compressible": false
	},
	"multipart/report": { "source": "iana" },
	"multipart/signed": {
		"source": "iana",
		"compressible": false
	},
	"multipart/vnd.bint.med-plus": { "source": "iana" },
	"multipart/voice-message": { "source": "iana" },
	"multipart/x-mixed-replace": { "source": "iana" },
	"text/1d-interleaved-parityfec": { "source": "iana" },
	"text/cache-manifest": {
		"source": "iana",
		"compressible": true,
		"extensions": ["appcache", "manifest"]
	},
	"text/calendar": {
		"source": "iana",
		"extensions": ["ics", "ifb"]
	},
	"text/calender": { "compressible": true },
	"text/cmd": { "compressible": true },
	"text/coffeescript": { "extensions": ["coffee", "litcoffee"] },
	"text/cql": { "source": "iana" },
	"text/cql-expression": { "source": "iana" },
	"text/cql-identifier": { "source": "iana" },
	"text/css": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true,
		"extensions": ["css"]
	},
	"text/csv": {
		"source": "iana",
		"compressible": true,
		"extensions": ["csv"]
	},
	"text/csv-schema": { "source": "iana" },
	"text/directory": { "source": "iana" },
	"text/dns": { "source": "iana" },
	"text/ecmascript": { "source": "apache" },
	"text/encaprtp": { "source": "iana" },
	"text/enriched": { "source": "iana" },
	"text/fhirpath": { "source": "iana" },
	"text/flexfec": { "source": "iana" },
	"text/fwdred": { "source": "iana" },
	"text/gff3": { "source": "iana" },
	"text/grammar-ref-list": { "source": "iana" },
	"text/hl7v2": { "source": "iana" },
	"text/html": {
		"source": "iana",
		"compressible": true,
		"extensions": [
			"html",
			"htm",
			"shtml"
		]
	},
	"text/jade": { "extensions": ["jade"] },
	"text/javascript": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true,
		"extensions": ["js", "mjs"]
	},
	"text/jcr-cnd": { "source": "iana" },
	"text/jsx": {
		"compressible": true,
		"extensions": ["jsx"]
	},
	"text/less": {
		"compressible": true,
		"extensions": ["less"]
	},
	"text/markdown": {
		"source": "iana",
		"compressible": true,
		"extensions": ["md", "markdown"]
	},
	"text/mathml": {
		"source": "nginx",
		"extensions": ["mml"]
	},
	"text/mdx": {
		"compressible": true,
		"extensions": ["mdx"]
	},
	"text/mizar": { "source": "iana" },
	"text/n3": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true,
		"extensions": ["n3"]
	},
	"text/parameters": {
		"source": "iana",
		"charset": "UTF-8"
	},
	"text/parityfec": { "source": "iana" },
	"text/plain": {
		"source": "iana",
		"compressible": true,
		"extensions": [
			"txt",
			"text",
			"conf",
			"def",
			"list",
			"log",
			"in",
			"ini"
		]
	},
	"text/provenance-notation": {
		"source": "iana",
		"charset": "UTF-8"
	},
	"text/prs.fallenstein.rst": { "source": "iana" },
	"text/prs.lines.tag": {
		"source": "iana",
		"extensions": ["dsc"]
	},
	"text/prs.prop.logic": { "source": "iana" },
	"text/prs.texi": { "source": "iana" },
	"text/raptorfec": { "source": "iana" },
	"text/red": { "source": "iana" },
	"text/rfc822-headers": { "source": "iana" },
	"text/richtext": {
		"source": "iana",
		"compressible": true,
		"extensions": ["rtx"]
	},
	"text/rtf": {
		"source": "iana",
		"compressible": true,
		"extensions": ["rtf"]
	},
	"text/rtp-enc-aescm128": { "source": "iana" },
	"text/rtploopback": { "source": "iana" },
	"text/rtx": { "source": "iana" },
	"text/sgml": {
		"source": "iana",
		"extensions": ["sgml", "sgm"]
	},
	"text/shaclc": { "source": "iana" },
	"text/shex": {
		"source": "iana",
		"extensions": ["shex"]
	},
	"text/slim": { "extensions": ["slim", "slm"] },
	"text/spdx": {
		"source": "iana",
		"extensions": ["spdx"]
	},
	"text/strings": { "source": "iana" },
	"text/stylus": { "extensions": ["stylus", "styl"] },
	"text/t140": { "source": "iana" },
	"text/tab-separated-values": {
		"source": "iana",
		"compressible": true,
		"extensions": ["tsv"]
	},
	"text/troff": {
		"source": "iana",
		"extensions": [
			"t",
			"tr",
			"roff",
			"man",
			"me",
			"ms"
		]
	},
	"text/turtle": {
		"source": "iana",
		"charset": "UTF-8",
		"extensions": ["ttl"]
	},
	"text/ulpfec": { "source": "iana" },
	"text/uri-list": {
		"source": "iana",
		"compressible": true,
		"extensions": [
			"uri",
			"uris",
			"urls"
		]
	},
	"text/vcard": {
		"source": "iana",
		"compressible": true,
		"extensions": ["vcard"]
	},
	"text/vnd.a": { "source": "iana" },
	"text/vnd.abc": { "source": "iana" },
	"text/vnd.ascii-art": { "source": "iana" },
	"text/vnd.curl": {
		"source": "iana",
		"extensions": ["curl"]
	},
	"text/vnd.curl.dcurl": {
		"source": "apache",
		"extensions": ["dcurl"]
	},
	"text/vnd.curl.mcurl": {
		"source": "apache",
		"extensions": ["mcurl"]
	},
	"text/vnd.curl.scurl": {
		"source": "apache",
		"extensions": ["scurl"]
	},
	"text/vnd.debian.copyright": {
		"source": "iana",
		"charset": "UTF-8"
	},
	"text/vnd.dmclientscript": { "source": "iana" },
	"text/vnd.dvb.subtitle": {
		"source": "iana",
		"extensions": ["sub"]
	},
	"text/vnd.esmertec.theme-descriptor": {
		"source": "iana",
		"charset": "UTF-8"
	},
	"text/vnd.exchangeable": { "source": "iana" },
	"text/vnd.familysearch.gedcom": {
		"source": "iana",
		"extensions": ["ged"]
	},
	"text/vnd.ficlab.flt": { "source": "iana" },
	"text/vnd.fly": {
		"source": "iana",
		"extensions": ["fly"]
	},
	"text/vnd.fmi.flexstor": {
		"source": "iana",
		"extensions": ["flx"]
	},
	"text/vnd.gml": { "source": "iana" },
	"text/vnd.graphviz": {
		"source": "iana",
		"extensions": ["gv"]
	},
	"text/vnd.hans": { "source": "iana" },
	"text/vnd.hgl": { "source": "iana" },
	"text/vnd.in3d.3dml": {
		"source": "iana",
		"extensions": ["3dml"]
	},
	"text/vnd.in3d.spot": {
		"source": "iana",
		"extensions": ["spot"]
	},
	"text/vnd.iptc.newsml": { "source": "iana" },
	"text/vnd.iptc.nitf": { "source": "iana" },
	"text/vnd.latex-z": { "source": "iana" },
	"text/vnd.motorola.reflex": { "source": "iana" },
	"text/vnd.ms-mediapackage": { "source": "iana" },
	"text/vnd.net2phone.commcenter.command": { "source": "iana" },
	"text/vnd.radisys.msml-basic-layout": { "source": "iana" },
	"text/vnd.senx.warpscript": { "source": "iana" },
	"text/vnd.si.uricatalogue": { "source": "apache" },
	"text/vnd.sosi": { "source": "iana" },
	"text/vnd.sun.j2me.app-descriptor": {
		"source": "iana",
		"charset": "UTF-8",
		"extensions": ["jad"]
	},
	"text/vnd.trolltech.linguist": {
		"source": "iana",
		"charset": "UTF-8"
	},
	"text/vnd.vcf": { "source": "iana" },
	"text/vnd.wap.si": { "source": "iana" },
	"text/vnd.wap.sl": { "source": "iana" },
	"text/vnd.wap.wml": {
		"source": "iana",
		"extensions": ["wml"]
	},
	"text/vnd.wap.wmlscript": {
		"source": "iana",
		"extensions": ["wmls"]
	},
	"text/vnd.zoo.kcl": { "source": "iana" },
	"text/vtt": {
		"source": "iana",
		"charset": "UTF-8",
		"compressible": true,
		"extensions": ["vtt"]
	},
	"text/wgsl": {
		"source": "iana",
		"extensions": ["wgsl"]
	},
	"text/x-asm": {
		"source": "apache",
		"extensions": ["s", "asm"]
	},
	"text/x-c": {
		"source": "apache",
		"extensions": [
			"c",
			"cc",
			"cxx",
			"cpp",
			"h",
			"hh",
			"dic"
		]
	},
	"text/x-component": {
		"source": "nginx",
		"extensions": ["htc"]
	},
	"text/x-fortran": {
		"source": "apache",
		"extensions": [
			"f",
			"for",
			"f77",
			"f90"
		]
	},
	"text/x-gwt-rpc": { "compressible": true },
	"text/x-handlebars-template": { "extensions": ["hbs"] },
	"text/x-java-source": {
		"source": "apache",
		"extensions": ["java"]
	},
	"text/x-jquery-tmpl": { "compressible": true },
	"text/x-lua": { "extensions": ["lua"] },
	"text/x-markdown": {
		"compressible": true,
		"extensions": ["mkd"]
	},
	"text/x-nfo": {
		"source": "apache",
		"extensions": ["nfo"]
	},
	"text/x-opml": {
		"source": "apache",
		"extensions": ["opml"]
	},
	"text/x-org": {
		"compressible": true,
		"extensions": ["org"]
	},
	"text/x-pascal": {
		"source": "apache",
		"extensions": ["p", "pas"]
	},
	"text/x-processing": {
		"compressible": true,
		"extensions": ["pde"]
	},
	"text/x-sass": { "extensions": ["sass"] },
	"text/x-scss": { "extensions": ["scss"] },
	"text/x-setext": {
		"source": "apache",
		"extensions": ["etx"]
	},
	"text/x-sfv": {
		"source": "apache",
		"extensions": ["sfv"]
	},
	"text/x-suse-ymp": {
		"compressible": true,
		"extensions": ["ymp"]
	},
	"text/x-uuencode": {
		"source": "apache",
		"extensions": ["uu"]
	},
	"text/x-vcalendar": {
		"source": "apache",
		"extensions": ["vcs"]
	},
	"text/x-vcard": {
		"source": "apache",
		"extensions": ["vcf"]
	},
	"text/xml": {
		"source": "iana",
		"compressible": true,
		"extensions": ["xml"]
	},
	"text/xml-external-parsed-entity": { "source": "iana" },
	"text/yaml": {
		"compressible": true,
		"extensions": ["yaml", "yml"]
	},
	"video/1d-interleaved-parityfec": { "source": "iana" },
	"video/3gpp": {
		"source": "iana",
		"extensions": ["3gp", "3gpp"]
	},
	"video/3gpp-tt": { "source": "iana" },
	"video/3gpp2": {
		"source": "iana",
		"extensions": ["3g2"]
	},
	"video/av1": { "source": "iana" },
	"video/bmpeg": { "source": "iana" },
	"video/bt656": { "source": "iana" },
	"video/celb": { "source": "iana" },
	"video/dv": { "source": "iana" },
	"video/encaprtp": { "source": "iana" },
	"video/evc": { "source": "iana" },
	"video/ffv1": { "source": "iana" },
	"video/flexfec": { "source": "iana" },
	"video/h261": {
		"source": "iana",
		"extensions": ["h261"]
	},
	"video/h263": {
		"source": "iana",
		"extensions": ["h263"]
	},
	"video/h263-1998": { "source": "iana" },
	"video/h263-2000": { "source": "iana" },
	"video/h264": {
		"source": "iana",
		"extensions": ["h264"]
	},
	"video/h264-rcdo": { "source": "iana" },
	"video/h264-svc": { "source": "iana" },
	"video/h265": { "source": "iana" },
	"video/h266": { "source": "iana" },
	"video/iso.segment": {
		"source": "iana",
		"extensions": ["m4s"]
	},
	"video/jpeg": {
		"source": "iana",
		"extensions": ["jpgv"]
	},
	"video/jpeg2000": { "source": "iana" },
	"video/jpm": {
		"source": "apache",
		"extensions": ["jpm", "jpgm"]
	},
	"video/jxsv": { "source": "iana" },
	"video/lottie+json": {
		"source": "iana",
		"compressible": true
	},
	"video/matroska": { "source": "iana" },
	"video/matroska-3d": { "source": "iana" },
	"video/mj2": {
		"source": "iana",
		"extensions": ["mj2", "mjp2"]
	},
	"video/mp1s": { "source": "iana" },
	"video/mp2p": { "source": "iana" },
	"video/mp2t": {
		"source": "iana",
		"extensions": [
			"ts",
			"m2t",
			"m2ts",
			"mts"
		]
	},
	"video/mp4": {
		"source": "iana",
		"compressible": false,
		"extensions": [
			"mp4",
			"mp4v",
			"mpg4"
		]
	},
	"video/mp4v-es": { "source": "iana" },
	"video/mpeg": {
		"source": "iana",
		"compressible": false,
		"extensions": [
			"mpeg",
			"mpg",
			"mpe",
			"m1v",
			"m2v"
		]
	},
	"video/mpeg4-generic": { "source": "iana" },
	"video/mpv": { "source": "iana" },
	"video/nv": { "source": "iana" },
	"video/ogg": {
		"source": "iana",
		"compressible": false,
		"extensions": ["ogv"]
	},
	"video/parityfec": { "source": "iana" },
	"video/pointer": { "source": "iana" },
	"video/quicktime": {
		"source": "iana",
		"compressible": false,
		"extensions": ["qt", "mov"]
	},
	"video/raptorfec": { "source": "iana" },
	"video/raw": { "source": "iana" },
	"video/rtp-enc-aescm128": { "source": "iana" },
	"video/rtploopback": { "source": "iana" },
	"video/rtx": { "source": "iana" },
	"video/scip": { "source": "iana" },
	"video/smpte291": { "source": "iana" },
	"video/smpte292m": { "source": "iana" },
	"video/ulpfec": { "source": "iana" },
	"video/vc1": { "source": "iana" },
	"video/vc2": { "source": "iana" },
	"video/vnd.cctv": { "source": "iana" },
	"video/vnd.dece.hd": {
		"source": "iana",
		"extensions": ["uvh", "uvvh"]
	},
	"video/vnd.dece.mobile": {
		"source": "iana",
		"extensions": ["uvm", "uvvm"]
	},
	"video/vnd.dece.mp4": { "source": "iana" },
	"video/vnd.dece.pd": {
		"source": "iana",
		"extensions": ["uvp", "uvvp"]
	},
	"video/vnd.dece.sd": {
		"source": "iana",
		"extensions": ["uvs", "uvvs"]
	},
	"video/vnd.dece.video": {
		"source": "iana",
		"extensions": ["uvv", "uvvv"]
	},
	"video/vnd.directv.mpeg": { "source": "iana" },
	"video/vnd.directv.mpeg-tts": { "source": "iana" },
	"video/vnd.dlna.mpeg-tts": { "source": "iana" },
	"video/vnd.dvb.file": {
		"source": "iana",
		"extensions": ["dvb"]
	},
	"video/vnd.fvt": {
		"source": "iana",
		"extensions": ["fvt"]
	},
	"video/vnd.hns.video": { "source": "iana" },
	"video/vnd.iptvforum.1dparityfec-1010": { "source": "iana" },
	"video/vnd.iptvforum.1dparityfec-2005": { "source": "iana" },
	"video/vnd.iptvforum.2dparityfec-1010": { "source": "iana" },
	"video/vnd.iptvforum.2dparityfec-2005": { "source": "iana" },
	"video/vnd.iptvforum.ttsavc": { "source": "iana" },
	"video/vnd.iptvforum.ttsmpeg2": { "source": "iana" },
	"video/vnd.motorola.video": { "source": "iana" },
	"video/vnd.motorola.videop": { "source": "iana" },
	"video/vnd.mpegurl": {
		"source": "iana",
		"extensions": ["mxu", "m4u"]
	},
	"video/vnd.ms-playready.media.pyv": {
		"source": "iana",
		"extensions": ["pyv"]
	},
	"video/vnd.nokia.interleaved-multimedia": { "source": "iana" },
	"video/vnd.nokia.mp4vr": { "source": "iana" },
	"video/vnd.nokia.videovoip": { "source": "iana" },
	"video/vnd.objectvideo": { "source": "iana" },
	"video/vnd.planar": { "source": "iana" },
	"video/vnd.radgamettools.bink": { "source": "iana" },
	"video/vnd.radgamettools.smacker": { "source": "apache" },
	"video/vnd.sealed.mpeg1": { "source": "iana" },
	"video/vnd.sealed.mpeg4": { "source": "iana" },
	"video/vnd.sealed.swf": { "source": "iana" },
	"video/vnd.sealedmedia.softseal.mov": { "source": "iana" },
	"video/vnd.uvvu.mp4": {
		"source": "iana",
		"extensions": ["uvu", "uvvu"]
	},
	"video/vnd.vivo": {
		"source": "iana",
		"extensions": ["viv"]
	},
	"video/vnd.youtube.yt": { "source": "iana" },
	"video/vp8": { "source": "iana" },
	"video/vp9": { "source": "iana" },
	"video/webm": {
		"source": "apache",
		"compressible": false,
		"extensions": ["webm"]
	},
	"video/x-f4v": {
		"source": "apache",
		"extensions": ["f4v"]
	},
	"video/x-fli": {
		"source": "apache",
		"extensions": ["fli"]
	},
	"video/x-flv": {
		"source": "apache",
		"compressible": false,
		"extensions": ["flv"]
	},
	"video/x-m4v": {
		"source": "apache",
		"extensions": ["m4v"]
	},
	"video/x-matroska": {
		"source": "apache",
		"compressible": false,
		"extensions": [
			"mkv",
			"mk3d",
			"mks"
		]
	},
	"video/x-mng": {
		"source": "apache",
		"extensions": ["mng"]
	},
	"video/x-ms-asf": {
		"source": "apache",
		"extensions": ["asf", "asx"]
	},
	"video/x-ms-vob": {
		"source": "apache",
		"extensions": ["vob"]
	},
	"video/x-ms-wm": {
		"source": "apache",
		"extensions": ["wm"]
	},
	"video/x-ms-wmv": {
		"source": "apache",
		"compressible": false,
		"extensions": ["wmv"]
	},
	"video/x-ms-wmx": {
		"source": "apache",
		"extensions": ["wmx"]
	},
	"video/x-ms-wvx": {
		"source": "apache",
		"extensions": ["wvx"]
	},
	"video/x-msvideo": {
		"source": "apache",
		"extensions": ["avi"]
	},
	"video/x-sgi-movie": {
		"source": "apache",
		"extensions": ["movie"]
	},
	"video/x-smv": {
		"source": "apache",
		"extensions": ["smv"]
	},
	"x-conference/x-cooltalk": {
		"source": "apache",
		"extensions": ["ice"]
	},
	"x-shader/x-fragment": { "compressible": true },
	"x-shader/x-vertex": { "compressible": true }
};
/*!
* mime-db
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2015-2022 Douglas Christopher Wilson
* MIT Licensed
*/
var mimeDb;
var hasRequiredMimeDb;
function requireMimeDb() {
	if (hasRequiredMimeDb) return mimeDb;
	hasRequiredMimeDb = 1;
	mimeDb = require$$0$1$1;
	return mimeDb;
}
var mimeScore;
var hasRequiredMimeScore;
function requireMimeScore() {
	if (hasRequiredMimeScore) return mimeScore;
	hasRequiredMimeScore = 1;
	var FACET_SCORES = {
		"prs.": 100,
		"x-": 200,
		"x.": 300,
		"vnd.": 400,
		default: 900
	};
	var SOURCE_SCORES = {
		nginx: 10,
		apache: 20,
		iana: 40,
		default: 30
	};
	var TYPE_SCORES = {
		application: 1,
		font: 2,
		default: 0
	};
	mimeScore = function mimeScore2(mimeType, source = "default") {
		if (mimeType === "application/octet-stream") return 0;
		const [type2, subtype] = mimeType.split("/");
		const facetScore = FACET_SCORES[subtype.replace(/(\.|x-).*/, "$1")] || FACET_SCORES.default;
		const sourceScore = SOURCE_SCORES[source] || SOURCE_SCORES.default;
		const typeScore = TYPE_SCORES[type2] || TYPE_SCORES.default;
		const lengthScore = 1 - mimeType.length / 100;
		return facetScore + sourceScore + typeScore + lengthScore;
	};
	return mimeScore;
}
/*!
* mime-types
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var hasRequiredMimeTypes;
function requireMimeTypes() {
	if (hasRequiredMimeTypes) return mimeTypes;
	hasRequiredMimeTypes = 1;
	(function(exports$1) {
		var db$2 = requireMimeDb();
		var extname$1 = path$1.extname;
		var mimeScore2 = requireMimeScore();
		var EXTRACT_TYPE_REGEXP$1 = /^\s*([^;\s]*)(?:;|\s|$)/;
		var TEXT_TYPE_REGEXP$1 = /^text\//i;
		exports$1.charset = charset2;
		exports$1.charsets = { lookup: charset2 };
		exports$1.contentType = contentType2;
		exports$1.extension = extension$1;
		exports$1.extensions = /* @__PURE__ */ Object.create(null);
		exports$1.lookup = lookup$1;
		exports$1.types = /* @__PURE__ */ Object.create(null);
		exports$1._extensionConflicts = [];
		populateMaps$1(exports$1.extensions, exports$1.types);
		function charset2(type2) {
			if (!type2 || typeof type2 !== "string") return false;
			var match = EXTRACT_TYPE_REGEXP$1.exec(type2);
			var mime$1 = match && db$2[match[1].toLowerCase()];
			if (mime$1 && mime$1.charset) return mime$1.charset;
			if (match && TEXT_TYPE_REGEXP$1.test(match[1])) return "UTF-8";
			return false;
		}
		function contentType2(str) {
			if (!str || typeof str !== "string") return false;
			var mime$1 = str.indexOf("/") === -1 ? exports$1.lookup(str) : str;
			if (!mime$1) return false;
			if (mime$1.indexOf("charset") === -1) {
				var charset3 = exports$1.charset(mime$1);
				if (charset3) mime$1 += "; charset=" + charset3.toLowerCase();
			}
			return mime$1;
		}
		function extension$1(type2) {
			if (!type2 || typeof type2 !== "string") return false;
			var match = EXTRACT_TYPE_REGEXP$1.exec(type2);
			var exts = match && exports$1.extensions[match[1].toLowerCase()];
			if (!exts || !exts.length) return false;
			return exts[0];
		}
		function lookup$1(path$3) {
			if (!path$3 || typeof path$3 !== "string") return false;
			var extension2 = extname$1("x." + path$3).toLowerCase().slice(1);
			if (!extension2) return false;
			return exports$1.types[extension2] || false;
		}
		function populateMaps$1(extensions, types) {
			Object.keys(db$2).forEach(function forEachMimeType(type2) {
				var exts = db$2[type2].extensions;
				if (!exts || !exts.length) return;
				extensions[type2] = exts;
				for (var i = 0; i < exts.length; i++) {
					var extension2 = exts[i];
					types[extension2] = _preferredType(extension2, types[extension2], type2);
					const legacyType = _preferredTypeLegacy(extension2, types[extension2], type2);
					if (legacyType !== types[extension2]) exports$1._extensionConflicts.push([
						extension2,
						legacyType,
						types[extension2]
					]);
				}
			});
		}
		function _preferredType(ext, type0, type1) {
			return (type0 ? mimeScore2(type0, db$2[type0].source) : 0) > (type1 ? mimeScore2(type1, db$2[type1].source) : 0) ? type0 : type1;
		}
		function _preferredTypeLegacy(ext, type0, type1) {
			var SOURCE_RANK = [
				"nginx",
				"apache",
				void 0,
				"iana"
			];
			var score0 = type0 ? SOURCE_RANK.indexOf(db$2[type0].source) : 0;
			var score1 = type1 ? SOURCE_RANK.indexOf(db$2[type1].source) : 0;
			if (exports$1.types[extension$1] !== "application/octet-stream" && (score0 > score1 || score0 === score1 && exports$1.types[extension$1]?.slice(0, 12) === "application/")) return type0;
			return score0 > score1 ? type0 : type1;
		}
	})(mimeTypes);
	return mimeTypes;
}
var mediaTyper = {};
/*!
* media-typer
* Copyright(c) 2014-2017 Douglas Christopher Wilson
* MIT Licensed
*/
var hasRequiredMediaTyper;
function requireMediaTyper() {
	if (hasRequiredMediaTyper) return mediaTyper;
	hasRequiredMediaTyper = 1;
	var SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
	var TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
	var TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
	mediaTyper.format = format;
	mediaTyper.parse = parse2;
	mediaTyper.test = test$1;
	function format(obj) {
		if (!obj || typeof obj !== "object") throw new TypeError("argument obj is required");
		var subtype = obj.subtype;
		var suffix = obj.suffix;
		var type2 = obj.type;
		if (!type2 || !TYPE_NAME_REGEXP.test(type2)) throw new TypeError("invalid type");
		if (!subtype || !SUBTYPE_NAME_REGEXP.test(subtype)) throw new TypeError("invalid subtype");
		var string$2 = type2 + "/" + subtype;
		if (suffix) {
			if (!TYPE_NAME_REGEXP.test(suffix)) throw new TypeError("invalid suffix");
			string$2 += "+" + suffix;
		}
		return string$2;
	}
	function test$1(string$2) {
		if (!string$2) throw new TypeError("argument string is required");
		if (typeof string$2 !== "string") throw new TypeError("argument string is required to be a string");
		return TYPE_REGEXP.test(string$2.toLowerCase());
	}
	function parse2(string$2) {
		if (!string$2) throw new TypeError("argument string is required");
		if (typeof string$2 !== "string") throw new TypeError("argument string is required to be a string");
		var match = TYPE_REGEXP.exec(string$2.toLowerCase());
		if (!match) throw new TypeError("invalid media type");
		var type2 = match[1];
		var subtype = match[2];
		var suffix;
		var index2 = subtype.lastIndexOf("+");
		if (index2 !== -1) {
			suffix = subtype.substr(index2 + 1);
			subtype = subtype.substr(0, index2);
		}
		return new MediaType(type2, subtype, suffix);
	}
	function MediaType(type2, subtype, suffix) {
		this.type = type2;
		this.subtype = subtype;
		this.suffix = suffix;
	}
	return mediaTyper;
}
/*!
* type-is
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var hasRequiredTypeIs;
function requireTypeIs() {
	if (hasRequiredTypeIs) return typeIs.exports;
	hasRequiredTypeIs = 1;
	var contentType2 = requireContentType();
	var mime$1 = requireMimeTypes();
	var typer = requireMediaTyper();
	typeIs.exports = typeofrequest;
	typeIs.exports.is = typeis;
	typeIs.exports.hasBody = hasbody;
	typeIs.exports.normalize = normalize;
	typeIs.exports.match = mimeMatch;
	function typeis(value, types_) {
		var i;
		var types = types_;
		var val = tryNormalizeType(value);
		if (!val) return false;
		if (types && !Array.isArray(types)) {
			types = new Array(arguments.length - 1);
			for (i = 0; i < types.length; i++) types[i] = arguments[i + 1];
		}
		if (!types || !types.length) return val;
		var type2;
		for (i = 0; i < types.length; i++) if (mimeMatch(normalize(type2 = types[i]), val)) return type2[0] === "+" || type2.indexOf("*") !== -1 ? val : type2;
		return false;
	}
	function hasbody(req) {
		return req.headers["transfer-encoding"] !== void 0 || !isNaN(req.headers["content-length"]);
	}
	function typeofrequest(req, types_) {
		if (!hasbody(req)) return null;
		var types = arguments.length > 2 ? Array.prototype.slice.call(arguments, 1) : types_;
		var value = req.headers["content-type"];
		return typeis(value, types);
	}
	function normalize(type2) {
		if (typeof type2 !== "string") return false;
		switch (type2) {
			case "urlencoded": return "application/x-www-form-urlencoded";
			case "multipart": return "multipart/*";
		}
		if (type2[0] === "+") return "*/*" + type2;
		return type2.indexOf("/") === -1 ? mime$1.lookup(type2) : type2;
	}
	function mimeMatch(expected, actual) {
		if (expected === false) return false;
		var actualParts = actual.split("/");
		var expectedParts = expected.split("/");
		if (actualParts.length !== 2 || expectedParts.length !== 2) return false;
		if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) return false;
		if (expectedParts[1].slice(0, 2) === "*+") return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].slice(1) === actualParts[1].slice(1 - expectedParts[1].length);
		if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) return false;
		return true;
	}
	function normalizeType(value) {
		var type2 = contentType2.parse(value).type;
		return typer.test(type2) ? type2 : null;
	}
	function tryNormalizeType(value) {
		try {
			return value ? normalizeType(value) : null;
		} catch (err) {
			return null;
		}
	}
	return typeIs.exports;
}
var utils$2;
var hasRequiredUtils$2;
function requireUtils$2() {
	if (hasRequiredUtils$2) return utils$2;
	hasRequiredUtils$2 = 1;
	var bytes2 = requireBytes();
	var contentType2 = requireContentType();
	var typeis = requireTypeIs();
	utils$2 = {
		getCharset,
		normalizeOptions
	};
	function getCharset(req) {
		try {
			return (contentType2.parse(req).parameters.charset || "").toLowerCase();
		} catch {
			return;
		}
	}
	function typeChecker(type2) {
		return function checkType(req) {
			return Boolean(typeis(req, type2));
		};
	}
	function normalizeOptions(options, defaultType) {
		if (!defaultType) throw new TypeError("defaultType must be provided");
		var inflate = options?.inflate !== false;
		var limit = typeof options?.limit !== "number" ? bytes2.parse(options?.limit || "100kb") : options?.limit;
		var type2 = options?.type || defaultType;
		var verify = options?.verify || false;
		if (verify !== false && typeof verify !== "function") throw new TypeError("option verify must be function");
		return {
			inflate,
			limit,
			verify,
			shouldParse: typeof type2 !== "function" ? typeChecker(type2) : type2
		};
	}
	return utils$2;
}
/*!
* body-parser
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var json_1;
var hasRequiredJson;
function requireJson() {
	if (hasRequiredJson) return json_1;
	hasRequiredJson = 1;
	var createError = requireHttpErrors();
	var debug$2 = requireBrowser()("body-parser:json");
	var isFinished = requireOnFinished().isFinished;
	var read = requireRead();
	var typeis = requireTypeIs();
	var { getCharset, normalizeOptions } = requireUtils$2();
	json_1 = json2;
	var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
	var JSON_SYNTAX_CHAR = "#";
	var JSON_SYNTAX_REGEXP = /#+/g;
	function json2(options) {
		var { inflate, limit, verify, shouldParse } = normalizeOptions(options, "application/json");
		var reviver = options?.reviver;
		var strict = options?.strict !== false;
		function parse2(body) {
			if (body.length === 0) return {};
			if (strict) {
				var first = firstchar(body);
				if (first !== "{" && first !== "[") {
					debug$2("strict violation");
					throw createStrictSyntaxError(body, first);
				}
			}
			try {
				debug$2("parse json");
				return JSON.parse(body, reviver);
			} catch (e) {
				throw normalizeJsonSyntaxError(e, {
					message: e.message,
					stack: e.stack
				});
			}
		}
		return function jsonParser(req, res, next) {
			if (isFinished(req)) {
				debug$2("body already parsed");
				next();
				return;
			}
			if (!("body" in req)) req.body = void 0;
			if (!typeis.hasBody(req)) {
				debug$2("skip empty body");
				next();
				return;
			}
			debug$2("content-type %j", req.headers["content-type"]);
			if (!shouldParse(req)) {
				debug$2("skip parsing");
				next();
				return;
			}
			var charset2 = getCharset(req) || "utf-8";
			if (charset2.slice(0, 4) !== "utf-") {
				debug$2("invalid charset");
				next(createError(415, "unsupported charset \"" + charset2.toUpperCase() + "\"", {
					charset: charset2,
					type: "charset.unsupported"
				}));
				return;
			}
			read(req, res, next, parse2, debug$2, {
				encoding: charset2,
				inflate,
				limit,
				verify
			});
		};
	}
	function createStrictSyntaxError(str, char) {
		var index2 = str.indexOf(char);
		var partial$1 = "";
		if (index2 !== -1) {
			partial$1 = str.substring(0, index2) + JSON_SYNTAX_CHAR;
			for (var i = index2 + 1; i < str.length; i++) partial$1 += JSON_SYNTAX_CHAR;
		}
		try {
			JSON.parse(partial$1);
			throw new SyntaxError("strict violation");
		} catch (e) {
			return normalizeJsonSyntaxError(e, {
				message: e.message.replace(JSON_SYNTAX_REGEXP, function(placeholder) {
					return str.substring(index2, index2 + placeholder.length);
				}),
				stack: e.stack
			});
		}
	}
	function firstchar(str) {
		var match = FIRST_CHAR_REGEXP.exec(str);
		return match ? match[1] : void 0;
	}
	function normalizeJsonSyntaxError(error, obj) {
		var keys = Object.getOwnPropertyNames(error);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			if (key !== "stack" && key !== "message") delete error[key];
		}
		error.stack = obj.stack.replace(error.message, obj.message);
		error.message = obj.message;
		return error;
	}
	return json_1;
}
/*!
* body-parser
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var raw_1;
var hasRequiredRaw;
function requireRaw() {
	if (hasRequiredRaw) return raw_1;
	hasRequiredRaw = 1;
	var debug$2 = requireBrowser()("body-parser:raw");
	var isFinished = requireOnFinished().isFinished;
	var read = requireRead();
	var typeis = requireTypeIs();
	var { normalizeOptions } = requireUtils$2();
	raw_1 = raw2;
	function raw2(options) {
		var { inflate, limit, verify, shouldParse } = normalizeOptions(options, "application/octet-stream");
		function parse2(buf) {
			return buf;
		}
		return function rawParser(req, res, next) {
			if (isFinished(req)) {
				debug$2("body already parsed");
				next();
				return;
			}
			if (!("body" in req)) req.body = void 0;
			if (!typeis.hasBody(req)) {
				debug$2("skip empty body");
				next();
				return;
			}
			debug$2("content-type %j", req.headers["content-type"]);
			if (!shouldParse(req)) {
				debug$2("skip parsing");
				next();
				return;
			}
			read(req, res, next, parse2, debug$2, {
				encoding: null,
				inflate,
				limit,
				verify
			});
		};
	}
	return raw_1;
}
/*!
* body-parser
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var text_1;
var hasRequiredText;
function requireText() {
	if (hasRequiredText) return text_1;
	hasRequiredText = 1;
	var debug$2 = requireBrowser()("body-parser:text");
	var isFinished = requireOnFinished().isFinished;
	var read = requireRead();
	var typeis = requireTypeIs();
	var { getCharset, normalizeOptions } = requireUtils$2();
	text_1 = text2;
	function text2(options) {
		var { inflate, limit, verify, shouldParse } = normalizeOptions(options, "text/plain");
		var defaultCharset = options?.defaultCharset || "utf-8";
		function parse2(buf) {
			return buf;
		}
		return function textParser(req, res, next) {
			if (isFinished(req)) {
				debug$2("body already parsed");
				next();
				return;
			}
			if (!("body" in req)) req.body = void 0;
			if (!typeis.hasBody(req)) {
				debug$2("skip empty body");
				next();
				return;
			}
			debug$2("content-type %j", req.headers["content-type"]);
			if (!shouldParse(req)) {
				debug$2("skip parsing");
				next();
				return;
			}
			read(req, res, next, parse2, debug$2, {
				encoding: getCharset(req) || defaultCharset,
				inflate,
				limit,
				verify
			});
		};
	}
	return text_1;
}
var type;
var hasRequiredType;
function requireType() {
	if (hasRequiredType) return type;
	hasRequiredType = 1;
	type = TypeError;
	return type;
}
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(/* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
	__proto__: null,
	default: {}
}, Symbol.toStringTag, { value: "Module" })));
var objectInspect;
var hasRequiredObjectInspect;
function requireObjectInspect() {
	if (hasRequiredObjectInspect) return objectInspect;
	hasRequiredObjectInspect = 1;
	var hasMap = typeof Map === "function" && Map.prototype;
	var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
	var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
	var mapForEach = hasMap && Map.prototype.forEach;
	var hasSet = typeof Set === "function" && Set.prototype;
	var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
	var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
	var setForEach = hasSet && Set.prototype.forEach;
	var weakMapHas = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap.prototype.has : null;
	var weakSetHas = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet.prototype.has : null;
	var weakRefDeref = typeof WeakRef === "function" && WeakRef.prototype ? WeakRef.prototype.deref : null;
	var booleanValueOf = Boolean.prototype.valueOf;
	var objectToString = Object.prototype.toString;
	var functionToString = Function.prototype.toString;
	var $match = String.prototype.match;
	var $slice = String.prototype.slice;
	var $replace$1 = String.prototype.replace;
	var $toUpperCase = String.prototype.toUpperCase;
	var $toLowerCase = String.prototype.toLowerCase;
	var $test = RegExp.prototype.test;
	var $concat$1 = Array.prototype.concat;
	var $join = Array.prototype.join;
	var $arrSlice = Array.prototype.slice;
	var $floor = Math.floor;
	var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
	var gOPS = Object.getOwnPropertySymbols;
	var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
	var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
	var toStringTag$2 = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
		return O.__proto__;
	} : null);
	function addNumericSeparator(num, str) {
		if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) return str;
		var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
		if (typeof num === "number") {
			var int$1 = num < 0 ? -$floor(-num) : $floor(num);
			if (int$1 !== num) {
				var intStr = String(int$1);
				var dec = $slice.call(str, intStr.length + 1);
				return $replace$1.call(intStr, sepRegex, "$&_") + "." + $replace$1.call($replace$1.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
			}
		}
		return $replace$1.call(str, sepRegex, "$&_");
	}
	var utilInspect = require$$0;
	var inspectCustom = utilInspect.custom;
	var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
	var quotes = {
		__proto__: null,
		"double": "\"",
		single: "'"
	};
	var quoteREs = {
		__proto__: null,
		"double": /(["\\])/g,
		single: /(['\\])/g
	};
	objectInspect = function inspect_(obj, options, depth, seen) {
		var opts = options || {};
		if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) throw new TypeError("option \"quoteStyle\" must be \"single\" or \"double\"");
		if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) throw new TypeError("option \"maxStringLength\", if provided, must be a positive integer, Infinity, or `null`");
		var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
		if (typeof customInspect !== "boolean" && customInspect !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
		if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) throw new TypeError("option \"indent\" must be \"\\t\", an integer > 0, or `null`");
		if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") throw new TypeError("option \"numericSeparator\", if provided, must be `true` or `false`");
		var numericSeparator = opts.numericSeparator;
		if (typeof obj === "undefined") return "undefined";
		if (obj === null) return "null";
		if (typeof obj === "boolean") return obj ? "true" : "false";
		if (typeof obj === "string") return inspectString(obj, opts);
		if (typeof obj === "number") {
			if (obj === 0) return Infinity / obj > 0 ? "0" : "-0";
			var str = String(obj);
			return numericSeparator ? addNumericSeparator(obj, str) : str;
		}
		if (typeof obj === "bigint") {
			var bigIntStr = String(obj) + "n";
			return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
		}
		var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
		if (typeof depth === "undefined") depth = 0;
		if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") return isArray$1(obj) ? "[Array]" : "[Object]";
		var indent = getIndent(opts, depth);
		if (typeof seen === "undefined") seen = [];
		else if (indexOf(seen, obj) >= 0) return "[Circular]";
		function inspect(value, from, noIndent) {
			if (from) {
				seen = $arrSlice.call(seen);
				seen.push(from);
			}
			if (noIndent) {
				var newOpts = { depth: opts.depth };
				if (has(opts, "quoteStyle")) newOpts.quoteStyle = opts.quoteStyle;
				return inspect_(value, newOpts, depth + 1, seen);
			}
			return inspect_(value, opts, depth + 1, seen);
		}
		if (typeof obj === "function" && !isRegExp$1(obj)) {
			var name = nameOf(obj);
			var keys = arrObjKeys(obj, inspect);
			return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
		}
		if (isSymbol(obj)) {
			var symString = hasShammedSymbols ? $replace$1.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
			return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
		}
		if (isElement(obj)) {
			var s$1 = "<" + $toLowerCase.call(String(obj.nodeName));
			var attrs = obj.attributes || [];
			for (var i = 0; i < attrs.length; i++) s$1 += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
			s$1 += ">";
			if (obj.childNodes && obj.childNodes.length) s$1 += "...";
			s$1 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
			return s$1;
		}
		if (isArray$1(obj)) {
			if (obj.length === 0) return "[]";
			var xs = arrObjKeys(obj, inspect);
			if (indent && !singleLineValues(xs)) return "[" + indentedJoin(xs, indent) + "]";
			return "[ " + $join.call(xs, ", ") + " ]";
		}
		if (isError(obj)) {
			var parts = arrObjKeys(obj, inspect);
			if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) return "{ [" + String(obj) + "] " + $join.call($concat$1.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
			if (parts.length === 0) return "[" + String(obj) + "]";
			return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
		}
		if (typeof obj === "object" && customInspect) {
			if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) return utilInspect(obj, { depth: maxDepth - depth });
			else if (customInspect !== "symbol" && typeof obj.inspect === "function") return obj.inspect();
		}
		if (isMap(obj)) {
			var mapParts = [];
			if (mapForEach) mapForEach.call(obj, function(value, key) {
				mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
			});
			return collectionOf("Map", mapSize.call(obj), mapParts, indent);
		}
		if (isSet(obj)) {
			var setParts = [];
			if (setForEach) setForEach.call(obj, function(value) {
				setParts.push(inspect(value, obj));
			});
			return collectionOf("Set", setSize.call(obj), setParts, indent);
		}
		if (isWeakMap(obj)) return weakCollectionOf("WeakMap");
		if (isWeakSet(obj)) return weakCollectionOf("WeakSet");
		if (isWeakRef(obj)) return weakCollectionOf("WeakRef");
		if (isNumber$1(obj)) return markBoxed(inspect(Number(obj)));
		if (isBigInt(obj)) return markBoxed(inspect(bigIntValueOf.call(obj)));
		if (isBoolean$1(obj)) return markBoxed(booleanValueOf.call(obj));
		if (isString$2(obj)) return markBoxed(inspect(String(obj)));
		if (typeof window !== "undefined" && obj === window) return "{ [object Window] }";
		if (typeof globalThis !== "undefined" && obj === globalThis || typeof commonjsGlobal !== "undefined" && obj === commonjsGlobal) return "{ [object globalThis] }";
		if (!isDate$1(obj) && !isRegExp$1(obj)) {
			var ys = arrObjKeys(obj, inspect);
			var isPlainObject$2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
			var protoTag = obj instanceof Object ? "" : "null prototype";
			var stringTag = !isPlainObject$2 && toStringTag$2 && Object(obj) === obj && toStringTag$2 in obj ? $slice.call(toStr$1(obj), 8, -1) : protoTag ? "Object" : "";
			var tag = (isPlainObject$2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "") + (stringTag || protoTag ? "[" + $join.call($concat$1.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
			if (ys.length === 0) return tag + "{}";
			if (indent) return tag + "{" + indentedJoin(ys, indent) + "}";
			return tag + "{ " + $join.call(ys, ", ") + " }";
		}
		return String(obj);
	};
	function wrapQuotes(s$1, defaultStyle, opts) {
		var quoteChar = quotes[opts.quoteStyle || defaultStyle];
		return quoteChar + s$1 + quoteChar;
	}
	function quote(s$1) {
		return $replace$1.call(String(s$1), /"/g, "&quot;");
	}
	function canTrustToString(obj) {
		return !toStringTag$2 || !(typeof obj === "object" && (toStringTag$2 in obj || typeof obj[toStringTag$2] !== "undefined"));
	}
	function isArray$1(obj) {
		return toStr$1(obj) === "[object Array]" && canTrustToString(obj);
	}
	function isDate$1(obj) {
		return toStr$1(obj) === "[object Date]" && canTrustToString(obj);
	}
	function isRegExp$1(obj) {
		return toStr$1(obj) === "[object RegExp]" && canTrustToString(obj);
	}
	function isError(obj) {
		return toStr$1(obj) === "[object Error]" && canTrustToString(obj);
	}
	function isString$2(obj) {
		return toStr$1(obj) === "[object String]" && canTrustToString(obj);
	}
	function isNumber$1(obj) {
		return toStr$1(obj) === "[object Number]" && canTrustToString(obj);
	}
	function isBoolean$1(obj) {
		return toStr$1(obj) === "[object Boolean]" && canTrustToString(obj);
	}
	function isSymbol(obj) {
		if (hasShammedSymbols) return obj && typeof obj === "object" && obj instanceof Symbol;
		if (typeof obj === "symbol") return true;
		if (!obj || typeof obj !== "object" || !symToString) return false;
		try {
			symToString.call(obj);
			return true;
		} catch (e) {}
		return false;
	}
	function isBigInt(obj) {
		if (!obj || typeof obj !== "object" || !bigIntValueOf) return false;
		try {
			bigIntValueOf.call(obj);
			return true;
		} catch (e) {}
		return false;
	}
	var hasOwn$3 = Object.prototype.hasOwnProperty || function(key) {
		return key in this;
	};
	function has(obj, key) {
		return hasOwn$3.call(obj, key);
	}
	function toStr$1(obj) {
		return objectToString.call(obj);
	}
	function nameOf(f) {
		if (f.name) return f.name;
		var m$1 = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
		if (m$1) return m$1[1];
		return null;
	}
	function indexOf(xs, x) {
		if (xs.indexOf) return xs.indexOf(x);
		for (var i = 0, l = xs.length; i < l; i++) if (xs[i] === x) return i;
		return -1;
	}
	function isMap(x) {
		if (!mapSize || !x || typeof x !== "object") return false;
		try {
			mapSize.call(x);
			try {
				setSize.call(x);
			} catch (s$1) {
				return true;
			}
			return x instanceof Map;
		} catch (e) {}
		return false;
	}
	function isWeakMap(x) {
		if (!weakMapHas || !x || typeof x !== "object") return false;
		try {
			weakMapHas.call(x, weakMapHas);
			try {
				weakSetHas.call(x, weakSetHas);
			} catch (s$1) {
				return true;
			}
			return x instanceof WeakMap;
		} catch (e) {}
		return false;
	}
	function isWeakRef(x) {
		if (!weakRefDeref || !x || typeof x !== "object") return false;
		try {
			weakRefDeref.call(x);
			return true;
		} catch (e) {}
		return false;
	}
	function isSet(x) {
		if (!setSize || !x || typeof x !== "object") return false;
		try {
			setSize.call(x);
			try {
				mapSize.call(x);
			} catch (m$1) {
				return true;
			}
			return x instanceof Set;
		} catch (e) {}
		return false;
	}
	function isWeakSet(x) {
		if (!weakSetHas || !x || typeof x !== "object") return false;
		try {
			weakSetHas.call(x, weakSetHas);
			try {
				weakMapHas.call(x, weakMapHas);
			} catch (s$1) {
				return true;
			}
			return x instanceof WeakSet;
		} catch (e) {}
		return false;
	}
	function isElement(x) {
		if (!x || typeof x !== "object") return false;
		if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) return true;
		return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
	}
	function inspectString(str, opts) {
		if (str.length > opts.maxStringLength) {
			var remaining = str.length - opts.maxStringLength;
			var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
			return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
		}
		var quoteRE = quoteREs[opts.quoteStyle || "single"];
		quoteRE.lastIndex = 0;
		return wrapQuotes($replace$1.call($replace$1.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte), "single", opts);
	}
	function lowbyte(c) {
		var n = c.charCodeAt(0);
		var x = {
			8: "b",
			9: "t",
			10: "n",
			12: "f",
			13: "r"
		}[n];
		if (x) return "\\" + x;
		return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
	}
	function markBoxed(str) {
		return "Object(" + str + ")";
	}
	function weakCollectionOf(type2) {
		return type2 + " { ? }";
	}
	function collectionOf(type2, size, entries, indent) {
		var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
		return type2 + " (" + size + ") {" + joinedEntries + "}";
	}
	function singleLineValues(xs) {
		for (var i = 0; i < xs.length; i++) if (indexOf(xs[i], "\n") >= 0) return false;
		return true;
	}
	function getIndent(opts, depth) {
		var baseIndent;
		if (opts.indent === "	") baseIndent = "	";
		else if (typeof opts.indent === "number" && opts.indent > 0) baseIndent = $join.call(Array(opts.indent + 1), " ");
		else return null;
		return {
			base: baseIndent,
			prev: $join.call(Array(depth + 1), baseIndent)
		};
	}
	function indentedJoin(xs, indent) {
		if (xs.length === 0) return "";
		var lineJoiner = "\n" + indent.prev + indent.base;
		return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
	}
	function arrObjKeys(obj, inspect) {
		var isArr = isArray$1(obj);
		var xs = [];
		if (isArr) {
			xs.length = obj.length;
			for (var i = 0; i < obj.length; i++) xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
		}
		var syms = typeof gOPS === "function" ? gOPS(obj) : [];
		var symMap;
		if (hasShammedSymbols) {
			symMap = {};
			for (var k = 0; k < syms.length; k++) symMap["$" + syms[k]] = syms[k];
		}
		for (var key in obj) {
			if (!has(obj, key)) continue;
			if (isArr && String(Number(key)) === key && key < obj.length) continue;
			if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) continue;
			else if ($test.call(/[^\w$]/, key)) xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
			else xs.push(key + ": " + inspect(obj[key], obj));
		}
		if (typeof gOPS === "function") {
			for (var j = 0; j < syms.length; j++) if (isEnumerable.call(obj, syms[j])) xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
		}
		return xs;
	}
	return objectInspect;
}
var sideChannelList;
var hasRequiredSideChannelList;
function requireSideChannelList() {
	if (hasRequiredSideChannelList) return sideChannelList;
	hasRequiredSideChannelList = 1;
	var inspect = /* @__PURE__ */ requireObjectInspect();
	var $TypeError$3 = /* @__PURE__ */ requireType();
	var listGetNode = function(list, key, isDelete) {
		var prev = list;
		var curr;
		for (; (curr = prev.next) != null; prev = curr) if (curr.key === key) {
			prev.next = curr.next;
			if (!isDelete) {
				curr.next = list.next;
				list.next = curr;
			}
			return curr;
		}
	};
	var listGet = function(objects, key) {
		if (!objects) return;
		var node = listGetNode(objects, key);
		return node && node.value;
	};
	var listSet = function(objects, key, value) {
		var node = listGetNode(objects, key);
		if (node) node.value = value;
		else objects.next = {
			key,
			next: objects.next,
			value
		};
	};
	var listHas = function(objects, key) {
		if (!objects) return false;
		return !!listGetNode(objects, key);
	};
	var listDelete = function(objects, key) {
		if (objects) return listGetNode(objects, key, true);
	};
	sideChannelList = function getSideChannelList() {
		var $o;
		var channel = {
			assert: function(key) {
				if (!channel.has(key)) throw new $TypeError$3("Side channel does not contain " + inspect(key));
			},
			"delete": function(key) {
				var root = $o && $o.next;
				var deletedNode = listDelete($o, key);
				if (deletedNode && root && root === deletedNode) $o = void 0;
				return !!deletedNode;
			},
			get: function(key) {
				return listGet($o, key);
			},
			has: function(key) {
				return listHas($o, key);
			},
			set: function(key, value) {
				if (!$o) $o = { next: void 0 };
				listSet(
					/** @type {NonNullable<typeof $o>} */
					$o,
					key,
					value
				);
			}
		};
		return channel;
	};
	return sideChannelList;
}
var esObjectAtoms;
var hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
	if (hasRequiredEsObjectAtoms) return esObjectAtoms;
	hasRequiredEsObjectAtoms = 1;
	esObjectAtoms = Object;
	return esObjectAtoms;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
	if (hasRequiredEsErrors) return esErrors;
	hasRequiredEsErrors = 1;
	esErrors = Error;
	return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
	if (hasRequired_eval) return _eval;
	hasRequired_eval = 1;
	_eval = EvalError;
	return _eval;
}
var range$1;
var hasRequiredRange;
function requireRange() {
	if (hasRequiredRange) return range$1;
	hasRequiredRange = 1;
	range$1 = RangeError;
	return range$1;
}
var ref;
var hasRequiredRef;
function requireRef() {
	if (hasRequiredRef) return ref;
	hasRequiredRef = 1;
	ref = ReferenceError;
	return ref;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
	if (hasRequiredSyntax) return syntax;
	hasRequiredSyntax = 1;
	syntax = SyntaxError;
	return syntax;
}
var uri;
var hasRequiredUri;
function requireUri() {
	if (hasRequiredUri) return uri;
	hasRequiredUri = 1;
	uri = URIError;
	return uri;
}
var abs;
var hasRequiredAbs;
function requireAbs() {
	if (hasRequiredAbs) return abs;
	hasRequiredAbs = 1;
	abs = Math.abs;
	return abs;
}
var floor;
var hasRequiredFloor;
function requireFloor() {
	if (hasRequiredFloor) return floor;
	hasRequiredFloor = 1;
	floor = Math.floor;
	return floor;
}
var max;
var hasRequiredMax;
function requireMax() {
	if (hasRequiredMax) return max;
	hasRequiredMax = 1;
	max = Math.max;
	return max;
}
var min;
var hasRequiredMin;
function requireMin() {
	if (hasRequiredMin) return min;
	hasRequiredMin = 1;
	min = Math.min;
	return min;
}
var pow;
var hasRequiredPow;
function requirePow() {
	if (hasRequiredPow) return pow;
	hasRequiredPow = 1;
	pow = Math.pow;
	return pow;
}
var round;
var hasRequiredRound;
function requireRound() {
	if (hasRequiredRound) return round;
	hasRequiredRound = 1;
	round = Math.round;
	return round;
}
var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
	if (hasRequired_isNaN) return _isNaN;
	hasRequired_isNaN = 1;
	_isNaN = Number.isNaN || function isNaN2(a) {
		return a !== a;
	};
	return _isNaN;
}
var sign;
var hasRequiredSign;
function requireSign() {
	if (hasRequiredSign) return sign;
	hasRequiredSign = 1;
	var $isNaN$1 = /* @__PURE__ */ require_isNaN();
	sign = function sign2(number$3) {
		if ($isNaN$1(number$3) || number$3 === 0) return number$3;
		return number$3 < 0 ? -1 : 1;
	};
	return sign;
}
var gOPD;
var hasRequiredGOPD;
function requireGOPD() {
	if (hasRequiredGOPD) return gOPD;
	hasRequiredGOPD = 1;
	gOPD = Object.getOwnPropertyDescriptor;
	return gOPD;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
	if (hasRequiredGopd) return gopd;
	hasRequiredGopd = 1;
	var $gOPD$2 = /* @__PURE__ */ requireGOPD();
	if ($gOPD$2) try {
		$gOPD$2([], "length");
	} catch (e) {
		$gOPD$2 = null;
	}
	gopd = $gOPD$2;
	return gopd;
}
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
	if (hasRequiredEsDefineProperty) return esDefineProperty;
	hasRequiredEsDefineProperty = 1;
	var $defineProperty$3 = Object.defineProperty || false;
	if ($defineProperty$3) try {
		$defineProperty$3({}, "a", { value: 1 });
	} catch (e) {
		$defineProperty$3 = false;
	}
	esDefineProperty = $defineProperty$3;
	return esDefineProperty;
}
var shams;
var hasRequiredShams;
function requireShams() {
	if (hasRequiredShams) return shams;
	hasRequiredShams = 1;
	shams = function hasSymbols2() {
		if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") return false;
		if (typeof Symbol.iterator === "symbol") return true;
		var obj = {};
		var sym = Symbol("test");
		var symObj = Object(sym);
		if (typeof sym === "string") return false;
		if (Object.prototype.toString.call(sym) !== "[object Symbol]") return false;
		if (Object.prototype.toString.call(symObj) !== "[object Symbol]") return false;
		var symVal = 42;
		obj[sym] = symVal;
		for (var _ in obj) return false;
		if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) return false;
		if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) return false;
		var syms = Object.getOwnPropertySymbols(obj);
		if (syms.length !== 1 || syms[0] !== sym) return false;
		if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) return false;
		if (typeof Object.getOwnPropertyDescriptor === "function") {
			var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
			if (descriptor.value !== symVal || descriptor.enumerable !== true) return false;
		}
		return true;
	};
	return shams;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
	if (hasRequiredHasSymbols) return hasSymbols;
	hasRequiredHasSymbols = 1;
	var origSymbol$1 = typeof Symbol !== "undefined" && Symbol;
	var hasSymbolSham$1 = requireShams();
	hasSymbols = function hasNativeSymbols() {
		if (typeof origSymbol$1 !== "function") return false;
		if (typeof Symbol !== "function") return false;
		if (typeof origSymbol$1("foo") !== "symbol") return false;
		if (typeof Symbol("bar") !== "symbol") return false;
		return hasSymbolSham$1();
	};
	return hasSymbols;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
	if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
	hasRequiredReflect_getPrototypeOf = 1;
	Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
	return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
	if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
	hasRequiredObject_getPrototypeOf = 1;
	Object_getPrototypeOf = (/* @__PURE__ */ requireEsObjectAtoms()).getPrototypeOf || null;
	return Object_getPrototypeOf;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
	if (hasRequiredImplementation) return implementation;
	hasRequiredImplementation = 1;
	var ERROR_MESSAGE$1 = "Function.prototype.bind called on incompatible ";
	var toStr$1 = Object.prototype.toString;
	var max2 = Math.max;
	var funcType$1 = "[object Function]";
	var concatty$1 = function concatty2(a, b) {
		var arr = [];
		for (var i = 0; i < a.length; i += 1) arr[i] = a[i];
		for (var j = 0; j < b.length; j += 1) arr[j + a.length] = b[j];
		return arr;
	};
	var slicy$1 = function slicy2(arrLike, offset) {
		var arr = [];
		for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) arr[j] = arrLike[i];
		return arr;
	};
	var joiny$1 = function(arr, joiner) {
		var str = "";
		for (var i = 0; i < arr.length; i += 1) {
			str += arr[i];
			if (i + 1 < arr.length) str += joiner;
		}
		return str;
	};
	implementation = function bind$5(that) {
		var target = this;
		if (typeof target !== "function" || toStr$1.apply(target) !== funcType$1) throw new TypeError(ERROR_MESSAGE$1 + target);
		var args = slicy$1(arguments, 1);
		var bound;
		var binder = function() {
			if (this instanceof bound) {
				var result = target.apply(this, concatty$1(args, arguments));
				if (Object(result) === result) return result;
				return this;
			}
			return target.apply(that, concatty$1(args, arguments));
		};
		var boundLength = max2(0, target.length - args.length);
		var boundArgs = [];
		for (var i = 0; i < boundLength; i++) boundArgs[i] = "$" + i;
		bound = Function("binder", "return function (" + joiny$1(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
		if (target.prototype) {
			var Empty = function Empty2() {};
			Empty.prototype = target.prototype;
			bound.prototype = new Empty();
			Empty.prototype = null;
		}
		return bound;
	};
	return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
	if (hasRequiredFunctionBind) return functionBind;
	hasRequiredFunctionBind = 1;
	var implementation2 = requireImplementation();
	functionBind = Function.prototype.bind || implementation2;
	return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
	if (hasRequiredFunctionCall) return functionCall;
	hasRequiredFunctionCall = 1;
	functionCall = Function.prototype.call;
	return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
	if (hasRequiredFunctionApply) return functionApply;
	hasRequiredFunctionApply = 1;
	functionApply = Function.prototype.apply;
	return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
	if (hasRequiredReflectApply) return reflectApply;
	hasRequiredReflectApply = 1;
	reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
	return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
	if (hasRequiredActualApply) return actualApply;
	hasRequiredActualApply = 1;
	var bind$5 = requireFunctionBind();
	var $apply$2 = requireFunctionApply();
	var $call$3 = requireFunctionCall();
	actualApply = requireReflectApply() || bind$5.call($call$3, $apply$2);
	return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
	if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
	hasRequiredCallBindApplyHelpers = 1;
	var bind$5 = requireFunctionBind();
	var $TypeError$3 = /* @__PURE__ */ requireType();
	var $call$3 = requireFunctionCall();
	var $actualApply$1 = requireActualApply();
	callBindApplyHelpers = function callBindBasic(args) {
		if (args.length < 1 || typeof args[0] !== "function") throw new $TypeError$3("a function is required");
		return $actualApply$1(bind$5, $call$3, args);
	};
	return callBindApplyHelpers;
}
var get;
var hasRequiredGet;
function requireGet() {
	if (hasRequiredGet) return get;
	hasRequiredGet = 1;
	var callBind$1 = requireCallBindApplyHelpers();
	var gOPD2 = /* @__PURE__ */ requireGopd();
	var hasProtoAccessor$1;
	try {
		hasProtoAccessor$1 = [].__proto__ === Array.prototype;
	} catch (e) {
		if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") throw e;
	}
	var desc$1 = !!hasProtoAccessor$1 && gOPD2 && gOPD2(
		Object.prototype,
		/** @type {keyof typeof Object.prototype} */
		"__proto__"
	);
	var $Object$3 = Object;
	var $getPrototypeOf$1 = $Object$3.getPrototypeOf;
	get = desc$1 && typeof desc$1.get === "function" ? callBind$1([desc$1.get]) : typeof $getPrototypeOf$1 === "function" ? (function getDunder(value) {
		return $getPrototypeOf$1(value == null ? value : $Object$3(value));
	}) : false;
	return get;
}
var getProto;
var hasRequiredGetProto;
function requireGetProto() {
	if (hasRequiredGetProto) return getProto;
	hasRequiredGetProto = 1;
	var reflectGetProto$1 = requireReflect_getPrototypeOf();
	var originalGetProto$1 = requireObject_getPrototypeOf();
	var getDunderProto$1 = /* @__PURE__ */ requireGet();
	getProto = reflectGetProto$1 ? function getProto2(O) {
		return reflectGetProto$1(O);
	} : originalGetProto$1 ? function getProto2(O) {
		if (!O || typeof O !== "object" && typeof O !== "function") throw new TypeError("getProto: not an object");
		return originalGetProto$1(O);
	} : getDunderProto$1 ? function getProto2(O) {
		return getDunderProto$1(O);
	} : null;
	return getProto;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
	if (hasRequiredHasown) return hasown;
	hasRequiredHasown = 1;
	var call$1 = Function.prototype.call;
	var $hasOwn$1 = Object.prototype.hasOwnProperty;
	hasown = requireFunctionBind().call(call$1, $hasOwn$1);
	return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
	if (hasRequiredGetIntrinsic) return getIntrinsic;
	hasRequiredGetIntrinsic = 1;
	var undefined$1$1;
	var $Object$3 = /* @__PURE__ */ requireEsObjectAtoms();
	var $Error$1 = /* @__PURE__ */ requireEsErrors();
	var $EvalError$1 = /* @__PURE__ */ require_eval();
	var $RangeError$1 = /* @__PURE__ */ requireRange();
	var $ReferenceError$1 = /* @__PURE__ */ requireRef();
	var $SyntaxError$1 = /* @__PURE__ */ requireSyntax();
	var $TypeError$3 = /* @__PURE__ */ requireType();
	var $URIError$1 = /* @__PURE__ */ requireUri();
	var abs2 = /* @__PURE__ */ requireAbs();
	var floor2 = /* @__PURE__ */ requireFloor();
	var max2 = /* @__PURE__ */ requireMax();
	var min2 = /* @__PURE__ */ requireMin();
	var pow2 = /* @__PURE__ */ requirePow();
	var round2 = /* @__PURE__ */ requireRound();
	var sign2 = /* @__PURE__ */ requireSign();
	var $Function$1 = Function;
	var getEvalledConstructor$1 = function(expressionSyntax) {
		try {
			return $Function$1("\"use strict\"; return (" + expressionSyntax + ").constructor;")();
		} catch (e) {}
	};
	var $gOPD$2 = /* @__PURE__ */ requireGopd();
	var $defineProperty$3 = /* @__PURE__ */ requireEsDefineProperty();
	var throwTypeError$1 = function() {
		throw new $TypeError$3();
	};
	var ThrowTypeError$1 = $gOPD$2 ? function() {
		try {
			arguments.callee;
			return throwTypeError$1;
		} catch (calleeThrows) {
			try {
				return $gOPD$2(arguments, "callee").get;
			} catch (gOPDthrows) {
				return throwTypeError$1;
			}
		}
	}() : throwTypeError$1;
	var hasSymbols2 = requireHasSymbols()();
	var getProto2 = requireGetProto();
	var $ObjectGPO$1 = requireObject_getPrototypeOf();
	var $ReflectGPO$1 = requireReflect_getPrototypeOf();
	var $apply$2 = requireFunctionApply();
	var $call$3 = requireFunctionCall();
	var needsEval$1 = {};
	var TypedArray$1 = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1$1 : getProto2(Uint8Array);
	var INTRINSICS$1 = {
		__proto__: null,
		"%AggregateError%": typeof AggregateError === "undefined" ? undefined$1$1 : AggregateError,
		"%Array%": Array,
		"%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1$1 : ArrayBuffer,
		"%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1$1,
		"%AsyncFromSyncIteratorPrototype%": undefined$1$1,
		"%AsyncFunction%": needsEval$1,
		"%AsyncGenerator%": needsEval$1,
		"%AsyncGeneratorFunction%": needsEval$1,
		"%AsyncIteratorPrototype%": needsEval$1,
		"%Atomics%": typeof Atomics === "undefined" ? undefined$1$1 : Atomics,
		"%BigInt%": typeof BigInt === "undefined" ? undefined$1$1 : BigInt,
		"%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1$1 : BigInt64Array,
		"%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1$1 : BigUint64Array,
		"%Boolean%": Boolean,
		"%DataView%": typeof DataView === "undefined" ? undefined$1$1 : DataView,
		"%Date%": Date,
		"%decodeURI%": decodeURI,
		"%decodeURIComponent%": decodeURIComponent,
		"%encodeURI%": encodeURI,
		"%encodeURIComponent%": encodeURIComponent,
		"%Error%": $Error$1,
		"%eval%": eval,
		"%EvalError%": $EvalError$1,
		"%Float16Array%": typeof Float16Array === "undefined" ? undefined$1$1 : Float16Array,
		"%Float32Array%": typeof Float32Array === "undefined" ? undefined$1$1 : Float32Array,
		"%Float64Array%": typeof Float64Array === "undefined" ? undefined$1$1 : Float64Array,
		"%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1$1 : FinalizationRegistry,
		"%Function%": $Function$1,
		"%GeneratorFunction%": needsEval$1,
		"%Int8Array%": typeof Int8Array === "undefined" ? undefined$1$1 : Int8Array,
		"%Int16Array%": typeof Int16Array === "undefined" ? undefined$1$1 : Int16Array,
		"%Int32Array%": typeof Int32Array === "undefined" ? undefined$1$1 : Int32Array,
		"%isFinite%": isFinite,
		"%isNaN%": isNaN,
		"%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1$1,
		"%JSON%": typeof JSON === "object" ? JSON : undefined$1$1,
		"%Map%": typeof Map === "undefined" ? undefined$1$1 : Map,
		"%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
		"%Math%": Math,
		"%Number%": Number,
		"%Object%": $Object$3,
		"%Object.getOwnPropertyDescriptor%": $gOPD$2,
		"%parseFloat%": parseFloat,
		"%parseInt%": parseInt,
		"%Promise%": typeof Promise === "undefined" ? undefined$1$1 : Promise,
		"%Proxy%": typeof Proxy === "undefined" ? undefined$1$1 : Proxy,
		"%RangeError%": $RangeError$1,
		"%ReferenceError%": $ReferenceError$1,
		"%Reflect%": typeof Reflect === "undefined" ? undefined$1$1 : Reflect,
		"%RegExp%": RegExp,
		"%Set%": typeof Set === "undefined" ? undefined$1$1 : Set,
		"%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
		"%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1$1 : SharedArrayBuffer,
		"%String%": String,
		"%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1$1,
		"%Symbol%": hasSymbols2 ? Symbol : undefined$1$1,
		"%SyntaxError%": $SyntaxError$1,
		"%ThrowTypeError%": ThrowTypeError$1,
		"%TypedArray%": TypedArray$1,
		"%TypeError%": $TypeError$3,
		"%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1$1 : Uint8Array,
		"%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1$1 : Uint8ClampedArray,
		"%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1$1 : Uint16Array,
		"%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1$1 : Uint32Array,
		"%URIError%": $URIError$1,
		"%WeakMap%": typeof WeakMap === "undefined" ? undefined$1$1 : WeakMap,
		"%WeakRef%": typeof WeakRef === "undefined" ? undefined$1$1 : WeakRef,
		"%WeakSet%": typeof WeakSet === "undefined" ? undefined$1$1 : WeakSet,
		"%Function.prototype.call%": $call$3,
		"%Function.prototype.apply%": $apply$2,
		"%Object.defineProperty%": $defineProperty$3,
		"%Object.getPrototypeOf%": $ObjectGPO$1,
		"%Math.abs%": abs2,
		"%Math.floor%": floor2,
		"%Math.max%": max2,
		"%Math.min%": min2,
		"%Math.pow%": pow2,
		"%Math.round%": round2,
		"%Math.sign%": sign2,
		"%Reflect.getPrototypeOf%": $ReflectGPO$1
	};
	if (getProto2) try {
		null.error;
	} catch (e) {
		INTRINSICS$1["%Error.prototype%"] = getProto2(getProto2(e));
	}
	var doEval$1 = function doEval2(name) {
		var value;
		if (name === "%AsyncFunction%") value = getEvalledConstructor$1("async function () {}");
		else if (name === "%GeneratorFunction%") value = getEvalledConstructor$1("function* () {}");
		else if (name === "%AsyncGeneratorFunction%") value = getEvalledConstructor$1("async function* () {}");
		else if (name === "%AsyncGenerator%") {
			var fn = doEval2("%AsyncGeneratorFunction%");
			if (fn) value = fn.prototype;
		} else if (name === "%AsyncIteratorPrototype%") {
			var gen = doEval2("%AsyncGenerator%");
			if (gen && getProto2) value = getProto2(gen.prototype);
		}
		INTRINSICS$1[name] = value;
		return value;
	};
	var LEGACY_ALIASES$1 = {
		__proto__: null,
		"%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
		"%ArrayPrototype%": ["Array", "prototype"],
		"%ArrayProto_entries%": [
			"Array",
			"prototype",
			"entries"
		],
		"%ArrayProto_forEach%": [
			"Array",
			"prototype",
			"forEach"
		],
		"%ArrayProto_keys%": [
			"Array",
			"prototype",
			"keys"
		],
		"%ArrayProto_values%": [
			"Array",
			"prototype",
			"values"
		],
		"%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
		"%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
		"%AsyncGeneratorPrototype%": [
			"AsyncGeneratorFunction",
			"prototype",
			"prototype"
		],
		"%BooleanPrototype%": ["Boolean", "prototype"],
		"%DataViewPrototype%": ["DataView", "prototype"],
		"%DatePrototype%": ["Date", "prototype"],
		"%ErrorPrototype%": ["Error", "prototype"],
		"%EvalErrorPrototype%": ["EvalError", "prototype"],
		"%Float32ArrayPrototype%": ["Float32Array", "prototype"],
		"%Float64ArrayPrototype%": ["Float64Array", "prototype"],
		"%FunctionPrototype%": ["Function", "prototype"],
		"%Generator%": ["GeneratorFunction", "prototype"],
		"%GeneratorPrototype%": [
			"GeneratorFunction",
			"prototype",
			"prototype"
		],
		"%Int8ArrayPrototype%": ["Int8Array", "prototype"],
		"%Int16ArrayPrototype%": ["Int16Array", "prototype"],
		"%Int32ArrayPrototype%": ["Int32Array", "prototype"],
		"%JSONParse%": ["JSON", "parse"],
		"%JSONStringify%": ["JSON", "stringify"],
		"%MapPrototype%": ["Map", "prototype"],
		"%NumberPrototype%": ["Number", "prototype"],
		"%ObjectPrototype%": ["Object", "prototype"],
		"%ObjProto_toString%": [
			"Object",
			"prototype",
			"toString"
		],
		"%ObjProto_valueOf%": [
			"Object",
			"prototype",
			"valueOf"
		],
		"%PromisePrototype%": ["Promise", "prototype"],
		"%PromiseProto_then%": [
			"Promise",
			"prototype",
			"then"
		],
		"%Promise_all%": ["Promise", "all"],
		"%Promise_reject%": ["Promise", "reject"],
		"%Promise_resolve%": ["Promise", "resolve"],
		"%RangeErrorPrototype%": ["RangeError", "prototype"],
		"%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
		"%RegExpPrototype%": ["RegExp", "prototype"],
		"%SetPrototype%": ["Set", "prototype"],
		"%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
		"%StringPrototype%": ["String", "prototype"],
		"%SymbolPrototype%": ["Symbol", "prototype"],
		"%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
		"%TypedArrayPrototype%": ["TypedArray", "prototype"],
		"%TypeErrorPrototype%": ["TypeError", "prototype"],
		"%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
		"%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
		"%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
		"%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
		"%URIErrorPrototype%": ["URIError", "prototype"],
		"%WeakMapPrototype%": ["WeakMap", "prototype"],
		"%WeakSetPrototype%": ["WeakSet", "prototype"]
	};
	var bind$5 = requireFunctionBind();
	var hasOwn$3 = /* @__PURE__ */ requireHasown();
	var $concat$1 = bind$5.call($call$3, Array.prototype.concat);
	var $spliceApply$1 = bind$5.call($apply$2, Array.prototype.splice);
	var $replace$1 = bind$5.call($call$3, String.prototype.replace);
	var $strSlice$1 = bind$5.call($call$3, String.prototype.slice);
	var $exec$1 = bind$5.call($call$3, RegExp.prototype.exec);
	var rePropName$1 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
	var reEscapeChar$1 = /\\(\\)?/g;
	var stringToPath$1 = function stringToPath2(string$2) {
		var first = $strSlice$1(string$2, 0, 1);
		var last = $strSlice$1(string$2, -1);
		if (first === "%" && last !== "%") throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
		else if (last === "%" && first !== "%") throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
		var result = [];
		$replace$1(string$2, rePropName$1, function(match, number$3, quote, subString) {
			result[result.length] = quote ? $replace$1(subString, reEscapeChar$1, "$1") : number$3 || match;
		});
		return result;
	};
	var getBaseIntrinsic$1 = function getBaseIntrinsic2(name, allowMissing) {
		var intrinsicName = name;
		var alias;
		if (hasOwn$3(LEGACY_ALIASES$1, intrinsicName)) {
			alias = LEGACY_ALIASES$1[intrinsicName];
			intrinsicName = "%" + alias[0] + "%";
		}
		if (hasOwn$3(INTRINSICS$1, intrinsicName)) {
			var value = INTRINSICS$1[intrinsicName];
			if (value === needsEval$1) value = doEval$1(intrinsicName);
			if (typeof value === "undefined" && !allowMissing) throw new $TypeError$3("intrinsic " + name + " exists, but is not available. Please file an issue!");
			return {
				alias,
				name: intrinsicName,
				value
			};
		}
		throw new $SyntaxError$1("intrinsic " + name + " does not exist!");
	};
	getIntrinsic = function GetIntrinsic(name, allowMissing) {
		if (typeof name !== "string" || name.length === 0) throw new $TypeError$3("intrinsic name must be a non-empty string");
		if (arguments.length > 1 && typeof allowMissing !== "boolean") throw new $TypeError$3("\"allowMissing\" argument must be a boolean");
		if ($exec$1(/^%?[^%]*%?$/, name) === null) throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
		var parts = stringToPath$1(name);
		var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
		var intrinsic = getBaseIntrinsic$1("%" + intrinsicBaseName + "%", allowMissing);
		var intrinsicRealName = intrinsic.name;
		var value = intrinsic.value;
		var skipFurtherCaching = false;
		var alias = intrinsic.alias;
		if (alias) {
			intrinsicBaseName = alias[0];
			$spliceApply$1(parts, $concat$1([0, 1], alias));
		}
		for (var i = 1, isOwn = true; i < parts.length; i += 1) {
			var part = parts[i];
			var first = $strSlice$1(part, 0, 1);
			var last = $strSlice$1(part, -1);
			if ((first === "\"" || first === "'" || first === "`" || last === "\"" || last === "'" || last === "`") && first !== last) throw new $SyntaxError$1("property names with quotes must have matching quotes");
			if (part === "constructor" || !isOwn) skipFurtherCaching = true;
			intrinsicBaseName += "." + part;
			intrinsicRealName = "%" + intrinsicBaseName + "%";
			if (hasOwn$3(INTRINSICS$1, intrinsicRealName)) value = INTRINSICS$1[intrinsicRealName];
			else if (value != null) {
				if (!(part in value)) {
					if (!allowMissing) throw new $TypeError$3("base intrinsic for " + name + " exists, but the property is not available.");
					return;
				}
				if ($gOPD$2 && i + 1 >= parts.length) {
					var desc$1 = $gOPD$2(value, part);
					isOwn = !!desc$1;
					if (isOwn && "get" in desc$1 && !("originalValue" in desc$1.get)) value = desc$1.get;
					else value = value[part];
				} else {
					isOwn = hasOwn$3(value, part);
					value = value[part];
				}
				if (isOwn && !skipFurtherCaching) INTRINSICS$1[intrinsicRealName] = value;
			}
		}
		return value;
	};
	return getIntrinsic;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
	if (hasRequiredCallBound) return callBound;
	hasRequiredCallBound = 1;
	var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
	var callBindBasic = requireCallBindApplyHelpers();
	var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
	callBound = function callBoundIntrinsic(name, allowMissing) {
		var intrinsic = GetIntrinsic(name, !!allowMissing);
		if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) return callBindBasic(
			/** @type {const} */
			[intrinsic]
		);
		return intrinsic;
	};
	return callBound;
}
var sideChannelMap;
var hasRequiredSideChannelMap;
function requireSideChannelMap() {
	if (hasRequiredSideChannelMap) return sideChannelMap;
	hasRequiredSideChannelMap = 1;
	var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
	var callBound2 = /* @__PURE__ */ requireCallBound();
	var inspect = /* @__PURE__ */ requireObjectInspect();
	var $TypeError$3 = /* @__PURE__ */ requireType();
	var $Map = GetIntrinsic("%Map%", true);
	var $mapGet = callBound2("Map.prototype.get", true);
	var $mapSet = callBound2("Map.prototype.set", true);
	var $mapHas = callBound2("Map.prototype.has", true);
	var $mapDelete = callBound2("Map.prototype.delete", true);
	var $mapSize = callBound2("Map.prototype.size", true);
	sideChannelMap = !!$Map && function getSideChannelMap() {
		var $m;
		var channel = {
			assert: function(key) {
				if (!channel.has(key)) throw new $TypeError$3("Side channel does not contain " + inspect(key));
			},
			"delete": function(key) {
				if ($m) {
					var result = $mapDelete($m, key);
					if ($mapSize($m) === 0) $m = void 0;
					return result;
				}
				return false;
			},
			get: function(key) {
				if ($m) return $mapGet($m, key);
			},
			has: function(key) {
				if ($m) return $mapHas($m, key);
				return false;
			},
			set: function(key, value) {
				if (!$m) $m = new $Map();
				$mapSet($m, key, value);
			}
		};
		return channel;
	};
	return sideChannelMap;
}
var sideChannelWeakmap;
var hasRequiredSideChannelWeakmap;
function requireSideChannelWeakmap() {
	if (hasRequiredSideChannelWeakmap) return sideChannelWeakmap;
	hasRequiredSideChannelWeakmap = 1;
	var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
	var callBound2 = /* @__PURE__ */ requireCallBound();
	var inspect = /* @__PURE__ */ requireObjectInspect();
	var getSideChannelMap = requireSideChannelMap();
	var $TypeError$3 = /* @__PURE__ */ requireType();
	var $WeakMap = GetIntrinsic("%WeakMap%", true);
	var $weakMapGet = callBound2("WeakMap.prototype.get", true);
	var $weakMapSet = callBound2("WeakMap.prototype.set", true);
	var $weakMapHas = callBound2("WeakMap.prototype.has", true);
	var $weakMapDelete = callBound2("WeakMap.prototype.delete", true);
	sideChannelWeakmap = $WeakMap ? (function getSideChannelWeakMap() {
		var $wm;
		var $m;
		var channel = {
			assert: function(key) {
				if (!channel.has(key)) throw new $TypeError$3("Side channel does not contain " + inspect(key));
			},
			"delete": function(key) {
				if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
					if ($wm) return $weakMapDelete($wm, key);
				} else if (getSideChannelMap) {
					if ($m) return $m["delete"](key);
				}
				return false;
			},
			get: function(key) {
				if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
					if ($wm) return $weakMapGet($wm, key);
				}
				return $m && $m.get(key);
			},
			has: function(key) {
				if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
					if ($wm) return $weakMapHas($wm, key);
				}
				return !!$m && $m.has(key);
			},
			set: function(key, value) {
				if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
					if (!$wm) $wm = new $WeakMap();
					$weakMapSet($wm, key, value);
				} else if (getSideChannelMap) {
					if (!$m) $m = getSideChannelMap();
					$m.set(key, value);
				}
			}
		};
		return channel;
	}) : getSideChannelMap;
	return sideChannelWeakmap;
}
var sideChannel;
var hasRequiredSideChannel;
function requireSideChannel() {
	if (hasRequiredSideChannel) return sideChannel;
	hasRequiredSideChannel = 1;
	var $TypeError$3 = /* @__PURE__ */ requireType();
	var inspect = /* @__PURE__ */ requireObjectInspect();
	var getSideChannelList = requireSideChannelList();
	var getSideChannelMap = requireSideChannelMap();
	var makeChannel = requireSideChannelWeakmap() || getSideChannelMap || getSideChannelList;
	sideChannel = function getSideChannel() {
		var $channelData;
		var channel = {
			assert: function(key) {
				if (!channel.has(key)) throw new $TypeError$3("Side channel does not contain " + inspect(key));
			},
			"delete": function(key) {
				return !!$channelData && $channelData["delete"](key);
			},
			get: function(key) {
				return $channelData && $channelData.get(key);
			},
			has: function(key) {
				return !!$channelData && $channelData.has(key);
			},
			set: function(key, value) {
				if (!$channelData) $channelData = makeChannel();
				$channelData.set(key, value);
			}
		};
		return channel;
	};
	return sideChannel;
}
var formats;
var hasRequiredFormats;
function requireFormats() {
	if (hasRequiredFormats) return formats;
	hasRequiredFormats = 1;
	var replace = String.prototype.replace;
	var percentTwenties = /%20/g;
	var Format = {
		RFC1738: "RFC1738",
		RFC3986: "RFC3986"
	};
	formats = {
		"default": Format.RFC3986,
		formatters: {
			RFC1738: function(value) {
				return replace.call(value, percentTwenties, "+");
			},
			RFC3986: function(value) {
				return String(value);
			}
		},
		RFC1738: Format.RFC1738,
		RFC3986: Format.RFC3986
	};
	return formats;
}
var utils$1;
var hasRequiredUtils$1;
function requireUtils$1() {
	if (hasRequiredUtils$1) return utils$1;
	hasRequiredUtils$1 = 1;
	var formats2 = /* @__PURE__ */ requireFormats();
	var has = Object.prototype.hasOwnProperty;
	var isArray$1 = Array.isArray;
	var hexTable = function() {
		var array$1 = [];
		for (var i = 0; i < 256; ++i) array$1.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
		return array$1;
	}();
	var compactQueue = function compactQueue2(queue) {
		while (queue.length > 1) {
			var item = queue.pop();
			var obj = item.obj[item.prop];
			if (isArray$1(obj)) {
				var compacted = [];
				for (var j = 0; j < obj.length; ++j) if (typeof obj[j] !== "undefined") compacted.push(obj[j]);
				item.obj[item.prop] = compacted;
			}
		}
	};
	var arrayToObject$1 = function arrayToObject2(source, options) {
		var obj = options && options.plainObjects ? { __proto__: null } : {};
		for (var i = 0; i < source.length; ++i) if (typeof source[i] !== "undefined") obj[i] = source[i];
		return obj;
	};
	var merge$2 = function merge2(target, source, options) {
		if (!source) return target;
		if (typeof source !== "object" && typeof source !== "function") {
			if (isArray$1(target)) target.push(source);
			else if (target && typeof target === "object") {
				if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) target[source] = true;
			} else return [target, source];
			return target;
		}
		if (!target || typeof target !== "object") return [target].concat(source);
		var mergeTarget = target;
		if (isArray$1(target) && !isArray$1(source)) mergeTarget = arrayToObject$1(target, options);
		if (isArray$1(target) && isArray$1(source)) {
			source.forEach(function(item, i) {
				if (has.call(target, i)) {
					var targetItem = target[i];
					if (targetItem && typeof targetItem === "object" && item && typeof item === "object") target[i] = merge2(targetItem, item, options);
					else target.push(item);
				} else target[i] = item;
			});
			return target;
		}
		return Object.keys(source).reduce(function(acc, key) {
			var value = source[key];
			if (has.call(acc, key)) acc[key] = merge2(acc[key], value, options);
			else acc[key] = value;
			return acc;
		}, mergeTarget);
	};
	var assign = function assignSingleSource(target, source) {
		return Object.keys(source).reduce(function(acc, key) {
			acc[key] = source[key];
			return acc;
		}, target);
	};
	var decode$2 = function(str, defaultDecoder, charset2) {
		var strWithoutPlus = str.replace(/\+/g, " ");
		if (charset2 === "iso-8859-1") return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
		try {
			return decodeURIComponent(strWithoutPlus);
		} catch (e) {
			return strWithoutPlus;
		}
	};
	var limit = 1024;
	utils$1 = {
		arrayToObject: arrayToObject$1,
		assign,
		combine: function combine2(a, b) {
			return [].concat(a, b);
		},
		compact: function compact2(value) {
			var queue = [{
				obj: { o: value },
				prop: "o"
			}];
			var refs = [];
			for (var i = 0; i < queue.length; ++i) {
				var item = queue[i];
				var obj = item.obj[item.prop];
				var keys = Object.keys(obj);
				for (var j = 0; j < keys.length; ++j) {
					var key = keys[j];
					var val = obj[key];
					if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
						queue.push({
							obj,
							prop: key
						});
						refs.push(val);
					}
				}
			}
			compactQueue(queue);
			return value;
		},
		decode: decode$2,
		encode: function encode2(str, defaultEncoder, charset2, kind, format) {
			if (str.length === 0) return str;
			var string$2 = str;
			if (typeof str === "symbol") string$2 = Symbol.prototype.toString.call(str);
			else if (typeof str !== "string") string$2 = String(str);
			if (charset2 === "iso-8859-1") return escape(string$2).replace(/%u[0-9a-f]{4}/gi, function($0) {
				return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
			});
			var out = "";
			for (var j = 0; j < string$2.length; j += limit) {
				var segment$1 = string$2.length >= limit ? string$2.slice(j, j + limit) : string$2;
				var arr = [];
				for (var i = 0; i < segment$1.length; ++i) {
					var c = segment$1.charCodeAt(i);
					if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats2.RFC1738 && (c === 40 || c === 41)) {
						arr[arr.length] = segment$1.charAt(i);
						continue;
					}
					if (c < 128) {
						arr[arr.length] = hexTable[c];
						continue;
					}
					if (c < 2048) {
						arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
						continue;
					}
					if (c < 55296 || c >= 57344) {
						arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
						continue;
					}
					i += 1;
					c = 65536 + ((c & 1023) << 10 | segment$1.charCodeAt(i) & 1023);
					arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
				}
				out += arr.join("");
			}
			return out;
		},
		isBuffer: function isBuffer2(obj) {
			if (!obj || typeof obj !== "object") return false;
			return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
		},
		isRegExp: function isRegExp2(obj) {
			return Object.prototype.toString.call(obj) === "[object RegExp]";
		},
		maybeMap: function maybeMap2(val, fn) {
			if (isArray$1(val)) {
				var mapped = [];
				for (var i = 0; i < val.length; i += 1) mapped.push(fn(val[i]));
				return mapped;
			}
			return fn(val);
		},
		merge: merge$2
	};
	return utils$1;
}
var stringify_1;
var hasRequiredStringify;
function requireStringify() {
	if (hasRequiredStringify) return stringify_1;
	hasRequiredStringify = 1;
	var getSideChannel = requireSideChannel();
	var utils2 = /* @__PURE__ */ requireUtils$1();
	var formats2 = /* @__PURE__ */ requireFormats();
	var has = Object.prototype.hasOwnProperty;
	var arrayPrefixGenerators = {
		brackets: function brackets(prefix) {
			return prefix + "[]";
		},
		comma: "comma",
		indices: function indices(prefix, key) {
			return prefix + "[" + key + "]";
		},
		repeat: function repeat(prefix) {
			return prefix;
		}
	};
	var isArray$1 = Array.isArray;
	var push = Array.prototype.push;
	var pushToArray = function(arr, valueOrArray) {
		push.apply(arr, isArray$1(valueOrArray) ? valueOrArray : [valueOrArray]);
	};
	var toISO = Date.prototype.toISOString;
	var defaultFormat = formats2["default"];
	var defaults$1 = {
		addQueryPrefix: false,
		allowDots: false,
		allowEmptyArrays: false,
		arrayFormat: "indices",
		charset: "utf-8",
		charsetSentinel: false,
		commaRoundTrip: false,
		delimiter: "&",
		encode: true,
		encodeDotInKeys: false,
		encoder: utils2.encode,
		encodeValuesOnly: false,
		filter: void 0,
		format: defaultFormat,
		formatter: formats2.formatters[defaultFormat],
		indices: false,
		serializeDate: function serializeDate(date$2) {
			return toISO.call(date$2);
		},
		skipNulls: false,
		strictNullHandling: false
	};
	var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
		return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
	};
	var sentinel = {};
	var stringify = function stringify2(object$1, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset2, sideChannel2) {
		var obj = object$1;
		var tmpSc = sideChannel2;
		var step = 0;
		var findFlag = false;
		while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
			var pos = tmpSc.get(object$1);
			step += 1;
			if (typeof pos !== "undefined") if (pos === step) throw new RangeError("Cyclic object value");
			else findFlag = true;
			if (typeof tmpSc.get(sentinel) === "undefined") step = 0;
		}
		if (typeof filter === "function") obj = filter(prefix, obj);
		else if (obj instanceof Date) obj = serializeDate(obj);
		else if (generateArrayPrefix === "comma" && isArray$1(obj)) obj = utils2.maybeMap(obj, function(value2) {
			if (value2 instanceof Date) return serializeDate(value2);
			return value2;
		});
		if (obj === null) {
			if (strictNullHandling) return encoder && !encodeValuesOnly ? encoder(prefix, defaults$1.encoder, charset2, "key", format) : prefix;
			obj = "";
		}
		if (isNonNullishPrimitive(obj) || utils2.isBuffer(obj)) {
			if (encoder) return [formatter(encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder, charset2, "key", format)) + "=" + formatter(encoder(obj, defaults$1.encoder, charset2, "value", format))];
			return [formatter(prefix) + "=" + formatter(String(obj))];
		}
		var values = [];
		if (typeof obj === "undefined") return values;
		var objKeys;
		if (generateArrayPrefix === "comma" && isArray$1(obj)) {
			if (encodeValuesOnly && encoder) obj = utils2.maybeMap(obj, encoder);
			objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
		} else if (isArray$1(filter)) objKeys = filter;
		else {
			var keys = Object.keys(obj);
			objKeys = sort ? keys.sort(sort) : keys;
		}
		var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
		var adjustedPrefix = commaRoundTrip && isArray$1(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
		if (allowEmptyArrays && isArray$1(obj) && obj.length === 0) return adjustedPrefix + "[]";
		for (var j = 0; j < objKeys.length; ++j) {
			var key = objKeys[j];
			var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj[key];
			if (skipNulls && value === null) continue;
			var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
			var keyPrefix = isArray$1(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
			sideChannel2.set(object$1, step);
			var valueSideChannel = getSideChannel();
			valueSideChannel.set(sentinel, sideChannel2);
			pushToArray(values, stringify2(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === "comma" && encodeValuesOnly && isArray$1(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset2, valueSideChannel));
		}
		return values;
	};
	var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
		if (!opts) return defaults$1;
		if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
		if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
		if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") throw new TypeError("Encoder has to be a function.");
		var charset2 = opts.charset || defaults$1.charset;
		if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
		var format = formats2["default"];
		if (typeof opts.format !== "undefined") {
			if (!has.call(formats2.formatters, opts.format)) throw new TypeError("Unknown format option provided.");
			format = opts.format;
		}
		var formatter = formats2.formatters[format];
		var filter = defaults$1.filter;
		if (typeof opts.filter === "function" || isArray$1(opts.filter)) filter = opts.filter;
		var arrayFormat;
		if (opts.arrayFormat in arrayPrefixGenerators) arrayFormat = opts.arrayFormat;
		else if ("indices" in opts) arrayFormat = opts.indices ? "indices" : "repeat";
		else arrayFormat = defaults$1.arrayFormat;
		if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
		var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults$1.allowDots : !!opts.allowDots;
		return {
			addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
			allowDots,
			allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults$1.allowEmptyArrays,
			arrayFormat,
			charset: charset2,
			charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
			commaRoundTrip: !!opts.commaRoundTrip,
			delimiter: typeof opts.delimiter === "undefined" ? defaults$1.delimiter : opts.delimiter,
			encode: typeof opts.encode === "boolean" ? opts.encode : defaults$1.encode,
			encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults$1.encodeDotInKeys,
			encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$1.encoder,
			encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
			filter,
			format,
			formatter,
			serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$1.serializeDate,
			skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$1.skipNulls,
			sort: typeof opts.sort === "function" ? opts.sort : null,
			strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
		};
	};
	stringify_1 = function(object$1, opts) {
		var obj = object$1;
		var options = normalizeStringifyOptions(opts);
		var objKeys;
		var filter;
		if (typeof options.filter === "function") {
			filter = options.filter;
			obj = filter("", obj);
		} else if (isArray$1(options.filter)) {
			filter = options.filter;
			objKeys = filter;
		}
		var keys = [];
		if (typeof obj !== "object" || obj === null) return "";
		var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
		var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
		if (!objKeys) objKeys = Object.keys(obj);
		if (options.sort) objKeys.sort(options.sort);
		var sideChannel2 = getSideChannel();
		for (var i = 0; i < objKeys.length; ++i) {
			var key = objKeys[i];
			var value = obj[key];
			if (options.skipNulls && value === null) continue;
			pushToArray(keys, stringify(value, key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel2));
		}
		var joined = keys.join(options.delimiter);
		var prefix = options.addQueryPrefix === true ? "?" : "";
		if (options.charsetSentinel) if (options.charset === "iso-8859-1") prefix += "utf8=%26%2310003%3B&";
		else prefix += "utf8=%E2%9C%93&";
		return joined.length > 0 ? prefix + joined : "";
	};
	return stringify_1;
}
var parse;
var hasRequiredParse;
function requireParse() {
	if (hasRequiredParse) return parse;
	hasRequiredParse = 1;
	var utils2 = /* @__PURE__ */ requireUtils$1();
	var has = Object.prototype.hasOwnProperty;
	var isArray$1 = Array.isArray;
	var defaults$1 = {
		allowDots: false,
		allowEmptyArrays: false,
		allowPrototypes: false,
		allowSparse: false,
		arrayLimit: 20,
		charset: "utf-8",
		charsetSentinel: false,
		comma: false,
		decodeDotInKeys: false,
		decoder: utils2.decode,
		delimiter: "&",
		depth: 5,
		duplicates: "combine",
		ignoreQueryPrefix: false,
		interpretNumericEntities: false,
		parameterLimit: 1e3,
		parseArrays: true,
		plainObjects: false,
		strictDepth: false,
		strictNullHandling: false,
		throwOnLimitExceeded: false
	};
	var interpretNumericEntities = function(str) {
		return str.replace(/&#(\d+);/g, function($0, numberStr) {
			return String.fromCharCode(parseInt(numberStr, 10));
		});
	};
	var parseArrayValue = function(val, options, currentArrayLength) {
		if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) return val.split(",");
		if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
		return val;
	};
	var isoSentinel = "utf8=%26%2310003%3B";
	var charsetSentinel = "utf8=%E2%9C%93";
	var parseValues = function parseQueryStringValues(str, options) {
		var obj = { __proto__: null };
		var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
		cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
		var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
		var parts = cleanStr.split(options.delimiter, options.throwOnLimitExceeded ? limit + 1 : limit);
		if (options.throwOnLimitExceeded && parts.length > limit) throw new RangeError("Parameter limit exceeded. Only " + limit + " parameter" + (limit === 1 ? "" : "s") + " allowed.");
		var skipIndex = -1;
		var i;
		var charset2 = options.charset;
		if (options.charsetSentinel) {
			for (i = 0; i < parts.length; ++i) if (parts[i].indexOf("utf8=") === 0) {
				if (parts[i] === charsetSentinel) charset2 = "utf-8";
				else if (parts[i] === isoSentinel) charset2 = "iso-8859-1";
				skipIndex = i;
				i = parts.length;
			}
		}
		for (i = 0; i < parts.length; ++i) {
			if (i === skipIndex) continue;
			var part = parts[i];
			var bracketEqualsPos = part.indexOf("]=");
			var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
			var key;
			var val;
			if (pos === -1) {
				key = options.decoder(part, defaults$1.decoder, charset2, "key");
				val = options.strictNullHandling ? null : "";
			} else {
				key = options.decoder(part.slice(0, pos), defaults$1.decoder, charset2, "key");
				val = utils2.maybeMap(parseArrayValue(part.slice(pos + 1), options, isArray$1(obj[key]) ? obj[key].length : 0), function(encodedVal) {
					return options.decoder(encodedVal, defaults$1.decoder, charset2, "value");
				});
			}
			if (val && options.interpretNumericEntities && charset2 === "iso-8859-1") val = interpretNumericEntities(String(val));
			if (part.indexOf("[]=") > -1) val = isArray$1(val) ? [val] : val;
			var existing = has.call(obj, key);
			if (existing && options.duplicates === "combine") obj[key] = utils2.combine(obj[key], val);
			else if (!existing || options.duplicates === "last") obj[key] = val;
		}
		return obj;
	};
	var parseObject = function(chain, val, options, valuesParsed) {
		var currentArrayLength = 0;
		if (chain.length > 0 && chain[chain.length - 1] === "[]") {
			var parentKey = chain.slice(0, -1).join("");
			currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
		}
		var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
		for (var i = chain.length - 1; i >= 0; --i) {
			var obj;
			var root = chain[i];
			if (root === "[]" && options.parseArrays) obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : utils2.combine([], leaf);
			else {
				obj = options.plainObjects ? { __proto__: null } : {};
				var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
				var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
				var index2 = parseInt(decodedRoot, 10);
				if (!options.parseArrays && decodedRoot === "") obj = { 0: leaf };
				else if (!isNaN(index2) && root !== decodedRoot && String(index2) === decodedRoot && index2 >= 0 && options.parseArrays && index2 <= options.arrayLimit) {
					obj = [];
					obj[index2] = leaf;
				} else if (decodedRoot !== "__proto__") obj[decodedRoot] = leaf;
			}
			leaf = obj;
		}
		return leaf;
	};
	var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
		if (!givenKey) return;
		var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
		var brackets = /(\[[^[\]]*])/;
		var child = /(\[[^[\]]*])/g;
		var segment$1 = options.depth > 0 && brackets.exec(key);
		var parent = segment$1 ? key.slice(0, segment$1.index) : key;
		var keys = [];
		if (parent) {
			if (!options.plainObjects && has.call(Object.prototype, parent)) {
				if (!options.allowPrototypes) return;
			}
			keys.push(parent);
		}
		var i = 0;
		while (options.depth > 0 && (segment$1 = child.exec(key)) !== null && i < options.depth) {
			i += 1;
			if (!options.plainObjects && has.call(Object.prototype, segment$1[1].slice(1, -1))) {
				if (!options.allowPrototypes) return;
			}
			keys.push(segment$1[1]);
		}
		if (segment$1) {
			if (options.strictDepth === true) throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
			keys.push("[" + key.slice(segment$1.index) + "]");
		}
		return parseObject(keys, val, options, valuesParsed);
	};
	var normalizeParseOptions = function normalizeParseOptions2(opts) {
		if (!opts) return defaults$1;
		if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
		if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
		if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") throw new TypeError("Decoder has to be a function.");
		if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
		if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
		var charset2 = typeof opts.charset === "undefined" ? defaults$1.charset : opts.charset;
		var duplicates = typeof opts.duplicates === "undefined" ? defaults$1.duplicates : opts.duplicates;
		if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") throw new TypeError("The duplicates option must be either combine, first, or last");
		return {
			allowDots: typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults$1.allowDots : !!opts.allowDots,
			allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults$1.allowEmptyArrays,
			allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults$1.allowPrototypes,
			allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults$1.allowSparse,
			arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults$1.arrayLimit,
			charset: charset2,
			charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
			comma: typeof opts.comma === "boolean" ? opts.comma : defaults$1.comma,
			decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults$1.decodeDotInKeys,
			decoder: typeof opts.decoder === "function" ? opts.decoder : defaults$1.decoder,
			delimiter: typeof opts.delimiter === "string" || utils2.isRegExp(opts.delimiter) ? opts.delimiter : defaults$1.delimiter,
			depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults$1.depth,
			duplicates,
			ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
			interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults$1.interpretNumericEntities,
			parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults$1.parameterLimit,
			parseArrays: opts.parseArrays !== false,
			plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults$1.plainObjects,
			strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults$1.strictDepth,
			strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling,
			throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
		};
	};
	parse = function(str, opts) {
		var options = normalizeParseOptions(opts);
		if (str === "" || str === null || typeof str === "undefined") return options.plainObjects ? { __proto__: null } : {};
		var tempObj = typeof str === "string" ? parseValues(str, options) : str;
		var obj = options.plainObjects ? { __proto__: null } : {};
		var keys = Object.keys(tempObj);
		for (var i = 0; i < keys.length; ++i) {
			var key = keys[i];
			var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
			obj = utils2.merge(obj, newObj, options);
		}
		if (options.allowSparse === true) return obj;
		return utils2.compact(obj);
	};
	return parse;
}
var lib;
var hasRequiredLib;
function requireLib() {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;
	lib = {
		formats: /* @__PURE__ */ requireFormats(),
		parse: /* @__PURE__ */ requireParse(),
		stringify: /* @__PURE__ */ requireStringify()
	};
	return lib;
}
/*!
* body-parser
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var urlencoded_1;
var hasRequiredUrlencoded;
function requireUrlencoded() {
	if (hasRequiredUrlencoded) return urlencoded_1;
	hasRequiredUrlencoded = 1;
	var createError = requireHttpErrors();
	var debug$2 = requireBrowser()("body-parser:urlencoded");
	var isFinished = requireOnFinished().isFinished;
	var read = requireRead();
	var typeis = requireTypeIs();
	var qs = /* @__PURE__ */ requireLib();
	var { getCharset, normalizeOptions } = requireUtils$2();
	urlencoded_1 = urlencoded2;
	function urlencoded2(options) {
		var { inflate, limit, verify, shouldParse } = normalizeOptions(options, "application/x-www-form-urlencoded");
		var defaultCharset = options?.defaultCharset || "utf-8";
		if (defaultCharset !== "utf-8" && defaultCharset !== "iso-8859-1") throw new TypeError("option defaultCharset must be either utf-8 or iso-8859-1");
		var queryparse = createQueryParser(options);
		function parse2(body, encoding2) {
			return body.length ? queryparse(body, encoding2) : {};
		}
		return function urlencodedParser(req, res, next) {
			if (isFinished(req)) {
				debug$2("body already parsed");
				next();
				return;
			}
			if (!("body" in req)) req.body = void 0;
			if (!typeis.hasBody(req)) {
				debug$2("skip empty body");
				next();
				return;
			}
			debug$2("content-type %j", req.headers["content-type"]);
			if (!shouldParse(req)) {
				debug$2("skip parsing");
				next();
				return;
			}
			var charset2 = getCharset(req) || defaultCharset;
			if (charset2 !== "utf-8" && charset2 !== "iso-8859-1") {
				debug$2("invalid charset");
				next(createError(415, "unsupported charset \"" + charset2.toUpperCase() + "\"", {
					charset: charset2,
					type: "charset.unsupported"
				}));
				return;
			}
			read(req, res, next, parse2, debug$2, {
				encoding: charset2,
				inflate,
				limit,
				verify
			});
		};
	}
	function createQueryParser(options) {
		var extended = Boolean(options?.extended);
		var parameterLimit = options?.parameterLimit !== void 0 ? options?.parameterLimit : 1e3;
		var charsetSentinel = options?.charsetSentinel;
		var interpretNumericEntities = options?.interpretNumericEntities;
		var depth = extended ? options?.depth !== void 0 ? options?.depth : 32 : 0;
		if (isNaN(parameterLimit) || parameterLimit < 1) throw new TypeError("option parameterLimit must be a positive number");
		if (isNaN(depth) || depth < 0) throw new TypeError("option depth must be a zero or a positive number");
		if (isFinite(parameterLimit)) parameterLimit = parameterLimit | 0;
		return function queryparse(body, encoding2) {
			var paramCount = parameterCount(body, parameterLimit);
			if (paramCount === void 0) {
				debug$2("too many parameters");
				throw createError(413, "too many parameters", { type: "parameters.too.many" });
			}
			var arrayLimit = extended ? Math.max(100, paramCount) : 0;
			debug$2("parse " + (extended ? "extended " : "") + "urlencoding");
			try {
				return qs.parse(body, {
					allowPrototypes: true,
					arrayLimit,
					depth,
					charsetSentinel,
					interpretNumericEntities,
					charset: encoding2,
					parameterLimit,
					strictDepth: true
				});
			} catch (err) {
				if (err instanceof RangeError) throw createError(400, "The input exceeded the depth", { type: "querystring.parse.rangeError" });
				else throw err;
			}
		};
	}
	function parameterCount(body, limit) {
		var len = body.split("&").length;
		return len > limit ? void 0 : len - 1;
	}
	return urlencoded_1;
}
/*!
* body-parser
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var hasRequiredBodyParser;
function requireBodyParser() {
	if (hasRequiredBodyParser) return bodyParser.exports;
	hasRequiredBodyParser = 1;
	(function(module$1, exports$1) {
		exports$1 = module$1.exports = bodyParser2;
		Object.defineProperty(exports$1, "json", {
			configurable: true,
			enumerable: true,
			get: () => requireJson()
		});
		Object.defineProperty(exports$1, "raw", {
			configurable: true,
			enumerable: true,
			get: () => requireRaw()
		});
		Object.defineProperty(exports$1, "text", {
			configurable: true,
			enumerable: true,
			get: () => requireText()
		});
		Object.defineProperty(exports$1, "urlencoded", {
			configurable: true,
			enumerable: true,
			get: () => requireUrlencoded()
		});
		function bodyParser2() {
			throw new Error("The bodyParser() generic has been split into individual middleware to use instead.");
		}
	})(bodyParser, bodyParser.exports);
	return bodyParser.exports;
}
var mergeDescriptors_1;
var hasRequiredMergeDescriptors;
function requireMergeDescriptors() {
	if (hasRequiredMergeDescriptors) return mergeDescriptors_1;
	hasRequiredMergeDescriptors = 1;
	function mergeDescriptors(destination, source, overwrite = true) {
		if (!destination) throw new TypeError("The `destination` argument is required.");
		if (!source) throw new TypeError("The `source` argument is required.");
		for (const name of Object.getOwnPropertyNames(source)) {
			if (!overwrite && Object.hasOwn(destination, name)) continue;
			const descriptor = Object.getOwnPropertyDescriptor(source, name);
			Object.defineProperty(destination, name, descriptor);
		}
		return destination;
	}
	mergeDescriptors_1 = mergeDescriptors;
	return mergeDescriptors_1;
}
var application = { exports: {} };
/*!
* encodeurl
* Copyright(c) 2016 Douglas Christopher Wilson
* MIT Licensed
*/
var encodeurl;
var hasRequiredEncodeurl;
function requireEncodeurl() {
	if (hasRequiredEncodeurl) return encodeurl;
	hasRequiredEncodeurl = 1;
	encodeurl = encodeUrl;
	var ENCODE_CHARS_REGEXP = /(?:[^\x21\x23-\x3B\x3D\x3F-\x5F\x61-\x7A\x7C\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
	var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
	var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1$2";
	function encodeUrl(url$1) {
		return String(url$1).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
	}
	return encodeurl;
}
/*!
* escape-html
* Copyright(c) 2012-2013 TJ Holowaychuk
* Copyright(c) 2015 Andreas Lubbe
* Copyright(c) 2015 Tiancheng "Timothy" Gu
* MIT Licensed
*/
var escapeHtml_1;
var hasRequiredEscapeHtml;
function requireEscapeHtml() {
	if (hasRequiredEscapeHtml) return escapeHtml_1;
	hasRequiredEscapeHtml = 1;
	var matchHtmlRegExp = /["'&<>]/;
	escapeHtml_1 = escapeHtml;
	function escapeHtml(string$2) {
		var str = "" + string$2;
		var match = matchHtmlRegExp.exec(str);
		if (!match) return str;
		var escape2;
		var html = "";
		var index2 = 0;
		var lastIndex = 0;
		for (index2 = match.index; index2 < str.length; index2++) {
			switch (str.charCodeAt(index2)) {
				case 34:
					escape2 = "&quot;";
					break;
				case 38:
					escape2 = "&amp;";
					break;
				case 39:
					escape2 = "&#39;";
					break;
				case 60:
					escape2 = "&lt;";
					break;
				case 62:
					escape2 = "&gt;";
					break;
				default: continue;
			}
			if (lastIndex !== index2) html += str.substring(lastIndex, index2);
			lastIndex = index2 + 1;
			html += escape2;
		}
		return lastIndex !== index2 ? html + str.substring(lastIndex, index2) : html;
	}
	return escapeHtml_1;
}
var parseurl = { exports: {} };
/*!
* parseurl
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2014-2017 Douglas Christopher Wilson
* MIT Licensed
*/
var hasRequiredParseurl;
function requireParseurl() {
	if (hasRequiredParseurl) return parseurl.exports;
	hasRequiredParseurl = 1;
	var url$1 = URL2;
	var parse2 = url$1.parse;
	var Url = url$1.Url;
	parseurl.exports = parseurl$1;
	parseurl.exports.original = originalurl;
	function parseurl$1(req) {
		var url2 = req.url;
		if (url2 === void 0) return;
		var parsed = req._parsedUrl;
		if (fresh(url2, parsed)) return parsed;
		parsed = fastparse(url2);
		parsed._raw = url2;
		return req._parsedUrl = parsed;
	}
	function originalurl(req) {
		var url2 = req.originalUrl;
		if (typeof url2 !== "string") return parseurl$1(req);
		var parsed = req._parsedOriginalUrl;
		if (fresh(url2, parsed)) return parsed;
		parsed = fastparse(url2);
		parsed._raw = url2;
		return req._parsedOriginalUrl = parsed;
	}
	function fastparse(str) {
		if (typeof str !== "string" || str.charCodeAt(0) !== 47) return parse2(str);
		var pathname = str;
		var query = null;
		var search = null;
		for (var i = 1; i < str.length; i++) switch (str.charCodeAt(i)) {
			case 63:
				if (search === null) {
					pathname = str.substring(0, i);
					query = str.substring(i + 1);
					search = str.substring(i);
				}
				break;
			case 9:
			case 10:
			case 12:
			case 13:
			case 32:
			case 35:
			case 160:
			case 65279: return parse2(str);
		}
		var url2 = Url !== void 0 ? new Url() : {};
		url2.path = str;
		url2.href = str;
		url2.pathname = pathname;
		if (search !== null) {
			url2.query = query;
			url2.search = search;
		}
		return url2;
	}
	function fresh(url2, parsedUrl) {
		return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url2;
	}
	return parseurl.exports;
}
/*!
* finalhandler
* Copyright(c) 2014-2022 Douglas Christopher Wilson
* MIT Licensed
*/
var finalhandler_1;
var hasRequiredFinalhandler;
function requireFinalhandler() {
	if (hasRequiredFinalhandler) return finalhandler_1;
	hasRequiredFinalhandler = 1;
	var debug$2 = requireBrowser()("finalhandler");
	var encodeUrl = requireEncodeurl();
	var escapeHtml = requireEscapeHtml();
	var onFinished2 = requireOnFinished();
	var parseUrl$3 = requireParseurl();
	var statuses2 = requireStatuses();
	var isFinished = onFinished2.isFinished;
	function createHtmlDocument(message) {
		return "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Error</title>\n</head>\n<body>\n<pre>" + escapeHtml(message).replaceAll("\n", "<br>").replaceAll("  ", " &nbsp;") + "</pre>\n</body>\n</html>\n";
	}
	finalhandler_1 = finalhandler;
	function finalhandler(req, res, options) {
		var opts = options || {};
		var env$1 = opts.env || process.env.NODE_ENV || "development";
		var onerror = opts.onerror;
		return function(err) {
			var headers;
			var msg;
			var status;
			if (!err && res.headersSent) {
				debug$2("cannot 404 after headers sent");
				return;
			}
			if (err) {
				status = getErrorStatusCode(err);
				if (status === void 0) status = getResponseStatusCode(res);
				else headers = getErrorHeaders(err);
				msg = getErrorMessage(err, status, env$1);
			} else {
				status = 404;
				msg = "Cannot " + req.method + " " + encodeUrl(getResourceName(req));
			}
			debug$2("default %s", status);
			if (err && onerror) setImmediate(onerror, err, req, res);
			if (res.headersSent) {
				debug$2("cannot %d after headers sent", status);
				if (req.socket) req.socket.destroy();
				return;
			}
			send(req, res, status, headers, msg);
		};
	}
	function getErrorHeaders(err) {
		if (!err.headers || typeof err.headers !== "object") return;
		return { ...err.headers };
	}
	function getErrorMessage(err, status, env$1) {
		var msg;
		if (env$1 !== "production") {
			msg = err.stack;
			if (!msg && typeof err.toString === "function") msg = err.toString();
		}
		return msg || statuses2.message[status];
	}
	function getErrorStatusCode(err) {
		if (typeof err.status === "number" && err.status >= 400 && err.status < 600) return err.status;
		if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) return err.statusCode;
	}
	function getResourceName(req) {
		try {
			return parseUrl$3.original(req).pathname;
		} catch (e) {
			return "resource";
		}
	}
	function getResponseStatusCode(res) {
		var status = res.statusCode;
		if (typeof status !== "number" || status < 400 || status > 599) status = 500;
		return status;
	}
	function send(req, res, status, headers, message) {
		function write() {
			var body = createHtmlDocument(message);
			res.statusCode = status;
			if (req.httpVersionMajor < 2) res.statusMessage = statuses2.message[status];
			res.removeHeader("Content-Encoding");
			res.removeHeader("Content-Language");
			res.removeHeader("Content-Range");
			for (const [key, value] of Object.entries(headers ?? {})) res.setHeader(key, value);
			res.setHeader("Content-Security-Policy", "default-src 'none'");
			res.setHeader("X-Content-Type-Options", "nosniff");
			res.setHeader("Content-Type", "text/html; charset=utf-8");
			res.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
			if (req.method === "HEAD") {
				res.end();
				return;
			}
			res.end(body, "utf8");
		}
		if (isFinished(req)) {
			write();
			return;
		}
		req.unpipe();
		onFinished2(req, write);
		req.resume();
	}
	return finalhandler_1;
}
function commonjsRequire(path$3) {
	throw new Error("Could not dynamically require \"" + path$3 + "\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.");
}
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var view;
var hasRequiredView;
function requireView() {
	if (hasRequiredView) return view;
	hasRequiredView = 1;
	var debug$2 = requireBrowser()("express:view");
	var path$3 = path;
	var fs$4 = fs$1;
	var dirname = path$3.dirname;
	var basename = path$3.basename;
	var extname$1 = path$3.extname;
	var join$1 = path$3.join;
	var resolve = path$3.resolve;
	view = View;
	function View(name, options) {
		var opts = options || {};
		this.defaultEngine = opts.defaultEngine;
		this.ext = extname$1(name);
		this.name = name;
		this.root = opts.root;
		if (!this.ext && !this.defaultEngine) throw new Error("No default engine was specified and no extension was provided.");
		var fileName = name;
		if (!this.ext) {
			this.ext = this.defaultEngine[0] !== "." ? "." + this.defaultEngine : this.defaultEngine;
			fileName += this.ext;
		}
		if (!opts.engines[this.ext]) {
			var mod = this.ext.slice(1);
			debug$2("require \"%s\"", mod);
			var fn = commonjsRequire(mod).__express;
			if (typeof fn !== "function") throw new Error("Module \"" + mod + "\" does not provide a view engine.");
			opts.engines[this.ext] = fn;
		}
		this.engine = opts.engines[this.ext];
		this.path = this.lookup(fileName);
	}
	View.prototype.lookup = function lookup$1(name) {
		var path2;
		var roots = [].concat(this.root);
		debug$2("lookup \"%s\"", name);
		for (var i = 0; i < roots.length && !path2; i++) {
			var root = roots[i];
			var loc = resolve(root, name);
			var dir = dirname(loc);
			var file$2 = basename(loc);
			path2 = this.resolve(dir, file$2);
		}
		return path2;
	};
	View.prototype.render = function render$1(options, callback) {
		var sync = true;
		debug$2("render \"%s\"", this.path);
		this.engine(this.path, options, function onRender() {
			if (!sync) return callback.apply(this, arguments);
			var args = new Array(arguments.length);
			var cntx = this;
			for (var i = 0; i < arguments.length; i++) args[i] = arguments[i];
			return process.nextTick(function renderTick() {
				return callback.apply(cntx, args);
			});
		});
		sync = false;
	};
	View.prototype.resolve = function resolve2(dir, file$2) {
		var ext = this.ext;
		var path2 = join$1(dir, file$2);
		var stat$1 = tryStat(path2);
		if (stat$1 && stat$1.isFile()) return path2;
		path2 = join$1(dir, basename(file$2, ext), "index" + ext);
		stat$1 = tryStat(path2);
		if (stat$1 && stat$1.isFile()) return path2;
	};
	function tryStat(path2) {
		debug$2("stat \"%s\"", path2);
		try {
			return fs$4.statSync(path2);
		} catch (e) {
			return;
		}
	}
	return view;
}
var utils = {};
/*!
* etag
* Copyright(c) 2014-2016 Douglas Christopher Wilson
* MIT Licensed
*/
var etag_1;
var hasRequiredEtag;
function requireEtag() {
	if (hasRequiredEtag) return etag_1;
	hasRequiredEtag = 1;
	etag_1 = etag;
	var crypto$2 = crypto;
	var Stats = fs.Stats;
	var toString$1 = Object.prototype.toString;
	function entitytag(entity) {
		if (entity.length === 0) return "\"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk\"";
		var hash = crypto$2.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
		return "\"" + (typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length).toString(16) + "-" + hash + "\"";
	}
	function etag(entity, options) {
		if (entity == null) throw new TypeError("argument entity is required");
		var isStats = isstats(entity);
		var weak = options && typeof options.weak === "boolean" ? options.weak : isStats;
		if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
		var tag = isStats ? stattag(entity) : entitytag(entity);
		return weak ? "W/" + tag : tag;
	}
	function isstats(obj) {
		if (typeof Stats === "function" && obj instanceof Stats) return true;
		return obj && typeof obj === "object" && "ctime" in obj && toString$1.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString$1.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
	}
	function stattag(stat$1) {
		var mtime = stat$1.mtime.getTime().toString(16);
		return "\"" + stat$1.size.toString(16) + "-" + mtime + "\"";
	}
	return etag_1;
}
var proxyAddr = { exports: {} };
/*!
* forwarded
* Copyright(c) 2014-2017 Douglas Christopher Wilson
* MIT Licensed
*/
var forwarded_1;
var hasRequiredForwarded;
function requireForwarded() {
	if (hasRequiredForwarded) return forwarded_1;
	hasRequiredForwarded = 1;
	forwarded_1 = forwarded;
	function forwarded(req) {
		if (!req) throw new TypeError("argument req is required");
		var proxyAddrs = parse2(req.headers["x-forwarded-for"] || "");
		return [getSocketAddr(req)].concat(proxyAddrs);
	}
	function getSocketAddr(req) {
		return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
	}
	function parse2(header) {
		var end = header.length;
		var list = [];
		var start = header.length;
		for (var i = header.length - 1; i >= 0; i--) switch (header.charCodeAt(i)) {
			case 32:
				if (start === end) start = end = i;
				break;
			case 44:
				if (start !== end) list.push(header.substring(start, end));
				start = end = i;
				break;
			default:
				start = i;
				break;
		}
		if (start !== end) list.push(header.substring(start, end));
		return list;
	}
	return forwarded_1;
}
var ipaddr$1 = { exports: {} };
var ipaddr = ipaddr$1.exports;
var hasRequiredIpaddr;
function requireIpaddr() {
	if (hasRequiredIpaddr) return ipaddr$1.exports;
	hasRequiredIpaddr = 1;
	(function(module$1) {
		(function() {
			var expandIPv6, ipaddr2 = {}, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root = this, zoneIndex;
			if (module$1 !== null && module$1.exports) module$1.exports = ipaddr2;
			else root["ipaddr"] = ipaddr2;
			matchCIDR = function(first, second, partSize, cidrBits) {
				var part, shift;
				if (first.length !== second.length) throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
				part = 0;
				while (cidrBits > 0) {
					shift = partSize - cidrBits;
					if (shift < 0) shift = 0;
					if (first[part] >> shift !== second[part] >> shift) return false;
					cidrBits -= partSize;
					part += 1;
				}
				return true;
			};
			ipaddr2.subnetMatch = function(address, rangeList, defaultName) {
				var k, len, rangeName, rangeSubnets, subnet;
				if (defaultName == null) defaultName = "unicast";
				for (rangeName in rangeList) {
					rangeSubnets = rangeList[rangeName];
					if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) rangeSubnets = [rangeSubnets];
					for (k = 0, len = rangeSubnets.length; k < len; k++) {
						subnet = rangeSubnets[k];
						if (address.kind() === subnet[0].kind()) {
							if (address.match.apply(address, subnet)) return rangeName;
						}
					}
				}
				return defaultName;
			};
			ipaddr2.IPv4 = function() {
				function IPv4(octets) {
					var k, len, octet;
					if (octets.length !== 4) throw new Error("ipaddr: ipv4 octet count should be 4");
					for (k = 0, len = octets.length; k < len; k++) {
						octet = octets[k];
						if (!(0 <= octet && octet <= 255)) throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
					}
					this.octets = octets;
				}
				IPv4.prototype.kind = function() {
					return "ipv4";
				};
				IPv4.prototype.toString = function() {
					return this.octets.join(".");
				};
				IPv4.prototype.toNormalizedString = function() {
					return this.toString();
				};
				IPv4.prototype.toByteArray = function() {
					return this.octets.slice(0);
				};
				IPv4.prototype.match = function(other, cidrRange) {
					var ref2;
					if (cidrRange === void 0) ref2 = other, other = ref2[0], cidrRange = ref2[1];
					if (other.kind() !== "ipv4") throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
					return matchCIDR(this.octets, other.octets, 8, cidrRange);
				};
				IPv4.prototype.SpecialRanges = {
					unspecified: [[new IPv4([
						0,
						0,
						0,
						0
					]), 8]],
					broadcast: [[new IPv4([
						255,
						255,
						255,
						255
					]), 32]],
					multicast: [[new IPv4([
						224,
						0,
						0,
						0
					]), 4]],
					linkLocal: [[new IPv4([
						169,
						254,
						0,
						0
					]), 16]],
					loopback: [[new IPv4([
						127,
						0,
						0,
						0
					]), 8]],
					carrierGradeNat: [[new IPv4([
						100,
						64,
						0,
						0
					]), 10]],
					"private": [
						[new IPv4([
							10,
							0,
							0,
							0
						]), 8],
						[new IPv4([
							172,
							16,
							0,
							0
						]), 12],
						[new IPv4([
							192,
							168,
							0,
							0
						]), 16]
					],
					reserved: [
						[new IPv4([
							192,
							0,
							0,
							0
						]), 24],
						[new IPv4([
							192,
							0,
							2,
							0
						]), 24],
						[new IPv4([
							192,
							88,
							99,
							0
						]), 24],
						[new IPv4([
							198,
							51,
							100,
							0
						]), 24],
						[new IPv4([
							203,
							0,
							113,
							0
						]), 24],
						[new IPv4([
							240,
							0,
							0,
							0
						]), 4]
					]
				};
				IPv4.prototype.range = function() {
					return ipaddr2.subnetMatch(this, this.SpecialRanges);
				};
				IPv4.prototype.toIPv4MappedAddress = function() {
					return ipaddr2.IPv6.parse("::ffff:" + this.toString());
				};
				IPv4.prototype.prefixLengthFromSubnetMask = function() {
					var cidr, i, k, octet, stop, zeros, zerotable = {
						0: 8,
						128: 7,
						192: 6,
						224: 5,
						240: 4,
						248: 3,
						252: 2,
						254: 1,
						255: 0
					};
					cidr = 0;
					stop = false;
					for (i = k = 3; k >= 0; i = k += -1) {
						octet = this.octets[i];
						if (octet in zerotable) {
							zeros = zerotable[octet];
							if (stop && zeros !== 0) return null;
							if (zeros !== 8) stop = true;
							cidr += zeros;
						} else return null;
					}
					return 32 - cidr;
				};
				return IPv4;
			}();
			ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
			ipv4Regexes = {
				fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
				longValue: new RegExp("^" + ipv4Part + "$", "i")
			};
			ipaddr2.IPv4.parser = function(string$2) {
				var match, parseIntAuto = function(string2) {
					if (string2[0] === "0" && string2[1] !== "x") return parseInt(string2, 8);
					else return parseInt(string2);
				}, part, shift, value;
				if (match = string$2.match(ipv4Regexes.fourOctet)) return function() {
					var k, len, ref2 = match.slice(1, 6), results = [];
					for (k = 0, len = ref2.length; k < len; k++) {
						part = ref2[k];
						results.push(parseIntAuto(part));
					}
					return results;
				}();
				else if (match = string$2.match(ipv4Regexes.longValue)) {
					value = parseIntAuto(match[1]);
					if (value > 4294967295 || value < 0) throw new Error("ipaddr: address outside defined range");
					return function() {
						var k, results = [];
						for (shift = k = 0; k <= 24; shift = k += 8) results.push(value >> shift & 255);
						return results;
					}().reverse();
				} else return null;
			};
			ipaddr2.IPv6 = function() {
				function IPv6(parts, zoneId) {
					var i, k, l, len, part, ref2;
					if (parts.length === 16) {
						this.parts = [];
						for (i = k = 0; k <= 14; i = k += 2) this.parts.push(parts[i] << 8 | parts[i + 1]);
					} else if (parts.length === 8) this.parts = parts;
					else throw new Error("ipaddr: ipv6 part count should be 8 or 16");
					ref2 = this.parts;
					for (l = 0, len = ref2.length; l < len; l++) {
						part = ref2[l];
						if (!(0 <= part && part <= 65535)) throw new Error("ipaddr: ipv6 part should fit in 16 bits");
					}
					if (zoneId) this.zoneId = zoneId;
				}
				IPv6.prototype.kind = function() {
					return "ipv6";
				};
				IPv6.prototype.toString = function() {
					return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
				};
				IPv6.prototype.toRFC5952String = function() {
					var bestMatchIndex, bestMatchLength, match, regex = /((^|:)(0(:|$)){2,})/g, string$2 = this.toNormalizedString();
					bestMatchIndex = 0;
					bestMatchLength = -1;
					while (match = regex.exec(string$2)) if (match[0].length > bestMatchLength) {
						bestMatchIndex = match.index;
						bestMatchLength = match[0].length;
					}
					if (bestMatchLength < 0) return string$2;
					return string$2.substring(0, bestMatchIndex) + "::" + string$2.substring(bestMatchIndex + bestMatchLength);
				};
				IPv6.prototype.toByteArray = function() {
					var bytes2 = [], k, len, part, ref2 = this.parts;
					for (k = 0, len = ref2.length; k < len; k++) {
						part = ref2[k];
						bytes2.push(part >> 8);
						bytes2.push(part & 255);
					}
					return bytes2;
				};
				IPv6.prototype.toNormalizedString = function() {
					var addr = function() {
						var k, len, ref2 = this.parts, results = [];
						for (k = 0, len = ref2.length; k < len; k++) {
							part = ref2[k];
							results.push(part.toString(16));
						}
						return results;
					}.call(this).join(":"), part, suffix = "";
					if (this.zoneId) suffix = "%" + this.zoneId;
					return addr + suffix;
				};
				IPv6.prototype.toFixedLengthString = function() {
					var addr = function() {
						var k, len, ref2 = this.parts, results = [];
						for (k = 0, len = ref2.length; k < len; k++) {
							part = ref2[k];
							results.push(part.toString(16).padStart(4, "0"));
						}
						return results;
					}.call(this).join(":"), part, suffix = "";
					if (this.zoneId) suffix = "%" + this.zoneId;
					return addr + suffix;
				};
				IPv6.prototype.match = function(other, cidrRange) {
					var ref2;
					if (cidrRange === void 0) ref2 = other, other = ref2[0], cidrRange = ref2[1];
					if (other.kind() !== "ipv6") throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
					return matchCIDR(this.parts, other.parts, 16, cidrRange);
				};
				IPv6.prototype.SpecialRanges = {
					unspecified: [new IPv6([
						0,
						0,
						0,
						0,
						0,
						0,
						0,
						0
					]), 128],
					linkLocal: [new IPv6([
						65152,
						0,
						0,
						0,
						0,
						0,
						0,
						0
					]), 10],
					multicast: [new IPv6([
						65280,
						0,
						0,
						0,
						0,
						0,
						0,
						0
					]), 8],
					loopback: [new IPv6([
						0,
						0,
						0,
						0,
						0,
						0,
						0,
						1
					]), 128],
					uniqueLocal: [new IPv6([
						64512,
						0,
						0,
						0,
						0,
						0,
						0,
						0
					]), 7],
					ipv4Mapped: [new IPv6([
						0,
						0,
						0,
						0,
						0,
						65535,
						0,
						0
					]), 96],
					rfc6145: [new IPv6([
						0,
						0,
						0,
						0,
						65535,
						0,
						0,
						0
					]), 96],
					rfc6052: [new IPv6([
						100,
						65435,
						0,
						0,
						0,
						0,
						0,
						0
					]), 96],
					"6to4": [new IPv6([
						8194,
						0,
						0,
						0,
						0,
						0,
						0,
						0
					]), 16],
					teredo: [new IPv6([
						8193,
						0,
						0,
						0,
						0,
						0,
						0,
						0
					]), 32],
					reserved: [[new IPv6([
						8193,
						3512,
						0,
						0,
						0,
						0,
						0,
						0
					]), 32]]
				};
				IPv6.prototype.range = function() {
					return ipaddr2.subnetMatch(this, this.SpecialRanges);
				};
				IPv6.prototype.isIPv4MappedAddress = function() {
					return this.range() === "ipv4Mapped";
				};
				IPv6.prototype.toIPv4Address = function() {
					var high, low, ref2;
					if (!this.isIPv4MappedAddress()) throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
					ref2 = this.parts.slice(-2), high = ref2[0], low = ref2[1];
					return new ipaddr2.IPv4([
						high >> 8,
						high & 255,
						low >> 8,
						low & 255
					]);
				};
				IPv6.prototype.prefixLengthFromSubnetMask = function() {
					var cidr, i, k, part, stop, zeros, zerotable = {
						0: 16,
						32768: 15,
						49152: 14,
						57344: 13,
						61440: 12,
						63488: 11,
						64512: 10,
						65024: 9,
						65280: 8,
						65408: 7,
						65472: 6,
						65504: 5,
						65520: 4,
						65528: 3,
						65532: 2,
						65534: 1,
						65535: 0
					};
					cidr = 0;
					stop = false;
					for (i = k = 7; k >= 0; i = k += -1) {
						part = this.parts[i];
						if (part in zerotable) {
							zeros = zerotable[part];
							if (stop && zeros !== 0) return null;
							if (zeros !== 16) stop = true;
							cidr += zeros;
						} else return null;
					}
					return 128 - cidr;
				};
				return IPv6;
			}();
			ipv6Part = "(?:[0-9a-f]+::?)+";
			zoneIndex = "%[0-9a-z]{1,}";
			ipv6Regexes = {
				zoneIndex: new RegExp(zoneIndex, "i"),
				"native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", "i"),
				transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), "i")
			};
			expandIPv6 = function(string$2, parts) {
				var colonCount, lastColon, part, replacement, replacementCount, zoneId;
				if (string$2.indexOf("::") !== string$2.lastIndexOf("::")) return null;
				zoneId = (string$2.match(ipv6Regexes["zoneIndex"]) || [])[0];
				if (zoneId) {
					zoneId = zoneId.substring(1);
					string$2 = string$2.replace(/%.+$/, "");
				}
				colonCount = 0;
				lastColon = -1;
				while ((lastColon = string$2.indexOf(":", lastColon + 1)) >= 0) colonCount++;
				if (string$2.substr(0, 2) === "::") colonCount--;
				if (string$2.substr(-2, 2) === "::") colonCount--;
				if (colonCount > parts) return null;
				replacementCount = parts - colonCount;
				replacement = ":";
				while (replacementCount--) replacement += "0:";
				string$2 = string$2.replace("::", replacement);
				if (string$2[0] === ":") string$2 = string$2.slice(1);
				if (string$2[string$2.length - 1] === ":") string$2 = string$2.slice(0, -1);
				parts = function() {
					var k, len, ref2 = string$2.split(":"), results = [];
					for (k = 0, len = ref2.length; k < len; k++) {
						part = ref2[k];
						results.push(parseInt(part, 16));
					}
					return results;
				}();
				return {
					parts,
					zoneId
				};
			};
			ipaddr2.IPv6.parser = function(string$2) {
				var addr, k, len, match, octet, octets, zoneId;
				if (ipv6Regexes["native"].test(string$2)) return expandIPv6(string$2, 8);
				else if (match = string$2.match(ipv6Regexes["transitional"])) {
					zoneId = match[6] || "";
					addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
					if (addr.parts) {
						octets = [
							parseInt(match[2]),
							parseInt(match[3]),
							parseInt(match[4]),
							parseInt(match[5])
						];
						for (k = 0, len = octets.length; k < len; k++) {
							octet = octets[k];
							if (!(0 <= octet && octet <= 255)) return null;
						}
						addr.parts.push(octets[0] << 8 | octets[1]);
						addr.parts.push(octets[2] << 8 | octets[3]);
						return {
							parts: addr.parts,
							zoneId: addr.zoneId
						};
					}
				}
				return null;
			};
			ipaddr2.IPv4.isIPv4 = ipaddr2.IPv6.isIPv6 = function(string$2) {
				return this.parser(string$2) !== null;
			};
			ipaddr2.IPv4.isValid = function(string$2) {
				try {
					new this(this.parser(string$2));
					return true;
				} catch (error1) {
					return false;
				}
			};
			ipaddr2.IPv4.isValidFourPartDecimal = function(string$2) {
				if (ipaddr2.IPv4.isValid(string$2) && string$2.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) return true;
				else return false;
			};
			ipaddr2.IPv6.isValid = function(string$2) {
				var addr;
				if (typeof string$2 === "string" && string$2.indexOf(":") === -1) return false;
				try {
					addr = this.parser(string$2);
					new this(addr.parts, addr.zoneId);
					return true;
				} catch (error1) {
					return false;
				}
			};
			ipaddr2.IPv4.parse = function(string$2) {
				var parts = this.parser(string$2);
				if (parts === null) throw new Error("ipaddr: string is not formatted like ip address");
				return new this(parts);
			};
			ipaddr2.IPv6.parse = function(string$2) {
				var addr = this.parser(string$2);
				if (addr.parts === null) throw new Error("ipaddr: string is not formatted like ip address");
				return new this(addr.parts, addr.zoneId);
			};
			ipaddr2.IPv4.parseCIDR = function(string$2) {
				var maskLength, match, parsed;
				if (match = string$2.match(/^(.+)\/(\d+)$/)) {
					maskLength = parseInt(match[2]);
					if (maskLength >= 0 && maskLength <= 32) {
						parsed = [this.parse(match[1]), maskLength];
						Object.defineProperty(parsed, "toString", { value: function() {
							return this.join("/");
						} });
						return parsed;
					}
				}
				throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
			};
			ipaddr2.IPv4.subnetMaskFromPrefixLength = function(prefix) {
				var filledOctetCount, j, octets;
				prefix = parseInt(prefix);
				if (prefix < 0 || prefix > 32) throw new Error("ipaddr: invalid IPv4 prefix length");
				octets = [
					0,
					0,
					0,
					0
				];
				j = 0;
				filledOctetCount = Math.floor(prefix / 8);
				while (j < filledOctetCount) {
					octets[j] = 255;
					j++;
				}
				if (filledOctetCount < 4) octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
				return new this(octets);
			};
			ipaddr2.IPv4.broadcastAddressFromCIDR = function(string$2) {
				var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
				try {
					cidr = this.parseCIDR(string$2);
					ipInterfaceOctets = cidr[0].toByteArray();
					subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
					octets = [];
					i = 0;
					while (i < 4) {
						octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
						i++;
					}
					return new this(octets);
				} catch (error1) {
					throw new Error("ipaddr: the address does not have IPv4 CIDR format");
				}
			};
			ipaddr2.IPv4.networkAddressFromCIDR = function(string$2) {
				var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
				try {
					cidr = this.parseCIDR(string$2);
					ipInterfaceOctets = cidr[0].toByteArray();
					subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
					octets = [];
					i = 0;
					while (i < 4) {
						octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
						i++;
					}
					return new this(octets);
				} catch (error1) {
					throw new Error("ipaddr: the address does not have IPv4 CIDR format");
				}
			};
			ipaddr2.IPv6.parseCIDR = function(string$2) {
				var maskLength, match, parsed;
				if (match = string$2.match(/^(.+)\/(\d+)$/)) {
					maskLength = parseInt(match[2]);
					if (maskLength >= 0 && maskLength <= 128) {
						parsed = [this.parse(match[1]), maskLength];
						Object.defineProperty(parsed, "toString", { value: function() {
							return this.join("/");
						} });
						return parsed;
					}
				}
				throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
			};
			ipaddr2.isValid = function(string$2) {
				return ipaddr2.IPv6.isValid(string$2) || ipaddr2.IPv4.isValid(string$2);
			};
			ipaddr2.parse = function(string$2) {
				if (ipaddr2.IPv6.isValid(string$2)) return ipaddr2.IPv6.parse(string$2);
				else if (ipaddr2.IPv4.isValid(string$2)) return ipaddr2.IPv4.parse(string$2);
				else throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
			};
			ipaddr2.parseCIDR = function(string$2) {
				try {
					return ipaddr2.IPv6.parseCIDR(string$2);
				} catch (error1) {
					try {
						return ipaddr2.IPv4.parseCIDR(string$2);
					} catch (error12) {
						throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
					}
				}
			};
			ipaddr2.fromByteArray = function(bytes2) {
				var length = bytes2.length;
				if (length === 4) return new ipaddr2.IPv4(bytes2);
				else if (length === 16) return new ipaddr2.IPv6(bytes2);
				else throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
			};
			ipaddr2.process = function(string$2) {
				var addr = this.parse(string$2);
				if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) return addr.toIPv4Address();
				else return addr;
			};
		}).call(ipaddr);
	})(ipaddr$1);
	return ipaddr$1.exports;
}
/*!
* proxy-addr
* Copyright(c) 2014-2016 Douglas Christopher Wilson
* MIT Licensed
*/
var hasRequiredProxyAddr;
function requireProxyAddr() {
	if (hasRequiredProxyAddr) return proxyAddr.exports;
	hasRequiredProxyAddr = 1;
	proxyAddr.exports = proxyaddr;
	proxyAddr.exports.all = alladdrs;
	proxyAddr.exports.compile = compile;
	var forwarded = requireForwarded();
	var ipaddr2 = requireIpaddr();
	var DIGIT_REGEXP = /^[0-9]+$/;
	var isip = ipaddr2.isValid;
	var parseip = ipaddr2.parse;
	var IP_RANGES = {
		linklocal: ["169.254.0.0/16", "fe80::/10"],
		loopback: ["127.0.0.1/8", "::1/128"],
		uniquelocal: [
			"10.0.0.0/8",
			"172.16.0.0/12",
			"192.168.0.0/16",
			"fc00::/7"
		]
	};
	function alladdrs(req, trust) {
		var addrs = forwarded(req);
		if (!trust) return addrs;
		if (typeof trust !== "function") trust = compile(trust);
		for (var i = 0; i < addrs.length - 1; i++) {
			if (trust(addrs[i], i)) continue;
			addrs.length = i + 1;
		}
		return addrs;
	}
	function compile(val) {
		if (!val) throw new TypeError("argument is required");
		var trust;
		if (typeof val === "string") trust = [val];
		else if (Array.isArray(val)) trust = val.slice();
		else throw new TypeError("unsupported trust argument");
		for (var i = 0; i < trust.length; i++) {
			val = trust[i];
			if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) continue;
			val = IP_RANGES[val];
			trust.splice.apply(trust, [i, 1].concat(val));
			i += val.length - 1;
		}
		return compileTrust(compileRangeSubnets(trust));
	}
	function compileRangeSubnets(arr) {
		var rangeSubnets = new Array(arr.length);
		for (var i = 0; i < arr.length; i++) rangeSubnets[i] = parseipNotation(arr[i]);
		return rangeSubnets;
	}
	function compileTrust(rangeSubnets) {
		var len = rangeSubnets.length;
		return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
	}
	function parseipNotation(note) {
		var pos = note.lastIndexOf("/");
		var str = pos !== -1 ? note.substring(0, pos) : note;
		if (!isip(str)) throw new TypeError("invalid IP address: " + str);
		var ip = parseip(str);
		if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) ip = ip.toIPv4Address();
		var max2 = ip.kind() === "ipv6" ? 128 : 32;
		var range2 = pos !== -1 ? note.substring(pos + 1, note.length) : null;
		if (range2 === null) range2 = max2;
		else if (DIGIT_REGEXP.test(range2)) range2 = parseInt(range2, 10);
		else if (ip.kind() === "ipv4" && isip(range2)) range2 = parseNetmask(range2);
		else range2 = null;
		if (range2 <= 0 || range2 > max2) throw new TypeError("invalid range on address: " + note);
		return [ip, range2];
	}
	function parseNetmask(netmask) {
		var ip = parseip(netmask);
		return ip.kind() === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
	}
	function proxyaddr(req, trust) {
		if (!req) throw new TypeError("req argument is required");
		if (!trust) throw new TypeError("trust argument is required");
		var addrs = alladdrs(req, trust);
		return addrs[addrs.length - 1];
	}
	function trustNone() {
		return false;
	}
	function trustMulti(subnets) {
		return function trust(addr) {
			if (!isip(addr)) return false;
			var ip = parseip(addr);
			var ipconv;
			var kind = ip.kind();
			for (var i = 0; i < subnets.length; i++) {
				var subnet = subnets[i];
				var subnetip = subnet[0];
				var subnetkind = subnetip.kind();
				var subnetrange = subnet[1];
				var trusted = ip;
				if (kind !== subnetkind) {
					if (subnetkind === "ipv4" && !ip.isIPv4MappedAddress()) continue;
					if (!ipconv) ipconv = subnetkind === "ipv4" ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
					trusted = ipconv;
				}
				if (trusted.match(subnetip, subnetrange)) return true;
			}
			return false;
		};
	}
	function trustSingle(subnet) {
		var subnetip = subnet[0];
		var subnetkind = subnetip.kind();
		var subnetisipv4 = subnetkind === "ipv4";
		var subnetrange = subnet[1];
		return function trust(addr) {
			if (!isip(addr)) return false;
			var ip = parseip(addr);
			if (ip.kind() !== subnetkind) {
				if (subnetisipv4 && !ip.isIPv4MappedAddress()) return false;
				ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
			}
			return ip.match(subnetip, subnetrange);
		};
	}
	return proxyAddr.exports;
}
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var hasRequiredUtils;
function requireUtils() {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;
	(function(exports$1) {
		var { METHODS } = require$$2$2;
		var contentType2 = requireContentType();
		var etag = requireEtag();
		var mime$1 = requireMimeTypes();
		var proxyaddr = requireProxyAddr();
		var qs = /* @__PURE__ */ requireLib();
		var querystring = require$$6$1;
		exports$1.methods = METHODS.map((method) => method.toLowerCase());
		exports$1.etag = createETagGenerator({ weak: false });
		exports$1.wetag = createETagGenerator({ weak: true });
		exports$1.normalizeType = function(type2) {
			return ~type2.indexOf("/") ? acceptParams(type2) : {
				value: mime$1.lookup(type2) || "application/octet-stream",
				params: {}
			};
		};
		exports$1.normalizeTypes = function(types) {
			return types.map(exports$1.normalizeType);
		};
		function acceptParams(str) {
			var length = str.length;
			var colonIndex = str.indexOf(";");
			var index2 = colonIndex === -1 ? length : colonIndex;
			var ret = {
				value: str.slice(0, index2).trim(),
				quality: 1,
				params: {}
			};
			while (index2 < length) {
				var splitIndex = str.indexOf("=", index2);
				if (splitIndex === -1) break;
				var colonIndex = str.indexOf(";", index2);
				var endIndex = colonIndex === -1 ? length : colonIndex;
				if (splitIndex > endIndex) {
					index2 = str.lastIndexOf(";", splitIndex - 1) + 1;
					continue;
				}
				var key = str.slice(index2, splitIndex).trim();
				var value = str.slice(splitIndex + 1, endIndex).trim();
				if (key === "q") ret.quality = parseFloat(value);
				else ret.params[key] = value;
				index2 = endIndex + 1;
			}
			return ret;
		}
		exports$1.compileETag = function(val) {
			var fn;
			if (typeof val === "function") return val;
			switch (val) {
				case true:
				case "weak":
					fn = exports$1.wetag;
					break;
				case false: break;
				case "strong":
					fn = exports$1.etag;
					break;
				default: throw new TypeError("unknown value for etag function: " + val);
			}
			return fn;
		};
		exports$1.compileQueryParser = function compileQueryParser(val) {
			var fn;
			if (typeof val === "function") return val;
			switch (val) {
				case true:
				case "simple":
					fn = querystring.parse;
					break;
				case false: break;
				case "extended":
					fn = parseExtendedQueryString;
					break;
				default: throw new TypeError("unknown value for query parser function: " + val);
			}
			return fn;
		};
		exports$1.compileTrust = function(val) {
			if (typeof val === "function") return val;
			if (val === true) return function() {
				return true;
			};
			if (typeof val === "number") return function(a, i) {
				return i < val;
			};
			if (typeof val === "string") val = val.split(",").map(function(v) {
				return v.trim();
			});
			return proxyaddr.compile(val || []);
		};
		exports$1.setCharset = function setCharset(type2, charset2) {
			if (!type2 || !charset2) return type2;
			var parsed = contentType2.parse(type2);
			parsed.parameters.charset = charset2;
			return contentType2.format(parsed);
		};
		function createETagGenerator(options) {
			return function generateETag(body, encoding2) {
				return etag(!Buffer.isBuffer(body) ? Buffer.from(body, encoding2) : body, options);
			};
		}
		function parseExtendedQueryString(str) {
			return qs.parse(str, { allowPrototypes: true });
		}
	})(utils);
	return utils;
}
var once = { exports: {} };
var wrappy_1;
var hasRequiredWrappy;
function requireWrappy() {
	if (hasRequiredWrappy) return wrappy_1;
	hasRequiredWrappy = 1;
	wrappy_1 = wrappy;
	function wrappy(fn, cb) {
		if (fn && cb) return wrappy(fn)(cb);
		if (typeof fn !== "function") throw new TypeError("need wrapper function");
		Object.keys(fn).forEach(function(k) {
			wrapper[k] = fn[k];
		});
		return wrapper;
		function wrapper() {
			var args = new Array(arguments.length);
			for (var i = 0; i < args.length; i++) args[i] = arguments[i];
			var ret = fn.apply(this, args);
			var cb2 = args[args.length - 1];
			if (typeof ret === "function" && ret !== cb2) Object.keys(cb2).forEach(function(k) {
				ret[k] = cb2[k];
			});
			return ret;
		}
	}
	return wrappy_1;
}
var hasRequiredOnce;
function requireOnce() {
	if (hasRequiredOnce) return once.exports;
	hasRequiredOnce = 1;
	var wrappy = requireWrappy();
	once.exports = wrappy(once$1);
	once.exports.strict = wrappy(onceStrict);
	once$1.proto = once$1(function() {
		Object.defineProperty(Function.prototype, "once", {
			value: function() {
				return once$1(this);
			},
			configurable: true
		});
		Object.defineProperty(Function.prototype, "onceStrict", {
			value: function() {
				return onceStrict(this);
			},
			configurable: true
		});
	});
	function once$1(fn) {
		var f = function() {
			if (f.called) return f.value;
			f.called = true;
			return f.value = fn.apply(this, arguments);
		};
		f.called = false;
		return f;
	}
	function onceStrict(fn) {
		var f = function() {
			if (f.called) throw new Error(f.onceError);
			f.called = true;
			return f.value = fn.apply(this, arguments);
		};
		f.onceError = (fn.name || "Function wrapped with `once`") + " shouldn't be called more than once";
		f.called = false;
		return f;
	}
	return once.exports;
}
var router = { exports: {} };
var isPromise = { exports: {} };
var hasRequiredIsPromise;
function requireIsPromise() {
	if (hasRequiredIsPromise) return isPromise.exports;
	hasRequiredIsPromise = 1;
	isPromise.exports = isPromise$1;
	isPromise.exports.default = isPromise$1;
	function isPromise$1(obj) {
		return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
	}
	return isPromise.exports;
}
var dist = {};
var hasRequiredDist;
function requireDist() {
	if (hasRequiredDist) return dist;
	hasRequiredDist = 1;
	Object.defineProperty(dist, "__esModule", { value: true });
	dist.TokenData = void 0;
	dist.parse = parse2;
	dist.compile = compile;
	dist.match = match;
	dist.pathToRegexp = pathToRegexp;
	dist.stringify = stringify;
	const DEFAULT_DELIMITER = "/";
	const NOOP_VALUE = (value) => value;
	const ID_START = /^[$_\p{ID_Start}]$/u;
	const ID_CONTINUE = /^[$\u200c\u200d\p{ID_Continue}]$/u;
	const DEBUG_URL = "https://git.new/pathToRegexpError";
	const SIMPLE_TOKENS = {
		"{": "{",
		"}": "}",
		"(": "(",
		")": ")",
		"[": "[",
		"]": "]",
		"+": "+",
		"?": "?",
		"!": "!"
	};
	function escapeText(str) {
		return str.replace(/[{}()\[\]+?!:*]/g, "\\$&");
	}
	function escape2(str) {
		return str.replace(/[.+*?^${}()[\]|/\\]/g, "\\$&");
	}
	function* lexer(str) {
		const chars = [...str];
		let i = 0;
		function name() {
			let value = "";
			if (ID_START.test(chars[++i])) {
				value += chars[i];
				while (ID_CONTINUE.test(chars[++i])) value += chars[i];
			} else if (chars[i] === "\"") {
				let pos = i;
				while (i < chars.length) {
					if (chars[++i] === "\"") {
						i++;
						pos = 0;
						break;
					}
					if (chars[i] === "\\") value += chars[++i];
					else value += chars[i];
				}
				if (pos) throw new TypeError(`Unterminated quote at ${pos}: ${DEBUG_URL}`);
			}
			if (!value) throw new TypeError(`Missing parameter name at ${i}: ${DEBUG_URL}`);
			return value;
		}
		while (i < chars.length) {
			const value = chars[i];
			const type2 = SIMPLE_TOKENS[value];
			if (type2) yield {
				type: type2,
				index: i++,
				value
			};
			else if (value === "\\") yield {
				type: "ESCAPED",
				index: i++,
				value: chars[i++]
			};
			else if (value === ":") {
				const value2 = name();
				yield {
					type: "PARAM",
					index: i,
					value: value2
				};
			} else if (value === "*") {
				const value2 = name();
				yield {
					type: "WILDCARD",
					index: i,
					value: value2
				};
			} else yield {
				type: "CHAR",
				index: i,
				value: chars[i++]
			};
		}
		return {
			type: "END",
			index: i,
			value: ""
		};
	}
	class Iter {
		constructor(tokens) {
			this.tokens = tokens;
		}
		peek() {
			if (!this._peek) this._peek = this.tokens.next().value;
			return this._peek;
		}
		tryConsume(type2) {
			const token = this.peek();
			if (token.type !== type2) return;
			this._peek = void 0;
			return token.value;
		}
		consume(type2) {
			const value = this.tryConsume(type2);
			if (value !== void 0) return value;
			const { type: nextType, index: index2 } = this.peek();
			throw new TypeError(`Unexpected ${nextType} at ${index2}, expected ${type2}: ${DEBUG_URL}`);
		}
		text() {
			let result = "";
			let value;
			while (value = this.tryConsume("CHAR") || this.tryConsume("ESCAPED")) result += value;
			return result;
		}
	}
	class TokenData {
		constructor(tokens) {
			this.tokens = tokens;
		}
	}
	dist.TokenData = TokenData;
	function parse2(str, options = {}) {
		const { encodePath = NOOP_VALUE } = options;
		const it = new Iter(lexer(str));
		function consume(endType) {
			const tokens2 = [];
			while (true) {
				const path$3 = it.text();
				if (path$3) tokens2.push({
					type: "text",
					value: encodePath(path$3)
				});
				const param = it.tryConsume("PARAM");
				if (param) {
					tokens2.push({
						type: "param",
						name: param
					});
					continue;
				}
				const wildcard = it.tryConsume("WILDCARD");
				if (wildcard) {
					tokens2.push({
						type: "wildcard",
						name: wildcard
					});
					continue;
				}
				if (it.tryConsume("{")) {
					tokens2.push({
						type: "group",
						tokens: consume("}")
					});
					continue;
				}
				it.consume(endType);
				return tokens2;
			}
		}
		return new TokenData(consume("END"));
	}
	function compile(path$3, options = {}) {
		const { encode: encode$4 = encodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;
		const fn = tokensToFunction((path$3 instanceof TokenData ? path$3 : parse2(path$3, options)).tokens, delimiter, encode$4);
		return function path2(data2 = {}) {
			const [path3, ...missing] = fn(data2);
			if (missing.length) throw new TypeError(`Missing parameters: ${missing.join(", ")}`);
			return path3;
		};
	}
	function tokensToFunction(tokens, delimiter, encode$4) {
		const encoders = tokens.map((token) => tokenToFunction(token, delimiter, encode$4));
		return (data$1) => {
			const result = [""];
			for (const encoder of encoders) {
				const [value, ...extras] = encoder(data$1);
				result[0] += value;
				result.push(...extras);
			}
			return result;
		};
	}
	function tokenToFunction(token, delimiter, encode$4) {
		if (token.type === "text") return () => [token.value];
		if (token.type === "group") {
			const fn = tokensToFunction(token.tokens, delimiter, encode$4);
			return (data$1) => {
				const [value, ...missing] = fn(data$1);
				if (!missing.length) return [value];
				return [""];
			};
		}
		const encodeValue = encode$4 || NOOP_VALUE;
		if (token.type === "wildcard" && encode$4 !== false) return (data$1) => {
			const value = data$1[token.name];
			if (value == null) return ["", token.name];
			if (!Array.isArray(value) || value.length === 0) throw new TypeError(`Expected "${token.name}" to be a non-empty array`);
			return [value.map((value2, index2) => {
				if (typeof value2 !== "string") throw new TypeError(`Expected "${token.name}/${index2}" to be a string`);
				return encodeValue(value2);
			}).join(delimiter)];
		};
		return (data$1) => {
			const value = data$1[token.name];
			if (value == null) return ["", token.name];
			if (typeof value !== "string") throw new TypeError(`Expected "${token.name}" to be a string`);
			return [encodeValue(value)];
		};
	}
	function match(path$3, options = {}) {
		const { decode: decode$2 = decodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;
		const { regexp, keys } = pathToRegexp(path$3, options);
		const decoders = keys.map((key) => {
			if (decode$2 === false) return NOOP_VALUE;
			if (key.type === "param") return decode$2;
			return (value) => value.split(delimiter).map(decode$2);
		});
		return function match2(input) {
			const m$1 = regexp.exec(input);
			if (!m$1) return false;
			const path2 = m$1[0];
			const params = /* @__PURE__ */ Object.create(null);
			for (let i = 1; i < m$1.length; i++) {
				if (m$1[i] === void 0) continue;
				const key = keys[i - 1];
				const decoder = decoders[i - 1];
				params[key.name] = decoder(m$1[i]);
			}
			return {
				path: path2,
				params
			};
		};
	}
	function pathToRegexp(path$3, options = {}) {
		const { delimiter = DEFAULT_DELIMITER, end = true, sensitive = false, trailing = true } = options;
		const keys = [];
		const sources = [];
		const flags = sensitive ? "" : "i";
		const items = (Array.isArray(path$3) ? path$3 : [path$3]).map((path2) => path2 instanceof TokenData ? path2 : parse2(path2, options));
		for (const { tokens } of items) for (const seq of flatten(tokens, 0, [])) {
			const regexp2 = sequenceToRegExp(seq, delimiter, keys);
			sources.push(regexp2);
		}
		let pattern = `^(?:${sources.join("|")})`;
		if (trailing) pattern += `(?:${escape2(delimiter)}$)?`;
		pattern += end ? "$" : `(?=${escape2(delimiter)}|$)`;
		return {
			regexp: new RegExp(pattern, flags),
			keys
		};
	}
	function* flatten(tokens, index2, init$1) {
		if (index2 === tokens.length) return yield init$1;
		const token = tokens[index2];
		if (token.type === "group") {
			const fork = init$1.slice();
			for (const seq of flatten(token.tokens, 0, fork)) yield* flatten(tokens, index2 + 1, seq);
		} else init$1.push(token);
		yield* flatten(tokens, index2 + 1, init$1);
	}
	function sequenceToRegExp(tokens, delimiter, keys) {
		let result = "";
		let backtrack = "";
		let isSafeSegmentParam = true;
		for (let i = 0; i < tokens.length; i++) {
			const token = tokens[i];
			if (token.type === "text") {
				result += escape2(token.value);
				backtrack += token.value;
				isSafeSegmentParam || (isSafeSegmentParam = token.value.includes(delimiter));
				continue;
			}
			if (token.type === "param" || token.type === "wildcard") {
				if (!isSafeSegmentParam && !backtrack) throw new TypeError(`Missing text after "${token.name}": ${DEBUG_URL}`);
				if (token.type === "param") result += `(${negate(delimiter, isSafeSegmentParam ? "" : backtrack)}+)`;
				else result += `([\\s\\S]+)`;
				keys.push(token);
				backtrack = "";
				isSafeSegmentParam = false;
				continue;
			}
		}
		return result;
	}
	function negate(delimiter, backtrack) {
		if (backtrack.length < 2) {
			if (delimiter.length < 2) return `[^${escape2(delimiter + backtrack)}]`;
			return `(?:(?!${escape2(delimiter)})[^${escape2(backtrack)}])`;
		}
		if (delimiter.length < 2) return `(?:(?!${escape2(backtrack)})[^${escape2(delimiter)}])`;
		return `(?:(?!${escape2(backtrack)}|${escape2(delimiter)})[\\s\\S])`;
	}
	function stringify(data$1) {
		return data$1.tokens.map(function stringifyToken(token, index2, tokens) {
			if (token.type === "text") return escapeText(token.value);
			if (token.type === "group") return `{${token.tokens.map(stringifyToken).join("")}}`;
			const key = isNameSafe(token.name) && isNextNameSafe(tokens[index2 + 1]) ? token.name : JSON.stringify(token.name);
			if (token.type === "param") return `:${key}`;
			if (token.type === "wildcard") return `*${key}`;
			throw new TypeError(`Unexpected token: ${token}`);
		}).join("");
	}
	function isNameSafe(name) {
		const [first, ...rest] = name;
		if (!ID_START.test(first)) return false;
		return rest.every((char) => ID_CONTINUE.test(char));
	}
	function isNextNameSafe(token) {
		if ((token === null || token === void 0 ? void 0 : token.type) !== "text") return true;
		return !ID_CONTINUE.test(token.value[0]);
	}
	return dist;
}
/*!
* router
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2022 Douglas Christopher Wilson
* MIT Licensed
*/
var layer;
var hasRequiredLayer;
function requireLayer() {
	if (hasRequiredLayer) return layer;
	hasRequiredLayer = 1;
	const isPromise2 = requireIsPromise();
	const pathRegexp = requireDist();
	const debug$2 = requireBrowser()("router:layer");
	const deprecate = requireBrowser$1()("router");
	const TRAILING_SLASH_REGEXP = /\/+$/;
	const MATCHING_GROUP_REGEXP = /\((?:\?<(.*?)>)?(?!\?)/g;
	layer = Layer;
	function Layer(path$3, options, fn) {
		if (!(this instanceof Layer)) return new Layer(path$3, options, fn);
		debug$2("new %o", path$3);
		const opts = options || {};
		this.handle = fn;
		this.keys = [];
		this.name = fn.name || "<anonymous>";
		this.params = void 0;
		this.path = void 0;
		this.slash = path$3 === "/" && opts.end === false;
		function matcher(_path) {
			if (_path instanceof RegExp) {
				const keys = [];
				let name = 0;
				let m$1;
				while (m$1 = MATCHING_GROUP_REGEXP.exec(_path.source)) keys.push({
					name: m$1[1] || name++,
					offset: m$1.index
				});
				return function regexpMatcher(p) {
					const match = _path.exec(p);
					if (!match) return false;
					const params = {};
					for (let i = 1; i < match.length; i++) {
						const prop = keys[i - 1].name;
						const val = decodeParam(match[i]);
						if (val !== void 0) params[prop] = val;
					}
					return {
						params,
						path: match[0]
					};
				};
			}
			return pathRegexp.match(opts.strict ? _path : loosen(_path), {
				sensitive: opts.sensitive,
				end: opts.end,
				trailing: !opts.strict,
				decode: decodeParam
			});
		}
		this.matchers = Array.isArray(path$3) ? path$3.map(matcher) : [matcher(path$3)];
	}
	Layer.prototype.handleError = function handleError$1(error, req, res, next) {
		const fn = this.handle;
		if (fn.length !== 4) return next(error);
		try {
			const ret = fn(error, req, res, next);
			if (isPromise2(ret)) {
				if (!(ret instanceof Promise)) deprecate("handlers that are Promise-like are deprecated, use a native Promise instead");
				ret.then(null, function(error2) {
					next(error2 || /* @__PURE__ */ new Error("Rejected promise"));
				});
			}
		} catch (err) {
			next(err);
		}
	};
	Layer.prototype.handleRequest = function handleRequest(req, res, next) {
		const fn = this.handle;
		if (fn.length > 3) return next();
		try {
			const ret = fn(req, res, next);
			if (isPromise2(ret)) {
				if (!(ret instanceof Promise)) deprecate("handlers that are Promise-like are deprecated, use a native Promise instead");
				ret.then(null, function(error) {
					next(error || /* @__PURE__ */ new Error("Rejected promise"));
				});
			}
		} catch (err) {
			next(err);
		}
	};
	Layer.prototype.match = function match(path$3) {
		let match2;
		if (path$3 != null) {
			if (this.slash) {
				this.params = {};
				this.path = "";
				return true;
			}
			let i = 0;
			while (!match2 && i < this.matchers.length) {
				match2 = this.matchers[i](path$3);
				i++;
			}
		}
		if (!match2) {
			this.params = void 0;
			this.path = void 0;
			return false;
		}
		this.params = match2.params;
		this.path = match2.path;
		this.keys = Object.keys(match2.params);
		return true;
	};
	function decodeParam(val) {
		if (typeof val !== "string" || val.length === 0) return val;
		try {
			return decodeURIComponent(val);
		} catch (err) {
			if (err instanceof URIError) {
				err.message = "Failed to decode param '" + val + "'";
				err.status = 400;
			}
			throw err;
		}
	}
	function loosen(path$3) {
		if (path$3 instanceof RegExp || path$3 === "/") return path$3;
		return Array.isArray(path$3) ? path$3.map(function(p) {
			return loosen(p);
		}) : String(path$3).replace(TRAILING_SLASH_REGEXP, "");
	}
	return layer;
}
/*!
* router
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2022 Douglas Christopher Wilson
* MIT Licensed
*/
var route;
var hasRequiredRoute;
function requireRoute() {
	if (hasRequiredRoute) return route;
	hasRequiredRoute = 1;
	const debug$2 = requireBrowser()("router:route");
	const Layer = requireLayer();
	const { METHODS } = require$$2$2;
	const slice = Array.prototype.slice;
	const flatten = Array.prototype.flat;
	const methods = METHODS.map((method) => method.toLowerCase());
	route = Route2;
	function Route2(path$3) {
		debug$2("new %o", path$3);
		this.path = path$3;
		this.stack = [];
		this.methods = /* @__PURE__ */ Object.create(null);
	}
	Route2.prototype._handlesMethod = function _handlesMethod(method) {
		if (this.methods._all) return true;
		let name = typeof method === "string" ? method.toLowerCase() : method;
		if (name === "head" && !this.methods.head) name = "get";
		return Boolean(this.methods[name]);
	};
	Route2.prototype._methods = function _methods() {
		const methods2 = Object.keys(this.methods);
		if (this.methods.get && !this.methods.head) methods2.push("head");
		for (let i = 0; i < methods2.length; i++) methods2[i] = methods2[i].toUpperCase();
		return methods2;
	};
	Route2.prototype.dispatch = function dispatch(req, res, done) {
		let idx = 0;
		const stack = this.stack;
		let sync = 0;
		if (stack.length === 0) return done();
		let method = typeof req.method === "string" ? req.method.toLowerCase() : req.method;
		if (method === "head" && !this.methods.head) method = "get";
		req.route = this;
		next();
		function next(err) {
			if (err && err === "route") return done();
			if (err && err === "router") return done(err);
			if (idx >= stack.length) return done(err);
			if (++sync > 100) return setImmediate(next, err);
			let layer2;
			let match;
			while (match !== true && idx < stack.length) {
				layer2 = stack[idx++];
				match = !layer2.method || layer2.method === method;
			}
			if (match !== true) return done(err);
			if (err) layer2.handleError(err, req, res, next);
			else layer2.handleRequest(req, res, next);
			sync = 0;
		}
	};
	Route2.prototype.all = function all$1(handler) {
		const callbacks = flatten.call(slice.call(arguments), Infinity);
		if (callbacks.length === 0) throw new TypeError("argument handler is required");
		for (let i = 0; i < callbacks.length; i++) {
			const fn = callbacks[i];
			if (typeof fn !== "function") throw new TypeError("argument handler must be a function");
			const layer2 = Layer("/", {}, fn);
			layer2.method = void 0;
			this.methods._all = true;
			this.stack.push(layer2);
		}
		return this;
	};
	methods.forEach(function(method) {
		Route2.prototype[method] = function(handler) {
			const callbacks = flatten.call(slice.call(arguments), Infinity);
			if (callbacks.length === 0) throw new TypeError("argument handler is required");
			for (let i = 0; i < callbacks.length; i++) {
				const fn = callbacks[i];
				if (typeof fn !== "function") throw new TypeError("argument handler must be a function");
				debug$2("%s %s", method, this.path);
				const layer2 = Layer("/", {}, fn);
				layer2.method = method;
				this.methods[method] = true;
				this.stack.push(layer2);
			}
			return this;
		};
	});
	return route;
}
/*!
* router
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2022 Douglas Christopher Wilson
* MIT Licensed
*/
var hasRequiredRouter;
function requireRouter() {
	if (hasRequiredRouter) return router.exports;
	hasRequiredRouter = 1;
	const isPromise2 = requireIsPromise();
	const Layer = requireLayer();
	const { METHODS } = require$$2$2;
	const parseUrl$3 = requireParseurl();
	const Route2 = requireRoute();
	const debug$2 = requireBrowser()("router");
	const deprecate = requireBrowser$1()("router");
	const slice = Array.prototype.slice;
	const flatten = Array.prototype.flat;
	const methods = METHODS.map((method) => method.toLowerCase());
	router.exports = Router2;
	router.exports.Route = Route2;
	function Router2(options) {
		if (!(this instanceof Router2)) return new Router2(options);
		const opts = options || {};
		function router2(req, res, next) {
			router2.handle(req, res, next);
		}
		Object.setPrototypeOf(router2, this);
		router2.caseSensitive = opts.caseSensitive;
		router2.mergeParams = opts.mergeParams;
		router2.params = {};
		router2.strict = opts.strict;
		router2.stack = [];
		return router2;
	}
	Router2.prototype = function() {};
	Router2.prototype.param = function param(name, fn) {
		if (!name) throw new TypeError("argument name is required");
		if (typeof name !== "string") throw new TypeError("argument name must be a string");
		if (!fn) throw new TypeError("argument fn is required");
		if (typeof fn !== "function") throw new TypeError("argument fn must be a function");
		let params = this.params[name];
		if (!params) params = this.params[name] = [];
		params.push(fn);
		return this;
	};
	Router2.prototype.handle = function handle(req, res, callback) {
		if (!callback) throw new TypeError("argument callback is required");
		debug$2("dispatching %s %s", req.method, req.url);
		let idx = 0;
		let methods2;
		const protohost = getProtohost(req.url) || "";
		let removed = "";
		const self2 = this;
		let slashAdded = false;
		let sync = 0;
		const paramcalled = {};
		const stack = this.stack;
		const parentParams = req.params;
		const parentUrl = req.baseUrl || "";
		let done = restore(callback, req, "baseUrl", "next", "params");
		req.next = next;
		if (req.method === "OPTIONS") {
			methods2 = [];
			done = wrap$1(done, generateOptionsResponder(res, methods2));
		}
		req.baseUrl = parentUrl;
		req.originalUrl = req.originalUrl || req.url;
		next();
		function next(err) {
			let layerError = err === "route" ? null : err;
			if (slashAdded) {
				req.url = req.url.slice(1);
				slashAdded = false;
			}
			if (removed.length !== 0) {
				req.baseUrl = parentUrl;
				req.url = protohost + removed + req.url.slice(protohost.length);
				removed = "";
			}
			if (layerError === "router") {
				setImmediate(done, null);
				return;
			}
			if (idx >= stack.length) {
				setImmediate(done, layerError);
				return;
			}
			if (++sync > 100) return setImmediate(next, err);
			const path$3 = getPathname(req);
			if (path$3 == null) return done(layerError);
			let layer2;
			let match;
			let route2;
			while (match !== true && idx < stack.length) {
				layer2 = stack[idx++];
				match = matchLayer(layer2, path$3);
				route2 = layer2.route;
				if (typeof match !== "boolean") layerError = layerError || match;
				if (match !== true) continue;
				if (!route2) continue;
				if (layerError) {
					match = false;
					continue;
				}
				const method = req.method;
				const hasMethod = route2._handlesMethod(method);
				if (!hasMethod && method === "OPTIONS" && methods2) methods2.push.apply(methods2, route2._methods());
				if (!hasMethod && method !== "HEAD") match = false;
			}
			if (match !== true) return done(layerError);
			if (route2) req.route = route2;
			req.params = self2.mergeParams ? mergeParams(layer2.params, parentParams) : layer2.params;
			const layerPath = layer2.path;
			processParams(self2.params, layer2, paramcalled, req, res, function(err2) {
				if (err2) next(layerError || err2);
				else if (route2) layer2.handleRequest(req, res, next);
				else trimPrefix(layer2, layerError, layerPath, path$3);
				sync = 0;
			});
		}
		function trimPrefix(layer2, layerError, layerPath, path$3) {
			if (layerPath.length !== 0) {
				if (layerPath !== path$3.substring(0, layerPath.length)) {
					next(layerError);
					return;
				}
				const c = path$3[layerPath.length];
				if (c && c !== "/") {
					next(layerError);
					return;
				}
				debug$2("trim prefix (%s) from url %s", layerPath, req.url);
				removed = layerPath;
				req.url = protohost + req.url.slice(protohost.length + removed.length);
				if (!protohost && req.url[0] !== "/") {
					req.url = "/" + req.url;
					slashAdded = true;
				}
				req.baseUrl = parentUrl + (removed[removed.length - 1] === "/" ? removed.substring(0, removed.length - 1) : removed);
			}
			debug$2("%s %s : %s", layer2.name, layerPath, req.originalUrl);
			if (layerError) layer2.handleError(layerError, req, res, next);
			else layer2.handleRequest(req, res, next);
		}
	};
	Router2.prototype.use = function use(handler) {
		let offset = 0;
		let path$3 = "/";
		if (typeof handler !== "function") {
			let arg = handler;
			while (Array.isArray(arg) && arg.length !== 0) arg = arg[0];
			if (typeof arg !== "function") {
				offset = 1;
				path$3 = handler;
			}
		}
		const callbacks = flatten.call(slice.call(arguments, offset), Infinity);
		if (callbacks.length === 0) throw new TypeError("argument handler is required");
		for (let i = 0; i < callbacks.length; i++) {
			const fn = callbacks[i];
			if (typeof fn !== "function") throw new TypeError("argument handler must be a function");
			debug$2("use %o %s", path$3, fn.name || "<anonymous>");
			const layer2 = new Layer(path$3, {
				sensitive: this.caseSensitive,
				strict: false,
				end: false
			}, fn);
			layer2.route = void 0;
			this.stack.push(layer2);
		}
		return this;
	};
	Router2.prototype.route = function route2(path$3) {
		const route3 = new Route2(path$3);
		const layer2 = new Layer(path$3, {
			sensitive: this.caseSensitive,
			strict: this.strict,
			end: true
		}, handle);
		function handle(req, res, next) {
			route3.dispatch(req, res, next);
		}
		layer2.route = route3;
		this.stack.push(layer2);
		return route3;
	};
	methods.concat("all").forEach(function(method) {
		Router2.prototype[method] = function(path$3) {
			const route2 = this.route(path$3);
			route2[method].apply(route2, slice.call(arguments, 1));
			return this;
		};
	});
	function generateOptionsResponder(res, methods2) {
		return function onDone(fn, err) {
			if (err || methods2.length === 0) return fn(err);
			trySendOptionsResponse(res, methods2, fn);
		};
	}
	function getPathname(req) {
		try {
			return parseUrl$3(req).pathname;
		} catch (err) {
			return;
		}
	}
	function getProtohost(url$1) {
		if (typeof url$1 !== "string" || url$1.length === 0 || url$1[0] === "/") return;
		const searchIndex = url$1.indexOf("?");
		const pathLength = searchIndex !== -1 ? searchIndex : url$1.length;
		const fqdnIndex = url$1.substring(0, pathLength).indexOf("://");
		return fqdnIndex !== -1 ? url$1.substring(0, url$1.indexOf("/", 3 + fqdnIndex)) : void 0;
	}
	function matchLayer(layer2, path$3) {
		try {
			return layer2.match(path$3);
		} catch (err) {
			return err;
		}
	}
	function mergeParams(params, parent) {
		if (typeof parent !== "object" || !parent) return params;
		const obj = Object.assign({}, parent);
		if (!(0 in params) || !(0 in parent)) return Object.assign(obj, params);
		let i = 0;
		let o = 0;
		while (i in params) i++;
		while (o in parent) o++;
		for (i--; i >= 0; i--) {
			params[i + o] = params[i];
			if (i < o) delete params[i];
		}
		return Object.assign(obj, params);
	}
	function processParams(params, layer2, called, req, res, done) {
		const keys = layer2.keys;
		if (!keys || keys.length === 0) return done();
		let i = 0;
		let paramIndex = 0;
		let key;
		let paramVal;
		let paramCallbacks;
		let paramCalled;
		function param(err) {
			if (err) return done(err);
			if (i >= keys.length) return done();
			paramIndex = 0;
			key = keys[i++];
			paramVal = req.params[key];
			paramCallbacks = params[key];
			paramCalled = called[key];
			if (paramVal === void 0 || !paramCallbacks) return param();
			if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== "route")) {
				req.params[key] = paramCalled.value;
				return param(paramCalled.error);
			}
			called[key] = paramCalled = {
				error: null,
				match: paramVal,
				value: paramVal
			};
			paramCallback();
		}
		function paramCallback(err) {
			const fn = paramCallbacks[paramIndex++];
			paramCalled.value = req.params[key];
			if (err) {
				paramCalled.error = err;
				param(err);
				return;
			}
			if (!fn) return param();
			try {
				const ret = fn(req, res, paramCallback, paramVal, key);
				if (isPromise2(ret)) {
					if (!(ret instanceof Promise)) deprecate("parameters that are Promise-like are deprecated, use a native Promise instead");
					ret.then(null, function(error) {
						paramCallback(error || /* @__PURE__ */ new Error("Rejected promise"));
					});
				}
			} catch (e) {
				paramCallback(e);
			}
		}
		param();
	}
	function restore(fn, obj) {
		const props = new Array(arguments.length - 2);
		const vals = new Array(arguments.length - 2);
		for (let i = 0; i < props.length; i++) {
			props[i] = arguments[i + 2];
			vals[i] = obj[props[i]];
		}
		return function() {
			for (let i = 0; i < props.length; i++) obj[props[i]] = vals[i];
			return fn.apply(this, arguments);
		};
	}
	function sendOptionsResponse(res, methods2) {
		const options = /* @__PURE__ */ Object.create(null);
		for (let i = 0; i < methods2.length; i++) options[methods2[i]] = true;
		const allow = Object.keys(options).sort().join(", ");
		res.setHeader("Allow", allow);
		res.setHeader("Content-Length", Buffer.byteLength(allow));
		res.setHeader("Content-Type", "text/plain");
		res.setHeader("X-Content-Type-Options", "nosniff");
		res.end(allow);
	}
	function trySendOptionsResponse(res, methods2, next) {
		try {
			sendOptionsResponse(res, methods2);
		} catch (err) {
			next(err);
		}
	}
	function wrap$1(old, fn) {
		return function proxy() {
			const args = new Array(arguments.length + 1);
			args[0] = old;
			for (let i = 0, len = arguments.length; i < len; i++) args[i + 1] = arguments[i];
			fn.apply(this, args);
		};
	}
	return router.exports;
}
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var hasRequiredApplication;
function requireApplication() {
	if (hasRequiredApplication) return application.exports;
	hasRequiredApplication = 1;
	(function(module$1, exports$1) {
		var finalhandler = requireFinalhandler();
		var debug$2 = requireBrowser()("express:application");
		var View = requireView();
		var http$3 = require$$2$2;
		var methods = requireUtils().methods;
		var compileETag = requireUtils().compileETag;
		var compileQueryParser = requireUtils().compileQueryParser;
		var compileTrust = requireUtils().compileTrust;
		var resolve = path.resolve;
		var once2 = requireOnce();
		var Router2 = requireRouter();
		var slice = Array.prototype.slice;
		var flatten = Array.prototype.flat;
		var app$3 = module$1.exports = {};
		var trustProxyDefaultSymbol = "@@symbol:trust_proxy_default";
		app$3.init = function init$1() {
			var router2 = null;
			this.cache = /* @__PURE__ */ Object.create(null);
			this.engines = /* @__PURE__ */ Object.create(null);
			this.settings = /* @__PURE__ */ Object.create(null);
			this.defaultConfiguration();
			Object.defineProperty(this, "router", {
				configurable: true,
				enumerable: true,
				get: function getrouter() {
					if (router2 === null) router2 = new Router2({
						caseSensitive: this.enabled("case sensitive routing"),
						strict: this.enabled("strict routing")
					});
					return router2;
				}
			});
		};
		app$3.defaultConfiguration = function defaultConfiguration() {
			var env$1 = process.env.NODE_ENV || "development";
			this.enable("x-powered-by");
			this.set("etag", "weak");
			this.set("env", env$1);
			this.set("query parser", "simple");
			this.set("subdomain offset", 2);
			this.set("trust proxy", false);
			Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
				configurable: true,
				value: true
			});
			debug$2("booting in %s mode", env$1);
			this.on("mount", function onmount(parent) {
				if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings["trust proxy fn"] === "function") {
					delete this.settings["trust proxy"];
					delete this.settings["trust proxy fn"];
				}
				Object.setPrototypeOf(this.request, parent.request);
				Object.setPrototypeOf(this.response, parent.response);
				Object.setPrototypeOf(this.engines, parent.engines);
				Object.setPrototypeOf(this.settings, parent.settings);
			});
			this.locals = /* @__PURE__ */ Object.create(null);
			this.mountpath = "/";
			this.locals.settings = this.settings;
			this.set("view", View);
			this.set("views", resolve("views"));
			this.set("jsonp callback name", "callback");
			if (env$1 === "production") this.enable("view cache");
		};
		app$3.handle = function handle(req, res, callback) {
			var done = callback || finalhandler(req, res, {
				env: this.get("env"),
				onerror: logerror.bind(this)
			});
			if (this.enabled("x-powered-by")) res.setHeader("X-Powered-By", "Express");
			req.res = res;
			res.req = req;
			Object.setPrototypeOf(req, this.request);
			Object.setPrototypeOf(res, this.response);
			if (!res.locals) res.locals = /* @__PURE__ */ Object.create(null);
			this.router.handle(req, res, done);
		};
		app$3.use = function use(fn) {
			var offset = 0;
			var path$3 = "/";
			if (typeof fn !== "function") {
				var arg = fn;
				while (Array.isArray(arg) && arg.length !== 0) arg = arg[0];
				if (typeof arg !== "function") {
					offset = 1;
					path$3 = fn;
				}
			}
			var fns = flatten.call(slice.call(arguments, offset), Infinity);
			if (fns.length === 0) throw new TypeError("app.use() requires a middleware function");
			var router2 = this.router;
			fns.forEach(function(fn2) {
				if (!fn2 || !fn2.handle || !fn2.set) return router2.use(path$3, fn2);
				debug$2(".use app under %s", path$3);
				fn2.mountpath = path$3;
				fn2.parent = this;
				router2.use(path$3, function mounted_app(req, res, next) {
					var orig = req.app;
					fn2.handle(req, res, function(err) {
						Object.setPrototypeOf(req, orig.request);
						Object.setPrototypeOf(res, orig.response);
						next(err);
					});
				});
				fn2.emit("mount", this);
			}, this);
			return this;
		};
		app$3.route = function route2(path$3) {
			return this.router.route(path$3);
		};
		app$3.engine = function engine(ext, fn) {
			if (typeof fn !== "function") throw new Error("callback function required");
			var extension$1 = ext[0] !== "." ? "." + ext : ext;
			this.engines[extension$1] = fn;
			return this;
		};
		app$3.param = function param(name, fn) {
			if (Array.isArray(name)) {
				for (var i = 0; i < name.length; i++) this.param(name[i], fn);
				return this;
			}
			this.router.param(name, fn);
			return this;
		};
		app$3.set = function set(setting, val) {
			if (arguments.length === 1) return this.settings[setting];
			debug$2("set \"%s\" to %o", setting, val);
			this.settings[setting] = val;
			switch (setting) {
				case "etag":
					this.set("etag fn", compileETag(val));
					break;
				case "query parser":
					this.set("query parser fn", compileQueryParser(val));
					break;
				case "trust proxy":
					this.set("trust proxy fn", compileTrust(val));
					Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
						configurable: true,
						value: false
					});
					break;
			}
			return this;
		};
		app$3.path = function path$3() {
			return this.parent ? this.parent.path() + this.mountpath : "";
		};
		app$3.enabled = function enabled(setting) {
			return Boolean(this.set(setting));
		};
		app$3.disabled = function disabled(setting) {
			return !this.set(setting);
		};
		app$3.enable = function enable(setting) {
			return this.set(setting, true);
		};
		app$3.disable = function disable(setting) {
			return this.set(setting, false);
		};
		methods.forEach(function(method) {
			app$3[method] = function(path$3) {
				if (method === "get" && arguments.length === 1) return this.set(path$3);
				var route2 = this.route(path$3);
				route2[method].apply(route2, slice.call(arguments, 1));
				return this;
			};
		});
		app$3.all = function all$1(path$3) {
			var route2 = this.route(path$3);
			var args = slice.call(arguments, 1);
			for (var i = 0; i < methods.length; i++) route2[methods[i]].apply(route2, args);
			return this;
		};
		app$3.render = function render$1(name, options, callback) {
			var cache = this.cache;
			var done = callback;
			var engines = this.engines;
			var opts = options;
			var view2;
			if (typeof options === "function") {
				done = options;
				opts = {};
			}
			var renderOptions = {
				...this.locals,
				...opts._locals,
				...opts
			};
			if (renderOptions.cache == null) renderOptions.cache = this.enabled("view cache");
			if (renderOptions.cache) view2 = cache[name];
			if (!view2) {
				view2 = new (this.get("view"))(name, {
					defaultEngine: this.get("view engine"),
					root: this.get("views"),
					engines
				});
				if (!view2.path) {
					var dirs = Array.isArray(view2.root) && view2.root.length > 1 ? "directories \"" + view2.root.slice(0, -1).join("\", \"") + "\" or \"" + view2.root[view2.root.length - 1] + "\"" : "directory \"" + view2.root + "\"";
					var err = /* @__PURE__ */ new Error("Failed to lookup view \"" + name + "\" in views " + dirs);
					err.view = view2;
					return done(err);
				}
				if (renderOptions.cache) cache[name] = view2;
			}
			tryRender(view2, renderOptions, done);
		};
		app$3.listen = function listen() {
			var server = http$3.createServer(this);
			var args = Array.prototype.slice.call(arguments);
			if (typeof args[args.length - 1] === "function") {
				var done = args[args.length - 1] = once2(args[args.length - 1]);
				server.once("error", done);
			}
			return server.listen.apply(server, args);
		};
		function logerror(err) {
			if (this.get("env") !== "test") console.error(err.stack || err.toString());
		}
		function tryRender(view2, options, callback) {
			try {
				view2.render(options, callback);
			} catch (err) {
				callback(err);
			}
		}
	})(application);
	return application.exports;
}
var negotiator = { exports: {} };
var charset = { exports: {} };
var hasRequiredCharset;
function requireCharset() {
	if (hasRequiredCharset) return charset.exports;
	hasRequiredCharset = 1;
	charset.exports = preferredCharsets;
	charset.exports.preferredCharsets = preferredCharsets;
	var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
	function parseAcceptCharset(accept) {
		var accepts2 = accept.split(",");
		for (var i = 0, j = 0; i < accepts2.length; i++) {
			var charset2 = parseCharset(accepts2[i].trim(), i);
			if (charset2) accepts2[j++] = charset2;
		}
		accepts2.length = j;
		return accepts2;
	}
	function parseCharset(str, i) {
		var match = simpleCharsetRegExp.exec(str);
		if (!match) return null;
		var charset2 = match[1];
		var q = 1;
		if (match[2]) {
			var params = match[2].split(";");
			for (var j = 0; j < params.length; j++) {
				var p = params[j].trim().split("=");
				if (p[0] === "q") {
					q = parseFloat(p[1]);
					break;
				}
			}
		}
		return {
			charset: charset2,
			q,
			i
		};
	}
	function getCharsetPriority(charset2, accepted, index2) {
		var priority = {
			o: -1,
			q: 0,
			s: 0
		};
		for (var i = 0; i < accepted.length; i++) {
			var spec = specify(charset2, accepted[i], index2);
			if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
		}
		return priority;
	}
	function specify(charset2, spec, index2) {
		var s$1 = 0;
		if (spec.charset.toLowerCase() === charset2.toLowerCase()) s$1 |= 1;
		else if (spec.charset !== "*") return null;
		return {
			i: index2,
			o: spec.i,
			q: spec.q,
			s: s$1
		};
	}
	function preferredCharsets(accept, provided) {
		var accepts2 = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
		if (!provided) return accepts2.filter(isQuality).sort(compareSpecs).map(getFullCharset);
		var priorities = provided.map(function getPriority(type2, index2) {
			return getCharsetPriority(type2, accepts2, index2);
		});
		return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
			return provided[priorities.indexOf(priority)];
		});
	}
	function compareSpecs(a, b) {
		return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}
	function getFullCharset(spec) {
		return spec.charset;
	}
	function isQuality(spec) {
		return spec.q > 0;
	}
	return charset.exports;
}
var encoding = { exports: {} };
var hasRequiredEncoding;
function requireEncoding() {
	if (hasRequiredEncoding) return encoding.exports;
	hasRequiredEncoding = 1;
	encoding.exports = preferredEncodings;
	encoding.exports.preferredEncodings = preferredEncodings;
	var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
	function parseAcceptEncoding(accept) {
		var accepts2 = accept.split(",");
		var hasIdentity = false;
		var minQuality = 1;
		for (var i = 0, j = 0; i < accepts2.length; i++) {
			var encoding2 = parseEncoding(accepts2[i].trim(), i);
			if (encoding2) {
				accepts2[j++] = encoding2;
				hasIdentity = hasIdentity || specify("identity", encoding2);
				minQuality = Math.min(minQuality, encoding2.q || 1);
			}
		}
		if (!hasIdentity) accepts2[j++] = {
			encoding: "identity",
			q: minQuality,
			i
		};
		accepts2.length = j;
		return accepts2;
	}
	function parseEncoding(str, i) {
		var match = simpleEncodingRegExp.exec(str);
		if (!match) return null;
		var encoding2 = match[1];
		var q = 1;
		if (match[2]) {
			var params = match[2].split(";");
			for (var j = 0; j < params.length; j++) {
				var p = params[j].trim().split("=");
				if (p[0] === "q") {
					q = parseFloat(p[1]);
					break;
				}
			}
		}
		return {
			encoding: encoding2,
			q,
			i
		};
	}
	function getEncodingPriority(encoding2, accepted, index2) {
		var priority = {
			encoding: encoding2,
			o: -1,
			q: 0,
			s: 0
		};
		for (var i = 0; i < accepted.length; i++) {
			var spec = specify(encoding2, accepted[i], index2);
			if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
		}
		return priority;
	}
	function specify(encoding2, spec, index2) {
		var s$1 = 0;
		if (spec.encoding.toLowerCase() === encoding2.toLowerCase()) s$1 |= 1;
		else if (spec.encoding !== "*") return null;
		return {
			encoding: encoding2,
			i: index2,
			o: spec.i,
			q: spec.q,
			s: s$1
		};
	}
	function preferredEncodings(accept, provided, preferred) {
		var accepts2 = parseAcceptEncoding(accept || "");
		var comparator = preferred ? function comparator2(a, b) {
			if (a.q !== b.q) return b.q - a.q;
			var aPreferred = preferred.indexOf(a.encoding);
			var bPreferred = preferred.indexOf(b.encoding);
			if (aPreferred === -1 && bPreferred === -1) return b.s - a.s || a.o - b.o || a.i - b.i;
			if (aPreferred !== -1 && bPreferred !== -1) return aPreferred - bPreferred;
			return aPreferred === -1 ? 1 : -1;
		} : compareSpecs;
		if (!provided) return accepts2.filter(isQuality).sort(comparator).map(getFullEncoding);
		var priorities = provided.map(function getPriority(type2, index2) {
			return getEncodingPriority(type2, accepts2, index2);
		});
		return priorities.filter(isQuality).sort(comparator).map(function getEncoding(priority) {
			return provided[priorities.indexOf(priority)];
		});
	}
	function compareSpecs(a, b) {
		return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i;
	}
	function getFullEncoding(spec) {
		return spec.encoding;
	}
	function isQuality(spec) {
		return spec.q > 0;
	}
	return encoding.exports;
}
var language = { exports: {} };
var hasRequiredLanguage;
function requireLanguage() {
	if (hasRequiredLanguage) return language.exports;
	hasRequiredLanguage = 1;
	language.exports = preferredLanguages;
	language.exports.preferredLanguages = preferredLanguages;
	var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
	function parseAcceptLanguage(accept) {
		var accepts2 = accept.split(",");
		for (var i = 0, j = 0; i < accepts2.length; i++) {
			var language2 = parseLanguage(accepts2[i].trim(), i);
			if (language2) accepts2[j++] = language2;
		}
		accepts2.length = j;
		return accepts2;
	}
	function parseLanguage(str, i) {
		var match = simpleLanguageRegExp.exec(str);
		if (!match) return null;
		var prefix = match[1];
		var suffix = match[2];
		var full = prefix;
		if (suffix) full += "-" + suffix;
		var q = 1;
		if (match[3]) {
			var params = match[3].split(";");
			for (var j = 0; j < params.length; j++) {
				var p = params[j].split("=");
				if (p[0] === "q") q = parseFloat(p[1]);
			}
		}
		return {
			prefix,
			suffix,
			q,
			i,
			full
		};
	}
	function getLanguagePriority(language2, accepted, index2) {
		var priority = {
			o: -1,
			q: 0,
			s: 0
		};
		for (var i = 0; i < accepted.length; i++) {
			var spec = specify(language2, accepted[i], index2);
			if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
		}
		return priority;
	}
	function specify(language2, spec, index2) {
		var p = parseLanguage(language2);
		if (!p) return null;
		var s$1 = 0;
		if (spec.full.toLowerCase() === p.full.toLowerCase()) s$1 |= 4;
		else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) s$1 |= 2;
		else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) s$1 |= 1;
		else if (spec.full !== "*") return null;
		return {
			i: index2,
			o: spec.i,
			q: spec.q,
			s: s$1
		};
	}
	function preferredLanguages(accept, provided) {
		var accepts2 = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
		if (!provided) return accepts2.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
		var priorities = provided.map(function getPriority(type2, index2) {
			return getLanguagePriority(type2, accepts2, index2);
		});
		return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
			return provided[priorities.indexOf(priority)];
		});
	}
	function compareSpecs(a, b) {
		return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}
	function getFullLanguage(spec) {
		return spec.full;
	}
	function isQuality(spec) {
		return spec.q > 0;
	}
	return language.exports;
}
var mediaType = { exports: {} };
var hasRequiredMediaType;
function requireMediaType() {
	if (hasRequiredMediaType) return mediaType.exports;
	hasRequiredMediaType = 1;
	mediaType.exports = preferredMediaTypes;
	mediaType.exports.preferredMediaTypes = preferredMediaTypes;
	var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
	function parseAccept(accept) {
		var accepts2 = splitMediaTypes(accept);
		for (var i = 0, j = 0; i < accepts2.length; i++) {
			var mediaType2 = parseMediaType(accepts2[i].trim(), i);
			if (mediaType2) accepts2[j++] = mediaType2;
		}
		accepts2.length = j;
		return accepts2;
	}
	function parseMediaType(str, i) {
		var match = simpleMediaTypeRegExp.exec(str);
		if (!match) return null;
		var params = /* @__PURE__ */ Object.create(null);
		var q = 1;
		var subtype = match[2];
		var type2 = match[1];
		if (match[3]) {
			var kvps = splitParameters(match[3]).map(splitKeyValuePair);
			for (var j = 0; j < kvps.length; j++) {
				var pair = kvps[j];
				var key = pair[0].toLowerCase();
				var val = pair[1];
				var value = val && val[0] === "\"" && val[val.length - 1] === "\"" ? val.slice(1, -1) : val;
				if (key === "q") {
					q = parseFloat(value);
					break;
				}
				params[key] = value;
			}
		}
		return {
			type: type2,
			subtype,
			params,
			q,
			i
		};
	}
	function getMediaTypePriority(type2, accepted, index2) {
		var priority = {
			o: -1,
			q: 0,
			s: 0
		};
		for (var i = 0; i < accepted.length; i++) {
			var spec = specify(type2, accepted[i], index2);
			if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
		}
		return priority;
	}
	function specify(type2, spec, index2) {
		var p = parseMediaType(type2);
		var s$1 = 0;
		if (!p) return null;
		if (spec.type.toLowerCase() == p.type.toLowerCase()) s$1 |= 4;
		else if (spec.type != "*") return null;
		if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) s$1 |= 2;
		else if (spec.subtype != "*") return null;
		var keys = Object.keys(spec.params);
		if (keys.length > 0) if (keys.every(function(k) {
			return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
		})) s$1 |= 1;
		else return null;
		return {
			i: index2,
			o: spec.i,
			q: spec.q,
			s: s$1
		};
	}
	function preferredMediaTypes(accept, provided) {
		var accepts2 = parseAccept(accept === void 0 ? "*/*" : accept || "");
		if (!provided) return accepts2.filter(isQuality).sort(compareSpecs).map(getFullType);
		var priorities = provided.map(function getPriority(type2, index2) {
			return getMediaTypePriority(type2, accepts2, index2);
		});
		return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
			return provided[priorities.indexOf(priority)];
		});
	}
	function compareSpecs(a, b) {
		return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}
	function getFullType(spec) {
		return spec.type + "/" + spec.subtype;
	}
	function isQuality(spec) {
		return spec.q > 0;
	}
	function quoteCount(string$2) {
		var count = 0;
		var index2 = 0;
		while ((index2 = string$2.indexOf("\"", index2)) !== -1) {
			count++;
			index2++;
		}
		return count;
	}
	function splitKeyValuePair(str) {
		var index2 = str.indexOf("=");
		var key;
		var val;
		if (index2 === -1) key = str;
		else {
			key = str.slice(0, index2);
			val = str.slice(index2 + 1);
		}
		return [key, val];
	}
	function splitMediaTypes(accept) {
		var accepts2 = accept.split(",");
		for (var i = 1, j = 0; i < accepts2.length; i++) if (quoteCount(accepts2[j]) % 2 == 0) accepts2[++j] = accepts2[i];
		else accepts2[j] += "," + accepts2[i];
		accepts2.length = j + 1;
		return accepts2;
	}
	function splitParameters(str) {
		var parameters = str.split(";");
		for (var i = 1, j = 0; i < parameters.length; i++) if (quoteCount(parameters[j]) % 2 == 0) parameters[++j] = parameters[i];
		else parameters[j] += ";" + parameters[i];
		parameters.length = j + 1;
		for (var i = 0; i < parameters.length; i++) parameters[i] = parameters[i].trim();
		return parameters;
	}
	return mediaType.exports;
}
/*!
* negotiator
* Copyright(c) 2012 Federico Romero
* Copyright(c) 2012-2014 Isaac Z. Schlueter
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var hasRequiredNegotiator;
function requireNegotiator() {
	if (hasRequiredNegotiator) return negotiator.exports;
	hasRequiredNegotiator = 1;
	var preferredCharsets = requireCharset();
	var preferredEncodings = requireEncoding();
	var preferredLanguages = requireLanguage();
	var preferredMediaTypes = requireMediaType();
	negotiator.exports = Negotiator;
	negotiator.exports.Negotiator = Negotiator;
	function Negotiator(request2) {
		if (!(this instanceof Negotiator)) return new Negotiator(request2);
		this.request = request2;
	}
	Negotiator.prototype.charset = function charset2(available) {
		var set = this.charsets(available);
		return set && set[0];
	};
	Negotiator.prototype.charsets = function charsets(available) {
		return preferredCharsets(this.request.headers["accept-charset"], available);
	};
	Negotiator.prototype.encoding = function encoding2(available, opts) {
		var set = this.encodings(available, opts);
		return set && set[0];
	};
	Negotiator.prototype.encodings = function encodings2(available, options) {
		var opts = options || {};
		return preferredEncodings(this.request.headers["accept-encoding"], available, opts.preferred);
	};
	Negotiator.prototype.language = function language2(available) {
		var set = this.languages(available);
		return set && set[0];
	};
	Negotiator.prototype.languages = function languages(available) {
		return preferredLanguages(this.request.headers["accept-language"], available);
	};
	Negotiator.prototype.mediaType = function mediaType2(available) {
		var set = this.mediaTypes(available);
		return set && set[0];
	};
	Negotiator.prototype.mediaTypes = function mediaTypes(available) {
		return preferredMediaTypes(this.request.headers.accept, available);
	};
	Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
	Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
	Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
	Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
	Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
	Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
	Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
	Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
	return negotiator.exports;
}
/*!
* accepts
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var accepts;
var hasRequiredAccepts;
function requireAccepts() {
	if (hasRequiredAccepts) return accepts;
	hasRequiredAccepts = 1;
	var Negotiator = requireNegotiator();
	var mime$1 = requireMimeTypes();
	accepts = Accepts;
	function Accepts(req) {
		if (!(this instanceof Accepts)) return new Accepts(req);
		this.headers = req.headers;
		this.negotiator = new Negotiator(req);
	}
	Accepts.prototype.type = Accepts.prototype.types = function(types_) {
		var types = types_;
		if (types && !Array.isArray(types)) {
			types = new Array(arguments.length);
			for (var i = 0; i < types.length; i++) types[i] = arguments[i];
		}
		if (!types || types.length === 0) return this.negotiator.mediaTypes();
		if (!this.headers.accept) return types[0];
		var mimes = types.map(extToMime);
		var first = this.negotiator.mediaTypes(mimes.filter(validMime))[0];
		return first ? types[mimes.indexOf(first)] : false;
	};
	Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
		var encodings2 = encodings_;
		if (encodings2 && !Array.isArray(encodings2)) {
			encodings2 = new Array(arguments.length);
			for (var i = 0; i < encodings2.length; i++) encodings2[i] = arguments[i];
		}
		if (!encodings2 || encodings2.length === 0) return this.negotiator.encodings();
		return this.negotiator.encodings(encodings2)[0] || false;
	};
	Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
		var charsets = charsets_;
		if (charsets && !Array.isArray(charsets)) {
			charsets = new Array(arguments.length);
			for (var i = 0; i < charsets.length; i++) charsets[i] = arguments[i];
		}
		if (!charsets || charsets.length === 0) return this.negotiator.charsets();
		return this.negotiator.charsets(charsets)[0] || false;
	};
	Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
		var languages = languages_;
		if (languages && !Array.isArray(languages)) {
			languages = new Array(arguments.length);
			for (var i = 0; i < languages.length; i++) languages[i] = arguments[i];
		}
		if (!languages || languages.length === 0) return this.negotiator.languages();
		return this.negotiator.languages(languages)[0] || false;
	};
	function extToMime(type2) {
		return type2.indexOf("/") === -1 ? mime$1.lookup(type2) : type2;
	}
	function validMime(type2) {
		return typeof type2 === "string";
	}
	return accepts;
}
/*!
* fresh
* Copyright(c) 2012 TJ Holowaychuk
* Copyright(c) 2016-2017 Douglas Christopher Wilson
* MIT Licensed
*/
var fresh_1;
var hasRequiredFresh;
function requireFresh() {
	if (hasRequiredFresh) return fresh_1;
	hasRequiredFresh = 1;
	var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
	fresh_1 = fresh;
	function fresh(reqHeaders, resHeaders) {
		var modifiedSince = reqHeaders["if-modified-since"];
		var noneMatch = reqHeaders["if-none-match"];
		if (!modifiedSince && !noneMatch) return false;
		var cacheControl = reqHeaders["cache-control"];
		if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) return false;
		if (noneMatch) {
			if (noneMatch === "*") return true;
			var etag = resHeaders.etag;
			if (!etag) return false;
			var matches = parseTokenList(noneMatch);
			for (var i = 0; i < matches.length; i++) {
				var match = matches[i];
				if (match === etag || match === "W/" + etag || "W/" + match === etag) return true;
			}
			return false;
		}
		if (modifiedSince) {
			var lastModified = resHeaders["last-modified"];
			if (!lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince))) return false;
		}
		return true;
	}
	function parseHttpDate(date$2) {
		var timestamp = date$2 && Date.parse(date$2);
		return typeof timestamp === "number" ? timestamp : NaN;
	}
	function parseTokenList(str) {
		var end = 0;
		var list = [];
		var start = 0;
		for (var i = 0, len = str.length; i < len; i++) switch (str.charCodeAt(i)) {
			case 32:
				if (start === end) start = end = i + 1;
				break;
			case 44:
				list.push(str.substring(start, end));
				start = end = i + 1;
				break;
			default:
				end = i + 1;
				break;
		}
		list.push(str.substring(start, end));
		return list;
	}
	return fresh_1;
}
/*!
* range-parser
* Copyright(c) 2012-2014 TJ Holowaychuk
* Copyright(c) 2015-2016 Douglas Christopher Wilson
* MIT Licensed
*/
var rangeParser_1;
var hasRequiredRangeParser;
function requireRangeParser() {
	if (hasRequiredRangeParser) return rangeParser_1;
	hasRequiredRangeParser = 1;
	rangeParser_1 = rangeParser;
	function rangeParser(size, str, options) {
		if (typeof str !== "string") throw new TypeError("argument str must be a string");
		var index2 = str.indexOf("=");
		if (index2 === -1) return -2;
		var arr = str.slice(index2 + 1).split(",");
		var ranges = [];
		ranges.type = str.slice(0, index2);
		for (var i = 0; i < arr.length; i++) {
			var range2 = arr[i].split("-");
			var start = parseInt(range2[0], 10);
			var end = parseInt(range2[1], 10);
			if (isNaN(start)) {
				start = size - end;
				end = size - 1;
			} else if (isNaN(end)) end = size - 1;
			if (end > size - 1) end = size - 1;
			if (isNaN(start) || isNaN(end) || start > end || start < 0) continue;
			ranges.push({
				start,
				end
			});
		}
		if (ranges.length < 1) return -1;
		return options && options.combine ? combineRanges(ranges) : ranges;
	}
	function combineRanges(ranges) {
		var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
		for (var j = 0, i = 1; i < ordered.length; i++) {
			var range2 = ordered[i];
			var current = ordered[j];
			if (range2.start > current.end + 1) ordered[++j] = range2;
			else if (range2.end > current.end) {
				current.end = range2.end;
				current.index = Math.min(current.index, range2.index);
			}
		}
		ordered.length = j + 1;
		var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
		combined.type = ranges.type;
		return combined;
	}
	function mapWithIndex(range2, index2) {
		return {
			start: range2.start,
			end: range2.end,
			index: index2
		};
	}
	function mapWithoutIndex(range2) {
		return {
			start: range2.start,
			end: range2.end
		};
	}
	function sortByRangeIndex(a, b) {
		return a.index - b.index;
	}
	function sortByRangeStart(a, b) {
		return a.start - b.start;
	}
	return rangeParser_1;
}
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var request;
var hasRequiredRequest;
function requireRequest() {
	if (hasRequiredRequest) return request;
	hasRequiredRequest = 1;
	var accepts2 = requireAccepts();
	var isIP = require$$1$4.isIP;
	var typeis = requireTypeIs();
	var http$3 = require$$2$2;
	var fresh = requireFresh();
	var parseRange = requireRangeParser();
	var parse2 = requireParseurl();
	var proxyaddr = requireProxyAddr();
	var req = Object.create(http$3.IncomingMessage.prototype);
	request = req;
	req.get = req.header = function header(name) {
		if (!name) throw new TypeError("name argument is required to req.get");
		if (typeof name !== "string") throw new TypeError("name must be a string to req.get");
		var lc = name.toLowerCase();
		switch (lc) {
			case "referer":
			case "referrer": return this.headers.referrer || this.headers.referer;
			default: return this.headers[lc];
		}
	};
	req.accepts = function() {
		var accept = accepts2(this);
		return accept.types.apply(accept, arguments);
	};
	req.acceptsEncodings = function() {
		var accept = accepts2(this);
		return accept.encodings.apply(accept, arguments);
	};
	req.acceptsCharsets = function() {
		var accept = accepts2(this);
		return accept.charsets.apply(accept, arguments);
	};
	req.acceptsLanguages = function() {
		var accept = accepts2(this);
		return accept.languages.apply(accept, arguments);
	};
	req.range = function range2(size, options) {
		var range3 = this.get("Range");
		if (!range3) return;
		return parseRange(size, range3, options);
	};
	defineGetter(req, "query", function query() {
		var queryparse = this.app.get("query parser fn");
		if (!queryparse) return /* @__PURE__ */ Object.create(null);
		var querystring = parse2(this).query;
		return queryparse(querystring);
	});
	req.is = function is(types) {
		var arr = types;
		if (!Array.isArray(types)) {
			arr = new Array(arguments.length);
			for (var i = 0; i < arr.length; i++) arr[i] = arguments[i];
		}
		return typeis(this, arr);
	};
	defineGetter(req, "protocol", function protocol() {
		var proto = this.connection.encrypted ? "https" : "http";
		if (!this.app.get("trust proxy fn")(this.connection.remoteAddress, 0)) return proto;
		var header = this.get("X-Forwarded-Proto") || proto;
		var index2 = header.indexOf(",");
		return index2 !== -1 ? header.substring(0, index2).trim() : header.trim();
	});
	defineGetter(req, "secure", function secure() {
		return this.protocol === "https";
	});
	defineGetter(req, "ip", function ip() {
		var trust = this.app.get("trust proxy fn");
		return proxyaddr(this, trust);
	});
	defineGetter(req, "ips", function ips() {
		var trust = this.app.get("trust proxy fn");
		var addrs = proxyaddr.all(this, trust);
		addrs.reverse().pop();
		return addrs;
	});
	defineGetter(req, "subdomains", function subdomains() {
		var hostname$1 = this.hostname;
		if (!hostname$1) return [];
		var offset = this.app.get("subdomain offset");
		return (!isIP(hostname$1) ? hostname$1.split(".").reverse() : [hostname$1]).slice(offset);
	});
	defineGetter(req, "path", function path$3() {
		return parse2(this).pathname;
	});
	defineGetter(req, "host", function host() {
		var trust = this.app.get("trust proxy fn");
		var val = this.get("X-Forwarded-Host");
		if (!val || !trust(this.connection.remoteAddress, 0)) val = this.get("Host");
		else if (val.indexOf(",") !== -1) val = val.substring(0, val.indexOf(",")).trimRight();
		return val || void 0;
	});
	defineGetter(req, "hostname", function hostname$1() {
		var host = this.host;
		if (!host) return;
		var offset = host[0] === "[" ? host.indexOf("]") + 1 : 0;
		var index2 = host.indexOf(":", offset);
		return index2 !== -1 ? host.substring(0, index2) : host;
	});
	defineGetter(req, "fresh", function() {
		var method = this.method;
		var res = this.res;
		var status = res.statusCode;
		if ("GET" !== method && "HEAD" !== method) return false;
		if (status >= 200 && status < 300 || 304 === status) return fresh(this.headers, {
			"etag": res.get("ETag"),
			"last-modified": res.get("Last-Modified")
		});
		return false;
	});
	defineGetter(req, "stale", function stale() {
		return !this.fresh;
	});
	defineGetter(req, "xhr", function xhr() {
		return (this.get("X-Requested-With") || "").toLowerCase() === "xmlhttprequest";
	});
	function defineGetter(obj, name, getter) {
		Object.defineProperty(obj, name, {
			configurable: true,
			enumerable: true,
			get: getter
		});
	}
	return request;
}
var contentDisposition = { exports: {} };
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
	if (hasRequiredSafeBuffer) return safeBuffer.exports;
	hasRequiredSafeBuffer = 1;
	(function(module$1, exports$1) {
		var buffer$1 = require$$0$4;
		var Buffer2 = buffer$1.Buffer;
		function copyProps(src, dst) {
			for (var key in src) dst[key] = src[key];
		}
		if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) module$1.exports = buffer$1;
		else {
			copyProps(buffer$1, exports$1);
			exports$1.Buffer = SafeBuffer;
		}
		function SafeBuffer(arg, encodingOrOffset, length) {
			return Buffer2(arg, encodingOrOffset, length);
		}
		SafeBuffer.prototype = Object.create(Buffer2.prototype);
		copyProps(Buffer2, SafeBuffer);
		SafeBuffer.from = function(arg, encodingOrOffset, length) {
			if (typeof arg === "number") throw new TypeError("Argument must not be a number");
			return Buffer2(arg, encodingOrOffset, length);
		};
		SafeBuffer.alloc = function(size, fill, encoding2) {
			if (typeof size !== "number") throw new TypeError("Argument must be a number");
			var buf = Buffer2(size);
			if (fill !== void 0) if (typeof encoding2 === "string") buf.fill(fill, encoding2);
			else buf.fill(fill);
			else buf.fill(0);
			return buf;
		};
		SafeBuffer.allocUnsafe = function(size) {
			if (typeof size !== "number") throw new TypeError("Argument must be a number");
			return Buffer2(size);
		};
		SafeBuffer.allocUnsafeSlow = function(size) {
			if (typeof size !== "number") throw new TypeError("Argument must be a number");
			return buffer$1.SlowBuffer(size);
		};
	})(safeBuffer, safeBuffer.exports);
	return safeBuffer.exports;
}
/*!
* content-disposition
* Copyright(c) 2014-2017 Douglas Christopher Wilson
* MIT Licensed
*/
var hasRequiredContentDisposition;
function requireContentDisposition() {
	if (hasRequiredContentDisposition) return contentDisposition.exports;
	hasRequiredContentDisposition = 1;
	contentDisposition.exports = contentDisposition$1;
	contentDisposition.exports.parse = parse2;
	var basename = path$1.basename;
	var Buffer2 = requireSafeBuffer().Buffer;
	var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
	var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
	var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
	var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
	var QESC_REGEXP = /\\([\u0000-\u007f])/g;
	var QUOTE_REGEXP = /([\\"])/g;
	var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
	var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
	var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
	var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
	var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
	function contentDisposition$1(filename, options) {
		var opts = options || {};
		return format(new ContentDisposition(opts.type || "attachment", createparams(filename, opts.fallback)));
	}
	function createparams(filename, fallback) {
		if (filename === void 0) return;
		var params = {};
		if (typeof filename !== "string") throw new TypeError("filename must be a string");
		if (fallback === void 0) fallback = true;
		if (typeof fallback !== "string" && typeof fallback !== "boolean") throw new TypeError("fallback must be a string or boolean");
		if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) throw new TypeError("fallback must be ISO-8859-1 string");
		var name = basename(filename);
		var isQuotedString = TEXT_REGEXP.test(name);
		var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name) : basename(fallback);
		var hasFallback = typeof fallbackName === "string" && fallbackName !== name;
		if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) params["filename*"] = name;
		if (isQuotedString || hasFallback) params.filename = hasFallback ? fallbackName : name;
		return params;
	}
	function format(obj) {
		var parameters = obj.parameters;
		var type2 = obj.type;
		if (!type2 || typeof type2 !== "string" || !TOKEN_REGEXP.test(type2)) throw new TypeError("invalid type");
		var string$2 = String(type2).toLowerCase();
		if (parameters && typeof parameters === "object") {
			var param;
			var params = Object.keys(parameters).sort();
			for (var i = 0; i < params.length; i++) {
				param = params[i];
				var val = param.slice(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
				string$2 += "; " + param + "=" + val;
			}
		}
		return string$2;
	}
	function decodefield(str) {
		var match = EXT_VALUE_REGEXP.exec(str);
		if (!match) throw new TypeError("invalid extended field value");
		var charset2 = match[1].toLowerCase();
		var encoded = match[2];
		var value;
		var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
		switch (charset2) {
			case "iso-8859-1":
				value = getlatin1(binary);
				break;
			case "utf-8":
			case "utf8":
				value = Buffer2.from(binary, "binary").toString("utf8");
				break;
			default: throw new TypeError("unsupported charset in extended field");
		}
		return value;
	}
	function getlatin1(val) {
		return String(val).replace(NON_LATIN1_REGEXP, "?");
	}
	function parse2(string$2) {
		if (!string$2 || typeof string$2 !== "string") throw new TypeError("argument string is required");
		var match = DISPOSITION_TYPE_REGEXP.exec(string$2);
		if (!match) throw new TypeError("invalid type format");
		var index2 = match[0].length;
		var type2 = match[1].toLowerCase();
		var key;
		var names = [];
		var params = {};
		var value;
		index2 = PARAM_REGEXP.lastIndex = match[0].slice(-1) === ";" ? index2 - 1 : index2;
		while (match = PARAM_REGEXP.exec(string$2)) {
			if (match.index !== index2) throw new TypeError("invalid parameter format");
			index2 += match[0].length;
			key = match[1].toLowerCase();
			value = match[2];
			if (names.indexOf(key) !== -1) throw new TypeError("invalid duplicate parameter");
			names.push(key);
			if (key.indexOf("*") + 1 === key.length) {
				key = key.slice(0, -1);
				value = decodefield(value);
				params[key] = value;
				continue;
			}
			if (typeof params[key] === "string") continue;
			if (value[0] === "\"") value = value.slice(1, -1).replace(QESC_REGEXP, "$1");
			params[key] = value;
		}
		if (index2 !== -1 && index2 !== string$2.length) throw new TypeError("invalid parameter format");
		return new ContentDisposition(type2, params);
	}
	function pdecode(str, hex) {
		return String.fromCharCode(parseInt(hex, 16));
	}
	function pencode(char) {
		return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
	}
	function qstring(val) {
		return "\"" + String(val).replace(QUOTE_REGEXP, "\\$1") + "\"";
	}
	function ustring(val) {
		var str = String(val);
		return "UTF-8''" + encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
	}
	function ContentDisposition(type2, parameters) {
		this.type = type2;
		this.parameters = parameters;
	}
	return contentDisposition.exports;
}
var cookieSignature = {};
var hasRequiredCookieSignature;
function requireCookieSignature() {
	if (hasRequiredCookieSignature) return cookieSignature;
	hasRequiredCookieSignature = 1;
	(function(exports$1) {
		var crypto$2 = crypto;
		exports$1.sign = function(val, secret) {
			if ("string" != typeof val) throw new TypeError("Cookie value must be provided as a string.");
			if (null == secret) throw new TypeError("Secret key must be provided.");
			return val + "." + crypto$2.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
		};
		exports$1.unsign = function(input, secret) {
			if ("string" != typeof input) throw new TypeError("Signed cookie string must be provided.");
			if (null == secret) throw new TypeError("Secret key must be provided.");
			var tentativeValue = input.slice(0, input.lastIndexOf(".")), expectedInput = exports$1.sign(tentativeValue, secret), expectedBuffer = Buffer.from(expectedInput), inputBuffer = Buffer.from(input);
			return expectedBuffer.length === inputBuffer.length && crypto$2.timingSafeEqual(expectedBuffer, inputBuffer) ? tentativeValue : false;
		};
	})(cookieSignature);
	return cookieSignature;
}
var cookie = {};
/*!
* cookie
* Copyright(c) 2012-2014 Roman Shtylman
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var hasRequiredCookie;
function requireCookie() {
	if (hasRequiredCookie) return cookie;
	hasRequiredCookie = 1;
	cookie.parse = parse2;
	cookie.serialize = serialize;
	var __toString = Object.prototype.toString;
	var __hasOwnProperty = Object.prototype.hasOwnProperty;
	var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
	var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;
	var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
	var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
	function parse2(str, opt) {
		if (typeof str !== "string") throw new TypeError("argument str must be a string");
		var obj = {};
		var len = str.length;
		if (len < 2) return obj;
		var dec = opt && opt.decode || decode$2;
		var index2 = 0;
		var eqIdx = 0;
		var endIdx = 0;
		do {
			eqIdx = str.indexOf("=", index2);
			if (eqIdx === -1) break;
			endIdx = str.indexOf(";", index2);
			if (endIdx === -1) endIdx = len;
			else if (eqIdx > endIdx) {
				index2 = str.lastIndexOf(";", eqIdx - 1) + 1;
				continue;
			}
			var keyStartIdx = startIndex(str, index2, eqIdx);
			var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
			var key = str.slice(keyStartIdx, keyEndIdx);
			if (!__hasOwnProperty.call(obj, key)) {
				var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
				var valEndIdx = endIndex(str, endIdx, valStartIdx);
				if (str.charCodeAt(valStartIdx) === 34 && str.charCodeAt(valEndIdx - 1) === 34) {
					valStartIdx++;
					valEndIdx--;
				}
				obj[key] = tryDecode(str.slice(valStartIdx, valEndIdx), dec);
			}
			index2 = endIdx + 1;
		} while (index2 < len);
		return obj;
	}
	function startIndex(str, index2, max2) {
		do {
			var code = str.charCodeAt(index2);
			if (code !== 32 && code !== 9) return index2;
		} while (++index2 < max2);
		return max2;
	}
	function endIndex(str, index2, min2) {
		while (index2 > min2) {
			var code = str.charCodeAt(--index2);
			if (code !== 32 && code !== 9) return index2 + 1;
		}
		return min2;
	}
	function serialize(name, val, opt) {
		var enc = opt && opt.encode || encodeURIComponent;
		if (typeof enc !== "function") throw new TypeError("option encode is invalid");
		if (!cookieNameRegExp.test(name)) throw new TypeError("argument name is invalid");
		var value = enc(val);
		if (!cookieValueRegExp.test(value)) throw new TypeError("argument val is invalid");
		var str = name + "=" + value;
		if (!opt) return str;
		if (null != opt.maxAge) {
			var maxAge = Math.floor(opt.maxAge);
			if (!isFinite(maxAge)) throw new TypeError("option maxAge is invalid");
			str += "; Max-Age=" + maxAge;
		}
		if (opt.domain) {
			if (!domainValueRegExp.test(opt.domain)) throw new TypeError("option domain is invalid");
			str += "; Domain=" + opt.domain;
		}
		if (opt.path) {
			if (!pathValueRegExp.test(opt.path)) throw new TypeError("option path is invalid");
			str += "; Path=" + opt.path;
		}
		if (opt.expires) {
			var expires = opt.expires;
			if (!isDate$1(expires) || isNaN(expires.valueOf())) throw new TypeError("option expires is invalid");
			str += "; Expires=" + expires.toUTCString();
		}
		if (opt.httpOnly) str += "; HttpOnly";
		if (opt.secure) str += "; Secure";
		if (opt.partitioned) str += "; Partitioned";
		if (opt.priority) switch (typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority) {
			case "low":
				str += "; Priority=Low";
				break;
			case "medium":
				str += "; Priority=Medium";
				break;
			case "high":
				str += "; Priority=High";
				break;
			default: throw new TypeError("option priority is invalid");
		}
		if (opt.sameSite) switch (typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite) {
			case true:
				str += "; SameSite=Strict";
				break;
			case "lax":
				str += "; SameSite=Lax";
				break;
			case "strict":
				str += "; SameSite=Strict";
				break;
			case "none":
				str += "; SameSite=None";
				break;
			default: throw new TypeError("option sameSite is invalid");
		}
		return str;
	}
	function decode$2(str) {
		return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
	}
	function isDate$1(val) {
		return __toString.call(val) === "[object Date]";
	}
	function tryDecode(str, decode2) {
		try {
			return decode2(str);
		} catch (e) {
			return str;
		}
	}
	return cookie;
}
/*!
* send
* Copyright(c) 2012 TJ Holowaychuk
* Copyright(c) 2014-2022 Douglas Christopher Wilson
* MIT Licensed
*/
var send_1;
var hasRequiredSend;
function requireSend() {
	if (hasRequiredSend) return send_1;
	hasRequiredSend = 1;
	var createError = requireHttpErrors();
	var debug$2 = requireBrowser()("send");
	var encodeUrl = requireEncodeurl();
	var escapeHtml = requireEscapeHtml();
	var etag = requireEtag();
	var fresh = requireFresh();
	var fs$4 = fs;
	var mime$1 = requireMimeTypes();
	var ms2 = requireMs();
	var onFinished2 = requireOnFinished();
	var parseRange = requireRangeParser();
	var path$3 = path$1;
	var statuses2 = requireStatuses();
	var Stream$3 = require$$13;
	var util$4 = require$$14;
	var extname$1 = path$3.extname;
	var join$1 = path$3.join;
	var normalize = path$3.normalize;
	var resolve = path$3.resolve;
	var sep = path$3.sep;
	var BYTES_RANGE_REGEXP = /^ *bytes=/;
	var MAX_MAXAGE = 3600 * 24 * 365 * 1e3;
	var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
	send_1 = send;
	function send(req, path2, options) {
		return new SendStream(req, path2, options);
	}
	function SendStream(req, path2, options) {
		Stream$3.call(this);
		var opts = options || {};
		this.options = opts;
		this.path = path2;
		this.req = req;
		this._acceptRanges = opts.acceptRanges !== void 0 ? Boolean(opts.acceptRanges) : true;
		this._cacheControl = opts.cacheControl !== void 0 ? Boolean(opts.cacheControl) : true;
		this._etag = opts.etag !== void 0 ? Boolean(opts.etag) : true;
		this._dotfiles = opts.dotfiles !== void 0 ? opts.dotfiles : "ignore";
		if (this._dotfiles !== "ignore" && this._dotfiles !== "allow" && this._dotfiles !== "deny") throw new TypeError("dotfiles option must be \"allow\", \"deny\", or \"ignore\"");
		this._extensions = opts.extensions !== void 0 ? normalizeList(opts.extensions, "extensions option") : [];
		this._immutable = opts.immutable !== void 0 ? Boolean(opts.immutable) : false;
		this._index = opts.index !== void 0 ? normalizeList(opts.index, "index option") : ["index.html"];
		this._lastModified = opts.lastModified !== void 0 ? Boolean(opts.lastModified) : true;
		this._maxage = opts.maxAge || opts.maxage;
		this._maxage = typeof this._maxage === "string" ? ms2(this._maxage) : Number(this._maxage);
		this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
		this._root = opts.root ? resolve(opts.root) : null;
	}
	util$4.inherits(SendStream, Stream$3);
	SendStream.prototype.error = function error(status, err) {
		if (hasListeners(this, "error")) return this.emit("error", createHttpError(status, err));
		var res = this.res;
		var doc = createHtmlDocument("Error", escapeHtml(statuses2.message[status] || String(status)));
		clearHeaders(res);
		if (err && err.headers) setHeaders(res, err.headers);
		res.statusCode = status;
		res.setHeader("Content-Type", "text/html; charset=UTF-8");
		res.setHeader("Content-Length", Buffer.byteLength(doc));
		res.setHeader("Content-Security-Policy", "default-src 'none'");
		res.setHeader("X-Content-Type-Options", "nosniff");
		res.end(doc);
	};
	SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
		return this.path[this.path.length - 1] === "/";
	};
	SendStream.prototype.isConditionalGET = function isConditionalGET() {
		return this.req.headers["if-match"] || this.req.headers["if-unmodified-since"] || this.req.headers["if-none-match"] || this.req.headers["if-modified-since"];
	};
	SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
		var req = this.req;
		var res = this.res;
		var match = req.headers["if-match"];
		if (match) {
			var etag2 = res.getHeader("ETag");
			return !etag2 || match !== "*" && parseTokenList(match).every(function(match2) {
				return match2 !== etag2 && match2 !== "W/" + etag2 && "W/" + match2 !== etag2;
			});
		}
		var unmodifiedSince = parseHttpDate(req.headers["if-unmodified-since"]);
		if (!isNaN(unmodifiedSince)) {
			var lastModified = parseHttpDate(res.getHeader("Last-Modified"));
			return isNaN(lastModified) || lastModified > unmodifiedSince;
		}
		return false;
	};
	SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
		var res = this.res;
		res.removeHeader("Content-Encoding");
		res.removeHeader("Content-Language");
		res.removeHeader("Content-Length");
		res.removeHeader("Content-Range");
		res.removeHeader("Content-Type");
	};
	SendStream.prototype.notModified = function notModified() {
		var res = this.res;
		debug$2("not modified");
		this.removeContentHeaderFields();
		res.statusCode = 304;
		res.end();
	};
	SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
		var err = /* @__PURE__ */ new Error("Can't set headers after they are sent.");
		debug$2("headers already sent");
		this.error(500, err);
	};
	SendStream.prototype.isCachable = function isCachable() {
		var statusCode = this.res.statusCode;
		return statusCode >= 200 && statusCode < 300 || statusCode === 304;
	};
	SendStream.prototype.onStatError = function onStatError(error) {
		switch (error.code) {
			case "ENAMETOOLONG":
			case "ENOENT":
			case "ENOTDIR":
				this.error(404, error);
				break;
			default:
				this.error(500, error);
				break;
		}
	};
	SendStream.prototype.isFresh = function isFresh() {
		return fresh(this.req.headers, {
			etag: this.res.getHeader("ETag"),
			"last-modified": this.res.getHeader("Last-Modified")
		});
	};
	SendStream.prototype.isRangeFresh = function isRangeFresh() {
		var ifRange = this.req.headers["if-range"];
		if (!ifRange) return true;
		if (ifRange.indexOf("\"") !== -1) {
			var etag2 = this.res.getHeader("ETag");
			return Boolean(etag2 && ifRange.indexOf(etag2) !== -1);
		}
		return parseHttpDate(this.res.getHeader("Last-Modified")) <= parseHttpDate(ifRange);
	};
	SendStream.prototype.redirect = function redirect(path2) {
		var res = this.res;
		if (hasListeners(this, "directory")) {
			this.emit("directory", res, path2);
			return;
		}
		if (this.hasTrailingSlash()) {
			this.error(403);
			return;
		}
		var loc = encodeUrl(collapseLeadingSlashes(this.path + "/"));
		var doc = createHtmlDocument("Redirecting", "Redirecting to " + escapeHtml(loc));
		res.statusCode = 301;
		res.setHeader("Content-Type", "text/html; charset=UTF-8");
		res.setHeader("Content-Length", Buffer.byteLength(doc));
		res.setHeader("Content-Security-Policy", "default-src 'none'");
		res.setHeader("X-Content-Type-Options", "nosniff");
		res.setHeader("Location", loc);
		res.end(doc);
	};
	SendStream.prototype.pipe = function pipe$1(res) {
		var root = this._root;
		this.res = res;
		var path2 = decode$2(this.path);
		if (path2 === -1) {
			this.error(400);
			return res;
		}
		if (~path2.indexOf("\0")) {
			this.error(400);
			return res;
		}
		var parts;
		if (root !== null) {
			if (path2) path2 = normalize("." + sep + path2);
			if (UP_PATH_REGEXP.test(path2)) {
				debug$2("malicious path \"%s\"", path2);
				this.error(403);
				return res;
			}
			parts = path2.split(sep);
			path2 = normalize(join$1(root, path2));
		} else {
			if (UP_PATH_REGEXP.test(path2)) {
				debug$2("malicious path \"%s\"", path2);
				this.error(403);
				return res;
			}
			parts = normalize(path2).split(sep);
			path2 = resolve(path2);
		}
		if (containsDotFile(parts)) {
			debug$2("%s dotfile \"%s\"", this._dotfiles, path2);
			switch (this._dotfiles) {
				case "allow": break;
				case "deny":
					this.error(403);
					return res;
				case "ignore":
				default:
					this.error(404);
					return res;
			}
		}
		if (this._index.length && this.hasTrailingSlash()) {
			this.sendIndex(path2);
			return res;
		}
		this.sendFile(path2);
		return res;
	};
	SendStream.prototype.send = function send2(path2, stat$1) {
		var len = stat$1.size;
		var options = this.options;
		var opts = {};
		var res = this.res;
		var req = this.req;
		var ranges = req.headers.range;
		var offset = options.start || 0;
		if (res.headersSent) {
			this.headersAlreadySent();
			return;
		}
		debug$2("pipe \"%s\"", path2);
		this.setHeader(path2, stat$1);
		this.type(path2);
		if (this.isConditionalGET()) {
			if (this.isPreconditionFailure()) {
				this.error(412);
				return;
			}
			if (this.isCachable() && this.isFresh()) {
				this.notModified();
				return;
			}
		}
		len = Math.max(0, len - offset);
		if (options.end !== void 0) {
			var bytes2 = options.end - offset + 1;
			if (len > bytes2) len = bytes2;
		}
		if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
			ranges = parseRange(len, ranges, { combine: true });
			if (!this.isRangeFresh()) {
				debug$2("range stale");
				ranges = -2;
			}
			if (ranges === -1) {
				debug$2("range unsatisfiable");
				res.setHeader("Content-Range", contentRange("bytes", len));
				return this.error(416, { headers: { "Content-Range": res.getHeader("Content-Range") } });
			}
			if (ranges !== -2 && ranges.length === 1) {
				debug$2("range %j", ranges);
				res.statusCode = 206;
				res.setHeader("Content-Range", contentRange("bytes", len, ranges[0]));
				offset += ranges[0].start;
				len = ranges[0].end - ranges[0].start + 1;
			}
		}
		for (var prop in options) opts[prop] = options[prop];
		opts.start = offset;
		opts.end = Math.max(offset, offset + len - 1);
		res.setHeader("Content-Length", len);
		if (req.method === "HEAD") {
			res.end();
			return;
		}
		this.stream(path2, opts);
	};
	SendStream.prototype.sendFile = function sendFile(path2) {
		var i = 0;
		var self2 = this;
		debug$2("stat \"%s\"", path2);
		fs$4.stat(path2, function onstat(err, stat$1) {
			var pathEndsWithSep = path2[path2.length - 1] === sep;
			if (err && err.code === "ENOENT" && !extname$1(path2) && !pathEndsWithSep) return next(err);
			if (err) return self2.onStatError(err);
			if (stat$1.isDirectory()) return self2.redirect(path2);
			if (pathEndsWithSep) return self2.error(404);
			self2.emit("file", path2, stat$1);
			self2.send(path2, stat$1);
		});
		function next(err) {
			if (self2._extensions.length <= i) return err ? self2.onStatError(err) : self2.error(404);
			var p = path2 + "." + self2._extensions[i++];
			debug$2("stat \"%s\"", p);
			fs$4.stat(p, function(err2, stat$1) {
				if (err2) return next(err2);
				if (stat$1.isDirectory()) return next();
				self2.emit("file", p, stat$1);
				self2.send(p, stat$1);
			});
		}
	};
	SendStream.prototype.sendIndex = function sendIndex(path2) {
		var i = -1;
		var self2 = this;
		function next(err) {
			if (++i >= self2._index.length) {
				if (err) return self2.onStatError(err);
				return self2.error(404);
			}
			var p = join$1(path2, self2._index[i]);
			debug$2("stat \"%s\"", p);
			fs$4.stat(p, function(err2, stat$1) {
				if (err2) return next(err2);
				if (stat$1.isDirectory()) return next();
				self2.emit("file", p, stat$1);
				self2.send(p, stat$1);
			});
		}
		next();
	};
	SendStream.prototype.stream = function stream(path2, options) {
		var self2 = this;
		var res = this.res;
		var stream2 = fs$4.createReadStream(path2, options);
		this.emit("stream", stream2);
		stream2.pipe(res);
		function cleanup() {
			stream2.destroy();
		}
		onFinished2(res, cleanup);
		stream2.on("error", function onerror(err) {
			cleanup();
			self2.onStatError(err);
		});
		stream2.on("end", function onend() {
			self2.emit("end");
		});
	};
	SendStream.prototype.type = function type2(path2) {
		var res = this.res;
		if (res.getHeader("Content-Type")) return;
		var ext = extname$1(path2);
		var type3 = mime$1.contentType(ext) || "application/octet-stream";
		debug$2("content-type %s", type3);
		res.setHeader("Content-Type", type3);
	};
	SendStream.prototype.setHeader = function setHeader(path2, stat$1) {
		var res = this.res;
		this.emit("headers", res, path2, stat$1);
		if (this._acceptRanges && !res.getHeader("Accept-Ranges")) {
			debug$2("accept ranges");
			res.setHeader("Accept-Ranges", "bytes");
		}
		if (this._cacheControl && !res.getHeader("Cache-Control")) {
			var cacheControl = "public, max-age=" + Math.floor(this._maxage / 1e3);
			if (this._immutable) cacheControl += ", immutable";
			debug$2("cache-control %s", cacheControl);
			res.setHeader("Cache-Control", cacheControl);
		}
		if (this._lastModified && !res.getHeader("Last-Modified")) {
			var modified = stat$1.mtime.toUTCString();
			debug$2("modified %s", modified);
			res.setHeader("Last-Modified", modified);
		}
		if (this._etag && !res.getHeader("ETag")) {
			var val = etag(stat$1);
			debug$2("etag %s", val);
			res.setHeader("ETag", val);
		}
	};
	function clearHeaders(res) {
		for (const header of res.getHeaderNames()) res.removeHeader(header);
	}
	function collapseLeadingSlashes(str) {
		for (var i = 0; i < str.length; i++) if (str[i] !== "/") break;
		return i > 1 ? "/" + str.substr(i) : str;
	}
	function containsDotFile(parts) {
		for (var i = 0; i < parts.length; i++) {
			var part = parts[i];
			if (part.length > 1 && part[0] === ".") return true;
		}
		return false;
	}
	function contentRange(type2, size, range2) {
		return type2 + " " + (range2 ? range2.start + "-" + range2.end : "*") + "/" + size;
	}
	function createHtmlDocument(title, body) {
		return "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>" + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
	}
	function createHttpError(status, err) {
		if (!err) return createError(status);
		return err instanceof Error ? createError(status, err, { expose: false }) : createError(status, err);
	}
	function decode$2(path2) {
		try {
			return decodeURIComponent(path2);
		} catch (err) {
			return -1;
		}
	}
	function hasListeners(emitter, type2) {
		return (typeof emitter.listenerCount !== "function" ? emitter.listeners(type2).length : emitter.listenerCount(type2)) > 0;
	}
	function normalizeList(val, name) {
		var list = [].concat(val || []);
		for (var i = 0; i < list.length; i++) if (typeof list[i] !== "string") throw new TypeError(name + " must be array of strings or false");
		return list;
	}
	function parseHttpDate(date$2) {
		var timestamp = date$2 && Date.parse(date$2);
		return typeof timestamp === "number" ? timestamp : NaN;
	}
	function parseTokenList(str) {
		var end = 0;
		var list = [];
		var start = 0;
		for (var i = 0, len = str.length; i < len; i++) switch (str.charCodeAt(i)) {
			case 32:
				if (start === end) start = end = i + 1;
				break;
			case 44:
				if (start !== end) list.push(str.substring(start, end));
				start = end = i + 1;
				break;
			default:
				end = i + 1;
				break;
		}
		if (start !== end) list.push(str.substring(start, end));
		return list;
	}
	function setHeaders(res, headers) {
		var keys = Object.keys(headers);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			res.setHeader(key, headers[key]);
		}
	}
	return send_1;
}
var vary = { exports: {} };
/*!
* vary
* Copyright(c) 2014-2017 Douglas Christopher Wilson
* MIT Licensed
*/
var hasRequiredVary;
function requireVary() {
	if (hasRequiredVary) return vary.exports;
	hasRequiredVary = 1;
	vary.exports = vary$1;
	vary.exports.append = append;
	var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
	function append(header, field) {
		if (typeof header !== "string") throw new TypeError("header argument is required");
		if (!field) throw new TypeError("field argument is required");
		var fields = !Array.isArray(field) ? parse2(String(field)) : field;
		for (var j = 0; j < fields.length; j++) if (!FIELD_NAME_REGEXP.test(fields[j])) throw new TypeError("field argument contains an invalid header name");
		if (header === "*") return header;
		var val = header;
		var vals = parse2(header.toLowerCase());
		if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) return "*";
		for (var i = 0; i < fields.length; i++) {
			var fld = fields[i].toLowerCase();
			if (vals.indexOf(fld) === -1) {
				vals.push(fld);
				val = val ? val + ", " + fields[i] : fields[i];
			}
		}
		return val;
	}
	function parse2(header) {
		var end = 0;
		var list = [];
		var start = 0;
		for (var i = 0, len = header.length; i < len; i++) switch (header.charCodeAt(i)) {
			case 32:
				if (start === end) start = end = i + 1;
				break;
			case 44:
				list.push(header.substring(start, end));
				start = end = i + 1;
				break;
			default:
				end = i + 1;
				break;
		}
		list.push(header.substring(start, end));
		return list;
	}
	function vary$1(res, field) {
		if (!res || !res.getHeader || !res.setHeader) throw new TypeError("res argument is required");
		var val = res.getHeader("Vary") || "";
		if (val = append(Array.isArray(val) ? val.join(", ") : String(val), field)) res.setHeader("Vary", val);
	}
	return vary.exports;
}
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var response;
var hasRequiredResponse;
function requireResponse() {
	if (hasRequiredResponse) return response;
	hasRequiredResponse = 1;
	var contentDisposition2 = requireContentDisposition();
	var createError = requireHttpErrors();
	var encodeUrl = requireEncodeurl();
	var escapeHtml = requireEscapeHtml();
	var http$3 = require$$2$2;
	var onFinished2 = requireOnFinished();
	var mime$1 = requireMimeTypes();
	var path$3 = path;
	var pathIsAbsolute = path.isAbsolute;
	var statuses2 = requireStatuses();
	var sign2 = requireCookieSignature().sign;
	var normalizeType = requireUtils().normalizeType;
	var normalizeTypes = requireUtils().normalizeTypes;
	var setCharset = requireUtils().setCharset;
	var cookie2 = requireCookie();
	var send = requireSend();
	var extname$1 = path$3.extname;
	var resolve = path$3.resolve;
	var vary2 = requireVary();
	var res = Object.create(http$3.ServerResponse.prototype);
	response = res;
	res.status = function status(code) {
		if (!Number.isInteger(code)) throw new TypeError(`Invalid status code: ${JSON.stringify(code)}. Status code must be an integer.`);
		if (code < 100 || code > 999) throw new RangeError(`Invalid status code: ${JSON.stringify(code)}. Status code must be greater than 99 and less than 1000.`);
		this.statusCode = code;
		return this;
	};
	res.links = function(links) {
		var link$1 = this.get("Link") || "";
		if (link$1) link$1 += ", ";
		return this.set("Link", link$1 + Object.keys(links).map(function(rel) {
			if (Array.isArray(links[rel])) return links[rel].map(function(singleLink) {
				return `<${singleLink}>; rel="${rel}"`;
			}).join(", ");
			else return `<${links[rel]}>; rel="${rel}"`;
		}).join(", "));
	};
	res.send = function send2(body) {
		var chunk = body;
		var encoding2;
		var req = this.req;
		var type2;
		var app$3 = this.app;
		switch (typeof chunk) {
			case "string":
				if (!this.get("Content-Type")) this.type("html");
				break;
			case "boolean":
			case "number":
			case "object":
				if (chunk === null) chunk = "";
				else if (ArrayBuffer.isView(chunk)) {
					if (!this.get("Content-Type")) this.type("bin");
				} else return this.json(chunk);
				break;
		}
		if (typeof chunk === "string") {
			encoding2 = "utf8";
			type2 = this.get("Content-Type");
			if (typeof type2 === "string") this.set("Content-Type", setCharset(type2, "utf-8"));
		}
		var etagFn = app$3.get("etag fn");
		var generateETag = !this.get("ETag") && typeof etagFn === "function";
		var len;
		if (chunk !== void 0) {
			if (Buffer.isBuffer(chunk)) len = chunk.length;
			else if (!generateETag && chunk.length < 1e3) len = Buffer.byteLength(chunk, encoding2);
			else {
				chunk = Buffer.from(chunk, encoding2);
				encoding2 = void 0;
				len = chunk.length;
			}
			this.set("Content-Length", len);
		}
		var etag;
		if (generateETag && len !== void 0) {
			if (etag = etagFn(chunk, encoding2)) this.set("ETag", etag);
		}
		if (req.fresh) this.status(304);
		if (204 === this.statusCode || 304 === this.statusCode) {
			this.removeHeader("Content-Type");
			this.removeHeader("Content-Length");
			this.removeHeader("Transfer-Encoding");
			chunk = "";
		}
		if (this.statusCode === 205) {
			this.set("Content-Length", "0");
			this.removeHeader("Transfer-Encoding");
			chunk = "";
		}
		if (req.method === "HEAD") this.end();
		else this.end(chunk, encoding2);
		return this;
	};
	res.json = function json2(obj) {
		var app$3 = this.app;
		var escape2 = app$3.get("json escape");
		var body = stringify(obj, app$3.get("json replacer"), app$3.get("json spaces"), escape2);
		if (!this.get("Content-Type")) this.set("Content-Type", "application/json");
		return this.send(body);
	};
	res.jsonp = function jsonp(obj) {
		var app$3 = this.app;
		var escape2 = app$3.get("json escape");
		var body = stringify(obj, app$3.get("json replacer"), app$3.get("json spaces"), escape2);
		var callback = this.req.query[app$3.get("jsonp callback name")];
		if (!this.get("Content-Type")) {
			this.set("X-Content-Type-Options", "nosniff");
			this.set("Content-Type", "application/json");
		}
		if (Array.isArray(callback)) callback = callback[0];
		if (typeof callback === "string" && callback.length !== 0) {
			this.set("X-Content-Type-Options", "nosniff");
			this.set("Content-Type", "text/javascript");
			callback = callback.replace(/[^\[\]\w$.]/g, "");
			if (body === void 0) body = "";
			else if (typeof body === "string") body = body.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
			body = "/**/ typeof " + callback + " === 'function' && " + callback + "(" + body + ");";
		}
		return this.send(body);
	};
	res.sendStatus = function sendStatus(statusCode) {
		var body = statuses2.message[statusCode] || String(statusCode);
		this.status(statusCode);
		this.type("txt");
		return this.send(body);
	};
	res.sendFile = function sendFile(path2, options, callback) {
		var done = callback;
		var req = this.req;
		var res2 = this;
		var next = req.next;
		var opts = options || {};
		if (!path2) throw new TypeError("path argument is required to res.sendFile");
		if (typeof path2 !== "string") throw new TypeError("path must be a string to res.sendFile");
		if (typeof options === "function") {
			done = options;
			opts = {};
		}
		if (!opts.root && !pathIsAbsolute(path2)) throw new TypeError("path must be absolute or specify root to res.sendFile");
		var pathname = encodeURI(path2);
		opts.etag = this.app.enabled("etag");
		sendfile(res2, send(req, pathname, opts), opts, function(err) {
			if (done) return done(err);
			if (err && err.code === "EISDIR") return next();
			if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") next(err);
		});
	};
	res.download = function download(path2, filename, options, callback) {
		var done = callback;
		var name = filename;
		var opts = options || null;
		if (typeof filename === "function") {
			done = filename;
			name = null;
			opts = null;
		} else if (typeof options === "function") {
			done = options;
			opts = null;
		}
		if (typeof filename === "object" && (typeof options === "function" || options === void 0)) {
			name = null;
			opts = filename;
		}
		var headers = { "Content-Disposition": contentDisposition2(name || path2) };
		if (opts && opts.headers) {
			var keys = Object.keys(opts.headers);
			for (var i = 0; i < keys.length; i++) {
				var key = keys[i];
				if (key.toLowerCase() !== "content-disposition") headers[key] = opts.headers[key];
			}
		}
		opts = Object.create(opts);
		opts.headers = headers;
		var fullPath = !opts.root ? resolve(path2) : path2;
		return this.sendFile(fullPath, opts, done);
	};
	res.contentType = res.type = function contentType2(type2) {
		var ct = type2.indexOf("/") === -1 ? mime$1.contentType(type2) || "application/octet-stream" : type2;
		return this.set("Content-Type", ct);
	};
	res.format = function(obj) {
		var req = this.req;
		var next = req.next;
		var keys = Object.keys(obj).filter(function(v) {
			return v !== "default";
		});
		var key = keys.length > 0 ? req.accepts(keys) : false;
		this.vary("Accept");
		if (key) {
			this.set("Content-Type", normalizeType(key).value);
			obj[key](req, this, next);
		} else if (obj.default) obj.default(req, this, next);
		else next(createError(406, { types: normalizeTypes(keys).map(function(o) {
			return o.value;
		}) }));
		return this;
	};
	res.attachment = function attachment(filename) {
		if (filename) this.type(extname$1(filename));
		this.set("Content-Disposition", contentDisposition2(filename));
		return this;
	};
	res.append = function append(field, val) {
		var prev = this.get(field);
		var value = val;
		if (prev) value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
		return this.set(field, value);
	};
	res.set = res.header = function header(field, val) {
		if (arguments.length === 2) {
			var value = Array.isArray(val) ? val.map(String) : String(val);
			if (field.toLowerCase() === "content-type") {
				if (Array.isArray(value)) throw new TypeError("Content-Type cannot be set to an Array");
				value = mime$1.contentType(value);
			}
			this.setHeader(field, value);
		} else for (var key in field) this.set(key, field[key]);
		return this;
	};
	res.get = function(field) {
		return this.getHeader(field);
	};
	res.clearCookie = function clearCookie(name, options) {
		const opts = {
			path: "/",
			...options,
			expires: /* @__PURE__ */ new Date(1)
		};
		delete opts.maxAge;
		return this.cookie(name, "", opts);
	};
	res.cookie = function(name, value, options) {
		var opts = { ...options };
		var secret = this.req.secret;
		var signed = opts.signed;
		if (signed && !secret) throw new Error("cookieParser(\"secret\") required for signed cookies");
		var val = typeof value === "object" ? "j:" + JSON.stringify(value) : String(value);
		if (signed) val = "s:" + sign2(val, secret);
		if (opts.maxAge != null) {
			var maxAge = opts.maxAge - 0;
			if (!isNaN(maxAge)) {
				opts.expires = new Date(Date.now() + maxAge);
				opts.maxAge = Math.floor(maxAge / 1e3);
			}
		}
		if (opts.path == null) opts.path = "/";
		this.append("Set-Cookie", cookie2.serialize(name, String(val), opts));
		return this;
	};
	res.location = function location(url$1) {
		return this.set("Location", encodeUrl(url$1));
	};
	res.redirect = function redirect(url$1) {
		var address = url$1;
		var body;
		var status = 302;
		if (arguments.length === 2) {
			status = arguments[0];
			address = arguments[1];
		}
		address = this.location(address).get("Location");
		this.format({
			text: function() {
				body = statuses2.message[status] + ". Redirecting to " + address;
			},
			html: function() {
				var u = escapeHtml(address);
				body = "<p>" + statuses2.message[status] + ". Redirecting to " + u + "</p>";
			},
			default: function() {
				body = "";
			}
		});
		this.status(status);
		this.set("Content-Length", Buffer.byteLength(body));
		if (this.req.method === "HEAD") this.end();
		else this.end(body);
	};
	res.vary = function(field) {
		vary2(this, field);
		return this;
	};
	res.render = function render$1(view2, options, callback) {
		var app$3 = this.req.app;
		var done = callback;
		var opts = options || {};
		var req = this.req;
		var self2 = this;
		if (typeof options === "function") {
			done = options;
			opts = {};
		}
		opts._locals = self2.locals;
		done = done || function(err, str) {
			if (err) return req.next(err);
			self2.send(str);
		};
		app$3.render(view2, opts, done);
	};
	function sendfile(res2, file$2, options, callback) {
		var done = false;
		var streaming;
		function onaborted() {
			if (done) return;
			done = true;
			var err = /* @__PURE__ */ new Error("Request aborted");
			err.code = "ECONNABORTED";
			callback(err);
		}
		function ondirectory() {
			if (done) return;
			done = true;
			var err = /* @__PURE__ */ new Error("EISDIR, read");
			err.code = "EISDIR";
			callback(err);
		}
		function onerror(err) {
			if (done) return;
			done = true;
			callback(err);
		}
		function onend() {
			if (done) return;
			done = true;
			callback();
		}
		function onfile() {
			streaming = false;
		}
		function onfinish(err) {
			if (err && err.code === "ECONNRESET") return onaborted();
			if (err) return onerror(err);
			if (done) return;
			setImmediate(function() {
				if (streaming !== false && !done) {
					onaborted();
					return;
				}
				if (done) return;
				done = true;
				callback();
			});
		}
		function onstream() {
			streaming = true;
		}
		file$2.on("directory", ondirectory);
		file$2.on("end", onend);
		file$2.on("error", onerror);
		file$2.on("file", onfile);
		file$2.on("stream", onstream);
		onFinished2(res2, onfinish);
		if (options.headers) file$2.on("headers", function headers(res3) {
			var obj = options.headers;
			var keys = Object.keys(obj);
			for (var i = 0; i < keys.length; i++) {
				var k = keys[i];
				res3.setHeader(k, obj[k]);
			}
		});
		file$2.pipe(res2);
	}
	function stringify(value, replacer, spaces, escape2) {
		var json2 = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
		if (escape2 && typeof json2 === "string") json2 = json2.replace(/[<>&]/g, function(c) {
			switch (c.charCodeAt(0)) {
				case 60: return "\\u003c";
				case 62: return "\\u003e";
				case 38: return "\\u0026";
				default: return c;
			}
		});
		return json2;
	}
	return response;
}
/*!
* serve-static
* Copyright(c) 2010 Sencha Inc.
* Copyright(c) 2011 TJ Holowaychuk
* Copyright(c) 2014-2016 Douglas Christopher Wilson
* MIT Licensed
*/
var serveStatic_1;
var hasRequiredServeStatic;
function requireServeStatic() {
	if (hasRequiredServeStatic) return serveStatic_1;
	hasRequiredServeStatic = 1;
	var encodeUrl = requireEncodeurl();
	var escapeHtml = requireEscapeHtml();
	var parseUrl$3 = requireParseurl();
	var resolve = path$1.resolve;
	var send = requireSend();
	var url$1 = URL2;
	serveStatic_1 = serveStatic;
	function serveStatic(root, options) {
		if (!root) throw new TypeError("root path required");
		if (typeof root !== "string") throw new TypeError("root path must be a string");
		var opts = Object.create(options || null);
		var fallthrough = opts.fallthrough !== false;
		var redirect = opts.redirect !== false;
		var setHeaders = opts.setHeaders;
		if (setHeaders && typeof setHeaders !== "function") throw new TypeError("option setHeaders must be function");
		opts.maxage = opts.maxage || opts.maxAge || 0;
		opts.root = resolve(root);
		var onDirectory = redirect ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
		return function serveStatic2(req, res, next) {
			if (req.method !== "GET" && req.method !== "HEAD") {
				if (fallthrough) return next();
				res.statusCode = 405;
				res.setHeader("Allow", "GET, HEAD");
				res.setHeader("Content-Length", "0");
				res.end();
				return;
			}
			var forwardError = !fallthrough;
			var originalUrl = parseUrl$3.original(req);
			var path$3 = parseUrl$3(req).pathname;
			if (path$3 === "/" && originalUrl.pathname.substr(-1) !== "/") path$3 = "";
			var stream = send(req, path$3, opts);
			stream.on("directory", onDirectory);
			if (setHeaders) stream.on("headers", setHeaders);
			if (fallthrough) stream.on("file", function onFile() {
				forwardError = true;
			});
			stream.on("error", function error(err) {
				if (forwardError || !(err.statusCode < 500)) {
					next(err);
					return;
				}
				next();
			});
			stream.pipe(res);
		};
	}
	function collapseLeadingSlashes(str) {
		for (var i = 0; i < str.length; i++) if (str.charCodeAt(i) !== 47) break;
		return i > 1 ? "/" + str.substr(i) : str;
	}
	function createHtmlDocument(title, body) {
		return "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>" + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
	}
	function createNotFoundDirectoryListener() {
		return function notFound() {
			this.error(404);
		};
	}
	function createRedirectDirectoryListener() {
		return function redirect(res) {
			if (this.hasTrailingSlash()) {
				this.error(404);
				return;
			}
			var originalUrl = parseUrl$3.original(this.req);
			originalUrl.path = null;
			originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + "/");
			var loc = encodeUrl(url$1.format(originalUrl));
			var doc = createHtmlDocument("Redirecting", "Redirecting to " + escapeHtml(loc));
			res.statusCode = 301;
			res.setHeader("Content-Type", "text/html; charset=UTF-8");
			res.setHeader("Content-Length", Buffer.byteLength(doc));
			res.setHeader("Content-Security-Policy", "default-src 'none'");
			res.setHeader("X-Content-Type-Options", "nosniff");
			res.setHeader("Location", loc);
			res.end(doc);
		};
	}
	return serveStatic_1;
}
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var hasRequiredExpress$1;
function requireExpress$1() {
	if (hasRequiredExpress$1) return express$1.exports;
	hasRequiredExpress$1 = 1;
	(function(module$1, exports$1) {
		var bodyParser2 = requireBodyParser();
		var EventEmitter$1 = require$$1$5.EventEmitter;
		var mixin = /* @__PURE__ */ requireMergeDescriptors();
		var proto = requireApplication();
		var Router2 = requireRouter();
		var req = requireRequest();
		var res = requireResponse();
		exports$1 = module$1.exports = createApplication;
		function createApplication() {
			var app$3 = function(req2, res2, next) {
				app$3.handle(req2, res2, next);
			};
			mixin(app$3, EventEmitter$1.prototype, false);
			mixin(app$3, proto, false);
			app$3.request = Object.create(req, { app: {
				configurable: true,
				enumerable: true,
				writable: true,
				value: app$3
			} });
			app$3.response = Object.create(res, { app: {
				configurable: true,
				enumerable: true,
				writable: true,
				value: app$3
			} });
			app$3.init();
			return app$3;
		}
		exports$1.application = proto;
		exports$1.request = req;
		exports$1.response = res;
		exports$1.Route = Router2.Route;
		exports$1.Router = Router2;
		exports$1.json = bodyParser2.json;
		exports$1.raw = bodyParser2.raw;
		exports$1.static = requireServeStatic();
		exports$1.text = bodyParser2.text;
		exports$1.urlencoded = bodyParser2.urlencoded;
	})(express$1, express$1.exports);
	return express$1.exports;
}
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var express;
var hasRequiredExpress;
function requireExpress() {
	if (hasRequiredExpress) return express;
	hasRequiredExpress = 1;
	express = requireExpress$1();
	return express;
}
var expressExports = requireExpress();
const index = /* @__PURE__ */ _mergeNamespaces({
	__proto__: null,
	default: expressExports
}, [expressExports]);
const Route = expressExports.Route;
const Router = expressExports.Router;
const application$1 = expressExports.application;
const json = expressExports.json;
const raw = expressExports.raw;
const request$1 = expressExports.request;
const response$1 = expressExports.response;
const text = expressExports.text;
const urlencoded = expressExports.urlencoded;

//#endregion
//#region ../../node_modules/.pnpm/@karinjs+express@1.0.3/node_modules/@karinjs/express/dist/index.js
const app$1 = index.default;

//#endregion
//#region ../../node_modules/.pnpm/@ikenxuan+amagi@5.6.3/node_modules/@ikenxuan/amagi/dist/default/esm/index.mjs
/*!
* @ikenxuan/amagi
* Copyright(c) 2023 ikenxuan
* GPL-3.0 Licensed
*/
var getPackageLogsPath = () => {
	const currentFileUrl = import.meta.url;
	const currentFilePath = fileURLToPath(currentFileUrl);
	let packageRoot = path$1.dirname(currentFilePath);
	while (packageRoot !== path$1.dirname(packageRoot)) {
		if (fs.existsSync(path$1.join(packageRoot, "package.json"))) break;
		packageRoot = path$1.dirname(packageRoot);
	}
	return path$1.join(packageRoot, "logs");
};
var logsPath = getPackageLogsPath();
var getLogLevel = () => {
	return process.env.LOG_LEVEL || "info";
};
var currentLogLevel = getLogLevel();
log4js_default.configure({
	appenders: {
		console: {
			type: "stdout",
			layout: {
				type: "pattern",
				pattern: "%[[amagi][%d{hh:mm:ss.SSS}][%4.4p]%] %m"
			}
		},
		command: {
			type: "dateFile",
			filename: path$1.join(logsPath, "application", "command"),
			pattern: "yyyy-MM-dd.log",
			numBackups: 15,
			alwaysIncludePattern: true,
			layout: {
				type: "pattern",
				pattern: "[%d{hh:mm:ss.SSS}][%4.4p] %m"
			}
		},
		httpConsole: {
			type: "stdout",
			layout: {
				type: "pattern",
				pattern: "%[[amagi][%d{hh:mm:ss.SSS}][HTTP]%] %m"
			}
		},
		httpRequest: {
			type: "dateFile",
			filename: path$1.join(logsPath, "http", "requests"),
			pattern: "yyyy-MM-dd.log",
			numBackups: 30,
			alwaysIncludePattern: true,
			layout: {
				type: "pattern",
				pattern: "[%d{hh:mm:ss.SSS}][%4.4p] %m"
			}
		}
	},
	categories: {
		default: {
			appenders: ["console", "command"],
			level: currentLogLevel
		},
		http: {
			appenders: ["httpConsole", "httpRequest"],
			level: "debug"
		}
	},
	pm2: true
});
var CustomLogger = class {
	logger;
	chalk;
	red;
	green;
	yellow;
	blue;
	magenta;
	cyan;
	white;
	gray;
	constructor(name) {
		this.logger = log4js_default.getLogger(name);
		this.chalk = new Chalk();
		this.red = this.chalk.red;
		this.green = this.chalk.green;
		this.yellow = this.chalk.yellow;
		this.blue = this.chalk.blue;
		this.magenta = this.chalk.magenta;
		this.cyan = this.chalk.cyan;
		this.white = this.chalk.white;
		this.gray = this.chalk.gray;
	}
	info(message, ...args) {
		this.logger.info(message, ...args);
	}
	warn(message, ...args) {
		this.logger.warn(message, ...args);
	}
	error(message, ...args) {
		this.logger.error(message, ...args);
	}
	mark(message, ...args) {
		this.logger.mark(message, ...args);
	}
	debug(message, ...args) {
		this.logger.debug(message, ...args);
	}
};
var logger$1 = new CustomLogger("default");
var httpLogger = new CustomLogger("http");
var logMiddleware = (pathsToLog) => {
	return (req, res, next) => {
		if (!pathsToLog || pathsToLog.some((path2) => req.url.startsWith(path2))) {
			const startTime = Date.now();
			const url$1 = req.url;
			const method = req.method;
			const clientIP = req.headers["x-forwarded-for"] || req.socket.remoteAddress;
			const referer = req.headers["referer"] || req.headers["referrer"] || "-";
			const contentType$2 = req.headers["content-type"] || "-";
			const requestSize = req.headers["content-length"] || "0";
			const protocol = req.protocol;
			const httpVersion = req.httpVersion;
			res.on("finish", () => {
				const responseTime = Date.now() - startTime;
				const statusCode = res.statusCode;
				const responseSize = res.get("content-length") || "0";
				const logData = {
					method,
					url: url$1,
					statusCode,
					responseTime: `${responseTime}ms`,
					clientIP,
					referer,
					contentType: contentType$2,
					requestSize: `${requestSize}B`,
					responseSize: `${responseSize}B`,
					protocol,
					httpVersion,
					timestamp: (/* @__PURE__ */ new Date()).toISOString()
				};
				httpLogger.debug(JSON.stringify(logData));
			});
		}
		next();
	};
};
var cleanUserAgent = (userAgent) => {
	return userAgent.replace(/\s+Edg\/[\d\.]+/g, "");
};
var fetchData = async (config$2) => {
	try {
		const cleanedConfig = { ...config$2 };
		if (cleanedConfig.headers && cleanedConfig.headers["User-Agent"]) cleanedConfig.headers["User-Agent"] = cleanUserAgent(cleanedConfig.headers["User-Agent"]);
		return (await axios_default({
			...cleanedConfig,
			validateStatus: () => true
		})).data;
	} catch (error) {
		if (error instanceof AxiosError$1) {
			logger$1.error(":", error.message);
			throw error;
		}
		throw error;
	}
};
var normalizeHeaders = (headers) => {
	if (headers && typeof headers.toJSON === "function") return headers.toJSON();
	return headers || {};
};
var fetchResponse = async (config$2) => {
	try {
		const cleanedConfig = { ...config$2 };
		if (cleanedConfig.headers && cleanedConfig.headers["User-Agent"]) cleanedConfig.headers["User-Agent"] = cleanUserAgent(cleanedConfig.headers["User-Agent"]);
		return await axios_default({
			...cleanedConfig,
			validateStatus: () => true
		});
	} catch (error) {
		if (error instanceof AxiosError$1) throw error;
		throw new Error("");
	}
};
var getHeadersAndData = async (config$2) => {
	try {
		const response$2 = await fetchResponse(config$2);
		return {
			headers: normalizeHeaders(response$2.headers),
			data: response$2.data
		};
	} catch (error) {
		logger$1.error(":", error);
		return {
			headers: {},
			data: {}
		};
	}
};
var qtparam = async (BASEURL, cookie$1) => {
	if (cookie$1 === "") return {
		QUERY: "&platform=html5",
		STATUS: "!isLogin"
	};
	const logininfo = await fetchData({
		url: bilibiliApiUrls.(),
		headers: { Cookie: cookie$1 }
	});
	const sign$2 = await wbi_sign(BASEURL, cookie$1);
	const qn = [
		6,
		16,
		32,
		64,
		74,
		80,
		112,
		116,
		120,
		125,
		126,
		127
	];
	let isvip;
	logininfo.data.vipStatus === 1 ? isvip = true : isvip = false;
	if (isvip) return {
		QUERY: `&fnval=4048&fourk=1&${sign$2}`,
		STATUS: "isLogin",
		isvip
	};
	else return {
		QUERY: `&qn=${qn[3]}&fnval=16&${sign$2}`,
		STATUS: "isLogin",
		isvip
	};
};
var XOR_CODE = 23442827791579n;
var MASK_CODE = 2251799813685247n;
var MAX_AID = 1n << 51n;
var BASE = 58n;
var data = "FcwAPNKTMug3GV5Lj7EJnHpWsx4tb8haYeviqBz6rkCy12mUSDQX9RdoZf";
var av2bv = (aid) => {
	const bytes$1 = [
		"B",
		"V",
		"1",
		"0",
		"0",
		"0",
		"0",
		"0",
		"0",
		"0",
		"0",
		"0"
	];
	let bvIndex = bytes$1.length - 1;
	let tmp = (MAX_AID | BigInt(aid)) ^ XOR_CODE;
	while (tmp > 0) {
		bytes$1[bvIndex] = data[Number(tmp % BigInt(BASE))];
		tmp = tmp / BASE;
		bvIndex -= 1;
	}
	[bytes$1[3], bytes$1[9]] = [bytes$1[9], bytes$1[3]];
	[bytes$1[4], bytes$1[7]] = [bytes$1[7], bytes$1[4]];
	return bytes$1.join("");
};
var bv2av = (bvid) => {
	const bvidArr = Array.from(bvid);
	[bvidArr[3], bvidArr[9]] = [bvidArr[9], bvidArr[3]];
	[bvidArr[4], bvidArr[7]] = [bvidArr[7], bvidArr[4]];
	bvidArr.splice(0, 3);
	const tmp = bvidArr.reduce((pre, bvidChar) => pre * BASE + BigInt(data.indexOf(bvidChar)), 0n);
	return Number(tmp & MASK_CODE ^ XOR_CODE);
};
var BiLiBiLiAPI = class {
	() {
		return "https://api.bilibili.com/x/web-interface/nav";
	}
	(data2) {
		return `https://api.bilibili.com/x/web-interface/view?bvid=${data2.bvid}`;
	}
	(data2) {
		return `https://api.bilibili.com/x/player/playurl?avid=${data2.avid}&cid=${data2.cid}`;
	}
	/** type [](https://github.com/SocialSisterYi/bilibili-API-collect/blob/master/docs/comment/readme.md#) */
	(data2) {
		const params = new URLSearchParams({
			oid: data2.oid.toString(),
			type: data2.type.toString(),
			mode: (data2.mode ?? 3).toString(),
			plat: "1",
			seek_rpid: "",
			web_location: "1315875"
		});
		if (data2.pagination_str) params.append("pagination_str", JSON.stringify({ offset: data2.pagination_str }));
		else params.append("pagination_str", JSON.stringify({ offset: "" }));
		return `https://api.bilibili.com/x/v2/reply/wbi/main?${params.toString()}`;
	}
	(data2) {
		return `https://api.bilibili.com/x/v2/reply/subject/description?type=${data2.type}&oid=${data2.oid}`;
	}
	() {
		return "https://api.bilibili.com/x/emote/user/panel/web?business=reply&web_location=0.0";
	}
	(data2) {
		if (data2.ep_id) return `https://api.bilibili.com/pgc/view/web/season?ep_id=${data2.ep_id}`;
		else if (data2.season_id) return `https://api.bilibili.com/pgc/view/web/season?season_id=${data2.season_id}`;
		else throw new Error(" ep_id  season_id ");
	}
	(data2) {
		return `https://api.bilibili.com/pgc/player/web/playurl?cid=${data2.cid}&ep_id=${data2.ep_id}`;
	}
	(data2) {
		return `https://api.bilibili.com/x/polymer/web-dynamic/v1/feed/space?host_mid=${data2.host_mid}&features=itemOpusStyle,listOnlyfans,opusBigCover,onlyfansVote,forwardListHidden,decorationCard,commentsNewVersion,onlyfansAssetsV2,ugcDelete,onlyfansQaCard`;
	}
	(data2) {
		return `https://api.bilibili.com/x/polymer/web-dynamic/v1/detail?id=${data2.dynamic_id}&features=itemOpusStyle,opusBigCover,onlyfansVote,endFooterHidden,decorationCard,onlyfansAssetsV2,ugcDelete,onlyfansQaCard,editable,opusPrivateVisible,avatarAutoTheme`;
	}
	(data2) {
		return `https://api.vc.bilibili.com/dynamic_svr/v1/dynamic_svr/get_dynamic_detail?dynamic_id=${data2.dynamic_id}`;
	}
	(data2) {
		return `https://api.bilibili.com/x/web-interface/card?mid=${data2.host_mid}&photo=true`;
	}
	(data2) {
		return `https://api.live.bilibili.com/room/v1/Room/get_info?room_id=${data2.room_id}`;
	}
	(data2) {
		return `https://api.live.bilibili.com/room/v1/Room/room_init?id=${data2.room_id}`;
	}
	() {
		return "https://passport.bilibili.com/x/passport-login/web/qrcode/generate";
	}
	(data2) {
		return `https://passport.bilibili.com/x/passport-login/web/qrcode/poll?qrcode_key=${data2.qrcode_key}`;
	}
	UP(data2) {
		return `https://api.bilibili.com/x/space/upstat?mid=${data2.host_mid}`;
	}
};
var bilibiliApiUrls = new BiLiBiLiAPI();
var kuaishouAPIErrorCode = /* @__PURE__ */ ((kuaishouAPIErrorCode2) => {
	kuaishouAPIErrorCode2["COOKIE"] = "INVALID_COOKIE";
	kuaishouAPIErrorCode2["UNKNOWN"] = "UNKNOWN_ERROR";
	return kuaishouAPIErrorCode2;
})(kuaishouAPIErrorCode || {});
var xiaohongshuAPIErrorCode = /* @__PURE__ */ ((xiaohongshuAPIErrorCode2) => {
	xiaohongshuAPIErrorCode2["COOKIE"] = "INVALID_COOKIE";
	xiaohongshuAPIErrorCode2["UNKNOWN"] = "UNKNOWN_ERROR";
	xiaohongshuAPIErrorCode2[xiaohongshuAPIErrorCode2["ILLEGAL_REQUEST"] = 500] = "ILLEGAL_REQUEST";
	xiaohongshuAPIErrorCode2[xiaohongshuAPIErrorCode2["ACCOUNT_ABNORMAL"] = 300011] = "ACCOUNT_ABNORMAL";
	xiaohongshuAPIErrorCode2[xiaohongshuAPIErrorCode2["NETWORK_ERROR"] = 300012] = "NETWORK_ERROR";
	xiaohongshuAPIErrorCode2[xiaohongshuAPIErrorCode2["FREQUENCY_ERROR"] = 300013] = "FREQUENCY_ERROR";
	xiaohongshuAPIErrorCode2[xiaohongshuAPIErrorCode2["BROWSER_ERROR"] = 300015] = "BROWSER_ERROR";
	return xiaohongshuAPIErrorCode2;
})(xiaohongshuAPIErrorCode || {});
var mixinKeyEncTab = [
	46,
	47,
	18,
	2,
	53,
	8,
	23,
	32,
	15,
	50,
	10,
	31,
	58,
	3,
	45,
	35,
	27,
	43,
	5,
	49,
	33,
	9,
	42,
	19,
	29,
	28,
	14,
	39,
	12,
	38,
	41,
	13,
	37,
	48,
	7,
	16,
	24,
	55,
	40,
	61,
	26,
	17,
	0,
	1,
	60,
	51,
	30,
	4,
	22,
	25,
	54,
	21,
	56,
	59,
	6,
	63,
	57,
	62,
	11,
	36,
	20,
	34,
	44,
	52
];
var getMixinKey = (orig) => mixinKeyEncTab.map((n) => orig[n]).join("").slice(0, 32);
var encWbi = (params, img_key, sub_key) => {
	const mixin_key = getMixinKey(img_key + sub_key);
	const curr_time = Math.round(Date.now() / 1e3);
	const chr_filter = /[!'()*]/g;
	Object.assign(params, { wts: curr_time });
	const query = Object.keys(params).sort().map((key) => {
		const value = params[key].toString().replace(chr_filter, "");
		return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
	}).join("&");
	return `&wts=${curr_time}&w_rid=${crypto.createHash("md5").update(query + mixin_key).digest("hex")}`;
};
var getWbiKeys = async (cookie$1) => {
	const { data: { wbi_img: { img_url, sub_url } } } = (await axios_default("https://api.bilibili.com/x/web-interface/nav", { headers: { Cookie: cookie$1 } })).data;
	return {
		img_key: img_url.slice(img_url.lastIndexOf("/") + 1, img_url.lastIndexOf(".")),
		sub_key: sub_url.slice(sub_url.lastIndexOf("/") + 1, sub_url.lastIndexOf("."))
	};
};
var wbi_sign = async (BASEURL, cookie$1) => {
	const web_keys = await getWbiKeys(cookie$1);
	const url$1 = new URL(BASEURL);
	const params = {};
	for (const [key, value] of url$1.searchParams.entries()) params[key] = value;
	return encWbi(params, web_keys.img_key, web_keys.sub_key);
};
var generateSecChUa = (userAgent) => {
	const chromeMatch = userAgent.match(/Chrome\/(\d+)/);
	const chromeVersion = chromeMatch ? chromeMatch[1] : "125";
	return `"Not)A;Brand";v="8", "Chromium";v="${chromeVersion}", "Google Chrome";v="${chromeVersion}"`;
};
var getDouyinDefaultConfig = (cookie$1, requestConfig) => {
	var _a;
	let finalUserAgent = ((_a = void 0) == null ? void 0 : _a["User-Agent"]) || "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36";
	finalUserAgent = finalUserAgent.replace(/\s+Edg\/[\d\.]+/g, "");
	const defHeaders = {
		Accept: "application/json, text/plain, */*",
		"Accept-Encoding": "gzip, deflate, br, zstd",
		"Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6",
		Cookie: cookie$1 ? cookie$1.replace(/\s+/g, "") : "",
		Priority: "u=1, i",
		Referer: "https://www.douyin.com/",
		"Sec-Ch-Ua": generateSecChUa(finalUserAgent),
		"Sec-Ch-Ua-Mobile": "?0",
		"Sec-Ch-Ua-Platform": "\"Windows\"",
		"Sec-Fetch-Dest": "empty",
		"Sec-Fetch-Mode": "cors",
		"Sec-Fetch-Site": "same-origin",
		"User-Agent": finalUserAgent
	};
	return {
		method: "GET",
		timeout: 1e4,
		...requestConfig,
		headers: { ...defHeaders }
	};
};
var getBilibiliDefaultConfig = (cookie$1, requestConfig) => {
	const defHeaders = {
		Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
		"Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6",
		"Cache-Control": "max-age=0",
		Priority: "u=0, i",
		"Sec-Ch-Ua": "\"Microsoft Edge\";v=\"131\", \"Chromium\";v=\"131\", \"Not_A Brand\";v=\"24\"",
		"Sec-Ch-Ua-Mobile": "?0",
		"Sec-Ch-Ua-Platform": "\"Windows\"",
		"Sec-Fetch-Dest": "document",
		"Sec-Fetch-Mode": "navigate",
		"Sec-Fetch-Site": "none",
		"Sec-Fetch-User": "?1",
		"Upgrade-Insecure-Requests": "1",
		Referer: "https://www.bilibili.com/",
		Cookie: cookie$1 ? cookie$1.replace(/\s+/g, "") : ""
	};
	return {
		method: "GET",
		timeout: 1e4,
		...requestConfig,
		headers: { ...defHeaders }
	};
};
var getKuaishouDefaultConfig = (cookie$1, requestConfig) => {
	const defHeaders = {
		Referer: "https://www.kuaishou.com/new-reco",
		Origin: "https://www.kuaishou.com",
		Accept: "application/json, text/plain, */*",
		"Accept-Encoding": "gzip, deflate, br, zstd",
		"Content-Type": "application/json",
		"Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6",
		Priority: "u=0, i",
		"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0",
		Cookie: cookie$1 ? cookie$1.replace(/\s+/g, "") : ""
	};
	return {
		method: "POST",
		timeout: 1e4,
		...requestConfig,
		headers: { ...defHeaders }
	};
};
var getXiaohongshuDefaultConfig = (cookie$1) => {
	return { headers: {
		"accept": "application/json, text/plain, */*",
		"accept-language": "zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6",
		"cache-control": "no-cache",
		"content-type": "application/json;charset=UTF-8",
		"pragma": "no-cache",
		"priority": "u=1, i",
		"referer": "https://www.xiaohongshu.com/",
		"sec-ch-ua": "\"Microsoft Edge\";v=\"141\", \"Not?A_Brand\";v=\"8\", \"Chromium\";v=\"141\"",
		"sec-ch-ua-mobile": "?0",
		"sec-ch-ua-platform": "\"Windows\"",
		"sec-fetch-dest": "empty",
		"sec-fetch-mode": "cors",
		"sec-fetch-site": "same-site",
		"user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36 Edg/141.0.0.0",
		"cookie": cookie$1 || ""
	} };
};
var fetchBilibili = async (data2, cookie$1, requestConfig) => {
	var _a, _b, _c, _d, _e, _f;
	const defHeaders = getBilibiliDefaultConfig(cookie$1)["headers"];
	const baseRequestConfig = {
		method: "GET",
		timeout: 1e4,
		...requestConfig,
		headers: { ...defHeaders }
	};
	switch (data2.methodType) {
		case "": return await GlobalGetData(data2.methodType, {
			...baseRequestConfig,
			url: bilibiliApiUrls.({ bvid: data2.bvid })
		});
		case "": {
			const SIGN = await qtparam(bilibiliApiUrls.({
				avid: data2.avid,
				cid: data2.cid
			}), (_a = baseRequestConfig.headers) == null ? void 0 : _a.Cookie);
			return await GlobalGetData(data2.methodType, {
				...baseRequestConfig,
				url: bilibiliApiUrls.({
					avid: data2.avid,
					cid: data2.cid
				}) + SIGN.QUERY
			});
		}
		case "": {
			let { oid: oid$1, number: number$3, type: type$1, mode, pagination_str, plat, seek_rpid, web_location } = data2;
			let fetchedComments = [];
			const maxRequestCount = 100;
			let requestCount = 0;
			let tmpresp;
			let nextPaginationStr = pagination_str;
			let isEnd = false;
			const checkStatusUrl = bilibiliApiUrls.({
				oid: oid$1,
				type: type$1
			});
			if ((await GlobalGetData(data2.methodType, {
				...baseRequestConfig,
				url: checkStatusUrl
			})).data === null) {
				logger$1.error("");
				return {
					code: 404,
					message: "",
					data: null
				};
			}
			while (fetchedComments.length < Number(number$3 ?? 20) && requestCount < maxRequestCount && !isEnd) {
				const baseUrl = bilibiliApiUrls.({
					type: type$1,
					oid: oid$1,
					mode: mode ?? 3,
					pagination_str: nextPaginationStr,
					plat: plat ?? 1,
					seek_rpid,
					web_location: web_location ?? "1315875"
				});
				const finalUrl = baseUrl + await wbi_sign(baseUrl, (_b = baseRequestConfig.headers) == null ? void 0 : _b.cookie);
				const response$2 = await GlobalGetData(data2.methodType, {
					...baseRequestConfig,
					url: finalUrl
				});
				tmpresp = response$2;
				const currentComments = ((_c = response$2.data) == null ? void 0 : _c.replies) || [];
				fetchedComments.push(...currentComments);
				if ((_d = response$2.data) == null ? void 0 : _d.cursor) {
					nextPaginationStr = (_e = response$2.data.cursor.pagination_reply) == null ? void 0 : _e.next_offset;
					isEnd = response$2.data.cursor.is_end;
				} else isEnd = true;
				requestCount++;
				if (isEnd || currentComments.length === 0 || !nextPaginationStr) {
					logger$1.info("");
					break;
				}
			}
			return {
				...tmpresp,
				data: {
					...tmpresp.data,
					replies: Array.from(new Map(fetchedComments.map((item) => [item.rpid, item])).values()).slice(0, Number(data2.number || 20))
				}
			};
		}
		case "Emoji": return await GlobalGetData(data2.methodType, {
			...baseRequestConfig,
			url: bilibiliApiUrls.()
		});
		case "": {
			let id = data2.ep_id ? data2.ep_id : data2.season_id;
			if (!id) return false;
			const idType = id ? id.startsWith("ep") ? "ep_id" : "season_id" : "ep_id";
			const newId = idType === "ep_id" ? id.replace("ep", "") : id.replace("ss", "");
			return await GlobalGetData(data2.methodType, {
				...baseRequestConfig,
				url: bilibiliApiUrls.({ [idType]: newId })
			});
		}
		case "": {
			const SIGN = await qtparam(bilibiliApiUrls.({
				cid: data2.cid,
				ep_id: data2.ep_id.replace("ep", "")
			}), (_f = baseRequestConfig.headers) == null ? void 0 : _f.cookie);
			return await GlobalGetData(data2.methodType, {
				...baseRequestConfig,
				url: bilibiliApiUrls.({
					cid: data2.cid,
					ep_id: data2.ep_id.replace("ep", "")
				}) + SIGN.QUERY
			});
		}
		case "": {
			const customConfig = {
				...baseRequestConfig,
				headers: {
					...baseRequestConfig.headers,
					referer: void 0
				}
			};
			const { host_mid } = data2;
			return await GlobalGetData(data2.methodType, {
				...customConfig,
				url: bilibiliApiUrls.({ host_mid })
			});
		}
		case "": {
			const customConfig = {
				...baseRequestConfig,
				headers: {
					...baseRequestConfig.headers,
					referer: void 0
				}
			};
			return await GlobalGetData(data2.methodType, {
				...customConfig,
				url: bilibiliApiUrls.({ dynamic_id: data2.dynamic_id })
			});
		}
		case "": {
			const customConfig = {
				...baseRequestConfig,
				headers: {
					...baseRequestConfig.headers,
					referer: void 0
				}
			};
			const { dynamic_id } = data2;
			return await GlobalGetData(data2.methodType, {
				...customConfig,
				url: bilibiliApiUrls.({ dynamic_id })
			});
		}
		case "": {
			const { host_mid } = data2;
			return await GlobalGetData(data2.methodType, {
				...baseRequestConfig,
				url: bilibiliApiUrls.({ host_mid })
			});
		}
		case "": return await GlobalGetData(data2.methodType, {
			...baseRequestConfig,
			url: bilibiliApiUrls.({ room_id: data2.room_id })
		});
		case "": return await GlobalGetData(data2.methodType, {
			...baseRequestConfig,
			url: bilibiliApiUrls.({ room_id: data2.room_id })
		});
		case "": return await GlobalGetData(data2.methodType, {
			...baseRequestConfig,
			url: bilibiliApiUrls.()
		});
		case "": try {
			const result = await getHeadersAndData({
				...baseRequestConfig,
				url: bilibiliApiUrls.({ qrcode_key: data2.qrcode_key })
			});
			if (result.data.code !== 0) {
				const Err = {
					errorDescription: `\u83B7\u53D6\u54CD\u5E94\u6570\u636E\u5931\u8D25\uFF01\u539F\u56E0\uFF1A${bilibiliErrorCodeMap[String(result.data.code)] || result.data.message || ""}\uFF01`,
					requestType: data2.methodType,
					requestUrl: bilibiliApiUrls.({ qrcode_key: data2.qrcode_key })
				};
				return {
					code: result.data.code,
					data: result.data,
					amagiError: Err
				};
			}
			return {
				code: 0,
				data: {
					data: result.data.data,
					headers: result.headers
				},
				message: "0"
			};
		} catch (error) {
			if (error && typeof error === "object") return error;
			return {
				code: "UNKNOWN_ERROR",
				data: error.data,
				amagiError: {
					errorDescription: "",
					requestType: data2.methodType,
					requestUrl: bilibiliApiUrls.({ qrcode_key: data2.qrcode_key })
				}
			};
		}
		case "": return await GlobalGetData(data2.methodType, {
			...baseRequestConfig,
			url: bilibiliApiUrls.()
		});
		case "UP": return await GlobalGetData(data2.methodType, {
			...baseRequestConfig,
			url: bilibiliApiUrls.UP({ host_mid: data2.host_mid })
		});
		case "AVBV": return {
			code: 0,
			message: "success",
			data: { bvid: av2bv(Number(data2.avid.toString().replace(/^av/i, ""))) }
		};
		case "BVAV": return {
			code: 0,
			message: "success",
			data: { aid: "av" + bv2av(data2.bvid) }
		};
		default:
			logger$1.warn(`\u672A\u77E5\u7684B\u7AD9\u6570\u636E\u63A5\u53E3\uFF1A\u300C${logger$1.red(data2.methodType)}\u300D`);
			return null;
	}
};
var GlobalGetData = async (type$1, options) => {
	let warningMessage = "";
	try {
		const result = await fetchData(options);
		if (!result || result === "") {
			const Err = {
				errorDescription: "Bck",
				requestType: type$1 ?? "",
				requestUrl: options.url
			};
			warningMessage = `
      \u83B7\u53D6\u54CD\u5E94\u6570\u636E\u5931\u8D25\uFF01\u539F\u56E0\uFF1A${logger$1.yellow("Bck")}
      \u8BF7\u6C42\u7C7B\u578B\uFF1A\u300C${type$1}\u300D
      \u8BF7\u6C42URL\uFF1A${options.url}
      `;
			logger$1.warn(warningMessage);
			throw {
				code: "-352",
				data: result,
				amagiError: Err
			};
		}
		if (result.code !== 0) {
			const errorMessage = bilibiliErrorCodeMap[result.code] || result.message || "";
			const Err = {
				errorDescription: `\u83B7\u53D6\u54CD\u5E94\u6570\u636E\u5931\u8D25\uFF01\u539F\u56E0\uFF1A${errorMessage}\uFF01`,
				requestType: type$1 ?? "",
				requestUrl: options.url
			};
			warningMessage = `
      \u83B7\u53D6\u54CD\u5E94\u6570\u636E\u5931\u8D25\uFF01\u539F\u56E0\uFF1A${logger$1.yellow(errorMessage)}
      \u9519\u8BEF\u4EE3\u7801\uFF1A${result.code}
      \u8BF7\u6C42\u7C7B\u578B\uFF1A\u300C${type$1}\u300D
      \u8BF7\u6C42URL\uFF1A${options.url}
      `;
			logger$1.warn(warningMessage);
			throw {
				code: result.code,
				data: result,
				amagiError: Err
			};
		}
		return result;
	} catch (error) {
		if (error && typeof error === "object") return {
			...error,
			amagiMessage: warningMessage
		};
		return {
			code: "UNKNOWN_ERROR",
			data: error.data,
			amagiError: {
				errorDescription: "",
				requestType: type$1,
				requestUrl: options.url
			},
			amagiMessage: warningMessage
		};
	}
};
var bilibiliErrorCodeMap = {
	"-1": "",
	"-2": "Access Key ",
	"-3": "API ",
	"-4": " Method ",
	"-101": "",
	"-102": "",
	"-103": "",
	"-104": "",
	"-105": "",
	"-106": "",
	"-107": "",
	"-108": "",
	"-110": "",
	"-111": "csrf ",
	"-112": "",
	"-113": "",
	"-114": "",
	"-115": "",
	"-304": "",
	"-307": "",
	"-352": " (UA  wbi )",
	"-400": "",
	"-401": " ()",
	"-403": "",
	"-404": "",
	"-405": "",
	"-409": "",
	"-412": " ( ip )",
	"-500": "",
	"-503": ",",
	"-504": "",
	"-509": "",
	"-616": "",
	"-617": "",
	"-625": "",
	"-626": "",
	"-628": "",
	"-629": "",
	"-632": "",
	"-643": "",
	"-650": "",
	"-652": "",
	"-658": "Token ",
	"-662": "",
	"-688": "",
	"-689": "",
	"-701": "",
	"-799": "",
	"-8888": "~ ()"
};
var SM3 = class {
	reg;
	chunk;
	size;
	constructor() {
		this.reg = [];
		this.chunk = [];
		this.size = 0;
		this.reset();
	}
	reset() {
		this.reg[0] = 1937774191;
		this.reg[1] = 1226093241;
		this.reg[2] = 388252375;
		this.reg[3] = 3666478592;
		this.reg[4] = 2842636476;
		this.reg[5] = 372324522;
		this.reg[6] = 3817729613;
		this.reg[7] = 2969243214;
		this.chunk = [];
		this.size = 0;
	}
	write(e) {
		const a = typeof e === "string" ? this.stringToBytes(e) : e;
		this.size += a.length;
		let f = 64 - this.chunk.length;
		if (a.length < f) this.chunk = this.chunk.concat(a);
		else {
			this.chunk = this.chunk.concat(a.slice(0, f));
			while (this.chunk.length >= 64) {
				this._compress(this.chunk);
				f < a.length ? this.chunk = a.slice(f, Math.min(f + 64, a.length)) : this.chunk = [];
				f += 64;
			}
		}
	}
	sum(e, t) {
		if (e) {
			this.reset();
			this.write(e);
		}
		this._fill();
		for (let f = 0; f < this.chunk.length; f += 64) this._compress(this.chunk.slice(f, f + 64));
		let i = null;
		if (t === "hex") {
			i = "";
			for (let f = 0; f < 8; f++) i += this.padHex(this.reg[f].toString(16), 8);
		} else {
			i = new Array(32);
			for (let f = 0; f < 8; f++) {
				let c = this.reg[f];
				i[4 * f + 3] = (255 & c) >>> 0;
				c >>>= 8;
				i[4 * f + 2] = (255 & c) >>> 0;
				c >>>= 8;
				i[4 * f + 1] = (255 & c) >>> 0;
				c >>>= 8;
				i[4 * f] = (255 & c) >>> 0;
			}
		}
		this.reset();
		return i;
	}
	_compress(t) {
		if (t.length < 64) console.error("compress error: not enough data");
		else {
			for (var f = ((e) => {
				for (var r = new Array(132), t2 = 0; t2 < 16; t2++) r[t2] = e[4 * t2] << 24, r[t2] |= e[4 * t2 + 1] << 16, r[t2] |= e[4 * t2 + 2] << 8, r[t2] |= e[4 * t2 + 3], r[t2] >>>= 0;
				for (var n = 16; n < 68; n++) {
					let a = r[n - 16] ^ r[n - 9] ^ this.le(r[n - 3], 15);
					a = a ^ this.le(a, 15) ^ this.le(a, 23), r[n] = (a ^ this.le(r[n - 13], 7) ^ r[n - 6]) >>> 0;
				}
				for (n = 0; n < 64; n++) r[n + 68] = (r[n] ^ r[n + 4]) >>> 0;
				return r;
			})(t), i = this.reg.slice(0), c = 0; c < 64; c++) {
				let o = this.le(i[0], 12) + i[4] + this.le(this.de(c), c);
				const s$1 = ((o = this.le(o = (4294967295 & o) >>> 0, 7)) ^ this.le(i[0], 12)) >>> 0;
				let u = this.pe(c, i[0], i[1], i[2]);
				u = (4294967295 & (u = u + i[3] + s$1 + f[c + 68])) >>> 0;
				let b = this.he(c, i[4], i[5], i[6]);
				b = (4294967295 & (b = b + i[7] + o + f[c])) >>> 0, i[3] = i[2], i[2] = this.le(i[1], 9), i[1] = i[0], i[0] = u, i[7] = i[6], i[6] = this.le(i[5], 19), i[5] = i[4], i[4] = (b ^ this.le(b, 9) ^ this.le(b, 17)) >>> 0;
			}
			for (let l = 0; l < 8; l++) this.reg[l] = (this.reg[l] ^ i[l]) >>> 0;
		}
	}
	_fill() {
		let a = 8 * this.size;
		let f = this.chunk.push(128) % 64;
		while (64 - f < 8) f -= 64;
		while (f < 56) {
			this.chunk.push(0);
			f++;
		}
		for (let i = 0; i < 4; i++) {
			const c = Math.floor(a / 4294967296);
			this.chunk.push(c >>> 8 * (3 - i) & 255);
		}
		for (let i = 0; i < 4; i++) this.chunk.push(a >>> 8 * (3 - i) & 255);
	}
	de(e) {
		return e >= 0 && e < 16 ? 2043430169 : e >= 16 && e < 64 ? 2055708042 : (console.error("invalid j for constant Tj"), 0);
	}
	pe(e, r, t, n) {
		return e >= 0 && e < 16 ? (r ^ t ^ n) >>> 0 : e >= 16 && e < 64 ? (r & t | r & n | t & n) >>> 0 : (console.error("invalid j for bool function FF"), 0);
	}
	he(e, r, t, n) {
		return e >= 0 && e < 16 ? (r ^ t ^ n) >>> 0 : e >= 16 && e < 64 ? (r & t | ~r & n) >>> 0 : (console.error("invalid j for bool function GG"), 0);
	}
	le(e, r) {
		return (e << (r %= 32) | e >>> 32 - r) >>> 0;
	}
	stringToBytes(str) {
		const n = encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (_, r) => String.fromCharCode(parseInt(r, 16)));
		const a = new Array(n.length);
		for (let i = 0; i < n.length; i++) a[i] = n.charCodeAt(i);
		return a;
	}
	padHex(num, size) {
		return num.padStart(size, "0");
	}
};
function rc4_encrypt(plaintext, key) {
	const s$1 = [];
	for (var i = 0; i < 256; i++) s$1[i] = i;
	var j = 0;
	for (var i = 0; i < 256; i++) {
		j = (j + s$1[i] + key.charCodeAt(i % key.length)) % 256;
		var temp = s$1[i];
		s$1[i] = s$1[j];
		s$1[j] = temp;
	}
	var i = 0;
	var j = 0;
	const cipher = [];
	for (let k = 0; k < plaintext.length; k++) {
		i = (i + 1) % 256;
		j = (j + s$1[i]) % 256;
		var temp = s$1[i];
		s$1[i] = s$1[j];
		s$1[j] = temp;
		const t = (s$1[i] + s$1[j]) % 256;
		cipher.push(String.fromCharCode(s$1[t] ^ plaintext.charCodeAt(k)));
	}
	return cipher.join("");
}
function result_encrypt(long_str, num) {
	const s_obj = {
		s0: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
		s1: "Dkdpgh4ZKsQB80/Mfvw36XI1R25+WUAlEi7NLboqYTOPuzmFjJnryx9HVGcaStCe=",
		s2: "Dkdpgh4ZKsQB80/Mfvw36XI1R25-WUAlEi7NLboqYTOPuzmFjJnryx9HVGcaStCe=",
		s3: "ckdp1h4ZKsUB80/Mfvw36XIgR25+WQAlEi7NLboqYTOPuzmFjJnryx9HVGDaStCe",
		s4: "Dkdpgh2ZmsQB80/MfvV36XI1R45-WUAlEixNLwoqYTOPuzKFjJnry79HbGcaStCe"
	};
	const constant = {
		0: 16515072,
		1: 258048,
		2: 4032,
		str: s_obj[num]
	};
	let result = "";
	let lound = 0;
	let long_int = get_long_int(lound, long_str);
	for (let i = 0; i < long_str.length / 3 * 4; i++) {
		if (Math.floor(i / 4) !== lound) {
			lound += 1;
			long_int = get_long_int(lound, long_str);
		}
		let key = i % 4;
		let temp_int;
		switch (key) {
			case 0:
				temp_int = (long_int & constant["0"]) >> 18;
				result += constant["str"].charAt(temp_int);
				break;
			case 1:
				temp_int = (long_int & constant["1"]) >> 12;
				result += constant["str"].charAt(temp_int);
				break;
			case 2:
				temp_int = (long_int & constant["2"]) >> 6;
				result += constant["str"].charAt(temp_int);
				break;
			case 3:
				temp_int = long_int & 63;
				result += constant["str"].charAt(temp_int);
				break;
		}
	}
	return result;
}
function get_long_int(round$2, long_str) {
	round$2 = round$2 * 3;
	return long_str.charCodeAt(round$2) << 16 | long_str.charCodeAt(round$2 + 1) << 8 | long_str.charCodeAt(round$2 + 2);
}
function gener_random(random, option) {
	return [
		random & 170 | option[0] & 85,
		random & 85 | option[0] & 170,
		random >> 8 & 170 | option[1] & 85,
		random >> 8 & 85 | option[1] & 170
	];
}
function generate_rc4_bb_str(url_search_params, user_agent, window_env_str, suffix = "cus", Arguments = [
	0,
	1,
	14
]) {
	let sm3 = new SM3();
	let start_time = Date.now();
	const url_search_params_list = sm3.sum(sm3.sum(url_search_params + suffix));
	const cus = sm3.sum(sm3.sum(suffix));
	const ua = sm3.sum(result_encrypt(rc4_encrypt(user_agent, String.fromCharCode.apply(null, [
		.00390625,
		1,
		14
	])), "s3"));
	const end_time = Date.now();
	let b = {
		8: 3,
		10: end_time,
		15: {
			aid: 6383,
			pageId: 6241
		},
		16: start_time,
		18: 44
	};
	b[20] = b[16] >> 24 & 255;
	b[21] = b[16] >> 16 & 255;
	b[22] = b[16] >> 8 & 255;
	b[23] = b[16] & 255;
	b[24] = b[16] / 256 / 256 / 256 / 256 >> 0;
	b[25] = b[16] / 256 / 256 / 256 / 256 / 256 >> 0;
	b[26] = Arguments[0] >> 24 & 255;
	b[27] = Arguments[0] >> 16 & 255;
	b[28] = Arguments[0] >> 8 & 255;
	b[29] = Arguments[0] & 255;
	b[30] = Arguments[1] / 256 & 255;
	b[31] = Arguments[1] % 256 & 255;
	b[32] = Arguments[1] >> 24 & 255;
	b[33] = Arguments[1] >> 16 & 255;
	b[34] = Arguments[2] >> 24 & 255;
	b[35] = Arguments[2] >> 16 & 255;
	b[36] = Arguments[2] >> 8 & 255;
	b[37] = Arguments[2] & 255;
	b[38] = url_search_params_list[21];
	b[39] = url_search_params_list[22];
	b[40] = cus[21];
	b[41] = cus[22];
	b[42] = ua[23];
	b[43] = ua[24];
	b[44] = b[10] >> 24 & 255;
	b[45] = b[10] >> 16 & 255;
	b[46] = b[10] >> 8 & 255;
	b[47] = b[10] & 255;
	b[48] = b[8];
	b[49] = b[10] / 256 / 256 / 256 / 256 >> 0;
	b[50] = b[10] / 256 / 256 / 256 / 256 / 256 >> 0;
	b[51] = b[15].pageId;
	b[52] = b[15].pageId >> 24 & 255;
	b[53] = b[15].pageId >> 16 & 255;
	b[54] = b[15].pageId >> 8 & 255;
	b[55] = b[15].pageId & 255;
	b[56] = b[15].aid;
	b[57] = b[15].aid & 255;
	b[58] = b[15].aid >> 8 & 255;
	b[59] = b[15].aid >> 16 & 255;
	b[60] = b[15].aid >> 24 & 255;
	const window_env_list = [];
	for (let index$1 = 0; index$1 < window_env_str.length; index$1++) window_env_list.push(window_env_str.charCodeAt(index$1));
	b[64] = window_env_list.length;
	b[65] = b[64] & 255;
	b[66] = b[64] >> 8 & 255;
	b[69] = 0;
	b[70] = b[69] & 255;
	b[71] = b[69] >> 8 & 255;
	b[72] = b[18] ^ b[20] ^ b[26] ^ b[30] ^ b[38] ^ b[40] ^ b[42] ^ b[21] ^ b[27] ^ b[31] ^ b[35] ^ b[39] ^ b[41] ^ b[43] ^ b[22] ^ b[28] ^ b[32] ^ b[36] ^ b[23] ^ b[29] ^ b[33] ^ b[37] ^ b[44] ^ b[45] ^ b[46] ^ b[47] ^ b[48] ^ b[49] ^ b[50] ^ b[24] ^ b[25] ^ b[52] ^ b[53] ^ b[54] ^ b[55] ^ b[57] ^ b[58] ^ b[59] ^ b[60] ^ b[65] ^ b[66] ^ b[70] ^ b[71];
	let bb = [
		b[18],
		b[20],
		b[52],
		b[26],
		b[30],
		b[34],
		b[58],
		b[38],
		b[40],
		b[53],
		b[42],
		b[21],
		b[27],
		b[54],
		b[55],
		b[31],
		b[35],
		b[57],
		b[39],
		b[41],
		b[43],
		b[22],
		b[28],
		b[32],
		b[60],
		b[36],
		b[23],
		b[29],
		b[33],
		b[37],
		b[44],
		b[45],
		b[59],
		b[46],
		b[47],
		b[48],
		b[49],
		b[50],
		b[24],
		b[25],
		b[65],
		b[66],
		b[70],
		b[71]
	];
	bb = bb.concat(window_env_list).concat(b[72]);
	return rc4_encrypt(String.fromCharCode.apply(null, bb), String.fromCharCode.apply(null, [121]));
}
function generate_random_str() {
	let random_str_list = [];
	random_str_list = random_str_list.concat(gener_random(Math.random() * 1e4, [3, 45]));
	random_str_list = random_str_list.concat(gener_random(Math.random() * 1e4, [1, 0]));
	random_str_list = random_str_list.concat(gener_random(Math.random() * 1e4, [1, 5]));
	return String.fromCharCode.apply(null, random_str_list);
}
var cleanUserAgentForSigning = (userAgent) => {
	return userAgent.replace(/\s+Edg\/[\d\.]+/g, "");
};
var a_bogus_default = (url$1, user_agent) => {
	const cleanedUserAgent = cleanUserAgentForSigning(user_agent);
	return result_encrypt(generate_random_str() + generate_rc4_bb_str(new URLSearchParams(new URL(url$1).search).toString(), cleanedUserAgent, "1536|747|1536|834|0|30|0|0|1536|834|1536|864|1525|747|24|24|Win32"), "s4") + "=";
};
var XBogus = class {
	charMap;
	base64Charset;
	uaKey;
	defaultUa;
	params;
	xb;
	constructor() {
		this.charMap = new Array(128).fill(null);
		for (let i = 48; i <= 57; i++) this.charMap[i] = i - 48;
		for (let i = 65; i <= 70; i++) this.charMap[i] = i - 55;
		for (let i = 97; i <= 102; i++) this.charMap[i] = i - 87;
		this.base64Charset = "Dkdpgh4ZKsQB80/Mfvw36XI1R25-WUAlEi7NLboqYTOPuzmFjJnryx9HVGcaStCe=";
		this.uaKey = Buffer.from([
			0,
			1,
			12
		]);
		this.defaultUa = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36 Edg/122.0.0.0";
	}
	md5StrToArray(md5Str) {
		const result = [];
		if (md5Str.length > 32) {
			for (const char of md5Str) result.push(char.charCodeAt(0));
			return result;
		}
		let idx = 0;
		while (idx < md5Str.length) {
			const leftCharCode = md5Str.charCodeAt(idx);
			const rightCharCode = md5Str.charCodeAt(idx + 1);
			const left = this.charMap[leftCharCode];
			const right = this.charMap[rightCharCode];
			if (left === null || right === null) throw new Error(`Invalid MD5 character: ${md5Str[idx]}${md5Str[idx + 1]}`);
			result.push(left << 4 | right);
			idx += 2;
		}
		return result;
	}
	md5(input) {
		const dataArray = typeof input === "string" ? this.md5StrToArray(input) : input;
		const dataBuffer = Buffer.from(dataArray);
		return crypto.createHash("md5").update(dataBuffer).digest("hex");
	}
	md5Encrypt(urlPath) {
		const firstMd5 = this.md5(urlPath);
		const firstArray = this.md5StrToArray(firstMd5);
		const secondMd5 = this.md5(firstArray);
		return this.md5StrToArray(secondMd5);
	}
	encodingConversion(...params) {
		const byteList = [];
		for (const param of params) if (typeof param === "number") byteList.push(Math.floor(param));
		else if (typeof param === "string") for (const char of param) byteList.push(char.charCodeAt(0));
		return Buffer.from(byteList).toString("latin1");
	}
	encodingConversion2(a, b, c) {
		return String.fromCharCode(a) + String.fromCharCode(b) + c;
	}
	rc4Encrypt(key, data2) {
		const keyBuffer = typeof key === "string" ? Buffer.from(key, "latin1") : key;
		const dataBuffer = Buffer.from(data2, "latin1");
		const S = Array.from({ length: 256 }, (_, i2) => i2);
		let j = 0;
		for (let i2 = 0; i2 < 256; i2++) {
			j = (j + S[i2] + keyBuffer[i2 % keyBuffer.length]) % 256;
			[S[i2], S[j]] = [S[j], S[i2]];
		}
		const encryptedBuffer = Buffer.alloc(dataBuffer.length);
		let i = 0;
		j = 0;
		for (let k = 0; k < dataBuffer.length; k++) {
			i = (i + 1) % 256;
			j = (j + S[i]) % 256;
			[S[i], S[j]] = [S[j], S[i]];
			const t = (S[i] + S[j]) % 256;
			encryptedBuffer[k] = dataBuffer[k] ^ S[t];
		}
		return encryptedBuffer.toString("latin1");
	}
	calculation(a1, a2, a3) {
		const x3 = (a1 & 255) << 16 | (a2 & 255) << 8 | a3 & 255;
		const c1 = this.base64Charset[(x3 & 16760832) >> 18];
		const c2 = this.base64Charset[(x3 & 258048) >> 12];
		const c3 = this.base64Charset[(x3 & 4032) >> 6];
		const c4 = this.base64Charset[x3 & 63];
		return c1 + c2 + c3 + c4;
	}
	/**
	* X-Bogus
	* @param url URL
	* @param ua User-Agent
	* @returns URLX-BogusUser-Agent
	*/
	getXBogus(url$1, ua) {
		const parsedUrl = new URL2.URL(url$1);
		const urlPath = parsedUrl.pathname + parsedUrl.search;
		const currentUa = ua || this.defaultUa;
		const rc4EncryptedUa = this.rc4Encrypt(this.uaKey, currentUa);
		const base64Ua = Buffer.from(rc4EncryptedUa, "latin1").toString("base64");
		const md5Ua = this.md5(base64Ua);
		const array1 = this.md5StrToArray(md5Ua);
		const array2 = this.md5StrToArray(this.md5(this.md5StrToArray("d41d8cd98f00b204e9800998ecf8427e")));
		const urlEncryptedArray = this.md5Encrypt(urlPath);
		const timestamp = Math.floor(Date.now() / 1e3);
		const ct = 536919696;
		const newArray = [
			64,
			1,
			1,
			12,
			urlEncryptedArray[14],
			urlEncryptedArray[15],
			array2[14],
			array2[15],
			array1[14],
			array1[15],
			timestamp >> 24 & 255,
			timestamp >> 16 & 255,
			timestamp >> 8 & 255,
			timestamp & 255,
			ct >> 24 & 255,
			ct >> 16 & 255,
			ct >> 8 & 255,
			ct & 255
		];
		let xorResult = newArray[0];
		for (let i = 1; i < newArray.length; i++) xorResult ^= newArray[i];
		newArray.push(xorResult);
		const array3 = [];
		const array4 = [];
		let idx = 0;
		while (idx < newArray.length) {
			array3.push(newArray[idx]);
			if (idx + 1 < newArray.length) array4.push(newArray[idx + 1]);
			idx += 2;
		}
		const mergedArray = [...array3, ...array4];
		const firstConversion = this.encodingConversion(...mergedArray);
		const rc4Garbled = this.rc4Encrypt("", firstConversion);
		const garbledCode = this.encodingConversion2(2, 255, rc4Garbled);
		let xb = "";
		idx = 0;
		while (idx < garbledCode.length) {
			if (idx + 2 >= garbledCode.length) break;
			const a1 = garbledCode.charCodeAt(idx);
			const a2 = garbledCode.charCodeAt(idx + 1);
			const a3 = garbledCode.charCodeAt(idx + 2);
			xb += this.calculation(a1, a2, a3);
			idx += 3;
		}
		return {
			fullUrl: url$1.includes("?") ? `${url$1}&X-Bogus=${xb}` : `${url$1}?X-Bogus=${xb}`,
			xbogus: xb,
			userAgent: currentUa
		};
	}
};
var defaultUserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36";
var douyinSign = class {
	/**
	* 
	* @param length 116
	* @returns 
	*/
	static Mstoken(length) {
		const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
		const randomBytes = crypto.randomBytes(length ?? 116);
		return Array.from(randomBytes, (byte) => characters[byte % 62]).join("");
	}
	/**
	* a_bogus 
	* @param url 
	* @returns URL
	*/
	static AB(url$1, userAgent) {
		return a_bogus_default(url$1, userAgent || defaultUserAgent);
	}
	/**
	* X-Bogus 
	* @param url 
	* @returns URL
	*/
	static XB(url$1, userAgent) {
		return new XBogus().getXBogus(url$1, userAgent || defaultUserAgent).xbogus;
	}
	/**  */
	static VerifyFpManager() {
		const e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");
		const t = e.length;
		const n = (/* @__PURE__ */ new Date()).getTime().toString(36);
		const r = [];
		r[8] = "_";
		r[13] = "_";
		r[18] = "_";
		r[23] = "_";
		r[14] = "4";
		for (let o, i = 0; i < 36; i++) if (!r[i]) {
			o = 0 | Math.random() * t;
			r[i] = e[i === 19 ? 3 & o | 8 : o];
		}
		return "verify_" + n + "_" + r.join("");
	}
};
var extractBrowserVersion = (userAgent) => {
	if (!userAgent) return "125.0.0.0";
	const chromeMatch = userAgent.match(/Chrome\/(\d+\.\d+\.\d+\.\d+)/);
	if (chromeMatch) return chromeMatch[1];
	const edgeMatch = userAgent.match(/Edg\/(\d+\.\d+\.\d+\.\d+)/);
	if (edgeMatch) return edgeMatch[1];
	return "125.0.0.0";
};
var buildQueryString = (params) => {
	return Object.entries(params).filter(([_, value]) => value !== void 0 && value !== null).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join("&");
};
var fp = douyinSign.VerifyFpManager();
var DouyinAPI = class {
	browserVersion;
	/**
	* 
	* @param userAgent - 
	*/
	constructor(userAgent) {
		this.browserVersion = extractBrowserVersion(userAgent);
	}
	/**
	* 
	* @returns 
	*/
	getBaseParams() {
		return {
			device_platform: "webapp",
			aid: "6383",
			channel: "channel_pc_web",
			pc_client_type: "1",
			cookie_enabled: "true",
			browser_language: "zh-CN",
			browser_platform: "Win32",
			browser_name: "Chrome",
			browser_version: this.browserVersion,
			browser_online: "true",
			engine_name: "Blink",
			engine_version: this.browserVersion,
			os_name: "Windows",
			os_version: "10",
			cpu_core_num: "16",
			device_memory: "8",
			platform: "PC",
			downlink: "10",
			effective_type: "4g",
			msToken: douyinSign.Mstoken(116),
			verifyFp: fp,
			fp
		};
	}
	/**
	* 
	* @param data - aweme_id
	* @returns URL
	*/
	(data2) {
		return `https://www.douyin.com/aweme/v1/web/aweme/detail/?${buildQueryString({
			...this.getBaseParams(),
			aweme_id: data2.aweme_id,
			update_version_code: "170400",
			version_code: "190500",
			version_name: "19.5.0",
			screen_width: "2328",
			screen_height: "1310",
			round_trip_time: "150",
			webid: "7351848354471872041"
		})}`;
	}
	/**
	* 
	* @param data - aweme_idcursornumber
	* @returns URL
	*/
	(data2) {
		return `https://www.douyin.com/aweme/v1/web/comment/list/?${buildQueryString({
			...this.getBaseParams(),
			aweme_id: data2.aweme_id,
			cursor: data2.cursor ?? 0,
			count: data2.number ?? 50,
			item_type: "0",
			insert_ids: "",
			whale_cut_token: "",
			cut_version: "1",
			rcFT: "",
			version_code: "170400",
			version_name: "17.4.0",
			screen_width: "1552",
			screen_height: "970",
			round_trip_time: "50"
		})}`;
	}
	/**
	* 
	* @param data - aweme_idcomment_id
	* @returns URL
	*/
	(data2) {
		return `https://www-hj.douyin.com/aweme/v1/web/comment/list/reply/?${buildQueryString({
			device_platform: "webapp",
			aid: "6383",
			channel: "channel_pc_web",
			item_id: data2.aweme_id,
			comment_id: data2.comment_id,
			cut_version: "1",
			cursor: data2.cursor,
			count: data2.number,
			item_type: "0",
			update_version_code: "170400",
			pc_client_type: "1",
			pc_libra_divert: "Windows",
			support_h265: "1",
			support_dash: "1",
			version_code: "170400",
			version_name: "17.4.0",
			cookie_enabled: "true",
			screen_width: "1552",
			screen_height: "970",
			browser_language: "zh-CN",
			browser_platform: "Win32",
			browser_name: "Edge",
			browser_version: this.browserVersion,
			browser_online: "true",
			engine_name: "Blink",
			engine_version: this.browserVersion,
			os_name: "Windows",
			os_version: "10",
			cpu_core_num: "16",
			device_memory: "8",
			platform: "PC",
			downlink: "10",
			effective_type: "4g",
			round_trip_time: "50",
			webid: "7487210762873685515",
			verifyFp: fp,
			fp
		})}`;
	}
	/**
	* 
	* @param data - aweme_id
	* @returns URL
	*/
	(data2) {
		return `https://www.iesdouyin.com/web/api/v2/aweme/slidesinfo/?${buildQueryString({
			reflow_source: "reflow_page",
			web_id: "7326472315356857893",
			device_id: "7326472315356857893",
			aweme_ids: `[${data2.aweme_id}]`,
			request_source: "200",
			msToken: douyinSign.Mstoken(116),
			verifyFp: fp,
			fp
		})}`;
	}
	/**
	* 
	* @returns URL
	*/
	() {
		return "https://www.douyin.com/aweme/v1/web/emoji/list";
	}
	/**
	* 
	* @param data - sec_uid
	* @returns URL
	*/
	(data2) {
		return `https://www.douyin.com/aweme/v1/web/aweme/post/?${buildQueryString({
			...this.getBaseParams(),
			sec_user_id: data2.sec_uid,
			max_cursor: "0",
			locate_query: "false",
			show_live_replay_strategy: "1",
			need_time_list: "1",
			time_list_query: "0",
			whale_cut_token: "",
			cut_version: "1",
			count: "18",
			publish_video_strategy_type: "2",
			version_code: "170400",
			version_name: "17.4.0",
			screen_width: "1552",
			screen_height: "970",
			round_trip_time: "50",
			webid: "7338423850134226495"
		})}`;
	}
	/**
	* 
	* @param data - sec_uid
	* @returns URL
	*/
	(data2) {
		return `https://www.douyin.com/aweme/v1/web/user/profile/other/?${buildQueryString({
			...this.getBaseParams(),
			publish_video_strategy_type: "2",
			source: "channel_pc_web",
			sec_user_id: data2.sec_uid,
			personal_center_strategy: "1",
			version_code: "170400",
			version_name: "17.4.0",
			screen_width: "1552",
			screen_height: "970",
			round_trip_time: "0",
			webid: "7327957959955580467"
		})}`;
	}
	/**
	* 
	* @param data - query
	* @returns URL
	*/
	(data2) {
		return `https://www.douyin.com/aweme/v1/web/api/suggest_words/?${buildQueryString({
			...this.getBaseParams(),
			query: data2.query,
			business_id: "30088",
			from_group_id: "7129543174929812767",
			version_code: "170400",
			version_name: "17.4.0",
			screen_width: "1552",
			screen_height: "970",
			round_trip_time: "50",
			webid: "7327957959955580467"
		})}`;
	}
	/**
	* 
	* @param data - querynumbersearch_id
	* @returns URL
	*/
	(data2) {
		return `https://www.douyin.com/aweme/v1/web/general/search/single/?${buildQueryString({
			...this.getBaseParams(),
			search_channel: "aweme_general",
			sort_type: "0",
			publish_time: "0",
			keyword: data2.query,
			search_source: "normal_search",
			query_correct_type: "1",
			is_filter_search: "0",
			from_group_id: "",
			offset: "0",
			version_code: "190600",
			version_name: "19.6.0",
			screen_width: "1552",
			screen_height: "970",
			round_trip_time: "50",
			webid: "7338423850134226495",
			search_id: data2.search_id ?? "",
			count: data2.number ?? 10
		})}`;
	}
	/**
	* 
	* @returns URL
	*/
	() {
		return `https://www.douyin.com/aweme/v1/web/im/strategy/config?${buildQueryString({
			device_platform: "webapp",
			aid: "1128",
			channel: "channel_pc_web",
			publish_video_strategy_type: "2",
			app_id: "1128",
			scenes: "[%22interactive_resources%22]",
			pc_client_type: "1",
			version_code: "170400",
			version_name: "17.4.0",
			cookie_enabled: "true",
			screen_width: "2328",
			screen_height: "1310",
			browser_language: "zh-CN",
			browser_platform: "Win32",
			browser_name: "Chrome",
			browser_version: "126.0.0.0",
			browser_online: "true",
			engine_name: "Blink",
			engine_version: "126.0.0.0",
			os_name: "Windows",
			os_version: "10",
			cpu_core_num: "16",
			device_memory: "8",
			platform: "PC",
			downlink: "1.5",
			effective_type: "4g",
			round_trip_time: "350",
			webid: "7347329698282833447",
			msToken: douyinSign.Mstoken(116),
			verifyFp: fp,
			fp
		})}`;
	}
	/**
	* 
	* @param data - music_id
	* @returns URL
	*/
	(data2) {
		return `https://www.douyin.com/aweme/v1/web/music/detail/?${buildQueryString({
			device_platform: "webapp",
			aid: "6383",
			channel: "channel_pc_web",
			music_id: data2.music_id,
			scene: "1",
			pc_client_type: "1",
			version_code: "170400",
			version_name: "17.4.0",
			cookie_enabled: "true",
			screen_width: "2328",
			screen_height: "1310",
			browser_language: "zh-CN",
			browser_platform: "Win32",
			browser_name: "Chrome",
			browser_version: "126.0.0.0",
			browser_online: "true",
			engine_name: "Blink",
			engine_version: "126.0.0.0",
			os_name: "Windows",
			os_version: "10",
			cpu_core_num: "16",
			device_memory: "8",
			platform: "PC",
			downlink: "1.5",
			effective_type: "4g",
			round_trip_time: "350",
			webid: "7347329698282833447",
			msToken: douyinSign.Mstoken(116),
			verifyFp: fp,
			fp
		})}`;
	}
	/**
	* 
	* @param data - web_ridroom_id
	* @returns URL
	*/
	(data2) {
		return `https://live.douyin.com/webcast/room/web/enter/?${buildQueryString({
			aid: "6383",
			app_name: "douyin_web",
			live_id: "1",
			device_platform: "web",
			language: "zh-CN",
			enter_from: "web_share_link",
			cookie_enabled: "true",
			screen_width: "2048",
			screen_height: "1152",
			browser_language: "zh-CN",
			browser_platform: "Win32",
			browser_name: "Chrome",
			browser_version: "125.0.0.0",
			web_rid: data2.web_rid,
			room_id_str: data2.room_id,
			enter_source: "",
			is_need_double_stream: "false",
			insert_task_id: "",
			live_reason: "",
			msToken: douyinSign.Mstoken(116),
			verifyFp: fp,
			fp
		})}`;
	}
	/**
	* 
	* @param data - verify_fp
	* @returns URL
	*/
	(data2) {
		return `https://sso.douyin.com/get_qrcode/?${buildQueryString({
			verifyFp: data2.verify_fp,
			fp: data2.verify_fp
		})}`;
	}
	/**
	* 
	* @param data - group_iditem_id
	* @returns URL
	*/
	(data2) {
		return `https://www-hj.douyin.com/aweme/v1/web/danmaku/get_v2/?${buildQueryString({
			...this.getBaseParams(),
			app_name: "aweme",
			format: "json",
			group_id: data2.aweme_id,
			item_id: data2.aweme_id,
			start_time: data2.start_time ?? "0",
			end_time: data2.end_time ?? "32000",
			duration: data2.duration,
			update_version_code: "170400",
			pc_libra_divert: "Windows",
			support_h265: "1",
			support_dash: "1",
			version_code: "170400",
			version_name: "17.4.0",
			screen_width: "2328",
			screen_height: "1310",
			browser_name: "Edge",
			browser_version: "140.0.0.0",
			engine_name: "Blink",
			engine_version: "140.0.0.0",
			downlink: "1.55",
			round_trip_time: "200",
			webid: "7487210762873685515",
			msToken: douyinSign.Mstoken(116),
			verifyFp: fp,
			fp
		})}`;
	}
};
var createDouyinApiUrls = (userAgent) => {
	return new DouyinAPI(userAgent);
};
var douyinApiUrls = new DouyinAPI();
var getSignature = (url$1, signType = "a_bogus", userAgent) => {
	switch (signType) {
		case "x_bogus": return douyinSign.XB(url$1, userAgent);
		case "a_bogus":
		default: return douyinSign.AB(url$1, userAgent);
	}
};
var getSignParamName = (signType = "a_bogus") => {
	switch (signType) {
		case "x_bogus": return "X-Bogus";
		case "a_bogus":
		default: return "a_bogus";
	}
};
var buildSignedUrl = (url$1, signType = "a_bogus", userAgent) => {
	const signature = getSignature(url$1, signType, userAgent);
	return `${url$1}&${getSignParamName(signType)}=${signature}`;
};
var DouyinData = async (data2, cookie$1, requestConfig) => {
	var _a, _b, _c, _d, _e;
	const defHeaders = getDouyinDefaultConfig(cookie$1)["headers"];
	const baseRequestConfig = {
		method: "GET",
		timeout: 1e4,
		...requestConfig,
		headers: {
			...defHeaders,
			...(requestConfig == null ? void 0 : requestConfig.headers) || {}
		}
	};
	const userAgent = (_a = baseRequestConfig.headers) == null ? void 0 : _a["User-Agent"];
	const douyinApiUrls2 = createDouyinApiUrls(userAgent);
	const signType = data2.signType || "a_bogus";
	switch (data2.methodType) {
		case "":
		case "":
		case "":
		case "":
		case "": {
			const url$1 = douyinApiUrls2.({ aweme_id: data2.aweme_id });
			return await GlobalGetData2(data2.methodType, {
				...baseRequestConfig,
				url: buildSignedUrl(url$1, signType, userAgent)
			});
		}
		case "": {
			const urlGenerator = (params) => douyinApiUrls2.(params);
			return await fetchPaginatedData(data2.methodType, urlGenerator, data2, 50, baseRequestConfig, signType);
		}
		case "": {
			const urlGenerator = (params) => douyinApiUrls2.(params);
			return await fetchPaginatedData(data2.methodType, urlGenerator, data2, 3, baseRequestConfig, "x_bogus");
		}
		case "": {
			const url$1 = douyinApiUrls2.({ sec_uid: data2.sec_uid });
			const customConfig = {
				...baseRequestConfig,
				headers: {
					...baseRequestConfig.headers,
					...(!(requestConfig == null ? void 0 : requestConfig.headers) || !("Referer" in requestConfig.headers)) && { Referer: `https://www.douyin.com/user/${data2.sec_uid}` }
				}
			};
			return await GlobalGetData2(data2.methodType, {
				...customConfig,
				url: buildSignedUrl(url$1, signType, userAgent)
			});
		}
		case "Emoji": {
			const url$1 = douyinApiUrls2.();
			return await GlobalGetData2(data2.methodType, {
				...baseRequestConfig,
				url: url$1
			});
		}
		case "": {
			const url$1 = douyinApiUrls2.({ sec_uid: data2.sec_uid });
			const customConfig = {
				...baseRequestConfig,
				headers: {
					...baseRequestConfig.headers,
					...(!(requestConfig == null ? void 0 : requestConfig.headers) || !("Referer" in requestConfig.headers)) && { Referer: `https://www.douyin.com/user/${data2.sec_uid}` }
				}
			};
			return await GlobalGetData2(data2.methodType, {
				...customConfig,
				url: buildSignedUrl(url$1, signType, userAgent)
			});
		}
		case "": {
			const url$1 = douyinApiUrls2.({
				query: data2.query,
				number: data2.number ?? 10
			});
			const customConfig = {
				...baseRequestConfig,
				headers: {
					...baseRequestConfig.headers,
					...(!(requestConfig == null ? void 0 : requestConfig.headers) || !("Referer" in requestConfig.headers)) && { Referer: `https://www.douyin.com/search/${encodeURIComponent(String(data2.query))}` }
				}
			};
			return await GlobalGetData2(data2.methodType, {
				...customConfig,
				url: buildSignedUrl(url$1, signType, userAgent)
			});
		}
		case "": {
			let search_id = "";
			const maxPageSize = 15;
			let fetchedSearchList = [];
			let tmpresp = {};
			const customConfig = {
				...baseRequestConfig,
				headers: {
					...baseRequestConfig.headers,
					...(!(requestConfig == null ? void 0 : requestConfig.headers) || !("Referer" in requestConfig.headers)) && { Referer: `https://www.douyin.com/search/${encodeURIComponent(String(data2.query))}` }
				}
			};
			while (fetchedSearchList.length < Number(data2.number ?? 10)) {
				const requestCount = Math.min(Number(data2.number ?? 50) - fetchedSearchList.length, maxPageSize);
				const url$1 = douyinApiUrls2.({
					query: data2.query,
					number: requestCount,
					search_id: search_id === "" ? void 0 : search_id
				});
				const response$2 = await GlobalGetData2(data2.methodType, {
					...customConfig,
					url: buildSignedUrl(url$1, signType, userAgent)
				});
				if (((_b = response$2.data) == null ? void 0 : _b.length) === 0) {
					logger$1.warn("\nck\n" + data2.methodType);
					return false;
				}
				if (!response$2.data) response$2.data = [];
				fetchedSearchList.push(...response$2.data);
				tmpresp = response$2;
				search_id = (_c = response$2.log_pb) == null ? void 0 : _c.impr_id;
			}
			return {
				...tmpresp,
				data: data2.number === 0 ? [] : fetchedSearchList.slice(0, Number(data2.number ?? 10))
			};
		}
		case "": {
			const url$1 = douyinApiUrls2.();
			return await GlobalGetData2(data2.methodType, {
				...baseRequestConfig,
				url: buildSignedUrl(url$1, signType, userAgent)
			});
		}
		case "": {
			const url$1 = douyinApiUrls2.({ music_id: data2.music_id });
			return await GlobalGetData2(data2.methodType, {
				...baseRequestConfig,
				url: buildSignedUrl(url$1, signType, userAgent)
			});
		}
		case "": {
			let url$1 = douyinApiUrls2.({ sec_uid: data2.sec_uid });
			const fetchUrl = buildSignedUrl(url$1, signType, userAgent);
			const customConfig = {
				...baseRequestConfig,
				headers: {
					...baseRequestConfig.headers,
					...(!(requestConfig == null ? void 0 : requestConfig.headers) || !("Referer" in requestConfig.headers)) && { Referer: `https://www.douyin.com/user/${data2.sec_uid}` }
				}
			};
			const UserInfoData = await GlobalGetData2(data2.methodType, {
				...customConfig,
				url: fetchUrl
			});
			if (!((_d = UserInfoData == null ? void 0 : UserInfoData.user) == null ? void 0 : _d.live_status) || UserInfoData.user.live_status !== 1) {
				logger$1.error((((_e = UserInfoData == null ? void 0 : UserInfoData.user) == null ? void 0 : _e.nickname) || "") + "");
				const Err = {
					errorDescription: " TypeError: Cannot read properties of undefined (reading 'live_status')",
					requestType: data2.methodType ?? "",
					requestUrl: fetchUrl
				};
				return {
					code: "USER_NOT_LIVE",
					data: UserInfoData,
					amagiError: Err,
					amagiMessage: Err.errorDescription
				};
			}
			if (!UserInfoData.user.room_data) {
				logger$1.error("");
				return {
					code: 500,
					message: "",
					data: null
				};
			}
			const room_data = JSON.parse(UserInfoData.user.room_data);
			url$1 = douyinApiUrls2.({
				room_id: UserInfoData.user.room_id_str,
				web_rid: room_data.owner.web_rid
			});
			const liveCustomConfig = {
				...baseRequestConfig,
				headers: {
					...baseRequestConfig.headers,
					...(!(requestConfig == null ? void 0 : requestConfig.headers) || !("Referer" in requestConfig.headers)) && { Referer: `https://live.douyin.com/${room_data.owner.web_rid}` }
				}
			};
			return await GlobalGetData2(data2.methodType, {
				...liveCustomConfig,
				url: buildSignedUrl(url$1, signType, userAgent)
			});
		}
		case "": {
			const url$1 = douyinApiUrls2.({ verify_fp: data2.verify_fp });
			return await GlobalGetData2(data2.methodType, {
				...baseRequestConfig,
				url: buildSignedUrl(url$1, signType, userAgent)
			});
		}
		case "": {
			const MAX_SEGMENT_DURATION = 32e3;
			const startTime = data2.start_time ?? 0;
			const endTime = data2.end_time ?? data2.duration;
			const totalDuration = endTime - startTime;
			if (totalDuration <= MAX_SEGMENT_DURATION) {
				const url$1 = douyinApiUrls2.({
					aweme_id: data2.aweme_id,
					start_time: startTime,
					end_time: endTime,
					duration: data2.duration
				});
				return await GlobalGetData2(data2.methodType, {
					...baseRequestConfig,
					url: buildSignedUrl(url$1, signType, userAgent)
				});
			}
			const segments = [];
			let currentStart = startTime;
			while (currentStart < endTime) {
				const currentEnd = Math.min(currentStart + MAX_SEGMENT_DURATION, endTime);
				segments.push({
					start: currentStart,
					end: currentEnd
				});
				currentStart = currentEnd;
			}
			logger$1.debug(`\u5F39\u5E55\u6570\u636E\u9700\u8981\u5206${segments.length}\u6BB5\u83B7\u53D6\uFF0C\u603B\u65F6\u957F\uFF1A${totalDuration}ms`);
			const segmentPromises = segments.map(async (segment$1, index$1) => {
				const url$1 = douyinApiUrls2.({
					aweme_id: data2.aweme_id,
					start_time: segment$1.start,
					end_time: segment$1.end,
					duration: data2.duration
				});
				try {
					const segmentData = await GlobalGetData2(`${data2.methodType}-\u6BB5${index$1 + 1}`, {
						...baseRequestConfig,
						url: buildSignedUrl(url$1, signType, userAgent)
					});
					logger$1.debug(`\u5F39\u5E55\u7B2C${index$1 + 1}\u6BB5\u83B7\u53D6\u6210\u529F (${segment$1.start}ms-${segment$1.end}ms)`);
					return segmentData;
				} catch (error) {
					logger$1.debug(`\u5F39\u5E55\u7B2C${index$1 + 1}\u6BB5\u83B7\u53D6\u5931\u8D25 (${segment$1.start}ms-${segment$1.end}ms):`, error);
					return null;
				}
			});
			const segmentResults = await Promise.all(segmentPromises);
			const mergedDanmakuList = [];
			let totalCount = 0;
			let finalStartTime = startTime;
			let finalEndTime = endTime;
			let finalExtra = null;
			let finalLogPb = null;
			let finalStatusCode = 0;
			segmentResults.forEach((segmentData, index$1) => {
				if (segmentData && segmentData.danmaku_list) {
					mergedDanmakuList.push(...segmentData.danmaku_list);
					totalCount += segmentData.total || 0;
					if (index$1 === 0) {
						finalExtra = segmentData.extra;
						finalLogPb = segmentData.log_pb;
						finalStatusCode = segmentData.status_code;
					}
				}
			});
			mergedDanmakuList.sort((a, b) => (a.offset_time || 0) - (b.offset_time || 0));
			const finalDanmakuData = {
				danmaku_list: mergedDanmakuList,
				start_time: finalStartTime,
				end_time: finalEndTime,
				total: mergedDanmakuList.length,
				status_code: finalStatusCode,
				extra: finalExtra,
				log_pb: finalLogPb
			};
			logger$1.debug(`\u5F39\u5E55\u6570\u636E\u5408\u5E76\u5B8C\u6210\uFF0C\u5171\u83B7\u53D6${mergedDanmakuList.length}\u6761\u5F39\u5E55`);
			return finalDanmakuData;
		}
		default:
			logger$1.warn(`\u672A\u77E5\u7684\u6296\u97F3\u6570\u636E\u63A5\u53E3\uFF1A\u300C${logger$1.red(data2.methodType)}\u300D`);
			return null;
	}
};
var fetchPaginatedData = async (type$1, apiUrlGenerator, params, maxPageSize, requestConfig, signType = "a_bogus") => {
	var _a;
	let cursor = params.cursor ?? 0;
	let fetchedData = [];
	let tmpresp = {};
	const userAgent = (_a = requestConfig.headers) == null ? void 0 : _a["User-Agent"];
	while (fetchedData.length < Number(params.number ?? maxPageSize)) {
		const requestCount = Math.min(Number(params.number ?? maxPageSize) - fetchedData.length, maxPageSize);
		const url$1 = apiUrlGenerator({
			...params,
			number: requestCount,
			cursor
		});
		const response$2 = await GlobalGetData2(type$1, {
			...requestConfig,
			url: buildSignedUrl(url$1, signType, userAgent)
		});
		fetchedData.push(...response$2.comments || response$2.data || []);
		tmpresp = response$2;
		if ((response$2.comments || response$2.data || []).length < requestCount) break;
		cursor = response$2.cursor;
	}
	return {
		...tmpresp,
		comments: params.number === 0 ? [] : fetchedData.slice(0, Number(params.number ?? maxPageSize)),
		cursor: params.number === 0 ? 0 : fetchedData.length
	};
};
var GlobalGetData2 = async (type$1, config$2) => {
	let warningMessage = "";
	try {
		const result = await fetchData(config$2);
		if (!result || result === "") {
			const Err = {
				errorDescription: "ck",
				requestType: type$1 ?? "",
				requestUrl: config$2.url
			};
			warningMessage = `
      \u83B7\u53D6\u54CD\u5E94\u6570\u636E\u5931\u8D25\uFF01\u539F\u56E0\uFF1A${logger$1.yellow("ck")}
      \u8BF7\u6C42\u7C7B\u578B\uFF1A\u300C${type$1}\u300D
      \u8BF7\u6C42URL\uFF1A${config$2.url}
      `;
			logger$1.warn(warningMessage);
			throw {
				code: "INVALID_COOKIE",
				data: result,
				amagiError: Err
			};
		}
		if (result.filter_detail && result.filter_detail.filter_reason) {
			const filterReason = result.filter_detail.filter_reason;
			const Err = {
				errorDescription: `\u83B7\u53D6\u54CD\u5E94\u6570\u636E\u5931\u8D25\uFF01\u539F\u56E0\uFF1A${filterReason}\uFF01`,
				requestType: type$1 ?? "",
				requestUrl: config$2.url
			};
			warningMessage = `
      \u83B7\u53D6\u54CD\u5E94\u6570\u636E\u5931\u8D25\uFF01\u539F\u56E0\uFF1A${logger$1.yellow(filterReason)}
      \u8BF7\u6C42\u7C7B\u578B\uFF1A\u300C${type$1}\u300D
      \u8BF7\u6C42URL\uFF1A${config$2.url}
      `;
			logger$1.warn(warningMessage);
			throw {
				code: "CONTENT_FILTERED",
				data: result,
				amagiError: Err
			};
		}
		return result;
	} catch (error) {
		if (error && typeof error === "object") return {
			...error,
			amagiMessage: warningMessage
		};
		return {
			code: "UNKNOWN_ERROR",
			data: null,
			amagiError: {
				errorDescription: "",
				requestType: type$1,
				requestUrl: config$2.url
			},
			amagiMessage: warningMessage
		};
	}
};
var API = class {
	(data2) {
		return {
			type: "visionVideoDetail",
			url: "https://www.kuaishou.com/graphql",
			body: {
				operationName: "visionVideoDetail",
				variables: {
					photoId: data2.photoId,
					page: "detail"
				},
				query: "query visionVideoDetail($photoId: String, $type: String, $page: String, $webPageArea: String) {\n  visionVideoDetail(photoId: $photoId, type: $type, page: $page, webPageArea: $webPageArea) {\n    status\n    type\n    author {\n      id\n      name\n      following\n      headerUrl\n      __typename\n    }\n    photo {\n      id\n      duration\n      caption\n      likeCount\n      realLikeCount\n      coverUrl\n      photoUrl\n      liked\n      timestamp\n      expTag\n      llsid\n      viewCount\n      videoRatio\n      stereoType\n      musicBlocked\n      manifest {\n        mediaType\n        businessType\n        version\n        adaptationSet {\n          id\n          duration\n          representation {\n            id\n            defaultSelect\n            backupUrl\n            codecs\n            url\n            height\n            width\n            avgBitrate\n            maxBitrate\n            m3u8Slice\n            qualityType\n            qualityLabel\n            frameRate\n            featureP2sp\n            hidden\n            disableAdaptive\n            __typename\n          }\n          __typename\n        }\n        __typename\n      }\n      manifestH265\n      photoH265Url\n      coronaCropManifest\n      coronaCropManifestH265\n      croppedPhotoH265Url\n      croppedPhotoUrl\n      videoResource\n      __typename\n    }\n    tags {\n      type\n      name\n      __typename\n    }\n    commentLimit {\n      canAddComment\n      __typename\n    }\n    llsid\n    danmakuSwitch\n    __typename\n  }\n}\n"
			}
		};
	}
	(data2) {
		return {
			type: "commentListQuery",
			url: "https://www.kuaishou.com/graphql",
			body: {
				operationName: "commentListQuery",
				variables: {
					photoId: data2.photoId,
					pcursor: ""
				},
				query: "query commentListQuery($photoId: String, $pcursor: String) {\n  visionCommentList(photoId: $photoId, pcursor: $pcursor) {\n    commentCount\n    pcursor\n    rootComments {\n      commentId\n      authorId\n      authorName\n      content\n      headurl\n      timestamp\n      likedCount\n      realLikedCount\n      liked\n      status\n      authorLiked\n      subCommentCount\n      subCommentsPcursor\n      subComments {\n        commentId\n        authorId\n        authorName\n        content\n        headurl\n        timestamp\n        likedCount\n        realLikedCount\n        liked\n        status\n        authorLiked\n        replyToUserName\n        replyTo\n        __typename\n      }\n      __typename\n    }\n    __typename\n  }\n}\n"
			}
		};
	}
	() {
		return {
			type: "visionBaseEmoticons",
			url: "https://www.kuaishou.com/graphql",
			body: {
				operationName: "visionBaseEmoticons",
				variables: {},
				query: "query visionBaseEmoticons {\n  visionBaseEmoticons {\n    iconUrls\n    __typename\n  }\n}\n"
			}
		};
	}
};
var kuaishouApiUrls = new API();
var KuaishouData = async (data2, cookie$1, requestConfig) => {
	const defHeaders = getKuaishouDefaultConfig(cookie$1)["headers"];
	const baseRequestConfig = {
		method: "POST",
		timeout: 1e4,
		...requestConfig,
		headers: { ...defHeaders }
	};
	switch (data2.methodType) {
		case "": {
			const body = kuaishouApiUrls.({ photoId: data2.photoId });
			return await GlobalGetData3(data2.methodType, {
				...baseRequestConfig,
				url: body.url,
				data: body.body
			});
		}
		case "": {
			const body = kuaishouApiUrls.({ photoId: data2.photoId });
			return await GlobalGetData3(data2.methodType, {
				...baseRequestConfig,
				url: body.url,
				data: body.body
			});
		}
		case "Emoji": {
			const body = kuaishouApiUrls.();
			return await GlobalGetData3(data2.methodType, {
				...baseRequestConfig,
				url: body.url,
				data: body.body
			});
		}
		default:
			logger$1.warn(`\u672A\u77E5\u7684\u5FEB\u624B\u6570\u636E\u63A5\u53E3\uFF1A\u300C${logger$1.red(data2.methodType)}\u300D`);
			return null;
	}
};
var GlobalGetData3 = async (type$1, options) => {
	let warningMessage = "";
	try {
		const result = await fetchData(options);
		if (result === "" || !result || result.result === 2) {
			const Err = {
				errorDescription: `\u83B7\u53D6\u54CD\u5E94\u6570\u636E\u5931\u8D25\uFF01\u63A5\u53E3\u8FD4\u56DE\u5185\u5BB9\u4E3A\u7A7A\uFF01`,
				requestType: type$1 ?? "",
				requestUrl: options.url,
				requestBody: JSON.stringify(options.data)
			};
			warningMessage = `
      \u83B7\u53D6\u54CD\u5E94\u6570\u636E\u5931\u8D25\uFF01\u539F\u56E0\uFF1A${logger$1.yellow("ck")}
      \u8BF7\u6C42\u7C7B\u578B\uFF1A\u300C${type$1}\u300D
      \u8BF7\u6C42URL\uFF1A${options.url}
      \u8BF7\u6C42\u53C2\u6570\uFF1A${JSON.stringify(options.data, null, 2)}
      `;
			logger$1.warn(warningMessage);
			throw {
				code: "INVALID_COOKIE",
				data: result,
				amagiError: Err
			};
		}
		return result;
	} catch (error) {
		if (error && typeof error === "object") return {
			...error,
			amagiMessage: warningMessage
		};
		return {
			code: "UNKNOWN_ERROR",
			data: null,
			amagiError: {
				errorDescription: "",
				requestType: type$1,
				requestUrl: options.url
			},
			amagiMessage: warningMessage
		};
	}
};
function smartNumber(errorMessage, minValue = 1, isInteger = false) {
	if (isInteger) return number({ error: errorMessage }).int({ error: `${errorMessage.replace("", "")}\u5FC5\u987B\u662F\u6574\u6570\uFF0C\u4E0D\u80FD\u5305\u542B\u5C0F\u6570` }).min(minValue, { error: `${errorMessage.replace("", "")}\u5FC5\u987B\u5927\u4E8E\u7B49\u4E8E${minValue}` });
	else return number({ error: errorMessage }).min(minValue, { error: `${errorMessage.replace("", "")}\u5FC5\u987B\u5927\u4E8E\u7B49\u4E8E${minValue}` });
}
var smartPositiveInteger = (errorMessage) => {
	return smartNumber(errorMessage, 1, true);
};
var extractCreatorInfoFromHtml = (html) => {
	var _a;
	const match = html.match(/<script>window\.__INITIAL_STATE__=(.+)<\/script>/m);
	if (!match) return null;
	try {
		const jsonStr = match[1].replace(/:undefined/g, ":null");
		const info = JSON.parse(jsonStr);
		return ((_a = info == null ? void 0 : info.user) == null ? void 0 : _a.userPageData) || null;
	} catch (error) {
		console.error(":", error);
		return null;
	}
};
var DouyinWorkParamsSchema = object({
	methodType: _enum([
		"",
		"",
		"",
		"",
		""
	], { error: "" }),
	aweme_id: string({ error: "ID" }).min(1, { error: "ID" })
});
var DouyinCommentParamsSchema = object({
	methodType: literal("", { error: "\"\"" }),
	aweme_id: string({ error: "ID" }).min(1, { error: "ID" }),
	number: smartPositiveInteger("").optional().default(50),
	cursor: number({ error: "" }).int({ error: "" }).min(0, { error: "0" }).default(0).optional()
});
var DouyinSearchParamsSchema = object({
	methodType: _enum(["", ""], { error: "\"\"\"\"" }),
	query: string({ error: "" }).min(1, { error: "" }),
	number: smartPositiveInteger("").optional().default(10),
	search_id: string({ error: "ID" }).optional()
});
var DouyinCommentReplyParamsSchema = object({
	methodType: literal("", { error: "\"\"" }),
	aweme_id: string({ error: "ID" }).min(1, { error: "ID" }),
	comment_id: string({ error: "ID" }).min(1, { error: "ID" }),
	number: smartPositiveInteger("").optional().default(5),
	cursor: number({ error: "" }).int({ error: "" }).min(0, { error: "0" }).default(0).optional()
});
var DouyinUserParamsSchema = object({
	methodType: _enum([
		"",
		"",
		""
	], { error: "" }),
	sec_uid: string({ error: "ID" }).min(1, { error: "ID" })
});
var DouyinMusicParamsSchema = object({
	methodType: literal("", { error: "\"\"" }),
	music_id: string({ error: "ID" }).min(1, { error: "ID" })
});
var DouyinQrcodeParamsSchema = object({
	methodType: literal("", { error: "\"\"" }),
	verify_fp: string({ error: "fp" }).min(1, { error: "fp" })
});
var DouyinEmojiListParamsSchema = object({ methodType: literal("Emoji", { error: "\"Emoji\"" }) });
var DouyinEmojiProParamsSchema = object({ methodType: literal("", { error: "\"\"" }) });
var DouyinDanmakuParamsSchema = object({
	methodType: literal("", { error: "\"\"" }),
	aweme_id: string({ error: "ID" }).min(1, { error: "ID" }),
	start_time: number({ error: "" }).int({ error: "" }).min(0, { error: "0" }).optional(),
	end_time: number({ error: "" }).int({ error: "" }).min(0, { error: "0" }).optional(),
	duration: number({ error: "" }).int({ error: "" }).min(0, { error: "0" })
}).refine((data2) => {
	if (data2.end_time !== void 0) return data2.end_time <= data2.duration;
	return true;
}, {
	error: "",
	path: ["end_time"]
}).refine((data2) => {
	if (data2.start_time !== void 0 && data2.end_time !== void 0) return data2.start_time < data2.end_time;
	return true;
}, {
	error: "",
	path: ["start_time"]
});
var DouyinValidationSchemas2 = {
	"": DouyinWorkParamsSchema,
	"": DouyinWorkParamsSchema,
	"": DouyinWorkParamsSchema,
	"": DouyinWorkParamsSchema,
	"": DouyinWorkParamsSchema,
	"": DouyinCommentParamsSchema,
	"": DouyinUserParamsSchema,
	"": DouyinUserParamsSchema,
	"": DouyinSearchParamsSchema,
	"": DouyinSearchParamsSchema,
	"": DouyinMusicParamsSchema,
	"": DouyinUserParamsSchema,
	"": DouyinQrcodeParamsSchema,
	"Emoji": DouyinEmojiListParamsSchema,
	"": DouyinEmojiProParamsSchema,
	"": DouyinCommentReplyParamsSchema,
	"": DouyinDanmakuParamsSchema
};
var BilibiliVideoParamsSchema = object({
	methodType: literal("", { error: "\"\"" }),
	bvid: string({ error: "BVID" }).min(1, { error: "BVID" })
});
var BilibiliVideoDownloadParamsSchema = object({
	methodType: literal("", { error: "\"\"" }),
	avid: smartNumber("AVID", 1, true),
	cid: smartNumber("CID", 1, true)
});
var BilibiliCommentParamsSchema = object({
	methodType: literal("", { error: "\"\"" }),
	oid: string({ error: "OID" }).min(1, { error: "OID" }),
	type: smartNumber("", 1, true).refine((val) => [
		1,
		2,
		4,
		5,
		6,
		7,
		8,
		9,
		10,
		11,
		12,
		13,
		14,
		15,
		16,
		17,
		18,
		19,
		20,
		21,
		22,
		33
	].includes(val), { error: "" }),
	number: number({ error: "" }).int({ error: "" }).positive({ error: "" }).default(20).optional(),
	pn: number({ error: "" }).int({ error: "" }).positive({ error: "" }).default(1).optional()
});
var BilibiliUserParamsSchema = object({
	methodType: _enum([
		"",
		"",
		"UP"
	], { error: "" }),
	host_mid: smartNumber("UPUID", 1, true)
});
var BilibiliEmojiParamsSchema = object({ methodType: literal("Emoji", { error: "\"Emoji\"" }) });
var BilibiliBangumiInfoParamsSchema = object({
	methodType: literal("", { error: "\"\"" }),
	ep_id: string({ error: "EP ID" }).min(1, { error: "EP ID" }).optional(),
	season_id: string({ error: "ID" }).optional()
}).refine((data2) => data2.ep_id || data2.season_id, {
	error: "ep_id  season_id ",
	path: ["ep_id"]
});
var BilibiliBangumiStreamParamsSchema = object({
	methodType: literal("", { error: "\"\"" }),
	cid: smartNumber("CID", 1, true),
	ep_id: string({ error: "EP ID" }).min(1, { error: "EP ID" })
});
var BilibiliDynamicParamsSchema = object({
	methodType: _enum(["", ""], { error: "\"\"\"\"" }),
	dynamic_id: string({ error: "ID" }).min(1, { error: "ID" })
});
var BilibiliLiveParamsSchema = object({
	methodType: _enum(["", ""], { error: "\"\"\"\"" }),
	room_id: string({ error: "ID" }).min(1, { error: "ID" })
});
var BilibiliLoginParamsSchema = object({ methodType: literal("", { error: "\"\"" }) });
var BilibiliQrcodeParamsSchema = object({ methodType: literal("", { error: "\"\"" }) });
var BilibiliQrcodeStatusParamsSchema = object({
	methodType: literal("", { error: "\"\"" }),
	qrcode_key: string({ error: "key" }).min(1, { error: "key" })
});
var BilibiliAv2BvParamsSchema = object({
	methodType: literal("AVBV", { error: "\"AVBV\"" }),
	avid: number({ error: "AVID" }).int({ error: "AVID" }).positive({ error: "AVID" })
});
var BilibiliBv2AvParamsSchema = object({
	methodType: literal("BVAV", { error: "\"BVAV\"" }),
	bvid: string({ error: "BVID" }).min(1, { error: "BVID" })
});
var BilibiliValidationSchemas2 = {
	"": BilibiliVideoParamsSchema,
	"": BilibiliVideoDownloadParamsSchema,
	"": BilibiliCommentParamsSchema,
	"": BilibiliUserParamsSchema,
	"": BilibiliUserParamsSchema,
	"Emoji": BilibiliEmojiParamsSchema,
	"": BilibiliBangumiInfoParamsSchema,
	"": BilibiliBangumiStreamParamsSchema,
	"": BilibiliDynamicParamsSchema,
	"": BilibiliDynamicParamsSchema,
	"": BilibiliLiveParamsSchema,
	"": BilibiliLiveParamsSchema,
	"": BilibiliLoginParamsSchema,
	"": BilibiliQrcodeParamsSchema,
	"": BilibiliQrcodeStatusParamsSchema,
	"UP": BilibiliUserParamsSchema,
	"AVBV": BilibiliAv2BvParamsSchema,
	"BVAV": BilibiliBv2AvParamsSchema
};
var KuaishouVideoParamsSchema = object({
	methodType: literal("", { error: "\"\"" }),
	photoId: string({ error: "ID" }).min(1, { error: "ID" })
});
var KuaishouCommentParamsSchema = object({
	methodType: literal("", { error: "\"\"" }),
	photoId: string({ error: "ID" }).min(1, { error: "ID" })
});
var KuaishouEmojiParamsSchema = object({ methodType: literal("Emoji", { error: "\"Emoji\"" }) });
var KuaishouValidationSchemas2 = {
	"": KuaishouVideoParamsSchema,
	"": KuaishouCommentParamsSchema,
	"Emoji": KuaishouEmojiParamsSchema
};
var xiaohongshuSign = class {
	static client = new Xhshow();
	/**
	* GETX-S
	* @param path - API
	* @param a1Cookie - a1 cookie
	* @param clientType -  'xhs-pc-web'
	* @param params - 
	* @returns X-S
	*/
	static generateXSGet(path2, a1Cookie, clientType = "xhs-pc-web", params = {}) {
		return this.client.signXsGet(path2, a1Cookie, clientType, params);
	}
	/**
	* POSTX-S
	* @param path - API
	* @param a1Cookie - a1 cookie
	* @param clientType -  'xhs-pc-web'
	* @param body - 
	* @returns X-S
	*/
	static generateXSPost(path2, a1Cookie, clientType = "xhs-pc-web", body = {}) {
		return this.client.signXsPost(path2, a1Cookie, clientType, body);
	}
	/**
	* X-S
	* @param url - URL
	* @param body - 
	* @param userAgent - User-Agent
	* @param method -  'POST'
	* @param a1Cookie - a1 cookie
	* @returns X-S
	*/
	static generateXS(url$1, body, userAgent, method = "POST", a1Cookie = "") {
		try {
			const urlObj = new URL(url$1);
			const path2 = urlObj.pathname + urlObj.search;
			if (method.toUpperCase() === "GET") {
				const params = typeof body === "object" ? body : {};
				return this.generateXSGet(path2, a1Cookie, "xhs-pc-web", params);
			} else {
				const requestBody = typeof body === "object" ? body : {};
				return this.generateXSPost(path2, a1Cookie, "xhs-pc-web", requestBody);
			}
		} catch (error) {
			console.error("X-S:", error);
			throw new Error(`\u7B7E\u540D\u751F\u6210\u5931\u8D25: ${error}`);
		}
	}
	/**
	* X-S-Common
	* @param length - 
	* @returns Base64
	*/
	static generateXSCommon(length = 945) {
		return crypto.randomBytes(length).toString("base64").replace(/=+$/, "");
	}
	/**
	* X-T
	* @returns 
	*/
	static generateXT() {
		return Date.now().toString();
	}
	/**
	* X-B3-Traceid
	* @returns 16
	*/
	static generateXB3Traceid() {
		return Array.from({ length: 16 }, () => "abcdef0123456789"[Math.floor(Math.random() * 16)]).join("");
	}
	/**
	* cookiea1
	* @param cookieString - cookie
	* @returns a1 cookie
	*/
	static extractA1FromCookie(cookieString) {
		const match = cookieString.match(/a1=([^;]+)/);
		return match ? match[1] : "";
	}
	/**
	* ID
	* @returns ID
	*/
	static getSearchId = () => (BigInt(Date.now()) << 64n) + BigInt(Math.floor(Math.random() * 2147483646)).toString(36);
};
var SearchSortType = /* @__PURE__ */ ((SearchSortType2) => {
	SearchSortType2["GENERAL"] = "general";
	SearchSortType2["MOST_POPULAR"] = "popularity_descending";
	SearchSortType2["LATEST"] = "time_descending";
	return SearchSortType2;
})(SearchSortType || {});
var SearchNoteType = /* @__PURE__ */ ((SearchNoteType2) => {
	SearchNoteType2[SearchNoteType2["ALL"] = 0] = "ALL";
	SearchNoteType2[SearchNoteType2["VIDEO"] = 1] = "VIDEO";
	SearchNoteType2[SearchNoteType2["IMAGE"] = 2] = "IMAGE";
	return SearchNoteType2;
})(SearchNoteType || {});
var buildQueryString2 = (params) => {
	return Object.entries(params).filter(([_, value]) => value !== void 0 && value !== null).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join("&");
};
var xiaohongshuApiUrls = {
	(data2 = {}) {
		return {
			apiPath: "/api/sns/web/v1/homefeed",
			Url: "https://edith.xiaohongshu.com/api/sns/web/v1/homefeed",
			Body: {
				cursor_score: data2.cursor_score || "1.7599348899670024E9",
				num: data2.num || 33,
				refresh_type: data2.refresh_type || 3,
				note_index: data2.note_index || 33,
				category: data2.category || "homefeed_recommend",
				search_key: data2.search_key || "",
				image_formats: [
					"jpg",
					"webp",
					"avif"
				]
			}
		};
	},
	(data2) {
		return {
			apiPath: "/api/sns/web/v1/feed",
			Url: "https://edith.xiaohongshu.com/api/sns/web/v1/feed",
			Body: {
				source_note_id: data2.note_id,
				image_formats: [
					"jpg",
					"webp",
					"avif"
				],
				extra: { need_body_topic: "1" },
				xsec_source: "pc_feed",
				xsec_token: data2.xsec_token
			}
		};
	},
	(data2) {
		return {
			apiPath: "/api/sns/web/v2/comment/page",
			Url: `https://edith.xiaohongshu.com/api/sns/web/v2/comment/page?${buildQueryString2({
				note_id: data2.note_id,
				cursor: data2.cursor || "",
				image_formats: [
					"jpg",
					"webp",
					"avif"
				].join(","),
				xsec_token: data2.xsec_token
			})}`
		};
	},
	(data2) {
		return {
			apiPath: "/api/sns/web/v1/user/otherinfo",
			Url: `https://www.xiaohongshu.com/user/profile/${data2.user_id}`
		};
	},
	(data2) {
		return {
			apiPath: "/api/sns/web/v1/user_posted",
			Url: `https://edith.xiaohongshu.com/api/sns/web/v1/user_posted?${buildQueryString2({
				user_id: data2.user_id,
				cursor: data2.cursor || "",
				num: data2.num || 30,
				image_formats: [
					"jpg",
					"webp",
					"avif"
				].join(","),
				xsec_source: "pc_feed"
			})}`
		};
	},
	(data2) {
		return {
			apiPath: "/api/im/redmoji/detail",
			Url: "https://edith.xiaohongshu.com/api/im/redmoji/detail"
		};
	},
	(data2) {
		return {
			apiPath: "/api/sns/web/v1/search/notes",
			Body: {
				keyword: data2.keyword,
				page: data2.page || 1,
				page_size: data2.page_size || 20,
				sort: "general",
				note_type: 0,
				search_id: xiaohongshuSign.getSearchId(),
				image_formats: [
					"jpg",
					"webp",
					"avif"
				]
			},
			Url: "https://edith.xiaohongshu.com/api/sns/web/v1/search/notes"
		};
	}
};
var createXiaohongshuApiUrls = () => {
	return xiaohongshuApiUrls;
};
var SearchSortTypeValues = Object.values(SearchSortType).filter((v) => typeof v === "string");
var SearchNoteTypeValues = Object.values(SearchNoteType).filter((v) => typeof v === "string");
var XiaohongshuValidationSchemas = {
	: object({
		methodType: literal("", { error: "\"\"" }),
		cursor_score: string({ error: "cursor_score" }).optional(),
		num: number$1({ error: "" }).min(1, { error: "1" }).max(100, { error: "100" }).optional(),
		refresh_type: number$1({ error: "refresh_type" }).optional(),
		note_index: number$1({ error: "note_index" }).optional(),
		category: string({ error: "category" }).optional(),
		search_key: string({ error: "search_key" }).optional()
	}),
	: object({
		methodType: literal("", { error: "\"\"" }),
		note_id: string({ error: "note_id" }),
		xsec_token: string({ error: "xsec_token" })
	}),
	: object({
		methodType: literal("", { error: "\"\"" }),
		note_id: string({ error: "note_id" }),
		cursor: string({ error: "cursor" }).optional(),
		xsec_token: string({ error: "xsec_token" })
	}),
	: object({
		methodType: literal("", { error: "\"\"" }),
		user_id: string({ error: "user_id" })
	}),
	: object({
		methodType: literal("", { error: "\"\"" }),
		user_id: string({ error: "user_id" }),
		cursor: string({ error: "cursor" }).optional(),
		num: number$1({ error: "" }).min(1, { error: "1" }).max(100, { error: "100" }).optional()
	}),
	: object({ methodType: literal("", { error: "\"\"" }) }),
	: object({
		methodType: literal("", { error: "\"\"" }),
		keyword: string({ error: "keyword" }),
		page: number$1({ error: "page" }).min(1, { error: "page1" }).optional(),
		page_size: number$1({ error: "page_size" }).min(1, { error: "page_size1" }).max(100, { error: "page_size100" }).optional(),
		sort: _enum(SearchSortTypeValues, { error: "" }).optional(),
		note_type: _enum(SearchNoteTypeValues, { error: "" }).optional()
	})
};
var validateXiaohongshuParams = (methodType, params) => {
	return XiaohongshuValidationSchemas[methodType].parse(typeof params === "object" && params !== null ? {
		methodType,
		...params
	} : {
		methodType,
		params
	});
};
var validateDouyinParams = (methodType, params) => {
	return DouyinValidationSchemas2[methodType].parse(typeof params === "object" && params !== null ? {
		methodType,
		...params
	} : {
		methodType,
		params
	});
};
var validateBilibiliParams = (methodType, params) => {
	return BilibiliValidationSchemas2[methodType].parse(typeof params === "object" && params !== null ? {
		methodType,
		...params
	} : {
		methodType,
		params
	});
};
var validateKuaishouParams = (methodType, params) => {
	return KuaishouValidationSchemas2[methodType].parse(typeof params === "object" && params !== null ? {
		methodType,
		...params
	} : {
		methodType,
		params
	});
};
var createSuccessResponse$1 = (data2, message, code = 200) => {
	return {
		success: true,
		data: data2,
		message,
		code,
		error: void 0
	};
};
var createErrorResponse = (error, message, code = 500) => {
	return {
		success: false,
		error,
		message,
		code,
		data: void 0
	};
};
var XiaohongshuData = async (data2, cookie$1, requestConfig) => {
	const defHeaders = getXiaohongshuDefaultConfig(cookie$1)["headers"];
	const baseRequestConfig = {
		method: "POST",
		timeout: 1e4,
		...requestConfig,
		headers: { ...defHeaders }
	};
	const xiaohongshuApiUrls2 = createXiaohongshuApiUrls();
	switch (data2.methodType) {
		case "": return await GlobalGetData4(data2.methodType, {
			...baseRequestConfig,
			url: xiaohongshuApiUrls2.(data2).Url,
			data: JSON.stringify(xiaohongshuApiUrls2.(data2).Body),
			headers: {
				...baseRequestConfig.headers,
				"x-s": xiaohongshuSign.generateXSPost(xiaohongshuApiUrls2.(data2).apiPath, xiaohongshuSign.extractA1FromCookie(cookie$1 || ""), "xhs-pc-web", xiaohongshuApiUrls2.(data2).Body),
				"x-s-common": xiaohongshuSign.generateXSCommon(),
				"x-t": xiaohongshuSign.generateXT()
			}
		});
		case "": return await GlobalGetData4(data2.methodType, {
			...baseRequestConfig,
			url: xiaohongshuApiUrls2.(data2).Url,
			data: xiaohongshuApiUrls2.(data2).Body,
			headers: {
				...baseRequestConfig.headers,
				"x-s": xiaohongshuSign.generateXSPost(xiaohongshuApiUrls2.(data2).apiPath, xiaohongshuSign.extractA1FromCookie(cookie$1 || ""), "xhs-pc-web", xiaohongshuApiUrls2.(data2).Body),
				"x-s-common": xiaohongshuSign.generateXSCommon(),
				"x-t": xiaohongshuSign.generateXT()
			}
		});
		case "": {
			const baseRequestConfig2 = {
				method: "GET",
				timeout: 1e4,
				...requestConfig,
				headers: { ...defHeaders }
			};
			return await GlobalGetData4(data2.methodType, {
				...baseRequestConfig2,
				url: xiaohongshuApiUrls2.(data2).Url,
				headers: {
					...baseRequestConfig2.headers,
					"x-s": xiaohongshuSign.generateXSGet(xiaohongshuApiUrls2.(data2).apiPath, xiaohongshuSign.extractA1FromCookie(cookie$1 || ""), "xhs-pc-web"),
					"x-s-common": xiaohongshuSign.generateXSCommon(),
					"x-t": xiaohongshuSign.generateXT()
				}
			});
		}
		case "": {
			const baseRequestConfig2 = {
				method: "GET",
				timeout: 1e4,
				...requestConfig,
				headers: { ...defHeaders }
			};
			return {
				code: 0,
				data: extractCreatorInfoFromHtml(await GlobalGetData4(data2.methodType, {
					...baseRequestConfig2,
					url: xiaohongshuApiUrls2.(data2).Url,
					headers: {
						...baseRequestConfig2.headers,
						"x-s": xiaohongshuSign.generateXSGet(xiaohongshuApiUrls2.(data2).apiPath, xiaohongshuSign.extractA1FromCookie(cookie$1 || ""), "xhs-pc-web"),
						"x-s-common": xiaohongshuSign.generateXSCommon(),
						"x-t": xiaohongshuSign.generateXT()
					}
				})),
				msg: ""
			};
		}
		case "": return await GlobalGetData4(data2.methodType, {
			...baseRequestConfig,
			method: "GET",
			url: xiaohongshuApiUrls2.(data2).Url,
			headers: {
				...baseRequestConfig.headers,
				"x-b3-traceid": xiaohongshuSign.generateXB3Traceid(),
				"x-s": xiaohongshuSign.generateXSGet(xiaohongshuApiUrls2.(data2).apiPath, xiaohongshuSign.extractA1FromCookie(cookie$1 || ""), "xhs-pc-web"),
				"x-s-common": xiaohongshuSign.generateXSCommon(),
				"x-t": xiaohongshuSign.generateXT()
			}
		});
		case "": {
			const baseRequestConfig2 = {
				method: "GET",
				timeout: 1e4,
				...requestConfig,
				headers: { ...defHeaders }
			};
			return await GlobalGetData4(data2.methodType, {
				...baseRequestConfig2,
				url: xiaohongshuApiUrls2.(data2).Url,
				headers: {
					...baseRequestConfig2.headers,
					"x-s": xiaohongshuSign.generateXSGet(xiaohongshuApiUrls2.(data2).apiPath, xiaohongshuSign.extractA1FromCookie(cookie$1 || ""), "xhs-pc-web"),
					"x-s-common": xiaohongshuSign.generateXSCommon(),
					"x-t": xiaohongshuSign.generateXT()
				}
			});
		}
		case "": return await GlobalGetData4(data2.methodType, {
			...baseRequestConfig,
			url: xiaohongshuApiUrls2.(data2).Url,
			data: xiaohongshuApiUrls2.(data2).Body,
			headers: {
				...baseRequestConfig.headers,
				"x-s": xiaohongshuSign.generateXSPost(xiaohongshuApiUrls2.(data2).apiPath, xiaohongshuSign.extractA1FromCookie(cookie$1 || ""), "xhs-pc-web"),
				"x-s-common": xiaohongshuSign.generateXSCommon(),
				"x-t": xiaohongshuSign.generateXT()
			}
		});
		default: throw new Error(`\u672A\u77E5\u7684\u5C0F\u7EA2\u4E66\u6570\u636E\u63A5\u53E3: \u300C${logger$1.red(data2.methodType)}\u300D`);
	}
};
var GlobalGetData4 = async (methodType, config$2) => {
	var _a;
	try {
		const response$2 = await fetchData(config$2);
		if (typeof response$2 === "string" && response$2.includes("<html>")) return response$2;
		if (response$2.code !== 0) throw new Error(`API\u8BF7\u6C42\u5931\u8D25: ${((_a = response$2.data) == null ? void 0 : _a.msg) || response$2.msg || ""}, code: ${response$2.code}`);
		return response$2;
	} catch (error) {
		logger$1.error(`\u5C0F\u7EA2\u4E66API\u8BF7\u6C42\u5931\u8D25 [${methodType}]:`, error.message);
		return {
			code: 500,
			message: "error",
			data: null,
			amagiError: {
				errorDescription: error.message || "",
				requestType: methodType,
				requestUrl: config$2.url || ""
			},
			amagiMessage: `\u5C0F\u7EA2\u4E66API\u8BF7\u6C42\u5931\u8D25: ${error.message}`
		};
	}
};
async function getDouyinData(methodType, optionsOrCookie, cookieOrOptions, requestConfig) {
	try {
		let options;
		let cookie$1;
		let config$2;
		if (typeof optionsOrCookie === "string") {
			cookie$1 = optionsOrCookie;
			options = cookieOrOptions;
			config$2 = requestConfig;
		} else {
			options = optionsOrCookie;
			cookie$1 = cookieOrOptions;
			config$2 = requestConfig;
		}
		const { typeMode: _,...validationOptions } = options || {};
		const rawData = await DouyinData({ ...validateDouyinParams(methodType, validationOptions) }, cookie$1, config$2);
		if (rawData.data === "" || rawData.status_code !== 0) return createErrorResponse(rawData.amagiError, rawData.status_msg || "");
		return createSuccessResponse$1(rawData, "", 200);
	} catch (error) {
		const errorMessage = error instanceof Error ? error.message : "";
		throw new Error(`\u6296\u97F3\u6570\u636E\u83B7\u53D6\u5931\u8D25: ${errorMessage}`);
	}
}
async function getBilibiliData(methodType, optionsOrCookie, cookieOrOptions, requestConfig) {
	try {
		let options;
		let cookie$1;
		if (typeof optionsOrCookie === "string") {
			cookie$1 = optionsOrCookie;
			options = cookieOrOptions;
		} else {
			options = optionsOrCookie;
			cookie$1 = cookieOrOptions;
		}
		const { typeMode: _,...validationOptions } = options || {};
		const rawData = await fetchBilibili({ ...validateBilibiliParams(methodType, validationOptions) }, cookie$1);
		if (rawData.code !== 0) return createErrorResponse(rawData.amagiError, "B");
		return createSuccessResponse$1(rawData, "", 200);
	} catch (error) {
		const errorMessage = error instanceof Error ? error.message : "";
		throw new Error(`B\u7AD9\u6570\u636E\u83B7\u53D6\u5931\u8D25: ${errorMessage}`);
	}
}
async function getKuaishouData(methodType, optionsOrCookie, cookieOrOptions, requestConfig) {
	try {
		let options;
		let cookie$1;
		if (typeof optionsOrCookie === "string") {
			cookie$1 = optionsOrCookie;
			options = cookieOrOptions;
		} else {
			options = optionsOrCookie;
			cookie$1 = cookieOrOptions;
		}
		const { typeMode: _,...validationOptions } = options || {};
		const rawData = await KuaishouData({ ...validateKuaishouParams(methodType, validationOptions) }, cookie$1);
		if (rawData.code && Object.values(kuaishouAPIErrorCode).includes(rawData.code)) return createErrorResponse(rawData.amagiError, "");
		return createSuccessResponse$1(rawData, "", 200);
	} catch (error) {
		const errorMessage = error instanceof Error ? error.message : "";
		throw new Error(`\u5FEB\u624B\u6570\u636E\u83B7\u53D6\u5931\u8D25: ${errorMessage}`);
	}
}
async function getXiaohongshuData(methodType, optionsOrCookie, cookieOrOptions, requestConfig) {
	try {
		let options;
		let cookie$1;
		if (typeof optionsOrCookie === "string") {
			cookie$1 = optionsOrCookie;
			options = cookieOrOptions;
		} else {
			options = optionsOrCookie;
			cookie$1 = cookieOrOptions;
		}
		const { typeMode: _,...validationOptions } = options || {};
		const rawData = await XiaohongshuData({ ...validateXiaohongshuParams(methodType, validationOptions) }, cookie$1);
		if (rawData.code && Object.values(xiaohongshuAPIErrorCode).includes(rawData.code)) return createErrorResponse(rawData.amagiError, "");
		return createSuccessResponse$1(rawData, "", 200);
	} catch (error) {
		const errorMessage = error instanceof Error ? error.message : "";
		throw new Error(`\u5C0F\u7EA2\u4E66\u6570\u636E\u83B7\u53D6\u5931\u8D25: ${errorMessage}`);
	}
}
var createBilibiliApiMethod = (methodType) => {
	return async (options, cookie$1) => {
		return await getBilibiliData(methodType, options, cookie$1);
	};
};
var createBoundBilibiliApiMethod = (methodType, cookie$1) => {
	return async (options) => {
		return await getBilibiliData(methodType, options, cookie$1);
	};
};
var bilibili = {
	getVideoInfo: createBilibiliApiMethod(""),
	getVideoStream: createBilibiliApiMethod(""),
	getComments: createBilibiliApiMethod(""),
	getUserProfile: createBilibiliApiMethod(""),
	getUserDynamic: createBilibiliApiMethod(""),
	getEmojiList: createBilibiliApiMethod("Emoji"),
	getBangumiInfo: createBilibiliApiMethod(""),
	getBangumiStream: createBilibiliApiMethod(""),
	getDynamicInfo: createBilibiliApiMethod(""),
	getDynamicCard: createBilibiliApiMethod(""),
	getLiveRoomDetail: createBilibiliApiMethod(""),
	getLiveRoomInitInfo: createBilibiliApiMethod(""),
	getLoginBasicInfo: createBilibiliApiMethod(""),
	getLoginQrcode: createBilibiliApiMethod(""),
	checkQrcodeStatus: createBilibiliApiMethod(""),
	getUserTotalPlayCount: createBilibiliApiMethod("UP"),
	convertAvToBv: createBilibiliApiMethod("AVBV"),
	convertBvToAv: createBilibiliApiMethod("BVAV")
};
var createBoundBilibiliApi = (cookie$1, requestConfig) => {
	return {
		getVideoInfo: createBoundBilibiliApiMethod("", cookie$1),
		getVideoStream: createBoundBilibiliApiMethod("", cookie$1),
		getComments: createBoundBilibiliApiMethod("", cookie$1),
		getUserProfile: createBoundBilibiliApiMethod("", cookie$1),
		getUserDynamic: createBoundBilibiliApiMethod("", cookie$1),
		getEmojiList: createBoundBilibiliApiMethod("Emoji", cookie$1),
		getBangumiInfo: createBoundBilibiliApiMethod("", cookie$1),
		getBangumiStream: createBoundBilibiliApiMethod("", cookie$1),
		getDynamicInfo: createBoundBilibiliApiMethod("", cookie$1),
		getDynamicCard: createBoundBilibiliApiMethod("", cookie$1),
		getLiveRoomDetail: createBoundBilibiliApiMethod("", cookie$1),
		getLiveRoomInitInfo: createBoundBilibiliApiMethod("", cookie$1),
		getLoginBasicInfo: createBoundBilibiliApiMethod("", cookie$1),
		getLoginQrcode: createBoundBilibiliApiMethod("", cookie$1),
		checkQrcodeStatus: createBoundBilibiliApiMethod("", cookie$1),
		getUserTotalPlayCount: createBoundBilibiliApiMethod("UP", cookie$1),
		convertAvToBv: createBoundBilibiliApiMethod("AVBV", cookie$1),
		convertBvToAv: createBoundBilibiliApiMethod("BVAV", cookie$1)
	};
};
var ApiError = class extends Error {
	code;
	platform;
	/**
	* API
	* @param message - 
	* @param code - 
	* @param platform - 
	*/
	constructor(message, code = 500, platform = "unknown") {
		super(message);
		this.name = "ApiError";
		this.code = code;
		this.platform = platform;
	}
};
var ValidationError = class _ValidationError extends Error {
	errors;
	requestPath;
	/**
	* 
	* @param message - 
	* @param errors - 
	* @param requestPath - HTTP
	*/
	constructor(message, errors, requestPath) {
		super(message);
		this.name = "ValidationError";
		this.errors = errors;
		this.requestPath = requestPath;
	}
	/**
	* Zod
	* @param zodError - Zod
	* @param requestPath - HTTP
	* @returns 
	*/
	static fromZodError(zodError, requestPath) {
		return new _ValidationError("", zodError.issues.map((err) => ({
			field: err.path.join("."),
			message: err.message
		})), requestPath);
	}
};
var handleError = (error, requestPath) => {
	if (error instanceof ValidationError) return {
		code: 400,
		message: error.message,
		data: null,
		errors: error.errors,
		requestPath: error.requestPath || requestPath
	};
	if (error instanceof ApiError) return {
		code: error.code,
		message: error.message,
		data: null,
		platform: error.platform,
		requestPath
	};
	if (error instanceof ZodError) return handleError(ValidationError.fromZodError(error, requestPath), requestPath);
	return {
		code: 500,
		message: error instanceof Error ? error.message : "",
		data: null,
		requestPath
	};
};
var createValidationMiddleware = (validateFn, methodType) => {
	return (req, res, next) => {
		try {
			req.validatedParams = validateFn(methodType, {
				...req.query,
				...req.body
			});
			next();
		} catch (error) {
			const errorResponse = handleError(error, req.originalUrl);
			res.status(errorResponse.code || 500).json(errorResponse);
		}
	};
};
var createDouyinValidationMiddleware = (methodType) => createValidationMiddleware(validateDouyinParams, methodType);
var createBilibiliValidationMiddleware = (methodType) => createValidationMiddleware(validateBilibiliParams, methodType);
var createKuaishouValidationMiddleware = (methodType) => createValidationMiddleware(validateKuaishouParams, methodType);
var createXiaohongshuValidationMiddleware = (methodType) => createValidationMiddleware(validateXiaohongshuParams, methodType);
var createBilibiliRouteHandler = (dataFetcher, methodType, cookie$1, requestConfig = getBilibiliDefaultConfig(cookie$1)) => {
	return async (req, res) => {
		try {
			const result = await dataFetcher(methodType, req.validatedParams, cookie$1, requestConfig);
			res.json({
				...result,
				requestPath: req.originalUrl
			});
		} catch (error) {
			const errorResponse = handleError(error);
			res.status(errorResponse.code || 500).json({
				...errorResponse,
				requestPath: req.originalUrl
			});
		}
	};
};
var createBilibiliRoutes = (cookie$1, requestConfig = getBilibiliDefaultConfig(cookie$1)) => {
	const router$1 = Router();
	router$1.get("/fetch_one_video", createBilibiliValidationMiddleware(""), createBilibiliRouteHandler(getBilibiliData, "", cookie$1, requestConfig));
	router$1.get("/fetch_video_playurl", createBilibiliValidationMiddleware(""), createBilibiliRouteHandler(getBilibiliData, "", cookie$1, requestConfig));
	router$1.get("/fetch_work_comments", createBilibiliValidationMiddleware(""), createBilibiliRouteHandler(getBilibiliData, "", cookie$1, requestConfig));
	router$1.get("/fetch_user_profile", createBilibiliValidationMiddleware(""), createBilibiliRouteHandler(getBilibiliData, "", cookie$1, requestConfig));
	router$1.get("/fetch_user_dynamic", createBilibiliValidationMiddleware(""), createBilibiliRouteHandler(getBilibiliData, "", cookie$1, requestConfig));
	router$1.get("/fetch_emoji_list", createBilibiliValidationMiddleware("Emoji"), createBilibiliRouteHandler(getBilibiliData, "Emoji", cookie$1, requestConfig));
	router$1.get("/fetch_bangumi_video_info", createBilibiliValidationMiddleware(""), createBilibiliRouteHandler(getBilibiliData, "", cookie$1, requestConfig));
	router$1.get("/fetch_bangumi_video_playurl", createBilibiliValidationMiddleware(""), createBilibiliRouteHandler(getBilibiliData, "", cookie$1, requestConfig));
	router$1.get("/fetch_dynamic_info", createBilibiliValidationMiddleware(""), createBilibiliRouteHandler(getBilibiliData, "", cookie$1, requestConfig));
	router$1.get("/fetch_dynamic_card", createBilibiliValidationMiddleware(""), createBilibiliRouteHandler(getBilibiliData, "", cookie$1, requestConfig));
	router$1.get("/fetch_live_room_detail", createBilibiliValidationMiddleware(""), createBilibiliRouteHandler(getBilibiliData, "", cookie$1, requestConfig));
	router$1.get("/fetch_liveroom_def", createBilibiliValidationMiddleware(""), createBilibiliRouteHandler(getBilibiliData, "", cookie$1, requestConfig));
	router$1.get("/login_basic_info", createBilibiliValidationMiddleware(""), createBilibiliRouteHandler(getBilibiliData, "", cookie$1, requestConfig));
	router$1.get("/new_login_qrcode", createBilibiliValidationMiddleware(""), createBilibiliRouteHandler(getBilibiliData, "", cookie$1, requestConfig));
	router$1.get("/check_qrcode", createBilibiliValidationMiddleware(""), createBilibiliRouteHandler(getBilibiliData, "", cookie$1, requestConfig));
	router$1.get("/fetch_user_full_view", createBilibiliValidationMiddleware("UP"), createBilibiliRouteHandler(getBilibiliData, "UP", cookie$1, requestConfig));
	router$1.get("/av_to_bv", createBilibiliValidationMiddleware("AVBV"), createBilibiliRouteHandler(getBilibiliData, "AVBV", cookie$1, requestConfig));
	router$1.get("/bv_to_av", createBilibiliValidationMiddleware("BVAV"), createBilibiliRouteHandler(getBilibiliData, "BVAV", cookie$1, requestConfig));
	return router$1;
};
var bilibiliUtils = {
	sign: {
		wbi_sign,
		av2bv,
		bv2av
	},
	bilibiliApiUrls,
	api: bilibili
};
var createDouyinApiMethod = (methodType) => {
	return async (options, cookie$1, requestConfig) => {
		return await getDouyinData(methodType, options, cookie$1, requestConfig);
	};
};
var createBoundDouyinApiMethod = (methodType, cookie$1, requestConfig) => {
	return async (options) => {
		return await getDouyinData(methodType, options, cookie$1, requestConfig);
	};
};
var douyin = {
	getTextWorkInfo: createDouyinApiMethod(""),
	getWorkInfo: createDouyinApiMethod(""),
	getVideoWorkInfo: createDouyinApiMethod(""),
	getImageAlbumWorkInfo: createDouyinApiMethod(""),
	getSlidesWorkInfo: createDouyinApiMethod(""),
	getComments: createDouyinApiMethod(""),
	getCommentReplies: createDouyinApiMethod(""),
	getUserProfile: createDouyinApiMethod(""),
	getEmojiList: createDouyinApiMethod("Emoji"),
	getEmojiProList: createDouyinApiMethod(""),
	getUserVideos: createDouyinApiMethod(""),
	getMusicInfo: createDouyinApiMethod(""),
	getSuggestWords: createDouyinApiMethod(""),
	search: createDouyinApiMethod(""),
	getLiveRoomInfo: createDouyinApiMethod(""),
	getDanmaku: createDouyinApiMethod("")
};
var createBoundDouyinApi = (cookie$1, requestConfig) => {
	return {
		getTextWorkInfo: createBoundDouyinApiMethod("", cookie$1, requestConfig),
		getWorkInfo: createBoundDouyinApiMethod("", cookie$1, requestConfig),
		getVideoWorkInfo: createBoundDouyinApiMethod("", cookie$1, requestConfig),
		getImageAlbumWorkInfo: createBoundDouyinApiMethod("", cookie$1, requestConfig),
		getSlidesWorkInfo: createBoundDouyinApiMethod("", cookie$1, requestConfig),
		getComments: createBoundDouyinApiMethod("", cookie$1, requestConfig),
		getCommentReplies: createBoundDouyinApiMethod("", cookie$1, requestConfig),
		getUserProfile: createBoundDouyinApiMethod("", cookie$1, requestConfig),
		getEmojiList: createBoundDouyinApiMethod("Emoji", cookie$1, requestConfig),
		getEmojiProList: createBoundDouyinApiMethod("", cookie$1, requestConfig),
		getUserVideos: createBoundDouyinApiMethod("", cookie$1, requestConfig),
		getMusicInfo: createBoundDouyinApiMethod("", cookie$1, requestConfig),
		getSuggestWords: createBoundDouyinApiMethod("", cookie$1, requestConfig),
		search: createBoundDouyinApiMethod("", cookie$1, requestConfig),
		getLiveRoomInfo: createBoundDouyinApiMethod("", cookie$1, requestConfig),
		getDanmaku: createBoundDouyinApiMethod("", cookie$1, requestConfig)
	};
};
var createDouyinRouteHandler = (dataFetcher, methodType, cookie$1, requestConfig = getDouyinDefaultConfig(cookie$1)) => {
	return async (req, res) => {
		try {
			const result = await dataFetcher(methodType, req.validatedParams, cookie$1, requestConfig);
			res.json({
				...result,
				requestPath: req.originalUrl
			});
		} catch (error) {
			const errorResponse = handleError(error);
			res.status(errorResponse.code || 500).json({
				...errorResponse,
				requestPath: req.originalUrl
			});
		}
	};
};
var createDouyinRoutes = (cookie$1, requestConfig = getDouyinDefaultConfig(cookie$1)) => {
	const router$1 = Router();
	router$1.get("/fetch_one_work", createDouyinValidationMiddleware(""), createDouyinRouteHandler(getDouyinData, "", cookie$1, requestConfig));
	router$1.get("/fetch_one_work", createDouyinValidationMiddleware(""), createDouyinRouteHandler(getDouyinData, "", cookie$1, requestConfig));
	router$1.get("/fetch_one_work", createDouyinValidationMiddleware(""), createDouyinRouteHandler(getDouyinData, "", cookie$1, requestConfig));
	router$1.get("/fetch_one_work", createDouyinValidationMiddleware(""), createDouyinRouteHandler(getDouyinData, "", cookie$1, requestConfig));
	router$1.get("/fetch_work_comments", createDouyinValidationMiddleware(""), createDouyinRouteHandler(getDouyinData, "", cookie$1, requestConfig));
	router$1.get("/fetch_user_info", createDouyinValidationMiddleware(""), createDouyinRouteHandler(getDouyinData, "", cookie$1, requestConfig));
	router$1.get("/fetch_user_post_videos", createDouyinValidationMiddleware(""), createDouyinRouteHandler(getDouyinData, "", cookie$1, requestConfig));
	router$1.get("/fetch_search_info", createDouyinValidationMiddleware(""), createDouyinRouteHandler(getDouyinData, "", cookie$1, requestConfig));
	router$1.get("/fetch_suggest_words", createDouyinValidationMiddleware(""), createDouyinRouteHandler(getDouyinData, "", cookie$1, requestConfig));
	router$1.get("/fetch_music_work", createDouyinValidationMiddleware(""), createDouyinRouteHandler(getDouyinData, "", cookie$1, requestConfig));
	router$1.get("/fetch_emoji_list", createDouyinValidationMiddleware("Emoji"), createDouyinRouteHandler(getDouyinData, "Emoji", cookie$1, requestConfig));
	router$1.get("/fetch_emoji_pro_list", createDouyinValidationMiddleware(""), createDouyinRouteHandler(getDouyinData, "", cookie$1, requestConfig));
	router$1.get("/fetch_user_live_videos", createDouyinValidationMiddleware(""), createDouyinRouteHandler(getDouyinData, "", cookie$1, requestConfig));
	router$1.get("/fetch_video_comment_replies", createDouyinValidationMiddleware(""), createDouyinRouteHandler(getDouyinData, "", cookie$1, requestConfig));
	router$1.get("/fetch_work_danmaku", createDouyinValidationMiddleware(""), createDouyinRouteHandler(getDouyinData, "", cookie$1, requestConfig));
	return router$1;
};
var douyinUtils = {
	sign: douyinSign,
	douyinApiUrls,
	api: douyin
};
var createKuaishouRouteHandler = (dataFetcher, methodType, cookie$1, requestConfig = getKuaishouDefaultConfig(cookie$1)) => {
	return async (req, res) => {
		try {
			const result = await dataFetcher(methodType, req.validatedParams, cookie$1, requestConfig);
			res.json({
				...result,
				requestPath: req.originalUrl
			});
		} catch (error) {
			const errorResponse = handleError(error);
			res.status(errorResponse.code || 500).json({
				...errorResponse,
				requestPath: req.originalUrl
			});
		}
	};
};
var createKuaishouRoutes = (cookie$1, requestConfig = getKuaishouDefaultConfig(cookie$1)) => {
	const router$1 = Router();
	router$1.get("/fetch_one_work", createKuaishouValidationMiddleware(""), createKuaishouRouteHandler(getKuaishouData, "", cookie$1, requestConfig));
	router$1.get("/fetch_work_comments", createKuaishouValidationMiddleware(""), createKuaishouRouteHandler(getKuaishouData, "", cookie$1, requestConfig));
	router$1.get("/fetch_emoji_list", createKuaishouValidationMiddleware("Emoji"), createKuaishouRouteHandler(getKuaishouData, "Emoji", cookie$1, requestConfig));
	return router$1;
};
var createKuaishouApiMethod = (methodType) => {
	return async (options, cookie$1) => {
		return await getKuaishouData(methodType, options, cookie$1);
	};
};
var createBoundKuaishouApiMethod = (methodType, cookie$1) => {
	return async (options) => {
		return await getKuaishouData(methodType, options, cookie$1);
	};
};
var kuaishou = {
	getWorkInfo: createKuaishouApiMethod(""),
	getComments: createKuaishouApiMethod(""),
	getEmojiList: createKuaishouApiMethod("Emoji")
};
var createBoundKuaishouApi = (cookie$1, requestConfig) => {
	return {
		getWorkInfo: createBoundKuaishouApiMethod("", cookie$1),
		getComments: createBoundKuaishouApiMethod("", cookie$1),
		getEmojiList: createBoundKuaishouApiMethod("Emoji", cookie$1)
	};
};
var kuaishouUtils = {
	kuaishouApiUrls,
	api: kuaishou
};
var createXiaohongshuApiMethod = (methodType) => {
	return async (options, cookie$1, requestConfig) => {
		return await getXiaohongshuData(methodType, options, cookie$1);
	};
};
var createBoundXiaohongshuApiMethod = (methodType, cookie$1, requestConfig) => {
	return async (options) => {
		return await getXiaohongshuData(methodType, options, cookie$1);
	};
};
var xiaohongshu = {
	getHomeFeed: createXiaohongshuApiMethod(""),
	getNote: createXiaohongshuApiMethod(""),
	getComments: createXiaohongshuApiMethod(""),
	getUser: createXiaohongshuApiMethod(""),
	getUserNotes: createXiaohongshuApiMethod(""),
	getSearchNotes: createXiaohongshuApiMethod(""),
	getEmojiList: createXiaohongshuApiMethod("")
};
var createBoundXiaohongshuApi = (cookie$1, requestConfig) => {
	return {
		getHomeFeed: createBoundXiaohongshuApiMethod("", cookie$1),
		getNote: createBoundXiaohongshuApiMethod("", cookie$1),
		getComments: createBoundXiaohongshuApiMethod("", cookie$1),
		getUser: createBoundXiaohongshuApiMethod("", cookie$1),
		getUserNotes: createBoundXiaohongshuApiMethod("", cookie$1),
		getSearchNotes: createBoundXiaohongshuApiMethod("", cookie$1),
		getEmojiList: createBoundXiaohongshuApiMethod("", cookie$1)
	};
};
var createXiaohongshuRouteHandler = (dataFetcher, methodType, cookie$1, requestConfig = getXiaohongshuDefaultConfig(cookie$1)) => {
	return async (req, res) => {
		try {
			const result = await dataFetcher(methodType, req.validatedParams, cookie$1, requestConfig);
			res.json({
				...result,
				requestPath: req.originalUrl
			});
		} catch (error) {
			const errorResponse = handleError(error);
			res.status(errorResponse.code || 500).json({
				...errorResponse,
				requestPath: req.originalUrl
			});
		}
	};
};
var createXiaohongshuRoutes = (cookie$1, requestConfig = getXiaohongshuDefaultConfig(cookie$1)) => {
	const router$1 = Router();
	router$1.get("/fetch_home_feed", createXiaohongshuValidationMiddleware(""), createXiaohongshuRouteHandler(getXiaohongshuData, "", cookie$1, requestConfig));
	router$1.get("/fetch_one_note", createXiaohongshuValidationMiddleware(""), createXiaohongshuRouteHandler(getXiaohongshuData, "", cookie$1, requestConfig));
	router$1.get("/fetch_note_comments", createXiaohongshuValidationMiddleware(""), createXiaohongshuRouteHandler(getXiaohongshuData, "", cookie$1, requestConfig));
	router$1.get("/fetch_user_profile", createXiaohongshuValidationMiddleware(""), createXiaohongshuRouteHandler(getXiaohongshuData, "", cookie$1, requestConfig));
	router$1.get("/fetch_user_notes", createXiaohongshuValidationMiddleware(""), createXiaohongshuRouteHandler(getXiaohongshuData, "", cookie$1, requestConfig));
	router$1.get("/fetch_emoji_list", createXiaohongshuValidationMiddleware(""), createXiaohongshuRouteHandler(getXiaohongshuData, "", cookie$1, requestConfig));
	router$1.get("/fetch_search_notes", createXiaohongshuValidationMiddleware(""), createXiaohongshuRouteHandler(getXiaohongshuData, "", cookie$1, requestConfig));
	return router$1;
};
var xiaohongshuUtils = {
	sign: xiaohongshuSign,
	xiaohongshuApiUrls,
	api: xiaohongshu
};
var createAmagiClient = (options) => {
	var _a, _b, _c, _d;
	const douyinCookie = ((_a = options == null ? void 0 : options.cookies) == null ? void 0 : _a.douyin) ?? "";
	const bilibiliCookie = ((_b = options == null ? void 0 : options.cookies) == null ? void 0 : _b.bilibili) ?? "";
	const kuaishouCookie = ((_c = options == null ? void 0 : options.cookies) == null ? void 0 : _c.kuaishou) ?? "";
	const xiaohongshuCookie = ((_d = options == null ? void 0 : options.cookies) == null ? void 0 : _d.xiaohongshu) ?? "";
	const requestConfig = (options == null ? void 0 : options.request) ?? {};
	const startServer = (port = 4567) => {
		const app$3 = app$1();
		app$3.use(app$1.json());
		app$3.use(app$1.urlencoded({ extended: true }));
		app$3.get("/", (_req, res) => {
			res.redirect(301, "https://amagi.apifox.cn");
		});
		app$3.get("/docs", (_req, res) => {
			res.redirect(301, "https://amagi.apifox.cn");
		});
		app$3.use("/api/douyin", createDouyinRoutes(douyinCookie, requestConfig));
		app$3.use("/api/bilibili", createBilibiliRoutes(bilibiliCookie, requestConfig));
		app$3.use("/api/kuaishou", createKuaishouRoutes(kuaishouCookie, requestConfig));
		app$3.use("/api/xiaohongshu", createXiaohongshuRoutes(xiaohongshuCookie, requestConfig));
		app$3.listen(port, "::", () => {
			logger$1.mark(`Amagi server listening on ${logger$1.green(`http://localhost:${port}`)} ${logger$1.yellow("API docs: https://amagi.apifox.cn ")}`);
		});
		return app$3;
	};
	const getDouyinDataWithCookie = async (methodType, options2) => {
		return await getDouyinData(methodType, options2, douyinCookie, requestConfig);
	};
	const getBilibiliDataWithCookie = async (methodType, options2) => {
		return await getBilibiliData(methodType, options2, bilibiliCookie);
	};
	const getKuaishouDataWithCookie = async (methodType, options2) => {
		return await getKuaishouData(methodType, options2, kuaishouCookie);
	};
	const getXiaohongshuDataWithCookie = async (methodType, options2) => {
		return await getXiaohongshuData(methodType, options2, xiaohongshuCookie);
	};
	return {
		startServer,
		getDouyinData: getDouyinDataWithCookie,
		getBilibiliData: getBilibiliDataWithCookie,
		getKuaishouData: getKuaishouDataWithCookie,
		getXiaohongshuData: getXiaohongshuDataWithCookie,
		douyin: {
			...douyinUtils,
			api: createBoundDouyinApi(douyinCookie, requestConfig)
		},
		bilibili: {
			...bilibiliUtils,
			api: createBoundBilibiliApi(bilibiliCookie)
		},
		kuaishou: {
			...kuaishouUtils,
			api: createBoundKuaishouApi(kuaishouCookie)
		},
		xiaohongshu: {
			...xiaohongshuUtils,
			api: createBoundXiaohongshuApi(xiaohongshuCookie)
		}
	};
};
var DynamicType = /* @__PURE__ */ ((DynamicType2) => {
	DynamicType2["AV"] = "DYNAMIC_TYPE_AV";
	DynamicType2["DRAW"] = "DYNAMIC_TYPE_DRAW";
	DynamicType2["WORD"] = "DYNAMIC_TYPE_WORD";
	DynamicType2["LIVE_RCMD"] = "DYNAMIC_TYPE_LIVE_RCMD";
	DynamicType2["FORWARD"] = "DYNAMIC_TYPE_FORWARD";
	return DynamicType2;
})(DynamicType || {});
var MajorType = /* @__PURE__ */ ((MajorType2) => {
	MajorType2["NONE"] = "MAJOR_TYPE_NONE";
	MajorType2["OPUS"] = "MAJOR_TYPE_OPUS";
	MajorType2["ARCHIVE"] = "MAJOR_TYPE_ARCHIVE";
	MajorType2["PGC"] = "MAJOR_TYPE_PGC";
	MajorType2["COURSES"] = "MAJOR_TYPE_COURSES";
	MajorType2["DRAW"] = "MAJOR_TYPE_DRAW";
	MajorType2["ARTICLE"] = "MAJOR_TYPE_ARTICLE";
	MajorType2["MUSIC"] = "MAJOR_TYPE_MUSIC";
	MajorType2["COMMON"] = "MAJOR_TYPE_COMMON";
	MajorType2["LIVE"] = "MAJOR_TYPE_LIVE";
	MajorType2["MEDIALIST"] = "MAJOR_TYPE_MEDIALIST";
	MajorType2["APPLET"] = "MAJOR_TYPE_APPLET";
	MajorType2["SUBSCRIPTION"] = "MAJOR_TYPE_SUBSCRIPTION";
	MajorType2["LIVE_RCMD"] = "MAJOR_TYPE_LIVE_RCMD";
	MajorType2["UGC_SEASON"] = "MAJOR_TYPE_UGC_SEASON";
	MajorType2["SUBSCRIPTION_NEW"] = "MAJOR_TYPE_SUBSCRIPTION_NEW";
	MajorType2["UPOWER_COMMON"] = "MAJOR_TYPE_UPOWER_COMMON";
	return MajorType2;
})(MajorType || {});
function CreateAmagiApp(options = {}) {
	if (!(this instanceof CreateAmagiApp)) return createAmagiClient(options);
	return createAmagiClient(options);
}
CreateAmagiApp.douyin = douyinUtils;
CreateAmagiApp.bilibili = bilibiliUtils;
CreateAmagiApp.kuaishou = kuaishouUtils;
CreateAmagiApp.xiaohongshu = xiaohongshuUtils;
CreateAmagiApp.getDouyinData = getDouyinData;
CreateAmagiApp.getBilibiliData = getBilibiliData;
CreateAmagiApp.getKuaishouData = getKuaishouData;
CreateAmagiApp.getXiaohongshuData = getXiaohongshuData;
var CreateApp = CreateAmagiApp;
var Client = CreateApp;
var amagi = Client;

//#endregion
//#region src/module/utils/Config.ts
var Cfg = class {
	/**  */
	dirCfgPath;
	/**  */
	defCfgPath;
	constructor() {
		this.dirCfgPath = `${karinPathBase}/${Root.pluginName}/config`;
		this.defCfgPath = `${Root.pluginPath}/config/default_config/`;
	}
	/**  */
	initCfg() {
		copyConfigSync(this.defCfgPath, this.dirCfgPath);
		const files = filesByExt(this.dirCfgPath, ".yaml", "name");
		for (const file$2 of files) {
			const config$2 = YAML.parseDocument(fs$1.readFileSync(`${this.dirCfgPath}/${file$2}`, "utf8"));
			const defConfig = YAML.parseDocument(fs$1.readFileSync(`${this.defCfgPath}/${file$2}`, "utf8"));
			const { differences, result } = this.mergeObjectsWithPriority(config$2, defConfig);
			if (differences) fs$1.writeFileSync(`${this.dirCfgPath}/${file$2}`, result.toString({ lineWidth: -1 }));
		}
		/**
		* @description 
		*/
		setTimeout(() => {
			filesByExt(this.dirCfgPath, ".yaml", "abs").forEach((file$2) => watch(file$2, (_old, _now) => {}));
		}, 2e3);
		return this;
	}
	/**
	* 
	* @param name 
	* @returns 
	*/
	getDefOrConfig(name) {
		const def = this.getYaml("default_config", name);
		const config$2 = this.getYaml("config", name);
		return {
			...def,
			...config$2
		};
	}
	/**  */
	async All() {
		const douyinDB$1 = await getDouyinDB();
		const bilibiliDB$1 = await getBilibiliDB();
		const allConfig = {};
		const files = fs$1.readdirSync(this.defCfgPath);
		for (const file$2 of files) {
			const fileName = path.basename(file$2, ".yaml");
			allConfig[fileName] = this.getDefOrConfig(fileName) || {};
		}
		if (allConfig.pushlist) try {
			if (allConfig.pushlist.douyin) for (const item of allConfig.pushlist.douyin) {
				const filterWords = await douyinDB$1.getFilterWords(item.sec_uid);
				const filterTags = await douyinDB$1.getFilterTags(item.sec_uid);
				const userInfo = await douyinDB$1.getDouyinUser(item.sec_uid);
				if (userInfo) item.filterMode = userInfo.filterMode || "blacklist";
				item.Keywords = filterWords;
				item.Tags = filterTags;
			}
			if (allConfig.pushlist.bilibili) for (const item of allConfig.pushlist.bilibili) {
				const filterWords = await bilibiliDB$1.getFilterWords(item.host_mid);
				const filterTags = await bilibiliDB$1.getFilterTags(item.host_mid);
				const userInfo = await bilibiliDB$1.getOrCreateBilibiliUser(item.host_mid);
				if (userInfo) item.filterMode = userInfo.filterMode || "blacklist";
				item.Keywords = filterWords;
				item.Tags = filterTags;
			}
		} catch (error) {
			logger.error(`: ${error}`);
		}
		return allConfig;
	}
	/**
	*  YAML 
	* @param type 
	* @param name 
	* @returns  YAML 
	*/
	getYaml(type$1, name) {
		return requireFileSync(type$1 === "config" ? `${this.dirCfgPath}/${name}.yaml` : `${this.defCfgPath}/${name}.yaml`, { force: true });
	}
	/**
	* 
	* @param name 
	* @param key 
	* @param value 
	* @param type  `config`
	*/
	Modify(name, key, value, type$1 = "config") {
		const path$3 = type$1 === "config" ? `${this.dirCfgPath}/${name}.yaml` : `${this.defCfgPath}/${name}.yaml`;
		const yamlData = YAML.parseDocument(fs$1.readFileSync(path$3, "utf8"));
		const keys = key.split(".");
		this.setNestedValue(yamlData.contents, keys, value);
		fs$1.writeFileSync(path$3, yamlData.toString({ lineWidth: -1 }), "utf8");
	}
	/**
	* 
	* @param name 
	* @param config 
	* @param type  `config`
	*/
	async ModifyPro(name, config$2, type$1 = "config") {
		const douyinDB$1 = await getDouyinDB();
		const bilibiliDB$1 = await getBilibiliDB();
		const filePath = type$1 === "config" ? `${this.dirCfgPath}/${name}.yaml` : `${this.defCfgPath}/${name}.yaml`;
		try {
			const existingContent = fs$1.readFileSync(filePath, "utf8");
			const doc = YAML.parseDocument(existingContent);
			let filterCfg = config$2;
			if (name === "pushlist" && ("douyin" in config$2 || "bilibili" in config$2)) {
				const cleanedConfig = { ...config$2 };
				if ("douyin" in cleanedConfig) cleanedConfig.douyin = cleanedConfig.douyin.map((item) => {
					const { Keywords, Tags, filterMode,...rest } = item;
					return rest;
				});
				if ("bilibili" in cleanedConfig) cleanedConfig.bilibili = cleanedConfig.bilibili.map((item) => {
					const { Keywords, Tags, filterMode,...rest } = item;
					return rest;
				});
				filterCfg = cleanedConfig;
			}
			const newConfigNode = YAML.parseDocument(YAML.stringify(filterCfg)).contents;
			this.deepMergeYaml(doc.contents, newConfigNode);
			fs$1.writeFileSync(filePath, doc.toString({ lineWidth: -1 }), "utf8");
			if ("douyin" in config$2) {
				await this.syncFilterConfigToDb(config$2.douyin, douyinDB$1, "sec_uid");
				logger.debug("");
			}
			if ("bilibili" in config$2) {
				await this.syncFilterConfigToDb(config$2.bilibili, bilibiliDB$1, "host_mid");
				logger.debug("B");
			}
			return true;
		} catch (error) {
			logger.error(`${error}`);
			return false;
		}
	}
	/**
	* 
	* @param items 
	* @param db 
	* @param idField ID
	*/
	async syncFilterConfigToDb(items, db$2, idField) {
		for (const item of items) {
			const id = item[idField];
			if (!id) continue;
			if (item.filterMode) await db$2.updateFilterMode(id, item.filterMode);
			if (item.Keywords && Array.isArray(item.Keywords)) {
				const existingWords = await db$2.getFilterWords(id);
				for (const word of existingWords) if (!item.Keywords.includes(word)) await db$2.removeFilterWord(id, word);
				for (const word of item.Keywords) if (!existingWords.includes(word)) await db$2.addFilterWord(id, word);
			}
			if (item.Tags && Array.isArray(item.Tags)) {
				const existingTags = await db$2.getFilterTags(id);
				for (const tag of existingTags) if (!item.Tags.includes(tag)) await db$2.removeFilterTag(id, tag);
				for (const tag of item.Tags) if (!existingTags.includes(tag)) await db$2.addFilterTag(id, tag);
			}
		}
	}
	/**
	* YAML
	* @param target 
	* @param source 
	*/
	deepMergeYaml(target, source) {
		if (YAML.isMap(target) && YAML.isMap(source)) for (const pair of source.items) {
			const key = pair.key;
			const sourceVal = pair.value;
			const targetVal = target.get(key);
			if (targetVal === void 0) target.set(key, sourceVal);
			else if (YAML.isMap(targetVal) && YAML.isMap(sourceVal)) this.deepMergeYaml(targetVal, sourceVal);
			else if (YAML.isSeq(targetVal) && YAML.isSeq(sourceVal)) {
				targetVal.items = sourceVal.items;
				targetVal.flow = sourceVal.flow;
			} else target.set(key, sourceVal);
		}
	}
	/**
	* YAML
	*
	* YAMLmapkeysvalue
	* 
	*
	* @param map YAML
	* @param keys 
	* @param value 
	*/
	setNestedValue(map, keys, value) {
		if (keys.length === 1) {
			map.set(keys[0], value);
			return;
		}
		const subKey = keys[0];
		let subMap = map.get(subKey);
		if (!subMap || !YAML.isMap(subMap)) {
			subMap = new YAML.YAMLMap();
			map.set(subKey, subMap);
		}
		this.setNestedValue(subMap, keys.slice(1), value);
	}
	mergeObjectsWithPriority(userDoc, defaultDoc) {
		let differences = false;
		/**  YAML  */
		const mergeYamlNodes = (target, source) => {
			if (YAML.isMap(target) && YAML.isMap(source)) for (const pair of source.items) {
				const key = pair.key;
				const value = pair.value;
				const existing = target.get(key);
				if (existing === void 0) {
					differences = true;
					target.set(key, value);
				} else if (YAML.isMap(value) && YAML.isMap(existing)) mergeYamlNodes(existing, value);
				else if (existing !== value) {
					differences = true;
					target.set(key, value);
				}
			}
		};
		mergeYamlNodes(defaultDoc.contents, userDoc.contents);
		return {
			differences,
			result: defaultDoc
		};
	}
	/**
	* 
	* 
	*/
	async syncConfigToDatabase() {
		try {
			const pushCfg = this.getYaml("config", "pushlist");
			const douyinDB$1 = await getDouyinDB();
			const bilibiliDB$1 = await getBilibiliDB();
			if (pushCfg.bilibili) await bilibiliDB$1.syncConfigSubscriptions(pushCfg.bilibili);
			if (pushCfg.douyin) await douyinDB$1.syncConfigSubscriptions(pushCfg.douyin);
			logger.debug("[BilibiliDB] + [DouyinDB] ");
		} catch (error) {
			logger.error(":", error);
		}
	}
};
/**
* 
*/
let configInstance = null;
/**
* 
* @returns 
*/
const getConfigInstance = () => {
	if (!configInstance) configInstance = new Proxy(new Cfg().initCfg(), { get(target, prop) {
		if (prop in target) return target[prop];
		return target.getDefOrConfig(prop);
	} });
	return configInstance;
};
/**
* 
*/
const Config = new Proxy({}, { get(target, prop) {
	return getConfigInstance()[prop];
} });

//#endregion
//#region src/module/utils/Base.ts
var Base = class {
	e;
	headers;
	amagi;
	constructor(e) {
		this.e = e;
		this.headers = baseHeaders;
		const client = Client({
			cookies: {
				douyin: Config.cookies.douyin,
				bilibili: Config.cookies.bilibili,
				kuaishou: Config.cookies.kuaishou,
				xiaohongshu: Config.cookies.xiaohongshu
			},
			request: {
				timeout: Config.request.timeout,
				headers: { "User-Agent": Config.request["User-Agent"] },
				proxy: Config.request.proxy?.switch ? Config.request.proxy : false
			}
		});
		this.amagi = new Proxy(client, { get(target, prop) {
			const method = target[prop];
			if (typeof method === "function") return async (...args) => {
				const result = await Function.prototype.apply.call(method, target, args);
				if (!result) {
					logger.warn(`Amagi API (${String(prop)}) `);
					return result;
				}
				return result;
			};
			return method;
		} });
	}
};
/**  */
const Count = (count) => {
	if (count > 1e4) return (count / 1e4).toFixed(1) + "";
	else return count?.toString() ?? "";
};
/**
* 
* @param event - 
* @param file - 
* @param videoUrl 
* @param options 
* @returns
*/
const uploadFile = async (event, file$2, videoUrl, options) => {
	let sendStatus = true;
	let File$1;
	let newFileSize = file$2.totalBytes;
	let selfId;
	let contact;
	if (options?.active) {
		selfId = options?.activeOption?.uin;
		contact = karin.contactGroup(options?.activeOption?.group_id);
	} else {
		selfId = event.selfId;
		contact = event.contact;
	}
	if (Config.upload.compress && file$2.totalBytes > Config.upload.compresstrigger) {
		const Duration = await mergeFile("", { path: file$2.filepath });
		logger.warn(logger.yellow(` (${file$2.totalBytes} MB) ${Config.upload.compresstrigger} MB${Config.upload.compressvalue} MB...`));
		const message = [segment.text(` (${file$2.totalBytes} MB) ${Config.upload.compresstrigger} MB${Config.upload.compressvalue} MB...`), options?.message_id ? segment.reply(options.message_id) : segment.text("")];
		const msg1 = await karin.sendMsg(selfId, contact, message);
		const targetBitrate = Common.calculateBitrate(Config.upload.compresstrigger, Duration) * .75;
		const startTime = Date.now();
		file$2.filepath = await mergeFile("", {
			path: file$2.filepath,
			targetBitrate,
			resultPath: `${Common.tempDri.video}tmp_${Date.now()}.mp4`
		});
		const endTime = Date.now();
		newFileSize = await Common.getVideoFileSize(file$2.filepath);
		logger.debug(`: ${file$2.totalBytes.toFixed(1)} MB, ${logger.green(` FFmpeg : ${newFileSize.toFixed(1)} MB`)}`);
		const message2 = [segment.text(`: ${newFileSize.toFixed(1)} MB${((endTime - startTime) / 1e3).toFixed(1)} `), segment.reply(msg1.messageId)];
		await karin.sendMsg(selfId, contact, message2);
	}
	if (options) options.useGroupFile = Config.upload.usegroupfile && newFileSize > Config.upload.groupfilevalue;
	if (Config.upload.sendbase64 && !options?.useGroupFile) {
		File$1 = `base64://${(await fs$1.promises.readFile(file$2.filepath)).toString("base64")}`;
		logger.mark(` base64 ${logger.yellow("base64")}...`);
	} else File$1 = options?.useGroupFile ? file$2.filepath : `file://${file$2.filepath}`;
	try {
		if (options?.active) if (options.useGroupFile) {
			const bot = karin.getBot(String(options.activeOption?.uin));
			logger.mark(`${logger.blue(":")} : ${newFileSize.toFixed(1)}MB ${logger.yellow("bot.uploadFile")}...`);
			await bot.uploadFile(contact, File$1, file$2.originTitle ? `${file$2.originTitle}.mp4` : `${File$1.split("/").pop()}`);
		} else {
			logger.mark(`${logger.blue(":")} : ${newFileSize.toFixed(1)}MB ${logger.yellow("karin.sendMsg")}...`);
			(await karin.sendMsg(selfId, contact, [segment.video(File$1)])).messageId ? sendStatus = true : sendStatus = false;
		}
		else if (options?.useGroupFile) {
			logger.mark(`${logger.blue(":")} : ${newFileSize.toFixed(1)}MB ${logger.yellow("e.bot.uploadFile")}...`);
			await event.bot.uploadFile(event.contact, File$1, file$2.originTitle ? `${file$2.originTitle}.mp4` : `${File$1.split("/").pop()}`);
		} else {
			logger.mark(`${logger.blue(":")} : ${newFileSize.toFixed(1)}MB ${logger.yellow("e.reply")}...`);
			(await event.reply(segment.video(File$1) || videoUrl)).messageId ? sendStatus = true : sendStatus = false;
		}
		return sendStatus;
	} catch (error) {
		if (options && options.active === false) await event.reply("" + JSON.stringify(error, null, 2));
		logger.error("," + String(error));
		return false;
	} finally {
		const filePath = file$2.filepath;
		logger.mark(`http://localhost:${process.env.HTTP_PORT}/api/kkk/video/${encodeURIComponent(filePath.split("/").pop() ?? "")}`);
		Config.app.removeCache && logger.info(` ${filePath}  10 `);
		setTimeout(async () => {
			await Common.removeFile(filePath);
		}, 600 * 1e3);
	}
};
/**
* 
* @param event 
* @param downloadOpt 
* @param uploadOpt 
* @returns
*/
const downloadVideo = async (event, downloadOpt, uploadOpt) => {
	/**  */
	const fileHeaders = await new Networks({
		url: downloadOpt.video_url,
		headers: downloadOpt.headers ?? baseHeaders
	}).getHeaders();
	const fileSizeInMB = ((fileHeaders["content-range"]?.match(/\/(\d+)/) ? parseInt(fileHeaders["content-range"]?.match(/\/(\d+)/)[1], 10) : 0) / (1024 * 1024)).toFixed(2);
	const fileSize = parseInt(parseFloat(fileSizeInMB).toFixed(2));
	if (Config.upload.usefilelimit && fileSize > Config.upload.filelimit) {
		const message = segment.text(`${downloadOpt.title.originTitle ?? "Error: "} (${fileSizeInMB} MB) ${Config.upload.filelimit} MB`);
		const selfId = event.selfId || uploadOpt?.activeOption?.uin;
		const contact = event.contact || karin.contactGroup(uploadOpt?.activeOption?.group_id) || karin.contactFriend(selfId);
		await karin.sendMsg(selfId, contact, message);
		return false;
	}
	let res = await downloadFile(downloadOpt.video_url, {
		title: Config.app.removeCache ? downloadOpt.title.timestampTitle : processFilename(downloadOpt.title.originTitle, 50),
		headers: downloadOpt.headers ?? baseHeaders
	});
	res = {
		...res,
		...downloadOpt.title
	};
	res.totalBytes = Number((res.totalBytes / (1024 * 1024)).toFixed(2));
	/**  */
	return await uploadFile(event, res, downloadOpt.video_url, uploadOpt);
};
/**
* 
* @param videoUrl 
* @param opt 
* @returns 
*/
const downloadFile = async (videoUrl, opt) => {
	const startTime = Date.now();
	const { filepath, totalBytes } = await new Networks({
		url: videoUrl,
		headers: opt.headers ?? baseHeaders,
		filepath: Common.tempDri.video + opt.title,
		timeout: 3e4
	}).downloadStream((downloadedBytes, totalBytes$1) => {
		const barLength = 45;
		function generateProgressBar(progressPercentage$1) {
			const filledLength = Math.floor(progressPercentage$1 / 100 * barLength);
			let progress = "";
			progress += "".repeat(filledLength);
			progress += "".repeat(Math.max(0, barLength - filledLength - 1));
			return `[${progress}]`;
		}
		const progressPercentage = downloadedBytes / totalBytes$1 * 100;
		const red = Math.floor(255 - 255 * progressPercentage / 100);
		const coloredPercentage = logger.chalk.rgb(red, 255, 0)(`${progressPercentage.toFixed(1)}%`);
		const speed = downloadedBytes / ((Date.now() - startTime) / 1e3);
		const formattedSpeed = (speed / 1048576).toFixed(1) + " MB/s";
		const remainingTime = (totalBytes$1 - downloadedBytes) / speed;
		const formattedRemainingTime = remainingTime > 60 ? `${Math.floor(remainingTime / 60)}min ${Math.floor(remainingTime % 60)}s` : `${remainingTime.toFixed(0)}s`;
		const downloadedSizeMB = (downloadedBytes / 1048576).toFixed(1);
		const totalSizeMB = (totalBytes$1 / 1048576).toFixed(1);
		console.log(`  ${opt.title} ${generateProgressBar(progressPercentage)} ${coloredPercentage} ${downloadedSizeMB}/${totalSizeMB} MB | ${formattedSpeed} : ${formattedRemainingTime}\r`);
	}, 3);
	return {
		filepath,
		totalBytes
	};
};
/**
* 
* @param filename 
* @param maxLength 
* @returns 
*/
const processFilename = (filename, maxLength = 50) => {
	const lastDotIndex = filename.lastIndexOf(".");
	if (!(lastDotIndex > 0 && lastDotIndex < filename.length - 1)) return filename.substring(0, maxLength).replace(/[\\/:*?"<>|\r\n\s]/g, " ");
	const nameWithoutExt = filename.substring(0, lastDotIndex);
	const extension$1 = filename.substring(lastDotIndex);
	return nameWithoutExt.substring(0, maxLength).replace(/[\\/:*?"<>|\r\n\s]/g, " ") + "..." + extension$1;
};

//#endregion
//#region src/module/utils/Common.ts
/**  */
var Tools = class {
	/**
	* 
	*/
	tempDri;
	constructor() {
		this.tempDri = {
			default: `${karinPathTemp}/${Root.pluginName}/`.replace(/\\/g, "/"),
			video: `${karinPathTemp}/${Root.pluginName}/kkkdownload/video/`.replace(/\\/g, "/"),
			images: `${karinPathTemp}/${Root.pluginName}/kkkdownload/images/`.replace(/\\/g, "/")
		};
	}
	/**
	* 
	* @param e event 
	* @returns 
	*/
	async getReplyMessage(e) {
		if (e.replyId) {
			const reply = await e.bot.getMsg(e.contact, e.replyId);
			for (const v of reply.elements) if (v.type === "text") return v.text;
			else if (v.type === "json") return v.data;
		}
		return "";
	}
	/**
	* 
	* @param chineseNumber 
	* @returns 
	*/
	chineseToArabic(chineseNumber) {
		const chineseToArabicMap = {
			: 0,
			: 1,
			: 2,
			: 3,
			: 4,
			: 5,
			: 6,
			: 7,
			: 8,
			: 9
		};
		const units = {
			: 10,
			: 100,
			: 1e3,
			: 1e4,
			: 1e8
		};
		let result = 0;
		let temp = 0;
		let unit = 1;
		for (let i = chineseNumber.length - 1; i >= 0; i--) {
			const char = chineseNumber[i];
			if (units[char] !== void 0) {
				unit = units[char];
				if (unit === 1e4 || unit === 1e8) {
					result += temp * unit;
					temp = 0;
				}
			} else {
				const num = chineseToArabicMap[char];
				if (unit > 1) temp += num * unit;
				else temp += num;
				unit = 1;
			}
		}
		return result + temp;
	}
	/**
	* cookie
	* @param cookies cookie
	* @returns cookie
	*/
	formatCookies(cookies) {
		return cookies.map((cookie$1) => {
			const [nameValue] = cookie$1.split(";").map((part) => part.trim());
			const [name, value] = nameValue.split("=");
			return `${name}=${value}`;
		}).join("; ");
	}
	/**
	* Kbps
	* @param targetSizeMB MB
	* @param duration 
	* @returns
	*/
	calculateBitrate(targetSizeMB, duration$2) {
		return targetSizeMB * 1024 * 1024 * 8 / duration$2 / 1024;
	}
	/**
	* MB
	* @param filePath 
	* @returns
	*/
	async getVideoFileSize(filePath) {
		try {
			return (await fs$1.promises.stat(filePath)).size / (1024 * 1024);
		} catch (error) {
			console.error(":", error);
			throw error;
		}
	}
	/**
	* 
	* @param path 
	* @param force  `false`
	* @returns
	*/
	async removeFile(path$3, force = false) {
		path$3 = path$3.replace(/\\/g, "/");
		if (Config.app.removeCache) try {
			await fs$1.promises.unlink(path$3);
			logger.mark(": ", path$3 + " ");
			return true;
		} catch (err) {
			logger.error(": ", path$3 + " ", err);
			return false;
		}
		else if (force) try {
			await fs$1.promises.unlink(path$3);
			logger.mark(": ", path$3 + " ");
			return true;
		} catch (err) {
			logger.error(": ", path$3 + " ", err);
			return false;
		}
		return true;
	}
	/**
	* 
	* @param timestamp 
	* @returns YYYY-MM-DD HH:MM
	*/
	convertTimestampToDateTime(timestamp) {
		const date$2 = /* @__PURE__ */ new Date(timestamp * 1e3);
		return `${date$2.getFullYear()}-${String(date$2.getMonth() + 1).padStart(2, "0")}-${String(date$2.getDate()).padStart(2, "0")} ${String(date$2.getHours()).padStart(2, "0")}:${String(date$2.getMinutes()).padStart(2, "0")}`;
	}
	/**
	* -- ::
	* @returns
	*/
	getCurrentTime() {
		const now$1 = /* @__PURE__ */ new Date();
		const year = now$1.getFullYear();
		const month = now$1.getMonth() + 1;
		const day = now$1.getDate();
		const hour = now$1.getHours();
		const minute = now$1.getMinutes();
		const second = now$1.getSeconds();
		return `${year}-${month < 10 ? "0" + month : "" + month}-${day < 10 ? "0" + day : "" + day} ${hour < 10 ? "0" + hour : "" + hour}:${minute < 10 ? "0" + minute : "" + minute}:${second < 10 ? "0" + second : "" + second}`;
	}
	/**
	* 
	* @returns
	*/
	useDarkTheme() {
		let dark = true;
		const configTheme = Config.app.Theme;
		if (configTheme === 0) {
			const date$2 = (/* @__PURE__ */ new Date()).getHours();
			if (date$2 >= 6 && date$2 < 18) dark = false;
		} else if (configTheme === 1) dark = false;
		else if (configTheme === 2) dark = true;
		return dark;
	}
	/**
	* 
	* @param timestamp 
	* @returns 
	*/
	timeSince(timestamp) {
		const elapsed = Date.now() - timestamp;
		const seconds = Math.floor(elapsed / 1e3);
		const minutes = Math.floor(seconds / 60);
		const hours = Math.floor(minutes / 60);
		const remainingSeconds = seconds % 60;
		const remainingMinutes = minutes % 60;
		if (hours > 0) return `${hours}${remainingMinutes}${remainingSeconds}`;
		else if (minutes > 0) return `${minutes}${remainingSeconds}`;
		else return `${seconds}`;
	}
	/**
	* 
	* @param filename 
	* @param res 
	* @returns 
	*/
	validateVideoRequest(filename, res) {
		if (!filename) {
			createNotFoundResponse(res, "");
			return null;
		}
		const intendedBaseDir = path.resolve(Common.tempDri.video);
		const requestedPath = path.join(intendedBaseDir, filename);
		const resolvedPath = path.normalize(requestedPath);
		if (!resolvedPath.startsWith(intendedBaseDir + path.sep) || filename.includes("/") || filename.includes("\\")) {
			logger.warn(`: ${filename}, : ${resolvedPath}`);
			createNotFoundResponse(res, "");
			return null;
		}
		if (path.basename(filename) !== filename) {
			logger.warn(`: ${filename}`);
			createNotFoundResponse(res, "");
			return null;
		}
		if (!fs$1.existsSync(resolvedPath)) {
			createNotFoundResponse(res, "");
			return null;
		}
		return resolvedPath;
	}
	/**
	* 
	* @param num 
	* @returns 
	*/
	count(num) {
		if (num > 1e4) return (num / 1e4).toFixed(1) + "";
		return num.toString();
	}
};
/**  */
const Common = new Tools();

//#endregion
//#region src/module/utils/FFmpeg.ts
/**
*  FFmpeg 
* @param type 
* @param options 
* @returns
*/
const mergeFile = async (type$1, options) => {
	return await new FFmpeg(type$1).FFmpeg(options);
};
var FFmpeg = class {
	type;
	constructor(type$1) {
		this.type = type$1;
	}
	async FFmpeg(opt) {
		switch (this.type) {
			case " + ": {
				const result = await ffmpeg(`-y -i ${opt.path} -i ${opt.path2} -c copy ${opt.resultPath}`);
				result.status ? logger.mark(`${opt.resultPath}`) : logger.error(result);
				await opt.callback(result.status, opt.resultPath);
				return result;
			}
			case "*3 + ": {
				const result = await ffmpeg(`-y -stream_loop 2 -i ${opt.path} -i ${opt.path2} -filter_complex "[0:v]setpts=N/FRAME_RATE/TB[v];[0:a][1:a]amix=inputs=2:duration=shortest:dropout_transition=3[aout]" -map "[v]" -map "[aout]" -c:v libx264 -c:a aac -b:a 192k -shortest ${opt.resultPath}`);
				result ? logger.mark(`${opt.resultPath}`) : logger.error(result);
				await opt.callback(result.status, opt.resultPath);
				return result;
			}
			case "": {
				const { stdout: stdout$1 } = await ffprobe(`-v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 ${opt.path}`);
				return parseFloat(parseFloat(stdout$1.trim()).toFixed(2));
			}
			case "": {
				const result = await ffmpeg(`-y -i "${opt.path}" -b:v ${opt.targetBitrate}k -maxrate ${opt.maxRate ?? opt.targetBitrate * 1.5}k -bufsize ${opt.bufSize ?? opt.targetBitrate * 2}k -crf ${opt.crf ?? 35} -preset medium -c:v libx264 -vf "scale='if(gte(iw/ih,16/9),1280,-1)':'if(gte(iw/ih,16/9),-1,720)',scale=ceil(iw/2)*2:ceil(ih/2)*2" "${opt.resultPath}"`);
				if (result.status) {
					logger.mark(`: ${opt.resultPath}`);
					Common.removeFile(opt.path);
				} else {
					logger.error(opt.path + " ");
					logger.error(result);
				}
				return opt.resultPath;
			}
		}
	}
};

//#endregion
//#region src/module/utils/Networks.ts
const baseHeaders = {
	Accept: "*/*",
	"accept-language": "zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6",
	"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Edg/137.0.0.0"
};
var Networks = class {
	url;
	method;
	headers;
	type;
	body;
	axiosInstance;
	timeout;
	filepath;
	maxRetries;
	constructor(data$1) {
		this.headers = data$1.headers ? Object.fromEntries(Object.entries(data$1.headers).map(([key, value]) => [key, String(value)])) : {};
		this.url = data$1.url ?? "";
		this.type = data$1.type ?? "json";
		this.method = data$1.method ?? "GET";
		this.body = data$1.body ?? null;
		this.timeout = data$1.timeout ?? 15e3;
		this.filepath = data$1.filepath ?? "";
		this.maxRetries = 0;
		this.axiosInstance = axios.create({
			timeout: this.timeout,
			headers: this.headers,
			maxRedirects: 5,
			validateStatus: (status) => {
				return status >= 200 && status < 300 || status === 406 || status >= 500;
			}
		});
	}
	get config() {
		const config$2 = {
			url: this.url,
			method: this.method,
			headers: this.headers,
			responseType: this.type
		};
		if (this.method === "POST" && this.body) config$2.data = this.body;
		return config$2;
	}
	/**
	* 
	*
	* @param progressCallback 
	* @param retryCount 0
	* @returns Promise
	*
	* axiosHTTPURL
	* 
	*/
	async downloadStream(progressCallback, retryCount = 0) {
		const controller = new AbortController();
		const timeoutId = setTimeout(() => controller.abort(), this.timeout);
		try {
			const response$2 = await axios({
				...this.config,
				url: this.url,
				responseType: "stream",
				signal: controller.signal
			});
			clearTimeout(timeoutId);
			if (!(response$2.status >= 200 && response$2.status < 300)) throw new Error(` ${this.url}: ${response$2.status} ${response$2.statusText}`);
			const totalBytes = parseInt(response$2.headers["content-length"] ?? "0", 10);
			if (isNaN(totalBytes)) throw new Error(" content-length ");
			let downloadedBytes = 0;
			let lastPrintedPercentage = -1;
			const writer = fs$1.createWriteStream(this.filepath);
			const printProgress = () => {
				const progressPercentage = Math.floor(downloadedBytes / totalBytes * 100);
				if (progressPercentage !== lastPrintedPercentage) {
					progressCallback(downloadedBytes, totalBytes);
					lastPrintedPercentage = progressPercentage;
				}
			};
			const interval = totalBytes < 10 * 1024 * 1024 ? 1e3 : 500;
			const intervalId = setInterval(printProgress, interval);
			const onData = (chunk) => {
				downloadedBytes += chunk.length;
			};
			response$2.data.on("data", onData);
			await pipeline(response$2.data, writer);
			clearInterval(intervalId);
			response$2.data.off("data", onData);
			writer.end();
			return {
				filepath: this.filepath,
				totalBytes
			};
		} catch (error) {
			clearTimeout(timeoutId);
			if (error instanceof AxiosError) logger.error(` ${this.timeout / 1e3} `);
			else logger.error(":", error);
			if (retryCount < this.maxRetries) {
				const delay = Math.min(Math.pow(2, retryCount) * 1e3, 1e3);
				logger.warn(`... (${retryCount + 1}/${this.maxRetries}) ${delay / 1e3} `);
				await new Promise((resolve) => setTimeout(resolve, delay));
				return this.downloadStream(progressCallback, retryCount + 1);
			} else throw new Error(` ${this.maxRetries} : ${error}`);
		}
	}
	async getfetch() {
		try {
			const result = await this.returnResult();
			if (result.status === 504) return result;
			return result;
		} catch (error) {
			logger.info(error);
			return false;
		}
	}
	async returnResult() {
		let response$2 = {};
		try {
			response$2 = await this.axiosInstance(this.config);
		} catch (error) {
			logger.error(error);
		}
		return response$2;
	}
	/**  */
	async getLongLink(url$1 = "") {
		let errorMsg = `: ${this.url || url$1}`;
		try {
			return (await this.axiosInstance.head(this.url || url$1)).request.res.responseUrl;
		} catch (error) {
			const axiosError = error;
			if (axiosError.response) {
				if (axiosError.response.status === 302) {
					const redirectUrl = axiosError.response.headers.location;
					logger.info(`302: ${redirectUrl}`);
					return await this.getLongLink(redirectUrl);
				} else if (axiosError.response.status === 403) {
					errorMsg = `403 Forbidden ${this.url || url$1}`;
					logger.error(errorMsg);
					return errorMsg;
				}
			}
			logger.error(errorMsg);
			return errorMsg;
		}
	}
	/** 302 */
	async getLocation() {
		try {
			return (await this.axiosInstance({
				method: "GET",
				url: this.url,
				maxRedirects: 0,
				validateStatus: (status) => status >= 300 && status < 400
			})).headers.location;
		} catch (error) {
			if (error instanceof AxiosError) {
				logger.error(` ${this.url} : ${error.response?.status}`);
				throw new Error(error.stack);
			}
		}
	}
	/** json */
	async getData() {
		try {
			const result = await this.returnResult();
			if (result.status === 504) return result;
			if (result.status === 429) {
				logger.error("HTTP : 429");
				throw new Error("ratelimit triggered,  https://www.douyin.com/ ");
			}
			return result.data;
		} catch (error) {
			if (error instanceof AxiosError) throw new Error(error.stack ?? error.message);
			return false;
		}
	}
	/**
	* 
	* 
	* @returns 
	*/
	async getHeaders() {
		try {
			return (await this.axiosInstance({
				...this.config,
				method: "GET",
				headers: {
					...this.config.headers,
					Range: "bytes=0-0"
				}
			})).headers;
		} catch (error) {
			logger.error(error);
			throw error;
		}
	}
	/**
	* 
	* @returns
	*/
	async getHeadersFull() {
		try {
			return (await this.axiosInstance({
				...this.config,
				method: "GET"
			})).headers;
		} catch (error) {
			logger.error(error);
			throw error;
		}
	}
};

//#endregion
//#region src/module/utils/Render.ts
/**
* 
* @template P 
* @param path  "/ID"
* @param data 
* @returns Promise
*/
const Render = async (path$3, data$1) => {
	const pathParts = path$3.split("/");
	let templateType;
	let templateName;
	if (pathParts.length === 2) [templateType, templateName] = pathParts;
	else if (pathParts.length === 3) {
		templateType = pathParts[0];
		templateName = `${pathParts[1]}/${pathParts[2]}`;
	} else throw new Error(`: ${path$3}`);
	const outputDir = join(karinPathHtml, Root.pluginName, templateType);
	const result = await src_default({
		templateType,
		templateName,
		scale: Math.min(2, Math.max(.5, Number(Config.app.renderScale) / 100)),
		useDarkTheme: Common.useDarkTheme(),
		version: Config.app.RemoveWatermark ? void 0 : {
			pluginName: "kkk",
			pluginVersion: Root.pluginVersion,
			releaseType: /^\d+\.\d+\.\d+$/.test(Root.pluginVersion) ? "Stable" : "Preview",
			poweredBy: "Karin"
		},
		data: {
			...data$1,
			useDarkTheme: Common.useDarkTheme()
		}
	}, outputDir).then((res) => {
		if (!res.success || !res.htmlPath) throw new Error(res.error || "SSR");
		return res;
	}).catch((err) => {
		throw new Error(err.message || "SSR");
	});
	const renderResult = await render.render({
		name: `${Root.pluginName}/${templateType}/${templateName}`,
		file: result.htmlPath,
		multiPage: Config.app.multiPageRender ? Config.app.multiPageHeight : false,
		selector: "#container",
		fullPage: false,
		type: "png",
		pageGotoParams: {
			waitUntil: "load",
			timeout: Config.app.RenderWaitTime * 1e3
		}
	});
	const ret = [];
	if (Array.isArray(renderResult)) for (const image of renderResult) ret.push(segment.image("base64://" + image));
	else ret.push(segment.image("base64://" + renderResult));
	return ret;
};

//#endregion
//#region src/platform/bilibili/bilibili.ts
let img;
var Bilibili = class extends Base {
	e;
	type;
	STATUS;
	isVIP;
	Type;
	islogin;
	downloadfilename;
	get botadapter() {
		return this.e.bot?.adapter?.name;
	}
	constructor(e, data$1) {
		super(e);
		this.e = e;
		this.isVIP = false;
		this.Type = data$1?.type;
		this.islogin = data$1?.USER?.STATUS === "isLogin";
		this.downloadfilename = "";
		this.headers.Referer = "https://api.bilibili.com/";
		this.headers.Cookie = Config.cookies.bilibili;
	}
	async RESOURCES(iddata) {
		Config.app.EmojiReply && await this.e.bot.setMsgReaction(this.e.contact, this.e.messageId, Config.app.EmojiReplyID, true);
		Config.bilibili.tip && await this.e.reply("B");
		switch (this.Type) {
			case "one_video": {
				const infoData = await this.amagi.getBilibiliData("", {
					bvid: iddata.bvid,
					typeMode: "strict"
				});
				const playUrlData = await this.amagi.getBilibiliData("", {
					avid: infoData.data.data.aid,
					cid: iddata.p ? infoData.data.data.pages[iddata.p - 1]?.cid ?? infoData.data.data.cid : infoData.data.data.cid,
					typeMode: "strict"
				});
				this.islogin = (await checkCk()).Status === "isLogin";
				this.downloadfilename = infoData.data.data.title.substring(0, 50).replace(/[\\/:*?"<>|\r\n\s]/g, " ");
				const nockData = await new Networks({
					url: bilibiliApiUrls.({
						avid: infoData.data.data.aid,
						cid: iddata.p ? infoData.data.data.pages[iddata.p - 1]?.cid ?? infoData.data.data.cid : infoData.data.data.cid
					}) + "&platform=html5",
					headers: this.headers
				}).getData();
				if (Config.bilibili.sendContent.some((content) => content === "info")) if (Config.bilibili.videoInfoMode === "text") {
					const replyContent = [];
					const { coin, like, share, view: view$1, favorite, danmaku } = infoData.data.data.stat;
					const contentMap = {
						cover: segment.image(infoData.data.data.pic),
						title: segment.text(`\n : ${infoData.data.data.title}\n`),
						author: segment.text(`\n : ${infoData.data.data.owner.name}\n`),
						stats: segment.text(formatVideoStats(view$1, danmaku, like, coin, share, favorite)),
						desc: segment.text(`\n\n : ${infoData.data.data.desc}`)
					};
					[
						"cover",
						"title",
						"author",
						"stats",
						"desc"
					].forEach((item) => {
						if (Config.bilibili.displayContent.includes(item) && contentMap[item]) replyContent.push(contentMap[item]);
					});
					if (replyContent.length > 0) this.e.reply(replyContent);
				} else {
					const img$1 = await Render("bilibili/videoInfo", {
						share_url: "https://b23.tv/" + infoData.data.data.bvid,
						title: infoData.data.data.title,
						desc: infoData.data.data.desc,
						stat: infoData.data.data.stat,
						bvid: infoData.data.data.bvid,
						ctime: infoData.data.data.ctime,
						pic: infoData.data.data.pic,
						owner: infoData.data.data.owner
					});
					this.e.reply(img$1);
				}
				let videoSize = "";
				let correctList;
				if (this.islogin && Config.bilibili.videopriority === false) {
					/**  */
					const simplify = playUrlData.data.data.dash.video.filter((item, index$1, self$1) => {
						return self$1.findIndex((t) => {
							return t.id === item.id;
						}) === index$1;
					});
					/**  */
					playUrlData.data.data.dash.video = simplify;
					/**  */
					correctList = await bilibiliProcessVideos({
						accept_description: playUrlData.data.data.accept_description,
						bvid: infoData.data.data.bvid,
						qn: Config.bilibili.videoQuality
					}, simplify, playUrlData.data.data.dash.audio[0].base_url);
					playUrlData.data.data.dash.video = correctList.videoList;
					playUrlData.data.data.accept_description = correctList.accept_description;
					/**  */
					videoSize = await getvideosize(correctList.videoList[0].base_url, playUrlData.data.data.dash.audio[0].base_url, infoData.data.data.bvid);
				} else videoSize = (nockData.data.durl[0].size / (1024 * 1024)).toFixed(2);
				if (Config.bilibili.sendContent.some((content) => content === "comment")) {
					const commentsdata = bilibiliComments((await this.amagi.getBilibiliData("", {
						number: Config.bilibili.numcomment,
						type: 1,
						oid: infoData.data.data.aid.toString(),
						typeMode: "strict"
					})).data, infoData.data.data.owner.mid.toString());
					if (!commentsdata?.length) this.e.reply(" ~");
					else {
						img = await Render("bilibili/comment", {
							Type: "",
							CommentsData: commentsdata,
							CommentLength: Config.bilibili.realCommentCount ? Count(infoData.data.data.stat.reply) : String(commentsdata.length),
							share_url: "https://b23.tv/" + infoData.data.data.bvid,
							Clarity: Config.bilibili.videopriority === true ? nockData.data.accept_description[nockData.data.accept_description.length - 1] : playUrlData.data.data.accept_description[0],
							VideoSize: Config.bilibili.videopriority === true ? (nockData.data.durl[0].size / (1024 * 1024)).toFixed(2) : videoSize,
							ImageLength: 0,
							shareurl: "https://b23.tv/" + infoData.data.data.bvid
						});
						this.e.reply(img);
					}
				}
				if (Config.bilibili.sendContent.some((content) => content === "video")) if (Config.upload.usefilelimit && Number(videoSize) > Number(Config.upload.filelimit) && !Config.upload.compress) this.e.reply(` ${Config.upload.filelimit}MB\n ${Number(videoSize)}MB\nB~`, { reply: true });
				else await this.getvideo(Config.bilibili.videopriority === true ? { playUrlData: nockData.data } : {
					infoData: infoData.data,
					playUrlData: playUrlData.data
				});
				break;
			}
			case "bangumi_video_info": {
				const videoInfo = await this.amagi.getBilibiliData("", {
					[iddata.isEpid ? "ep_id" : "season_id"]: iddata.realid,
					typeMode: "strict"
				});
				this.islogin = (await checkCk()).Status === "isLogin";
				this.isVIP = (await checkCk()).isVIP;
				const Episodes = [];
				for (const item of videoInfo.data.result.episodes) Episodes.push({
					cover: item.cover,
					bvid: item.bvid,
					link: item.short_link,
					long_title: item.long_title,
					pub_time: item.pub_time,
					badge: item.badge === "" ? "" : item.badge,
					badge_info: item.badge_info
				});
				img = await Render("bilibili/bangumi", {
					mainCover: videoInfo.data.result.cover,
					Actors: videoInfo.data.result.actors,
					Evaluate: videoInfo.data.result.evaluate,
					Link: videoInfo.data.result.link,
					newEP: videoInfo.data.result.new_ep,
					Title: videoInfo.data.result.title,
					Styles: videoInfo.data.result.styles,
					seasonID: videoInfo.data.result.season_id,
					subtitle: videoInfo.data.result.subtitle,
					UPInfo: videoInfo.data.result.up_info,
					Copyright: videoInfo.data.result.rights.copyright,
					Stat: videoInfo.data.result.stat,
					Episodes,
					length: videoInfo.data.result.episodes.length
				});
				this.e.reply([...img, segment.text("120 ? ")]);
				const context = await karin.ctx(this.e, { reply: true });
				const regex = /([0-9]+)/.exec(context.msg);
				let Episode;
				if (regex && regex[1]) {
					Episode = regex[1];
					if (/^[]+$/.test(Episode)) Episode = Common.chineseToArabic(Episode).toString();
					this.downloadfilename = videoInfo.data.result.episodes[Number(Episode) - 1].share_copy.substring(0, 50).replace(/[\\/:*?"<>|\r\n\s]/g, " ");
					this.e.reply(`${Episode}\n${this.downloadfilename}\n`);
				} else {
					logger.debug(Episode);
					this.e.reply("");
					return true;
				}
				const bangumidataBASEURL = bilibiliApiUrls.({
					cid: videoInfo.data.result.episodes[Number(Episode) - 1].cid,
					ep_id: videoInfo.data.result.episodes[Number(Episode) - 1].ep_id.toString()
				});
				const Params = await genParams(bangumidataBASEURL);
				if (!this.islogin) this.e.reply("Bck#Bck");
				const playUrlData = await new Networks({
					url: bangumidataBASEURL + Params,
					headers: this.headers
				}).getData();
				if (videoInfo.data.result.episodes[Number(Episode) - 1].badge === "" && !this.isVIP) {
					logger.warn("CK");
					return true;
				}
				if (Config.bilibili.videoQuality === 0) {
					/**  */
					const simplify = playUrlData.result.dash.video.filter((item, index$1, self$1) => {
						return self$1.findIndex((t) => {
							return t.id === item.id;
						}) === index$1;
					});
					/**  */
					playUrlData.result.dash.video = simplify;
					/**  */
					const correctList = await bilibiliProcessVideos({
						accept_description: playUrlData.result.accept_description,
						bvid: videoInfo.data.result.season_id.toString(),
						qn: Config.bilibili.videoQuality
					}, simplify, playUrlData.result.dash.audio[0].base_url);
					playUrlData.result.dash.video = correctList.videoList;
					playUrlData.result.cept_description = correctList.accept_description;
				}
				await this.getvideo({
					infoData: videoInfo.data,
					playUrlData
				});
				break;
			}
			case "dynamic_info": {
				const dynamicInfo = await this.amagi.getBilibiliData("", {
					dynamic_id: iddata.dynamic_id,
					typeMode: "strict"
				});
				const dynamicInfoCard = await this.amagi.getBilibiliData("", {
					dynamic_id: dynamicInfo.data.data.item.id_str,
					typeMode: "strict"
				});
				const commentsData = dynamicInfo.data.data.item.type !== DynamicType.LIVE_RCMD && await this.amagi.getBilibiliData("", {
					type: mapping_table(dynamicInfo.data.data.item.type),
					oid: oid(dynamicInfo.data, dynamicInfoCard.data),
					number: Config.bilibili.numcomment,
					typeMode: "strict"
				});
				const dynamicCARD = JSON.parse(dynamicInfoCard.data.data.card.card);
				const userProfileData = await this.amagi.getBilibiliData("", {
					host_mid: dynamicInfo.data.data.item.modules.module_author.mid,
					typeMode: "strict"
				});
				switch (dynamicInfo.data.data.item.type) {
					case DynamicType.DRAW: {
						const imgArray = [];
						for (const img$1 of dynamicInfo.data.data.item.modules.module_dynamic.major.opus.pics) if (img$1.url) imgArray.push(segment.image(img$1.url));
						if (Config.bilibili.sendContent.some((content) => content === "comment") && commentsData) {
							const commentsdata = bilibiliComments(commentsData.data, dynamicInfo.data.data.item.modules.module_author.mid.toString());
							img = await Render("bilibili/comment", {
								Type: "",
								CommentsData: commentsdata,
								CommentLength: String(commentsdata?.length ?? 0),
								share_url: "https://t.bilibili.com/" + dynamicInfo.data.data.item.id_str,
								ImageLength: dynamicInfo.data.data.item.modules?.module_dynamic?.major?.draw?.items?.length ?? 0,
								shareurl: ""
							});
							if (imgArray.length === 1) this.e.reply(imgArray[0]);
							if (imgArray.length > 1) {
								const forwardMsg = common.makeForward(imgArray, this.e.userId, this.e.sender.nick);
								await this.e.bot.sendForwardMsg(this.e.contact, forwardMsg);
							}
							this.e.reply(img);
						}
						const dynamicCARD$1 = JSON.parse(dynamicInfoCard.data.data.card.card);
						if ("topic" in dynamicInfo.data.data.item.modules.module_dynamic && dynamicInfo.data.data.item.modules.module_dynamic.topic !== null) {
							const name = dynamicInfo.data.data.item.modules.module_dynamic.topic.name;
							dynamicInfo.data.data.item.modules.module_dynamic.major.opus.summary.rich_text_nodes.unshift({
								orig_text: name,
								jump_url: "",
								text: name,
								type: "topic"
							});
							dynamicInfo.data.data.item.modules.module_dynamic.major.opus.summary.text = `${name}\n\n` + dynamicInfo.data.data.item.modules.module_dynamic.major.opus.summary.text;
						}
						this.e.reply(await Render("bilibili/dynamic/DYNAMIC_TYPE_DRAW", {
							image_url: dynamicCARD$1.item.pictures && cover(dynamicCARD$1.item.pictures),
							text: dynamicInfo.data.data.item.modules.module_dynamic.major ? replacetext(br$2(dynamicInfo.data.data.item.modules.module_dynamic.major.opus?.summary?.text ?? ""), dynamicInfo.data.data.item.modules.module_dynamic.major.opus?.summary?.rich_text_nodes ?? []) : "",
							dianzan: Count(dynamicInfo.data.data.item.modules.module_stat.like.count),
							pinglun: Count(dynamicInfo.data.data.item.modules.module_stat.comment.count),
							share: Count(dynamicInfo.data.data.item.modules.module_stat.forward.count),
							create_time: dynamicInfo.data.data.item.modules.module_author.pub_time,
							avatar_url: dynamicInfo.data.data.item.modules.module_author.face,
							frame: dynamicInfo.data.data.item.modules.module_author.pendant.image,
							share_url: "https://t.bilibili.com/" + dynamicInfo.data.data.item.id_str,
							username: checkvip$2(userProfileData.data.data.card),
							fans: Count(userProfileData.data.data.follower),
							user_shortid: dynamicInfo.data.data.item.modules.module_author.mid,
							total_favorited: Count(userProfileData.data.data.like_num),
							following_count: Count(userProfileData.data.data.card.attention),
							decoration_card: generateDecorationCard(dynamicInfo.data.data.item.modules.module_author.decoration_card),
							render_time: Common.getCurrentTime(),
							dynamicTYPE: "",
							imageLayout: Config.bilibili.imageLayout
						}));
						break;
					}
					case DynamicType.FORWARD: {
						const text$1 = replacetext(br$2(dynamicInfo.data.data.item.modules.module_dynamic.desc.text), dynamicInfo.data.data.item.modules.module_dynamic.desc.rich_text_nodes);
						const imgList = [];
						for (const richTxtItem of dynamicInfo.data.data.item.modules.module_dynamic.desc.rich_text_nodes) if (richTxtItem.type === "RICH_TEXT_NODE_TYPE_VIEW_PICTURE") for (const pic of richTxtItem.pics) imgList.push(pic.src);
						let data$1 = {};
						switch (dynamicInfo.data.data.item.orig.type) {
							case DynamicType.AV:
								data$1 = {
									username: checkvip$2(dynamicInfo.data.data.item.orig.modules.module_author),
									pub_action: dynamicInfo.data.data.item.orig.modules.module_author.pub_action,
									avatar_url: dynamicInfo.data.data.item.orig.modules.module_author.face,
									duration_text: dynamicInfo.data.data.item.orig.modules.module_dynamic.major.archive.duration_text,
									title: dynamicInfo.data.data.item.orig.modules.module_dynamic.major.archive.title,
									danmaku: dynamicInfo.data.data.item.orig.modules.module_dynamic.major.archive.stat.danmaku,
									view: dynamicInfo.data.data.item.orig.modules.module_dynamic.major.archive.stat.view,
									play: dynamicInfo.data.data.item.orig.modules.module_dynamic.major.archive.stat.play,
									cover: dynamicInfo.data.data.item.orig.modules.module_dynamic.major.archive.cover,
									create_time: Common.convertTimestampToDateTime(dynamicInfo.data.data.item.orig.modules.module_author.pub_ts),
									decoration_card: generateDecorationCard(dynamicInfo.data.data.item.orig.modules.module_author.decoration_card),
									frame: dynamicInfo.data.data.item.orig.modules.module_author.pendant.image
								};
								break;
							case DynamicType.DRAW: {
								const dynamicCARD2 = await this.amagi.getBilibiliData("", {
									dynamic_id: dynamicInfo.data.data.item.orig.id_str,
									typeMode: "strict"
								});
								const cardData = JSON.parse(dynamicCARD2.data.data.card.card);
								data$1 = {
									username: checkvip$2(dynamicInfo.data.data.item.orig.modules.module_author),
									create_time: Common.convertTimestampToDateTime(dynamicInfo.data.data.item.orig.modules.module_author.pub_ts),
									avatar_url: dynamicInfo.data.data.item.orig.modules.module_author.face,
									text: replacetext(br$2(dynamicInfo.data.data.item.orig.modules.module_dynamic.major.opus.summary.text), dynamicInfo.data.data.item.orig.modules.module_dynamic.major.opus.summary.rich_text_nodes),
									image_url: cardData.item.pictures && cover(cardData.item.pictures),
									decoration_card: generateDecorationCard(dynamicInfo.data.data.item.orig.modules.module_author.decoration_card),
									frame: dynamicInfo.data.data.item.orig.modules.module_author.pendant.image
								};
								break;
							}
							case DynamicType.WORD:
								data$1 = {
									username: checkvip$2(dynamicInfo.data.data.item.orig.modules.module_author),
									create_time: Common.convertTimestampToDateTime(dynamicInfo.data.data.item.orig.modules.module_author.pub_ts),
									avatar_url: dynamicInfo.data.data.item.orig.modules.module_author.face,
									text: replacetext(br$2(dynamicInfo.data.data.item.orig.modules.module_dynamic.major.opus.summary.text), dynamicInfo.data.data.item.orig.modules.module_dynamic.major.opus.summary.rich_text_nodes),
									decoration_card: generateDecorationCard(dynamicInfo.data.data.item.orig.modules.module_author.decoration_card),
									frame: dynamicInfo.data.data.item.orig.modules.module_author.pendant.image
								};
								break;
							case DynamicType.LIVE_RCMD: {
								const liveData = JSON.parse(dynamicInfo.data.data.item.orig.modules.module_dynamic.major.live_rcmd.content);
								data$1 = {
									username: checkvip$2(dynamicInfo.data.data.item.orig.modules.module_author),
									create_time: Common.convertTimestampToDateTime(dynamicInfo.data.data.item.orig.modules.module_author.pub_ts),
									avatar_url: dynamicInfo.data.data.item.orig.modules.module_author.face,
									decoration_card: generateDecorationCard(dynamicInfo.data.data.item.orig.modules.module_author.decoration_card),
									frame: dynamicInfo.data.data.item.orig.modules.module_author.pendant.image,
									cover: liveData.live_play_info.cover,
									text_large: liveData.live_play_info.watched_show.text_large,
									area_name: liveData.live_play_info.area_name,
									title: liveData.live_play_info.title,
									online: liveData.live_play_info.online
								};
								break;
							}
							case DynamicType.FORWARD:
							default:
								logger.warn(`UP${userProfileData.data.data.card.name}${logger.green("")}${logger.yellow(dynamicInfo.data.item.orig.type)}`);
								break;
						}
						this.e.reply(await Render("bilibili/dynamic/DYNAMIC_TYPE_FORWARD", {
							text: text$1,
							imgList: imgList.length > 0 ? imgList : null,
							dianzan: Count(dynamicInfo.data.data.item.modules.module_stat.like.count),
							pinglun: Count(dynamicInfo.data.data.item.modules.module_stat.comment.count),
							share: Count(dynamicInfo.data.data.item.modules.module_stat.forward.count),
							create_time: dynamicInfo.data.data.item.modules.module_author.pub_time,
							avatar_url: dynamicInfo.data.data.item.modules.module_author.face,
							frame: dynamicInfo.data.data.item.modules.module_author.pendant.image,
							share_url: "https://t.bilibili.com/" + dynamicInfo.data.data.item.id_str,
							username: checkvip$2(userProfileData.data.data.card),
							fans: Count(userProfileData.data.data.follower),
							user_shortid: dynamicInfo.data.data.item.modules.module_author.mid,
							total_favorited: Count(userProfileData.data.data.like_num),
							following_count: Count(userProfileData.data.data.card.attention),
							dynamicTYPE: "",
							decoration_card: generateDecorationCard(dynamicInfo.data.data.item.modules.module_author.decorate),
							render_time: Common.getCurrentTime(),
							original_content: { [dynamicInfo.data.data.item.orig.type]: data$1 }
						}));
						break;
					}
					case DynamicType.AV:
						if (dynamicInfo.data.data.item.modules.module_dynamic.major.type === "MAJOR_TYPE_ARCHIVE") {
							const bvid = dynamicInfo.data.data.item.modules.module_dynamic.major.archive.bvid;
							const INFODATA = await getBilibiliData("", "", {
								bvid,
								typeMode: "strict"
							});
							const dycrad = dynamicInfoCard.data.data.card && dynamicInfoCard.data.data.card.card && JSON.parse(dynamicInfoCard.data.data.card.card);
							commentsData && Config.bilibili.sendContent.some((item) => item === "comment") && this.e.reply(await Render("bilibili/comment", {
								Type: "",
								CommentsData: bilibiliComments(commentsData.data, dynamicInfo.data.data.item.modules.module_author.mid.toString()),
								CommentLength: String(bilibiliComments(commentsData.data, dynamicInfo.data.data.item.modules.module_author.mid.toString())?.length ? bilibiliComments(commentsData.data, dynamicInfo.data.data.item.modules.module_author.mid.toString()).length : 0),
								share_url: "https://www.bilibili.com/video/" + bvid,
								ImageLength: dynamicInfo.data.data.item.modules?.module_dynamic?.major?.draw?.items?.length ?? 0,
								shareurl: ""
							}));
							img = await Render("bilibili/dynamic/DYNAMIC_TYPE_AV", {
								image_url: INFODATA.data.data.pic,
								text: br$2(INFODATA.data.data.title),
								desc: br$2(dycrad.desc),
								dianzan: Count(INFODATA.data.data.stat.like),
								pinglun: Count(INFODATA.data.data.stat.reply),
								share: Count(INFODATA.data.data.stat.share),
								view: Count(dycrad.stat.view),
								coin: Count(dycrad.stat.coin),
								duration_text: dynamicInfo.data.data.item.modules.module_dynamic.major.archive.duration_text,
								create_time: Common.convertTimestampToDateTime(INFODATA.data.data.ctime),
								avatar_url: INFODATA.data.data.owner.face,
								frame: dynamicInfo.data.data.item.modules.module_author.pendant.image,
								share_url: "https://www.bilibili.com/video/" + bvid,
								username: checkvip$2(userProfileData.data.data.card),
								fans: Count(userProfileData.data.data.follower),
								user_shortid: userProfileData.data.data.card.mid,
								total_favorited: Count(userProfileData.data.data.like_num),
								following_count: Count(userProfileData.data.data.card.attention),
								render_time: Common.getCurrentTime(),
								dynamicTYPE: "",
								dynamic_id: dynamicInfo.data.data.item.id_str
							});
							this.e.reply(img);
						}
						break;
					case DynamicType.LIVE_RCMD: {
						const userINFO = await getBilibiliData("", "", {
							host_mid: dynamicInfo.data.data.item.modules.module_author.mid,
							typeMode: "strict"
						});
						img = await Render("bilibili/dynamic/DYNAMIC_TYPE_LIVE_RCMD", {
							image_url: dynamicCARD.live_play_info.cover,
							text: br$2(dynamicCARD.live_play_info.title),
							liveinf: br$2(`${dynamicCARD.live_play_info.area_name} | : ${dynamicCARD.live_play_info.room_id}`),
							username: checkvip$2(userINFO.data.data.card),
							avatar_url: userINFO.data.data.card.face,
							frame: dynamicInfo.data.data.item.modules.module_author.pendant.image,
							fans: Count(userINFO.data.data.follower),
							create_time: Common.convertTimestampToDateTime(dynamicInfo.data.data.item.modules.module_author.pub_ts),
							now_time: Common.getCurrentTime(),
							share_url: "https://live.bilibili.com/" + dynamicCARD.live_play_info.room_id,
							dynamicTYPE: ""
						});
						this.e.reply(img);
						break;
					}
					default: {
						const unknownItem = dynamicInfo.data.data.item;
						this.e.reply(`${unknownItem.type}`);
						break;
					}
				}
				break;
			}
			case "live_room_detail": {
				const liveInfo = await this.amagi.getBilibiliData("", {
					room_id: iddata.room_id,
					typeMode: "strict"
				});
				const roomInitInfo = await this.amagi.getBilibiliData("", {
					room_id: iddata.room_id,
					typeMode: "strict"
				});
				const userProfileData = await this.amagi.getBilibiliData("", {
					host_mid: roomInitInfo.data.data.uid,
					typeMode: "strict"
				});
				if (roomInitInfo.data.data.live_status === 0) {
					this.e.reply(`${userProfileData.data.data.card.name}\n~`);
					return true;
				}
				const img$1 = await Render("bilibili/dynamic/DYNAMIC_TYPE_LIVE_RCMD", {
					image_url: liveInfo.data.data.user_cover,
					text: br$2(liveInfo.data.data.title),
					liveinf: br$2(`${liveInfo.data.data.area_name} | : ${liveInfo.data.data.room_id}`),
					username: userProfileData.data.data.card.name,
					avatar_url: userProfileData.data.data.card.face,
					frame: userProfileData.data.data.card.pendant.image,
					fans: Count(userProfileData.data.data.card.fans),
					create_time: liveInfo.data.data.live_time === "-62170012800" ? "" : liveInfo.data.data.live_time,
					now_time: Common.getCurrentTime(),
					share_url: "https://live.bilibili.com/" + liveInfo.data.data.room_id,
					dynamicTYPE: ""
				});
				this.e.reply(img$1);
				break;
			}
			default: break;
		}
	}
	async getvideo({ infoData, playUrlData }) {
		/**  => FFmpeg */
		if (Config.bilibili.videopriority === true) this.islogin = false;
		switch (this.islogin) {
			case true: {
				const bmp4 = await downloadFile(this.Type === "one_video" ? playUrlData.data?.dash?.video[0].base_url : playUrlData.result.dash.video[0].base_url, {
					title: `Bil_V_${this.Type === "one_video" ? infoData && infoData.data.bvid : infoData && infoData.result.season_id}.mp4`,
					headers: this.headers
				});
				const bmp3 = await downloadFile(this.Type === "one_video" ? playUrlData.data?.dash?.audio[0].base_url : playUrlData.result.dash.audio[0].base_url, {
					title: `Bil_A_${this.Type === "one_video" ? infoData && infoData.data.bvid : infoData && infoData.result.season_id}.mp3`,
					headers: this.headers
				});
				if (bmp4.filepath && bmp3.filepath) await mergeFile(" + ", {
					path: bmp4.filepath,
					path2: bmp3.filepath,
					resultPath: Common.tempDri.video + `Bil_Result_${this.Type === "one_video" ? infoData && infoData.data.bvid : infoData && infoData.result.season_id}.mp4`,
					callback: async (success, resultPath) => {
						if (success) {
							const filePath = Common.tempDri.video + `${Config.app.removeCache ? "tmp_" + Date.now() : this.downloadfilename}.mp4`;
							fs$1.renameSync(resultPath, filePath);
							logger.mark(`: ${resultPath.split("/").pop()} -> ${filePath.split("/").pop()}`);
							logger.mark("");
							await Common.removeFile(bmp4.filepath, true);
							await Common.removeFile(bmp3.filepath, true);
							const stats = fs$1.statSync(filePath);
							const fileSizeInMB = Number((stats.size / (1024 * 1024)).toFixed(2));
							if (fileSizeInMB > Config.upload.groupfilevalue) return await uploadFile(this.e, {
								filepath: filePath,
								totalBytes: fileSizeInMB,
								originTitle: this.downloadfilename
							}, "", { useGroupFile: true });
							else
 /**  */
							return await uploadFile(this.e, {
								filepath: filePath,
								totalBytes: fileSizeInMB,
								originTitle: this.downloadfilename
							}, "");
						} else {
							await Common.removeFile(bmp4.filepath, true);
							await Common.removeFile(bmp3.filepath, true);
							return true;
						}
					}
				});
				break;
			}
			case false:
				/** ckDownLoadVideo() */
				await downloadVideo(this.e, {
					video_url: playUrlData.durl[0].url,
					title: {
						timestampTitle: `tmp_${Date.now()}.mp4`,
						originTitle: `${this.downloadfilename}.mp4`
					}
				});
				break;
			default: break;
		}
	}
};
function checkvip$2(member) {
	return member.vip.status === 1 ? `<span style="color: ${member.vip.nickname_color ?? "#FB7299"}; font-weight: 700;">${member.name}</span>` : `<span style="color: ${Common.useDarkTheme() ? "#e9e9e9" : "#313131"}; font-weight: 700;">${member.name}</span>`;
}
function br$2(data$1) {
	return data$1 = data$1.replace(/\n/g, "<br>");
}
function replacetext(text$1, rich_text_nodes) {
	for (const tag of rich_text_nodes) {
		const escapedText = tag.orig_text.replace(/([.*+?^${}()|[\]\\])/g, "\\$1").replace(/\n/g, "\\n");
		const regex = new RegExp(escapedText, "g");
		switch (tag.type) {
			case "topic":
				text$1 = text$1.replace(regex, `<span style="color: ${Common.useDarkTheme() ? "#58B0D5" : "#006A9E"};"><svg style="width: 80px;height: 80px;margin: 0 -25px -25px 0;" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" class="opus-module-topic__icon"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.4302 2.57458C11.4416 2.51023 11.4439 2.43974 11.4218 2.3528C11.3281 1.98196 10.9517 1.72037 10.5284 1.7527C10.432 1.76018 10.3599 1.78383 10.297 1.81376C10.2347 1.84398 10.1832 1.88155 10.1401 1.92465C10.1195 1.94485 10.1017 1.96692 10.0839 1.98897L10.0808 1.99289L10.0237 2.06277L9.91103 2.2033C9.76177 2.39141 9.61593 2.58191 9.47513 2.77556C9.33433 2.96936 9.19744 3.16585 9.06672 3.36638C9.00275 3.46491 8.93968 3.56401 8.87883 3.66461L8.56966 3.6613C8.00282 3.6574 7.43605 3.65952 6.86935 3.67034C6.80747 3.56778 6.74325 3.46677 6.67818 3.3664C6.54732 3.16585 6.41045 2.96934 6.26968 2.77568C6.12891 2.58186 5.98309 2.39134 5.83387 2.20322L5.72122 2.06268L5.66416 1.99279L5.6622 1.99036C5.64401 1.96783 5.62586 1.94535 5.60483 1.92454C5.56192 1.88144 5.51022 1.84388 5.44797 1.81364C5.38522 1.78386 5.31305 1.76006 5.21665 1.75273C4.80555 1.72085 4.4203 1.97094 4.32341 2.35273C4.30147 2.43968 4.30358 2.51018 4.31512 2.57453C4.32715 2.63859 4.34975 2.69546 4.38112 2.74649C4.39567 2.77075 4.41283 2.79315 4.42999 2.81557C4.43104 2.81694 4.43209 2.81831 4.43314 2.81968L4.48759 2.89122L4.59781 3.03355C4.74589 3.22242 4.89739 3.40905 5.05377 3.59254C5.09243 3.63788 5.13136 3.68306 5.17057 3.72785C4.99083 3.73681 4.81112 3.7467 4.63143 3.75756C4.41278 3.771 4.19397 3.78537 3.97547 3.80206L3.64757 3.82786L3.48362 3.84177L3.39157 3.85181C3.36984 3.8543 3.34834 3.8577 3.32679 3.86111C3.31761 3.86257 3.30843 3.86402 3.29921 3.86541C3.05406 3.90681 2.81526 3.98901 2.59645 4.10752C2.37765 4.22603 2.17867 4.38039 2.00992 4.56302C1.84117 4.74565 1.70247 4.95593 1.60144 5.18337C1.50025 5.4105 1.43687 5.65447 1.41362 5.90153C1.33103 6.77513 1.27663 7.6515 1.25742 8.5302C1.23758 9.40951 1.25835 10.2891 1.3098 11.1655C1.32266 11.3846 1.33738 11.6035 1.35396 11.8223L1.38046 12.1505L1.39472 12.3144L1.39658 12.335L1.39906 12.3583L1.40417 12.4048C1.40671 12.4305 1.41072 12.4558 1.41473 12.4811C1.41561 12.4866 1.41648 12.4922 1.41734 12.4977C1.45717 12.7449 1.53806 12.9859 1.65567 13.2074C1.77314 13.4289 1.92779 13.6304 2.11049 13.8022C2.29319 13.974 2.50441 14.1159 2.73329 14.2197C2.96201 14.3235 3.2084 14.3901 3.45836 14.4135C3.47066 14.415 3.48114 14.4159 3.49135 14.4167C3.49477 14.417 3.49817 14.4173 3.50159 14.4176L3.5425 14.4212L3.62448 14.4283L3.78843 14.4417L4.11633 14.4674C4.33514 14.4831 4.55379 14.4983 4.7726 14.5111C6.52291 14.6145 8.27492 14.6346 10.0263 14.5706C10.4642 14.5547 10.9019 14.5332 11.3396 14.5062C11.5584 14.4923 11.7772 14.4776 11.9959 14.4604L12.3239 14.434L12.4881 14.4196L12.5813 14.4093C12.6035 14.4065 12.6255 14.403 12.6474 14.3995C12.6565 14.3981 12.6655 14.3966 12.6746 14.3952C12.9226 14.3527 13.1635 14.2691 13.3844 14.1486C13.6052 14.0284 13.8059 13.8716 13.9759 13.6868C14.1463 13.5022 14.2861 13.2892 14.3874 13.0593C14.4381 12.9444 14.4793 12.8253 14.5108 12.7037C14.519 12.6734 14.5257 12.6428 14.5322 12.612L14.5421 12.566L14.55 12.5196C14.5556 12.4887 14.5607 12.4578 14.5641 12.4266C14.5681 12.3959 14.5723 12.363 14.5746 12.3373C14.6642 11.4637 14.7237 10.5864 14.7435 9.70617C14.764 8.825 14.7347 7.94337 14.6719 7.06715C14.6561 6.8479 14.6385 6.62896 14.6183 6.41033L14.5867 6.08246L14.5697 5.91853L14.5655 5.87758C14.5641 5.86445 14.5618 5.8473 14.5599 5.83231C14.5588 5.8242 14.5578 5.81609 14.5567 5.80797C14.5538 5.78514 14.5509 5.76229 14.5466 5.7396C14.5064 5.49301 14.4252 5.25275 14.3067 5.03242C14.1886 4.81208 14.0343 4.61153 13.8519 4.44095C13.6695 4.27038 13.4589 4.12993 13.2311 4.02733C13.0033 3.92458 12.7583 3.85907 12.5099 3.83636C12.4974 3.83492 12.4865 3.83394 12.4759 3.833C12.4729 3.83273 12.4698 3.83246 12.4668 3.83219L12.4258 3.82879L12.3438 3.82199L12.1798 3.80886L11.8516 3.78413C11.633 3.76915 11.4143 3.75478 11.1955 3.74288C10.993 3.73147 10.7904 3.72134 10.5878 3.71243L10.6914 3.59236C10.8479 3.40903 10.9992 3.22242 11.1473 3.03341L11.2576 2.89124L11.312 2.81971C11.3136 2.81773 11.3151 2.81575 11.3166 2.81377C11.3333 2.79197 11.3501 2.77013 11.3641 2.74653C11.3954 2.6955 11.418 2.63863 11.4302 2.57458ZM9.33039 5.49268C9.38381 5.16945 9.67705 4.95281 9.98536 5.00882L9.98871 5.00944C10.2991 5.06783 10.5063 5.37802 10.4524 5.70377L10.2398 6.99039L11.3846 6.9904C11.7245 6.9904 12 7.27925 12 7.63557C12 7.99188 11.7245 8.28073 11.3846 8.28073L10.0266 8.28059L9.7707 9.82911L11.0154 9.82913C11.3553 9.82913 11.6308 10.118 11.6308 10.4743C11.6308 10.8306 11.3553 11.1195 11.0154 11.1195L9.55737 11.1195L9.32807 12.5073C9.27465 12.8306 8.98141 13.0472 8.6731 12.9912L8.66975 12.9906C8.35937 12.9322 8.1522 12.622 8.20604 12.2962L8.40041 11.1195H6.89891L6.66961 12.5073C6.61619 12.8306 6.32295 13.0472 6.01464 12.9912L6.01129 12.9906C5.7009 12.9322 5.49374 12.622 5.54758 12.2962L5.74196 11.1195L4.61538 11.1195C4.27552 11.1195 4 10.8306 4 10.4743C4 10.118 4.27552 9.82913 4.61538 9.82913L5.95514 9.82911L6.21103 8.28059L4.98462 8.28073C4.64475 8.28073 4.36923 7.99188 4.36923 7.63557C4.36923 7.27925 4.64475 6.9904 4.98462 6.9904L6.42421 6.99039L6.67193 5.49268C6.72535 5.16945 7.01859 4.95281 7.3269 5.00882L7.33025 5.00944C7.64063 5.06783 7.8478 5.37802 7.79396 5.70377L7.58132 6.99039H9.08281L9.33039 5.49268ZM8.61374 9.82911L8.86963 8.28059H7.36813L7.11225 9.82911H8.61374Z" fill="currentColor"></path></svg> ${tag.orig_text}</span>`);
				break;
			case "RICH_TEXT_NODE_TYPE_TOPIC":
			case "RICH_TEXT_NODE_TYPE_AT":
				text$1 = text$1.replace(regex, `<span style="color: ${Common.useDarkTheme() ? "#58B0D5" : "#006A9E"};">${tag.orig_text}</span>`);
				break;
			case "RICH_TEXT_NODE_TYPE_LOTTERY":
				text$1 = text$1.replace(regex, `<span style="color: ${Common.useDarkTheme() ? "#58B0D5" : "#006A9E"};"><svg style="width: 65px;height: 65px;margin: 0 -15px -12px 0;" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 20 20" width="20" height="20"><path d="M3.7499750000000005 9.732083333333334C4.095158333333333 9.732083333333334 4.374975 10.011875000000002 4.374975 10.357083333333334L4.374975 15.357083333333334C4.374975 15.899458333333335 4.8147 16.339166666666667 5.357116666666667 16.339166666666667L14.642833333333334 16.339166666666667C15.185250000000002 16.339166666666667 15.625 15.899458333333335 15.625 15.357083333333334L15.625 10.357083333333334C15.625 10.011875000000002 15.904791666666668 9.732083333333334 16.25 9.732083333333334C16.595166666666668 9.732083333333334 16.875 10.011875000000002 16.875 10.357083333333334L16.875 15.357083333333334C16.875 16.589833333333335 15.875625000000001 17.589166666666667 14.642833333333334 17.589166666666667L5.357116666666667 17.589166666666667C4.124341666666667 17.589166666666667 3.124975 16.589833333333335 3.124975 15.357083333333334L3.124975 10.357083333333334C3.124975 10.011875000000002 3.4048 9.732083333333334 3.7499750000000005 9.732083333333334z" fill="currentColor"></path><path d="M2.4106916666666667 7.3214250000000005C2.4106916666666667 6.384516666666666 3.1702083333333335 5.625 4.107116666666667 5.625L15.892833333333334 5.625C16.82975 5.625 17.58925 6.384516666666666 17.58925 7.3214250000000005L17.58925 8.917583333333335C17.58925 9.74225 16.987583333333337 10.467208333333334 16.13125 10.554C15.073666666666668 10.661208333333335 13.087708333333333 10.803583333333334 10 10.803583333333334C6.912275 10.803583333333334 4.9263 10.661208333333335 3.8687250000000004 10.554C3.0123833333333336 10.467208333333334 2.4106916666666667 9.74225 2.4106916666666667 8.917583333333335L2.4106916666666667 7.3214250000000005zM4.107116666666667 6.875C3.8605666666666667 6.875 3.6606916666666667 7.0748750000000005 3.6606916666666667 7.3214250000000005L3.6606916666666667 8.917583333333335C3.6606916666666667 9.135250000000001 3.8040833333333333 9.291041666666667 3.9947583333333334 9.310375C5.0068 9.412958333333334 6.950525000000001 9.553583333333334 10 9.553583333333334C13.049458333333334 9.553583333333334 14.993166666666669 9.412958333333334 16.005166666666668 9.310375C16.195875 9.291041666666667 16.33925 9.135250000000001 16.33925 8.917583333333335L16.33925 7.3214250000000005C16.33925 7.0748750000000005 16.139375 6.875 15.892833333333334 6.875L4.107116666666667 6.875z" fill="currentColor"></path><path d="M5.446408333333333 4.464341666666667C5.446408333333333 3.1329416666666665 6.525716666666667 2.0536333333333334 7.857116666666667 2.0536333333333334C9.188541666666666 2.0536333333333334 10.267833333333334 3.1329416666666665 10.267833333333334 4.464341666666667L10.267833333333334 6.875058333333333L7.857116666666667 6.875058333333333C6.525716666666667 6.875058333333333 5.446408333333333 5.795741666666666 5.446408333333333 4.464341666666667zM7.857116666666667 3.3036333333333334C7.216075000000001 3.3036333333333334 6.696408333333334 3.8233 6.696408333333334 4.464341666666667C6.696408333333334 5.105391666666667 7.216075000000001 5.6250583333333335 7.857116666666667 5.6250583333333335L9.017833333333334 5.6250583333333335L9.017833333333334 4.464341666666667C9.017833333333334 3.8233 8.498166666666668 3.3036333333333334 7.857116666666667 3.3036333333333334z" fill="currentColor"></path><path d="M9.732083333333334 4.464341666666667C9.732083333333334 3.1329416666666665 10.811416666666666 2.0536333333333334 12.142833333333334 2.0536333333333334C13.474250000000001 2.0536333333333334 14.553583333333336 3.1329416666666665 14.553583333333336 4.464341666666667C14.553583333333336 5.795741666666666 13.474250000000001 6.875058333333333 12.142833333333334 6.875058333333333L9.732083333333334 6.875058333333333L9.732083333333334 4.464341666666667zM12.142833333333334 3.3036333333333334C11.501791666666666 3.3036333333333334 10.982083333333334 3.8233 10.982083333333334 4.464341666666667L10.982083333333334 5.6250583333333335L12.142833333333334 5.6250583333333335C12.783875 5.6250583333333335 13.303583333333334 5.105391666666667 13.303583333333334 4.464341666666667C13.303583333333334 3.8233 12.783875 3.3036333333333334 12.142833333333334 3.3036333333333334z" fill="currentColor"></path><path d="M10 4.732058333333334C10.345166666666666 4.732058333333334 10.625 5.011875 10.625 5.357058333333334L10.625 16.428500000000003C10.625 16.773666666666667 10.345166666666666 17.053500000000003 10 17.053500000000003C9.654791666666668 17.053500000000003 9.375 16.773666666666667 9.375 16.428500000000003L9.375 5.357058333333334C9.375 5.011875 9.654791666666668 4.732058333333334 10 4.732058333333334z" fill="currentColor"></path></svg> ${tag.orig_text}</span>`);
				break;
			case "RICH_TEXT_NODE_TYPE_WEB":
				text$1 = text$1.replace(regex, `<span style="color: ${Common.useDarkTheme() ? "#58B0D5" : "#006A9E"};"><svg style="width: 60px;height: 60px;margin: 0 -15px -12px 0;" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 20 20" width="20" height="20"><path d="M9.571416666666666 7.6439C9.721125 7.33675 10.091416666666667 7.209108333333334 10.398583333333335 7.358808333333333C10.896041666666667 7.540316666666667 11.366333333333333 7.832000000000001 11.767333333333333 8.232975C13.475833333333334 9.941541666666668 13.475833333333334 12.711625 11.767333333333333 14.420166666666669L9.704916666666666 16.482583333333334C7.996383333333334 18.191125000000003 5.226283333333334 18.191125000000003 3.5177416666666668 16.482583333333334C1.8091916666666668 14.774041666666669 1.8091916666666668 12.003916666666667 3.5177416666666668 10.295375L5.008791666666667 8.804333333333334C5.252875 8.56025 5.6486 8.56025 5.892683333333334 8.804333333333334C6.136758333333334 9.048416666666668 6.136758333333334 9.444125000000001 5.892683333333334 9.688208333333334L4.401625 11.179250000000001C3.1812333333333336 12.399666666666667 3.1812333333333336 14.378291666666668 4.401625 15.598708333333335C5.622000000000001 16.819083333333335 7.60065 16.819083333333335 8.821041666666668 15.598708333333335L10.883416666666667 13.536291666666667C12.103833333333334 12.315916666666666 12.103833333333334 10.337250000000001 10.883416666666667 9.116875C10.582458333333333 8.815875 10.229416666666667 8.600908333333333 9.856458333333334 8.471066666666667C9.549333333333333 8.321375 9.421708333333335 7.9510499999999995 9.571416666666666 7.6439z" fill="currentColor"></path><path d="M15.597541666666668 4.402641666666667C14.377166666666668 3.1822500000000002 12.398541666666667 3.1822500000000002 11.178125000000001 4.402641666666667L9.11575 6.465033333333333C7.895358333333333 7.685425 7.895358333333333 9.664041666666668 9.11575 10.884458333333333C9.397666666666668 11.166375 9.725916666666667 11.371583333333334 10.073083333333333 11.500958333333333C10.376583333333334 11.658083333333334 10.495291666666667 12.031416666666667 10.338208333333332 12.334875C10.181083333333333 12.638375 9.80775 12.757083333333334 9.504291666666667 12.6C9.042416666666666 12.420333333333334 8.606383333333333 12.142833333333334 8.231858333333333 11.768333333333334C6.523316666666667 10.059791666666667 6.523316666666667 7.289691666666666 8.231858333333333 5.58115L10.29425 3.5187583333333334C12.002791666666667 1.8102083333333334 14.772875 1.8102083333333334 16.481458333333336 3.5187583333333334C18.19 5.2273000000000005 18.19 7.997400000000001 16.481458333333336 9.705916666666667L15.054916666666667 11.132458333333334C14.810875000000001 11.3765 14.415166666666668 11.3765 14.171041666666667 11.132458333333334C13.927 10.888333333333334 13.927 10.492625 14.171041666666667 10.248541666666666L15.597541666666668 8.822041666666667C16.81791666666667 7.601666666666667 16.81791666666667 5.623025 15.597541666666668 4.402641666666667z" fill="currentColor"></path></svg> ${tag.text}</span>`);
				break;
			case "RICH_TEXT_NODE_TYPE_EMOJI": {
				const regex$1 = new RegExp(tag.orig_text.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g");
				const emojiUrl = tag.emoji.gif_url || tag.emoji.icon_url;
				text$1 = text$1.replace(regex$1, `<img src='${emojiUrl}' style='height: 160px; margin: 0 0 -10px 0;'>`);
				break;
			}
			case "RICH_TEXT_NODE_TYPE_VOTE":
				text$1 = text$1.replace(regex, `<span style="color: ${Common.useDarkTheme() ? "#58B0D5" : "#006A9E"};"><svg style="width:60px;height: 60px;margin: 0 -15px -12px 0;" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 20 20" width="20" height="20"><path d="M1.6666666666666667 11.875916666666667C1.6666666666666667 10.725333333333333 2.5994083333333333 9.792583333333333 3.75 9.792583333333333L4.583333333333334 9.792583333333333C5.733925 9.792583333333333 6.666666666666667 10.725333333333333 6.666666666666667 11.875916666666667L6.666666666666667 14.792583333333335C6.666666666666667 15.943166666666666 5.733925 16.87591666666667 4.583333333333334 16.87591666666667L3.75 16.87591666666667C2.5994083333333333 16.87591666666667 1.6666666666666667 15.943166666666666 1.6666666666666667 14.792583333333335L1.6666666666666667 11.875916666666667zM3.75 11.042583333333333C3.2897666666666665 11.042583333333333 2.916666666666667 11.415666666666667 2.916666666666667 11.875916666666667L2.916666666666667 14.792583333333335C2.916666666666667 15.252833333333333 3.2897666666666665 15.625916666666669 3.75 15.625916666666669L4.583333333333334 15.625916666666669C5.043575000000001 15.625916666666669 5.416666666666667 15.252833333333333 5.416666666666667 14.792583333333335L5.416666666666667 11.875916666666667C5.416666666666667 11.415666666666667 5.043575000000001 11.042583333333333 4.583333333333334 11.042583333333333L3.75 11.042583333333333z" fill="currentColor"></path><path d="M7.5 4.792483333333334C7.5 3.6418916666666665 8.432758333333334 2.70915 9.583333333333334 2.70915L10.416666666666668 2.70915C11.56725 2.70915 12.5 3.6418916666666665 12.5 4.792483333333334L12.5 14.792500000000002C12.5 15.943083333333332 11.56725 16.875833333333336 10.416666666666668 16.875833333333336L9.583333333333334 16.875833333333336C8.432758333333334 16.875833333333336 7.5 15.943083333333332 7.5 14.792500000000002L7.5 4.792483333333334zM9.583333333333334 3.95915C9.123083333333334 3.95915 8.75 4.3322416666666665 8.75 4.792483333333334L8.75 14.792500000000002C8.75 15.252708333333333 9.123083333333334 15.625833333333334 9.583333333333334 15.625833333333334L10.416666666666668 15.625833333333334C10.876916666666668 15.625833333333334 11.25 15.252708333333333 11.25 14.792500000000002L11.25 4.792483333333334C11.25 4.3322416666666665 10.876916666666668 3.95915 10.416666666666668 3.95915L9.583333333333334 3.95915z" fill="currentColor"></path><path d="M13.333333333333334 9.1675C13.333333333333334 8.016891666666666 14.266083333333333 7.08415 15.416666666666668 7.08415L16.25 7.08415C17.400583333333334 7.08415 18.333333333333336 8.016891666666666 18.333333333333336 9.1675L18.333333333333336 14.792500000000002C18.333333333333336 15.943083333333332 17.400583333333334 16.875833333333336 16.25 16.875833333333336L15.416666666666668 16.875833333333336C14.266083333333333 16.875833333333336 13.333333333333334 15.943083333333332 13.333333333333334 14.792500000000002L13.333333333333334 9.1675zM15.416666666666668 8.334158333333333C14.956416666666668 8.334158333333333 14.583333333333334 8.70725 14.583333333333334 9.1675L14.583333333333334 14.792500000000002C14.583333333333334 15.252708333333333 14.956416666666668 15.625833333333334 15.416666666666668 15.625833333333334L16.25 15.625833333333334C16.71025 15.625833333333334 17.083333333333336 15.252708333333333 17.083333333333336 14.792500000000002L17.083333333333336 9.1675C17.083333333333336 8.70725 16.71025 8.334158333333333 16.25 8.334158333333333L15.416666666666668 8.334158333333333z" fill="currentColor"></path></svg> ${tag.text} </span>`);
				break;
			case "RICH_TEXT_NODE_TYPE_VIEW_PICTURE":
				text$1 = text$1.replace(regex, `<span style="color: ${Common.useDarkTheme() ? "#58B0D5" : "#006A9E"};"><svg style="width: 80px; height: 80px;" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 22 22" width="22" height="22"><path d="M7.791666666666666 7.733060333333333C7.253044666666666 7.733060333333333 6.816416666666667 8.169688333333333 6.816416666666667 8.708310333333333C6.816416666666667 9.246946 7.253044666666666 9.683544999999999 7.791666666666666 9.683544999999999C8.330281000000001 9.683544999999999 8.766916666666667 9.246946 8.766916666666667 8.708310333333333C8.766916666666667 8.169688333333333 8.330281000000001 7.733060333333333 7.791666666666666 7.733060333333333zM5.558583333333333 8.708310333333333C5.558583333333333 7.475007999999999 6.558372 6.4752193333333325 7.791666666666666 6.4752193333333325C9.024961333333332 6.4752193333333325 10.02475 7.475007999999999 10.02475 8.708310333333333C10.02475 9.941568333333333 9.024961333333332 10.941378333333333 7.791666666666666 10.941378333333333C6.558372 10.941378333333333 5.558583333333333 9.941568333333333 5.558583333333333 8.708310333333333z" fill="currentColor"></path><path d="M11 4.543596666666667C8.690401666666668 4.543596666666667 6.673815333333333 4.661083166666667 5.250284333333333 4.776523999999999C4.243521333333333 4.858162833333334 3.4624053333333333 5.627683666666666 3.37265 6.626020666666667C3.268142166666667 7.788485666666666 3.170833333333333 9.321563333333334 3.170833333333333 10.9978C3.170833333333333 12.673983333333332 3.268142166666667 14.207033333333332 3.37265 15.369535C3.4624053333333333 16.36785666666667 4.243521333333333 17.137388333333334 5.250284333333333 17.219013333333333C6.673816833333333 17.334481666666665 8.690401666666668 17.451966666666664 11 17.451966666666664C13.309854999999999 17.451966666666664 15.326548333333335 17.33439 16.750163333333333 17.218959999999996C17.756758333333334 17.137349999999998 18.5377 16.36804 18.627441666666666 15.36994C18.731925 14.207988333333333 18.829166666666666 12.675175 18.829166666666666 10.9978C18.829166666666666 9.320333333333332 18.731925 7.787542999999999 18.627441666666666 6.6255715C18.5377 5.627479 17.756758333333334 4.858190333333333 16.750163333333333 4.776553C15.326548333333335 4.661109166666666 13.309854999999999 4.543596666666667 11 4.543596666666667zM5.145209166666667 3.480780333333333C6.5952265 3.3631968333333333 8.647761666666666 3.2435966666666665 11 3.2435966666666665C13.352495000000001 3.2435966666666665 15.405159999999999 3.3632151666666665 16.855203333333332 3.4808078333333334C18.484758333333332 3.6129723333333335 19.775116666666666 4.873037 19.922241666666665 6.509160333333334C20.02923333333333 7.6992561666666655 20.129166666666666 9.272141666666666 20.129166666666666 10.9978C20.129166666666666 12.723366666666667 20.02923333333333 14.296258333333332 19.922241666666665 15.486381666666665C19.775116666666666 17.12246833333333 18.484758333333332 18.382566666666666 16.855203333333332 18.514723333333333C15.405159999999999 18.63231 13.352495000000001 18.751966666666664 11 18.751966666666664C8.647761666666666 18.751966666666664 6.5952265 18.63231 5.145209166666667 18.514761666666665C3.515391333333333 18.382566666666666 2.224978166666667 17.122193333333332 2.0778760000000003 15.485923333333332C1.970837 14.295341666666666 1.8708333333333333 12.722213333333332 1.8708333333333333 10.9978C1.8708333333333333 9.273295 1.970837 7.700146833333332 2.0778760000000003 6.509618666666666C2.224978166666667 4.8733365 3.515391333333333 3.6129448333333336 5.145209166666667 3.480780333333333z" fill="currentColor"></path><path d="M14.586553333333333 12.397246666666668C14.19608 12.006681666666665 13.562881666666666 12.006681666666665 13.172316666666665 12.397208333333333L11.288666666666668 14.280896666666665C10.517069999999999 15.052493333333333 9.265836666666667 15.052218333333332 8.494585500000001 14.280124999999998C8.166277166666667 13.951508333333333 7.633659333333334 13.951363333333331 7.305149499999999 14.279834999999999L5.922092833333333 15.66269C5.6682380000000006 15.91648833333333 5.256674833333333 15.91648833333333 5.002853666666667 15.662636666666666C4.7490248333333325 15.4088 4.749050833333333 14.99722 5.002907166666666 14.743368333333333L6.385979166666666 13.360513333333333C7.222356166666667 12.524223333333333 8.578404666666666 12.524628333333332 9.414303333333333 13.361376666666667C9.677975 13.6253 10.105658333333334 13.625445 10.369436666666665 13.361666666666666L12.253033333333333 11.477978333333331C13.151301666666665 10.57971 14.607698333333333 10.579763333333334 15.505913333333332 11.478108333333331L16.99718 12.969611666666665C17.250978333333336 13.223448333333334 17.25094 13.63499 16.997049999999998 13.888841666666666C16.743198333333332 14.142639999999998 16.331671666666665 14.142639999999998 16.07782 13.88875L14.586553333333333 12.397246666666668z" fill="currentColor"></path></svg> ${tag.orig_text}</span>`);
				break;
		}
	}
	return text$1;
}
const qnd = {
	6: " 240P",
	16: " 360P",
	32: "480P",
	64: "720P",
	74: " 720P60",
	80: " 1080P",
	112: " 1080P+",
	116: " 1080P60",
	120: " 4K",
	125: " HDR ",
	126: "",
	127: " 8K"
};
/**
* Bhtml
* @param colors 
* @param text 
* @returns html
*/
const generateGradientStyle = (colors, text$1) => {
	if (!colors) return "";
	const gradientString = colors.map((color) => {
		return `${color}`;
	}).join(", ");
	return `<span style="font-family: bilifont; color: transparent; background-clip: text; margin: 0 200px 0 0; font-size: 43px; background-image: linear-gradient(135deg, ${gradientString} 0%, ${gradientString} 100%); ">${text$1}</span>`;
};
/**
* 
* @param pic 
* @returns 
*/
const cover = (pic) => {
	const imgArray = [];
	for (const i of pic) {
		const obj = { image_src: i.img_src };
		imgArray.push(obj);
	}
	return imgArray;
};
/**
* HTML
* @param decorate URL
* @returns HTMLdiv
*/
const generateDecorationCard = (decorate) => {
	return decorate ? `<div style="display: flex; width: 500px; height: 150px; background-position: center; background-attachment: fixed; background-repeat: no-repeat; background-size: contain; align-items: center; justify-content: flex-end; background-image: url('${decorate.card_url}')">${generateGradientStyle(decorate.fan?.color_format?.colors, decorate.fan.num_str || decorate.fan.num_desc)}</div>` : "<div></div>";
};
function mapping_table(type$1) {
	const Array$1 = {
		1: [
			"DYNAMIC_TYPE_AV",
			"DYNAMIC_TYPE_PGC",
			"DYNAMIC_TYPE_UGC_SEASON"
		],
		11: ["DYNAMIC_TYPE_DRAW"],
		12: ["DYNAMIC_TYPE_ARTICLE"],
		17: [
			"DYNAMIC_TYPE_LIVE_RCMD",
			"DYNAMIC_TYPE_FORWARD",
			"DYNAMIC_TYPE_WORD",
			"DYNAMIC_TYPE_COMMON_SQUARE"
		],
		19: ["DYNAMIC_TYPE_MEDIALIST"]
	};
	for (const key in Array$1) if (Array$1[key].includes(type$1)) return parseInt(key, 10);
	return 1;
}
const oid = (dynamicINFO, dynamicInfoCard) => {
	switch (dynamicINFO.data.item.type) {
		case "DYNAMIC_TYPE_WORD":
		case "DYNAMIC_TYPE_FORWARD": return dynamicINFO.data.item.id_str;
		default: return dynamicInfoCard.data.card.desc.rid.toString();
	}
};
/**
* 
* @param accept_description 
* @param videoList 
* @param audioUrl 
* @param bvid bvidBV
* @returns
*/
const bilibiliProcessVideos = async (qualityOptions, videoList, audioUrl) => {
	if (qualityOptions.qn !== 0 || Config.bilibili.videoQuality !== 0) {
		const targetQuality = qualityOptions.qn ?? Config.bilibili.videoQuality;
		let matchedVideo = videoList.find((video) => video.id === targetQuality);
		if (!matchedVideo) {
			const sortedVideos = [...videoList].sort((a, b) => a.id - b.id);
			const lowerVideos = sortedVideos.filter((video) => video.id < targetQuality);
			const higherVideos = sortedVideos.filter((video) => video.id > targetQuality);
			if (lowerVideos.length > 0) matchedVideo = lowerVideos[lowerVideos.length - 1];
			else if (higherVideos.length > 0) matchedVideo = higherVideos[0];
			else matchedVideo = sortedVideos[0];
		}
		qualityOptions.accept_description = [qnd[matchedVideo.id] || qualityOptions.accept_description[0]];
		videoList = [matchedVideo];
		return {
			accept_description: qualityOptions.accept_description,
			videoList
		};
	}
	const results = {};
	for (const video of videoList) {
		const size = await getvideosize(video.base_url, audioUrl, qualityOptions.bvid);
		results[video.id] = size;
	}
	const sizes = Object.values(results).map((size) => parseFloat(size.replace("MB", "")));
	let closestId = null;
	let smallestDifference = Infinity;
	sizes.forEach((size, index$1) => {
		if (size <= (qualityOptions?.maxAutoVideoSize ?? Config.bilibili.maxAutoVideoSize)) {
			const difference = Math.abs(size - (qualityOptions?.maxAutoVideoSize ?? Config.bilibili.maxAutoVideoSize));
			if (difference < smallestDifference) {
				smallestDifference = difference;
				closestId = Object.keys(results)[index$1];
			}
		}
	});
	if (closestId !== null) {
		const closestQuality = qnd[Number(closestId)];
		qualityOptions.accept_description = qualityOptions.accept_description.filter((desc$1) => desc$1 === closestQuality);
		if (qualityOptions.accept_description.length === 0) qualityOptions.accept_description = [closestQuality];
		videoList = [videoList.find((video) => video.id === Number(closestId))];
	} else {
		videoList = [[...videoList].pop()];
		qualityOptions.accept_description = [[...qualityOptions.accept_description].pop()];
	}
	return {
		accept_description: qualityOptions.accept_description,
		videoList
	};
};
/**
* [bilibili] 
* @param videourl - URL
* @param audiourl - URL
* @param bvid - BV
* @returns  (MB),2
*/
const getvideosize = async (videourl, audiourl, bvid) => {
	const videoheaders = await new Networks({
		url: videourl,
		headers: {
			...baseHeaders,
			Referer: `https://api.bilibili.com/video/${bvid}`,
			Cookie: Config.cookies.bilibili
		}
	}).getHeaders();
	const audioheaders = await new Networks({
		url: audiourl,
		headers: {
			...baseHeaders,
			Referer: `https://api.bilibili.com/video/${bvid}`,
			Cookie: Config.cookies.bilibili
		}
	}).getHeaders();
	const videoSize = videoheaders["content-range"]?.match(/\/(\d+)/) ? parseInt(videoheaders["content-range"]?.match(/\/(\d+)/)[1], 10) : 0;
	const audioSize = audioheaders["content-range"]?.match(/\/(\d+)/) ? parseInt(audioheaders["content-range"]?.match(/\/(\d+)/)[1], 10) : 0;
	const videoSizeInMB = (videoSize / (1024 * 1024)).toFixed(2);
	const audioSizeInMB = (audioSize / (1024 * 1024)).toFixed(2);
	return (parseFloat(videoSizeInMB) + parseFloat(audioSizeInMB)).toFixed(2);
};
/**
* 
*/
const formatVideoStats = (view$1, danmaku, like, coin, share, favorite) => {
	const viewText = ` : ${Count(view$1)}`;
	const danmakuText = ` : ${Count(danmaku)}`;
	const likeText = ` : ${Count(like)}`;
	const coinText = ` : ${Count(coin)}`;
	const shareText = ` : ${Count(share)}`;
	const favoriteText = ` : ${Count(favorite)}`;
	const firstColItems = [
		viewText,
		likeText,
		shareText
	];
	const maxFirstColLength = Math.max(...firstColItems.map((item) => getStringDisplayWidth(item)));
	return `${alignTwoColumns(viewText, danmakuText, maxFirstColLength)}\n${alignTwoColumns(likeText, coinText, maxFirstColLength)}\n${alignTwoColumns(shareText, favoriteText, maxFirstColLength)}`;
};
/**
* 
*/
const alignTwoColumns = (col1, col2, targetLength) => {
	const spacesNeeded = targetLength - getStringDisplayWidth(col1) + 5;
	return col1 + " ".repeat(spacesNeeded) + col2;
};
/**
* 
* emoji
*/
const getStringDisplayWidth = (str) => {
	let width = 0;
	for (let i = 0; i < str.length; i++) {
		const code = str.codePointAt(i);
		if (!code) continue;
		if (code > 65535) {
			width += 2;
			i++;
		} else if (code >= 12288 && code <= 40959 || code >= 65280 && code <= 65519 || code === 8230 || code === 8212 || code >= 11904 && code <= 12031 || code >= 12288 && code <= 12351 || code >= 12736 && code <= 12783 || code >= 12800 && code <= 13055 || code >= 13056 && code <= 13311 || code >= 44032 && code <= 55215 || code >= 63744 && code <= 64255 || code >= 65072 && code <= 65103) width += 2;
		else if (code === 8205 || code >= 65024 && code <= 65039 || code >= 127995 && code <= 127999) width += 0;
		else width += 1;
	}
	return width;
};

//#endregion
//#region src/platform/bilibili/comments.ts
/**
* Bilibili
* @param commentsData 
* @param host_mid UPID
* @returns 
*/
function bilibiliComments(commentsData, host_mid) {
	if (!commentsData) return [];
	let jsonArray = [];
	if (commentsData.code === 404) return null;
	if (commentsData.data.top && commentsData.data.top.upper) {
		const topReply = commentsData.data.top.upper;
		const ctime = getRelativeTimeFromTimestamp(topReply.ctime);
		const emote = topReply.content.emote;
		let message = topReply.content.message;
		if (message && emote) message = emoteToUrl(message, emote);
		const avatar = topReply.member.avatar;
		const frame = topReply.member.pendant.image;
		const uname = checkvip$1(topReply.member);
		const level = topReply.member.level_info.current_level;
		const vipstatus = topReply.member.vip.status;
		const like = topReply.like;
		const replylength = topReply.rcount;
		const location = topReply.reply_control?.location?.replace("IP", "") ?? "";
		const img_src = topReply.content && topReply.content.pictures && topReply.content.pictures.length > 0 ? topReply.content.pictures[0].img_src : null;
		const members = topReply.content.members;
		const isUP = topReply.mid_str === host_mid;
		const obj = {
			id: 0,
			ctime,
			message,
			avatar,
			frame,
			uname,
			level,
			vipstatus,
			img_src,
			replylength,
			location,
			like,
			icon_big_vip: vipstatus === 1 ? "https://i0.hdslb.com/bfs/seed/jinkela/short/user-avatar/big-vip.svg" : null,
			members,
			isTop: true,
			isUP
		};
		jsonArray.push(obj);
	}
	for (const [i, reply] of commentsData.data.replies.entries()) {
		const ctime = getRelativeTimeFromTimestamp(reply.ctime);
		const emote = reply.content.emote;
		let message = reply.content.message;
		if (message && emote) message = emoteToUrl(message, emote);
		const avatar = reply.member.avatar;
		const frame = reply.member.pendant.image;
		const uname = checkvip$1(reply.member);
		const level = reply.member.level_info.current_level;
		const vipstatus = reply.member.vip.vipStatus;
		const like = reply.like;
		const replylength = reply.rcount;
		const location = reply.reply_control?.location?.replace("IP", "") ?? "";
		const img_src = reply.content && reply.content.pictures && reply.content.pictures.length > 0 ? reply.content.pictures[0].img_src : null;
		const members = reply.content.members;
		const isUP = reply.mid_str === host_mid;
		const obj = {
			id: i + 1,
			ctime,
			message,
			avatar,
			frame,
			uname,
			level,
			vipstatus,
			img_src,
			replylength,
			location,
			like,
			icon_big_vip: vipstatus === 1 ? "https://i0.hdslb.com/bfs/seed/jinkela/short/user-avatar/big-vip.svg" : null,
			members,
			isTop: false,
			isUP
		};
		jsonArray.push(obj);
	}
	jsonArray.sort((a, b) => {
		if (a.isTop && !b.isTop) return -1;
		if (!a.isTop && b.isTop) return 1;
		if (a.isTop && b.isTop) return 0;
		return b.like - a.like;
	});
	/**  */
	for (const i of jsonArray) if (i.like > 1e4) i.like = (i.like / 1e4).toFixed(1) + "w";
	jsonArray = space(jsonArray);
	/**  */
	for (const comment of jsonArray) {
		let originalText = comment.message;
		if (comment.members && comment.members.length > 0) for (const member of comment.members) {
			const regex = new RegExp(`@${member.uname}`, "g");
			originalText = originalText.replace(regex, `<span style="color: ${Common.useDarkTheme() ? "#58B0D5" : "#006A9E"};">@${member.uname}</span>`);
		}
		comment.message = originalText;
	}
	let res;
	res = br$1(jsonArray);
	res = [...res.filter((c) => c.isTop), ...res.filter((c) => !c.isTop)].slice(0, Config.bilibili.numcomment);
	return res;
}
/** img */
const emoteToUrl = (message, emote) => {
	for (const key in emote) if (Object.prototype.hasOwnProperty.call(emote, key)) {
		if (message.includes(key)) {
			if (message.includes("[") && message.includes("]")) message = message.replace(new RegExp(key.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g"), `<img src="${emote[key].url}"/>`);
		}
	}
	return message;
};
/**  */
function space(data$1) {
	for (const i in data$1) if (data$1[i].message) data$1[i].message = data$1[i].message.replace(/ /g, " ");
	return data$1;
}
/** <br> */
function br$1(data$1) {
	for (const i in data$1) {
		let message = data$1[i].message;
		message = message?.replace(/\n/g, "<br>");
		data$1[i].message = message;
	}
	return data$1;
}
/**  */
function checkvip$1(member) {
	return member.vip.vipStatus === 1 ? `<span style="color: ${member.vip.nickname_color ?? "#FB7299"}; font-weight: 700;">${member.uname}</span>` : `<span style="color: #888">${member.uname}</span>`;
}
/**  */
function getRelativeTimeFromTimestamp(timestamp) {
	const differenceInSeconds = Math.floor(Date.now() / 1e3) - timestamp;
	if (differenceInSeconds < 30) return "";
	else if (differenceInSeconds < 60) return differenceInSeconds + "";
	else if (differenceInSeconds < 3600) return Math.floor(differenceInSeconds / 60) + "";
	else if (differenceInSeconds < 86400) return Math.floor(differenceInSeconds / 3600) + "";
	else if (differenceInSeconds < 2592e3) return Math.floor(differenceInSeconds / 86400) + "";
	else if (differenceInSeconds < 7776e3) return Math.floor(differenceInSeconds / 2592e3) + "";
	else {
		const date$2 = /* @__PURE__ */ new Date(timestamp * 1e3);
		const year = date$2.getFullYear();
		const month = (date$2.getMonth() + 1).toString().padStart(2, "0");
		const day = date$2.getDate().toString().padStart(2, "0");
		return year + "-" + month + "-" + day;
	}
}

//#endregion
//#region src/platform/bilibili/genParams.ts
/**
* 
* @param apiURL 
* @returns
*/
async function genParams(apiURL) {
	if (Config.cookies.bilibili === "" || Config.cookies.bilibili === null) return "&platform=html5";
	const loginInfo = await getBilibiliData("", Config.cookies.bilibili);
	const genSign = await wbi_sign(apiURL, Config.cookies.bilibili);
	const qn = [
		6,
		16,
		32,
		64,
		74,
		80,
		112,
		116,
		120,
		125,
		126,
		127
	];
	let isvip;
	loginInfo.data.data.vipStatus === 1 ? isvip = true : isvip = false;
	if (isvip) return `&fnval=16&fourk=1&${genSign}`;
	else return `&qn=${qn[3]}&fnval=16`;
}
async function checkCk() {
	if (Config.cookies.bilibili === "" || Config.cookies.bilibili === null) return {
		Status: "!isLogin",
		isVIP: false
	};
	const loginInfo = await getBilibiliData("", Config.cookies.bilibili);
	let isVIP;
	loginInfo.data.data.vipStatus === 1 ? isVIP = true : isVIP = false;
	if (isVIP) return {
		Status: "isLogin",
		isVIP
	};
	else return {
		Status: "isLogin",
		isVIP
	};
}

//#endregion
//#region src/platform/bilibili/getID.ts
/**
* return aweme_id
* @param {string} url 
* @returns
*/
async function getBilibiliID(url$1) {
	const resp = await axios.get(url$1, { headers: { "User-Agent": "Apifox/1.0.0 (https://apifox.com)" } });
	const longLink = resp?.request?.res?.responseUrl ?? resp?.config?.url ?? url$1;
	let result = {};
	let pValue;
	const parsedUrl = new URL(longLink);
	const pParam = parsedUrl.searchParams.get("p");
	if (pParam) {
		pValue = parseInt(pParam, 10);
		if (isNaN(pValue)) pValue = void 0;
	}
	const pathname = parsedUrl.pathname;
	const hostname$1 = parsedUrl.hostname;
	switch (true) {
		case hostname$1 === "t.bilibili.com" && /^\/\d+/.test(pathname) || hostname$1 === "www.bilibili.com" && /^\/opus\/\d+/.test(pathname): {
			const tMatch = hostname$1 === "t.bilibili.com" ? pathname.match(/^\/(\d+)/) : null;
			const opusMatch = hostname$1 === "www.bilibili.com" ? pathname.match(/^\/opus\/(\d+)/) : null;
			const dynamic_id = tMatch ?? opusMatch;
			result = {
				type: "dynamic_info",
				dynamic_id: dynamic_id ? dynamic_id[1] : void 0
			};
			break;
		}
		case /\/bangumi\/play\/(\w+)/.test(longLink): {
			const playMatch = /\/bangumi\/play\/(\w+)/.exec(longLink);
			const id = playMatch ? playMatch[1] : "";
			let realid = "";
			let isEpid = false;
			if (id.startsWith("ss")) realid = id;
			else if (id.startsWith("ep")) {
				realid = id;
				isEpid = true;
			}
			result = {
				type: "bangumi_video_info",
				isEpid,
				realid
			};
			break;
		}
		case /(video\/|video-)([A-Za-z0-9]+)/.test(longLink): {
			const bvideoMatch = /video\/([A-Za-z0-9]+)|bvid=([A-Za-z0-9]+)/.exec(longLink);
			result = {
				type: "one_video",
				bvid: bvideoMatch ? bvideoMatch[1] || bvideoMatch[2] : void 0,
				...pValue !== void 0 && { p: pValue }
			};
			break;
		}
		case /festival\/([A-Za-z0-9]+)/.test(longLink): {
			const festivalMatch = /festival\/([A-Za-z0-9]+)\?bvid=([A-Za-z0-9]+)/.exec(longLink);
			result = {
				type: "one_video",
				id: festivalMatch ? festivalMatch[2] : void 0
			};
			break;
		}
		case /play\/(\S+?)\??/.test(longLink): {
			const playMatch = /play\/(\w+)/.exec(longLink);
			const id = playMatch ? playMatch[1] : "";
			const isEpid = false;
			if (id.startsWith("ss")) result.realid = "season_id";
			else if (id.startsWith("ep")) result.realid = "ep_id";
			result = {
				type: "bangumi_video_info",
				isEpid,
				realid: playMatch ? playMatch[1] : ""
			};
			break;
		}
		case /^https:\/\/t\.bilibili\.com\/(\d+)/.test(longLink) || /^https:\/\/www\.bilibili\.com\/opus\/(\d+)/.test(longLink): {
			const tMatch = /^https:\/\/t\.bilibili\.com\/(\d+)/.exec(longLink);
			const opusMatch = /^https:\/\/www\.bilibili\.com\/opus\/(\d+)/.exec(longLink);
			const dynamic_id = tMatch ?? opusMatch;
			result = {
				type: "dynamic_info",
				dynamic_id: dynamic_id ? dynamic_id[1] : dynamic_id
			};
			break;
		}
		case longLink.includes("live.bilibili.com"): {
			const match = /https?:\/\/live\.bilibili\.com\/(\d+)/.exec(longLink);
			result = {
				type: "live_room_detail",
				room_id: match ? match[1] : void 0
			};
			break;
		}
		default:
			logger.warn("ID");
			break;
	}
	return result;
}

//#endregion
//#region src/platform/bilibili/login.ts
/** B */
const bilibiliLogin = async (e) => {
	/**  */
	const qrcodeurl = await getBilibiliData("", { typeMode: "strict" });
	const qrimg = await Render("bilibili/qrcodeImg", { share_url: qrcodeurl.data.data.url });
	const base64Data = qrimg[0]?.file;
	if (!base64Data) throw new Error("");
	const cleanBase64 = base64Data.replace(/^base64:\/\//, "");
	const buffer$1 = Buffer.from(cleanBase64, "base64");
	fs$1.writeFileSync(`${Common.tempDri.default}BilibiliLoginQrcode.png`, buffer$1);
	const qrcode_key = qrcodeurl.data.data.qrcode_key;
	const messageIds = [];
	const qrcodeMsg = await e.reply(qrimg, { reply: true });
	messageIds.push(qrcodeMsg.messageId);
	/**
	* 
	*/
	const recallMessages = async () => {
		await Promise.all(messageIds.map(async (id) => {
			try {
				await e.bot.recallMsg(e.contact, id);
			} catch {}
		}));
	};
	const handleLoginSuccess = async (responseData) => {
		const setCookieHeader = responseData.data.data.headers["set-cookie"];
		let cookieString;
		if (Array.isArray(setCookieHeader)) cookieString = setCookieHeader.join("; ");
		else cookieString = setCookieHeader || "";
		Config.Modify("cookies", "bilibili", cookieString);
		await e.reply("cookies.yaml", { reply: true });
		await recallMessages();
	};
	/**
	* 
	*/
	const handleQrScanned = async () => {
		const scannedMsg = await e.reply("", { reply: true });
		messageIds.push(scannedMsg.messageId);
		try {
			await e.bot.recallMsg(e.contact, qrcodeMsg.messageId);
		} catch {}
		const index$1 = messageIds.indexOf(qrcodeMsg.messageId);
		if (index$1 > -1) messageIds.splice(index$1, 1);
	};
	/**
	* 
	*/
	const handleQrExpired = async () => {
		await e.reply("", { reply: true });
		await recallMessages();
	};
	/**  */
	let hasScanned = false;
	while (true) try {
		const qrcodeStatusData = await getBilibiliData("", {
			qrcode_key,
			typeMode: "strict"
		});
		switch (qrcodeStatusData.data.data.data.code) {
			case 0:
				await handleLoginSuccess(qrcodeStatusData);
				return;
			case 86038:
				await handleQrExpired();
				return;
			case 86090:
				if (!hasScanned) {
					await handleQrScanned();
					hasScanned = true;
				}
				break;
			case 86101:
			default: break;
		}
		await common.sleep(3e3);
	} catch (error) {
		console.error(":", error);
		await e.reply("", { reply: true });
		await recallMessages();
		return;
	}
};

//#endregion
//#region src/platform/bilibili/push.ts
const bilibiliBaseHeaders = {
	...baseHeaders,
	Referer: "https://api.bilibili.com/",
	Cookie: Config.cookies.bilibili
};
var Bilibilipush = class extends Base {
	force = false;
	constructor(e = {}, force = false) {
		super(e);
		if (this.e.bot?.adapter?.name === "QQBot") {
			e.reply("QQBot");
			return;
		}
		this.force = force;
	}
	/**
	* 
	*/
	async action() {
		await this.syncConfigToDatabase();
		const deletedCount = await cleanOldDynamicCache("bilibili");
		if (deletedCount > 0) logger.info(` ${deletedCount} B`);
		const data$1 = await this.getDynamicList(Config.pushlist.bilibili);
		const pushdata = await this.excludeAlreadyPushed(data$1.willbepushlist);
		if (Object.keys(pushdata).length === 0) return true;
		if (this.force) return await this.forcepush(pushdata);
		else return await this.getdata(pushdata);
	}
	/**
	* 
	*/
	async syncConfigToDatabase() {
		if (!Config.pushlist.bilibili || Config.pushlist.bilibili.length === 0) return;
		await bilibiliDBInstance.syncConfigSubscriptions(Config.pushlist.bilibili);
	}
	/**
	* 
	* @param data 
	*/
	async getdata(data$1) {
		for (const dynamicId in data$1) {
			logger.mark(`
        ${logger.blue("B")}
        ${logger.cyan("UP")}: ${logger.green(data$1[dynamicId].remark)}
        ${logger.cyan("id")}${logger.yellow(dynamicId)}
        ${logger.cyan("")}${logger.green("https://t.bilibili.com/" + dynamicId)}`);
			let skip = await skipDynamic(data$1[dynamicId]);
			skip && logger.warn(` https://t.bilibili.com/${dynamicId} `);
			let send_video = true;
			let img$1 = [];
			const dynamicCARDINFO = await this.amagi.getBilibiliData("", {
				dynamic_id: dynamicId,
				typeMode: "strict"
			});
			const dycrad = dynamicCARDINFO.data.data.card && dynamicCARDINFO.data.data.card.card && JSON.parse(dynamicCARDINFO.data.data.card.card);
			if (!skip) {
				const userINFO = await this.amagi.getBilibiliData("", {
					host_mid: data$1[dynamicId].host_mid,
					typeMode: "strict"
				});
				let emojiDATA = await this.amagi.getBilibiliData("Emoji");
				emojiDATA = extractEmojisData(emojiDATA.data.data.packages);
				switch (data$1[dynamicId].dynamic_type) {
					case DynamicType.DRAW:
						if (data$1[dynamicId].Dynamic_Data.modules.module_dynamic.topic !== null && data$1[dynamicId].Dynamic_Data.modules.module_dynamic && data$1[dynamicId].Dynamic_Data.modules.module_dynamic.topic !== null) {
							const name = data$1[dynamicId].Dynamic_Data.modules.module_dynamic.topic.name;
							data$1[dynamicId].Dynamic_Data.modules.module_dynamic.major?.opus.summary.rich_text_nodes.unshift({
								orig_text: name,
								text: name,
								type: "topic",
								rid: data$1[dynamicId].Dynamic_Data.modules.module_dynamic.topic.id.toString()
							});
							data$1[dynamicId].Dynamic_Data.modules.module_dynamic.major.opus.summary.text = `${name}\n\n` + data$1[dynamicId].Dynamic_Data.modules.module_dynamic.major?.opus?.summary?.text;
						}
						img$1 = await Render("bilibili/dynamic/DYNAMIC_TYPE_DRAW", {
							image_url: dycrad.item.pictures && cover(dycrad.item.pictures),
							text: replacetext(br(data$1[dynamicId].Dynamic_Data.modules.module_dynamic.major?.opus?.summary?.text ?? ""), data$1[dynamicId].Dynamic_Data.modules.module_dynamic.major?.opus?.summary?.rich_text_nodes ?? []),
							dianzan: Count(data$1[dynamicId].Dynamic_Data.modules.module_stat.like.count),
							pinglun: Count(data$1[dynamicId].Dynamic_Data.modules.module_stat.comment.count),
							share: Count(data$1[dynamicId].Dynamic_Data.modules.module_stat.forward.count),
							create_time: Common.convertTimestampToDateTime(data$1[dynamicId].Dynamic_Data.modules.module_author.pub_ts),
							avatar_url: data$1[dynamicId].Dynamic_Data.modules.module_author.face,
							frame: data$1[dynamicId].Dynamic_Data.modules.module_author.pendant.image,
							share_url: "https://t.bilibili.com/" + data$1[dynamicId].Dynamic_Data.id_str,
							username: checkvip(userINFO.data.data.card),
							fans: Count(userINFO.data.data.follower),
							user_shortid: data$1[dynamicId].host_mid,
							total_favorited: Count(userINFO.data.data.like_num),
							following_count: Count(userINFO.data.data.card.attention),
							decoration_card: generateDecorationCard(data$1[dynamicId].Dynamic_Data.modules.module_author.decoration_card),
							render_time: Common.getCurrentTime(),
							imageLayout: Config.bilibili.imageLayout,
							dynamicTYPE: ""
						});
						break;
					case DynamicType.AV:
						if (data$1[dynamicId].Dynamic_Data.modules.module_dynamic.major?.type === "MAJOR_TYPE_ARCHIVE") {
							const bvid = data$1[dynamicId].Dynamic_Data?.modules.module_dynamic.major?.archive?.bvid ?? "";
							const INFODATA = await getBilibiliData("", "", {
								bvid,
								typeMode: "strict"
							});
							/**  */
							if (INFODATA.data.data.redirect_url) {
								send_video = false;
								logger.debug(`UP${INFODATA.data.data.owner.name} ${logger.yellow("")}${logger.green(INFODATA.data.data.redirect_url)}`);
							}
							img$1 = await Render("bilibili/dynamic/DYNAMIC_TYPE_AV", {
								image_url: INFODATA.data.data.pic,
								text: br(INFODATA.data.data.title),
								desc: br(dycrad.desc),
								dianzan: Count(INFODATA.data.data.stat.like),
								pinglun: Count(INFODATA.data.data.stat.reply),
								share: Count(INFODATA.data.data.stat.share),
								view: Count(dycrad.stat.view),
								coin: Count(dycrad.stat.coin),
								duration_text: data$1[dynamicId].Dynamic_Data.modules.module_dynamic.major?.archive?.duration_text ?? "0:00",
								create_time: Common.convertTimestampToDateTime(data$1[dynamicId].Dynamic_Data.modules.module_author.pub_ts),
								avatar_url: INFODATA.data.data.owner.face,
								frame: data$1[dynamicId].Dynamic_Data.modules.module_author.pendant.image,
								share_url: "https://www.bilibili.com/video/" + bvid,
								username: checkvip(userINFO.data.data.card),
								fans: Count(userINFO.data.data.follower),
								user_shortid: data$1[dynamicId].host_mid,
								total_favorited: Count(userINFO.data.data.like_num),
								following_count: Count(userINFO.data.data.card.attention),
								render_time: Common.getCurrentTime(),
								dynamicTYPE: "",
								dynamic_id: dynamicId
							});
						}
						break;
					case DynamicType.LIVE_RCMD:
						img$1 = await Render("bilibili/dynamic/DYNAMIC_TYPE_LIVE_RCMD", {
							image_url: dycrad.live_play_info.cover,
							text: br(dycrad.live_play_info.title),
							liveinf: br(`${dycrad.live_play_info.area_name} | : ${dycrad.live_play_info.room_id}`),
							username: checkvip(userINFO.data.data.card),
							avatar_url: userINFO.data.data.card.face,
							frame: data$1[dynamicId].Dynamic_Data.modules.module_author.pendant.image,
							fans: Count(userINFO.data.data.follower),
							create_time: Common.convertTimestampToDateTime(data$1[dynamicId].Dynamic_Data.modules.module_author.pub_ts),
							now_time: Common.getCurrentTime(),
							share_url: "https://live.bilibili.com/" + dycrad.live_play_info.room_id,
							dynamicTYPE: ""
						});
						break;
					case DynamicType.FORWARD: {
						const text$1 = replacetext(br(data$1[dynamicId].Dynamic_Data.modules.module_dynamic.desc.text), data$1[dynamicId].Dynamic_Data.modules.module_dynamic.desc.rich_text_nodes);
						let param = {};
						switch (data$1[dynamicId].Dynamic_Data.orig.type) {
							case DynamicType.AV:
								param = {
									username: checkvip(data$1[dynamicId].Dynamic_Data.orig.modules.module_author),
									pub_action: data$1[dynamicId].Dynamic_Data.orig.modules.module_author.pub_action,
									avatar_url: data$1[dynamicId].Dynamic_Data.orig.modules.module_author.face,
									duration_text: data$1[dynamicId].Dynamic_Data.orig.modules.module_dynamic.major.archive?.duration_text,
									title: data$1[dynamicId].Dynamic_Data.orig.modules.module_dynamic.major.archive?.title,
									danmaku: data$1[dynamicId].Dynamic_Data.orig.modules.module_dynamic.major.archive?.stat.danmaku,
									play: data$1[dynamicId].Dynamic_Data.orig.modules.module_dynamic.major.archive?.stat.play,
									cover: data$1[dynamicId].Dynamic_Data.orig.modules.module_dynamic.major.archive?.cover,
									create_time: Common.convertTimestampToDateTime(data$1[dynamicId].Dynamic_Data.orig.modules.module_author.pub_ts),
									decoration_card: generateDecorationCard(data$1[dynamicId].Dynamic_Data.orig.modules.module_author.decoration_card),
									frame: data$1[dynamicId].Dynamic_Data.orig.modules.module_author.pendant.image
								};
								break;
							case DynamicType.DRAW: {
								const dynamicCARD = await getBilibiliData("", Config.cookies.bilibili, {
									dynamic_id: data$1[dynamicId].Dynamic_Data.orig.id_str,
									typeMode: "strict"
								});
								const cardData = JSON.parse(dynamicCARD.data.data.card.card);
								param = {
									username: checkvip(data$1[dynamicId].Dynamic_Data.orig.modules.module_author),
									create_time: Common.convertTimestampToDateTime(data$1[dynamicId].Dynamic_Data.orig.modules.module_author.pub_ts),
									avatar_url: data$1[dynamicId].Dynamic_Data.orig.modules.module_author.face,
									text: replacetext(br(data$1[dynamicId].Dynamic_Data.orig.modules.module_dynamic.major.opus.summary.text), data$1[dynamicId].Dynamic_Data.orig.modules.module_dynamic.major.opus.summary.rich_text_nodes),
									image_url: cardData.item.pictures && cover(cardData.item.pictures),
									decoration_card: generateDecorationCard(data$1[dynamicId].Dynamic_Data.orig.modules.module_author.decoration_card),
									frame: data$1[dynamicId].Dynamic_Data.orig.modules.module_author.pendant.image
								};
								break;
							}
							case DynamicType.WORD:
								param = {
									username: checkvip(data$1[dynamicId].Dynamic_Data.orig.modules.module_author),
									create_time: Common.convertTimestampToDateTime(data$1[dynamicId].Dynamic_Data.orig.modules.module_author.pub_ts),
									avatar_url: data$1[dynamicId].Dynamic_Data.orig.modules.module_author.face,
									text: replacetext(br(data$1[dynamicId].Dynamic_Data.orig.modules.module_dynamic.major.opus.summary.text), data$1[dynamicId].Dynamic_Data.orig.modules.module_dynamic.major.opus.summary.rich_text_nodes),
									decoration_card: generateDecorationCard(data$1[dynamicId].Dynamic_Data.orig.modules.module_author.decoration_card),
									frame: data$1[dynamicId].Dynamic_Data.orig.modules.module_author.pendant.image
								};
								break;
							case DynamicType.LIVE_RCMD: {
								const liveData = JSON.parse(data$1[dynamicId].Dynamic_Data.orig.modules.module_dynamic.major.live_rcmd.content);
								param = {
									username: checkvip(data$1[dynamicId].Dynamic_Data.orig.modules.module_author),
									create_time: Common.convertTimestampToDateTime(data$1[dynamicId].Dynamic_Data.orig.modules.module_author.pub_ts),
									avatar_url: data$1[dynamicId].Dynamic_Data.orig.modules.module_author.face,
									decoration_card: generateDecorationCard(data$1[dynamicId].Dynamic_Data.orig.modules.module_author.decoration_card),
									frame: data$1[dynamicId].Dynamic_Data.orig.modules.module_author.pendant.image,
									cover: liveData.live_play_info.cover,
									text_large: liveData.live_play_info.watched_show.text_large,
									area_name: liveData.live_play_info.area_name,
									title: liveData.live_play_info.title,
									online: liveData.live_play_info.online
								};
								break;
							}
							case DynamicType.FORWARD:
							default:
								logger.warn(`UP${data$1[dynamicId].remark}${logger.green("")}${logger.yellow(data$1[dynamicId].Dynamic_Data.orig.type)}`);
								break;
						}
						img$1 = await Render("bilibili/dynamic/DYNAMIC_TYPE_FORWARD", {
							text: text$1,
							dianzan: Count(data$1[dynamicId].Dynamic_Data.modules.module_stat.like.count),
							pinglun: Count(data$1[dynamicId].Dynamic_Data.modules.module_stat.comment.count),
							share: Count(data$1[dynamicId].Dynamic_Data.modules.module_stat.forward.count),
							create_time: data$1[dynamicId].Dynamic_Data.modules.module_author.pub_time,
							avatar_url: data$1[dynamicId].Dynamic_Data.modules.module_author.face,
							frame: data$1[dynamicId].Dynamic_Data.modules.module_author.pendant.image,
							share_url: "https://t.bilibili.com/" + data$1[dynamicId].Dynamic_Data.id_str,
							username: checkvip(userINFO.data.data.card),
							fans: Count(userINFO.data.data.follower),
							user_shortid: data$1[dynamicId].Dynamic_Data.modules.module_author.mid,
							total_favorited: Count(userINFO.data.data.like_num),
							following_count: Count(userINFO.data.data.card.attention),
							dynamicTYPE: "",
							decoration_card: generateDecorationCard(data$1[dynamicId].Dynamic_Data.modules.module_author.decorate),
							render_time: Common.getCurrentTime(),
							original_content: { [data$1[dynamicId].Dynamic_Data.orig.type]: param }
						});
						break;
					}
					default:
						skip = true;
						logger.warn(`UP${data$1[dynamicId].remark}${data$1[dynamicId].dynamic_type}\n${"https://t.bilibili.com/" + data$1[dynamicId].Dynamic_Data.id_str}`);
						break;
				}
			}
			for (const target of data$1[dynamicId].targets) {
				let status = null;
				if (!skip) {
					const { groupId, botId } = target;
					const bot = karin.getBot(botId);
					const Contact = karin.contactGroup(groupId);
					status = await karin.sendMsg(botId, Contact, img$1 ? [...img$1] : []);
					if (Config.bilibili.push.parsedynamic && status.messageId) switch (data$1[dynamicId].dynamic_type) {
						case "DYNAMIC_TYPE_AV":
							if (send_video) {
								let correctList;
								let videoSize = "";
								const playUrlData = await this.amagi.getBilibiliData("", {
									avid: dycrad.aid,
									cid: dycrad.cid,
									typeMode: "strict"
								});
								/**  */
								const simplify = playUrlData.data.data.dash.video.filter((item, index$1, self$1) => {
									return self$1.findIndex((t) => {
										return t.id === item.id;
									}) === index$1;
								});
								/**  */
								playUrlData.data.data.dash.video = simplify;
								/**  */
								correctList = await bilibiliProcessVideos({
									accept_description: playUrlData.data.data.accept_description,
									bvid: dynamicCARDINFO.data.data.card.desc.bvid,
									qn: Config.bilibili.push.pushVideoQuality,
									maxAutoVideoSize: Config.bilibili.push.pushMaxAutoVideoSize
								}, simplify, playUrlData.data.data.dash.audio[0].base_url);
								playUrlData.data.data.dash.video = correctList.videoList;
								playUrlData.data.data.accept_description = correctList.accept_description;
								/**  */
								videoSize = await getvideosize(correctList.videoList[0].base_url, playUrlData.data.data.dash.audio[0].base_url, dynamicCARDINFO.data.data.card.desc.bvid);
								if (Config.upload.usefilelimit && Number(videoSize) > Number(Config.upload.filelimit) && !Config.upload.compress) {
									await karin.sendMsg(botId, Contact, [segment.text(` ${Config.upload.filelimit}MB\n ${Number(videoSize)}MB\nB~`), segment.reply(status.messageId)]);
									break;
								}
								logger.mark(` ${logger.yellow(Number(videoSize))} MB`);
								const infoData = await this.amagi.getBilibiliData("", {
									bvid: dynamicCARDINFO.data.data.card.desc.bvid,
									typeMode: "strict"
								});
								const mp4File = await downloadFile(playUrlData.data?.data?.dash?.video[0].base_url, {
									title: `Bil_V_${infoData.data.data.bvid}.mp4`,
									headers: bilibiliBaseHeaders
								});
								const mp3File = await downloadFile(playUrlData.data?.data?.dash?.audio[0].base_url, {
									title: `Bil_A_${infoData.data.data.bvid}.mp3`,
									headers: bilibiliBaseHeaders
								});
								if (mp4File.filepath && mp3File.filepath) await mergeFile(" + ", {
									path: mp4File.filepath,
									path2: mp3File.filepath,
									resultPath: Common.tempDri.video + `Bil_Result_${infoData.data.data.bvid}.mp4`,
									callback: async (success, resultPath) => {
										if (success) {
											const filePath = Common.tempDri.video + `tmp_${Date.now()}.mp4`;
											fs$1.renameSync(resultPath, filePath);
											logger.mark(`: ${resultPath.split("/").pop()} -> ${filePath.split("/").pop()}`);
											logger.mark("");
											await Common.removeFile(mp4File.filepath, true);
											await Common.removeFile(mp3File.filepath, true);
											const stats = fs$1.statSync(filePath);
											const fileSizeInMB = Number((stats.size / (1024 * 1024)).toFixed(2));
											if (fileSizeInMB > Config.upload.groupfilevalue) return await uploadFile(this.e, {
												filepath: filePath,
												totalBytes: fileSizeInMB,
												originTitle: `${infoData.data.data.desc.substring(0, 50).replace(/[\\/:\\*\\?"<>\\|\r\n\s]/g, " ")}`
											}, "", {
												useGroupFile: true,
												active: true,
												activeOption: {
													group_id: groupId,
													uin: botId
												}
											});
											else
 /**  */
											return await uploadFile(this.e, {
												filepath: filePath,
												totalBytes: fileSizeInMB
											}, "", {
												active: true,
												activeOption: {
													group_id: groupId,
													uin: botId
												}
											});
										} else {
											await Common.removeFile(mp4File.filepath, true);
											await Common.removeFile(mp3File.filepath, true);
											return true;
										}
									}
								});
							}
							break;
						case "DYNAMIC_TYPE_DRAW": {
							const imgArray = [];
							for (const img2 of data$1[dynamicId].Dynamic_Data.modules.module_dynamic.major && data$1[dynamicId].Dynamic_Data.modules.module_dynamic?.major?.draw?.items || data$1[dynamicId].Dynamic_Data.modules.module_dynamic?.major?.opus.pics) imgArray.push(segment.image(img2.src ?? img2.url));
							const forwardMsg = common.makeForward(imgArray, botId, bot.account.name);
							bot.sendForwardMsg(karin.contactFriend(botId), forwardMsg);
							break;
						}
					}
				}
				if (skip || status && status?.messageId) await bilibiliDBInstance.addDynamicCache(dynamicId, data$1[dynamicId].host_mid, target.groupId, data$1[dynamicId].dynamic_type);
			}
		}
	}
	/**
	* UP
	* @returns
	*/
	async getDynamicList(userList) {
		const willbepushlist = {};
		try {
			/**  */
			const filteredUserList = userList.filter((item) => item.switch !== false);
			for (const item of filteredUserList) {
				const dynamic_list = await this.amagi.getBilibiliData("", {
					host_mid: item.host_mid,
					typeMode: "strict"
				});
				if (dynamic_list.data.data.items.length > 0) for (const dynamic of dynamic_list.data.data.items) {
					const now$1 = Date.now();
					const createTime = dynamic.modules.module_author.pub_ts * 1e3;
					const timeDifference = now$1 - createTime;
					const is_top = dynamic.modules.module_tag?.text === "";
					let shouldPush = false;
					const timeDiffSeconds = Math.round(timeDifference / 1e3);
					const timeDiffHours = Math.round(timeDifference / 1e3 / 60 / 60 * 100) / 100;
					logger.debug(`
              
              UP${dynamic.modules.module_author.name}
              ID${dynamic.id_str}
              ${Common.convertTimestampToDateTime(createTime / 1e3)}
              ms${createTime}
              ms${now$1}
              ms${timeDifference} ms (${timeDiffSeconds}s) (${timeDiffHours}h)
              ${is_top}
              ${timeDifference < 864e5 ? logger.green("true") : logger.red("false")}
              `);
					if (is_top && timeDifference < 864e5 || timeDifference < 864e5) {
						shouldPush = true;
						logger.debug(logger.green(`shoulPush  truehttps://t.bilibili.com/${dynamic.id_str}\n`));
					} else logger.debug(logger.yellow(`shoulPush  falsehttps://t.bilibili.com/${dynamic.id_str}\n`));
					if (timeDifference < 864e5 || shouldPush) {
						const targets = item.group_id.map((groupWithBot) => {
							const [groupId, botId] = groupWithBot.split(":");
							return {
								groupId,
								botId
							};
						});
						if (!willbepushlist[dynamic.id_str]) willbepushlist[dynamic.id_str] = {
							remark: item.remark,
							host_mid: item.host_mid,
							create_time: dynamic.modules.module_author.pub_ts,
							targets,
							Dynamic_Data: dynamic,
							avatar_img: dynamic.modules.module_author.face,
							dynamic_type: dynamic.type
						};
					}
				}
				else logger.error(`${item.remark}`);
			}
		} catch (error) {
			throw new Error(`: ${error}`);
		}
		return { willbepushlist };
	}
	/**
	* 
	* @param willBePushList 
	* @returns 
	*/
	async excludeAlreadyPushed(willBePushList) {
		for (const dynamicId in willBePushList) {
			const pushItem = willBePushList[dynamicId];
			const newTargets = [];
			for (const target of pushItem.targets) if (!await bilibiliDBInstance.isDynamicPushed(dynamicId, pushItem.host_mid, target.groupId)) newTargets.push(target);
			if (newTargets.length > 0) pushItem.targets = newTargets;
			else delete willBePushList[dynamicId];
		}
		return willBePushList;
	}
	/**
	*  host_mid 
	* @param data  card 
	* @returns 
	*/
	async setting(data$1) {
		const groupInfo = await this.e.bot.getGroupInfo("groupId" in this.e && this.e.groupId ? this.e.groupId : "");
		const host_mid = Number(data$1.data.card.mid);
		const config$2 = Config.pushlist;
		const groupId = "groupId" in this.e && this.e.groupId ? this.e.groupId : "";
		const botId = this.e.selfId;
		if (!config$2.bilibili) config$2.bilibili = [];
		const existingItem = config$2.bilibili.find((item) => item.host_mid === host_mid);
		const isSubscribed = await bilibiliDBInstance.isSubscribed(host_mid, groupId);
		if (existingItem) {
			let has = false;
			let groupIndexToRemove = -1;
			for (let index$1 = 0; index$1 < existingItem.group_id.length; index$1++) if (existingItem.group_id[index$1].split(":")[0] === String(groupId)) {
				has = true;
				groupIndexToRemove = index$1;
				break;
			}
			if (has) {
				existingItem.group_id.splice(groupIndexToRemove, 1);
				if (isSubscribed) await bilibiliDBInstance.unsubscribeBilibiliUser(groupId, host_mid);
				logger.info(`\n${data$1.data.card.name}\nUID${host_mid}`);
				await this.e.reply(`${groupInfo.groupName}(${groupId})\n${data$1.data.card.name}\nUID${host_mid}`);
				if (existingItem.group_id.length === 0) {
					const index$1 = config$2.bilibili.indexOf(existingItem);
					config$2.bilibili.splice(index$1, 1);
				}
			} else {
				await bilibiliDBInstance.subscribeBilibiliUser(groupId, botId, host_mid, data$1.data.card.name);
				existingItem.group_id.push(`${groupId}:${botId}`);
				await this.e.reply(`${groupInfo.groupName}(${groupId})\n${data$1.data.card.name}\nUID${host_mid}`);
				if (Config.bilibili.push.switch === false) await this.e.reply("#kkkB");
				logger.info(`\n${data$1.data.card.name}\nUID${host_mid}`);
			}
		} else {
			await bilibiliDBInstance.subscribeBilibiliUser(groupId, botId, host_mid, data$1.data.card.name);
			config$2.bilibili.push({
				switch: true,
				host_mid,
				group_id: [`${groupId}:${botId}`],
				remark: data$1.data.card.name
			});
			await this.e.reply(`${groupInfo.groupName}(${groupId})\n${data$1.data.card.name}\nUID${host_mid}`);
			if (Config.bilibili.push.switch === false) await this.e.reply("#kkkB");
		}
		Config.Modify("pushlist", "bilibili", config$2.bilibili);
		await this.renderPushList();
	}
	/**
	* 
	* 
	*/
	async checkremark() {
		const config$2 = Config.pushlist;
		const abclist = [];
		if (Config.pushlist.bilibili === null || Config.pushlist.bilibili.length === 0) return true;
		for (const i of Config.pushlist.bilibili) {
			const remark = i.remark;
			const group_id = i.group_id;
			const host_mid = i.host_mid;
			if (remark === void 0 || remark === "") abclist.push({
				host_mid,
				group_id
			});
		}
		if (abclist.length > 0) {
			for (const i of abclist) {
				const remark = (await this.amagi.getBilibiliData("", {
					host_mid: i.host_mid,
					typeMode: "strict"
				})).data.data.card.name;
				const matchingItemIndex = config$2.bilibili.findIndex((item) => item.host_mid === i.host_mid);
				if (matchingItemIndex !== -1) config$2.bilibili[matchingItemIndex].remark = remark;
			}
			Config.Modify("pushlist", "bilibili", config$2.bilibili);
		}
	}
	/**
	* 
	* @param data 
	*/
	async forcepush(data$1) {
		const currentGroupId = "groupId" in this.e && this.e.groupId ? this.e.groupId : "";
		const currentBotId = this.e.selfId;
		if (!this.e.msg.includes("")) {
			const subscribedUids = (await bilibiliDBInstance.getGroupSubscriptions(currentGroupId)).map((sub) => sub.host_mid);
			/** UP */
			const filteredData = {};
			for (const dynamicId in data$1) if (subscribedUids.includes(data$1[dynamicId].host_mid)) filteredData[dynamicId] = {
				...data$1[dynamicId],
				targets: [{
					groupId: currentGroupId,
					botId: currentBotId
				}]
			};
			await this.getdata(filteredData);
		} else await this.getdata(data$1);
	}
	/**  */
	async renderPushList() {
		await this.syncConfigToDatabase();
		const groupInfo = await this.e.bot.getGroupInfo("groupId" in this.e && this.e.groupId ? this.e.groupId : "");
		const subscriptions = await bilibiliDBInstance.getGroupSubscriptions(groupInfo.groupId);
		if (subscriptions.length === 0) {
			await this.e.reply(`${groupInfo.groupName}(${groupInfo.groupId})\nBUP\n#B + UPUID`);
			return;
		}
		/**  */
		const renderOpt = [];
		for (const subscription of subscriptions) {
			const host_mid = subscription.host_mid;
			const userInfo = await this.amagi.getBilibiliData("", {
				host_mid,
				typeMode: "strict"
			});
			renderOpt.push({
				avatar_img: userInfo.data.data.card.face,
				username: userInfo.data.data.card.name,
				host_mid: userInfo.data.data.card.mid,
				fans: Count(userInfo.data.data.follower),
				total_favorited: Count(userInfo.data.data.like_num),
				following_count: Count(userInfo.data.data.card.attention)
			});
		}
		const img$1 = await Render("bilibili/userlist", { renderOpt });
		await this.e.reply(img$1);
	}
};
/**
* HTML<br>
* @param data 
* @returns \n<br>
*/
function br(data$1) {
	return data$1 = data$1.replace(/\n/g, "<br>");
}
/**
* VIPVIP
* @param member vipvipStatusnickname_color
* @returns HTMLVIPVIP
*/
function checkvip(member) {
	return member.vip.status === 1 ? `<span style="color: ${member.vip.nickname_color ?? "#FB7299"}; font-weight: 700;">${member.name}</span>` : `<span style="color: ${Common.useDarkTheme() ? "#EDEDED" : "#606060"}">${member.name}</span>`;
}
/**
* URL
* @param data 
* @returns text()url()
*/
function extractEmojisData(data$1) {
	const emojisData = [];
	data$1.forEach((packages) => {
		packages.emote.forEach((emote) => {
			emojisData.push({
				text: emote.text,
				url: emote.url
			});
		});
	});
	return emojisData;
}
/**
* 
* @param PushItem 
* @returns 
*/
const skipDynamic = async (PushItem) => {
	const tags = [];
	if (PushItem.Dynamic_Data.modules.module_dynamic?.desc?.rich_text_nodes) {
		for (const node of PushItem.Dynamic_Data.modules.module_dynamic.desc.rich_text_nodes) if (node.type === "topic") {
			if (node.orig_text) tags.push(node.orig_text);
		}
	}
	if (PushItem.Dynamic_Data.type === DynamicType.FORWARD && "orig" in PushItem.Dynamic_Data) {
		if (PushItem.Dynamic_Data.orig.modules.module_dynamic.major.type === MajorType.DRAW || PushItem.Dynamic_Data.orig.modules.module_dynamic.major.type === MajorType.OPUS || PushItem.Dynamic_Data.orig.modules.module_dynamic.major.type === MajorType.LIVE_RCMD) {
			for (const node of PushItem.Dynamic_Data.orig.modules.module_dynamic.major.opus.summary.rich_text_nodes) if (node.type === "topic") tags.push(node.orig_text);
		}
	}
	logger.debug(`https://t.bilibili.com/${PushItem.Dynamic_Data.id_str}`);
	return await bilibiliDBInstance.shouldFilter(PushItem, tags);
};

//#endregion
//#region src/module/db/bilibili.ts
/**  */
var BilibiliDBBase = class {
	db;
	dbPath;
	constructor() {
		this.dbPath = path.join(`${karinPathBase}/${Root.pluginName}/data`, "bilibili.db");
	}
	/**
	* 
	*/
	async init() {
		try {
			logger.debug(logger.green("--------------------------[BilibiliDB] --------------------------"));
			logger.debug("[BilibiliDB] ...");
			await fs$1.promises.mkdir(path.dirname(this.dbPath), { recursive: true });
			this.db = new sqlite3.Database(this.dbPath);
			await this.createTables();
			logger.debug("[BilibiliDB] ");
			logger.debug("[BilibiliDB] ...");
			logger.debug("[BilibiliDB] :", Config.pushlist.bilibili?.length || 0);
			await this.syncConfigSubscriptions(Config.pushlist.bilibili);
			logger.debug("[BilibiliDB] ");
			logger.debug(logger.green("--------------------------[BilibiliDB] --------------------------"));
		} catch (error) {
			logger.error("[BilibiliDB] :", error);
			throw error;
		}
		return this;
	}
	/**
	* 
	*/
	async createTables() {
		for (const query of [
			`CREATE TABLE IF NOT EXISTS Bots (
        id TEXT PRIMARY KEY,
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
        updatedAt TEXT DEFAULT CURRENT_TIMESTAMP
      )`,
			`CREATE TABLE IF NOT EXISTS Groups (
        id TEXT PRIMARY KEY,
        botId TEXT NOT NULL,
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
        updatedAt TEXT DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (botId) REFERENCES Bots(id)
      )`,
			`CREATE TABLE IF NOT EXISTS BilibiliUsers (
        host_mid INTEGER PRIMARY KEY,
        remark TEXT,
        filterMode TEXT DEFAULT 'blacklist',
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
        updatedAt TEXT DEFAULT CURRENT_TIMESTAMP
      )`,
			`CREATE TABLE IF NOT EXISTS GroupUserSubscriptions (
        groupId TEXT,
        host_mid INTEGER,
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
        updatedAt TEXT DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (groupId, host_mid),
        FOREIGN KEY (groupId) REFERENCES Groups(id),
        FOREIGN KEY (host_mid) REFERENCES BilibiliUsers(host_mid)
      )`,
			`CREATE TABLE IF NOT EXISTS DynamicCaches (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        dynamic_id TEXT NOT NULL,
        host_mid INTEGER NOT NULL,
        groupId TEXT NOT NULL,
        dynamic_type TEXT,
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
        updatedAt TEXT DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (host_mid) REFERENCES BilibiliUsers(host_mid),
        FOREIGN KEY (groupId) REFERENCES Groups(id),
        UNIQUE(dynamic_id, host_mid, groupId)
      )`,
			`CREATE TABLE IF NOT EXISTS FilterWords (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        host_mid INTEGER NOT NULL,
        word TEXT NOT NULL,
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
        updatedAt TEXT DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (host_mid) REFERENCES BilibiliUsers(host_mid),
        UNIQUE(host_mid, word)
      )`,
			`CREATE TABLE IF NOT EXISTS FilterTags (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        host_mid INTEGER NOT NULL,
        tag TEXT NOT NULL,
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
        updatedAt TEXT DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (host_mid) REFERENCES BilibiliUsers(host_mid),
        UNIQUE(host_mid, tag)
      )`
		]) await this.runQuery(query);
	}
	/**
	* SQL
	*/
	runQuery(sql, params = []) {
		return new Promise((resolve, reject) => {
			this.db.run(sql, params, function(err) {
				if (err) reject(err);
				else resolve({
					lastID: this.lastID,
					changes: this.changes
				});
			});
		});
	}
	/**
	* SQL
	*/
	getQuery(sql, params = []) {
		return new Promise((resolve, reject) => {
			this.db.get(sql, params, (err, row) => {
				if (err) reject(err);
				else resolve(row);
			});
		});
	}
	/**
	* SQL
	*/
	allQuery(sql, params = []) {
		return new Promise((resolve, reject) => {
			this.db.all(sql, params, (err, rows) => {
				if (err) reject(err);
				else resolve(rows);
			});
		});
	}
	/**
	* 
	* @param botId ID
	*/
	async getOrCreateBot(botId) {
		let bot = await this.getQuery("SELECT * FROM Bots WHERE id = ?", [botId]);
		if (!bot) {
			const now$1 = (/* @__PURE__ */ new Date()).toISOString();
			await this.runQuery("INSERT INTO Bots (id, createdAt, updatedAt) VALUES (?, ?, ?)", [
				botId,
				now$1,
				now$1
			]);
			bot = {
				id: botId,
				createdAt: now$1,
				updatedAt: now$1
			};
		}
		return bot;
	}
	/**
	* 
	* @param groupId ID
	* @param botId ID
	*/
	async getOrCreateGroup(groupId, botId) {
		await this.getOrCreateBot(botId);
		let group = await this.getQuery("SELECT * FROM Groups WHERE id = ? AND botId = ?", [groupId, botId]);
		if (!group) {
			const now$1 = (/* @__PURE__ */ new Date()).toISOString();
			await this.runQuery("INSERT INTO Groups (id, botId, createdAt, updatedAt) VALUES (?, ?, ?, ?)", [
				groupId,
				botId,
				now$1,
				now$1
			]);
			group = {
				id: groupId,
				botId,
				createdAt: now$1,
				updatedAt: now$1
			};
		}
		return group;
	}
	/**
	* B
	* @param host_mid BUID
	* @param remark UP
	*/
	async getOrCreateBilibiliUser(host_mid, remark = "") {
		let user = await this.getQuery("SELECT * FROM BilibiliUsers WHERE host_mid = ?", [host_mid]);
		if (!user) {
			const now$1 = (/* @__PURE__ */ new Date()).toISOString();
			await this.runQuery("INSERT INTO BilibiliUsers (host_mid, remark, filterMode, createdAt, updatedAt) VALUES (?, ?, ?, ?, ?)", [
				host_mid,
				remark,
				"blacklist",
				now$1,
				now$1
			]);
			user = {
				host_mid,
				remark,
				filterMode: "blacklist",
				createdAt: now$1,
				updatedAt: now$1
			};
		} else if (remark && user.remark !== remark) {
			const now$1 = (/* @__PURE__ */ new Date()).toISOString();
			await this.runQuery("UPDATE BilibiliUsers SET remark = ?, updatedAt = ? WHERE host_mid = ?", [
				remark,
				now$1,
				host_mid
			]);
			user.remark = remark;
			user.updatedAt = now$1;
		}
		return user;
	}
	/**
	* B
	* @param groupId ID
	* @param botId ID
	* @param host_mid BUID
	* @param remark UP
	*/
	async subscribeBilibiliUser(groupId, botId, host_mid, remark = "") {
		await this.getOrCreateGroup(groupId, botId);
		await this.getOrCreateBilibiliUser(host_mid, remark);
		let subscription = await this.getQuery("SELECT * FROM GroupUserSubscriptions WHERE groupId = ? AND host_mid = ?", [groupId, host_mid]);
		if (!subscription) {
			const now$1 = (/* @__PURE__ */ new Date()).toISOString();
			await this.runQuery("INSERT INTO GroupUserSubscriptions (groupId, host_mid, createdAt, updatedAt) VALUES (?, ?, ?, ?)", [
				groupId,
				host_mid,
				now$1,
				now$1
			]);
			subscription = {
				groupId,
				host_mid,
				createdAt: now$1,
				updatedAt: now$1
			};
		}
		return subscription;
	}
	/**
	* B
	* @param groupId ID
	* @param host_mid BUID
	*/
	async unsubscribeBilibiliUser(groupId, host_mid) {
		const result = await this.runQuery("DELETE FROM GroupUserSubscriptions WHERE groupId = ? AND host_mid = ?", [groupId, host_mid]);
		await this.runQuery("DELETE FROM DynamicCaches WHERE groupId = ? AND host_mid = ?", [groupId, host_mid]);
		return result.changes > 0;
	}
	/**
	* 
	* @param dynamic_id ID
	* @param host_mid BUID
	* @param groupId ID
	* @param dynamic_type 
	*/
	async addDynamicCache(dynamic_id, host_mid, groupId, dynamic_type) {
		let cache = await this.getQuery("SELECT * FROM DynamicCaches WHERE dynamic_id = ? AND host_mid = ? AND groupId = ?", [
			dynamic_id,
			host_mid,
			groupId
		]);
		if (!cache) {
			const now$1 = (/* @__PURE__ */ new Date()).toISOString();
			cache = {
				id: (await this.runQuery("INSERT INTO DynamicCaches (dynamic_id, host_mid, groupId, dynamic_type, createdAt, updatedAt) VALUES (?, ?, ?, ?, ?, ?)", [
					dynamic_id,
					host_mid,
					groupId,
					dynamic_type,
					now$1,
					now$1
				])).lastID,
				dynamic_id,
				host_mid,
				groupId,
				dynamic_type,
				createdAt: now$1,
				updatedAt: now$1
			};
		}
		return cache;
	}
	/**
	* 
	* @param dynamic_id ID
	* @param host_mid BUID
	* @param groupId ID
	*/
	async isDynamicPushed(dynamic_id, host_mid, groupId) {
		return ((await this.getQuery("SELECT COUNT(*) as count FROM DynamicCaches WHERE dynamic_id = ? AND host_mid = ? AND groupId = ?", [
			dynamic_id,
			host_mid,
			groupId
		]))?.count || 0) > 0;
	}
	/**
	* 
	* @param botId ID
	*/
	async getBotGroups(botId) {
		return await this.allQuery("SELECT * FROM Groups WHERE botId = ?", [botId]);
	}
	/**
	* ID
	* @param groupId ID
	* @param oldBotId ID
	* @param newBotId ID
	*/
	async updateGroupBotId(groupId, oldBotId, newBotId) {
		await this.getOrCreateBot(newBotId);
		const now$1 = (/* @__PURE__ */ new Date()).toISOString();
		await this.runQuery("UPDATE Groups SET botId = ?, updatedAt = ? WHERE id = ? AND botId = ?", [
			newBotId,
			now$1,
			groupId,
			oldBotId
		]);
	}
	/**
	* B
	* @param groupId ID
	*/
	async getGroupSubscriptions(groupId) {
		return (await this.allQuery(`SELECT 
        gus.groupId, gus.host_mid, gus.createdAt, gus.updatedAt,
        bu.remark, bu.filterMode,
        bu.createdAt as bu_createdAt, bu.updatedAt as bu_updatedAt
      FROM GroupUserSubscriptions gus
      LEFT JOIN BilibiliUsers bu ON gus.host_mid = bu.host_mid
      WHERE gus.groupId = ?`, [groupId])).map((sub) => ({
			groupId: sub.groupId,
			host_mid: sub.host_mid,
			createdAt: sub.createdAt,
			updatedAt: sub.updatedAt,
			bilibiliUser: {
				host_mid: sub.host_mid,
				remark: sub.remark,
				filterMode: sub.filterMode,
				createdAt: sub.bu_createdAt,
				updatedAt: sub.bu_updatedAt
			}
		}));
	}
	/**
	* B
	* @param host_mid BUID
	*/
	async getUserSubscribedGroups(host_mid) {
		return await this.allQuery(`SELECT g.* FROM Groups g
      INNER JOIN GroupUserSubscriptions gus ON g.id = gus.groupId
      WHERE gus.host_mid = ?`, [host_mid]);
	}
	/**
	* 
	* @param groupId ID
	* @param host_mid BUID
	*/
	async getGroupDynamicCache(groupId, host_mid) {
		let sql = "SELECT * FROM DynamicCaches WHERE groupId = ?";
		const params = [groupId];
		if (host_mid) {
			sql += " AND host_mid = ?";
			params.push(host_mid);
		}
		sql += " ORDER BY createdAt DESC";
		return await this.allQuery(sql, params);
	}
	/**
	* B
	* @param host_mid BUID
	* @param groupId ID
	*/
	async isSubscribed(host_mid, groupId) {
		return ((await this.getQuery("SELECT COUNT(*) as count FROM GroupUserSubscriptions WHERE host_mid = ? AND groupId = ?", [host_mid, groupId]))?.count || 0) > 0;
	}
	/**
	* 
	* @param configItems 
	*/
	async syncConfigSubscriptions(configItems) {
		const configSubscriptions = /* @__PURE__ */ new Map();
		for (const item of configItems) {
			const host_mid = item.host_mid;
			const remark = item.remark ?? "";
			await this.getOrCreateBilibiliUser(host_mid, remark);
			for (const groupWithBot of item.group_id) {
				const [groupId, botId] = groupWithBot.split(":");
				if (!groupId || !botId) continue;
				await this.getOrCreateGroup(groupId, botId);
				if (!configSubscriptions.has(groupId)) configSubscriptions.set(groupId, /* @__PURE__ */ new Set());
				configSubscriptions.get(groupId)?.add(host_mid);
				if (!await this.isSubscribed(host_mid, groupId)) await this.subscribeBilibiliUser(groupId, botId, host_mid, remark);
			}
		}
		const allGroups = await this.allQuery("SELECT * FROM Groups");
		for (const group of allGroups) {
			const groupId = group.id;
			const configUps = configSubscriptions.get(groupId) ?? /* @__PURE__ */ new Set();
			const dbSubscriptions = await this.getGroupSubscriptions(groupId);
			for (const subscription of dbSubscriptions) {
				const host_mid = subscription.host_mid;
				if (!configUps.has(host_mid)) {
					await this.unsubscribeBilibiliUser(groupId, host_mid);
					logger.mark(` ${groupId} UP ${host_mid} `);
				}
			}
		}
		const allUsers = await this.allQuery("SELECT * FROM BilibiliUsers");
		for (const user of allUsers) {
			const host_mid = user.host_mid;
			if ((await this.getUserSubscribedGroups(host_mid)).length === 0) {
				await this.runQuery("DELETE FROM FilterWords WHERE host_mid = ?", [host_mid]);
				await this.runQuery("DELETE FROM FilterTags WHERE host_mid = ?", [host_mid]);
				await this.runQuery("DELETE FROM BilibiliUsers WHERE host_mid = ?", [host_mid]);
				logger.mark(`UP ${host_mid} `);
			}
		}
	}
	/**
	* 
	* @param host_mid BUID
	* @param filterMode 
	*/
	async updateFilterMode(host_mid, filterMode) {
		const user = await this.getOrCreateBilibiliUser(host_mid);
		const now$1 = (/* @__PURE__ */ new Date()).toISOString();
		await this.runQuery("UPDATE BilibiliUsers SET filterMode = ?, updatedAt = ? WHERE host_mid = ?", [
			filterMode,
			now$1,
			host_mid
		]);
		return {
			...user,
			filterMode,
			updatedAt: now$1
		};
	}
	/**
	* 
	* @param host_mid BUID
	* @param word 
	*/
	async addFilterWord(host_mid, word) {
		await this.getOrCreateBilibiliUser(host_mid);
		let filterWord = await this.getQuery("SELECT * FROM FilterWords WHERE host_mid = ? AND word = ?", [host_mid, word]);
		if (!filterWord) {
			const now$1 = (/* @__PURE__ */ new Date()).toISOString();
			filterWord = {
				id: (await this.runQuery("INSERT INTO FilterWords (host_mid, word, createdAt, updatedAt) VALUES (?, ?, ?, ?)", [
					host_mid,
					word,
					now$1,
					now$1
				])).lastID,
				host_mid,
				word,
				createdAt: now$1,
				updatedAt: now$1
			};
		}
		return filterWord;
	}
	/**
	* 
	* @param host_mid BUID
	* @param word 
	*/
	async removeFilterWord(host_mid, word) {
		return (await this.runQuery("DELETE FROM FilterWords WHERE host_mid = ? AND word = ?", [host_mid, word])).changes > 0;
	}
	/**
	* 
	* @param host_mid BUID
	* @param tag 
	*/
	async addFilterTag(host_mid, tag) {
		await this.getOrCreateBilibiliUser(host_mid);
		let filterTag = await this.getQuery("SELECT * FROM FilterTags WHERE host_mid = ? AND tag = ?", [host_mid, tag]);
		if (!filterTag) {
			const now$1 = (/* @__PURE__ */ new Date()).toISOString();
			filterTag = {
				id: (await this.runQuery("INSERT INTO FilterTags (host_mid, tag, createdAt, updatedAt) VALUES (?, ?, ?, ?)", [
					host_mid,
					tag,
					now$1,
					now$1
				])).lastID,
				host_mid,
				tag,
				createdAt: now$1,
				updatedAt: now$1
			};
		}
		return filterTag;
	}
	/**
	* 
	* @param host_mid BUID
	* @param tag 
	*/
	async removeFilterTag(host_mid, tag) {
		return (await this.runQuery("DELETE FROM FilterTags WHERE host_mid = ? AND tag = ?", [host_mid, tag])).changes > 0;
	}
	/**
	* 
	* @param host_mid BUID
	*/
	async getFilterWords(host_mid) {
		return (await this.allQuery("SELECT * FROM FilterWords WHERE host_mid = ?", [host_mid])).map((word) => word.word);
	}
	/**
	* 
	* @param host_mid BUID
	*/
	async getFilterTags(host_mid) {
		return (await this.allQuery("SELECT * FROM FilterTags WHERE host_mid = ?", [host_mid])).map((tag) => tag.tag);
	}
	/**
	* 
	* @param host_mid BUID
	*/
	async getFilterConfig(host_mid) {
		const user = await this.getOrCreateBilibiliUser(host_mid);
		const filterWords = await this.getFilterWords(host_mid);
		const filterTags = await this.getFilterTags(host_mid);
		return {
			filterMode: user.filterMode,
			filterWords,
			filterTags
		};
	}
	/**
	* 
	* @param dynamicData 
	* @returns 
	*/
	async extractTextAndTags(dynamicData) {
		let text$1 = "";
		const tags = [];
		if (!dynamicData || !dynamicData.modules || !dynamicData.modules.module_dynamic) return {
			text: text$1,
			tags
		};
		const moduleDynamic = dynamicData.modules.module_dynamic;
		if (moduleDynamic.major && moduleDynamic.major.live_rcmd) {
			const content = JSON.parse(moduleDynamic.major.live_rcmd.content);
			text$1 += content.live_play_info.title + " ";
			tags.push(content.live_play_info.area_name);
		}
		if (moduleDynamic.desc && moduleDynamic.desc.text) text$1 += moduleDynamic.desc.text + " ";
		if (moduleDynamic.major && moduleDynamic.major.archive && moduleDynamic.major.archive.title) text$1 += moduleDynamic.major.archive.title + " ";
		if (moduleDynamic.desc && moduleDynamic.desc.rich_text_nodes) {
			for (const node of moduleDynamic.desc.rich_text_nodes) if (node.type !== "RICH_TEXT_NODE_TYPE_TEXT") tags.push(node.orig_text);
		}
		if (dynamicData.type === DynamicType.FORWARD && "orig" in dynamicData) if (dynamicData.orig.type === DynamicType.AV) text$1 += dynamicData.orig.modules.module_dynamic.major.archive.title + "";
		else {
			logger.debug(`taghttps://t.bilibili.com/${dynamicData.id_str}`);
			try {
				text$1 += dynamicData.orig.modules.module_dynamic.major.opus.summary.text + " ";
				for (const node of dynamicData.orig.modules.module_dynamic.major.opus.summary.rich_text_nodes) tags.push(node.orig_text);
			} catch (error) {
				logger.error(`tag${error}`);
			}
		}
		return {
			text: text$1.trim(),
			tags
		};
	}
	/**
	* 
	* @param PushItem 
	* @param tags 
	*/
	async shouldFilter(PushItem, extraTags = []) {
		const { filterMode, filterWords, filterTags } = await this.getFilterConfig(PushItem.host_mid);
		logger.debug(`
      ${PushItem.remark}${PushItem.host_mid}
      ${filterMode}
      ${filterWords}
      ${filterTags}
      `);
		const { text: mainText, tags: mainTags } = await this.extractTextAndTags(PushItem.Dynamic_Data);
		logger.debug(`
      
      ${mainText}
      [${mainTags.join("][")}]
      `);
		let allTags = [...mainTags, ...extraTags];
		let allText = mainText;
		if (PushItem.Dynamic_Data.type === DynamicType.FORWARD && "orig" in PushItem.Dynamic_Data) {
			const { text: origText, tags: origTags } = await this.extractTextAndTags(PushItem.Dynamic_Data.orig);
			allText += " " + origText;
			allTags = [...allTags, ...origTags];
		}
		const hasFilterWord = filterWords.some((word) => allText.includes(word));
		const hasFilterTag = filterTags.some((filterTag) => allTags.some((tag) => tag.includes(filterTag)));
		logger.debug(`
    UPUID${PushItem.host_mid}
    ${allText}
    ${allTags.join(", ")}
    [${filterWords.join("], [")}]
    [${filterTags.join("], [")}]
    ${filterMode}
    ${hasFilterWord || hasFilterTag ? logger.red(`${hasFilterWord || hasFilterTag}`) : logger.green(`${hasFilterWord || hasFilterTag}`)}
    ${logger.green(`https://t.bilibili.com/${PushItem.Dynamic_Data.id_str}`)}
    ${PushItem.dynamic_type}
    `);
		if (filterMode === "blacklist") {
			if (hasFilterWord || hasFilterTag) {
				logger.warn(`
        
        ${logger.yellow(`https://t.bilibili.com/${PushItem.Dynamic_Data.id_str}`)}
        [${filterWords.join("], [")}]
        [${filterTags.join("], [")}]
        `);
				return true;
			}
			return false;
		} else {
			if (filterWords.length === 0 && filterTags.length === 0) return false;
			if (hasFilterWord || hasFilterTag) return false;
			logger.warn(`
        
        ${logger.yellow(`https://t.bilibili.com/${PushItem.Dynamic_Data.id_str}`)}
        [${filterWords.join("], [")}]
        [${filterTags.join("], [")}]
      `);
			return true;
		}
	}
	/**
	* 
	* @param days 
	* @returns 
	*/
	async cleanOldDynamicCache(days = 7) {
		const cutoffDate = /* @__PURE__ */ new Date();
		cutoffDate.setDate(cutoffDate.getDate() - days);
		const cutoffDateStr = cutoffDate.toISOString();
		return (await this.runQuery("DELETE FROM DynamicCaches WHERE createdAt < ?", [cutoffDateStr])).changes ?? 0;
	}
	/** groupRepositorydynamicCacheRepository */
	get groupRepository() {
		return { find: async (options) => {
			if (options?.where?.botId) return await this.getBotGroups(options.where.botId);
			return await this.allQuery("SELECT * FROM Groups");
		} };
	}
	get dynamicCacheRepository() {
		return {
			find: async (options = {}) => {
				const { where = {}, order, take, relations } = options;
				let sql = "SELECT * FROM DynamicCaches";
				const params = [];
				const conditions = [];
				if (where.groupId) {
					conditions.push("groupId = ?");
					params.push(where.groupId);
				}
				if (where.host_mid) {
					conditions.push("host_mid = ?");
					params.push(where.host_mid);
				}
				if (where.dynamic_id) {
					conditions.push("dynamic_id = ?");
					params.push(where.dynamic_id);
				}
				if (conditions.length > 0) sql += " WHERE " + conditions.join(" AND ");
				if (order) {
					const orderClauses = [];
					const allowedFields = [
						"id",
						"dynamic_id",
						"host_mid",
						"groupId",
						"dynamic_type",
						"createdAt",
						"updatedAt"
					];
					const allowedDirections = ["ASC", "DESC"];
					for (const [field, direction] of Object.entries(order)) if (allowedFields.includes(field) && allowedDirections.includes(direction)) orderClauses.push(`${field} ${direction}`);
					if (orderClauses.length > 0) sql += " ORDER BY " + orderClauses.join(", ");
				}
				if (take) {
					sql += " LIMIT ?";
					params.push(take.toString());
				}
				const caches = await this.allQuery(sql, params);
				if (relations && relations.includes("bilibiliUser")) {
					const result = [];
					for (const cache of caches) {
						const bilibiliUser = await this.getQuery("SELECT * FROM BilibiliUsers WHERE host_mid = ?", [cache.host_mid]);
						result.push({
							...cache,
							bilibiliUser,
							createdAt: new Date(cache.createdAt),
							updatedAt: new Date(cache.updatedAt)
						});
					}
					return result;
				}
				return caches.map((cache) => ({
					...cache,
					createdAt: new Date(cache.createdAt),
					updatedAt: new Date(cache.updatedAt)
				}));
			},
			delete: async (conditions) => {
				const { groupId, host_mid, dynamic_id } = conditions;
				if (groupId && host_mid) return { affected: (await this.runQuery("DELETE FROM DynamicCaches WHERE groupId = ? AND host_mid = ?", [groupId, host_mid])).changes };
				if (groupId) return { affected: (await this.runQuery("DELETE FROM DynamicCaches WHERE groupId = ?", [groupId])).changes };
				if (host_mid) return { affected: (await this.runQuery("DELETE FROM DynamicCaches WHERE host_mid = ?", [host_mid])).changes };
				if (dynamic_id) return { affected: (await this.runQuery("DELETE FROM DynamicCaches WHERE dynamic_id = ?", [dynamic_id])).changes };
				return { affected: 0 };
			}
		};
	}
};

//#endregion
//#region src/module/db/douyin.ts
/**  */
var DouyinDBBase = class {
	db;
	dbPath;
	constructor() {
		this.dbPath = path.join(`${karinPathBase}/${Root.pluginName}/data`, "douyin.db");
	}
	/**
	* 
	*/
	async init() {
		try {
			logger.debug(logger.green("--------------------------[DouyinDB] --------------------------"));
			logger.debug("[DouyinDB] ...");
			await fs$1.promises.mkdir(path.dirname(this.dbPath), { recursive: true });
			this.db = new sqlite3.Database(this.dbPath);
			await this.createTables();
			logger.debug("[DouyinDB] ");
			logger.debug("[DouyinDB] ...");
			logger.debug("[DouyinDB] :", Config.pushlist.douyin?.length || 0);
			await this.syncConfigSubscriptions(Config.pushlist.douyin);
			logger.debug("[DouyinDB] ");
			logger.debug(logger.green("--------------------------[DouyinDB] --------------------------"));
		} catch (error) {
			logger.error("[DouyinDB] :", error);
			throw error;
		}
		return this;
	}
	/**
	* 
	*/
	async createTables() {
		for (const query of [
			`CREATE TABLE IF NOT EXISTS Bots (
        id TEXT PRIMARY KEY,
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
        updatedAt TEXT DEFAULT CURRENT_TIMESTAMP
      )`,
			`CREATE TABLE IF NOT EXISTS Groups (
        id TEXT PRIMARY KEY,
        botId TEXT NOT NULL,
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
        updatedAt TEXT DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (botId) REFERENCES Bots(id)
      )`,
			`CREATE TABLE IF NOT EXISTS DouyinUsers (
        sec_uid TEXT PRIMARY KEY,
        short_id TEXT,
        remark TEXT,
        living INTEGER DEFAULT 0,
        filterMode TEXT DEFAULT 'blacklist',
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
        updatedAt TEXT DEFAULT CURRENT_TIMESTAMP
      )`,
			`CREATE TABLE IF NOT EXISTS GroupUserSubscriptions (
        groupId TEXT,
        sec_uid TEXT,
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
        updatedAt TEXT DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (groupId, sec_uid),
        FOREIGN KEY (groupId) REFERENCES Groups(id),
        FOREIGN KEY (sec_uid) REFERENCES DouyinUsers(sec_uid)
      )`,
			`CREATE TABLE IF NOT EXISTS AwemeCaches (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        aweme_id TEXT NOT NULL,
        sec_uid TEXT NOT NULL,
        groupId TEXT NOT NULL,
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
        updatedAt TEXT DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (sec_uid) REFERENCES DouyinUsers(sec_uid),
        FOREIGN KEY (groupId) REFERENCES Groups(id),
        UNIQUE(aweme_id, sec_uid, groupId)
      )`,
			`CREATE TABLE IF NOT EXISTS FilterWords (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        sec_uid TEXT NOT NULL,
        word TEXT NOT NULL,
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
        updatedAt TEXT DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (sec_uid) REFERENCES DouyinUsers(sec_uid),
        UNIQUE(sec_uid, word)
      )`,
			`CREATE TABLE IF NOT EXISTS FilterTags (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        sec_uid TEXT NOT NULL,
        tag TEXT NOT NULL,
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
        updatedAt TEXT DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (sec_uid) REFERENCES DouyinUsers(sec_uid),
        UNIQUE(sec_uid, tag)
      )`
		]) await this.runQuery(query);
	}
	/**
	* SQL
	*/
	runQuery(sql, params = []) {
		return new Promise((resolve, reject) => {
			this.db.run(sql, params, function(err) {
				if (err) reject(err);
				else resolve({
					lastID: this.lastID,
					changes: this.changes
				});
			});
		});
	}
	/**
	* SQL
	*/
	getQuery(sql, params = []) {
		return new Promise((resolve, reject) => {
			this.db.get(sql, params, (err, row) => {
				if (err) reject(err);
				else resolve(row);
			});
		});
	}
	/**
	* SQL
	*/
	allQuery(sql, params = []) {
		return new Promise((resolve, reject) => {
			this.db.all(sql, params, (err, rows) => {
				if (err) reject(err);
				else resolve(rows);
			});
		});
	}
	/**
	* 
	* @param botId ID
	*/
	async getOrCreateBot(botId) {
		let bot = await this.getQuery("SELECT * FROM Bots WHERE id = ?", [botId]);
		if (!bot) {
			const now$1 = (/* @__PURE__ */ new Date()).toISOString();
			await this.runQuery("INSERT INTO Bots (id, createdAt, updatedAt) VALUES (?, ?, ?)", [
				botId,
				now$1,
				now$1
			]);
			bot = {
				id: botId,
				createdAt: now$1,
				updatedAt: now$1
			};
		}
		return bot;
	}
	/**
	* 
	* @param groupId ID
	* @param botId ID
	*/
	async getOrCreateGroup(groupId, botId) {
		await this.getOrCreateBot(botId);
		let group = await this.getQuery("SELECT * FROM Groups WHERE id = ? AND botId = ?", [groupId, botId]);
		if (!group) {
			const now$1 = (/* @__PURE__ */ new Date()).toISOString();
			await this.runQuery("INSERT INTO Groups (id, botId, createdAt, updatedAt) VALUES (?, ?, ?, ?)", [
				groupId,
				botId,
				now$1,
				now$1
			]);
			group = {
				id: groupId,
				botId,
				createdAt: now$1,
				updatedAt: now$1
			};
		}
		return group;
	}
	/**
	* 
	* @param sec_uid sec_uid
	* @param short_id 
	* @param remark 
	*/
	async getOrCreateDouyinUser(sec_uid, short_id = "", remark = "") {
		let user = await this.getQuery("SELECT * FROM DouyinUsers WHERE sec_uid = ?", [sec_uid]);
		if (!user) {
			const now$1 = (/* @__PURE__ */ new Date()).toISOString();
			await this.runQuery("INSERT INTO DouyinUsers (sec_uid, short_id, remark, living, filterMode, createdAt, updatedAt) VALUES (?, ?, ?, ?, ?, ?, ?)", [
				sec_uid,
				short_id,
				remark,
				0,
				"blacklist",
				now$1,
				now$1
			]);
			user = {
				sec_uid,
				short_id,
				remark,
				living: false,
				filterMode: "blacklist",
				createdAt: now$1,
				updatedAt: now$1
			};
		} else {
			let needUpdate = false;
			const updates = [];
			const params = [];
			if (remark && user.remark !== remark) {
				updates.push("remark = ?");
				params.push(remark);
				user.remark = remark;
				needUpdate = true;
			}
			if (short_id && user.short_id !== short_id) {
				updates.push("short_id = ?");
				params.push(short_id);
				user.short_id = short_id;
				needUpdate = true;
			}
			if (needUpdate) {
				const now$1 = (/* @__PURE__ */ new Date()).toISOString();
				updates.push("updatedAt = ?");
				params.push(now$1);
				params.push(sec_uid);
				await this.runQuery(`UPDATE DouyinUsers SET ${updates.join(", ")} WHERE sec_uid = ?`, params);
				user.updatedAt = now$1;
			}
		}
		return user;
	}
	/**
	* 
	* @param groupId ID
	* @param botId ID
	* @param sec_uid sec_uid
	* @param short_id 
	* @param remark 
	*/
	async subscribeDouyinUser(groupId, botId, sec_uid, short_id = "", remark = "") {
		await this.getOrCreateGroup(groupId, botId);
		await this.getOrCreateDouyinUser(sec_uid, short_id, remark);
		let subscription = await this.getQuery("SELECT * FROM GroupUserSubscriptions WHERE groupId = ? AND sec_uid = ?", [groupId, sec_uid]);
		if (!subscription) {
			const now$1 = (/* @__PURE__ */ new Date()).toISOString();
			await this.runQuery("INSERT INTO GroupUserSubscriptions (groupId, sec_uid, createdAt, updatedAt) VALUES (?, ?, ?, ?)", [
				groupId,
				sec_uid,
				now$1,
				now$1
			]);
			subscription = {
				groupId,
				sec_uid,
				createdAt: now$1,
				updatedAt: now$1
			};
		}
		return subscription;
	}
	/**
	* 
	* @param groupId ID
	* @param sec_uid sec_uid
	*/
	async unsubscribeDouyinUser(groupId, sec_uid) {
		const result = await this.runQuery("DELETE FROM GroupUserSubscriptions WHERE groupId = ? AND sec_uid = ?", [groupId, sec_uid]);
		await this.runQuery("DELETE FROM AwemeCaches WHERE groupId = ? AND sec_uid = ?", [groupId, sec_uid]);
		return result.changes > 0;
	}
	/**
	* 
	* @param aweme_id ID
	* @param sec_uid sec_uid
	* @param groupId ID
	*/
	async addAwemeCache(aweme_id, sec_uid, groupId) {
		let cache = await this.getQuery("SELECT * FROM AwemeCaches WHERE aweme_id = ? AND sec_uid = ? AND groupId = ?", [
			aweme_id,
			sec_uid,
			groupId
		]);
		if (!cache) {
			const now$1 = (/* @__PURE__ */ new Date()).toISOString();
			cache = {
				id: (await this.runQuery("INSERT INTO AwemeCaches (aweme_id, sec_uid, groupId, createdAt, updatedAt) VALUES (?, ?, ?, ?, ?)", [
					aweme_id,
					sec_uid,
					groupId,
					now$1,
					now$1
				])).lastID,
				aweme_id,
				sec_uid,
				groupId,
				createdAt: now$1,
				updatedAt: now$1
			};
		}
		return cache;
	}
	/**
	* 
	* @param aweme_id ID
	* @param sec_uid sec_uid
	* @param groupId ID
	*/
	async isAwemePushed(aweme_id, sec_uid, groupId) {
		return ((await this.getQuery("SELECT COUNT(*) as count FROM AwemeCaches WHERE aweme_id = ? AND sec_uid = ? AND groupId = ?", [
			aweme_id,
			sec_uid,
			groupId
		]))?.count || 0) > 0;
	}
	/**
	* 
	* @param botId ID
	*/
	async getBotGroups(botId) {
		return await this.allQuery("SELECT * FROM Groups WHERE botId = ?", [botId]);
	}
	/**
	* ID
	* @param groupId ID
	* @param oldBotId ID
	* @param newBotId ID
	*/
	async updateGroupBotId(groupId, oldBotId, newBotId) {
		await this.getOrCreateBot(newBotId);
		const now$1 = (/* @__PURE__ */ new Date()).toISOString();
		await this.runQuery("UPDATE Groups SET botId = ?, updatedAt = ? WHERE id = ? AND botId = ?", [
			newBotId,
			now$1,
			groupId,
			oldBotId
		]);
	}
	/**
	* 
	* @param groupId ID
	*/
	async getGroupSubscriptions(groupId) {
		return (await this.allQuery(`SELECT 
        gus.groupId, gus.sec_uid, gus.createdAt, gus.updatedAt,
        du.short_id, du.remark, du.living, du.filterMode,
        du.createdAt as du_createdAt, du.updatedAt as du_updatedAt
      FROM GroupUserSubscriptions gus
      LEFT JOIN DouyinUsers du ON gus.sec_uid = du.sec_uid
      WHERE gus.groupId = ?`, [groupId])).map((sub) => ({
			groupId: sub.groupId,
			sec_uid: sub.sec_uid,
			createdAt: sub.createdAt,
			updatedAt: sub.updatedAt,
			douyinUser: {
				sec_uid: sub.sec_uid,
				short_id: sub.short_id,
				remark: sub.remark,
				living: !!sub.living,
				filterMode: sub.filterMode,
				createdAt: sub.du_createdAt,
				updatedAt: sub.du_updatedAt
			}
		}));
	}
	/**
	* 
	* @param sec_uid sec_uid
	*/
	async getUserSubscribedGroups(sec_uid) {
		return await this.allQuery(`SELECT g.* FROM Groups g
      INNER JOIN GroupUserSubscriptions gus ON g.id = gus.groupId
      WHERE gus.sec_uid = ?`, [sec_uid]);
	}
	/**
	* 
	* @param sec_uid sec_uid
	* @param groupId ID
	*/
	async isSubscribed(sec_uid, groupId) {
		return ((await this.getQuery("SELECT COUNT(*) as count FROM GroupUserSubscriptions WHERE sec_uid = ? AND groupId = ?", [sec_uid, groupId]))?.count || 0) > 0;
	}
	/**
	* 
	* @param sec_uid sec_uid
	* @returns null
	*/
	async getDouyinUser(sec_uid) {
		const user = await this.getQuery("SELECT * FROM DouyinUsers WHERE sec_uid = ?", [sec_uid]);
		if (user) user.living = !!user.living;
		return user || null;
	}
	/**
	* 
	* @param sec_uid sec_uid
	* @param living 
	*/
	async updateLiveStatus(sec_uid, living) {
		if (!await this.getDouyinUser(sec_uid)) return false;
		const now$1 = (/* @__PURE__ */ new Date()).toISOString();
		return (await this.runQuery("UPDATE DouyinUsers SET living = ?, updatedAt = ? WHERE sec_uid = ?", [
			living ? 1 : 0,
			now$1,
			sec_uid
		])).changes > 0;
	}
	/**
	* 
	* @param sec_uid sec_uid
	*/
	async getLiveStatus(sec_uid) {
		return { living: (await this.getDouyinUser(sec_uid))?.living || false };
	}
	/**
	* 
	* @param configItems 
	*/
	async syncConfigSubscriptions(configItems) {
		const configSubscriptions = /* @__PURE__ */ new Map();
		for (const item of configItems) {
			const sec_uid = item.sec_uid;
			const short_id = item.short_id ?? "";
			const remark = item.remark ?? "";
			await this.getOrCreateDouyinUser(sec_uid, short_id, remark);
			for (const groupWithBot of item.group_id) {
				const [groupId, botId] = groupWithBot.split(":");
				if (!groupId || !botId) continue;
				await this.getOrCreateGroup(groupId, botId);
				if (!configSubscriptions.has(groupId)) configSubscriptions.set(groupId, /* @__PURE__ */ new Set());
				configSubscriptions.get(groupId)?.add(sec_uid);
				if (!await this.isSubscribed(sec_uid, groupId)) await this.subscribeDouyinUser(groupId, botId, sec_uid, short_id, remark);
			}
		}
		const allGroups = await this.allQuery("SELECT * FROM Groups");
		for (const group of allGroups) {
			const groupId = group.id;
			const configUsers = configSubscriptions.get(groupId) ?? /* @__PURE__ */ new Set();
			const dbSubscriptions = await this.getGroupSubscriptions(groupId);
			for (const subscription of dbSubscriptions) {
				const sec_uid = subscription.sec_uid;
				if (!configUsers.has(sec_uid)) {
					await this.unsubscribeDouyinUser(groupId, sec_uid);
					logger.mark(` ${groupId}  ${sec_uid} `);
				}
			}
		}
		const allUsers = await this.allQuery("SELECT * FROM DouyinUsers");
		for (const user of allUsers) {
			const sec_uid = user.sec_uid;
			if ((await this.getUserSubscribedGroups(sec_uid)).length === 0) {
				await this.runQuery("DELETE FROM FilterWords WHERE sec_uid = ?", [sec_uid]);
				await this.runQuery("DELETE FROM FilterTags WHERE sec_uid = ?", [sec_uid]);
				await this.runQuery("DELETE FROM DouyinUsers WHERE sec_uid = ?", [sec_uid]);
				logger.mark(` ${sec_uid} `);
			}
		}
	}
	/**
	* ID
	* @param groupId ID
	*/
	async getGroupById(groupId) {
		return await this.getQuery("SELECT * FROM Groups WHERE id = ?", [groupId]) || null;
	}
	/**
	* 
	* @param sec_uid sec_uid
	* @param filterMode 
	*/
	async updateFilterMode(sec_uid, filterMode) {
		const user = await this.getOrCreateDouyinUser(sec_uid);
		const now$1 = (/* @__PURE__ */ new Date()).toISOString();
		await this.runQuery("UPDATE DouyinUsers SET filterMode = ?, updatedAt = ? WHERE sec_uid = ?", [
			filterMode,
			now$1,
			sec_uid
		]);
		return {
			...user,
			filterMode,
			updatedAt: now$1
		};
	}
	/**
	* 
	* @param sec_uid sec_uid
	* @param word 
	*/
	async addFilterWord(sec_uid, word) {
		await this.getOrCreateDouyinUser(sec_uid);
		let filterWord = await this.getQuery("SELECT * FROM FilterWords WHERE sec_uid = ? AND word = ?", [sec_uid, word]);
		if (!filterWord) {
			const now$1 = (/* @__PURE__ */ new Date()).toISOString();
			filterWord = {
				id: (await this.runQuery("INSERT INTO FilterWords (sec_uid, word, createdAt, updatedAt) VALUES (?, ?, ?, ?)", [
					sec_uid,
					word,
					now$1,
					now$1
				])).lastID,
				sec_uid,
				word,
				createdAt: now$1,
				updatedAt: now$1
			};
		}
		return filterWord;
	}
	/**
	* 
	* @param sec_uid sec_uid
	* @param word 
	*/
	async removeFilterWord(sec_uid, word) {
		return (await this.runQuery("DELETE FROM FilterWords WHERE sec_uid = ? AND word = ?", [sec_uid, word])).changes > 0;
	}
	/**
	* 
	* @param sec_uid sec_uid
	* @param tag 
	*/
	async addFilterTag(sec_uid, tag) {
		await this.getOrCreateDouyinUser(sec_uid);
		let filterTag = await this.getQuery("SELECT * FROM FilterTags WHERE sec_uid = ? AND tag = ?", [sec_uid, tag]);
		if (!filterTag) {
			const now$1 = (/* @__PURE__ */ new Date()).toISOString();
			filterTag = {
				id: (await this.runQuery("INSERT INTO FilterTags (sec_uid, tag, createdAt, updatedAt) VALUES (?, ?, ?, ?)", [
					sec_uid,
					tag,
					now$1,
					now$1
				])).lastID,
				sec_uid,
				tag,
				createdAt: now$1,
				updatedAt: now$1
			};
		}
		return filterTag;
	}
	/**
	* 
	* @param sec_uid sec_uid
	* @param tag 
	*/
	async removeFilterTag(sec_uid, tag) {
		return (await this.runQuery("DELETE FROM FilterTags WHERE sec_uid = ? AND tag = ?", [sec_uid, tag])).changes > 0;
	}
	/**
	* 
	* @param sec_uid sec_uid
	*/
	async getFilterWords(sec_uid) {
		return (await this.allQuery("SELECT * FROM FilterWords WHERE sec_uid = ?", [sec_uid])).map((word) => word.word);
	}
	/**
	* 
	* @param sec_uid sec_uid
	*/
	async getFilterTags(sec_uid) {
		return (await this.allQuery("SELECT * FROM FilterTags WHERE sec_uid = ?", [sec_uid])).map((tag) => tag.tag);
	}
	/**
	* 
	* @param sec_uid sec_uid
	*/
	async getFilterConfig(sec_uid) {
		const user = await this.getOrCreateDouyinUser(sec_uid);
		const filterWords = await this.getFilterWords(sec_uid);
		const filterTags = await this.getFilterTags(sec_uid);
		return {
			filterMode: user.filterMode,
			filterWords,
			filterTags
		};
	}
	/**
	* 
	* @param PushItem 
	* @param tags 
	*/
	async shouldFilter(PushItem, tags = []) {
		const sec_uid = PushItem.sec_uid;
		if (!sec_uid) {
			logger.warn(` sec_uid : ${JSON.stringify(PushItem)}`);
			return false;
		}
		const { filterMode, filterWords, filterTags } = await this.getFilterConfig(sec_uid);
		logger.debug(`
      ${PushItem.remark}${PushItem.sec_uid}
      ${filterMode}
      ${filterWords}
      ${filterTags}
      `);
		const desc$1 = PushItem.Detail_Data.desc ?? "";
		const hasFilterWord = filterWords.some((word) => desc$1.includes(word));
		const hasFilterTag = filterTags.some((filterTag) => tags.some((tag) => tag === filterTag));
		logger.debug(`
      ${PushItem.remark}
      ${desc$1}
      [${filterWords.join("], [")}]
      [${filterTags.join("], [")}]
      ${filterMode}
      ${hasFilterWord || hasFilterTag ? logger.red(`${hasFilterWord || hasFilterTag}`) : logger.green(`${hasFilterWord || hasFilterTag}`)}
      ${logger.green(`https://www.douyin.com/video/${PushItem.Detail_Data.aweme_id}`)}
      `);
		if (filterMode === "blacklist") {
			if (hasFilterWord || hasFilterTag) {
				logger.warn(`
          
          ${logger.yellow(PushItem.Detail_Data.share_url)}
          [${filterWords.join("], [")}]
          [${filterTags.join("], [")}]
          `);
				return true;
			}
			return false;
		} else {
			if (filterWords.length === 0 && filterTags.length === 0) return false;
			if (hasFilterWord || hasFilterTag) return false;
			logger.warn(`
        
        ${logger.yellow(PushItem.Detail_Data.share_url)}
        [${filterWords.join("], [")}]
        [${filterTags.join("], [")}]
        `);
			return true;
		}
	}
	/**
	* 
	* @param days 
	* @returns 
	*/
	async cleanOldAwemeCache(days = 7) {
		const cutoffDate = /* @__PURE__ */ new Date();
		cutoffDate.setDate(cutoffDate.getDate() - days);
		const cutoffDateStr = cutoffDate.toISOString();
		return (await this.runQuery("DELETE FROM AwemeCaches WHERE createdAt < ?", [cutoffDateStr])).changes ?? 0;
	}
	/** groupRepositoryawemeCacheRepository */
	get groupRepository() {
		return { find: async (options) => {
			if (options?.where?.botId) return await this.getBotGroups(options.where.botId);
			return await this.allQuery("SELECT * FROM Groups");
		} };
	}
	get awemeCacheRepository() {
		return {
			find: async (options = {}) => {
				const { where = {}, order, take, relations } = options;
				let sql = "SELECT * FROM AwemeCaches";
				const params = [];
				const conditions = [];
				if (where.groupId) {
					conditions.push("groupId = ?");
					params.push(where.groupId);
				}
				if (where.sec_uid) {
					conditions.push("sec_uid = ?");
					params.push(where.sec_uid);
				}
				if (where.aweme_id) {
					conditions.push("aweme_id = ?");
					params.push(where.aweme_id);
				}
				if (conditions.length > 0) sql += " WHERE " + conditions.join(" AND ");
				if (order) {
					const orderClauses = [];
					const allowedFields = [
						"id",
						"aweme_id",
						"sec_uid",
						"groupId",
						"createdAt",
						"updatedAt"
					];
					const allowedDirections = ["ASC", "DESC"];
					for (const [field, direction] of Object.entries(order)) if (allowedFields.includes(field) && allowedDirections.includes(direction)) orderClauses.push(`${field} ${direction}`);
					if (orderClauses.length > 0) sql += " ORDER BY " + orderClauses.join(", ");
				}
				if (take) {
					sql += " LIMIT ?";
					params.push(take.toString());
				}
				const caches = await this.allQuery(sql, params);
				if (relations && relations.includes("douyinUser")) {
					const result = [];
					for (const cache of caches) {
						const douyinUser = await this.getDouyinUser(cache.sec_uid);
						result.push({
							...cache,
							douyinUser,
							createdAt: new Date(cache.createdAt),
							updatedAt: new Date(cache.updatedAt)
						});
					}
					return result;
				}
				return caches.map((cache) => ({
					...cache,
					createdAt: new Date(cache.createdAt),
					updatedAt: new Date(cache.updatedAt)
				}));
			},
			delete: async (conditions) => {
				const { groupId, sec_uid, aweme_id } = conditions;
				if (groupId && sec_uid) return { affected: (await this.runQuery("DELETE FROM AwemeCaches WHERE groupId = ? AND sec_uid = ?", [groupId, sec_uid])).changes };
				if (groupId) return { affected: (await this.runQuery("DELETE FROM AwemeCaches WHERE groupId = ?", [groupId])).changes };
				if (sec_uid) return { affected: (await this.runQuery("DELETE FROM AwemeCaches WHERE sec_uid = ?", [sec_uid])).changes };
				if (aweme_id) return { affected: (await this.runQuery("DELETE FROM AwemeCaches WHERE aweme_id = ?", [aweme_id])).changes };
				return { affected: 0 };
			}
		};
	}
};

//#endregion
//#region src/module/db/index.ts
/**  */
let douyinDB = null;
let douyinInitializing = false;
/** B */
let bilibiliDB = null;
let bilibiliInitializing = false;
/**
*  DouyinDB 
* @returns DouyinDB
*/
const getDouyinDB = async () => {
	if (douyinDB) return douyinDB;
	if (douyinInitializing) {
		await new Promise((resolve) => setTimeout(resolve, 100));
		return douyinDB;
	}
	douyinInitializing = true;
	try {
		douyinDB = await new DouyinDBBase().init();
		return douyinDB;
	} finally {
		douyinInitializing = false;
	}
};
/**
*  BilibiliDB 
* @returns BilibiliDB
*/
const getBilibiliDB = async () => {
	if (bilibiliDB) return bilibiliDB;
	if (bilibiliInitializing) {
		await new Promise((resolve) => setTimeout(resolve, 100));
		return bilibiliDB;
	}
	bilibiliInitializing = true;
	try {
		bilibiliDB = await new BilibiliDBBase().init();
		return bilibiliDB;
	} finally {
		bilibiliInitializing = false;
	}
};
/**
* 
* @returns 
*/
const initAllDatabases = async () => {
	const [douyin$1, bilibili$1] = await Promise.all([getDouyinDB(), getBilibiliDB()]);
	return {
		douyinDB: douyin$1,
		bilibiliDB: bilibili$1
	};
};
const douyinDBInstance = await getDouyinDB();
const bilibiliDBInstance = await getBilibiliDB();
/**
* 
* @param platform 'douyin' | 'bilibili'
* @param days 7
* @returns 
*/
const cleanOldDynamicCache = async (platform, days = 7) => {
	if (platform === "douyin") return await (await getDouyinDB()).cleanOldAwemeCache(days);
	else return await (await getBilibiliDB()).cleanOldDynamicCache(days);
};

//#endregion
export { Base, Bilibili, BilibiliDBBase, Bilibilipush, Client, Common, Config, Count, DouyinDBBase, Networks, Render, amagi, baseHeaders, bilibiliDBInstance, bilibiliLogin, cleanOldDynamicCache, createBilibiliRoutes, createDouyinRoutes, createKuaishouRoutes, douyinDBInstance, downloadFile, downloadVideo, getBilibiliDB, getBilibiliData, getBilibiliID, getDouyinDB, getDouyinData, initAllDatabases, logMiddleware, logger$1 as logger, mergeFile, require_follow_redirects, require_src };