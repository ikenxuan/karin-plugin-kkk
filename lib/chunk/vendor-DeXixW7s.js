const __filename = import.meta.url ? new URL(import.meta.url).pathname : "";
const __dirname = import.meta.url ? new URL(".", import.meta.url).pathname : "";
import require$$1$2 from "fs";
import require$$0$5 from "util";
import require$$1$1 from "os";
import require$$1$3 from "path";
import require$$0$6, { fileURLToPath } from "url";
import require$$0$1$1 from "constants";
import stream, { Readable } from "stream";
import require$$5$1 from "assert";
import zlib from "zlib";
import require$$1$3$1 from "net";
import require$$1$4 from "http";
import require$$2$1 from "https";
import crypto$1 from "crypto";
import { EventEmitter } from "events";
import require$$0$4$1 from "buffer";
import require$$1$1$1 from "string_decoder";
import require$$4$1 from "node:zlib";
import require$$1$5 from "node:events";
import path from "node:path";
import fs$1 from "node:fs";
import require$$2$2 from "node:http";
import require$$6$1 from "querystring";
import require$$1$4$1 from "node:net";
var commonjsGlobal$2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var _Reflect = {};
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var hasRequired_Reflect;
function require_Reflect() {
  if (hasRequired_Reflect) return _Reflect;
  hasRequired_Reflect = 1;
  var Reflect2;
  (function(Reflect3) {
    (function(factory2) {
      var root = typeof globalThis === "object" ? globalThis : typeof commonjsGlobal$2 === "object" ? commonjsGlobal$2 : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
      var exporter = makeExporter(Reflect3);
      if (typeof root.Reflect !== "undefined") {
        exporter = makeExporter(root.Reflect, exporter);
      }
      factory2(exporter, root);
      if (typeof root.Reflect === "undefined") {
        root.Reflect = Reflect3;
      }
      function makeExporter(target, previous) {
        return function(key, value) {
          Object.defineProperty(target, key, { configurable: true, writable: true, value });
          if (previous)
            previous(key, value);
        };
      }
      function functionThis() {
        try {
          return Function("return this;")();
        } catch (_) {
        }
      }
      function indirectEvalThis() {
        try {
          return (void 0, eval)("(function() { return this; })()");
        } catch (_) {
        }
      }
      function sloppyModeThis() {
        return functionThis() || indirectEvalThis();
      }
    })(function(exporter, root) {
      var hasOwn = Object.prototype.hasOwnProperty;
      var supportsSymbol = typeof Symbol === "function";
      var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
      var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
      var supportsCreate = typeof Object.create === "function";
      var supportsProto = { __proto__: [] } instanceof Array;
      var downLevel = !supportsCreate && !supportsProto;
      var HashMap = {
        // create an object in dictionary mode (a.k.a. "slow" mode in v8)
        create: supportsCreate ? function() {
          return MakeDictionary(/* @__PURE__ */ Object.create(null));
        } : supportsProto ? function() {
          return MakeDictionary({ __proto__: null });
        } : function() {
          return MakeDictionary({});
        },
        has: downLevel ? function(map, key) {
          return hasOwn.call(map, key);
        } : function(map, key) {
          return key in map;
        },
        get: downLevel ? function(map, key) {
          return hasOwn.call(map, key) ? map[key] : void 0;
        } : function(map, key) {
          return map[key];
        }
      };
      var functionPrototype = Object.getPrototypeOf(Function);
      var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
      var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
      var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
      var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : void 0;
      var metadataRegistry = GetOrCreateMetadataRegistry();
      var metadataProvider = CreateMetadataProvider(metadataRegistry);
      function decorate(decorators, target, propertyKey, attributes) {
        if (!IsUndefined(propertyKey)) {
          if (!IsArray(decorators))
            throw new TypeError();
          if (!IsObject(target))
            throw new TypeError();
          if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
            throw new TypeError();
          if (IsNull(attributes))
            attributes = void 0;
          propertyKey = ToPropertyKey(propertyKey);
          return DecorateProperty(decorators, target, propertyKey, attributes);
        } else {
          if (!IsArray(decorators))
            throw new TypeError();
          if (!IsConstructor(target))
            throw new TypeError();
          return DecorateConstructor(decorators, target);
        }
      }
      exporter("decorate", decorate);
      function metadata(metadataKey, metadataValue) {
        function decorator(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
            throw new TypeError();
          OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        return decorator;
      }
      exporter("metadata", metadata);
      function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      exporter("defineMetadata", defineMetadata);
      function hasMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasMetadata(metadataKey, target, propertyKey);
      }
      exporter("hasMetadata", hasMetadata);
      function hasOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
      }
      exporter("hasOwnMetadata", hasOwnMetadata);
      function getMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetMetadata(metadataKey, target, propertyKey);
      }
      exporter("getMetadata", getMetadata);
      function getOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
      }
      exporter("getOwnMetadata", getOwnMetadata);
      function getMetadataKeys(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryMetadataKeys(target, propertyKey);
      }
      exporter("getMetadataKeys", getMetadataKeys);
      function getOwnMetadataKeys(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryOwnMetadataKeys(target, propertyKey);
      }
      exporter("getOwnMetadataKeys", getOwnMetadataKeys);
      function deleteMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        var provider = GetMetadataProvider(
          target,
          propertyKey,
          /*Create*/
          false
        );
        if (IsUndefined(provider))
          return false;
        return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
      }
      exporter("deleteMetadata", deleteMetadata);
      function DecorateConstructor(decorators, target) {
        for (var i = decorators.length - 1; i >= 0; --i) {
          var decorator = decorators[i];
          var decorated = decorator(target);
          if (!IsUndefined(decorated) && !IsNull(decorated)) {
            if (!IsConstructor(decorated))
              throw new TypeError();
            target = decorated;
          }
        }
        return target;
      }
      function DecorateProperty(decorators, target, propertyKey, descriptor) {
        for (var i = decorators.length - 1; i >= 0; --i) {
          var decorator = decorators[i];
          var decorated = decorator(target, propertyKey, descriptor);
          if (!IsUndefined(decorated) && !IsNull(decorated)) {
            if (!IsObject(decorated))
              throw new TypeError();
            descriptor = decorated;
          }
        }
        return descriptor;
      }
      function OrdinaryHasMetadata(MetadataKey, O, P) {
        var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn2)
          return true;
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent))
          return OrdinaryHasMetadata(MetadataKey, parent, P);
        return false;
      }
      function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
        var provider = GetMetadataProvider(
          O,
          P,
          /*Create*/
          false
        );
        if (IsUndefined(provider))
          return false;
        return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O, P));
      }
      function OrdinaryGetMetadata(MetadataKey, O, P) {
        var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn2)
          return OrdinaryGetOwnMetadata(MetadataKey, O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent))
          return OrdinaryGetMetadata(MetadataKey, parent, P);
        return void 0;
      }
      function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
        var provider = GetMetadataProvider(
          O,
          P,
          /*Create*/
          false
        );
        if (IsUndefined(provider))
          return;
        return provider.OrdinaryGetOwnMetadata(MetadataKey, O, P);
      }
      function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
        var provider = GetMetadataProvider(
          O,
          P,
          /*Create*/
          true
        );
        provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P);
      }
      function OrdinaryMetadataKeys(O, P) {
        var ownKeys = OrdinaryOwnMetadataKeys(O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (parent === null)
          return ownKeys;
        var parentKeys = OrdinaryMetadataKeys(parent, P);
        if (parentKeys.length <= 0)
          return ownKeys;
        if (ownKeys.length <= 0)
          return parentKeys;
        var set = new _Set();
        var keys = [];
        for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
          var key = ownKeys_1[_i];
          var hasKey = set.has(key);
          if (!hasKey) {
            set.add(key);
            keys.push(key);
          }
        }
        for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
          var key = parentKeys_1[_a];
          var hasKey = set.has(key);
          if (!hasKey) {
            set.add(key);
            keys.push(key);
          }
        }
        return keys;
      }
      function OrdinaryOwnMetadataKeys(O, P) {
        var provider = GetMetadataProvider(
          O,
          P,
          /*create*/
          false
        );
        if (!provider) {
          return [];
        }
        return provider.OrdinaryOwnMetadataKeys(O, P);
      }
      function Type(x) {
        if (x === null)
          return 1;
        switch (typeof x) {
          case "undefined":
            return 0;
          case "boolean":
            return 2;
          case "string":
            return 3;
          case "symbol":
            return 4;
          case "number":
            return 5;
          case "object":
            return x === null ? 1 : 6;
          default:
            return 6;
        }
      }
      function IsUndefined(x) {
        return x === void 0;
      }
      function IsNull(x) {
        return x === null;
      }
      function IsSymbol(x) {
        return typeof x === "symbol";
      }
      function IsObject(x) {
        return typeof x === "object" ? x !== null : typeof x === "function";
      }
      function ToPrimitive(input, PreferredType) {
        switch (Type(input)) {
          case 0:
            return input;
          case 1:
            return input;
          case 2:
            return input;
          case 3:
            return input;
          case 4:
            return input;
          case 5:
            return input;
        }
        var hint = "string";
        var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
        if (exoticToPrim !== void 0) {
          var result = exoticToPrim.call(input, hint);
          if (IsObject(result))
            throw new TypeError();
          return result;
        }
        return OrdinaryToPrimitive(input);
      }
      function OrdinaryToPrimitive(O, hint) {
        var valueOf, result, toString_2;
        {
          var toString_1 = O.toString;
          if (IsCallable(toString_1)) {
            var result = toString_1.call(O);
            if (!IsObject(result))
              return result;
          }
          var valueOf = O.valueOf;
          if (IsCallable(valueOf)) {
            var result = valueOf.call(O);
            if (!IsObject(result))
              return result;
          }
        }
        throw new TypeError();
      }
      function ToBoolean(argument) {
        return !!argument;
      }
      function ToString(argument) {
        return "" + argument;
      }
      function ToPropertyKey(argument) {
        var key = ToPrimitive(argument);
        if (IsSymbol(key))
          return key;
        return ToString(key);
      }
      function IsArray(argument) {
        return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
      }
      function IsCallable(argument) {
        return typeof argument === "function";
      }
      function IsConstructor(argument) {
        return typeof argument === "function";
      }
      function IsPropertyKey(argument) {
        switch (Type(argument)) {
          case 3:
            return true;
          case 4:
            return true;
          default:
            return false;
        }
      }
      function SameValueZero(x, y) {
        return x === y || x !== x && y !== y;
      }
      function GetMethod(V, P) {
        var func = V[P];
        if (func === void 0 || func === null)
          return void 0;
        if (!IsCallable(func))
          throw new TypeError();
        return func;
      }
      function GetIterator(obj) {
        var method = GetMethod(obj, iteratorSymbol);
        if (!IsCallable(method))
          throw new TypeError();
        var iterator2 = method.call(obj);
        if (!IsObject(iterator2))
          throw new TypeError();
        return iterator2;
      }
      function IteratorValue(iterResult) {
        return iterResult.value;
      }
      function IteratorStep(iterator2) {
        var result = iterator2.next();
        return result.done ? false : result;
      }
      function IteratorClose(iterator2) {
        var f = iterator2["return"];
        if (f)
          f.call(iterator2);
      }
      function OrdinaryGetPrototypeOf(O) {
        var proto2 = Object.getPrototypeOf(O);
        if (typeof O !== "function" || O === functionPrototype)
          return proto2;
        if (proto2 !== functionPrototype)
          return proto2;
        var prototype2 = O.prototype;
        var prototypeProto = prototype2 && Object.getPrototypeOf(prototype2);
        if (prototypeProto == null || prototypeProto === Object.prototype)
          return proto2;
        var constructor = prototypeProto.constructor;
        if (typeof constructor !== "function")
          return proto2;
        if (constructor === O)
          return proto2;
        return constructor;
      }
      function CreateMetadataRegistry() {
        var fallback;
        if (!IsUndefined(registrySymbol) && typeof root.Reflect !== "undefined" && !(registrySymbol in root.Reflect) && typeof root.Reflect.defineMetadata === "function") {
          fallback = CreateFallbackProvider(root.Reflect);
        }
        var first;
        var second;
        var rest;
        var targetProviderMap = new _WeakMap();
        var registry = {
          registerProvider,
          getProvider,
          setProvider
        };
        return registry;
        function registerProvider(provider) {
          if (!Object.isExtensible(registry)) {
            throw new Error("Cannot add provider to a frozen registry.");
          }
          switch (true) {
            case fallback === provider:
              break;
            case IsUndefined(first):
              first = provider;
              break;
            case first === provider:
              break;
            case IsUndefined(second):
              second = provider;
              break;
            case second === provider:
              break;
            default:
              if (rest === void 0)
                rest = new _Set();
              rest.add(provider);
              break;
          }
        }
        function getProviderNoCache(O, P) {
          if (!IsUndefined(first)) {
            if (first.isProviderFor(O, P))
              return first;
            if (!IsUndefined(second)) {
              if (second.isProviderFor(O, P))
                return first;
              if (!IsUndefined(rest)) {
                var iterator2 = GetIterator(rest);
                while (true) {
                  var next = IteratorStep(iterator2);
                  if (!next) {
                    return void 0;
                  }
                  var provider = IteratorValue(next);
                  if (provider.isProviderFor(O, P)) {
                    IteratorClose(iterator2);
                    return provider;
                  }
                }
              }
            }
          }
          if (!IsUndefined(fallback) && fallback.isProviderFor(O, P)) {
            return fallback;
          }
          return void 0;
        }
        function getProvider(O, P) {
          var providerMap = targetProviderMap.get(O);
          var provider;
          if (!IsUndefined(providerMap)) {
            provider = providerMap.get(P);
          }
          if (!IsUndefined(provider)) {
            return provider;
          }
          provider = getProviderNoCache(O, P);
          if (!IsUndefined(provider)) {
            if (IsUndefined(providerMap)) {
              providerMap = new _Map();
              targetProviderMap.set(O, providerMap);
            }
            providerMap.set(P, provider);
          }
          return provider;
        }
        function hasProvider(provider) {
          if (IsUndefined(provider))
            throw new TypeError();
          return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
        }
        function setProvider(O, P, provider) {
          if (!hasProvider(provider)) {
            throw new Error("Metadata provider not registered.");
          }
          var existingProvider = getProvider(O, P);
          if (existingProvider !== provider) {
            if (!IsUndefined(existingProvider)) {
              return false;
            }
            var providerMap = targetProviderMap.get(O);
            if (IsUndefined(providerMap)) {
              providerMap = new _Map();
              targetProviderMap.set(O, providerMap);
            }
            providerMap.set(P, provider);
          }
          return true;
        }
      }
      function GetOrCreateMetadataRegistry() {
        var metadataRegistry2;
        if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
          metadataRegistry2 = root.Reflect[registrySymbol];
        }
        if (IsUndefined(metadataRegistry2)) {
          metadataRegistry2 = CreateMetadataRegistry();
        }
        if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
          Object.defineProperty(root.Reflect, registrySymbol, {
            enumerable: false,
            configurable: false,
            writable: false,
            value: metadataRegistry2
          });
        }
        return metadataRegistry2;
      }
      function CreateMetadataProvider(registry) {
        var metadata2 = new _WeakMap();
        var provider = {
          isProviderFor: function(O, P) {
            var targetMetadata = metadata2.get(O);
            if (IsUndefined(targetMetadata))
              return false;
            return targetMetadata.has(P);
          },
          OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
          OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
          OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
          OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
          OrdinaryDeleteMetadata
        };
        metadataRegistry.registerProvider(provider);
        return provider;
        function GetOrCreateMetadataMap(O, P, Create) {
          var targetMetadata = metadata2.get(O);
          var createdTargetMetadata = false;
          if (IsUndefined(targetMetadata)) {
            if (!Create)
              return void 0;
            targetMetadata = new _Map();
            metadata2.set(O, targetMetadata);
            createdTargetMetadata = true;
          }
          var metadataMap = targetMetadata.get(P);
          if (IsUndefined(metadataMap)) {
            if (!Create)
              return void 0;
            metadataMap = new _Map();
            targetMetadata.set(P, metadataMap);
            if (!registry.setProvider(O, P, provider)) {
              targetMetadata.delete(P);
              if (createdTargetMetadata) {
                metadata2.delete(O);
              }
              throw new Error("Wrong provider for target.");
            }
          }
          return metadataMap;
        }
        function OrdinaryHasOwnMetadata2(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(
            O,
            P,
            /*Create*/
            false
          );
          if (IsUndefined(metadataMap))
            return false;
          return ToBoolean(metadataMap.has(MetadataKey));
        }
        function OrdinaryGetOwnMetadata2(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(
            O,
            P,
            /*Create*/
            false
          );
          if (IsUndefined(metadataMap))
            return void 0;
          return metadataMap.get(MetadataKey);
        }
        function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O, P) {
          var metadataMap = GetOrCreateMetadataMap(
            O,
            P,
            /*Create*/
            true
          );
          metadataMap.set(MetadataKey, MetadataValue);
        }
        function OrdinaryOwnMetadataKeys2(O, P) {
          var keys = [];
          var metadataMap = GetOrCreateMetadataMap(
            O,
            P,
            /*Create*/
            false
          );
          if (IsUndefined(metadataMap))
            return keys;
          var keysObj = metadataMap.keys();
          var iterator2 = GetIterator(keysObj);
          var k = 0;
          while (true) {
            var next = IteratorStep(iterator2);
            if (!next) {
              keys.length = k;
              return keys;
            }
            var nextValue = IteratorValue(next);
            try {
              keys[k] = nextValue;
            } catch (e) {
              try {
                IteratorClose(iterator2);
              } finally {
                throw e;
              }
            }
            k++;
          }
        }
        function OrdinaryDeleteMetadata(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(
            O,
            P,
            /*Create*/
            false
          );
          if (IsUndefined(metadataMap))
            return false;
          if (!metadataMap.delete(MetadataKey))
            return false;
          if (metadataMap.size === 0) {
            var targetMetadata = metadata2.get(O);
            if (!IsUndefined(targetMetadata)) {
              targetMetadata.delete(P);
              if (targetMetadata.size === 0) {
                metadata2.delete(targetMetadata);
              }
            }
          }
          return true;
        }
      }
      function CreateFallbackProvider(reflect) {
        var defineMetadata2 = reflect.defineMetadata, hasOwnMetadata2 = reflect.hasOwnMetadata, getOwnMetadata2 = reflect.getOwnMetadata, getOwnMetadataKeys2 = reflect.getOwnMetadataKeys, deleteMetadata2 = reflect.deleteMetadata;
        var metadataOwner = new _WeakMap();
        var provider = {
          isProviderFor: function(O, P) {
            var metadataPropertySet = metadataOwner.get(O);
            if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P)) {
              return true;
            }
            if (getOwnMetadataKeys2(O, P).length) {
              if (IsUndefined(metadataPropertySet)) {
                metadataPropertySet = new _Set();
                metadataOwner.set(O, metadataPropertySet);
              }
              metadataPropertySet.add(P);
              return true;
            }
            return false;
          },
          OrdinaryDefineOwnMetadata: defineMetadata2,
          OrdinaryHasOwnMetadata: hasOwnMetadata2,
          OrdinaryGetOwnMetadata: getOwnMetadata2,
          OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
          OrdinaryDeleteMetadata: deleteMetadata2
        };
        return provider;
      }
      function GetMetadataProvider(O, P, Create) {
        var registeredProvider = metadataRegistry.getProvider(O, P);
        if (!IsUndefined(registeredProvider)) {
          return registeredProvider;
        }
        if (Create) {
          if (metadataRegistry.setProvider(O, P, metadataProvider)) {
            return metadataProvider;
          }
          throw new Error("Illegal state.");
        }
        return void 0;
      }
      function CreateMapPolyfill() {
        var cacheSentinel = {};
        var arraySentinel = [];
        var MapIterator = (
          /** @class */
          function() {
            function MapIterator2(keys, values, selector) {
              this._index = 0;
              this._keys = keys;
              this._values = values;
              this._selector = selector;
            }
            MapIterator2.prototype["@@iterator"] = function() {
              return this;
            };
            MapIterator2.prototype[iteratorSymbol] = function() {
              return this;
            };
            MapIterator2.prototype.next = function() {
              var index2 = this._index;
              if (index2 >= 0 && index2 < this._keys.length) {
                var result = this._selector(this._keys[index2], this._values[index2]);
                if (index2 + 1 >= this._keys.length) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                } else {
                  this._index++;
                }
                return { value: result, done: false };
              }
              return { value: void 0, done: true };
            };
            MapIterator2.prototype.throw = function(error) {
              if (this._index >= 0) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              }
              throw error;
            };
            MapIterator2.prototype.return = function(value) {
              if (this._index >= 0) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              }
              return { value, done: true };
            };
            return MapIterator2;
          }()
        );
        var Map2 = (
          /** @class */
          function() {
            function Map3() {
              this._keys = [];
              this._values = [];
              this._cacheKey = cacheSentinel;
              this._cacheIndex = -2;
            }
            Object.defineProperty(Map3.prototype, "size", {
              get: function() {
                return this._keys.length;
              },
              enumerable: true,
              configurable: true
            });
            Map3.prototype.has = function(key) {
              return this._find(
                key,
                /*insert*/
                false
              ) >= 0;
            };
            Map3.prototype.get = function(key) {
              var index2 = this._find(
                key,
                /*insert*/
                false
              );
              return index2 >= 0 ? this._values[index2] : void 0;
            };
            Map3.prototype.set = function(key, value) {
              var index2 = this._find(
                key,
                /*insert*/
                true
              );
              this._values[index2] = value;
              return this;
            };
            Map3.prototype.delete = function(key) {
              var index2 = this._find(
                key,
                /*insert*/
                false
              );
              if (index2 >= 0) {
                var size = this._keys.length;
                for (var i = index2 + 1; i < size; i++) {
                  this._keys[i - 1] = this._keys[i];
                  this._values[i - 1] = this._values[i];
                }
                this._keys.length--;
                this._values.length--;
                if (SameValueZero(key, this._cacheKey)) {
                  this._cacheKey = cacheSentinel;
                  this._cacheIndex = -2;
                }
                return true;
              }
              return false;
            };
            Map3.prototype.clear = function() {
              this._keys.length = 0;
              this._values.length = 0;
              this._cacheKey = cacheSentinel;
              this._cacheIndex = -2;
            };
            Map3.prototype.keys = function() {
              return new MapIterator(this._keys, this._values, getKey);
            };
            Map3.prototype.values = function() {
              return new MapIterator(this._keys, this._values, getValue);
            };
            Map3.prototype.entries = function() {
              return new MapIterator(this._keys, this._values, getEntry);
            };
            Map3.prototype["@@iterator"] = function() {
              return this.entries();
            };
            Map3.prototype[iteratorSymbol] = function() {
              return this.entries();
            };
            Map3.prototype._find = function(key, insert) {
              if (!SameValueZero(this._cacheKey, key)) {
                this._cacheIndex = -1;
                for (var i = 0; i < this._keys.length; i++) {
                  if (SameValueZero(this._keys[i], key)) {
                    this._cacheIndex = i;
                    break;
                  }
                }
              }
              if (this._cacheIndex < 0 && insert) {
                this._cacheIndex = this._keys.length;
                this._keys.push(key);
                this._values.push(void 0);
              }
              return this._cacheIndex;
            };
            return Map3;
          }()
        );
        return Map2;
        function getKey(key, _) {
          return key;
        }
        function getValue(_, value) {
          return value;
        }
        function getEntry(key, value) {
          return [key, value];
        }
      }
      function CreateSetPolyfill() {
        var Set2 = (
          /** @class */
          function() {
            function Set3() {
              this._map = new _Map();
            }
            Object.defineProperty(Set3.prototype, "size", {
              get: function() {
                return this._map.size;
              },
              enumerable: true,
              configurable: true
            });
            Set3.prototype.has = function(value) {
              return this._map.has(value);
            };
            Set3.prototype.add = function(value) {
              return this._map.set(value, value), this;
            };
            Set3.prototype.delete = function(value) {
              return this._map.delete(value);
            };
            Set3.prototype.clear = function() {
              this._map.clear();
            };
            Set3.prototype.keys = function() {
              return this._map.keys();
            };
            Set3.prototype.values = function() {
              return this._map.keys();
            };
            Set3.prototype.entries = function() {
              return this._map.entries();
            };
            Set3.prototype["@@iterator"] = function() {
              return this.keys();
            };
            Set3.prototype[iteratorSymbol] = function() {
              return this.keys();
            };
            return Set3;
          }()
        );
        return Set2;
      }
      function CreateWeakMapPolyfill() {
        var UUID_SIZE = 16;
        var keys = HashMap.create();
        var rootKey = CreateUniqueKey();
        return (
          /** @class */
          function() {
            function WeakMap2() {
              this._key = CreateUniqueKey();
            }
            WeakMap2.prototype.has = function(target) {
              var table = GetOrCreateWeakMapTable(
                target,
                /*create*/
                false
              );
              return table !== void 0 ? HashMap.has(table, this._key) : false;
            };
            WeakMap2.prototype.get = function(target) {
              var table = GetOrCreateWeakMapTable(
                target,
                /*create*/
                false
              );
              return table !== void 0 ? HashMap.get(table, this._key) : void 0;
            };
            WeakMap2.prototype.set = function(target, value) {
              var table = GetOrCreateWeakMapTable(
                target,
                /*create*/
                true
              );
              table[this._key] = value;
              return this;
            };
            WeakMap2.prototype.delete = function(target) {
              var table = GetOrCreateWeakMapTable(
                target,
                /*create*/
                false
              );
              return table !== void 0 ? delete table[this._key] : false;
            };
            WeakMap2.prototype.clear = function() {
              this._key = CreateUniqueKey();
            };
            return WeakMap2;
          }()
        );
        function CreateUniqueKey() {
          var key;
          do
            key = "@@WeakMap@@" + CreateUUID();
          while (HashMap.has(keys, key));
          keys[key] = true;
          return key;
        }
        function GetOrCreateWeakMapTable(target, create) {
          if (!hasOwn.call(target, rootKey)) {
            if (!create)
              return void 0;
            Object.defineProperty(target, rootKey, { value: HashMap.create() });
          }
          return target[rootKey];
        }
        function FillRandomBytes(buffer2, size) {
          for (var i = 0; i < size; ++i)
            buffer2[i] = Math.random() * 255 | 0;
          return buffer2;
        }
        function GenRandomBytes(size) {
          if (typeof Uint8Array === "function") {
            var array = new Uint8Array(size);
            if (typeof crypto !== "undefined") {
              crypto.getRandomValues(array);
            } else if (typeof msCrypto !== "undefined") {
              msCrypto.getRandomValues(array);
            } else {
              FillRandomBytes(array, size);
            }
            return array;
          }
          return FillRandomBytes(new Array(size), size);
        }
        function CreateUUID() {
          var data2 = GenRandomBytes(UUID_SIZE);
          data2[6] = data2[6] & 79 | 64;
          data2[8] = data2[8] & 191 | 128;
          var result = "";
          for (var offset = 0; offset < UUID_SIZE; ++offset) {
            var byte = data2[offset];
            if (offset === 4 || offset === 6 || offset === 8)
              result += "-";
            if (byte < 16)
              result += "0";
            result += byte.toString(16).toLowerCase();
          }
          return result;
        }
      }
      function MakeDictionary(obj) {
        obj.__ = void 0;
        delete obj.__;
        return obj;
      }
    });
  })(Reflect2 || (Reflect2 = {}));
  return _Reflect;
}
require_Reflect();
const ANSI_BACKGROUND_OFFSET = 10;
const wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
const wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
const styles$1 = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
Object.keys(styles$1.modifier);
const foregroundColorNames = Object.keys(styles$1.color);
const backgroundColorNames = Object.keys(styles$1.bgColor);
[...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes = /* @__PURE__ */ new Map();
  for (const [groupName, group] of Object.entries(styles$1)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles$1[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles$1[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles$1, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles$1, "codes", {
    value: codes,
    enumerable: false
  });
  styles$1.color.close = "\x1B[39m";
  styles$1.bgColor.close = "\x1B[49m";
  styles$1.color.ansi = wrapAnsi16();
  styles$1.color.ansi256 = wrapAnsi256();
  styles$1.color.ansi16m = wrapAnsi16m();
  styles$1.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles$1.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles$1.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles$1, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles$1.rgbToAnsi256(...styles$1.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles$1.ansi256ToAnsi(styles$1.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles$1.ansi256ToAnsi(styles$1.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles$1;
}
const ansiStyles = assembleStyles();
const level = (() => {
  if (!("navigator" in globalThis)) {
    return 0;
  }
  if (globalThis.navigator.userAgentData) {
    const brand = navigator.userAgentData.brands.find(({ brand: brand2 }) => brand2 === "Chromium");
    if (brand && brand.version > 93) {
      return 3;
    }
  }
  if (/\b(Chrome|Chromium)\//.test(globalThis.navigator.userAgent)) {
    return 1;
  }
  return 0;
})();
const colorSupport = level !== 0 && {
  level
};
const supportsColor = {
  stdout: colorSupport,
  stderr: colorSupport
};
function stringReplaceAll(string, substring, replacer) {
  let index2 = string.indexOf(substring);
  if (index2 === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index2) + substring + replacer;
    endIndex = index2 + substringLength;
    index2 = string.indexOf(substring, endIndex);
  } while (index2 !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index2) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index2 - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index2 - 1 : index2) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index2 + 1;
    index2 = string.indexOf("\n", endIndex);
  } while (index2 !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
const { stdout: stdoutColor, stderr: stderrColor } = supportsColor;
const GENERATOR = Symbol("GENERATOR");
const STYLER = Symbol("STYLER");
const IS_EMPTY = Symbol("IS_EMPTY");
const levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
const styles = /* @__PURE__ */ Object.create(null);
const applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
};
class Chalk {
  constructor(options) {
    return chalkFactory(options);
  }
}
const chalkFactory = (options) => {
  const chalk = (...strings) => strings.join(" ");
  applyOptions(chalk, options);
  Object.setPrototypeOf(chalk, createChalk.prototype);
  return chalk;
};
function createChalk(options) {
  return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansiStyles)) {
  styles[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
const getModelAnsi = (model, level2, type2, ...arguments_) => {
  if (model === "rgb") {
    if (level2 === "ansi16m") {
      return ansiStyles[type2].ansi16m(...arguments_);
    }
    if (level2 === "ansi256") {
      return ansiStyles[type2].ansi256(ansiStyles.rgbToAnsi256(...arguments_));
    }
    return ansiStyles[type2].ansi(ansiStyles.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level2, type2, ...ansiStyles.hexToRgb(...arguments_));
  }
  return ansiStyles[type2][model](...arguments_);
};
const usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles[model] = {
    get() {
      const { level: level2 } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level2], "color", ...arguments_), ansiStyles.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles[bgModel] = {
    get() {
      const { level: level2 } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level2], "bgColor", ...arguments_), ansiStyles.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
const proto = Object.defineProperties(() => {
}, {
  ...styles,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level2) {
      this[GENERATOR].level = level2;
    }
  }
});
const createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
const createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self2;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
const applyStyle = (self2, string) => {
  if (self2.level <= 0 || !string) {
    return self2[IS_EMPTY] ? "" : string;
  }
  let styler = self2[STYLER];
  if (styler === void 0) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== void 0) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf("\n");
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles);
createChalk();
createChalk({ level: stderrColor ? stderrColor.level : 0 });
function _mergeNamespaces$1(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var browser$4 = { exports: {} };
var ms$3;
var hasRequiredMs$3;
function requireMs$3() {
  if (hasRequiredMs$3) return ms$3;
  hasRequiredMs$3 = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms$3 = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms$3;
}
var common$4;
var hasRequiredCommon$4;
function requireCommon$4() {
  if (hasRequiredCommon$4) return common$4;
  hasRequiredCommon$4 = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs$3();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index2++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index2];
            match = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend2;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common$4 = setup;
  return common$4;
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4) return browser$4.exports;
  hasRequiredBrowser$4 = 1;
  (function(module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = requireCommon$4()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser$4, browser$4.exports);
  return browser$4.exports;
}
var rfdc_1;
var hasRequiredRfdc;
function requireRfdc() {
  if (hasRequiredRfdc) return rfdc_1;
  hasRequiredRfdc = 1;
  rfdc_1 = rfdc;
  function copyBuffer(cur) {
    if (cur instanceof Buffer) {
      return Buffer.from(cur);
    }
    return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
  }
  function rfdc(opts) {
    opts = opts || {};
    if (opts.circles) return rfdcCircles(opts);
    const constructorHandlers = /* @__PURE__ */ new Map();
    constructorHandlers.set(Date, (o) => new Date(o));
    constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
    constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
    if (opts.constructorHandlers) {
      for (const handler2 of opts.constructorHandlers) {
        constructorHandlers.set(handler2[0], handler2[1]);
      }
    }
    let handler = null;
    return opts.proto ? cloneProto : clone;
    function cloneArray(a, fn) {
      const keys = Object.keys(a);
      const a2 = new Array(keys.length);
      for (let i = 0; i < keys.length; i++) {
        const k = keys[i];
        const cur = a[k];
        if (typeof cur !== "object" || cur === null) {
          a2[k] = cur;
        } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
          a2[k] = handler(cur, fn);
        } else if (ArrayBuffer.isView(cur)) {
          a2[k] = copyBuffer(cur);
        } else {
          a2[k] = fn(cur);
        }
      }
      return a2;
    }
    function clone(o) {
      if (typeof o !== "object" || o === null) return o;
      if (Array.isArray(o)) return cloneArray(o, clone);
      if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
        return handler(o, clone);
      }
      const o2 = {};
      for (const k in o) {
        if (Object.hasOwnProperty.call(o, k) === false) continue;
        const cur = o[k];
        if (typeof cur !== "object" || cur === null) {
          o2[k] = cur;
        } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
          o2[k] = handler(cur, clone);
        } else if (ArrayBuffer.isView(cur)) {
          o2[k] = copyBuffer(cur);
        } else {
          o2[k] = clone(cur);
        }
      }
      return o2;
    }
    function cloneProto(o) {
      if (typeof o !== "object" || o === null) return o;
      if (Array.isArray(o)) return cloneArray(o, cloneProto);
      if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
        return handler(o, cloneProto);
      }
      const o2 = {};
      for (const k in o) {
        const cur = o[k];
        if (typeof cur !== "object" || cur === null) {
          o2[k] = cur;
        } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
          o2[k] = handler(cur, cloneProto);
        } else if (ArrayBuffer.isView(cur)) {
          o2[k] = copyBuffer(cur);
        } else {
          o2[k] = cloneProto(cur);
        }
      }
      return o2;
    }
  }
  function rfdcCircles(opts) {
    const refs = [];
    const refsNew = [];
    const constructorHandlers = /* @__PURE__ */ new Map();
    constructorHandlers.set(Date, (o) => new Date(o));
    constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
    constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
    if (opts.constructorHandlers) {
      for (const handler2 of opts.constructorHandlers) {
        constructorHandlers.set(handler2[0], handler2[1]);
      }
    }
    let handler = null;
    return opts.proto ? cloneProto : clone;
    function cloneArray(a, fn) {
      const keys = Object.keys(a);
      const a2 = new Array(keys.length);
      for (let i = 0; i < keys.length; i++) {
        const k = keys[i];
        const cur = a[k];
        if (typeof cur !== "object" || cur === null) {
          a2[k] = cur;
        } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
          a2[k] = handler(cur, fn);
        } else if (ArrayBuffer.isView(cur)) {
          a2[k] = copyBuffer(cur);
        } else {
          const index2 = refs.indexOf(cur);
          if (index2 !== -1) {
            a2[k] = refsNew[index2];
          } else {
            a2[k] = fn(cur);
          }
        }
      }
      return a2;
    }
    function clone(o) {
      if (typeof o !== "object" || o === null) return o;
      if (Array.isArray(o)) return cloneArray(o, clone);
      if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
        return handler(o, clone);
      }
      const o2 = {};
      refs.push(o);
      refsNew.push(o2);
      for (const k in o) {
        if (Object.hasOwnProperty.call(o, k) === false) continue;
        const cur = o[k];
        if (typeof cur !== "object" || cur === null) {
          o2[k] = cur;
        } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
          o2[k] = handler(cur, clone);
        } else if (ArrayBuffer.isView(cur)) {
          o2[k] = copyBuffer(cur);
        } else {
          const i = refs.indexOf(cur);
          if (i !== -1) {
            o2[k] = refsNew[i];
          } else {
            o2[k] = clone(cur);
          }
        }
      }
      refs.pop();
      refsNew.pop();
      return o2;
    }
    function cloneProto(o) {
      if (typeof o !== "object" || o === null) return o;
      if (Array.isArray(o)) return cloneArray(o, cloneProto);
      if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
        return handler(o, cloneProto);
      }
      const o2 = {};
      refs.push(o);
      refsNew.push(o2);
      for (const k in o) {
        const cur = o[k];
        if (typeof cur !== "object" || cur === null) {
          o2[k] = cur;
        } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
          o2[k] = handler(cur, cloneProto);
        } else if (ArrayBuffer.isView(cur)) {
          o2[k] = copyBuffer(cur);
        } else {
          const i = refs.indexOf(cur);
          if (i !== -1) {
            o2[k] = refsNew[i];
          } else {
            o2[k] = cloneProto(cur);
          }
        }
      }
      refs.pop();
      refsNew.pop();
      return o2;
    }
  }
  return rfdc_1;
}
var configuration$1;
var hasRequiredConfiguration$1;
function requireConfiguration$1() {
  if (hasRequiredConfiguration$1) return configuration$1;
  hasRequiredConfiguration$1 = 1;
  const util2 = require$$0$5;
  const debug2 = requireBrowser$4()("log4js:configuration");
  const preProcessingListeners = [];
  const listeners = [];
  const not = (thing) => !thing;
  const anObject = (thing) => thing && typeof thing === "object" && !Array.isArray(thing);
  const validIdentifier = (thing) => /^[A-Za-z][A-Za-z0-9_]*$/g.test(thing);
  const anInteger = (thing) => thing && typeof thing === "number" && Number.isInteger(thing);
  const addListener = (fn) => {
    listeners.push(fn);
    debug2(`Added listener, now ${listeners.length} listeners`);
  };
  const addPreProcessingListener = (fn) => {
    preProcessingListeners.push(fn);
    debug2(
      `Added pre-processing listener, now ${preProcessingListeners.length} listeners`
    );
  };
  const throwExceptionIf = (config, checks, message) => {
    const tests = Array.isArray(checks) ? checks : [checks];
    tests.forEach((test2) => {
      if (test2) {
        throw new Error(
          `Problem with log4js configuration: (${util2.inspect(config, {
            depth: 5
          })}) - ${message}`
        );
      }
    });
  };
  const configure2 = (candidate) => {
    debug2("New configuration to be validated: ", candidate);
    throwExceptionIf(candidate, not(anObject(candidate)), "must be an object.");
    debug2(`Calling pre-processing listeners (${preProcessingListeners.length})`);
    preProcessingListeners.forEach((listener) => listener(candidate));
    debug2("Configuration pre-processing finished.");
    debug2(`Calling configuration listeners (${listeners.length})`);
    listeners.forEach((listener) => listener(candidate));
    debug2("Configuration finished.");
  };
  configuration$1 = {
    configure: configure2,
    addListener,
    addPreProcessingListener,
    throwExceptionIf,
    anObject,
    anInteger,
    validIdentifier,
    not
  };
  return configuration$1;
}
var lib$2$1 = { exports: {} };
var hasRequiredLib$2$1;
function requireLib$2$1() {
  if (hasRequiredLib$2$1) return lib$2$1.exports;
  hasRequiredLib$2$1 = 1;
  (function(module) {
    function padWithZeros(vNumber, width) {
      var numAsString = vNumber.toString();
      while (numAsString.length < width) {
        numAsString = "0" + numAsString;
      }
      return numAsString;
    }
    function addZero(vNumber) {
      return padWithZeros(vNumber, 2);
    }
    function offset(timezoneOffset) {
      var os = Math.abs(timezoneOffset);
      var h = String(Math.floor(os / 60));
      var m = String(os % 60);
      h = ("0" + h).slice(-2);
      m = ("0" + m).slice(-2);
      return timezoneOffset === 0 ? "Z" : (timezoneOffset < 0 ? "+" : "-") + h + ":" + m;
    }
    function asString(format, date) {
      if (typeof format !== "string") {
        date = format;
        format = module.exports.ISO8601_FORMAT;
      }
      if (!date) {
        date = module.exports.now();
      }
      var vDay = addZero(date.getDate());
      var vMonth = addZero(date.getMonth() + 1);
      var vYearLong = addZero(date.getFullYear());
      var vYearShort = addZero(vYearLong.substring(2, 4));
      var vYear = format.indexOf("yyyy") > -1 ? vYearLong : vYearShort;
      var vHour = addZero(date.getHours());
      var vMinute = addZero(date.getMinutes());
      var vSecond = addZero(date.getSeconds());
      var vMillisecond = padWithZeros(date.getMilliseconds(), 3);
      var vTimeZone = offset(date.getTimezoneOffset());
      var formatted = format.replace(/dd/g, vDay).replace(/MM/g, vMonth).replace(/y{1,4}/g, vYear).replace(/hh/g, vHour).replace(/mm/g, vMinute).replace(/ss/g, vSecond).replace(/SSS/g, vMillisecond).replace(/O/g, vTimeZone);
      return formatted;
    }
    function setDatePart(date, part, value, local) {
      date["set" + (local ? "" : "UTC") + part](value);
    }
    function extractDateParts(pattern, str, missingValuesDate) {
      var local = pattern.indexOf("O") < 0;
      var monthOverflow = false;
      var matchers = [
        {
          pattern: /y{1,4}/,
          regexp: "\\d{1,4}",
          fn: function(date2, value) {
            setDatePart(date2, "FullYear", value, local);
          }
        },
        {
          pattern: /MM/,
          regexp: "\\d{1,2}",
          fn: function(date2, value) {
            setDatePart(date2, "Month", value - 1, local);
            if (date2.getMonth() !== value - 1) {
              monthOverflow = true;
            }
          }
        },
        {
          pattern: /dd/,
          regexp: "\\d{1,2}",
          fn: function(date2, value) {
            if (monthOverflow) {
              setDatePart(date2, "Month", date2.getMonth() - 1, local);
            }
            setDatePart(date2, "Date", value, local);
          }
        },
        {
          pattern: /hh/,
          regexp: "\\d{1,2}",
          fn: function(date2, value) {
            setDatePart(date2, "Hours", value, local);
          }
        },
        {
          pattern: /mm/,
          regexp: "\\d\\d",
          fn: function(date2, value) {
            setDatePart(date2, "Minutes", value, local);
          }
        },
        {
          pattern: /ss/,
          regexp: "\\d\\d",
          fn: function(date2, value) {
            setDatePart(date2, "Seconds", value, local);
          }
        },
        {
          pattern: /SSS/,
          regexp: "\\d\\d\\d",
          fn: function(date2, value) {
            setDatePart(date2, "Milliseconds", value, local);
          }
        },
        {
          pattern: /O/,
          regexp: "[+-]\\d{1,2}:?\\d{2}?|Z",
          fn: function(date2, value) {
            if (value === "Z") {
              value = 0;
            } else {
              value = value.replace(":", "");
            }
            var offset2 = Math.abs(value);
            var timezoneOffset = (value > 0 ? -1 : 1) * (offset2 % 100 + Math.floor(offset2 / 100) * 60);
            date2.setUTCMinutes(date2.getUTCMinutes() + timezoneOffset);
          }
        }
      ];
      var parsedPattern = matchers.reduce(
        function(p, m) {
          if (m.pattern.test(p.regexp)) {
            m.index = p.regexp.match(m.pattern).index;
            p.regexp = p.regexp.replace(m.pattern, "(" + m.regexp + ")");
          } else {
            m.index = -1;
          }
          return p;
        },
        { regexp: pattern, index: [] }
      );
      var dateFns = matchers.filter(function(m) {
        return m.index > -1;
      });
      dateFns.sort(function(a, b) {
        return a.index - b.index;
      });
      var matcher = new RegExp(parsedPattern.regexp);
      var matches = matcher.exec(str);
      if (matches) {
        var date = missingValuesDate || module.exports.now();
        dateFns.forEach(function(f, i) {
          f.fn(date, matches[i + 1]);
        });
        return date;
      }
      throw new Error(
        "String '" + str + "' could not be parsed as '" + pattern + "'"
      );
    }
    function parse2(pattern, str, missingValuesDate) {
      if (!pattern) {
        throw new Error("pattern must be supplied");
      }
      return extractDateParts(pattern, str, missingValuesDate);
    }
    function now2() {
      return /* @__PURE__ */ new Date();
    }
    module.exports = asString;
    module.exports.asString = asString;
    module.exports.parse = parse2;
    module.exports.now = now2;
    module.exports.ISO8601_FORMAT = "yyyy-MM-ddThh:mm:ss.SSS";
    module.exports.ISO8601_WITH_TZ_OFFSET_FORMAT = "yyyy-MM-ddThh:mm:ss.SSSO";
    module.exports.DATETIME_FORMAT = "dd MM yyyy hh:mm:ss.SSS";
    module.exports.ABSOLUTETIME_FORMAT = "hh:mm:ss.SSS";
  })(lib$2$1);
  return lib$2$1.exports;
}
var layouts;
var hasRequiredLayouts;
function requireLayouts() {
  if (hasRequiredLayouts) return layouts;
  hasRequiredLayouts = 1;
  const dateFormat = requireLib$2$1();
  const os = require$$1$1;
  const util2 = require$$0$5;
  const path2 = require$$1$3;
  const url = require$$0$6;
  const debug2 = requireBrowser$4()("log4js:layouts");
  const styles2 = {
    // styles
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    // grayscale
    white: [37, 39],
    grey: [90, 39],
    black: [90, 39],
    // colors
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [91, 39],
    yellow: [33, 39]
  };
  function colorizeStart(style) {
    return style ? `\x1B[${styles2[style][0]}m` : "";
  }
  function colorizeEnd(style) {
    return style ? `\x1B[${styles2[style][1]}m` : "";
  }
  function colorize(str, style) {
    return colorizeStart(style) + str + colorizeEnd(style);
  }
  function timestampLevelAndCategory(loggingEvent, colour) {
    return colorize(
      util2.format(
        "[%s] [%s] %s - ",
        dateFormat.asString(loggingEvent.startTime),
        loggingEvent.level.toString(),
        loggingEvent.categoryName
      ),
      colour
    );
  }
  function basicLayout(loggingEvent) {
    return timestampLevelAndCategory(loggingEvent) + util2.format(...loggingEvent.data);
  }
  function colouredLayout(loggingEvent) {
    return timestampLevelAndCategory(loggingEvent, loggingEvent.level.colour) + util2.format(...loggingEvent.data);
  }
  function messagePassThroughLayout(loggingEvent) {
    return util2.format(...loggingEvent.data);
  }
  function dummyLayout(loggingEvent) {
    return loggingEvent.data[0];
  }
  function patternLayout(pattern, tokens) {
    const TTCC_CONVERSION_PATTERN = "%r %p %c - %m%n";
    const regex2 = /%(-?[0-9]+)?(\.?-?[0-9]+)?([[\]cdhmnprzxXyflosCMAF%])(\{([^}]+)\})?|([^%]+)/;
    pattern = pattern || TTCC_CONVERSION_PATTERN;
    function categoryName(loggingEvent, specifier) {
      let loggerName = loggingEvent.categoryName;
      if (specifier) {
        const precision = parseInt(specifier, 10);
        const loggerNameBits = loggerName.split(".");
        if (precision < loggerNameBits.length) {
          loggerName = loggerNameBits.slice(loggerNameBits.length - precision).join(".");
        }
      }
      return loggerName;
    }
    function formatAsDate(loggingEvent, specifier) {
      let format = dateFormat.ISO8601_FORMAT;
      if (specifier) {
        format = specifier;
        switch (format) {
          case "ISO8601":
          case "ISO8601_FORMAT":
            format = dateFormat.ISO8601_FORMAT;
            break;
          case "ISO8601_WITH_TZ_OFFSET":
          case "ISO8601_WITH_TZ_OFFSET_FORMAT":
            format = dateFormat.ISO8601_WITH_TZ_OFFSET_FORMAT;
            break;
          case "ABSOLUTE":
            process.emitWarning(
              "Pattern %d{ABSOLUTE} is deprecated in favor of %d{ABSOLUTETIME}. Please use %d{ABSOLUTETIME} instead.",
              "DeprecationWarning",
              "log4js-node-DEP0003"
            );
            debug2(
              "[log4js-node-DEP0003]",
              "DEPRECATION: Pattern %d{ABSOLUTE} is deprecated and replaced by %d{ABSOLUTETIME}."
            );
          // falls through
          case "ABSOLUTETIME":
          case "ABSOLUTETIME_FORMAT":
            format = dateFormat.ABSOLUTETIME_FORMAT;
            break;
          case "DATE":
            process.emitWarning(
              "Pattern %d{DATE} is deprecated due to the confusion it causes when used. Please use %d{DATETIME} instead.",
              "DeprecationWarning",
              "log4js-node-DEP0004"
            );
            debug2(
              "[log4js-node-DEP0004]",
              "DEPRECATION: Pattern %d{DATE} is deprecated and replaced by %d{DATETIME}."
            );
          // falls through
          case "DATETIME":
          case "DATETIME_FORMAT":
            format = dateFormat.DATETIME_FORMAT;
            break;
        }
      }
      return dateFormat.asString(format, loggingEvent.startTime);
    }
    function hostname() {
      return os.hostname().toString();
    }
    function formatMessage(loggingEvent, specifier) {
      let dataSlice = loggingEvent.data;
      if (specifier) {
        const [lowerBound, upperBound] = specifier.split(",");
        dataSlice = dataSlice.slice(lowerBound, upperBound);
      }
      return util2.format(...dataSlice);
    }
    function endOfLine() {
      return os.EOL;
    }
    function logLevel(loggingEvent) {
      return loggingEvent.level.toString();
    }
    function startTime(loggingEvent) {
      return dateFormat.asString("hh:mm:ss", loggingEvent.startTime);
    }
    function startColour(loggingEvent) {
      return colorizeStart(loggingEvent.level.colour);
    }
    function endColour(loggingEvent) {
      return colorizeEnd(loggingEvent.level.colour);
    }
    function percent() {
      return "%";
    }
    function pid(loggingEvent) {
      return loggingEvent && loggingEvent.pid ? loggingEvent.pid.toString() : process.pid.toString();
    }
    function clusterInfo() {
      return pid();
    }
    function userDefined(loggingEvent, specifier) {
      if (typeof tokens[specifier] !== "undefined") {
        return typeof tokens[specifier] === "function" ? tokens[specifier](loggingEvent) : tokens[specifier];
      }
      return null;
    }
    function contextDefined(loggingEvent, specifier) {
      const resolver = loggingEvent.context[specifier];
      if (typeof resolver !== "undefined") {
        return typeof resolver === "function" ? resolver(loggingEvent) : resolver;
      }
      return null;
    }
    function fileName(loggingEvent, specifier) {
      let filename = loggingEvent.fileName || "";
      const convertFileURLToPath = function(filepath) {
        const urlPrefix = "file://";
        if (filepath.startsWith(urlPrefix)) {
          if (typeof url.fileURLToPath === "function") {
            filepath = url.fileURLToPath(filepath);
          } else {
            filepath = path2.normalize(
              filepath.replace(new RegExp(`^${urlPrefix}`), "")
            );
            if (process.platform === "win32") {
              if (filepath.startsWith("\\")) {
                filepath = filepath.slice(1);
              } else {
                filepath = path2.sep + path2.sep + filepath;
              }
            }
          }
        }
        return filepath;
      };
      filename = convertFileURLToPath(filename);
      if (specifier) {
        const fileDepth = parseInt(specifier, 10);
        const fileList = filename.split(path2.sep);
        if (fileList.length > fileDepth) {
          filename = fileList.slice(-fileDepth).join(path2.sep);
        }
      }
      return filename;
    }
    function lineNumber(loggingEvent) {
      return loggingEvent.lineNumber ? `${loggingEvent.lineNumber}` : "";
    }
    function columnNumber(loggingEvent) {
      return loggingEvent.columnNumber ? `${loggingEvent.columnNumber}` : "";
    }
    function callStack(loggingEvent) {
      return loggingEvent.callStack || "";
    }
    function className(loggingEvent) {
      return loggingEvent.className || "";
    }
    function functionName(loggingEvent) {
      return loggingEvent.functionName || "";
    }
    function functionAlias(loggingEvent) {
      return loggingEvent.functionAlias || "";
    }
    function callerName(loggingEvent) {
      return loggingEvent.callerName || "";
    }
    const replacers = {
      c: categoryName,
      d: formatAsDate,
      h: hostname,
      m: formatMessage,
      n: endOfLine,
      p: logLevel,
      r: startTime,
      "[": startColour,
      "]": endColour,
      y: clusterInfo,
      z: pid,
      "%": percent,
      x: userDefined,
      X: contextDefined,
      f: fileName,
      l: lineNumber,
      o: columnNumber,
      s: callStack,
      C: className,
      M: functionName,
      A: functionAlias,
      F: callerName
    };
    function replaceToken(conversionCharacter, loggingEvent, specifier) {
      return replacers[conversionCharacter](loggingEvent, specifier);
    }
    function truncate(truncation, toTruncate) {
      let len;
      if (truncation) {
        len = parseInt(truncation.slice(1), 10);
        return len > 0 ? toTruncate.slice(0, len) : toTruncate.slice(len);
      }
      return toTruncate;
    }
    function pad(padding, toPad) {
      let len;
      if (padding) {
        if (padding.charAt(0) === "-") {
          len = parseInt(padding.slice(1), 10);
          while (toPad.length < len) {
            toPad += " ";
          }
        } else {
          len = parseInt(padding, 10);
          while (toPad.length < len) {
            toPad = ` ${toPad}`;
          }
        }
      }
      return toPad;
    }
    function truncateAndPad(toTruncAndPad, truncation, padding) {
      let replacement = toTruncAndPad;
      replacement = truncate(truncation, replacement);
      replacement = pad(padding, replacement);
      return replacement;
    }
    return function(loggingEvent) {
      let formattedString = "";
      let result;
      let searchString = pattern;
      while ((result = regex2.exec(searchString)) !== null) {
        const padding = result[1];
        const truncation = result[2];
        const conversionCharacter = result[3];
        const specifier = result[5];
        const text = result[6];
        if (text) {
          formattedString += text.toString();
        } else {
          const replacement = replaceToken(
            conversionCharacter,
            loggingEvent,
            specifier
          );
          formattedString += truncateAndPad(replacement, truncation, padding);
        }
        searchString = searchString.slice(result.index + result[0].length);
      }
      return formattedString;
    };
  }
  const layoutMakers = {
    messagePassThrough() {
      return messagePassThroughLayout;
    },
    basic() {
      return basicLayout;
    },
    colored() {
      return colouredLayout;
    },
    coloured() {
      return colouredLayout;
    },
    pattern(config) {
      return patternLayout(config && config.pattern, config && config.tokens);
    },
    dummy() {
      return dummyLayout;
    }
  };
  layouts = {
    basicLayout,
    messagePassThroughLayout,
    patternLayout,
    colouredLayout,
    coloredLayout: colouredLayout,
    dummyLayout,
    addLayout(name, serializerGenerator) {
      layoutMakers[name] = serializerGenerator;
    },
    layout(name, config) {
      return layoutMakers[name] && layoutMakers[name](config);
    }
  };
  return layouts;
}
var levels;
var hasRequiredLevels;
function requireLevels() {
  if (hasRequiredLevels) return levels;
  hasRequiredLevels = 1;
  const configuration2 = requireConfiguration$1();
  const validColours = [
    "white",
    "grey",
    "black",
    "blue",
    "cyan",
    "green",
    "magenta",
    "red",
    "yellow"
  ];
  class Level {
    constructor(level2, levelStr, colour) {
      this.level = level2;
      this.levelStr = levelStr;
      this.colour = colour;
    }
    toString() {
      return this.levelStr;
    }
    /**
     * converts given String to corresponding Level
     * @param {(Level|string)} sArg -- String value of Level OR Log4js.Level
     * @param {Level} [defaultLevel] -- default Level, if no String representation
     * @return {Level}
     */
    static getLevel(sArg, defaultLevel) {
      if (!sArg) {
        return defaultLevel;
      }
      if (sArg instanceof Level) {
        return sArg;
      }
      if (sArg instanceof Object && sArg.levelStr) {
        sArg = sArg.levelStr;
      }
      return Level[sArg.toString().toUpperCase()] || defaultLevel;
    }
    static addLevels(customLevels) {
      if (customLevels) {
        const levels2 = Object.keys(customLevels);
        levels2.forEach((l) => {
          const levelStr = l.toUpperCase();
          Level[levelStr] = new Level(
            customLevels[l].value,
            levelStr,
            customLevels[l].colour
          );
          const existingLevelIndex = Level.levels.findIndex(
            (lvl) => lvl.levelStr === levelStr
          );
          if (existingLevelIndex > -1) {
            Level.levels[existingLevelIndex] = Level[levelStr];
          } else {
            Level.levels.push(Level[levelStr]);
          }
        });
        Level.levels.sort((a, b) => a.level - b.level);
      }
    }
    isLessThanOrEqualTo(otherLevel) {
      if (typeof otherLevel === "string") {
        otherLevel = Level.getLevel(otherLevel);
      }
      return this.level <= otherLevel.level;
    }
    isGreaterThanOrEqualTo(otherLevel) {
      if (typeof otherLevel === "string") {
        otherLevel = Level.getLevel(otherLevel);
      }
      return this.level >= otherLevel.level;
    }
    isEqualTo(otherLevel) {
      if (typeof otherLevel === "string") {
        otherLevel = Level.getLevel(otherLevel);
      }
      return this.level === otherLevel.level;
    }
  }
  Level.levels = [];
  Level.addLevels({
    ALL: { value: Number.MIN_VALUE, colour: "grey" },
    TRACE: { value: 5e3, colour: "blue" },
    DEBUG: { value: 1e4, colour: "cyan" },
    INFO: { value: 2e4, colour: "green" },
    WARN: { value: 3e4, colour: "yellow" },
    ERROR: { value: 4e4, colour: "red" },
    FATAL: { value: 5e4, colour: "magenta" },
    MARK: { value: 9007199254740992, colour: "grey" },
    // 2^53
    OFF: { value: Number.MAX_VALUE, colour: "grey" }
  });
  configuration2.addListener((config) => {
    const levelConfig = config.levels;
    if (levelConfig) {
      configuration2.throwExceptionIf(
        config,
        configuration2.not(configuration2.anObject(levelConfig)),
        "levels must be an object"
      );
      const newLevels = Object.keys(levelConfig);
      newLevels.forEach((l) => {
        configuration2.throwExceptionIf(
          config,
          configuration2.not(configuration2.validIdentifier(l)),
          `level name "${l}" is not a valid identifier (must start with a letter, only contain A-Z,a-z,0-9,_)`
        );
        configuration2.throwExceptionIf(
          config,
          configuration2.not(configuration2.anObject(levelConfig[l])),
          `level "${l}" must be an object`
        );
        configuration2.throwExceptionIf(
          config,
          configuration2.not(levelConfig[l].value),
          `level "${l}" must have a 'value' property`
        );
        configuration2.throwExceptionIf(
          config,
          configuration2.not(configuration2.anInteger(levelConfig[l].value)),
          `level "${l}".value must have an integer value`
        );
        configuration2.throwExceptionIf(
          config,
          configuration2.not(levelConfig[l].colour),
          `level "${l}" must have a 'colour' property`
        );
        configuration2.throwExceptionIf(
          config,
          configuration2.not(validColours.indexOf(levelConfig[l].colour) > -1),
          `level "${l}".colour must be one of ${validColours.join(", ")}`
        );
      });
    }
  });
  configuration2.addListener((config) => {
    Level.addLevels(config.levels);
  });
  levels = Level;
  return levels;
}
function commonjsRequire$2(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var appenders = { exports: {} };
var cjs = {};
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs;
  hasRequiredCjs = 1;
  const { parse: $parse, stringify: $stringify } = JSON;
  const { keys } = Object;
  const Primitive = String;
  const primitive = "string";
  const ignore = {};
  const object = "object";
  const noop2 = (_, value) => value;
  const primitives = (value) => value instanceof Primitive ? Primitive(value) : value;
  const Primitives = (_, value) => typeof value === primitive ? new Primitive(value) : value;
  const revive = (input, parsed, output2, $) => {
    const lazy = [];
    for (let ke = keys(output2), { length } = ke, y = 0; y < length; y++) {
      const k = ke[y];
      const value = output2[k];
      if (value instanceof Primitive) {
        const tmp = input[value];
        if (typeof tmp === object && !parsed.has(tmp)) {
          parsed.add(tmp);
          output2[k] = ignore;
          lazy.push({ k, a: [input, parsed, tmp, $] });
        } else
          output2[k] = $.call(output2, k, tmp);
      } else if (output2[k] !== ignore)
        output2[k] = $.call(output2, k, value);
    }
    for (let { length } = lazy, i = 0; i < length; i++) {
      const { k, a } = lazy[i];
      output2[k] = $.call(output2, k, revive.apply(null, a));
    }
    return output2;
  };
  const set = (known, input, value) => {
    const index2 = Primitive(input.push(value) - 1);
    known.set(value, index2);
    return index2;
  };
  const parse2 = (text, reviver) => {
    const input = $parse(text, Primitives).map(primitives);
    const value = input[0];
    const $ = reviver || noop2;
    const tmp = typeof value === object && value ? revive(input, /* @__PURE__ */ new Set(), value, $) : value;
    return $.call({ "": tmp }, "", tmp);
  };
  cjs.parse = parse2;
  const stringify2 = (value, replacer, space) => {
    const $ = replacer && typeof replacer === object ? (k, v) => k === "" || -1 < replacer.indexOf(k) ? v : void 0 : replacer || noop2;
    const known = /* @__PURE__ */ new Map();
    const input = [];
    const output2 = [];
    let i = +set(known, input, $.call({ "": value }, "", value));
    let firstRun = !i;
    while (i < input.length) {
      firstRun = true;
      output2[i] = $stringify(input[i++], replace, space);
    }
    return "[" + output2.join(",") + "]";
    function replace(key, value2) {
      if (firstRun) {
        firstRun = !firstRun;
        return value2;
      }
      const after = $.call(this, key, value2);
      switch (typeof after) {
        case object:
          if (after === null) return after;
        case primitive:
          return known.get(after) || set(known, input, after);
      }
      return after;
    }
  };
  cjs.stringify = stringify2;
  const toJSON2 = (value) => $parse(stringify2(value));
  cjs.toJSON = toJSON2;
  const fromJSON = (value) => parse2($stringify(value));
  cjs.fromJSON = fromJSON;
  return cjs;
}
var LoggingEvent_1;
var hasRequiredLoggingEvent;
function requireLoggingEvent() {
  if (hasRequiredLoggingEvent) return LoggingEvent_1;
  hasRequiredLoggingEvent = 1;
  const flatted = requireCjs();
  const levels2 = requireLevels();
  class SerDe {
    constructor() {
      const deserialise = {
        __LOG4JS_undefined__: void 0,
        __LOG4JS_NaN__: Number("abc"),
        __LOG4JS_Infinity__: 1 / 0,
        "__LOG4JS_-Infinity__": -1 / 0
      };
      this.deMap = deserialise;
      this.serMap = {};
      Object.keys(this.deMap).forEach((key) => {
        const value = this.deMap[key];
        this.serMap[value] = key;
      });
    }
    canSerialise(key) {
      if (typeof key === "string") return false;
      return key in this.serMap;
    }
    serialise(key) {
      if (this.canSerialise(key)) return this.serMap[key];
      return key;
    }
    canDeserialise(key) {
      return key in this.deMap;
    }
    deserialise(key) {
      if (this.canDeserialise(key)) return this.deMap[key];
      return key;
    }
  }
  const serde = new SerDe();
  class LoggingEvent {
    /**
     * Models a logging event.
     * @constructor
     * @param {string} categoryName name of category
     * @param {Log4js.Level} level level of message
     * @param {Array} data objects to log
     * @param {Error} [error]
     * @author Seth Chisamore
     */
    constructor(categoryName, level2, data2, context, location, error) {
      this.startTime = /* @__PURE__ */ new Date();
      this.categoryName = categoryName;
      this.data = data2;
      this.level = level2;
      this.context = Object.assign({}, context);
      this.pid = process.pid;
      this.error = error;
      if (typeof location !== "undefined") {
        if (!location || typeof location !== "object" || Array.isArray(location))
          throw new TypeError(
            "Invalid location type passed to LoggingEvent constructor"
          );
        this.constructor._getLocationKeys().forEach((key) => {
          if (typeof location[key] !== "undefined") this[key] = location[key];
        });
      }
    }
    /** @private */
    static _getLocationKeys() {
      return [
        "fileName",
        "lineNumber",
        "columnNumber",
        "callStack",
        "className",
        "functionName",
        "functionAlias",
        "callerName"
      ];
    }
    serialise() {
      return flatted.stringify(this, (key, value) => {
        if (value instanceof Error) {
          value = Object.assign(
            { message: value.message, stack: value.stack },
            value
          );
        }
        return serde.serialise(value);
      });
    }
    static deserialise(serialised) {
      let event;
      try {
        const rehydratedEvent = flatted.parse(serialised, (key, value) => {
          if (value && value.message && value.stack) {
            const fakeError = new Error(value);
            Object.keys(value).forEach((k) => {
              fakeError[k] = value[k];
            });
            value = fakeError;
          }
          return serde.deserialise(value);
        });
        this._getLocationKeys().forEach((key) => {
          if (typeof rehydratedEvent[key] !== "undefined") {
            if (!rehydratedEvent.location) rehydratedEvent.location = {};
            rehydratedEvent.location[key] = rehydratedEvent[key];
          }
        });
        event = new LoggingEvent(
          rehydratedEvent.categoryName,
          levels2.getLevel(rehydratedEvent.level.levelStr),
          rehydratedEvent.data,
          rehydratedEvent.context,
          rehydratedEvent.location,
          rehydratedEvent.error
        );
        event.startTime = new Date(rehydratedEvent.startTime);
        event.pid = rehydratedEvent.pid;
        if (rehydratedEvent.cluster) {
          event.cluster = rehydratedEvent.cluster;
        }
      } catch (e) {
        event = new LoggingEvent("log4js", levels2.ERROR, [
          "Unable to parse log:",
          serialised,
          "because: ",
          e
        ]);
      }
      return event;
    }
  }
  LoggingEvent_1 = LoggingEvent;
  return LoggingEvent_1;
}
var clustering;
var hasRequiredClustering;
function requireClustering() {
  if (hasRequiredClustering) return clustering;
  hasRequiredClustering = 1;
  const debug2 = requireBrowser$4()("log4js:clustering");
  const LoggingEvent = requireLoggingEvent();
  const configuration2 = requireConfiguration$1();
  let disabled = false;
  let cluster = null;
  try {
    cluster = require("cluster");
  } catch (e) {
    debug2("cluster module not present");
    disabled = true;
  }
  const listeners = [];
  let pm2 = false;
  let pm2InstanceVar = "NODE_APP_INSTANCE";
  const isPM2Master = () => pm2 && process.env[pm2InstanceVar] === "0";
  const isMaster = () => disabled || cluster && cluster.isMaster || isPM2Master();
  const sendToListeners = (logEvent) => {
    listeners.forEach((l) => l(logEvent));
  };
  const receiver = (worker, message) => {
    debug2("cluster message received from worker ", worker, ": ", message);
    if (worker.topic && worker.data) {
      message = worker;
      worker = void 0;
    }
    if (message && message.topic && message.topic === "log4js:message") {
      debug2("received message: ", message.data);
      const logEvent = LoggingEvent.deserialise(message.data);
      sendToListeners(logEvent);
    }
  };
  if (!disabled) {
    configuration2.addListener((config) => {
      listeners.length = 0;
      ({
        pm2,
        disableClustering: disabled,
        pm2InstanceVar = "NODE_APP_INSTANCE"
      } = config);
      debug2(`clustering disabled ? ${disabled}`);
      debug2(`cluster.isMaster ? ${cluster && cluster.isMaster}`);
      debug2(`pm2 enabled ? ${pm2}`);
      debug2(`pm2InstanceVar = ${pm2InstanceVar}`);
      debug2(`process.env[${pm2InstanceVar}] = ${process.env[pm2InstanceVar]}`);
      if (pm2) {
        process.removeListener("message", receiver);
      }
      if (cluster && cluster.removeListener) {
        cluster.removeListener("message", receiver);
      }
      if (disabled || config.disableClustering) {
        debug2("Not listening for cluster messages, because clustering disabled.");
      } else if (isPM2Master()) {
        debug2("listening for PM2 broadcast messages");
        process.on("message", receiver);
      } else if (cluster && cluster.isMaster) {
        debug2("listening for cluster messages");
        cluster.on("message", receiver);
      } else {
        debug2("not listening for messages, because we are not a master process");
      }
    });
  }
  clustering = {
    onlyOnMaster: (fn, notMaster) => isMaster() ? fn() : notMaster,
    isMaster,
    send: (msg) => {
      if (isMaster()) {
        sendToListeners(msg);
      } else {
        if (!pm2) {
          msg.cluster = {
            workerId: cluster.worker.id,
            worker: process.pid
          };
        }
        process.send({ topic: "log4js:message", data: msg.serialise() });
      }
    },
    onMessage: (listener) => {
      listeners.push(listener);
    }
  };
  return clustering;
}
var adapters$1 = {};
var hasRequiredAdapters;
function requireAdapters() {
  if (hasRequiredAdapters) return adapters$1;
  hasRequiredAdapters = 1;
  function maxFileSizeUnitTransform(maxLogSize) {
    if (typeof maxLogSize === "number" && Number.isInteger(maxLogSize)) {
      return maxLogSize;
    }
    const units = {
      K: 1024,
      M: 1024 * 1024,
      G: 1024 * 1024 * 1024
    };
    const validUnit = Object.keys(units);
    const unit = maxLogSize.slice(-1).toLocaleUpperCase();
    const value = maxLogSize.slice(0, -1).trim();
    if (validUnit.indexOf(unit) < 0 || !Number.isInteger(Number(value))) {
      throw Error(`maxLogSize: "${maxLogSize}" is invalid`);
    } else {
      return value * units[unit];
    }
  }
  function adapter(configAdapter, config) {
    const newConfig = Object.assign({}, config);
    Object.keys(configAdapter).forEach((key) => {
      if (newConfig[key]) {
        newConfig[key] = configAdapter[key](config[key]);
      }
    });
    return newConfig;
  }
  function fileAppenderAdapter(config) {
    const configAdapter = {
      maxLogSize: maxFileSizeUnitTransform
    };
    return adapter(configAdapter, config);
  }
  const adapters$1$1 = {
    dateFile: fileAppenderAdapter,
    file: fileAppenderAdapter,
    fileSync: fileAppenderAdapter
  };
  adapters$1.modifyConfig = (config) => adapters$1$1[config.type] ? adapters$1$1[config.type](config) : config;
  return adapters$1;
}
var console$1 = {};
var hasRequiredConsole;
function requireConsole() {
  if (hasRequiredConsole) return console$1;
  hasRequiredConsole = 1;
  const consoleLog = console.log.bind(console);
  function consoleAppender(layout, timezoneOffset) {
    return (loggingEvent) => {
      consoleLog(layout(loggingEvent, timezoneOffset));
    };
  }
  function configure2(config, layouts2) {
    let layout = layouts2.colouredLayout;
    if (config.layout) {
      layout = layouts2.layout(config.layout.type, config.layout);
    }
    return consoleAppender(layout, config.timezoneOffset);
  }
  console$1.configure = configure2;
  return console$1;
}
var stdout = {};
var hasRequiredStdout;
function requireStdout() {
  if (hasRequiredStdout) return stdout;
  hasRequiredStdout = 1;
  function stdoutAppender(layout, timezoneOffset) {
    return (loggingEvent) => {
      process.stdout.write(`${layout(loggingEvent, timezoneOffset)}
`);
    };
  }
  function configure2(config, layouts2) {
    let layout = layouts2.colouredLayout;
    if (config.layout) {
      layout = layouts2.layout(config.layout.type, config.layout);
    }
    return stdoutAppender(layout, config.timezoneOffset);
  }
  stdout.configure = configure2;
  return stdout;
}
var stderr = {};
var hasRequiredStderr;
function requireStderr() {
  if (hasRequiredStderr) return stderr;
  hasRequiredStderr = 1;
  function stderrAppender(layout, timezoneOffset) {
    return (loggingEvent) => {
      process.stderr.write(`${layout(loggingEvent, timezoneOffset)}
`);
    };
  }
  function configure2(config, layouts2) {
    let layout = layouts2.colouredLayout;
    if (config.layout) {
      layout = layouts2.layout(config.layout.type, config.layout);
    }
    return stderrAppender(layout, config.timezoneOffset);
  }
  stderr.configure = configure2;
  return stderr;
}
var logLevelFilter = {};
var hasRequiredLogLevelFilter;
function requireLogLevelFilter() {
  if (hasRequiredLogLevelFilter) return logLevelFilter;
  hasRequiredLogLevelFilter = 1;
  function logLevelFilter$1(minLevelString, maxLevelString, appender, levels2) {
    const minLevel = levels2.getLevel(minLevelString);
    const maxLevel = levels2.getLevel(maxLevelString, levels2.FATAL);
    return (logEvent) => {
      const eventLevel = logEvent.level;
      if (minLevel.isLessThanOrEqualTo(eventLevel) && maxLevel.isGreaterThanOrEqualTo(eventLevel)) {
        appender(logEvent);
      }
    };
  }
  function configure2(config, layouts2, findAppender, levels2) {
    const appender = findAppender(config.appender);
    return logLevelFilter$1(config.level, config.maxLevel, appender, levels2);
  }
  logLevelFilter.configure = configure2;
  return logLevelFilter;
}
var categoryFilter = {};
var hasRequiredCategoryFilter;
function requireCategoryFilter() {
  if (hasRequiredCategoryFilter) return categoryFilter;
  hasRequiredCategoryFilter = 1;
  const debug2 = requireBrowser$4()("log4js:categoryFilter");
  function categoryFilter$1(excludes, appender) {
    if (typeof excludes === "string") excludes = [excludes];
    return (logEvent) => {
      debug2(`Checking ${logEvent.categoryName} against ${excludes}`);
      if (excludes.indexOf(logEvent.categoryName) === -1) {
        debug2("Not excluded, sending to appender");
        appender(logEvent);
      }
    };
  }
  function configure2(config, layouts2, findAppender) {
    const appender = findAppender(config.appender);
    return categoryFilter$1(config.exclude, appender);
  }
  categoryFilter.configure = configure2;
  return categoryFilter;
}
var noLogFilter = {};
var hasRequiredNoLogFilter;
function requireNoLogFilter() {
  if (hasRequiredNoLogFilter) return noLogFilter;
  hasRequiredNoLogFilter = 1;
  const debug2 = requireBrowser$4()("log4js:noLogFilter");
  function removeNullOrEmptyRegexp(regexp) {
    const filtered = regexp.filter((el) => el != null && el !== "");
    return filtered;
  }
  function noLogFilter$1(filters, appender) {
    return (logEvent) => {
      debug2(`Checking data: ${logEvent.data} against filters: ${filters}`);
      if (typeof filters === "string") {
        filters = [filters];
      }
      filters = removeNullOrEmptyRegexp(filters);
      const regex2 = new RegExp(filters.join("|"), "i");
      if (filters.length === 0 || logEvent.data.findIndex((value) => regex2.test(value)) < 0) {
        debug2("Not excluded, sending to appender");
        appender(logEvent);
      }
    };
  }
  function configure2(config, layouts2, findAppender) {
    const appender = findAppender(config.appender);
    return noLogFilter$1(config.exclude, appender);
  }
  noLogFilter.configure = configure2;
  return noLogFilter;
}
var file$1 = {};
var lib$1$2 = { exports: {} };
var fs = {};
var universalify = {};
var hasRequiredUniversalify;
function requireUniversalify() {
  if (hasRequiredUniversalify) return universalify;
  hasRequiredUniversalify = 1;
  universalify.fromCallback = function(fn) {
    return Object.defineProperty(function() {
      if (typeof arguments[arguments.length - 1] === "function") fn.apply(this, arguments);
      else {
        return new Promise((resolve, reject) => {
          arguments[arguments.length] = (err, res) => {
            if (err) return reject(err);
            resolve(res);
          };
          arguments.length++;
          fn.apply(this, arguments);
        });
      }
    }, "name", { value: fn.name });
  };
  universalify.fromPromise = function(fn) {
    return Object.defineProperty(function() {
      const cb = arguments[arguments.length - 1];
      if (typeof cb !== "function") return fn.apply(this, arguments);
      else fn.apply(this, arguments).then((r) => cb(null, r), cb);
    }, "name", { value: fn.name });
  };
  return universalify;
}
var polyfills;
var hasRequiredPolyfills;
function requirePolyfills() {
  if (hasRequiredPolyfills) return polyfills;
  hasRequiredPolyfills = 1;
  var constants2 = require$$0$1$1;
  var origCwd = process.cwd;
  var cwd = null;
  var platform2 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    if (!cwd)
      cwd = origCwd.call(process);
    return cwd;
  };
  try {
    process.cwd();
  } catch (er) {
  }
  if (typeof process.chdir === "function") {
    var chdir = process.chdir;
    process.chdir = function(d) {
      cwd = null;
      chdir.call(process, d);
    };
    if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
  }
  polyfills = patch;
  function patch(fs2) {
    if (constants2.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      patchLchmod(fs2);
    }
    if (!fs2.lutimes) {
      patchLutimes(fs2);
    }
    fs2.chown = chownFix(fs2.chown);
    fs2.fchown = chownFix(fs2.fchown);
    fs2.lchown = chownFix(fs2.lchown);
    fs2.chmod = chmodFix(fs2.chmod);
    fs2.fchmod = chmodFix(fs2.fchmod);
    fs2.lchmod = chmodFix(fs2.lchmod);
    fs2.chownSync = chownFixSync(fs2.chownSync);
    fs2.fchownSync = chownFixSync(fs2.fchownSync);
    fs2.lchownSync = chownFixSync(fs2.lchownSync);
    fs2.chmodSync = chmodFixSync(fs2.chmodSync);
    fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
    fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
    fs2.stat = statFix(fs2.stat);
    fs2.fstat = statFix(fs2.fstat);
    fs2.lstat = statFix(fs2.lstat);
    fs2.statSync = statFixSync(fs2.statSync);
    fs2.fstatSync = statFixSync(fs2.fstatSync);
    fs2.lstatSync = statFixSync(fs2.lstatSync);
    if (fs2.chmod && !fs2.lchmod) {
      fs2.lchmod = function(path2, mode2, cb) {
        if (cb) process.nextTick(cb);
      };
      fs2.lchmodSync = function() {
      };
    }
    if (fs2.chown && !fs2.lchown) {
      fs2.lchown = function(path2, uid, gid, cb) {
        if (cb) process.nextTick(cb);
      };
      fs2.lchownSync = function() {
      };
    }
    if (platform2 === "win32") {
      fs2.rename = typeof fs2.rename !== "function" ? fs2.rename : function(fs$rename) {
        function rename(from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
              setTimeout(function() {
                fs2.stat(to, function(stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff);
              if (backoff < 100)
                backoff += 10;
              return;
            }
            if (cb) cb(er);
          });
        }
        if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
        return rename;
      }(fs2.rename);
    }
    fs2.read = typeof fs2.read !== "function" ? fs2.read : function(fs$read) {
      function read(fd, buffer2, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ === "function") {
          var eagCounter = 0;
          callback = function(er, _, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              return fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
            }
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
      }
      if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
      return read;
    }(fs2.read);
    fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : /* @__PURE__ */ function(fs$readSync) {
      return function(fd, buffer2, offset, length, position) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs2, fd, buffer2, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
        }
      };
    }(fs2.readSync);
    function patchLchmod(fs3) {
      fs3.lchmod = function(path2, mode2, callback) {
        fs3.open(
          path2,
          constants2.O_WRONLY | constants2.O_SYMLINK,
          mode2,
          function(err, fd) {
            if (err) {
              if (callback) callback(err);
              return;
            }
            fs3.fchmod(fd, mode2, function(err2) {
              fs3.close(fd, function(err22) {
                if (callback) callback(err2 || err22);
              });
            });
          }
        );
      };
      fs3.lchmodSync = function(path2, mode2) {
        var fd = fs3.openSync(path2, constants2.O_WRONLY | constants2.O_SYMLINK, mode2);
        var threw = true;
        var ret;
        try {
          ret = fs3.fchmodSync(fd, mode2);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs3.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs3.closeSync(fd);
          }
        }
        return ret;
      };
    }
    function patchLutimes(fs3) {
      if (constants2.hasOwnProperty("O_SYMLINK") && fs3.futimes) {
        fs3.lutimes = function(path2, at, mt, cb) {
          fs3.open(path2, constants2.O_SYMLINK, function(er, fd) {
            if (er) {
              if (cb) cb(er);
              return;
            }
            fs3.futimes(fd, at, mt, function(er2) {
              fs3.close(fd, function(er22) {
                if (cb) cb(er2 || er22);
              });
            });
          });
        };
        fs3.lutimesSync = function(path2, at, mt) {
          var fd = fs3.openSync(path2, constants2.O_SYMLINK);
          var ret;
          var threw = true;
          try {
            ret = fs3.futimesSync(fd, at, mt);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs3.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs3.closeSync(fd);
            }
          }
          return ret;
        };
      } else if (fs3.futimes) {
        fs3.lutimes = function(_a, _b, _c, cb) {
          if (cb) process.nextTick(cb);
        };
        fs3.lutimesSync = function() {
        };
      }
    }
    function chmodFix(orig) {
      if (!orig) return orig;
      return function(target, mode2, cb) {
        return orig.call(fs2, target, mode2, function(er) {
          if (chownErOk(er)) er = null;
          if (cb) cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      if (!orig) return orig;
      return function(target, mode2) {
        try {
          return orig.call(fs2, target, mode2);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    function chownFix(orig) {
      if (!orig) return orig;
      return function(target, uid, gid, cb) {
        return orig.call(fs2, target, uid, gid, function(er) {
          if (chownErOk(er)) er = null;
          if (cb) cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      if (!orig) return orig;
      return function(target, uid, gid) {
        try {
          return orig.call(fs2, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    function statFix(orig) {
      if (!orig) return orig;
      return function(target, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        function callback(er, stats) {
          if (stats) {
            if (stats.uid < 0) stats.uid += 4294967296;
            if (stats.gid < 0) stats.gid += 4294967296;
          }
          if (cb) cb.apply(this, arguments);
        }
        return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
      };
    }
    function statFixSync(orig) {
      if (!orig) return orig;
      return function(target, options) {
        var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
        if (stats) {
          if (stats.uid < 0) stats.uid += 4294967296;
          if (stats.gid < 0) stats.gid += 4294967296;
        }
        return stats;
      };
    }
    function chownErOk(er) {
      if (!er)
        return true;
      if (er.code === "ENOSYS")
        return true;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true;
      }
      return false;
    }
  }
  return polyfills;
}
var legacyStreams;
var hasRequiredLegacyStreams;
function requireLegacyStreams() {
  if (hasRequiredLegacyStreams) return legacyStreams;
  hasRequiredLegacyStreams = 1;
  var Stream = stream.Stream;
  legacyStreams = legacy2;
  function legacy2(fs2) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path2, options) {
      if (!(this instanceof ReadStream)) return new ReadStream(path2, options);
      Stream.call(this);
      var self2 = this;
      this.path = path2;
      this.fd = null;
      this.readable = true;
      this.paused = false;
      this.flags = "r";
      this.mode = 438;
      this.bufferSize = 64 * 1024;
      options = options || {};
      var keys = Object.keys(options);
      for (var index2 = 0, length = keys.length; index2 < length; index2++) {
        var key = keys[index2];
        this[key] = options[key];
      }
      if (this.encoding) this.setEncoding(this.encoding);
      if (this.start !== void 0) {
        if ("number" !== typeof this.start) {
          throw TypeError("start must be a Number");
        }
        if (this.end === void 0) {
          this.end = Infinity;
        } else if ("number" !== typeof this.end) {
          throw TypeError("end must be a Number");
        }
        if (this.start > this.end) {
          throw new Error("start must be <= end");
        }
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs2.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err);
          self2.readable = false;
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2._read();
      });
    }
    function WriteStream(path2, options) {
      if (!(this instanceof WriteStream)) return new WriteStream(path2, options);
      Stream.call(this);
      this.path = path2;
      this.fd = null;
      this.writable = true;
      this.flags = "w";
      this.encoding = "binary";
      this.mode = 438;
      this.bytesWritten = 0;
      options = options || {};
      var keys = Object.keys(options);
      for (var index2 = 0, length = keys.length; index2 < length; index2++) {
        var key = keys[index2];
        this[key] = options[key];
      }
      if (this.start !== void 0) {
        if ("number" !== typeof this.start) {
          throw TypeError("start must be a Number");
        }
        if (this.start < 0) {
          throw new Error("start must be >= zero");
        }
        this.pos = this.start;
      }
      this.busy = false;
      this._queue = [];
      if (this.fd === null) {
        this._open = fs2.open;
        this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
        this.flush();
      }
    }
  }
  return legacyStreams;
}
var clone_1;
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone) return clone_1;
  hasRequiredClone = 1;
  clone_1 = clone;
  var getPrototypeOf2 = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
  function clone(obj) {
    if (obj === null || typeof obj !== "object")
      return obj;
    if (obj instanceof Object)
      var copy2 = { __proto__: getPrototypeOf2(obj) };
    else
      var copy2 = /* @__PURE__ */ Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
      Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy2;
  }
  return clone_1;
}
var gracefulFs;
var hasRequiredGracefulFs;
function requireGracefulFs() {
  if (hasRequiredGracefulFs) return gracefulFs;
  hasRequiredGracefulFs = 1;
  var fs2 = require$$1$2;
  var polyfills2 = requirePolyfills();
  var legacy2 = requireLegacyStreams();
  var clone = requireClone();
  var util2 = require$$0$5;
  var gracefulQueue;
  var previousSymbol;
  if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    gracefulQueue = Symbol.for("graceful-fs.queue");
    previousSymbol = Symbol.for("graceful-fs.previous");
  } else {
    gracefulQueue = "___graceful-fs.queue";
    previousSymbol = "___graceful-fs.previous";
  }
  function noop2() {
  }
  function publishQueue(context, queue2) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue2;
      }
    });
  }
  var debug2 = noop2;
  if (util2.debuglog)
    debug2 = util2.debuglog("gfs4");
  else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
    debug2 = function() {
      var m = util2.format.apply(util2, arguments);
      m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
      console.error(m);
    };
  if (!fs2[gracefulQueue]) {
    var queue = commonjsGlobal$1[gracefulQueue] || [];
    publishQueue(fs2, queue);
    fs2.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs2, fd, function(err) {
          if (!err) {
            resetQueue();
          }
          if (typeof cb === "function")
            cb.apply(this, arguments);
        });
      }
      Object.defineProperty(close, previousSymbol, {
        value: fs$close
      });
      return close;
    }(fs2.close);
    fs2.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs2, arguments);
        resetQueue();
      }
      Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      });
      return closeSync;
    }(fs2.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
      process.on("exit", function() {
        debug2(fs2[gracefulQueue]);
        require$$5$1.equal(fs2[gracefulQueue].length, 0);
      });
    }
  }
  if (!commonjsGlobal$1[gracefulQueue]) {
    publishQueue(commonjsGlobal$1, fs2[gracefulQueue]);
  }
  gracefulFs = patch(clone(fs2));
  if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched) {
    gracefulFs = patch(fs2);
    fs2.__patched = true;
  }
  function patch(fs3) {
    polyfills2(fs3);
    fs3.gracefulify = patch;
    fs3.createReadStream = createReadStream;
    fs3.createWriteStream = createWriteStream;
    var fs$readFile = fs3.readFile;
    fs3.readFile = readFile;
    function readFile(path2, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$readFile(path2, options, cb);
      function go$readFile(path22, options2, cb2, startTime) {
        return fs$readFile(path22, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readFile, [path22, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$writeFile = fs3.writeFile;
    fs3.writeFile = writeFile;
    function writeFile(path2, data2, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$writeFile(path2, data2, options, cb);
      function go$writeFile(path22, data22, options2, cb2, startTime) {
        return fs$writeFile(path22, data22, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$writeFile, [path22, data22, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$appendFile = fs3.appendFile;
    if (fs$appendFile)
      fs3.appendFile = appendFile;
    function appendFile(path2, data2, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$appendFile(path2, data2, options, cb);
      function go$appendFile(path22, data22, options2, cb2, startTime) {
        return fs$appendFile(path22, data22, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$appendFile, [path22, data22, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$copyFile = fs3.copyFile;
    if (fs$copyFile)
      fs3.copyFile = copyFile;
    function copyFile(src, dest, flags, cb) {
      if (typeof flags === "function") {
        cb = flags;
        flags = 0;
      }
      return go$copyFile(src, dest, flags, cb);
      function go$copyFile(src2, dest2, flags2, cb2, startTime) {
        return fs$copyFile(src2, dest2, flags2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$readdir = fs3.readdir;
    fs3.readdir = readdir;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir(path2, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path22, options2, cb2, startTime) {
        return fs$readdir(path22, fs$readdirCallback(
          path22,
          options2,
          cb2,
          startTime
        ));
      } : function go$readdir2(path22, options2, cb2, startTime) {
        return fs$readdir(path22, options2, fs$readdirCallback(
          path22,
          options2,
          cb2,
          startTime
        ));
      };
      return go$readdir(path2, options, cb);
      function fs$readdirCallback(path22, options2, cb2, startTime) {
        return function(err, files) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([
              go$readdir,
              [path22, options2, cb2],
              err,
              startTime || Date.now(),
              Date.now()
            ]);
          else {
            if (files && files.sort)
              files.sort();
            if (typeof cb2 === "function")
              cb2.call(this, err, files);
          }
        };
      }
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy2(fs3);
      ReadStream = legStreams.ReadStream;
      WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs3.ReadStream;
    if (fs$ReadStream) {
      ReadStream.prototype = Object.create(fs$ReadStream.prototype);
      ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs3.WriteStream;
    if (fs$WriteStream) {
      WriteStream.prototype = Object.create(fs$WriteStream.prototype);
      WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs3, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(fs3, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs3, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs3, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    function ReadStream(path2, options) {
      if (this instanceof ReadStream)
        return fs$ReadStream.apply(this, arguments), this;
      else
        return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          if (that.autoClose)
            that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
          that.read();
        }
      });
    }
    function WriteStream(path2, options) {
      if (this instanceof WriteStream)
        return fs$WriteStream.apply(this, arguments), this;
      else
        return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
        }
      });
    }
    function createReadStream(path2, options) {
      return new fs3.ReadStream(path2, options);
    }
    function createWriteStream(path2, options) {
      return new fs3.WriteStream(path2, options);
    }
    var fs$open = fs3.open;
    fs3.open = open;
    function open(path2, flags, mode2, cb) {
      if (typeof mode2 === "function")
        cb = mode2, mode2 = null;
      return go$open(path2, flags, mode2, cb);
      function go$open(path22, flags2, mode22, cb2, startTime) {
        return fs$open(path22, flags2, mode22, function(err, fd) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$open, [path22, flags2, mode22, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    return fs3;
  }
  function enqueue(elem) {
    debug2("ENQUEUE", elem[0].name, elem[1]);
    fs2[gracefulQueue].push(elem);
    retry();
  }
  var retryTimer;
  function resetQueue() {
    var now2 = Date.now();
    for (var i = 0; i < fs2[gracefulQueue].length; ++i) {
      if (fs2[gracefulQueue][i].length > 2) {
        fs2[gracefulQueue][i][3] = now2;
        fs2[gracefulQueue][i][4] = now2;
      }
    }
    retry();
  }
  function retry() {
    clearTimeout(retryTimer);
    retryTimer = void 0;
    if (fs2[gracefulQueue].length === 0)
      return;
    var elem = fs2[gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];
    if (startTime === void 0) {
      debug2("RETRY", fn.name, args);
      fn.apply(null, args);
    } else if (Date.now() - startTime >= 6e4) {
      debug2("TIMEOUT", fn.name, args);
      var cb = args.pop();
      if (typeof cb === "function")
        cb.call(null, err);
    } else {
      var sinceAttempt = Date.now() - lastTime;
      var sinceStart = Math.max(lastTime - startTime, 1);
      var desiredDelay = Math.min(sinceStart * 1.2, 100);
      if (sinceAttempt >= desiredDelay) {
        debug2("RETRY", fn.name, args);
        fn.apply(null, args.concat([startTime]));
      } else {
        fs2[gracefulQueue].push(elem);
      }
    }
    if (retryTimer === void 0) {
      retryTimer = setTimeout(retry, 0);
    }
  }
  return gracefulFs;
}
var hasRequiredFs;
function requireFs() {
  if (hasRequiredFs) return fs;
  hasRequiredFs = 1;
  (function(exports) {
    const u = requireUniversalify().fromCallback;
    const fs2 = requireGracefulFs();
    const api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchown",
      "lchmod",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "readFile",
      "readdir",
      "readlink",
      "realpath",
      "rename",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs2[key] === "function";
    });
    Object.keys(fs2).forEach((key) => {
      if (key === "promises") {
        return;
      }
      exports[key] = fs2[key];
    });
    api.forEach((method) => {
      exports[method] = u(fs2[method]);
    });
    exports.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs2.exists(filename, callback);
      }
      return new Promise((resolve) => {
        return fs2.exists(filename, resolve);
      });
    };
    exports.read = function(fd, buffer2, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs2.read(fd, buffer2, offset, length, position, callback);
      }
      return new Promise((resolve, reject) => {
        fs2.read(fd, buffer2, offset, length, position, (err, bytesRead, buffer3) => {
          if (err) return reject(err);
          resolve({ bytesRead, buffer: buffer3 });
        });
      });
    };
    exports.write = function(fd, buffer2, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs2.write(fd, buffer2, ...args);
      }
      return new Promise((resolve, reject) => {
        fs2.write(fd, buffer2, ...args, (err, bytesWritten, buffer3) => {
          if (err) return reject(err);
          resolve({ bytesWritten, buffer: buffer3 });
        });
      });
    };
    if (typeof fs2.realpath.native === "function") {
      exports.realpath.native = u(fs2.realpath.native);
    }
  })(fs);
  return fs;
}
var win32;
var hasRequiredWin32;
function requireWin32() {
  if (hasRequiredWin32) return win32;
  hasRequiredWin32 = 1;
  const path2 = require$$1$3;
  function getRootPath(p) {
    p = path2.normalize(path2.resolve(p)).split(path2.sep);
    if (p.length > 0) return p[0];
    return null;
  }
  const INVALID_PATH_CHARS = /[<>:"|?*]/;
  function invalidWin32Path(p) {
    const rp = getRootPath(p);
    p = p.replace(rp, "");
    return INVALID_PATH_CHARS.test(p);
  }
  win32 = {
    getRootPath,
    invalidWin32Path
  };
  return win32;
}
var mkdirs_1$1;
var hasRequiredMkdirs$1;
function requireMkdirs$1() {
  if (hasRequiredMkdirs$1) return mkdirs_1$1;
  hasRequiredMkdirs$1 = 1;
  const fs2 = requireGracefulFs();
  const path2 = require$$1$3;
  const invalidWin32Path = requireWin32().invalidWin32Path;
  const o777 = parseInt("0777", 8);
  function mkdirs(p, opts, callback, made) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    } else if (!opts || typeof opts !== "object") {
      opts = { mode: opts };
    }
    if (process.platform === "win32" && invalidWin32Path(p)) {
      const errInval = new Error(p + " contains invalid WIN32 path characters.");
      errInval.code = "EINVAL";
      return callback(errInval);
    }
    let mode2 = opts.mode;
    const xfs = opts.fs || fs2;
    if (mode2 === void 0) {
      mode2 = o777 & ~process.umask();
    }
    if (!made) made = null;
    callback = callback || function() {
    };
    p = path2.resolve(p);
    xfs.mkdir(p, mode2, (er) => {
      if (!er) {
        made = made || p;
        return callback(null, made);
      }
      switch (er.code) {
        case "ENOENT":
          if (path2.dirname(p) === p) return callback(er);
          mkdirs(path2.dirname(p), opts, (er2, made2) => {
            if (er2) callback(er2, made2);
            else mkdirs(p, opts, callback, made2);
          });
          break;
        // In the case of any other error, just see if there's a dir
        // there already.  If so, then hooray!  If not, then something
        // is borked.
        default:
          xfs.stat(p, (er2, stat2) => {
            if (er2 || !stat2.isDirectory()) callback(er, made);
            else callback(null, made);
          });
          break;
      }
    });
  }
  mkdirs_1$1 = mkdirs;
  return mkdirs_1$1;
}
var mkdirsSync_1;
var hasRequiredMkdirsSync;
function requireMkdirsSync() {
  if (hasRequiredMkdirsSync) return mkdirsSync_1;
  hasRequiredMkdirsSync = 1;
  const fs2 = requireGracefulFs();
  const path2 = require$$1$3;
  const invalidWin32Path = requireWin32().invalidWin32Path;
  const o777 = parseInt("0777", 8);
  function mkdirsSync(p, opts, made) {
    if (!opts || typeof opts !== "object") {
      opts = { mode: opts };
    }
    let mode2 = opts.mode;
    const xfs = opts.fs || fs2;
    if (process.platform === "win32" && invalidWin32Path(p)) {
      const errInval = new Error(p + " contains invalid WIN32 path characters.");
      errInval.code = "EINVAL";
      throw errInval;
    }
    if (mode2 === void 0) {
      mode2 = o777 & ~process.umask();
    }
    if (!made) made = null;
    p = path2.resolve(p);
    try {
      xfs.mkdirSync(p, mode2);
      made = made || p;
    } catch (err0) {
      if (err0.code === "ENOENT") {
        if (path2.dirname(p) === p) throw err0;
        made = mkdirsSync(path2.dirname(p), opts, made);
        mkdirsSync(p, opts, made);
      } else {
        let stat2;
        try {
          stat2 = xfs.statSync(p);
        } catch (err1) {
          throw err0;
        }
        if (!stat2.isDirectory()) throw err0;
      }
    }
    return made;
  }
  mkdirsSync_1 = mkdirsSync;
  return mkdirsSync_1;
}
var mkdirs_1;
var hasRequiredMkdirs;
function requireMkdirs() {
  if (hasRequiredMkdirs) return mkdirs_1;
  hasRequiredMkdirs = 1;
  const u = requireUniversalify().fromCallback;
  const mkdirs = u(requireMkdirs$1());
  const mkdirsSync = requireMkdirsSync();
  mkdirs_1 = {
    mkdirs,
    mkdirsSync,
    // alias
    mkdirp: mkdirs,
    mkdirpSync: mkdirsSync,
    ensureDir: mkdirs,
    ensureDirSync: mkdirsSync
  };
  return mkdirs_1;
}
var utimes;
var hasRequiredUtimes;
function requireUtimes() {
  if (hasRequiredUtimes) return utimes;
  hasRequiredUtimes = 1;
  const fs2 = requireGracefulFs();
  const os = require$$1$1;
  const path2 = require$$1$3;
  function hasMillisResSync() {
    let tmpfile = path2.join("millis-test-sync" + Date.now().toString() + Math.random().toString().slice(2));
    tmpfile = path2.join(os.tmpdir(), tmpfile);
    const d = /* @__PURE__ */ new Date(1435410243862);
    fs2.writeFileSync(tmpfile, "https://github.com/jprichardson/node-fs-extra/pull/141");
    const fd = fs2.openSync(tmpfile, "r+");
    fs2.futimesSync(fd, d, d);
    fs2.closeSync(fd);
    return fs2.statSync(tmpfile).mtime > 1435410243e3;
  }
  function hasMillisRes(callback) {
    let tmpfile = path2.join("millis-test" + Date.now().toString() + Math.random().toString().slice(2));
    tmpfile = path2.join(os.tmpdir(), tmpfile);
    const d = /* @__PURE__ */ new Date(1435410243862);
    fs2.writeFile(tmpfile, "https://github.com/jprichardson/node-fs-extra/pull/141", (err) => {
      if (err) return callback(err);
      fs2.open(tmpfile, "r+", (err2, fd) => {
        if (err2) return callback(err2);
        fs2.futimes(fd, d, d, (err3) => {
          if (err3) return callback(err3);
          fs2.close(fd, (err4) => {
            if (err4) return callback(err4);
            fs2.stat(tmpfile, (err5, stats) => {
              if (err5) return callback(err5);
              callback(null, stats.mtime > 1435410243e3);
            });
          });
        });
      });
    });
  }
  function timeRemoveMillis(timestamp) {
    if (typeof timestamp === "number") {
      return Math.floor(timestamp / 1e3) * 1e3;
    } else if (timestamp instanceof Date) {
      return new Date(Math.floor(timestamp.getTime() / 1e3) * 1e3);
    } else {
      throw new Error("fs-extra: timeRemoveMillis() unknown parameter type");
    }
  }
  function utimesMillis(path22, atime, mtime, callback) {
    fs2.open(path22, "r+", (err, fd) => {
      if (err) return callback(err);
      fs2.futimes(fd, atime, mtime, (futimesErr) => {
        fs2.close(fd, (closeErr) => {
          if (callback) callback(futimesErr || closeErr);
        });
      });
    });
  }
  function utimesMillisSync(path22, atime, mtime) {
    const fd = fs2.openSync(path22, "r+");
    fs2.futimesSync(fd, atime, mtime);
    return fs2.closeSync(fd);
  }
  utimes = {
    hasMillisRes,
    hasMillisResSync,
    timeRemoveMillis,
    utimesMillis,
    utimesMillisSync
  };
  return utimes;
}
var stat;
var hasRequiredStat;
function requireStat() {
  if (hasRequiredStat) return stat;
  hasRequiredStat = 1;
  const fs2 = requireGracefulFs();
  const path2 = require$$1$3;
  const NODE_VERSION_MAJOR_WITH_BIGINT = 10;
  const NODE_VERSION_MINOR_WITH_BIGINT = 5;
  const NODE_VERSION_PATCH_WITH_BIGINT = 0;
  const nodeVersion = process.versions.node.split(".");
  const nodeVersionMajor = Number.parseInt(nodeVersion[0], 10);
  const nodeVersionMinor = Number.parseInt(nodeVersion[1], 10);
  const nodeVersionPatch = Number.parseInt(nodeVersion[2], 10);
  function nodeSupportsBigInt() {
    if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {
      return true;
    } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {
      if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {
        return true;
      } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {
        if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {
          return true;
        }
      }
    }
    return false;
  }
  function getStats(src, dest, cb) {
    if (nodeSupportsBigInt()) {
      fs2.stat(src, { bigint: true }, (err, srcStat) => {
        if (err) return cb(err);
        fs2.stat(dest, { bigint: true }, (err2, destStat) => {
          if (err2) {
            if (err2.code === "ENOENT") return cb(null, { srcStat, destStat: null });
            return cb(err2);
          }
          return cb(null, { srcStat, destStat });
        });
      });
    } else {
      fs2.stat(src, (err, srcStat) => {
        if (err) return cb(err);
        fs2.stat(dest, (err2, destStat) => {
          if (err2) {
            if (err2.code === "ENOENT") return cb(null, { srcStat, destStat: null });
            return cb(err2);
          }
          return cb(null, { srcStat, destStat });
        });
      });
    }
  }
  function getStatsSync(src, dest) {
    let srcStat, destStat;
    if (nodeSupportsBigInt()) {
      srcStat = fs2.statSync(src, { bigint: true });
    } else {
      srcStat = fs2.statSync(src);
    }
    try {
      if (nodeSupportsBigInt()) {
        destStat = fs2.statSync(dest, { bigint: true });
      } else {
        destStat = fs2.statSync(dest);
      }
    } catch (err) {
      if (err.code === "ENOENT") return { srcStat, destStat: null };
      throw err;
    }
    return { srcStat, destStat };
  }
  function checkPaths(src, dest, funcName, cb) {
    getStats(src, dest, (err, stats) => {
      if (err) return cb(err);
      const { srcStat, destStat } = stats;
      if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
        return cb(new Error("Source and destination must not be the same."));
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        return cb(new Error(errMsg(src, dest, funcName)));
      }
      return cb(null, { srcStat, destStat });
    });
  }
  function checkPathsSync(src, dest, funcName) {
    const { srcStat, destStat } = getStatsSync(src, dest);
    if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return { srcStat, destStat };
  }
  function checkParentPaths(src, srcStat, dest, funcName, cb) {
    const srcParent = path2.resolve(path2.dirname(src));
    const destParent = path2.resolve(path2.dirname(dest));
    if (destParent === srcParent || destParent === path2.parse(destParent).root) return cb();
    if (nodeSupportsBigInt()) {
      fs2.stat(destParent, { bigint: true }, (err, destStat) => {
        if (err) {
          if (err.code === "ENOENT") return cb();
          return cb(err);
        }
        if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return checkParentPaths(src, srcStat, destParent, funcName, cb);
      });
    } else {
      fs2.stat(destParent, (err, destStat) => {
        if (err) {
          if (err.code === "ENOENT") return cb();
          return cb(err);
        }
        if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return checkParentPaths(src, srcStat, destParent, funcName, cb);
      });
    }
  }
  function checkParentPathsSync(src, srcStat, dest, funcName) {
    const srcParent = path2.resolve(path2.dirname(src));
    const destParent = path2.resolve(path2.dirname(dest));
    if (destParent === srcParent || destParent === path2.parse(destParent).root) return;
    let destStat;
    try {
      if (nodeSupportsBigInt()) {
        destStat = fs2.statSync(destParent, { bigint: true });
      } else {
        destStat = fs2.statSync(destParent);
      }
    } catch (err) {
      if (err.code === "ENOENT") return;
      throw err;
    }
    if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return checkParentPathsSync(src, srcStat, destParent, funcName);
  }
  function isSrcSubdir(src, dest) {
    const srcArr = path2.resolve(src).split(path2.sep).filter((i) => i);
    const destArr = path2.resolve(dest).split(path2.sep).filter((i) => i);
    return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
  }
  function errMsg(src, dest, funcName) {
    return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
  }
  stat = {
    checkPaths,
    checkPathsSync,
    checkParentPaths,
    checkParentPathsSync,
    isSrcSubdir
  };
  return stat;
}
var buffer;
var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  buffer = function(size) {
    if (typeof Buffer.allocUnsafe === "function") {
      try {
        return Buffer.allocUnsafe(size);
      } catch (e) {
        return new Buffer(size);
      }
    }
    return new Buffer(size);
  };
  return buffer;
}
var copySync_1;
var hasRequiredCopySync$1;
function requireCopySync$1() {
  if (hasRequiredCopySync$1) return copySync_1;
  hasRequiredCopySync$1 = 1;
  const fs2 = requireGracefulFs();
  const path2 = require$$1$3;
  const mkdirpSync = requireMkdirs().mkdirsSync;
  const utimesSync = requireUtimes().utimesMillisSync;
  const stat2 = requireStat();
  function copySync2(src, dest, opts) {
    if (typeof opts === "function") {
      opts = { filter: opts };
    }
    opts = opts || {};
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
    }
    const { srcStat, destStat } = stat2.checkPathsSync(src, dest, "copy");
    stat2.checkParentPathsSync(src, srcStat, dest, "copy");
    return handleFilterAndCopy(destStat, src, dest, opts);
  }
  function handleFilterAndCopy(destStat, src, dest, opts) {
    if (opts.filter && !opts.filter(src, dest)) return;
    const destParent = path2.dirname(dest);
    if (!fs2.existsSync(destParent)) mkdirpSync(destParent);
    return startCopy(destStat, src, dest, opts);
  }
  function startCopy(destStat, src, dest, opts) {
    if (opts.filter && !opts.filter(src, dest)) return;
    return getStats(destStat, src, dest, opts);
  }
  function getStats(destStat, src, dest, opts) {
    const statSync = opts.dereference ? fs2.statSync : fs2.lstatSync;
    const srcStat = statSync(src);
    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);
    else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);
    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);
  }
  function onFile(srcStat, destStat, src, dest, opts) {
    if (!destStat) return copyFile(srcStat, src, dest, opts);
    return mayCopyFile(srcStat, src, dest, opts);
  }
  function mayCopyFile(srcStat, src, dest, opts) {
    if (opts.overwrite) {
      fs2.unlinkSync(dest);
      return copyFile(srcStat, src, dest, opts);
    } else if (opts.errorOnExist) {
      throw new Error(`'${dest}' already exists`);
    }
  }
  function copyFile(srcStat, src, dest, opts) {
    if (typeof fs2.copyFileSync === "function") {
      fs2.copyFileSync(src, dest);
      fs2.chmodSync(dest, srcStat.mode);
      if (opts.preserveTimestamps) {
        return utimesSync(dest, srcStat.atime, srcStat.mtime);
      }
      return;
    }
    return copyFileFallback(srcStat, src, dest, opts);
  }
  function copyFileFallback(srcStat, src, dest, opts) {
    const BUF_LENGTH = 64 * 1024;
    const _buff = requireBuffer()(BUF_LENGTH);
    const fdr = fs2.openSync(src, "r");
    const fdw = fs2.openSync(dest, "w", srcStat.mode);
    let pos = 0;
    while (pos < srcStat.size) {
      const bytesRead = fs2.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
      fs2.writeSync(fdw, _buff, 0, bytesRead);
      pos += bytesRead;
    }
    if (opts.preserveTimestamps) fs2.futimesSync(fdw, srcStat.atime, srcStat.mtime);
    fs2.closeSync(fdr);
    fs2.closeSync(fdw);
  }
  function onDir(srcStat, destStat, src, dest, opts) {
    if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts);
    if (destStat && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
    }
    return copyDir(src, dest, opts);
  }
  function mkDirAndCopy(srcStat, src, dest, opts) {
    fs2.mkdirSync(dest);
    copyDir(src, dest, opts);
    return fs2.chmodSync(dest, srcStat.mode);
  }
  function copyDir(src, dest, opts) {
    fs2.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
  }
  function copyDirItem(item, src, dest, opts) {
    const srcItem = path2.join(src, item);
    const destItem = path2.join(dest, item);
    const { destStat } = stat2.checkPathsSync(srcItem, destItem, "copy");
    return startCopy(destStat, srcItem, destItem, opts);
  }
  function onLink(destStat, src, dest, opts) {
    let resolvedSrc = fs2.readlinkSync(src);
    if (opts.dereference) {
      resolvedSrc = path2.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs2.symlinkSync(resolvedSrc, dest);
    } else {
      let resolvedDest;
      try {
        resolvedDest = fs2.readlinkSync(dest);
      } catch (err) {
        if (err.code === "EINVAL" || err.code === "UNKNOWN") return fs2.symlinkSync(resolvedSrc, dest);
        throw err;
      }
      if (opts.dereference) {
        resolvedDest = path2.resolve(process.cwd(), resolvedDest);
      }
      if (stat2.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }
      if (fs2.statSync(dest).isDirectory() && stat2.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
      return copyLink(resolvedSrc, dest);
    }
  }
  function copyLink(resolvedSrc, dest) {
    fs2.unlinkSync(dest);
    return fs2.symlinkSync(resolvedSrc, dest);
  }
  copySync_1 = copySync2;
  return copySync_1;
}
var copySync;
var hasRequiredCopySync;
function requireCopySync() {
  if (hasRequiredCopySync) return copySync;
  hasRequiredCopySync = 1;
  copySync = {
    copySync: requireCopySync$1()
  };
  return copySync;
}
var pathExists_1;
var hasRequiredPathExists;
function requirePathExists() {
  if (hasRequiredPathExists) return pathExists_1;
  hasRequiredPathExists = 1;
  const u = requireUniversalify().fromPromise;
  const fs2 = requireFs();
  function pathExists(path2) {
    return fs2.access(path2).then(() => true).catch(() => false);
  }
  pathExists_1 = {
    pathExists: u(pathExists),
    pathExistsSync: fs2.existsSync
  };
  return pathExists_1;
}
var copy_1;
var hasRequiredCopy$1;
function requireCopy$1() {
  if (hasRequiredCopy$1) return copy_1;
  hasRequiredCopy$1 = 1;
  const fs2 = requireGracefulFs();
  const path2 = require$$1$3;
  const mkdirp = requireMkdirs().mkdirs;
  const pathExists = requirePathExists().pathExists;
  const utimes2 = requireUtimes().utimesMillis;
  const stat2 = requireStat();
  function copy2(src, dest, opts, cb) {
    if (typeof opts === "function" && !cb) {
      cb = opts;
      opts = {};
    } else if (typeof opts === "function") {
      opts = { filter: opts };
    }
    cb = cb || function() {
    };
    opts = opts || {};
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
    }
    stat2.checkPaths(src, dest, "copy", (err, stats) => {
      if (err) return cb(err);
      const { srcStat, destStat } = stats;
      stat2.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
        if (err2) return cb(err2);
        if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
        return checkParentDir(destStat, src, dest, opts, cb);
      });
    });
  }
  function checkParentDir(destStat, src, dest, opts, cb) {
    const destParent = path2.dirname(dest);
    pathExists(destParent, (err, dirExists) => {
      if (err) return cb(err);
      if (dirExists) return startCopy(destStat, src, dest, opts, cb);
      mkdirp(destParent, (err2) => {
        if (err2) return cb(err2);
        return startCopy(destStat, src, dest, opts, cb);
      });
    });
  }
  function handleFilter(onInclude, destStat, src, dest, opts, cb) {
    Promise.resolve(opts.filter(src, dest)).then((include) => {
      if (include) return onInclude(destStat, src, dest, opts, cb);
      return cb();
    }, (error) => cb(error));
  }
  function startCopy(destStat, src, dest, opts, cb) {
    if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb);
    return getStats(destStat, src, dest, opts, cb);
  }
  function getStats(destStat, src, dest, opts, cb) {
    const stat3 = opts.dereference ? fs2.stat : fs2.lstat;
    stat3(src, (err, srcStat) => {
      if (err) return cb(err);
      if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb);
      else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb);
    });
  }
  function onFile(srcStat, destStat, src, dest, opts, cb) {
    if (!destStat) return copyFile(srcStat, src, dest, opts, cb);
    return mayCopyFile(srcStat, src, dest, opts, cb);
  }
  function mayCopyFile(srcStat, src, dest, opts, cb) {
    if (opts.overwrite) {
      fs2.unlink(dest, (err) => {
        if (err) return cb(err);
        return copyFile(srcStat, src, dest, opts, cb);
      });
    } else if (opts.errorOnExist) {
      return cb(new Error(`'${dest}' already exists`));
    } else return cb();
  }
  function copyFile(srcStat, src, dest, opts, cb) {
    if (typeof fs2.copyFile === "function") {
      return fs2.copyFile(src, dest, (err) => {
        if (err) return cb(err);
        return setDestModeAndTimestamps(srcStat, dest, opts, cb);
      });
    }
    return copyFileFallback(srcStat, src, dest, opts, cb);
  }
  function copyFileFallback(srcStat, src, dest, opts, cb) {
    const rs = fs2.createReadStream(src);
    rs.on("error", (err) => cb(err)).once("open", () => {
      const ws = fs2.createWriteStream(dest, { mode: srcStat.mode });
      ws.on("error", (err) => cb(err)).on("open", () => rs.pipe(ws)).once("close", () => setDestModeAndTimestamps(srcStat, dest, opts, cb));
    });
  }
  function setDestModeAndTimestamps(srcStat, dest, opts, cb) {
    fs2.chmod(dest, srcStat.mode, (err) => {
      if (err) return cb(err);
      if (opts.preserveTimestamps) {
        return utimes2(dest, srcStat.atime, srcStat.mtime, cb);
      }
      return cb();
    });
  }
  function onDir(srcStat, destStat, src, dest, opts, cb) {
    if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts, cb);
    if (destStat && !destStat.isDirectory()) {
      return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
    }
    return copyDir(src, dest, opts, cb);
  }
  function mkDirAndCopy(srcStat, src, dest, opts, cb) {
    fs2.mkdir(dest, (err) => {
      if (err) return cb(err);
      copyDir(src, dest, opts, (err2) => {
        if (err2) return cb(err2);
        return fs2.chmod(dest, srcStat.mode, cb);
      });
    });
  }
  function copyDir(src, dest, opts, cb) {
    fs2.readdir(src, (err, items) => {
      if (err) return cb(err);
      return copyDirItems(items, src, dest, opts, cb);
    });
  }
  function copyDirItems(items, src, dest, opts, cb) {
    const item = items.pop();
    if (!item) return cb();
    return copyDirItem(items, item, src, dest, opts, cb);
  }
  function copyDirItem(items, item, src, dest, opts, cb) {
    const srcItem = path2.join(src, item);
    const destItem = path2.join(dest, item);
    stat2.checkPaths(srcItem, destItem, "copy", (err, stats) => {
      if (err) return cb(err);
      const { destStat } = stats;
      startCopy(destStat, srcItem, destItem, opts, (err2) => {
        if (err2) return cb(err2);
        return copyDirItems(items, src, dest, opts, cb);
      });
    });
  }
  function onLink(destStat, src, dest, opts, cb) {
    fs2.readlink(src, (err, resolvedSrc) => {
      if (err) return cb(err);
      if (opts.dereference) {
        resolvedSrc = path2.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs2.symlink(resolvedSrc, dest, cb);
      } else {
        fs2.readlink(dest, (err2, resolvedDest) => {
          if (err2) {
            if (err2.code === "EINVAL" || err2.code === "UNKNOWN") return fs2.symlink(resolvedSrc, dest, cb);
            return cb(err2);
          }
          if (opts.dereference) {
            resolvedDest = path2.resolve(process.cwd(), resolvedDest);
          }
          if (stat2.isSrcSubdir(resolvedSrc, resolvedDest)) {
            return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
          }
          if (destStat.isDirectory() && stat2.isSrcSubdir(resolvedDest, resolvedSrc)) {
            return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
          }
          return copyLink(resolvedSrc, dest, cb);
        });
      }
    });
  }
  function copyLink(resolvedSrc, dest, cb) {
    fs2.unlink(dest, (err) => {
      if (err) return cb(err);
      return fs2.symlink(resolvedSrc, dest, cb);
    });
  }
  copy_1 = copy2;
  return copy_1;
}
var copy;
var hasRequiredCopy;
function requireCopy() {
  if (hasRequiredCopy) return copy;
  hasRequiredCopy = 1;
  const u = requireUniversalify().fromCallback;
  copy = {
    copy: u(requireCopy$1())
  };
  return copy;
}
var rimraf_1;
var hasRequiredRimraf;
function requireRimraf() {
  if (hasRequiredRimraf) return rimraf_1;
  hasRequiredRimraf = 1;
  const fs2 = requireGracefulFs();
  const path2 = require$$1$3;
  const assert = require$$5$1;
  const isWindows = process.platform === "win32";
  function defaults2(options) {
    const methods = [
      "unlink",
      "chmod",
      "stat",
      "lstat",
      "rmdir",
      "readdir"
    ];
    methods.forEach((m) => {
      options[m] = options[m] || fs2[m];
      m = m + "Sync";
      options[m] = options[m] || fs2[m];
    });
    options.maxBusyTries = options.maxBusyTries || 3;
  }
  function rimraf(p, options, cb) {
    let busyTries = 0;
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    assert(p, "rimraf: missing path");
    assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
    assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
    assert(options, "rimraf: invalid options argument provided");
    assert.strictEqual(typeof options, "object", "rimraf: options should be object");
    defaults2(options);
    rimraf_(p, options, function CB(er) {
      if (er) {
        if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
          busyTries++;
          const time = busyTries * 100;
          return setTimeout(() => rimraf_(p, options, CB), time);
        }
        if (er.code === "ENOENT") er = null;
      }
      cb(er);
    });
  }
  function rimraf_(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.lstat(p, (er, st) => {
      if (er && er.code === "ENOENT") {
        return cb(null);
      }
      if (er && er.code === "EPERM" && isWindows) {
        return fixWinEPERM(p, options, er, cb);
      }
      if (st && st.isDirectory()) {
        return rmdir(p, options, er, cb);
      }
      options.unlink(p, (er2) => {
        if (er2) {
          if (er2.code === "ENOENT") {
            return cb(null);
          }
          if (er2.code === "EPERM") {
            return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
          }
          if (er2.code === "EISDIR") {
            return rmdir(p, options, er2, cb);
          }
        }
        return cb(er2);
      });
    });
  }
  function fixWinEPERM(p, options, er, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    if (er) {
      assert(er instanceof Error);
    }
    options.chmod(p, 438, (er2) => {
      if (er2) {
        cb(er2.code === "ENOENT" ? null : er);
      } else {
        options.stat(p, (er3, stats) => {
          if (er3) {
            cb(er3.code === "ENOENT" ? null : er);
          } else if (stats.isDirectory()) {
            rmdir(p, options, er, cb);
          } else {
            options.unlink(p, cb);
          }
        });
      }
    });
  }
  function fixWinEPERMSync(p, options, er) {
    let stats;
    assert(p);
    assert(options);
    if (er) {
      assert(er instanceof Error);
    }
    try {
      options.chmodSync(p, 438);
    } catch (er2) {
      if (er2.code === "ENOENT") {
        return;
      } else {
        throw er;
      }
    }
    try {
      stats = options.statSync(p);
    } catch (er3) {
      if (er3.code === "ENOENT") {
        return;
      } else {
        throw er;
      }
    }
    if (stats.isDirectory()) {
      rmdirSync(p, options, er);
    } else {
      options.unlinkSync(p);
    }
  }
  function rmdir(p, options, originalEr, cb) {
    assert(p);
    assert(options);
    if (originalEr) {
      assert(originalEr instanceof Error);
    }
    assert(typeof cb === "function");
    options.rmdir(p, (er) => {
      if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
        rmkids(p, options, cb);
      } else if (er && er.code === "ENOTDIR") {
        cb(originalEr);
      } else {
        cb(er);
      }
    });
  }
  function rmkids(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.readdir(p, (er, files) => {
      if (er) return cb(er);
      let n = files.length;
      let errState;
      if (n === 0) return options.rmdir(p, cb);
      files.forEach((f) => {
        rimraf(path2.join(p, f), options, (er2) => {
          if (errState) {
            return;
          }
          if (er2) return cb(errState = er2);
          if (--n === 0) {
            options.rmdir(p, cb);
          }
        });
      });
    });
  }
  function rimrafSync(p, options) {
    let st;
    options = options || {};
    defaults2(options);
    assert(p, "rimraf: missing path");
    assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
    assert(options, "rimraf: missing options");
    assert.strictEqual(typeof options, "object", "rimraf: options should be object");
    try {
      st = options.lstatSync(p);
    } catch (er) {
      if (er.code === "ENOENT") {
        return;
      }
      if (er.code === "EPERM" && isWindows) {
        fixWinEPERMSync(p, options, er);
      }
    }
    try {
      if (st && st.isDirectory()) {
        rmdirSync(p, options, null);
      } else {
        options.unlinkSync(p);
      }
    } catch (er) {
      if (er.code === "ENOENT") {
        return;
      } else if (er.code === "EPERM") {
        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
      } else if (er.code !== "EISDIR") {
        throw er;
      }
      rmdirSync(p, options, er);
    }
  }
  function rmdirSync(p, options, originalEr) {
    assert(p);
    assert(options);
    if (originalEr) {
      assert(originalEr instanceof Error);
    }
    try {
      options.rmdirSync(p);
    } catch (er) {
      if (er.code === "ENOTDIR") {
        throw originalEr;
      } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
        rmkidsSync(p, options);
      } else if (er.code !== "ENOENT") {
        throw er;
      }
    }
  }
  function rmkidsSync(p, options) {
    assert(p);
    assert(options);
    options.readdirSync(p).forEach((f) => rimrafSync(path2.join(p, f), options));
    if (isWindows) {
      const startTime = Date.now();
      do {
        try {
          const ret = options.rmdirSync(p, options);
          return ret;
        } catch (er) {
        }
      } while (Date.now() - startTime < 500);
    } else {
      const ret = options.rmdirSync(p, options);
      return ret;
    }
  }
  rimraf_1 = rimraf;
  rimraf.sync = rimrafSync;
  return rimraf_1;
}
var remove;
var hasRequiredRemove;
function requireRemove() {
  if (hasRequiredRemove) return remove;
  hasRequiredRemove = 1;
  const u = requireUniversalify().fromCallback;
  const rimraf = requireRimraf();
  remove = {
    remove: u(rimraf),
    removeSync: rimraf.sync
  };
  return remove;
}
var empty;
var hasRequiredEmpty;
function requireEmpty() {
  if (hasRequiredEmpty) return empty;
  hasRequiredEmpty = 1;
  const u = requireUniversalify().fromCallback;
  const fs2 = requireGracefulFs();
  const path2 = require$$1$3;
  const mkdir = requireMkdirs();
  const remove2 = requireRemove();
  const emptyDir = u(function emptyDir2(dir, callback) {
    callback = callback || function() {
    };
    fs2.readdir(dir, (err, items) => {
      if (err) return mkdir.mkdirs(dir, callback);
      items = items.map((item) => path2.join(dir, item));
      deleteItem();
      function deleteItem() {
        const item = items.pop();
        if (!item) return callback();
        remove2.remove(item, (err2) => {
          if (err2) return callback(err2);
          deleteItem();
        });
      }
    });
  });
  function emptyDirSync(dir) {
    let items;
    try {
      items = fs2.readdirSync(dir);
    } catch (err) {
      return mkdir.mkdirsSync(dir);
    }
    items.forEach((item) => {
      item = path2.join(dir, item);
      remove2.removeSync(item);
    });
  }
  empty = {
    emptyDirSync,
    emptydirSync: emptyDirSync,
    emptyDir,
    emptydir: emptyDir
  };
  return empty;
}
var file;
var hasRequiredFile$1;
function requireFile$1() {
  if (hasRequiredFile$1) return file;
  hasRequiredFile$1 = 1;
  const u = requireUniversalify().fromCallback;
  const path2 = require$$1$3;
  const fs2 = requireGracefulFs();
  const mkdir = requireMkdirs();
  const pathExists = requirePathExists().pathExists;
  function createFile(file2, callback) {
    function makeFile() {
      fs2.writeFile(file2, "", (err) => {
        if (err) return callback(err);
        callback();
      });
    }
    fs2.stat(file2, (err, stats) => {
      if (!err && stats.isFile()) return callback();
      const dir = path2.dirname(file2);
      pathExists(dir, (err2, dirExists) => {
        if (err2) return callback(err2);
        if (dirExists) return makeFile();
        mkdir.mkdirs(dir, (err3) => {
          if (err3) return callback(err3);
          makeFile();
        });
      });
    });
  }
  function createFileSync(file2) {
    let stats;
    try {
      stats = fs2.statSync(file2);
    } catch (e) {
    }
    if (stats && stats.isFile()) return;
    const dir = path2.dirname(file2);
    if (!fs2.existsSync(dir)) {
      mkdir.mkdirsSync(dir);
    }
    fs2.writeFileSync(file2, "");
  }
  file = {
    createFile: u(createFile),
    createFileSync
  };
  return file;
}
var link;
var hasRequiredLink;
function requireLink() {
  if (hasRequiredLink) return link;
  hasRequiredLink = 1;
  const u = requireUniversalify().fromCallback;
  const path2 = require$$1$3;
  const fs2 = requireGracefulFs();
  const mkdir = requireMkdirs();
  const pathExists = requirePathExists().pathExists;
  function createLink(srcpath, dstpath, callback) {
    function makeLink(srcpath2, dstpath2) {
      fs2.link(srcpath2, dstpath2, (err) => {
        if (err) return callback(err);
        callback(null);
      });
    }
    pathExists(dstpath, (err, destinationExists) => {
      if (err) return callback(err);
      if (destinationExists) return callback(null);
      fs2.lstat(srcpath, (err2) => {
        if (err2) {
          err2.message = err2.message.replace("lstat", "ensureLink");
          return callback(err2);
        }
        const dir = path2.dirname(dstpath);
        pathExists(dir, (err3, dirExists) => {
          if (err3) return callback(err3);
          if (dirExists) return makeLink(srcpath, dstpath);
          mkdir.mkdirs(dir, (err4) => {
            if (err4) return callback(err4);
            makeLink(srcpath, dstpath);
          });
        });
      });
    });
  }
  function createLinkSync(srcpath, dstpath) {
    const destinationExists = fs2.existsSync(dstpath);
    if (destinationExists) return void 0;
    try {
      fs2.lstatSync(srcpath);
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureLink");
      throw err;
    }
    const dir = path2.dirname(dstpath);
    const dirExists = fs2.existsSync(dir);
    if (dirExists) return fs2.linkSync(srcpath, dstpath);
    mkdir.mkdirsSync(dir);
    return fs2.linkSync(srcpath, dstpath);
  }
  link = {
    createLink: u(createLink),
    createLinkSync
  };
  return link;
}
var symlinkPaths_1;
var hasRequiredSymlinkPaths;
function requireSymlinkPaths() {
  if (hasRequiredSymlinkPaths) return symlinkPaths_1;
  hasRequiredSymlinkPaths = 1;
  const path2 = require$$1$3;
  const fs2 = requireGracefulFs();
  const pathExists = requirePathExists().pathExists;
  function symlinkPaths(srcpath, dstpath, callback) {
    if (path2.isAbsolute(srcpath)) {
      return fs2.lstat(srcpath, (err) => {
        if (err) {
          err.message = err.message.replace("lstat", "ensureSymlink");
          return callback(err);
        }
        return callback(null, {
          "toCwd": srcpath,
          "toDst": srcpath
        });
      });
    } else {
      const dstdir = path2.dirname(dstpath);
      const relativeToDst = path2.join(dstdir, srcpath);
      return pathExists(relativeToDst, (err, exists) => {
        if (err) return callback(err);
        if (exists) {
          return callback(null, {
            "toCwd": relativeToDst,
            "toDst": srcpath
          });
        } else {
          return fs2.lstat(srcpath, (err2) => {
            if (err2) {
              err2.message = err2.message.replace("lstat", "ensureSymlink");
              return callback(err2);
            }
            return callback(null, {
              "toCwd": srcpath,
              "toDst": path2.relative(dstdir, srcpath)
            });
          });
        }
      });
    }
  }
  function symlinkPathsSync(srcpath, dstpath) {
    let exists;
    if (path2.isAbsolute(srcpath)) {
      exists = fs2.existsSync(srcpath);
      if (!exists) throw new Error("absolute srcpath does not exist");
      return {
        "toCwd": srcpath,
        "toDst": srcpath
      };
    } else {
      const dstdir = path2.dirname(dstpath);
      const relativeToDst = path2.join(dstdir, srcpath);
      exists = fs2.existsSync(relativeToDst);
      if (exists) {
        return {
          "toCwd": relativeToDst,
          "toDst": srcpath
        };
      } else {
        exists = fs2.existsSync(srcpath);
        if (!exists) throw new Error("relative srcpath does not exist");
        return {
          "toCwd": srcpath,
          "toDst": path2.relative(dstdir, srcpath)
        };
      }
    }
  }
  symlinkPaths_1 = {
    symlinkPaths,
    symlinkPathsSync
  };
  return symlinkPaths_1;
}
var symlinkType_1;
var hasRequiredSymlinkType;
function requireSymlinkType() {
  if (hasRequiredSymlinkType) return symlinkType_1;
  hasRequiredSymlinkType = 1;
  const fs2 = requireGracefulFs();
  function symlinkType(srcpath, type2, callback) {
    callback = typeof type2 === "function" ? type2 : callback;
    type2 = typeof type2 === "function" ? false : type2;
    if (type2) return callback(null, type2);
    fs2.lstat(srcpath, (err, stats) => {
      if (err) return callback(null, "file");
      type2 = stats && stats.isDirectory() ? "dir" : "file";
      callback(null, type2);
    });
  }
  function symlinkTypeSync(srcpath, type2) {
    let stats;
    if (type2) return type2;
    try {
      stats = fs2.lstatSync(srcpath);
    } catch (e) {
      return "file";
    }
    return stats && stats.isDirectory() ? "dir" : "file";
  }
  symlinkType_1 = {
    symlinkType,
    symlinkTypeSync
  };
  return symlinkType_1;
}
var symlink;
var hasRequiredSymlink;
function requireSymlink() {
  if (hasRequiredSymlink) return symlink;
  hasRequiredSymlink = 1;
  const u = requireUniversalify().fromCallback;
  const path2 = require$$1$3;
  const fs2 = requireGracefulFs();
  const _mkdirs = requireMkdirs();
  const mkdirs = _mkdirs.mkdirs;
  const mkdirsSync = _mkdirs.mkdirsSync;
  const _symlinkPaths = requireSymlinkPaths();
  const symlinkPaths = _symlinkPaths.symlinkPaths;
  const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
  const _symlinkType = requireSymlinkType();
  const symlinkType = _symlinkType.symlinkType;
  const symlinkTypeSync = _symlinkType.symlinkTypeSync;
  const pathExists = requirePathExists().pathExists;
  function createSymlink(srcpath, dstpath, type2, callback) {
    callback = typeof type2 === "function" ? type2 : callback;
    type2 = typeof type2 === "function" ? false : type2;
    pathExists(dstpath, (err, destinationExists) => {
      if (err) return callback(err);
      if (destinationExists) return callback(null);
      symlinkPaths(srcpath, dstpath, (err2, relative) => {
        if (err2) return callback(err2);
        srcpath = relative.toDst;
        symlinkType(relative.toCwd, type2, (err3, type22) => {
          if (err3) return callback(err3);
          const dir = path2.dirname(dstpath);
          pathExists(dir, (err4, dirExists) => {
            if (err4) return callback(err4);
            if (dirExists) return fs2.symlink(srcpath, dstpath, type22, callback);
            mkdirs(dir, (err5) => {
              if (err5) return callback(err5);
              fs2.symlink(srcpath, dstpath, type22, callback);
            });
          });
        });
      });
    });
  }
  function createSymlinkSync(srcpath, dstpath, type2) {
    const destinationExists = fs2.existsSync(dstpath);
    if (destinationExists) return void 0;
    const relative = symlinkPathsSync(srcpath, dstpath);
    srcpath = relative.toDst;
    type2 = symlinkTypeSync(relative.toCwd, type2);
    const dir = path2.dirname(dstpath);
    const exists = fs2.existsSync(dir);
    if (exists) return fs2.symlinkSync(srcpath, dstpath, type2);
    mkdirsSync(dir);
    return fs2.symlinkSync(srcpath, dstpath, type2);
  }
  symlink = {
    createSymlink: u(createSymlink),
    createSymlinkSync
  };
  return symlink;
}
var ensure;
var hasRequiredEnsure;
function requireEnsure() {
  if (hasRequiredEnsure) return ensure;
  hasRequiredEnsure = 1;
  const file2 = requireFile$1();
  const link2 = requireLink();
  const symlink2 = requireSymlink();
  ensure = {
    // file
    createFile: file2.createFile,
    createFileSync: file2.createFileSync,
    ensureFile: file2.createFile,
    ensureFileSync: file2.createFileSync,
    // link
    createLink: link2.createLink,
    createLinkSync: link2.createLinkSync,
    ensureLink: link2.createLink,
    ensureLinkSync: link2.createLinkSync,
    // symlink
    createSymlink: symlink2.createSymlink,
    createSymlinkSync: symlink2.createSymlinkSync,
    ensureSymlink: symlink2.createSymlink,
    ensureSymlinkSync: symlink2.createSymlinkSync
  };
  return ensure;
}
var jsonfile_1;
var hasRequiredJsonfile$1;
function requireJsonfile$1() {
  if (hasRequiredJsonfile$1) return jsonfile_1;
  hasRequiredJsonfile$1 = 1;
  var _fs;
  try {
    _fs = requireGracefulFs();
  } catch (_) {
    _fs = require$$1$2;
  }
  function readFile(file2, options, callback) {
    if (callback == null) {
      callback = options;
      options = {};
    }
    if (typeof options === "string") {
      options = { encoding: options };
    }
    options = options || {};
    var fs2 = options.fs || _fs;
    var shouldThrow = true;
    if ("throws" in options) {
      shouldThrow = options.throws;
    }
    fs2.readFile(file2, options, function(err, data2) {
      if (err) return callback(err);
      data2 = stripBom(data2);
      var obj;
      try {
        obj = JSON.parse(data2, options ? options.reviver : null);
      } catch (err2) {
        if (shouldThrow) {
          err2.message = file2 + ": " + err2.message;
          return callback(err2);
        } else {
          return callback(null, null);
        }
      }
      callback(null, obj);
    });
  }
  function readFileSync(file2, options) {
    options = options || {};
    if (typeof options === "string") {
      options = { encoding: options };
    }
    var fs2 = options.fs || _fs;
    var shouldThrow = true;
    if ("throws" in options) {
      shouldThrow = options.throws;
    }
    try {
      var content = fs2.readFileSync(file2, options);
      content = stripBom(content);
      return JSON.parse(content, options.reviver);
    } catch (err) {
      if (shouldThrow) {
        err.message = file2 + ": " + err.message;
        throw err;
      } else {
        return null;
      }
    }
  }
  function stringify2(obj, options) {
    var spaces;
    var EOL = "\n";
    if (typeof options === "object" && options !== null) {
      if (options.spaces) {
        spaces = options.spaces;
      }
      if (options.EOL) {
        EOL = options.EOL;
      }
    }
    var str = JSON.stringify(obj, options ? options.replacer : null, spaces);
    return str.replace(/\n/g, EOL) + EOL;
  }
  function writeFile(file2, obj, options, callback) {
    if (callback == null) {
      callback = options;
      options = {};
    }
    options = options || {};
    var fs2 = options.fs || _fs;
    var str = "";
    try {
      str = stringify2(obj, options);
    } catch (err) {
      if (callback) callback(err, null);
      return;
    }
    fs2.writeFile(file2, str, options, callback);
  }
  function writeFileSync(file2, obj, options) {
    options = options || {};
    var fs2 = options.fs || _fs;
    var str = stringify2(obj, options);
    return fs2.writeFileSync(file2, str, options);
  }
  function stripBom(content) {
    if (Buffer.isBuffer(content)) content = content.toString("utf8");
    content = content.replace(/^\uFEFF/, "");
    return content;
  }
  var jsonfile2 = {
    readFile,
    readFileSync,
    writeFile,
    writeFileSync
  };
  jsonfile_1 = jsonfile2;
  return jsonfile_1;
}
var jsonfile;
var hasRequiredJsonfile;
function requireJsonfile() {
  if (hasRequiredJsonfile) return jsonfile;
  hasRequiredJsonfile = 1;
  const u = requireUniversalify().fromCallback;
  const jsonFile = requireJsonfile$1();
  jsonfile = {
    // jsonfile exports
    readJson: u(jsonFile.readFile),
    readJsonSync: jsonFile.readFileSync,
    writeJson: u(jsonFile.writeFile),
    writeJsonSync: jsonFile.writeFileSync
  };
  return jsonfile;
}
var outputJson_1;
var hasRequiredOutputJson;
function requireOutputJson() {
  if (hasRequiredOutputJson) return outputJson_1;
  hasRequiredOutputJson = 1;
  const path2 = require$$1$3;
  const mkdir = requireMkdirs();
  const pathExists = requirePathExists().pathExists;
  const jsonFile = requireJsonfile();
  function outputJson(file2, data2, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    const dir = path2.dirname(file2);
    pathExists(dir, (err, itDoes) => {
      if (err) return callback(err);
      if (itDoes) return jsonFile.writeJson(file2, data2, options, callback);
      mkdir.mkdirs(dir, (err2) => {
        if (err2) return callback(err2);
        jsonFile.writeJson(file2, data2, options, callback);
      });
    });
  }
  outputJson_1 = outputJson;
  return outputJson_1;
}
var outputJsonSync_1;
var hasRequiredOutputJsonSync;
function requireOutputJsonSync() {
  if (hasRequiredOutputJsonSync) return outputJsonSync_1;
  hasRequiredOutputJsonSync = 1;
  const fs2 = requireGracefulFs();
  const path2 = require$$1$3;
  const mkdir = requireMkdirs();
  const jsonFile = requireJsonfile();
  function outputJsonSync(file2, data2, options) {
    const dir = path2.dirname(file2);
    if (!fs2.existsSync(dir)) {
      mkdir.mkdirsSync(dir);
    }
    jsonFile.writeJsonSync(file2, data2, options);
  }
  outputJsonSync_1 = outputJsonSync;
  return outputJsonSync_1;
}
var json;
var hasRequiredJson$1;
function requireJson$1() {
  if (hasRequiredJson$1) return json;
  hasRequiredJson$1 = 1;
  const u = requireUniversalify().fromCallback;
  const jsonFile = requireJsonfile();
  jsonFile.outputJson = u(requireOutputJson());
  jsonFile.outputJsonSync = requireOutputJsonSync();
  jsonFile.outputJSON = jsonFile.outputJson;
  jsonFile.outputJSONSync = jsonFile.outputJsonSync;
  jsonFile.writeJSON = jsonFile.writeJson;
  jsonFile.writeJSONSync = jsonFile.writeJsonSync;
  jsonFile.readJSON = jsonFile.readJson;
  jsonFile.readJSONSync = jsonFile.readJsonSync;
  json = jsonFile;
  return json;
}
var moveSync_1;
var hasRequiredMoveSync$1;
function requireMoveSync$1() {
  if (hasRequiredMoveSync$1) return moveSync_1;
  hasRequiredMoveSync$1 = 1;
  const fs2 = requireGracefulFs();
  const path2 = require$$1$3;
  const copySync2 = requireCopySync().copySync;
  const removeSync = requireRemove().removeSync;
  const mkdirpSync = requireMkdirs().mkdirpSync;
  const stat2 = requireStat();
  function moveSync2(src, dest, opts) {
    opts = opts || {};
    const overwrite = opts.overwrite || opts.clobber || false;
    const { srcStat } = stat2.checkPathsSync(src, dest, "move");
    stat2.checkParentPathsSync(src, srcStat, dest, "move");
    mkdirpSync(path2.dirname(dest));
    return doRename(src, dest, overwrite);
  }
  function doRename(src, dest, overwrite) {
    if (overwrite) {
      removeSync(dest);
      return rename(src, dest, overwrite);
    }
    if (fs2.existsSync(dest)) throw new Error("dest already exists.");
    return rename(src, dest, overwrite);
  }
  function rename(src, dest, overwrite) {
    try {
      fs2.renameSync(src, dest);
    } catch (err) {
      if (err.code !== "EXDEV") throw err;
      return moveAcrossDevice(src, dest, overwrite);
    }
  }
  function moveAcrossDevice(src, dest, overwrite) {
    const opts = {
      overwrite,
      errorOnExist: true
    };
    copySync2(src, dest, opts);
    return removeSync(src);
  }
  moveSync_1 = moveSync2;
  return moveSync_1;
}
var moveSync;
var hasRequiredMoveSync;
function requireMoveSync() {
  if (hasRequiredMoveSync) return moveSync;
  hasRequiredMoveSync = 1;
  moveSync = {
    moveSync: requireMoveSync$1()
  };
  return moveSync;
}
var move_1;
var hasRequiredMove$1;
function requireMove$1() {
  if (hasRequiredMove$1) return move_1;
  hasRequiredMove$1 = 1;
  const fs2 = requireGracefulFs();
  const path2 = require$$1$3;
  const copy2 = requireCopy().copy;
  const remove2 = requireRemove().remove;
  const mkdirp = requireMkdirs().mkdirp;
  const pathExists = requirePathExists().pathExists;
  const stat2 = requireStat();
  function move2(src, dest, opts, cb) {
    if (typeof opts === "function") {
      cb = opts;
      opts = {};
    }
    const overwrite = opts.overwrite || opts.clobber || false;
    stat2.checkPaths(src, dest, "move", (err, stats) => {
      if (err) return cb(err);
      const { srcStat } = stats;
      stat2.checkParentPaths(src, srcStat, dest, "move", (err2) => {
        if (err2) return cb(err2);
        mkdirp(path2.dirname(dest), (err3) => {
          if (err3) return cb(err3);
          return doRename(src, dest, overwrite, cb);
        });
      });
    });
  }
  function doRename(src, dest, overwrite, cb) {
    if (overwrite) {
      return remove2(dest, (err) => {
        if (err) return cb(err);
        return rename(src, dest, overwrite, cb);
      });
    }
    pathExists(dest, (err, destExists) => {
      if (err) return cb(err);
      if (destExists) return cb(new Error("dest already exists."));
      return rename(src, dest, overwrite, cb);
    });
  }
  function rename(src, dest, overwrite, cb) {
    fs2.rename(src, dest, (err) => {
      if (!err) return cb();
      if (err.code !== "EXDEV") return cb(err);
      return moveAcrossDevice(src, dest, overwrite, cb);
    });
  }
  function moveAcrossDevice(src, dest, overwrite, cb) {
    const opts = {
      overwrite,
      errorOnExist: true
    };
    copy2(src, dest, opts, (err) => {
      if (err) return cb(err);
      return remove2(src, cb);
    });
  }
  move_1 = move2;
  return move_1;
}
var move;
var hasRequiredMove;
function requireMove() {
  if (hasRequiredMove) return move;
  hasRequiredMove = 1;
  const u = requireUniversalify().fromCallback;
  move = {
    move: u(requireMove$1())
  };
  return move;
}
var output;
var hasRequiredOutput;
function requireOutput() {
  if (hasRequiredOutput) return output;
  hasRequiredOutput = 1;
  const u = requireUniversalify().fromCallback;
  const fs2 = requireGracefulFs();
  const path2 = require$$1$3;
  const mkdir = requireMkdirs();
  const pathExists = requirePathExists().pathExists;
  function outputFile(file2, data2, encoding2, callback) {
    if (typeof encoding2 === "function") {
      callback = encoding2;
      encoding2 = "utf8";
    }
    const dir = path2.dirname(file2);
    pathExists(dir, (err, itDoes) => {
      if (err) return callback(err);
      if (itDoes) return fs2.writeFile(file2, data2, encoding2, callback);
      mkdir.mkdirs(dir, (err2) => {
        if (err2) return callback(err2);
        fs2.writeFile(file2, data2, encoding2, callback);
      });
    });
  }
  function outputFileSync(file2, ...args) {
    const dir = path2.dirname(file2);
    if (fs2.existsSync(dir)) {
      return fs2.writeFileSync(file2, ...args);
    }
    mkdir.mkdirsSync(dir);
    fs2.writeFileSync(file2, ...args);
  }
  output = {
    outputFile: u(outputFile),
    outputFileSync
  };
  return output;
}
var hasRequiredLib$1$2;
function requireLib$1$2() {
  if (hasRequiredLib$1$2) return lib$1$2.exports;
  hasRequiredLib$1$2 = 1;
  (function(module) {
    module.exports = Object.assign(
      {},
      // Export promiseified graceful-fs:
      requireFs(),
      // Export extra methods:
      requireCopySync(),
      requireCopy(),
      requireEmpty(),
      requireEnsure(),
      requireJson$1(),
      requireMkdirs(),
      requireMoveSync(),
      requireMove(),
      requireOutput(),
      requirePathExists(),
      requireRemove()
    );
    const fs2 = require$$1$2;
    if (Object.getOwnPropertyDescriptor(fs2, "promises")) {
      Object.defineProperty(module.exports, "promises", {
        get() {
          return fs2.promises;
        }
      });
    }
  })(lib$1$2);
  return lib$1$2.exports;
}
var now;
var hasRequiredNow;
function requireNow() {
  if (hasRequiredNow) return now;
  hasRequiredNow = 1;
  now = () => /* @__PURE__ */ new Date();
  return now;
}
var fileNameFormatter;
var hasRequiredFileNameFormatter;
function requireFileNameFormatter() {
  if (hasRequiredFileNameFormatter) return fileNameFormatter;
  hasRequiredFileNameFormatter = 1;
  const debug2 = requireBrowser$4()("streamroller:fileNameFormatter");
  const path2 = require$$1$3;
  const ZIP_EXT = ".gz";
  const DEFAULT_FILENAME_SEP = ".";
  fileNameFormatter = ({
    file: file2,
    keepFileExt,
    needsIndex,
    alwaysIncludeDate,
    compress,
    fileNameSep
  }) => {
    let FILENAME_SEP = fileNameSep || DEFAULT_FILENAME_SEP;
    const dirAndName = path2.join(file2.dir, file2.name);
    const ext = (f) => f + file2.ext;
    const index2 = (f, i, d) => (needsIndex || !d) && i ? f + FILENAME_SEP + i : f;
    const date = (f, i, d) => {
      return (i > 0 || alwaysIncludeDate) && d ? f + FILENAME_SEP + d : f;
    };
    const gzip = (f, i) => i && compress ? f + ZIP_EXT : f;
    const parts = keepFileExt ? [date, index2, ext, gzip] : [ext, date, index2, gzip];
    return ({ date: date2, index: index22 }) => {
      debug2(`_formatFileName: date=${date2}, index=${index22}`);
      return parts.reduce(
        (filename, part) => part(filename, index22, date2),
        dirAndName
      );
    };
  };
  return fileNameFormatter;
}
var fileNameParser;
var hasRequiredFileNameParser;
function requireFileNameParser() {
  if (hasRequiredFileNameParser) return fileNameParser;
  hasRequiredFileNameParser = 1;
  const debug2 = requireBrowser$4()("streamroller:fileNameParser");
  const ZIP_EXT = ".gz";
  const format = requireLib$2$1();
  const DEFAULT_FILENAME_SEP = ".";
  fileNameParser = ({ file: file2, keepFileExt, pattern, fileNameSep }) => {
    let FILENAME_SEP = fileNameSep || DEFAULT_FILENAME_SEP;
    const zip = (f, p) => {
      if (f.endsWith(ZIP_EXT)) {
        debug2("it is gzipped");
        p.isCompressed = true;
        return f.slice(0, -1 * ZIP_EXT.length);
      }
      return f;
    };
    const __NOT_MATCHING__ = "__NOT_MATCHING__";
    const extAtEnd = (f) => {
      if (f.startsWith(file2.name) && f.endsWith(file2.ext)) {
        debug2("it starts and ends with the right things");
        return f.slice(file2.name.length + 1, -1 * file2.ext.length);
      }
      return __NOT_MATCHING__;
    };
    const extInMiddle = (f) => {
      if (f.startsWith(file2.base)) {
        debug2("it starts with the right things");
        return f.slice(file2.base.length + 1);
      }
      return __NOT_MATCHING__;
    };
    const dateAndIndex = (f, p) => {
      const items = f.split(FILENAME_SEP);
      let indexStr = items[items.length - 1];
      debug2("items: ", items, ", indexStr: ", indexStr);
      let dateStr = f;
      if (indexStr !== void 0 && indexStr.match(/^\d+$/)) {
        dateStr = f.slice(0, -1 * (indexStr.length + 1));
        debug2(`dateStr is ${dateStr}`);
        if (pattern && !dateStr) {
          dateStr = indexStr;
          indexStr = "0";
        }
      } else {
        indexStr = "0";
      }
      try {
        const date = format.parse(pattern, dateStr, new Date(0, 0));
        if (format.asString(pattern, date) !== dateStr) return f;
        p.index = parseInt(indexStr, 10);
        p.date = dateStr;
        p.timestamp = date.getTime();
        return "";
      } catch (e) {
        debug2(`Problem parsing ${dateStr} as ${pattern}, error was: `, e);
        return f;
      }
    };
    const index2 = (f, p) => {
      if (f.match(/^\d+$/)) {
        debug2("it has an index");
        p.index = parseInt(f, 10);
        return "";
      }
      return f;
    };
    let parts = [
      zip,
      keepFileExt ? extAtEnd : extInMiddle,
      pattern ? dateAndIndex : index2
    ];
    return (filename) => {
      let result = { filename, index: 0, isCompressed: false };
      let whatsLeftOver = parts.reduce(
        (remains, part) => part(remains, result),
        filename
      );
      return whatsLeftOver ? null : result;
    };
  };
  return fileNameParser;
}
var moveAndMaybeCompressFile_1;
var hasRequiredMoveAndMaybeCompressFile;
function requireMoveAndMaybeCompressFile() {
  if (hasRequiredMoveAndMaybeCompressFile) return moveAndMaybeCompressFile_1;
  hasRequiredMoveAndMaybeCompressFile = 1;
  const debug2 = requireBrowser$4()("streamroller:moveAndMaybeCompressFile");
  const fs2 = requireLib$1$2();
  const zlib$1 = zlib;
  const _parseOption = function(rawOptions) {
    const defaultOptions = {
      mode: parseInt("0600", 8),
      compress: false
    };
    const options = Object.assign({}, defaultOptions, rawOptions);
    debug2(`_parseOption: moveAndMaybeCompressFile called with option=${JSON.stringify(options)}`);
    return options;
  };
  const moveAndMaybeCompressFile = async (sourceFilePath, targetFilePath, options) => {
    options = _parseOption(options);
    if (sourceFilePath === targetFilePath) {
      debug2(`moveAndMaybeCompressFile: source and target are the same, not doing anything`);
      return;
    }
    if (await fs2.pathExists(sourceFilePath)) {
      debug2(
        `moveAndMaybeCompressFile: moving file from ${sourceFilePath} to ${targetFilePath} ${options.compress ? "with" : "without"} compress`
      );
      if (options.compress) {
        await new Promise((resolve, reject) => {
          let isCreated = false;
          const writeStream = fs2.createWriteStream(targetFilePath, { mode: options.mode, flags: "wx" }).on("open", () => {
            isCreated = true;
            const readStream2 = fs2.createReadStream(sourceFilePath).on("open", () => {
              readStream2.pipe(zlib$1.createGzip()).pipe(writeStream);
            }).on("error", (e) => {
              debug2(`moveAndMaybeCompressFile: error reading ${sourceFilePath}`, e);
              writeStream.destroy(e);
            });
          }).on("finish", () => {
            debug2(`moveAndMaybeCompressFile: finished compressing ${targetFilePath}, deleting ${sourceFilePath}`);
            fs2.unlink(sourceFilePath).then(resolve).catch((e) => {
              debug2(`moveAndMaybeCompressFile: error deleting ${sourceFilePath}, truncating instead`, e);
              fs2.truncate(sourceFilePath).then(resolve).catch((e2) => {
                debug2(`moveAndMaybeCompressFile: error truncating ${sourceFilePath}`, e2);
                reject(e2);
              });
            });
          }).on("error", (e) => {
            if (!isCreated) {
              debug2(`moveAndMaybeCompressFile: error creating ${targetFilePath}`, e);
              reject(e);
            } else {
              debug2(`moveAndMaybeCompressFile: error writing ${targetFilePath}, deleting`, e);
              fs2.unlink(targetFilePath).then(() => {
                reject(e);
              }).catch((e2) => {
                debug2(`moveAndMaybeCompressFile: error deleting ${targetFilePath}`, e2);
                reject(e2);
              });
            }
          });
        }).catch(() => {
        });
      } else {
        debug2(`moveAndMaybeCompressFile: renaming ${sourceFilePath} to ${targetFilePath}`);
        try {
          await fs2.move(sourceFilePath, targetFilePath, { overwrite: true });
        } catch (e) {
          debug2(`moveAndMaybeCompressFile: error renaming ${sourceFilePath} to ${targetFilePath}`, e);
          if (e.code !== "ENOENT") {
            debug2(`moveAndMaybeCompressFile: trying copy+truncate instead`);
            try {
              await fs2.copy(sourceFilePath, targetFilePath, { overwrite: true });
              await fs2.truncate(sourceFilePath);
            } catch (e2) {
              debug2(`moveAndMaybeCompressFile: error copy+truncate`, e2);
            }
          }
        }
      }
    }
  };
  moveAndMaybeCompressFile_1 = moveAndMaybeCompressFile;
  return moveAndMaybeCompressFile_1;
}
var RollingFileWriteStream_1;
var hasRequiredRollingFileWriteStream;
function requireRollingFileWriteStream() {
  if (hasRequiredRollingFileWriteStream) return RollingFileWriteStream_1;
  hasRequiredRollingFileWriteStream = 1;
  const debug2 = requireBrowser$4()("streamroller:RollingFileWriteStream");
  const fs2 = requireLib$1$2();
  const path2 = require$$1$3;
  const os = require$$1$1;
  const newNow = requireNow();
  const format = requireLib$2$1();
  const { Writable } = stream;
  const fileNameFormatter2 = requireFileNameFormatter();
  const fileNameParser2 = requireFileNameParser();
  const moveAndMaybeCompressFile = requireMoveAndMaybeCompressFile();
  const deleteFiles = (fileNames) => {
    debug2(`deleteFiles: files to delete: ${fileNames}`);
    return Promise.all(fileNames.map((f) => fs2.unlink(f).catch((e) => {
      debug2(`deleteFiles: error when unlinking ${f}, ignoring. Error was ${e}`);
    })));
  };
  class RollingFileWriteStream extends Writable {
    /**
     * Create a RollingFileWriteStream
     * @constructor
     * @param {string} filePath - The file path to write.
     * @param {object} options - The extra options
     * @param {number} options.numToKeep - The max numbers of files to keep.
     * @param {number} options.maxSize - The maxSize one file can reach. Unit is Byte.
     *                                   This should be more than 1024. The default is 0.
     *                                   If not specified or 0, then no log rolling will happen.
     * @param {string} options.mode - The mode of the files. The default is '0600'. Refer to stream.writable for more.
     * @param {string} options.flags - The default is 'a'. Refer to stream.flags for more.
     * @param {boolean} options.compress - Whether to compress backup files.
     * @param {boolean} options.keepFileExt - Whether to keep the file extension.
     * @param {string} options.pattern - The date string pattern in the file name.
     * @param {boolean} options.alwaysIncludePattern - Whether to add date to the name of the first file.
     */
    constructor(filePath, options) {
      debug2(`constructor: creating RollingFileWriteStream. path=${filePath}`);
      if (typeof filePath !== "string" || filePath.length === 0) {
        throw new Error(`Invalid filename: ${filePath}`);
      } else if (filePath.endsWith(path2.sep)) {
        throw new Error(`Filename is a directory: ${filePath}`);
      } else if (filePath.indexOf(`~${path2.sep}`) === 0) {
        filePath = filePath.replace("~", os.homedir());
      }
      super(options);
      this.options = this._parseOption(options);
      this.fileObject = path2.parse(filePath);
      if (this.fileObject.dir === "") {
        this.fileObject = path2.parse(path2.join(process.cwd(), filePath));
      }
      this.fileFormatter = fileNameFormatter2({
        file: this.fileObject,
        alwaysIncludeDate: this.options.alwaysIncludePattern,
        needsIndex: this.options.maxSize < Number.MAX_SAFE_INTEGER,
        compress: this.options.compress,
        keepFileExt: this.options.keepFileExt,
        fileNameSep: this.options.fileNameSep
      });
      this.fileNameParser = fileNameParser2({
        file: this.fileObject,
        keepFileExt: this.options.keepFileExt,
        pattern: this.options.pattern,
        fileNameSep: this.options.fileNameSep
      });
      this.state = {
        currentSize: 0
      };
      if (this.options.pattern) {
        this.state.currentDate = format(this.options.pattern, newNow());
      }
      this.filename = this.fileFormatter({
        index: 0,
        date: this.state.currentDate
      });
      if (["a", "a+", "as", "as+"].includes(this.options.flags)) {
        this._setExistingSizeAndDate();
      }
      debug2(
        `constructor: create new file ${this.filename}, state=${JSON.stringify(
          this.state
        )}`
      );
      this._renewWriteStream();
    }
    _setExistingSizeAndDate() {
      try {
        const stats = fs2.statSync(this.filename);
        this.state.currentSize = stats.size;
        if (this.options.pattern) {
          this.state.currentDate = format(this.options.pattern, stats.mtime);
        }
      } catch (e) {
        return;
      }
    }
    _parseOption(rawOptions) {
      const defaultOptions = {
        maxSize: 0,
        numToKeep: Number.MAX_SAFE_INTEGER,
        encoding: "utf8",
        mode: parseInt("0600", 8),
        flags: "a",
        compress: false,
        keepFileExt: false,
        alwaysIncludePattern: false
      };
      const options = Object.assign({}, defaultOptions, rawOptions);
      if (!options.maxSize) {
        delete options.maxSize;
      } else if (options.maxSize <= 0) {
        throw new Error(`options.maxSize (${options.maxSize}) should be > 0`);
      }
      if (options.numBackups || options.numBackups === 0) {
        if (options.numBackups < 0) {
          throw new Error(`options.numBackups (${options.numBackups}) should be >= 0`);
        } else if (options.numBackups >= Number.MAX_SAFE_INTEGER) {
          throw new Error(`options.numBackups (${options.numBackups}) should be < Number.MAX_SAFE_INTEGER`);
        } else {
          options.numToKeep = options.numBackups + 1;
        }
      } else if (options.numToKeep <= 0) {
        throw new Error(`options.numToKeep (${options.numToKeep}) should be > 0`);
      }
      debug2(
        `_parseOption: creating stream with option=${JSON.stringify(options)}`
      );
      return options;
    }
    _final(callback) {
      this.currentFileStream.end("", this.options.encoding, callback);
    }
    _write(chunk, encoding2, callback) {
      this._shouldRoll().then(() => {
        debug2(
          `_write: writing chunk. file=${this.currentFileStream.path} state=${JSON.stringify(this.state)} chunk=${chunk}`
        );
        this.currentFileStream.write(chunk, encoding2, (e) => {
          this.state.currentSize += chunk.length;
          callback(e);
        });
      });
    }
    async _shouldRoll() {
      if (this._dateChanged() || this._tooBig()) {
        debug2(
          `_shouldRoll: rolling because dateChanged? ${this._dateChanged()} or tooBig? ${this._tooBig()}`
        );
        await this._roll();
      }
    }
    _dateChanged() {
      return this.state.currentDate && this.state.currentDate !== format(this.options.pattern, newNow());
    }
    _tooBig() {
      return this.state.currentSize >= this.options.maxSize;
    }
    _roll() {
      debug2(`_roll: closing the current stream`);
      return new Promise((resolve, reject) => {
        this.currentFileStream.end("", this.options.encoding, () => {
          this._moveOldFiles().then(resolve).catch(reject);
        });
      });
    }
    async _moveOldFiles() {
      const files = await this._getExistingFiles();
      const todaysFiles = this.state.currentDate ? files.filter((f) => f.date === this.state.currentDate) : files;
      for (let i = todaysFiles.length; i >= 0; i--) {
        debug2(`_moveOldFiles: i = ${i}`);
        const sourceFilePath = this.fileFormatter({
          date: this.state.currentDate,
          index: i
        });
        const targetFilePath = this.fileFormatter({
          date: this.state.currentDate,
          index: i + 1
        });
        const moveAndCompressOptions = {
          compress: this.options.compress && i === 0,
          mode: this.options.mode
        };
        await moveAndMaybeCompressFile(
          sourceFilePath,
          targetFilePath,
          moveAndCompressOptions
        );
      }
      this.state.currentSize = 0;
      this.state.currentDate = this.state.currentDate ? format(this.options.pattern, newNow()) : null;
      debug2(
        `_moveOldFiles: finished rolling files. state=${JSON.stringify(
          this.state
        )}`
      );
      this._renewWriteStream();
      await new Promise((resolve, reject) => {
        this.currentFileStream.write("", "utf8", () => {
          this._clean().then(resolve).catch(reject);
        });
      });
    }
    // Sorted from the oldest to the latest
    async _getExistingFiles() {
      const files = await fs2.readdir(this.fileObject.dir).catch(
        /* istanbul ignore next: will not happen on windows */
        () => []
      );
      debug2(`_getExistingFiles: files=${files}`);
      const existingFileDetails = files.map((n) => this.fileNameParser(n)).filter((n) => n);
      const getKey = (n) => (n.timestamp ? n.timestamp : newNow().getTime()) - n.index;
      existingFileDetails.sort((a, b) => getKey(a) - getKey(b));
      return existingFileDetails;
    }
    _renewWriteStream() {
      const filePath = this.fileFormatter({
        date: this.state.currentDate,
        index: 0
      });
      const mkdir = (dir) => {
        try {
          return fs2.mkdirSync(dir, { recursive: true });
        } catch (e) {
          if (e.code === "ENOENT") {
            mkdir(path2.dirname(dir));
            return mkdir(dir);
          }
          if (e.code !== "EEXIST" && e.code !== "EROFS") {
            throw e;
          } else {
            try {
              if (fs2.statSync(dir).isDirectory()) {
                return dir;
              }
              throw e;
            } catch (err) {
              throw e;
            }
          }
        }
      };
      mkdir(this.fileObject.dir);
      const ops = {
        flags: this.options.flags,
        encoding: this.options.encoding,
        mode: this.options.mode
      };
      const renameKey = function(obj, oldKey, newKey) {
        obj[newKey] = obj[oldKey];
        delete obj[oldKey];
        return obj;
      };
      fs2.appendFileSync(filePath, "", renameKey({ ...ops }, "flags", "flag"));
      this.currentFileStream = fs2.createWriteStream(filePath, ops);
      this.currentFileStream.on("error", (e) => {
        this.emit("error", e);
      });
    }
    async _clean() {
      const existingFileDetails = await this._getExistingFiles();
      debug2(
        `_clean: numToKeep = ${this.options.numToKeep}, existingFiles = ${existingFileDetails.length}`
      );
      debug2("_clean: existing files are: ", existingFileDetails);
      if (this._tooManyFiles(existingFileDetails.length)) {
        const fileNamesToRemove = existingFileDetails.slice(0, existingFileDetails.length - this.options.numToKeep).map((f) => path2.format({ dir: this.fileObject.dir, base: f.filename }));
        await deleteFiles(fileNamesToRemove);
      }
    }
    _tooManyFiles(numFiles) {
      return this.options.numToKeep > 0 && numFiles > this.options.numToKeep;
    }
  }
  RollingFileWriteStream_1 = RollingFileWriteStream;
  return RollingFileWriteStream_1;
}
var RollingFileStream_1;
var hasRequiredRollingFileStream;
function requireRollingFileStream() {
  if (hasRequiredRollingFileStream) return RollingFileStream_1;
  hasRequiredRollingFileStream = 1;
  const RollingFileWriteStream = requireRollingFileWriteStream();
  class RollingFileStream extends RollingFileWriteStream {
    constructor(filename, size, backups, options) {
      if (!options) {
        options = {};
      }
      if (size) {
        options.maxSize = size;
      }
      if (!options.numBackups && options.numBackups !== 0) {
        if (!backups && backups !== 0) {
          backups = 1;
        }
        options.numBackups = backups;
      }
      super(filename, options);
      this.backups = options.numBackups;
      this.size = this.options.maxSize;
    }
    get theStream() {
      return this.currentFileStream;
    }
  }
  RollingFileStream_1 = RollingFileStream;
  return RollingFileStream_1;
}
var DateRollingFileStream_1;
var hasRequiredDateRollingFileStream;
function requireDateRollingFileStream() {
  if (hasRequiredDateRollingFileStream) return DateRollingFileStream_1;
  hasRequiredDateRollingFileStream = 1;
  const RollingFileWriteStream = requireRollingFileWriteStream();
  class DateRollingFileStream extends RollingFileWriteStream {
    constructor(filename, pattern, options) {
      if (pattern && typeof pattern === "object") {
        options = pattern;
        pattern = null;
      }
      if (!options) {
        options = {};
      }
      if (!pattern) {
        pattern = "yyyy-MM-dd";
      }
      options.pattern = pattern;
      if (!options.numBackups && options.numBackups !== 0) {
        if (!options.daysToKeep && options.daysToKeep !== 0) {
          options.daysToKeep = 1;
        } else {
          process.emitWarning(
            "options.daysToKeep is deprecated due to the confusion it causes when used together with file size rolling. Please use options.numBackups instead.",
            "DeprecationWarning",
            "streamroller-DEP0001"
          );
        }
        options.numBackups = options.daysToKeep;
      } else {
        options.daysToKeep = options.numBackups;
      }
      super(filename, options);
      this.mode = this.options.mode;
    }
    get theStream() {
      return this.currentFileStream;
    }
  }
  DateRollingFileStream_1 = DateRollingFileStream;
  return DateRollingFileStream_1;
}
var lib$4;
var hasRequiredLib$4;
function requireLib$4() {
  if (hasRequiredLib$4) return lib$4;
  hasRequiredLib$4 = 1;
  lib$4 = {
    RollingFileWriteStream: requireRollingFileWriteStream(),
    RollingFileStream: requireRollingFileStream(),
    DateRollingFileStream: requireDateRollingFileStream()
  };
  return lib$4;
}
var hasRequiredFile;
function requireFile() {
  if (hasRequiredFile) return file$1;
  hasRequiredFile = 1;
  const debug2 = requireBrowser$4()("log4js:file");
  const path2 = require$$1$3;
  const streams2 = requireLib$4();
  const os = require$$1$1;
  const eol = os.EOL;
  let mainSighupListenerStarted = false;
  const sighupListeners = /* @__PURE__ */ new Set();
  function mainSighupHandler() {
    sighupListeners.forEach((app2) => {
      app2.sighupHandler();
    });
  }
  function fileAppender(file2, layout, logSize, numBackups, options, timezoneOffset) {
    if (typeof file2 !== "string" || file2.length === 0) {
      throw new Error(`Invalid filename: ${file2}`);
    } else if (file2.endsWith(path2.sep)) {
      throw new Error(`Filename is a directory: ${file2}`);
    } else if (file2.indexOf(`~${path2.sep}`) === 0) {
      file2 = file2.replace("~", os.homedir());
    }
    file2 = path2.normalize(file2);
    numBackups = !numBackups && numBackups !== 0 ? 5 : numBackups;
    debug2(
      "Creating file appender (",
      file2,
      ", ",
      logSize,
      ", ",
      numBackups,
      ", ",
      options,
      ", ",
      timezoneOffset,
      ")"
    );
    function openTheStream(filePath, fileSize, numFiles, opt) {
      const stream2 = new streams2.RollingFileStream(
        filePath,
        fileSize,
        numFiles,
        opt
      );
      stream2.on("error", (err) => {
        console.error(
          "log4js.fileAppender - Writing to file %s, error happened ",
          filePath,
          err
        );
      });
      stream2.on("drain", () => {
        process.emit("log4js:pause", false);
      });
      return stream2;
    }
    let writer = openTheStream(file2, logSize, numBackups, options);
    const app2 = function(loggingEvent) {
      if (!writer.writable) {
        return;
      }
      if (options.removeColor === true) {
        const regex2 = /\x1b[[0-9;]*m/g;
        loggingEvent.data = loggingEvent.data.map((d) => {
          if (typeof d === "string") return d.replace(regex2, "");
          return d;
        });
      }
      if (!writer.write(layout(loggingEvent, timezoneOffset) + eol, "utf8")) {
        process.emit("log4js:pause", true);
      }
    };
    app2.reopen = function() {
      writer.end(() => {
        writer = openTheStream(file2, logSize, numBackups, options);
      });
    };
    app2.sighupHandler = function() {
      debug2("SIGHUP handler called.");
      app2.reopen();
    };
    app2.shutdown = function(complete) {
      sighupListeners.delete(app2);
      if (sighupListeners.size === 0 && mainSighupListenerStarted) {
        process.removeListener("SIGHUP", mainSighupHandler);
        mainSighupListenerStarted = false;
      }
      writer.end("", "utf-8", complete);
    };
    sighupListeners.add(app2);
    if (!mainSighupListenerStarted) {
      process.on("SIGHUP", mainSighupHandler);
      mainSighupListenerStarted = true;
    }
    return app2;
  }
  function configure2(config, layouts2) {
    let layout = layouts2.basicLayout;
    if (config.layout) {
      layout = layouts2.layout(config.layout.type, config.layout);
    }
    config.mode = config.mode || 384;
    return fileAppender(
      config.filename,
      layout,
      config.maxLogSize,
      config.backups,
      config,
      config.timezoneOffset
    );
  }
  file$1.configure = configure2;
  return file$1;
}
var dateFile = {};
var hasRequiredDateFile;
function requireDateFile() {
  if (hasRequiredDateFile) return dateFile;
  hasRequiredDateFile = 1;
  const streams2 = requireLib$4();
  const os = require$$1$1;
  const eol = os.EOL;
  function openTheStream(filename, pattern, options) {
    const stream2 = new streams2.DateRollingFileStream(filename, pattern, options);
    stream2.on("error", (err) => {
      console.error(
        "log4js.dateFileAppender - Writing to file %s, error happened ",
        filename,
        err
      );
    });
    stream2.on("drain", () => {
      process.emit("log4js:pause", false);
    });
    return stream2;
  }
  function appender(filename, pattern, layout, options, timezoneOffset) {
    options.maxSize = options.maxLogSize;
    const writer = openTheStream(filename, pattern, options);
    const app2 = function(logEvent) {
      if (!writer.writable) {
        return;
      }
      if (!writer.write(layout(logEvent, timezoneOffset) + eol, "utf8")) {
        process.emit("log4js:pause", true);
      }
    };
    app2.shutdown = function(complete) {
      writer.end("", "utf-8", complete);
    };
    return app2;
  }
  function configure2(config, layouts2) {
    let layout = layouts2.basicLayout;
    if (config.layout) {
      layout = layouts2.layout(config.layout.type, config.layout);
    }
    if (!config.alwaysIncludePattern) {
      config.alwaysIncludePattern = false;
    }
    config.mode = config.mode || 384;
    return appender(
      config.filename,
      config.pattern,
      layout,
      config,
      config.timezoneOffset
    );
  }
  dateFile.configure = configure2;
  return dateFile;
}
var fileSync = {};
var hasRequiredFileSync;
function requireFileSync() {
  if (hasRequiredFileSync) return fileSync;
  hasRequiredFileSync = 1;
  const debug2 = requireBrowser$4()("log4js:fileSync");
  const path2 = require$$1$3;
  const fs2 = require$$1$2;
  const os = require$$1$1;
  const eol = os.EOL;
  function touchFile(file2, options) {
    const mkdir = (dir) => {
      try {
        return fs2.mkdirSync(dir, { recursive: true });
      } catch (e) {
        if (e.code === "ENOENT") {
          mkdir(path2.dirname(dir));
          return mkdir(dir);
        }
        if (e.code !== "EEXIST" && e.code !== "EROFS") {
          throw e;
        } else {
          try {
            if (fs2.statSync(dir).isDirectory()) {
              return dir;
            }
            throw e;
          } catch (err) {
            throw e;
          }
        }
      }
    };
    mkdir(path2.dirname(file2));
    fs2.appendFileSync(file2, "", { mode: options.mode, flag: options.flags });
  }
  class RollingFileSync {
    constructor(filename, maxLogSize, backups, options) {
      debug2("In RollingFileStream");
      if (maxLogSize < 0) {
        throw new Error(`maxLogSize (${maxLogSize}) should be > 0`);
      }
      this.filename = filename;
      this.size = maxLogSize;
      this.backups = backups;
      this.options = options;
      this.currentSize = 0;
      function currentFileSize(file2) {
        let fileSize = 0;
        try {
          fileSize = fs2.statSync(file2).size;
        } catch (e) {
          touchFile(file2, options);
        }
        return fileSize;
      }
      this.currentSize = currentFileSize(this.filename);
    }
    shouldRoll() {
      debug2(
        "should roll with current size %d, and max size %d",
        this.currentSize,
        this.size
      );
      return this.currentSize >= this.size;
    }
    roll(filename) {
      const that = this;
      const nameMatcher = new RegExp(`^${path2.basename(filename)}`);
      function justTheseFiles(item) {
        return nameMatcher.test(item);
      }
      function index2(filename_) {
        return parseInt(filename_.slice(`${path2.basename(filename)}.`.length), 10) || 0;
      }
      function byIndex(a, b) {
        return index2(a) - index2(b);
      }
      function increaseFileIndex(fileToRename) {
        const idx = index2(fileToRename);
        debug2(`Index of ${fileToRename} is ${idx}`);
        if (that.backups === 0) {
          fs2.truncateSync(filename, 0);
        } else if (idx < that.backups) {
          try {
            fs2.unlinkSync(`${filename}.${idx + 1}`);
          } catch (e) {
          }
          debug2(`Renaming ${fileToRename} -> ${filename}.${idx + 1}`);
          fs2.renameSync(
            path2.join(path2.dirname(filename), fileToRename),
            `${filename}.${idx + 1}`
          );
        }
      }
      function renameTheFiles() {
        debug2("Renaming the old files");
        const files = fs2.readdirSync(path2.dirname(filename));
        files.filter(justTheseFiles).sort(byIndex).reverse().forEach(increaseFileIndex);
      }
      debug2("Rolling, rolling, rolling");
      renameTheFiles();
    }
    // eslint-disable-next-line no-unused-vars
    write(chunk, encoding2) {
      const that = this;
      function writeTheChunk() {
        debug2("writing the chunk to the file");
        that.currentSize += chunk.length;
        fs2.appendFileSync(that.filename, chunk);
      }
      debug2("in write");
      if (this.shouldRoll()) {
        this.currentSize = 0;
        this.roll(this.filename);
      }
      writeTheChunk();
    }
  }
  function fileAppender(file2, layout, logSize, numBackups, options, timezoneOffset) {
    if (typeof file2 !== "string" || file2.length === 0) {
      throw new Error(`Invalid filename: ${file2}`);
    } else if (file2.endsWith(path2.sep)) {
      throw new Error(`Filename is a directory: ${file2}`);
    } else if (file2.indexOf(`~${path2.sep}`) === 0) {
      file2 = file2.replace("~", os.homedir());
    }
    file2 = path2.normalize(file2);
    numBackups = !numBackups && numBackups !== 0 ? 5 : numBackups;
    debug2(
      "Creating fileSync appender (",
      file2,
      ", ",
      logSize,
      ", ",
      numBackups,
      ", ",
      options,
      ", ",
      timezoneOffset,
      ")"
    );
    function openTheStream(filePath, fileSize, numFiles) {
      let stream2;
      if (fileSize) {
        stream2 = new RollingFileSync(filePath, fileSize, numFiles, options);
      } else {
        stream2 = ((f) => {
          touchFile(f, options);
          return {
            write(data2) {
              fs2.appendFileSync(f, data2);
            }
          };
        })(filePath);
      }
      return stream2;
    }
    const logFile = openTheStream(file2, logSize, numBackups);
    return (loggingEvent) => {
      logFile.write(layout(loggingEvent, timezoneOffset) + eol);
    };
  }
  function configure2(config, layouts2) {
    let layout = layouts2.basicLayout;
    if (config.layout) {
      layout = layouts2.layout(config.layout.type, config.layout);
    }
    const options = {
      flags: config.flags || "a",
      encoding: config.encoding || "utf8",
      mode: config.mode || 384
    };
    return fileAppender(
      config.filename,
      layout,
      config.maxLogSize,
      config.backups,
      options,
      config.timezoneOffset
    );
  }
  fileSync.configure = configure2;
  return fileSync;
}
var tcp = {};
var hasRequiredTcp;
function requireTcp() {
  if (hasRequiredTcp) return tcp;
  hasRequiredTcp = 1;
  const debug2 = requireBrowser$4()("log4js:tcp");
  const net = require$$1$3$1;
  function appender(config, layout) {
    let canWrite = false;
    const buffer2 = [];
    let socket;
    let shutdownAttempts = 3;
    let endMsg = "__LOG4JS__";
    function write(loggingEvent) {
      debug2("Writing log event to socket");
      canWrite = socket.write(`${layout(loggingEvent)}${endMsg}`, "utf8");
    }
    function emptyBuffer() {
      let evt;
      debug2("emptying buffer");
      while (evt = buffer2.shift()) {
        write(evt);
      }
    }
    function createSocket() {
      debug2(
        `appender creating socket to ${config.host || "localhost"}:${config.port || 5e3}`
      );
      endMsg = `${config.endMsg || "__LOG4JS__"}`;
      socket = net.createConnection(
        config.port || 5e3,
        config.host || "localhost"
      );
      socket.on("connect", () => {
        debug2("socket connected");
        emptyBuffer();
        canWrite = true;
      });
      socket.on("drain", () => {
        debug2("drain event received, emptying buffer");
        canWrite = true;
        emptyBuffer();
      });
      socket.on("timeout", socket.end.bind(socket));
      socket.on("error", (e) => {
        debug2("connection error", e);
        canWrite = false;
        emptyBuffer();
      });
      socket.on("close", createSocket);
    }
    createSocket();
    function log(loggingEvent) {
      if (canWrite) {
        write(loggingEvent);
      } else {
        debug2("buffering log event because it cannot write at the moment");
        buffer2.push(loggingEvent);
      }
    }
    log.shutdown = function(cb) {
      debug2("shutdown called");
      if (buffer2.length && shutdownAttempts) {
        debug2("buffer has items, waiting 100ms to empty");
        shutdownAttempts -= 1;
        setTimeout(() => {
          log.shutdown(cb);
        }, 100);
      } else {
        socket.removeAllListeners("close");
        socket.end(cb);
      }
    };
    return log;
  }
  function configure2(config, layouts2) {
    debug2(`configure with config = ${config}`);
    let layout = function(loggingEvent) {
      return loggingEvent.serialise();
    };
    if (config.layout) {
      layout = layouts2.layout(config.layout.type, config.layout);
    }
    return appender(config, layout);
  }
  tcp.configure = configure2;
  return tcp;
}
var hasRequiredAppenders;
function requireAppenders() {
  if (hasRequiredAppenders) return appenders.exports;
  hasRequiredAppenders = 1;
  const path2 = require$$1$3;
  const debug2 = requireBrowser$4()("log4js:appenders");
  const configuration2 = requireConfiguration$1();
  const clustering2 = requireClustering();
  const levels2 = requireLevels();
  const layouts2 = requireLayouts();
  const adapters2 = requireAdapters();
  const coreAppenders = /* @__PURE__ */ new Map();
  coreAppenders.set("console", requireConsole());
  coreAppenders.set("stdout", requireStdout());
  coreAppenders.set("stderr", requireStderr());
  coreAppenders.set("logLevelFilter", requireLogLevelFilter());
  coreAppenders.set("categoryFilter", requireCategoryFilter());
  coreAppenders.set("noLogFilter", requireNoLogFilter());
  coreAppenders.set("file", requireFile());
  coreAppenders.set("dateFile", requireDateFile());
  coreAppenders.set("fileSync", requireFileSync());
  coreAppenders.set("tcp", requireTcp());
  const appenders$1 = /* @__PURE__ */ new Map();
  const tryLoading = (modulePath, config) => {
    let resolvedPath;
    try {
      const modulePathCJS = `${modulePath}.cjs`;
      resolvedPath = require.resolve(modulePathCJS);
      debug2("Loading module from ", modulePathCJS);
    } catch (e) {
      resolvedPath = modulePath;
      debug2("Loading module from ", modulePath);
    }
    try {
      return commonjsRequire$2(resolvedPath);
    } catch (e) {
      configuration2.throwExceptionIf(
        config,
        e.code !== "MODULE_NOT_FOUND",
        `appender "${modulePath}" could not be loaded (error was: ${e})`
      );
      return void 0;
    }
  };
  const loadAppenderModule = (type2, config) => coreAppenders.get(type2) || tryLoading(`./${type2}`, config) || tryLoading(type2, config) || require.main && require.main.filename && tryLoading(path2.join(path2.dirname(require.main.filename), type2), config) || tryLoading(path2.join(process.cwd(), type2), config);
  const appendersLoading = /* @__PURE__ */ new Set();
  const getAppender = (name, config) => {
    if (appenders$1.has(name)) return appenders$1.get(name);
    if (!config.appenders[name]) return false;
    if (appendersLoading.has(name))
      throw new Error(`Dependency loop detected for appender ${name}.`);
    appendersLoading.add(name);
    debug2(`Creating appender ${name}`);
    const appender = createAppender(name, config);
    appendersLoading.delete(name);
    appenders$1.set(name, appender);
    return appender;
  };
  const createAppender = (name, config) => {
    const appenderConfig = config.appenders[name];
    const appenderModule = appenderConfig.type.configure ? appenderConfig.type : loadAppenderModule(appenderConfig.type, config);
    configuration2.throwExceptionIf(
      config,
      configuration2.not(appenderModule),
      `appender "${name}" is not valid (type "${appenderConfig.type}" could not be found)`
    );
    if (appenderModule.appender) {
      process.emitWarning(
        `Appender ${appenderConfig.type} exports an appender function.`,
        "DeprecationWarning",
        "log4js-node-DEP0001"
      );
      debug2(
        "[log4js-node-DEP0001]",
        `DEPRECATION: Appender ${appenderConfig.type} exports an appender function.`
      );
    }
    if (appenderModule.shutdown) {
      process.emitWarning(
        `Appender ${appenderConfig.type} exports a shutdown function.`,
        "DeprecationWarning",
        "log4js-node-DEP0002"
      );
      debug2(
        "[log4js-node-DEP0002]",
        `DEPRECATION: Appender ${appenderConfig.type} exports a shutdown function.`
      );
    }
    debug2(`${name}: clustering.isMaster ? ${clustering2.isMaster()}`);
    debug2(
      // eslint-disable-next-line global-require
      `${name}: appenderModule is ${require$$0$5.inspect(appenderModule)}`
    );
    return clustering2.onlyOnMaster(
      () => {
        debug2(
          `calling appenderModule.configure for ${name} / ${appenderConfig.type}`
        );
        return appenderModule.configure(
          adapters2.modifyConfig(appenderConfig),
          layouts2,
          (appender) => getAppender(appender, config),
          levels2
        );
      },
      /* istanbul ignore next: fn never gets called by non-master yet needed to pass config validation */
      () => {
      }
    );
  };
  const setup = (config) => {
    appenders$1.clear();
    appendersLoading.clear();
    if (!config) {
      return;
    }
    const usedAppenders = [];
    Object.values(config.categories).forEach((category) => {
      usedAppenders.push(...category.appenders);
    });
    Object.keys(config.appenders).forEach((name) => {
      if (usedAppenders.includes(name) || config.appenders[name].type === "tcp-server" || config.appenders[name].type === "multiprocess") {
        getAppender(name, config);
      }
    });
  };
  const init = () => {
    setup();
  };
  init();
  configuration2.addListener((config) => {
    configuration2.throwExceptionIf(
      config,
      configuration2.not(configuration2.anObject(config.appenders)),
      'must have a property "appenders" of type object.'
    );
    const appenderNames = Object.keys(config.appenders);
    configuration2.throwExceptionIf(
      config,
      configuration2.not(appenderNames.length),
      "must define at least one appender."
    );
    appenderNames.forEach((name) => {
      configuration2.throwExceptionIf(
        config,
        configuration2.not(config.appenders[name].type),
        `appender "${name}" is not valid (must be an object with property "type")`
      );
    });
  });
  configuration2.addListener(setup);
  appenders.exports = appenders$1;
  appenders.exports.init = init;
  return appenders.exports;
}
var categories = { exports: {} };
var hasRequiredCategories;
function requireCategories() {
  if (hasRequiredCategories) return categories.exports;
  hasRequiredCategories = 1;
  (function(module) {
    const debug2 = requireBrowser$4()("log4js:categories");
    const configuration2 = requireConfiguration$1();
    const levels2 = requireLevels();
    const appenders2 = requireAppenders();
    const categories2 = /* @__PURE__ */ new Map();
    function inheritFromParent(config, category, categoryName) {
      if (category.inherit === false) return;
      const lastDotIndex = categoryName.lastIndexOf(".");
      if (lastDotIndex < 0) return;
      const parentCategoryName = categoryName.slice(0, lastDotIndex);
      let parentCategory = config.categories[parentCategoryName];
      if (!parentCategory) {
        parentCategory = { inherit: true, appenders: [] };
      }
      inheritFromParent(config, parentCategory, parentCategoryName);
      if (!config.categories[parentCategoryName] && parentCategory.appenders && parentCategory.appenders.length && parentCategory.level) {
        config.categories[parentCategoryName] = parentCategory;
      }
      category.appenders = category.appenders || [];
      category.level = category.level || parentCategory.level;
      parentCategory.appenders.forEach((ap) => {
        if (!category.appenders.includes(ap)) {
          category.appenders.push(ap);
        }
      });
      category.parent = parentCategory;
    }
    function addCategoryInheritance(config) {
      if (!config.categories) return;
      const categoryNames = Object.keys(config.categories);
      categoryNames.forEach((name) => {
        const category = config.categories[name];
        inheritFromParent(config, category, name);
      });
    }
    configuration2.addPreProcessingListener(
      (config) => addCategoryInheritance(config)
    );
    configuration2.addListener((config) => {
      configuration2.throwExceptionIf(
        config,
        configuration2.not(configuration2.anObject(config.categories)),
        'must have a property "categories" of type object.'
      );
      const categoryNames = Object.keys(config.categories);
      configuration2.throwExceptionIf(
        config,
        configuration2.not(categoryNames.length),
        "must define at least one category."
      );
      categoryNames.forEach((name) => {
        const category = config.categories[name];
        configuration2.throwExceptionIf(
          config,
          [
            configuration2.not(category.appenders),
            configuration2.not(category.level)
          ],
          `category "${name}" is not valid (must be an object with properties "appenders" and "level")`
        );
        configuration2.throwExceptionIf(
          config,
          configuration2.not(Array.isArray(category.appenders)),
          `category "${name}" is not valid (appenders must be an array of appender names)`
        );
        configuration2.throwExceptionIf(
          config,
          configuration2.not(category.appenders.length),
          `category "${name}" is not valid (appenders must contain at least one appender name)`
        );
        if (Object.prototype.hasOwnProperty.call(category, "enableCallStack")) {
          configuration2.throwExceptionIf(
            config,
            typeof category.enableCallStack !== "boolean",
            `category "${name}" is not valid (enableCallStack must be boolean type)`
          );
        }
        category.appenders.forEach((appender) => {
          configuration2.throwExceptionIf(
            config,
            configuration2.not(appenders2.get(appender)),
            `category "${name}" is not valid (appender "${appender}" is not defined)`
          );
        });
        configuration2.throwExceptionIf(
          config,
          configuration2.not(levels2.getLevel(category.level)),
          `category "${name}" is not valid (level "${category.level}" not recognised; valid levels are ${levels2.levels.join(", ")})`
        );
      });
      configuration2.throwExceptionIf(
        config,
        configuration2.not(config.categories.default),
        'must define a "default" category.'
      );
    });
    const setup = (config) => {
      categories2.clear();
      if (!config) {
        return;
      }
      const categoryNames = Object.keys(config.categories);
      categoryNames.forEach((name) => {
        const category = config.categories[name];
        const categoryAppenders = [];
        category.appenders.forEach((appender) => {
          categoryAppenders.push(appenders2.get(appender));
          debug2(`Creating category ${name}`);
          categories2.set(name, {
            appenders: categoryAppenders,
            level: levels2.getLevel(category.level),
            enableCallStack: category.enableCallStack || false
          });
        });
      });
    };
    const init = () => {
      setup();
    };
    init();
    configuration2.addListener(setup);
    const configForCategory = (category) => {
      debug2(`configForCategory: searching for config for ${category}`);
      if (categories2.has(category)) {
        debug2(`configForCategory: ${category} exists in config, returning it`);
        return categories2.get(category);
      }
      let sourceCategoryConfig;
      if (category.indexOf(".") > 0) {
        debug2(`configForCategory: ${category} has hierarchy, cloning from parents`);
        sourceCategoryConfig = {
          ...configForCategory(category.slice(0, category.lastIndexOf(".")))
        };
      } else {
        if (!categories2.has("default")) {
          setup({ categories: { default: { appenders: ["out"], level: "OFF" } } });
        }
        debug2("configForCategory: cloning default category");
        sourceCategoryConfig = { ...categories2.get("default") };
      }
      categories2.set(category, sourceCategoryConfig);
      return sourceCategoryConfig;
    };
    const appendersForCategory = (category) => configForCategory(category).appenders;
    const getLevelForCategory = (category) => configForCategory(category).level;
    const setLevelForCategory = (category, level2) => {
      configForCategory(category).level = level2;
    };
    const getEnableCallStackForCategory = (category) => configForCategory(category).enableCallStack === true;
    const setEnableCallStackForCategory = (category, useCallStack) => {
      configForCategory(category).enableCallStack = useCallStack;
    };
    module.exports = categories2;
    module.exports = Object.assign(module.exports, {
      appendersForCategory,
      getLevelForCategory,
      setLevelForCategory,
      getEnableCallStackForCategory,
      setEnableCallStackForCategory,
      init
    });
  })(categories);
  return categories.exports;
}
var logger$2;
var hasRequiredLogger$1;
function requireLogger$1() {
  if (hasRequiredLogger$1) return logger$2;
  hasRequiredLogger$1 = 1;
  const debug2 = requireBrowser$4()("log4js:logger");
  const LoggingEvent = requireLoggingEvent();
  const levels2 = requireLevels();
  const clustering2 = requireClustering();
  const categories2 = requireCategories();
  const configuration2 = requireConfiguration$1();
  const stackReg = /^(?:\s*) at (?:(.+) \()?(?:([^(]+?):(\d+):(\d+))\)?$/;
  const baseCallStackSkip = 1;
  const defaultErrorCallStackSkip = 3;
  function defaultParseCallStack(data2, skipIdx = defaultErrorCallStackSkip + baseCallStackSkip) {
    try {
      const stacklines = data2.stack.split("\n").slice(skipIdx);
      if (!stacklines.length) {
        return null;
      }
      const lineMatch = stackReg.exec(stacklines[0]);
      if (lineMatch && lineMatch.length === 5) {
        let className = "";
        let functionName = "";
        let functionAlias = "";
        if (lineMatch[1] && lineMatch[1] !== "") {
          [functionName, functionAlias] = lineMatch[1].replace(/[[\]]/g, "").split(" as ");
          functionAlias = functionAlias || "";
          if (functionName.includes("."))
            [className, functionName] = functionName.split(".");
        }
        return {
          fileName: lineMatch[2],
          lineNumber: parseInt(lineMatch[3], 10),
          columnNumber: parseInt(lineMatch[4], 10),
          callStack: stacklines.join("\n"),
          className,
          functionName,
          functionAlias,
          callerName: lineMatch[1] || ""
        };
      } else {
        console.error("log4js.logger - defaultParseCallStack error");
      }
    } catch (err) {
      console.error("log4js.logger - defaultParseCallStack error", err);
    }
    return null;
  }
  class Logger {
    constructor(name) {
      if (!name) {
        throw new Error("No category provided.");
      }
      this.category = name;
      this.context = {};
      this.callStackSkipIndex = 0;
      this.parseCallStack = defaultParseCallStack;
      debug2(`Logger created (${this.category}, ${this.level})`);
    }
    get level() {
      return levels2.getLevel(
        categories2.getLevelForCategory(this.category),
        levels2.OFF
      );
    }
    set level(level2) {
      categories2.setLevelForCategory(
        this.category,
        levels2.getLevel(level2, this.level)
      );
    }
    get useCallStack() {
      return categories2.getEnableCallStackForCategory(this.category);
    }
    set useCallStack(bool) {
      categories2.setEnableCallStackForCategory(this.category, bool === true);
    }
    get callStackLinesToSkip() {
      return this.callStackSkipIndex;
    }
    set callStackLinesToSkip(number) {
      if (typeof number !== "number") {
        throw new TypeError("Must be a number");
      }
      if (number < 0) {
        throw new RangeError("Must be >= 0");
      }
      this.callStackSkipIndex = number;
    }
    log(level2, ...args) {
      const logLevel = levels2.getLevel(level2);
      if (!logLevel) {
        if (configuration2.validIdentifier(level2) && args.length > 0) {
          this.log(
            levels2.WARN,
            "log4js:logger.log: valid log-level not found as first parameter given:",
            level2
          );
          this.log(levels2.INFO, `[${level2}]`, ...args);
        } else {
          this.log(levels2.INFO, level2, ...args);
        }
      } else if (this.isLevelEnabled(logLevel)) {
        this._log(logLevel, args);
      }
    }
    isLevelEnabled(otherLevel) {
      return this.level.isLessThanOrEqualTo(otherLevel);
    }
    _log(level2, data2) {
      debug2(`sending log data (${level2}) to appenders`);
      const error = data2.find((item) => item instanceof Error);
      let callStack;
      if (this.useCallStack) {
        try {
          if (error) {
            callStack = this.parseCallStack(
              error,
              this.callStackSkipIndex + baseCallStackSkip
            );
          }
        } catch (_err) {
        }
        callStack = callStack || this.parseCallStack(
          new Error(),
          this.callStackSkipIndex + defaultErrorCallStackSkip + baseCallStackSkip
        );
      }
      const loggingEvent = new LoggingEvent(
        this.category,
        level2,
        data2,
        this.context,
        callStack,
        error
      );
      clustering2.send(loggingEvent);
    }
    addContext(key, value) {
      this.context[key] = value;
    }
    removeContext(key) {
      delete this.context[key];
    }
    clearContext() {
      this.context = {};
    }
    setParseCallStackFunction(parseFunction) {
      if (typeof parseFunction === "function") {
        this.parseCallStack = parseFunction;
      } else if (typeof parseFunction === "undefined") {
        this.parseCallStack = defaultParseCallStack;
      } else {
        throw new TypeError("Invalid type passed to setParseCallStackFunction");
      }
    }
  }
  function addLevelMethods(target) {
    const level2 = levels2.getLevel(target);
    const levelStrLower = level2.toString().toLowerCase();
    const levelMethod = levelStrLower.replace(
      /_([a-z])/g,
      (g) => g[1].toUpperCase()
    );
    const isLevelMethod = levelMethod[0].toUpperCase() + levelMethod.slice(1);
    Logger.prototype[`is${isLevelMethod}Enabled`] = function() {
      return this.isLevelEnabled(level2);
    };
    Logger.prototype[levelMethod] = function(...args) {
      this.log(level2, ...args);
    };
  }
  levels2.levels.forEach(addLevelMethods);
  configuration2.addListener(() => {
    levels2.levels.forEach(addLevelMethods);
  });
  logger$2 = Logger;
  return logger$2;
}
var connectLogger;
var hasRequiredConnectLogger;
function requireConnectLogger() {
  if (hasRequiredConnectLogger) return connectLogger;
  hasRequiredConnectLogger = 1;
  const levels2 = requireLevels();
  const DEFAULT_FORMAT = ':remote-addr - - ":method :url HTTP/:http-version" :status :content-length ":referrer" ":user-agent"';
  function getUrl(req) {
    return req.originalUrl || req.url;
  }
  function assembleTokens(req, res, customTokens) {
    const arrayUniqueTokens = (array) => {
      const a = array.concat();
      for (let i = 0; i < a.length; ++i) {
        for (let j = i + 1; j < a.length; ++j) {
          if (a[i].token == a[j].token) {
            a.splice(j--, 1);
          }
        }
      }
      return a;
    };
    const defaultTokens = [];
    defaultTokens.push({ token: ":url", replacement: getUrl(req) });
    defaultTokens.push({ token: ":protocol", replacement: req.protocol });
    defaultTokens.push({ token: ":hostname", replacement: req.hostname });
    defaultTokens.push({ token: ":method", replacement: req.method });
    defaultTokens.push({
      token: ":status",
      replacement: res.__statusCode || res.statusCode
    });
    defaultTokens.push({
      token: ":response-time",
      replacement: res.responseTime
    });
    defaultTokens.push({ token: ":date", replacement: (/* @__PURE__ */ new Date()).toUTCString() });
    defaultTokens.push({
      token: ":referrer",
      replacement: req.headers.referer || req.headers.referrer || ""
    });
    defaultTokens.push({
      token: ":http-version",
      replacement: `${req.httpVersionMajor}.${req.httpVersionMinor}`
    });
    defaultTokens.push({
      token: ":remote-addr",
      replacement: req.headers["x-forwarded-for"] || req.ip || req._remoteAddress || req.socket && (req.socket.remoteAddress || req.socket.socket && req.socket.socket.remoteAddress)
    });
    defaultTokens.push({
      token: ":user-agent",
      replacement: req.headers["user-agent"]
    });
    defaultTokens.push({
      token: ":content-length",
      replacement: res.getHeader("content-length") || res.__headers && res.__headers["Content-Length"] || "-"
    });
    defaultTokens.push({
      token: /:req\[([^\]]+)]/g,
      replacement(_, field) {
        return req.headers[field.toLowerCase()];
      }
    });
    defaultTokens.push({
      token: /:res\[([^\]]+)]/g,
      replacement(_, field) {
        return res.getHeader(field.toLowerCase()) || res.__headers && res.__headers[field];
      }
    });
    return arrayUniqueTokens(customTokens.concat(defaultTokens));
  }
  function format(str, tokens) {
    for (let i = 0; i < tokens.length; i++) {
      str = str.replace(tokens[i].token, tokens[i].replacement);
    }
    return str;
  }
  function createNoLogCondition(nolog) {
    let regexp = null;
    if (nolog instanceof RegExp) {
      regexp = nolog;
    }
    if (typeof nolog === "string") {
      regexp = new RegExp(nolog);
    }
    if (Array.isArray(nolog)) {
      const regexpsAsStrings = nolog.map(
        (reg) => reg.source ? reg.source : reg
      );
      regexp = new RegExp(regexpsAsStrings.join("|"));
    }
    return regexp;
  }
  function matchRules(statusCode2, currentLevel, ruleSet) {
    let level2 = currentLevel;
    if (ruleSet) {
      const matchedRule = ruleSet.find((rule) => {
        let ruleMatched = false;
        if (rule.from && rule.to) {
          ruleMatched = statusCode2 >= rule.from && statusCode2 <= rule.to;
        } else {
          ruleMatched = rule.codes.indexOf(statusCode2) !== -1;
        }
        return ruleMatched;
      });
      if (matchedRule) {
        level2 = levels2.getLevel(matchedRule.level, level2);
      }
    }
    return level2;
  }
  connectLogger = function getLogger2(logger4js, options) {
    if (typeof options === "string" || typeof options === "function") {
      options = { format: options };
    } else {
      options = options || {};
    }
    const thisLogger = logger4js;
    let level2 = levels2.getLevel(options.level, levels2.INFO);
    const fmt = options.format || DEFAULT_FORMAT;
    return (req, res, next) => {
      if (typeof req._logging !== "undefined") return next();
      if (typeof options.nolog !== "function") {
        const nolog = createNoLogCondition(options.nolog);
        if (nolog && nolog.test(req.originalUrl)) return next();
      }
      if (thisLogger.isLevelEnabled(level2) || options.level === "auto") {
        const start = /* @__PURE__ */ new Date();
        const { writeHead } = res;
        req._logging = true;
        res.writeHead = (code, headers2) => {
          res.writeHead = writeHead;
          res.writeHead(code, headers2);
          res.__statusCode = code;
          res.__headers = headers2 || {};
        };
        let finished = false;
        const handler = () => {
          if (finished) {
            return;
          }
          finished = true;
          if (typeof options.nolog === "function") {
            if (options.nolog(req, res) === true) {
              req._logging = false;
              return;
            }
          }
          res.responseTime = /* @__PURE__ */ new Date() - start;
          if (res.statusCode && options.level === "auto") {
            level2 = levels2.INFO;
            if (res.statusCode >= 300) level2 = levels2.WARN;
            if (res.statusCode >= 400) level2 = levels2.ERROR;
          }
          level2 = matchRules(res.statusCode, level2, options.statusRules);
          const combinedTokens = assembleTokens(req, res, options.tokens || []);
          if (options.context) thisLogger.addContext("res", res);
          if (typeof fmt === "function") {
            const line = fmt(req, res, (str) => format(str, combinedTokens));
            if (line) thisLogger.log(level2, line);
          } else {
            thisLogger.log(level2, format(fmt, combinedTokens));
          }
          if (options.context) thisLogger.removeContext("res");
        };
        res.on("end", handler);
        res.on("finish", handler);
        res.on("error", handler);
        res.on("close", handler);
      }
      return next();
    };
  };
  return connectLogger;
}
var recording;
var hasRequiredRecording;
function requireRecording() {
  if (hasRequiredRecording) return recording;
  hasRequiredRecording = 1;
  const debug2 = requireBrowser$4()("log4js:recording");
  const recordedEvents = [];
  function configure2() {
    return function(logEvent) {
      debug2(
        `received logEvent, number of events now ${recordedEvents.length + 1}`
      );
      debug2("log event was ", logEvent);
      recordedEvents.push(logEvent);
    };
  }
  function replay() {
    return recordedEvents.slice();
  }
  function reset() {
    recordedEvents.length = 0;
  }
  recording = {
    configure: configure2,
    replay,
    playback: replay,
    reset,
    erase: reset
  };
  return recording;
}
var log4js_1;
var hasRequiredLog4js;
function requireLog4js() {
  if (hasRequiredLog4js) return log4js_1;
  hasRequiredLog4js = 1;
  const debug2 = requireBrowser$4()("log4js:main");
  const fs2 = require$$1$2;
  const deepClone = requireRfdc()({ proto: true });
  const configuration2 = requireConfiguration$1();
  const layouts2 = requireLayouts();
  const levels2 = requireLevels();
  const appenders2 = requireAppenders();
  const categories2 = requireCategories();
  const Logger = requireLogger$1();
  const clustering2 = requireClustering();
  const connectLogger2 = requireConnectLogger();
  const recordingModule = requireRecording();
  let enabled = false;
  function sendLogEventToAppender(logEvent) {
    if (!enabled) return;
    debug2("Received log event ", logEvent);
    const categoryAppenders = categories2.appendersForCategory(
      logEvent.categoryName
    );
    categoryAppenders.forEach((appender) => {
      appender(logEvent);
    });
  }
  function loadConfigurationFile(filename) {
    debug2(`Loading configuration from ${filename}`);
    try {
      return JSON.parse(fs2.readFileSync(filename, "utf8"));
    } catch (e) {
      throw new Error(
        `Problem reading config from file "${filename}". Error was ${e.message}`,
        e
      );
    }
  }
  function configure2(configurationFileOrObject) {
    if (enabled) {
      shutdown2();
    }
    let configObject = configurationFileOrObject;
    if (typeof configObject === "string") {
      configObject = loadConfigurationFile(configurationFileOrObject);
    }
    debug2(`Configuration is ${configObject}`);
    configuration2.configure(deepClone(configObject));
    clustering2.onMessage(sendLogEventToAppender);
    enabled = true;
    return log4js2;
  }
  function isConfigured2() {
    return enabled;
  }
  function recording2() {
    return recordingModule;
  }
  function shutdown2(callback = () => {
  }) {
    if (typeof callback !== "function") {
      throw new TypeError("Invalid callback passed to shutdown");
    }
    debug2("Shutdown called. Disabling all log writing.");
    enabled = false;
    const appendersToCheck = Array.from(appenders2.values());
    appenders2.init();
    categories2.init();
    const shutdownFunctions = appendersToCheck.reduce(
      (accum, next) => next.shutdown ? accum + 1 : accum,
      0
    );
    if (shutdownFunctions === 0) {
      debug2("No appenders with shutdown functions found.");
      callback();
    }
    let completed = 0;
    let error;
    debug2(`Found ${shutdownFunctions} appenders with shutdown functions.`);
    function complete(err) {
      error = error || err;
      completed += 1;
      debug2(`Appender shutdowns complete: ${completed} / ${shutdownFunctions}`);
      if (completed >= shutdownFunctions) {
        debug2("All shutdown functions completed.");
        callback(error);
      }
    }
    appendersToCheck.filter((a) => a.shutdown).forEach((a) => a.shutdown(complete));
  }
  function getLogger2(category) {
    if (!enabled) {
      configure2(
        process.env.LOG4JS_CONFIG || {
          appenders: { out: { type: "stdout" } },
          categories: { default: { appenders: ["out"], level: "OFF" } }
        }
      );
    }
    return new Logger(category || "default");
  }
  const log4js2 = {
    getLogger: getLogger2,
    configure: configure2,
    isConfigured: isConfigured2,
    shutdown: shutdown2,
    connectLogger: connectLogger2,
    levels: levels2,
    addLayout: layouts2.addLayout,
    recording: recording2
  };
  log4js_1 = log4js2;
  return log4js_1;
}
var log4jsExports = requireLog4js();
const log4js = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null,
  default: log4jsExports
}, [log4jsExports]);
log4jsExports.addLayout;
log4jsExports.configure;
log4jsExports.connectLogger;
log4jsExports.getLogger;
log4jsExports.isConfigured;
log4jsExports.levels;
log4jsExports.recording;
log4jsExports.shutdown;
const app$1 = log4js.default;
var delayed_stream;
var hasRequiredDelayed_stream;
function requireDelayed_stream() {
  if (hasRequiredDelayed_stream) return delayed_stream;
  hasRequiredDelayed_stream = 1;
  var Stream = stream.Stream;
  var util2 = require$$0$5;
  delayed_stream = DelayedStream;
  function DelayedStream() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
  }
  util2.inherits(DelayedStream, Stream);
  DelayedStream.create = function(source, options) {
    var delayedStream = new this();
    options = options || {};
    for (var option in options) {
      delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function() {
      delayedStream._handleEmit(arguments);
      return realEmit.apply(source, arguments);
    };
    source.on("error", function() {
    });
    if (delayedStream.pauseStream) {
      source.pause();
    }
    return delayedStream;
  };
  Object.defineProperty(DelayedStream.prototype, "readable", {
    configurable: true,
    enumerable: true,
    get: function() {
      return this.source.readable;
    }
  });
  DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
  };
  DelayedStream.prototype.resume = function() {
    if (!this._released) {
      this.release();
    }
    this.source.resume();
  };
  DelayedStream.prototype.pause = function() {
    this.source.pause();
  };
  DelayedStream.prototype.release = function() {
    this._released = true;
    this._bufferedEvents.forEach(function(args) {
      this.emit.apply(this, args);
    }.bind(this));
    this._bufferedEvents = [];
  };
  DelayedStream.prototype.pipe = function() {
    var r = Stream.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
  };
  DelayedStream.prototype._handleEmit = function(args) {
    if (this._released) {
      this.emit.apply(this, args);
      return;
    }
    if (args[0] === "data") {
      this.dataSize += args[1].length;
      this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args);
  };
  DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) {
      return;
    }
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    this._maxDataSizeExceeded = true;
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this.emit("error", new Error(message));
  };
  return delayed_stream;
}
var combined_stream;
var hasRequiredCombined_stream;
function requireCombined_stream() {
  if (hasRequiredCombined_stream) return combined_stream;
  hasRequiredCombined_stream = 1;
  var util2 = require$$0$5;
  var Stream = stream.Stream;
  var DelayedStream = requireDelayed_stream();
  combined_stream = CombinedStream;
  function CombinedStream() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
  }
  util2.inherits(CombinedStream, Stream);
  CombinedStream.create = function(options) {
    var combinedStream = new this();
    options = options || {};
    for (var option in options) {
      combinedStream[option] = options[option];
    }
    return combinedStream;
  };
  CombinedStream.isStreamLike = function(stream2) {
    return typeof stream2 !== "function" && typeof stream2 !== "string" && typeof stream2 !== "boolean" && typeof stream2 !== "number" && !Buffer.isBuffer(stream2);
  };
  CombinedStream.prototype.append = function(stream2) {
    var isStreamLike = CombinedStream.isStreamLike(stream2);
    if (isStreamLike) {
      if (!(stream2 instanceof DelayedStream)) {
        var newStream = DelayedStream.create(stream2, {
          maxDataSize: Infinity,
          pauseStream: this.pauseStreams
        });
        stream2.on("data", this._checkDataSize.bind(this));
        stream2 = newStream;
      }
      this._handleErrors(stream2);
      if (this.pauseStreams) {
        stream2.pause();
      }
    }
    this._streams.push(stream2);
    return this;
  };
  CombinedStream.prototype.pipe = function(dest, options) {
    Stream.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
  };
  CombinedStream.prototype._getNext = function() {
    this._currentStream = null;
    if (this._insideLoop) {
      this._pendingNext = true;
      return;
    }
    this._insideLoop = true;
    try {
      do {
        this._pendingNext = false;
        this._realGetNext();
      } while (this._pendingNext);
    } finally {
      this._insideLoop = false;
    }
  };
  CombinedStream.prototype._realGetNext = function() {
    var stream2 = this._streams.shift();
    if (typeof stream2 == "undefined") {
      this.end();
      return;
    }
    if (typeof stream2 !== "function") {
      this._pipeNext(stream2);
      return;
    }
    var getStream = stream2;
    getStream(function(stream22) {
      var isStreamLike = CombinedStream.isStreamLike(stream22);
      if (isStreamLike) {
        stream22.on("data", this._checkDataSize.bind(this));
        this._handleErrors(stream22);
      }
      this._pipeNext(stream22);
    }.bind(this));
  };
  CombinedStream.prototype._pipeNext = function(stream2) {
    this._currentStream = stream2;
    var isStreamLike = CombinedStream.isStreamLike(stream2);
    if (isStreamLike) {
      stream2.on("end", this._getNext.bind(this));
      stream2.pipe(this, { end: false });
      return;
    }
    var value = stream2;
    this.write(value);
    this._getNext();
  };
  CombinedStream.prototype._handleErrors = function(stream2) {
    var self2 = this;
    stream2.on("error", function(err) {
      self2._emitError(err);
    });
  };
  CombinedStream.prototype.write = function(data2) {
    this.emit("data", data2);
  };
  CombinedStream.prototype.pause = function() {
    if (!this.pauseStreams) {
      return;
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
    this.emit("pause");
  };
  CombinedStream.prototype.resume = function() {
    if (!this._released) {
      this._released = true;
      this.writable = true;
      this._getNext();
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
    this.emit("resume");
  };
  CombinedStream.prototype.end = function() {
    this._reset();
    this.emit("end");
  };
  CombinedStream.prototype.destroy = function() {
    this._reset();
    this.emit("close");
  };
  CombinedStream.prototype._reset = function() {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
  };
  CombinedStream.prototype._checkDataSize = function() {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this._emitError(new Error(message));
  };
  CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self2 = this;
    this._streams.forEach(function(stream2) {
      if (!stream2.dataSize) {
        return;
      }
      self2.dataSize += stream2.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
      this.dataSize += this._currentStream.dataSize;
    }
  };
  CombinedStream.prototype._emitError = function(err) {
    this._reset();
    this.emit("error", err);
  };
  return combined_stream;
}
var mimeTypes$1 = {};
const require$$0$4 = {
  "application/1d-interleaved-parityfec": { "source": "iana" },
  "application/3gpdash-qoe-report+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/3gpp-ims+xml": { "source": "iana", "compressible": true },
  "application/3gpphal+json": { "source": "iana", "compressible": true },
  "application/3gpphalforms+json": { "source": "iana", "compressible": true },
  "application/a2l": { "source": "iana" },
  "application/ace+cbor": { "source": "iana" },
  "application/activemessage": { "source": "iana" },
  "application/activity+json": { "source": "iana", "compressible": true },
  "application/alto-costmap+json": { "source": "iana", "compressible": true },
  "application/alto-costmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-directory+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcost+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcostparams+json": { "source": "iana", "compressible": true },
  "application/alto-endpointprop+json": { "source": "iana", "compressible": true },
  "application/alto-endpointpropparams+json": { "source": "iana", "compressible": true },
  "application/alto-error+json": { "source": "iana", "compressible": true },
  "application/alto-networkmap+json": { "source": "iana", "compressible": true },
  "application/alto-networkmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamcontrol+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamparams+json": { "source": "iana", "compressible": true },
  "application/aml": { "source": "iana" },
  "application/andrew-inset": { "source": "iana", "extensions": ["ez"] },
  "application/applefile": { "source": "iana" },
  "application/applixware": { "source": "apache", "extensions": ["aw"] },
  "application/at+jwt": { "source": "iana" },
  "application/atf": { "source": "iana" },
  "application/atfx": { "source": "iana" },
  "application/atom+xml": { "source": "iana", "compressible": true, "extensions": ["atom"] },
  "application/atomcat+xml": { "source": "iana", "compressible": true, "extensions": ["atomcat"] },
  "application/atomdeleted+xml": { "source": "iana", "compressible": true, "extensions": ["atomdeleted"] },
  "application/atomicmail": { "source": "iana" },
  "application/atomsvc+xml": { "source": "iana", "compressible": true, "extensions": ["atomsvc"] },
  "application/atsc-dwd+xml": { "source": "iana", "compressible": true, "extensions": ["dwd"] },
  "application/atsc-dynamic-event-message": { "source": "iana" },
  "application/atsc-held+xml": { "source": "iana", "compressible": true, "extensions": ["held"] },
  "application/atsc-rdt+json": { "source": "iana", "compressible": true },
  "application/atsc-rsat+xml": { "source": "iana", "compressible": true, "extensions": ["rsat"] },
  "application/atxml": { "source": "iana" },
  "application/auth-policy+xml": { "source": "iana", "compressible": true },
  "application/bacnet-xdd+zip": { "source": "iana", "compressible": false },
  "application/batch-smtp": { "source": "iana" },
  "application/bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/beep+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/calendar+json": { "source": "iana", "compressible": true },
  "application/calendar+xml": { "source": "iana", "compressible": true, "extensions": ["xcs"] },
  "application/call-completion": { "source": "iana" },
  "application/cals-1840": { "source": "iana" },
  "application/captive+json": { "source": "iana", "compressible": true },
  "application/cbor": { "source": "iana" },
  "application/cbor-seq": { "source": "iana" },
  "application/cccex": { "source": "iana" },
  "application/ccmp+xml": { "source": "iana", "compressible": true },
  "application/ccxml+xml": { "source": "iana", "compressible": true, "extensions": ["ccxml"] },
  "application/cdfx+xml": { "source": "iana", "compressible": true, "extensions": ["cdfx"] },
  "application/cdmi-capability": { "source": "iana", "extensions": ["cdmia"] },
  "application/cdmi-container": { "source": "iana", "extensions": ["cdmic"] },
  "application/cdmi-domain": { "source": "iana", "extensions": ["cdmid"] },
  "application/cdmi-object": { "source": "iana", "extensions": ["cdmio"] },
  "application/cdmi-queue": { "source": "iana", "extensions": ["cdmiq"] },
  "application/cdni": { "source": "iana" },
  "application/cea": { "source": "iana" },
  "application/cea-2018+xml": { "source": "iana", "compressible": true },
  "application/cellml+xml": { "source": "iana", "compressible": true },
  "application/cfw": { "source": "iana" },
  "application/city+json": { "source": "iana", "compressible": true },
  "application/clr": { "source": "iana" },
  "application/clue+xml": { "source": "iana", "compressible": true },
  "application/clue_info+xml": { "source": "iana", "compressible": true },
  "application/cms": { "source": "iana" },
  "application/cnrp+xml": { "source": "iana", "compressible": true },
  "application/coap-group+json": { "source": "iana", "compressible": true },
  "application/coap-payload": { "source": "iana" },
  "application/commonground": { "source": "iana" },
  "application/conference-info+xml": { "source": "iana", "compressible": true },
  "application/cose": { "source": "iana" },
  "application/cose-key": { "source": "iana" },
  "application/cose-key-set": { "source": "iana" },
  "application/cpl+xml": { "source": "iana", "compressible": true, "extensions": ["cpl"] },
  "application/csrattrs": { "source": "iana" },
  "application/csta+xml": { "source": "iana", "compressible": true },
  "application/cstadata+xml": { "source": "iana", "compressible": true },
  "application/csvm+json": { "source": "iana", "compressible": true },
  "application/cu-seeme": { "source": "apache", "extensions": ["cu"] },
  "application/cwt": { "source": "iana" },
  "application/cybercash": { "source": "iana" },
  "application/dart": { "compressible": true },
  "application/dash+xml": { "source": "iana", "compressible": true, "extensions": ["mpd"] },
  "application/dash-patch+xml": { "source": "iana", "compressible": true, "extensions": ["mpp"] },
  "application/dashdelta": { "source": "iana" },
  "application/davmount+xml": { "source": "iana", "compressible": true, "extensions": ["davmount"] },
  "application/dca-rft": { "source": "iana" },
  "application/dcd": { "source": "iana" },
  "application/dec-dx": { "source": "iana" },
  "application/dialog-info+xml": { "source": "iana", "compressible": true },
  "application/dicom": { "source": "iana" },
  "application/dicom+json": { "source": "iana", "compressible": true },
  "application/dicom+xml": { "source": "iana", "compressible": true },
  "application/dii": { "source": "iana" },
  "application/dit": { "source": "iana" },
  "application/dns": { "source": "iana" },
  "application/dns+json": { "source": "iana", "compressible": true },
  "application/dns-message": { "source": "iana" },
  "application/docbook+xml": { "source": "apache", "compressible": true, "extensions": ["dbk"] },
  "application/dots+cbor": { "source": "iana" },
  "application/dskpp+xml": { "source": "iana", "compressible": true },
  "application/dssc+der": { "source": "iana", "extensions": ["dssc"] },
  "application/dssc+xml": { "source": "iana", "compressible": true, "extensions": ["xdssc"] },
  "application/dvcs": { "source": "iana" },
  "application/ecmascript": { "source": "iana", "compressible": true, "extensions": ["es", "ecma"] },
  "application/edi-consent": { "source": "iana" },
  "application/edi-x12": { "source": "iana", "compressible": false },
  "application/edifact": { "source": "iana", "compressible": false },
  "application/efi": { "source": "iana" },
  "application/elm+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/elm+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.cap+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/emergencycalldata.comment+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.control+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.deviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.ecall.msd": { "source": "iana" },
  "application/emergencycalldata.providerinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.serviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.subscriberinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.veds+xml": { "source": "iana", "compressible": true },
  "application/emma+xml": { "source": "iana", "compressible": true, "extensions": ["emma"] },
  "application/emotionml+xml": { "source": "iana", "compressible": true, "extensions": ["emotionml"] },
  "application/encaprtp": { "source": "iana" },
  "application/epp+xml": { "source": "iana", "compressible": true },
  "application/epub+zip": { "source": "iana", "compressible": false, "extensions": ["epub"] },
  "application/eshop": { "source": "iana" },
  "application/exi": { "source": "iana", "extensions": ["exi"] },
  "application/expect-ct-report+json": { "source": "iana", "compressible": true },
  "application/express": { "source": "iana", "extensions": ["exp"] },
  "application/fastinfoset": { "source": "iana" },
  "application/fastsoap": { "source": "iana" },
  "application/fdt+xml": { "source": "iana", "compressible": true, "extensions": ["fdt"] },
  "application/fhir+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fhir+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fido.trusted-apps+json": { "compressible": true },
  "application/fits": { "source": "iana" },
  "application/flexfec": { "source": "iana" },
  "application/font-sfnt": { "source": "iana" },
  "application/font-tdpfr": { "source": "iana", "extensions": ["pfr"] },
  "application/font-woff": { "source": "iana", "compressible": false },
  "application/framework-attributes+xml": { "source": "iana", "compressible": true },
  "application/geo+json": { "source": "iana", "compressible": true, "extensions": ["geojson"] },
  "application/geo+json-seq": { "source": "iana" },
  "application/geopackage+sqlite3": { "source": "iana" },
  "application/geoxacml+xml": { "source": "iana", "compressible": true },
  "application/gltf-buffer": { "source": "iana" },
  "application/gml+xml": { "source": "iana", "compressible": true, "extensions": ["gml"] },
  "application/gpx+xml": { "source": "apache", "compressible": true, "extensions": ["gpx"] },
  "application/gxf": { "source": "apache", "extensions": ["gxf"] },
  "application/gzip": { "source": "iana", "compressible": false, "extensions": ["gz"] },
  "application/h224": { "source": "iana" },
  "application/held+xml": { "source": "iana", "compressible": true },
  "application/hjson": { "extensions": ["hjson"] },
  "application/http": { "source": "iana" },
  "application/hyperstudio": { "source": "iana", "extensions": ["stk"] },
  "application/ibe-key-request+xml": { "source": "iana", "compressible": true },
  "application/ibe-pkg-reply+xml": { "source": "iana", "compressible": true },
  "application/ibe-pp-data": { "source": "iana" },
  "application/iges": { "source": "iana" },
  "application/im-iscomposing+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/index": { "source": "iana" },
  "application/index.cmd": { "source": "iana" },
  "application/index.obj": { "source": "iana" },
  "application/index.response": { "source": "iana" },
  "application/index.vnd": { "source": "iana" },
  "application/inkml+xml": { "source": "iana", "compressible": true, "extensions": ["ink", "inkml"] },
  "application/iotp": { "source": "iana" },
  "application/ipfix": { "source": "iana", "extensions": ["ipfix"] },
  "application/ipp": { "source": "iana" },
  "application/isup": { "source": "iana" },
  "application/its+xml": { "source": "iana", "compressible": true, "extensions": ["its"] },
  "application/java-archive": { "source": "apache", "compressible": false, "extensions": ["jar", "war", "ear"] },
  "application/java-serialized-object": { "source": "apache", "compressible": false, "extensions": ["ser"] },
  "application/java-vm": { "source": "apache", "compressible": false, "extensions": ["class"] },
  "application/javascript": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["js", "mjs"] },
  "application/jf2feed+json": { "source": "iana", "compressible": true },
  "application/jose": { "source": "iana" },
  "application/jose+json": { "source": "iana", "compressible": true },
  "application/jrd+json": { "source": "iana", "compressible": true },
  "application/jscalendar+json": { "source": "iana", "compressible": true },
  "application/json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["json", "map"] },
  "application/json-patch+json": { "source": "iana", "compressible": true },
  "application/json-seq": { "source": "iana" },
  "application/json5": { "extensions": ["json5"] },
  "application/jsonml+json": { "source": "apache", "compressible": true, "extensions": ["jsonml"] },
  "application/jwk+json": { "source": "iana", "compressible": true },
  "application/jwk-set+json": { "source": "iana", "compressible": true },
  "application/jwt": { "source": "iana" },
  "application/kpml-request+xml": { "source": "iana", "compressible": true },
  "application/kpml-response+xml": { "source": "iana", "compressible": true },
  "application/ld+json": { "source": "iana", "compressible": true, "extensions": ["jsonld"] },
  "application/lgr+xml": { "source": "iana", "compressible": true, "extensions": ["lgr"] },
  "application/link-format": { "source": "iana" },
  "application/load-control+xml": { "source": "iana", "compressible": true },
  "application/lost+xml": { "source": "iana", "compressible": true, "extensions": ["lostxml"] },
  "application/lostsync+xml": { "source": "iana", "compressible": true },
  "application/lpf+zip": { "source": "iana", "compressible": false },
  "application/lxf": { "source": "iana" },
  "application/mac-binhex40": { "source": "iana", "extensions": ["hqx"] },
  "application/mac-compactpro": { "source": "apache", "extensions": ["cpt"] },
  "application/macwriteii": { "source": "iana" },
  "application/mads+xml": { "source": "iana", "compressible": true, "extensions": ["mads"] },
  "application/manifest+json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["webmanifest"] },
  "application/marc": { "source": "iana", "extensions": ["mrc"] },
  "application/marcxml+xml": { "source": "iana", "compressible": true, "extensions": ["mrcx"] },
  "application/mathematica": { "source": "iana", "extensions": ["ma", "nb", "mb"] },
  "application/mathml+xml": { "source": "iana", "compressible": true, "extensions": ["mathml"] },
  "application/mathml-content+xml": { "source": "iana", "compressible": true },
  "application/mathml-presentation+xml": { "source": "iana", "compressible": true },
  "application/mbms-associated-procedure-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-deregister+xml": { "source": "iana", "compressible": true },
  "application/mbms-envelope+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-protection-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-reception-report+xml": { "source": "iana", "compressible": true },
  "application/mbms-register+xml": { "source": "iana", "compressible": true },
  "application/mbms-register-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-schedule+xml": { "source": "iana", "compressible": true },
  "application/mbms-user-service-description+xml": { "source": "iana", "compressible": true },
  "application/mbox": { "source": "iana", "extensions": ["mbox"] },
  "application/media-policy-dataset+xml": { "source": "iana", "compressible": true, "extensions": ["mpf"] },
  "application/media_control+xml": { "source": "iana", "compressible": true },
  "application/mediaservercontrol+xml": { "source": "iana", "compressible": true, "extensions": ["mscml"] },
  "application/merge-patch+json": { "source": "iana", "compressible": true },
  "application/metalink+xml": { "source": "apache", "compressible": true, "extensions": ["metalink"] },
  "application/metalink4+xml": { "source": "iana", "compressible": true, "extensions": ["meta4"] },
  "application/mets+xml": { "source": "iana", "compressible": true, "extensions": ["mets"] },
  "application/mf4": { "source": "iana" },
  "application/mikey": { "source": "iana" },
  "application/mipc": { "source": "iana" },
  "application/missing-blocks+cbor-seq": { "source": "iana" },
  "application/mmt-aei+xml": { "source": "iana", "compressible": true, "extensions": ["maei"] },
  "application/mmt-usd+xml": { "source": "iana", "compressible": true, "extensions": ["musd"] },
  "application/mods+xml": { "source": "iana", "compressible": true, "extensions": ["mods"] },
  "application/moss-keys": { "source": "iana" },
  "application/moss-signature": { "source": "iana" },
  "application/mosskey-data": { "source": "iana" },
  "application/mosskey-request": { "source": "iana" },
  "application/mp21": { "source": "iana", "extensions": ["m21", "mp21"] },
  "application/mp4": { "source": "iana", "extensions": ["mp4s", "m4p"] },
  "application/mpeg4-generic": { "source": "iana" },
  "application/mpeg4-iod": { "source": "iana" },
  "application/mpeg4-iod-xmt": { "source": "iana" },
  "application/mrb-consumer+xml": { "source": "iana", "compressible": true },
  "application/mrb-publish+xml": { "source": "iana", "compressible": true },
  "application/msc-ivr+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msc-mixer+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msword": { "source": "iana", "compressible": false, "extensions": ["doc", "dot"] },
  "application/mud+json": { "source": "iana", "compressible": true },
  "application/multipart-core": { "source": "iana" },
  "application/mxf": { "source": "iana", "extensions": ["mxf"] },
  "application/n-quads": { "source": "iana", "extensions": ["nq"] },
  "application/n-triples": { "source": "iana", "extensions": ["nt"] },
  "application/nasdata": { "source": "iana" },
  "application/news-checkgroups": { "source": "iana", "charset": "US-ASCII" },
  "application/news-groupinfo": { "source": "iana", "charset": "US-ASCII" },
  "application/news-transmission": { "source": "iana" },
  "application/nlsml+xml": { "source": "iana", "compressible": true },
  "application/node": { "source": "iana", "extensions": ["cjs"] },
  "application/nss": { "source": "iana" },
  "application/oauth-authz-req+jwt": { "source": "iana" },
  "application/oblivious-dns-message": { "source": "iana" },
  "application/ocsp-request": { "source": "iana" },
  "application/ocsp-response": { "source": "iana" },
  "application/octet-stream": { "source": "iana", "compressible": false, "extensions": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"] },
  "application/oda": { "source": "iana", "extensions": ["oda"] },
  "application/odm+xml": { "source": "iana", "compressible": true },
  "application/odx": { "source": "iana" },
  "application/oebps-package+xml": { "source": "iana", "compressible": true, "extensions": ["opf"] },
  "application/ogg": { "source": "iana", "compressible": false, "extensions": ["ogx"] },
  "application/omdoc+xml": { "source": "apache", "compressible": true, "extensions": ["omdoc"] },
  "application/onenote": { "source": "apache", "extensions": ["onetoc", "onetoc2", "onetmp", "onepkg"] },
  "application/opc-nodeset+xml": { "source": "iana", "compressible": true },
  "application/oscore": { "source": "iana" },
  "application/oxps": { "source": "iana", "extensions": ["oxps"] },
  "application/p21": { "source": "iana" },
  "application/p21+zip": { "source": "iana", "compressible": false },
  "application/p2p-overlay+xml": { "source": "iana", "compressible": true, "extensions": ["relo"] },
  "application/parityfec": { "source": "iana" },
  "application/passport": { "source": "iana" },
  "application/patch-ops-error+xml": { "source": "iana", "compressible": true, "extensions": ["xer"] },
  "application/pdf": { "source": "iana", "compressible": false, "extensions": ["pdf"] },
  "application/pdx": { "source": "iana" },
  "application/pem-certificate-chain": { "source": "iana" },
  "application/pgp-encrypted": { "source": "iana", "compressible": false, "extensions": ["pgp"] },
  "application/pgp-keys": { "source": "iana", "extensions": ["asc"] },
  "application/pgp-signature": { "source": "iana", "extensions": ["asc", "sig"] },
  "application/pics-rules": { "source": "apache", "extensions": ["prf"] },
  "application/pidf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pidf-diff+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pkcs10": { "source": "iana", "extensions": ["p10"] },
  "application/pkcs12": { "source": "iana" },
  "application/pkcs7-mime": { "source": "iana", "extensions": ["p7m", "p7c"] },
  "application/pkcs7-signature": { "source": "iana", "extensions": ["p7s"] },
  "application/pkcs8": { "source": "iana", "extensions": ["p8"] },
  "application/pkcs8-encrypted": { "source": "iana" },
  "application/pkix-attr-cert": { "source": "iana", "extensions": ["ac"] },
  "application/pkix-cert": { "source": "iana", "extensions": ["cer"] },
  "application/pkix-crl": { "source": "iana", "extensions": ["crl"] },
  "application/pkix-pkipath": { "source": "iana", "extensions": ["pkipath"] },
  "application/pkixcmp": { "source": "iana", "extensions": ["pki"] },
  "application/pls+xml": { "source": "iana", "compressible": true, "extensions": ["pls"] },
  "application/poc-settings+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/postscript": { "source": "iana", "compressible": true, "extensions": ["ai", "eps", "ps"] },
  "application/ppsp-tracker+json": { "source": "iana", "compressible": true },
  "application/problem+json": { "source": "iana", "compressible": true },
  "application/problem+xml": { "source": "iana", "compressible": true },
  "application/provenance+xml": { "source": "iana", "compressible": true, "extensions": ["provx"] },
  "application/prs.alvestrand.titrax-sheet": { "source": "iana" },
  "application/prs.cww": { "source": "iana", "extensions": ["cww"] },
  "application/prs.cyn": { "source": "iana", "charset": "7-BIT" },
  "application/prs.hpub+zip": { "source": "iana", "compressible": false },
  "application/prs.nprend": { "source": "iana" },
  "application/prs.plucker": { "source": "iana" },
  "application/prs.rdf-xml-crypt": { "source": "iana" },
  "application/prs.xsf+xml": { "source": "iana", "compressible": true },
  "application/pskc+xml": { "source": "iana", "compressible": true, "extensions": ["pskcxml"] },
  "application/pvd+json": { "source": "iana", "compressible": true },
  "application/qsig": { "source": "iana" },
  "application/raml+yaml": { "compressible": true, "extensions": ["raml"] },
  "application/raptorfec": { "source": "iana" },
  "application/rdap+json": { "source": "iana", "compressible": true },
  "application/rdf+xml": { "source": "iana", "compressible": true, "extensions": ["rdf", "owl"] },
  "application/reginfo+xml": { "source": "iana", "compressible": true, "extensions": ["rif"] },
  "application/relax-ng-compact-syntax": { "source": "iana", "extensions": ["rnc"] },
  "application/remote-printing": { "source": "iana" },
  "application/reputon+json": { "source": "iana", "compressible": true },
  "application/resource-lists+xml": { "source": "iana", "compressible": true, "extensions": ["rl"] },
  "application/resource-lists-diff+xml": { "source": "iana", "compressible": true, "extensions": ["rld"] },
  "application/rfc+xml": { "source": "iana", "compressible": true },
  "application/riscos": { "source": "iana" },
  "application/rlmi+xml": { "source": "iana", "compressible": true },
  "application/rls-services+xml": { "source": "iana", "compressible": true, "extensions": ["rs"] },
  "application/route-apd+xml": { "source": "iana", "compressible": true, "extensions": ["rapd"] },
  "application/route-s-tsid+xml": { "source": "iana", "compressible": true, "extensions": ["sls"] },
  "application/route-usd+xml": { "source": "iana", "compressible": true, "extensions": ["rusd"] },
  "application/rpki-ghostbusters": { "source": "iana", "extensions": ["gbr"] },
  "application/rpki-manifest": { "source": "iana", "extensions": ["mft"] },
  "application/rpki-publication": { "source": "iana" },
  "application/rpki-roa": { "source": "iana", "extensions": ["roa"] },
  "application/rpki-updown": { "source": "iana" },
  "application/rsd+xml": { "source": "apache", "compressible": true, "extensions": ["rsd"] },
  "application/rss+xml": { "source": "apache", "compressible": true, "extensions": ["rss"] },
  "application/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "application/rtploopback": { "source": "iana" },
  "application/rtx": { "source": "iana" },
  "application/samlassertion+xml": { "source": "iana", "compressible": true },
  "application/samlmetadata+xml": { "source": "iana", "compressible": true },
  "application/sarif+json": { "source": "iana", "compressible": true },
  "application/sarif-external-properties+json": { "source": "iana", "compressible": true },
  "application/sbe": { "source": "iana" },
  "application/sbml+xml": { "source": "iana", "compressible": true, "extensions": ["sbml"] },
  "application/scaip+xml": { "source": "iana", "compressible": true },
  "application/scim+json": { "source": "iana", "compressible": true },
  "application/scvp-cv-request": { "source": "iana", "extensions": ["scq"] },
  "application/scvp-cv-response": { "source": "iana", "extensions": ["scs"] },
  "application/scvp-vp-request": { "source": "iana", "extensions": ["spq"] },
  "application/scvp-vp-response": { "source": "iana", "extensions": ["spp"] },
  "application/sdp": { "source": "iana", "extensions": ["sdp"] },
  "application/secevent+jwt": { "source": "iana" },
  "application/senml+cbor": { "source": "iana" },
  "application/senml+json": { "source": "iana", "compressible": true },
  "application/senml+xml": { "source": "iana", "compressible": true, "extensions": ["senmlx"] },
  "application/senml-etch+cbor": { "source": "iana" },
  "application/senml-etch+json": { "source": "iana", "compressible": true },
  "application/senml-exi": { "source": "iana" },
  "application/sensml+cbor": { "source": "iana" },
  "application/sensml+json": { "source": "iana", "compressible": true },
  "application/sensml+xml": { "source": "iana", "compressible": true, "extensions": ["sensmlx"] },
  "application/sensml-exi": { "source": "iana" },
  "application/sep+xml": { "source": "iana", "compressible": true },
  "application/sep-exi": { "source": "iana" },
  "application/session-info": { "source": "iana" },
  "application/set-payment": { "source": "iana" },
  "application/set-payment-initiation": { "source": "iana", "extensions": ["setpay"] },
  "application/set-registration": { "source": "iana" },
  "application/set-registration-initiation": { "source": "iana", "extensions": ["setreg"] },
  "application/sgml": { "source": "iana" },
  "application/sgml-open-catalog": { "source": "iana" },
  "application/shf+xml": { "source": "iana", "compressible": true, "extensions": ["shf"] },
  "application/sieve": { "source": "iana", "extensions": ["siv", "sieve"] },
  "application/simple-filter+xml": { "source": "iana", "compressible": true },
  "application/simple-message-summary": { "source": "iana" },
  "application/simplesymbolcontainer": { "source": "iana" },
  "application/sipc": { "source": "iana" },
  "application/slate": { "source": "iana" },
  "application/smil": { "source": "iana" },
  "application/smil+xml": { "source": "iana", "compressible": true, "extensions": ["smi", "smil"] },
  "application/smpte336m": { "source": "iana" },
  "application/soap+fastinfoset": { "source": "iana" },
  "application/soap+xml": { "source": "iana", "compressible": true },
  "application/sparql-query": { "source": "iana", "extensions": ["rq"] },
  "application/sparql-results+xml": { "source": "iana", "compressible": true, "extensions": ["srx"] },
  "application/spdx+json": { "source": "iana", "compressible": true },
  "application/spirits-event+xml": { "source": "iana", "compressible": true },
  "application/sql": { "source": "iana" },
  "application/srgs": { "source": "iana", "extensions": ["gram"] },
  "application/srgs+xml": { "source": "iana", "compressible": true, "extensions": ["grxml"] },
  "application/sru+xml": { "source": "iana", "compressible": true, "extensions": ["sru"] },
  "application/ssdl+xml": { "source": "apache", "compressible": true, "extensions": ["ssdl"] },
  "application/ssml+xml": { "source": "iana", "compressible": true, "extensions": ["ssml"] },
  "application/stix+json": { "source": "iana", "compressible": true },
  "application/swid+xml": { "source": "iana", "compressible": true, "extensions": ["swidtag"] },
  "application/tamp-apex-update": { "source": "iana" },
  "application/tamp-apex-update-confirm": { "source": "iana" },
  "application/tamp-community-update": { "source": "iana" },
  "application/tamp-community-update-confirm": { "source": "iana" },
  "application/tamp-error": { "source": "iana" },
  "application/tamp-sequence-adjust": { "source": "iana" },
  "application/tamp-sequence-adjust-confirm": { "source": "iana" },
  "application/tamp-status-query": { "source": "iana" },
  "application/tamp-status-response": { "source": "iana" },
  "application/tamp-update": { "source": "iana" },
  "application/tamp-update-confirm": { "source": "iana" },
  "application/tar": { "compressible": true },
  "application/taxii+json": { "source": "iana", "compressible": true },
  "application/td+json": { "source": "iana", "compressible": true },
  "application/tei+xml": { "source": "iana", "compressible": true, "extensions": ["tei", "teicorpus"] },
  "application/tetra_isi": { "source": "iana" },
  "application/thraud+xml": { "source": "iana", "compressible": true, "extensions": ["tfi"] },
  "application/timestamp-query": { "source": "iana" },
  "application/timestamp-reply": { "source": "iana" },
  "application/timestamped-data": { "source": "iana", "extensions": ["tsd"] },
  "application/tlsrpt+gzip": { "source": "iana" },
  "application/tlsrpt+json": { "source": "iana", "compressible": true },
  "application/tnauthlist": { "source": "iana" },
  "application/token-introspection+jwt": { "source": "iana" },
  "application/toml": { "compressible": true, "extensions": ["toml"] },
  "application/trickle-ice-sdpfrag": { "source": "iana" },
  "application/trig": { "source": "iana", "extensions": ["trig"] },
  "application/ttml+xml": { "source": "iana", "compressible": true, "extensions": ["ttml"] },
  "application/tve-trigger": { "source": "iana" },
  "application/tzif": { "source": "iana" },
  "application/tzif-leap": { "source": "iana" },
  "application/ubjson": { "compressible": false, "extensions": ["ubj"] },
  "application/ulpfec": { "source": "iana" },
  "application/urc-grpsheet+xml": { "source": "iana", "compressible": true },
  "application/urc-ressheet+xml": { "source": "iana", "compressible": true, "extensions": ["rsheet"] },
  "application/urc-targetdesc+xml": { "source": "iana", "compressible": true, "extensions": ["td"] },
  "application/urc-uisocketdesc+xml": { "source": "iana", "compressible": true },
  "application/vcard+json": { "source": "iana", "compressible": true },
  "application/vcard+xml": { "source": "iana", "compressible": true },
  "application/vemmi": { "source": "iana" },
  "application/vividence.scriptfile": { "source": "apache" },
  "application/vnd.1000minds.decision-model+xml": { "source": "iana", "compressible": true, "extensions": ["1km"] },
  "application/vnd.3gpp-prose+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc3ch+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-v2x-local-service-information": { "source": "iana" },
  "application/vnd.3gpp.5gnas": { "source": "iana" },
  "application/vnd.3gpp.access-transfer-events+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.bsf+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gmop+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gtpc": { "source": "iana" },
  "application/vnd.3gpp.interworking-data": { "source": "iana" },
  "application/vnd.3gpp.lpp": { "source": "iana" },
  "application/vnd.3gpp.mc-signalling-ear": { "source": "iana" },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-payload": { "source": "iana" },
  "application/vnd.3gpp.mcdata-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-signalling": { "source": "iana" },
  "application/vnd.3gpp.mcdata-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-floor-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-signed+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mid-call+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ngap": { "source": "iana" },
  "application/vnd.3gpp.pfcp": { "source": "iana" },
  "application/vnd.3gpp.pic-bw-large": { "source": "iana", "extensions": ["plb"] },
  "application/vnd.3gpp.pic-bw-small": { "source": "iana", "extensions": ["psb"] },
  "application/vnd.3gpp.pic-bw-var": { "source": "iana", "extensions": ["pvb"] },
  "application/vnd.3gpp.s1ap": { "source": "iana" },
  "application/vnd.3gpp.sms": { "source": "iana" },
  "application/vnd.3gpp.sms+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-ext+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.state-and-event-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ussd+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.bcmcsinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.sms": { "source": "iana" },
  "application/vnd.3gpp2.tcap": { "source": "iana", "extensions": ["tcap"] },
  "application/vnd.3lightssoftware.imagescal": { "source": "iana" },
  "application/vnd.3m.post-it-notes": { "source": "iana", "extensions": ["pwn"] },
  "application/vnd.accpac.simply.aso": { "source": "iana", "extensions": ["aso"] },
  "application/vnd.accpac.simply.imp": { "source": "iana", "extensions": ["imp"] },
  "application/vnd.acucobol": { "source": "iana", "extensions": ["acu"] },
  "application/vnd.acucorp": { "source": "iana", "extensions": ["atc", "acutc"] },
  "application/vnd.adobe.air-application-installer-package+zip": { "source": "apache", "compressible": false, "extensions": ["air"] },
  "application/vnd.adobe.flash.movie": { "source": "iana" },
  "application/vnd.adobe.formscentral.fcdt": { "source": "iana", "extensions": ["fcdt"] },
  "application/vnd.adobe.fxp": { "source": "iana", "extensions": ["fxp", "fxpl"] },
  "application/vnd.adobe.partial-upload": { "source": "iana" },
  "application/vnd.adobe.xdp+xml": { "source": "iana", "compressible": true, "extensions": ["xdp"] },
  "application/vnd.adobe.xfdf": { "source": "iana", "extensions": ["xfdf"] },
  "application/vnd.aether.imp": { "source": "iana" },
  "application/vnd.afpc.afplinedata": { "source": "iana" },
  "application/vnd.afpc.afplinedata-pagedef": { "source": "iana" },
  "application/vnd.afpc.cmoca-cmresource": { "source": "iana" },
  "application/vnd.afpc.foca-charset": { "source": "iana" },
  "application/vnd.afpc.foca-codedfont": { "source": "iana" },
  "application/vnd.afpc.foca-codepage": { "source": "iana" },
  "application/vnd.afpc.modca": { "source": "iana" },
  "application/vnd.afpc.modca-cmtable": { "source": "iana" },
  "application/vnd.afpc.modca-formdef": { "source": "iana" },
  "application/vnd.afpc.modca-mediummap": { "source": "iana" },
  "application/vnd.afpc.modca-objectcontainer": { "source": "iana" },
  "application/vnd.afpc.modca-overlay": { "source": "iana" },
  "application/vnd.afpc.modca-pagesegment": { "source": "iana" },
  "application/vnd.age": { "source": "iana", "extensions": ["age"] },
  "application/vnd.ah-barcode": { "source": "iana" },
  "application/vnd.ahead.space": { "source": "iana", "extensions": ["ahead"] },
  "application/vnd.airzip.filesecure.azf": { "source": "iana", "extensions": ["azf"] },
  "application/vnd.airzip.filesecure.azs": { "source": "iana", "extensions": ["azs"] },
  "application/vnd.amadeus+json": { "source": "iana", "compressible": true },
  "application/vnd.amazon.ebook": { "source": "apache", "extensions": ["azw"] },
  "application/vnd.amazon.mobi8-ebook": { "source": "iana" },
  "application/vnd.americandynamics.acc": { "source": "iana", "extensions": ["acc"] },
  "application/vnd.amiga.ami": { "source": "iana", "extensions": ["ami"] },
  "application/vnd.amundsen.maze+xml": { "source": "iana", "compressible": true },
  "application/vnd.android.ota": { "source": "iana" },
  "application/vnd.android.package-archive": { "source": "apache", "compressible": false, "extensions": ["apk"] },
  "application/vnd.anki": { "source": "iana" },
  "application/vnd.anser-web-certificate-issue-initiation": { "source": "iana", "extensions": ["cii"] },
  "application/vnd.anser-web-funds-transfer-initiation": { "source": "apache", "extensions": ["fti"] },
  "application/vnd.antix.game-component": { "source": "iana", "extensions": ["atx"] },
  "application/vnd.apache.arrow.file": { "source": "iana" },
  "application/vnd.apache.arrow.stream": { "source": "iana" },
  "application/vnd.apache.thrift.binary": { "source": "iana" },
  "application/vnd.apache.thrift.compact": { "source": "iana" },
  "application/vnd.apache.thrift.json": { "source": "iana" },
  "application/vnd.api+json": { "source": "iana", "compressible": true },
  "application/vnd.aplextor.warrp+json": { "source": "iana", "compressible": true },
  "application/vnd.apothekende.reservation+json": { "source": "iana", "compressible": true },
  "application/vnd.apple.installer+xml": { "source": "iana", "compressible": true, "extensions": ["mpkg"] },
  "application/vnd.apple.keynote": { "source": "iana", "extensions": ["key"] },
  "application/vnd.apple.mpegurl": { "source": "iana", "extensions": ["m3u8"] },
  "application/vnd.apple.numbers": { "source": "iana", "extensions": ["numbers"] },
  "application/vnd.apple.pages": { "source": "iana", "extensions": ["pages"] },
  "application/vnd.apple.pkpass": { "compressible": false, "extensions": ["pkpass"] },
  "application/vnd.arastra.swi": { "source": "iana" },
  "application/vnd.aristanetworks.swi": { "source": "iana", "extensions": ["swi"] },
  "application/vnd.artisan+json": { "source": "iana", "compressible": true },
  "application/vnd.artsquare": { "source": "iana" },
  "application/vnd.astraea-software.iota": { "source": "iana", "extensions": ["iota"] },
  "application/vnd.audiograph": { "source": "iana", "extensions": ["aep"] },
  "application/vnd.autopackage": { "source": "iana" },
  "application/vnd.avalon+json": { "source": "iana", "compressible": true },
  "application/vnd.avistar+xml": { "source": "iana", "compressible": true },
  "application/vnd.balsamiq.bmml+xml": { "source": "iana", "compressible": true, "extensions": ["bmml"] },
  "application/vnd.balsamiq.bmpr": { "source": "iana" },
  "application/vnd.banana-accounting": { "source": "iana" },
  "application/vnd.bbf.usp.error": { "source": "iana" },
  "application/vnd.bbf.usp.msg": { "source": "iana" },
  "application/vnd.bbf.usp.msg+json": { "source": "iana", "compressible": true },
  "application/vnd.bekitzur-stech+json": { "source": "iana", "compressible": true },
  "application/vnd.bint.med-content": { "source": "iana" },
  "application/vnd.biopax.rdf+xml": { "source": "iana", "compressible": true },
  "application/vnd.blink-idb-value-wrapper": { "source": "iana" },
  "application/vnd.blueice.multipass": { "source": "iana", "extensions": ["mpm"] },
  "application/vnd.bluetooth.ep.oob": { "source": "iana" },
  "application/vnd.bluetooth.le.oob": { "source": "iana" },
  "application/vnd.bmi": { "source": "iana", "extensions": ["bmi"] },
  "application/vnd.bpf": { "source": "iana" },
  "application/vnd.bpf3": { "source": "iana" },
  "application/vnd.businessobjects": { "source": "iana", "extensions": ["rep"] },
  "application/vnd.byu.uapi+json": { "source": "iana", "compressible": true },
  "application/vnd.cab-jscript": { "source": "iana" },
  "application/vnd.canon-cpdl": { "source": "iana" },
  "application/vnd.canon-lips": { "source": "iana" },
  "application/vnd.capasystems-pg+json": { "source": "iana", "compressible": true },
  "application/vnd.cendio.thinlinc.clientconf": { "source": "iana" },
  "application/vnd.century-systems.tcp_stream": { "source": "iana" },
  "application/vnd.chemdraw+xml": { "source": "iana", "compressible": true, "extensions": ["cdxml"] },
  "application/vnd.chess-pgn": { "source": "iana" },
  "application/vnd.chipnuts.karaoke-mmd": { "source": "iana", "extensions": ["mmd"] },
  "application/vnd.ciedi": { "source": "iana" },
  "application/vnd.cinderella": { "source": "iana", "extensions": ["cdy"] },
  "application/vnd.cirpack.isdn-ext": { "source": "iana" },
  "application/vnd.citationstyles.style+xml": { "source": "iana", "compressible": true, "extensions": ["csl"] },
  "application/vnd.claymore": { "source": "iana", "extensions": ["cla"] },
  "application/vnd.cloanto.rp9": { "source": "iana", "extensions": ["rp9"] },
  "application/vnd.clonk.c4group": { "source": "iana", "extensions": ["c4g", "c4d", "c4f", "c4p", "c4u"] },
  "application/vnd.cluetrust.cartomobile-config": { "source": "iana", "extensions": ["c11amc"] },
  "application/vnd.cluetrust.cartomobile-config-pkg": { "source": "iana", "extensions": ["c11amz"] },
  "application/vnd.coffeescript": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet-template": { "source": "iana" },
  "application/vnd.collection+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.doc+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.next+json": { "source": "iana", "compressible": true },
  "application/vnd.comicbook+zip": { "source": "iana", "compressible": false },
  "application/vnd.comicbook-rar": { "source": "iana" },
  "application/vnd.commerce-battelle": { "source": "iana" },
  "application/vnd.commonspace": { "source": "iana", "extensions": ["csp"] },
  "application/vnd.contact.cmsg": { "source": "iana", "extensions": ["cdbcmsg"] },
  "application/vnd.coreos.ignition+json": { "source": "iana", "compressible": true },
  "application/vnd.cosmocaller": { "source": "iana", "extensions": ["cmc"] },
  "application/vnd.crick.clicker": { "source": "iana", "extensions": ["clkx"] },
  "application/vnd.crick.clicker.keyboard": { "source": "iana", "extensions": ["clkk"] },
  "application/vnd.crick.clicker.palette": { "source": "iana", "extensions": ["clkp"] },
  "application/vnd.crick.clicker.template": { "source": "iana", "extensions": ["clkt"] },
  "application/vnd.crick.clicker.wordbank": { "source": "iana", "extensions": ["clkw"] },
  "application/vnd.criticaltools.wbs+xml": { "source": "iana", "compressible": true, "extensions": ["wbs"] },
  "application/vnd.cryptii.pipe+json": { "source": "iana", "compressible": true },
  "application/vnd.crypto-shade-file": { "source": "iana" },
  "application/vnd.cryptomator.encrypted": { "source": "iana" },
  "application/vnd.cryptomator.vault": { "source": "iana" },
  "application/vnd.ctc-posml": { "source": "iana", "extensions": ["pml"] },
  "application/vnd.ctct.ws+xml": { "source": "iana", "compressible": true },
  "application/vnd.cups-pdf": { "source": "iana" },
  "application/vnd.cups-postscript": { "source": "iana" },
  "application/vnd.cups-ppd": { "source": "iana", "extensions": ["ppd"] },
  "application/vnd.cups-raster": { "source": "iana" },
  "application/vnd.cups-raw": { "source": "iana" },
  "application/vnd.curl": { "source": "iana" },
  "application/vnd.curl.car": { "source": "apache", "extensions": ["car"] },
  "application/vnd.curl.pcurl": { "source": "apache", "extensions": ["pcurl"] },
  "application/vnd.cyan.dean.root+xml": { "source": "iana", "compressible": true },
  "application/vnd.cybank": { "source": "iana" },
  "application/vnd.cyclonedx+json": { "source": "iana", "compressible": true },
  "application/vnd.cyclonedx+xml": { "source": "iana", "compressible": true },
  "application/vnd.d2l.coursepackage1p0+zip": { "source": "iana", "compressible": false },
  "application/vnd.d3m-dataset": { "source": "iana" },
  "application/vnd.d3m-problem": { "source": "iana" },
  "application/vnd.dart": { "source": "iana", "compressible": true, "extensions": ["dart"] },
  "application/vnd.data-vision.rdz": { "source": "iana", "extensions": ["rdz"] },
  "application/vnd.datapackage+json": { "source": "iana", "compressible": true },
  "application/vnd.dataresource+json": { "source": "iana", "compressible": true },
  "application/vnd.dbf": { "source": "iana", "extensions": ["dbf"] },
  "application/vnd.debian.binary-package": { "source": "iana" },
  "application/vnd.dece.data": { "source": "iana", "extensions": ["uvf", "uvvf", "uvd", "uvvd"] },
  "application/vnd.dece.ttml+xml": { "source": "iana", "compressible": true, "extensions": ["uvt", "uvvt"] },
  "application/vnd.dece.unspecified": { "source": "iana", "extensions": ["uvx", "uvvx"] },
  "application/vnd.dece.zip": { "source": "iana", "extensions": ["uvz", "uvvz"] },
  "application/vnd.denovo.fcselayout-link": { "source": "iana", "extensions": ["fe_launch"] },
  "application/vnd.desmume.movie": { "source": "iana" },
  "application/vnd.dir-bi.plate-dl-nosuffix": { "source": "iana" },
  "application/vnd.dm.delegation+xml": { "source": "iana", "compressible": true },
  "application/vnd.dna": { "source": "iana", "extensions": ["dna"] },
  "application/vnd.document+json": { "source": "iana", "compressible": true },
  "application/vnd.dolby.mlp": { "source": "apache", "extensions": ["mlp"] },
  "application/vnd.dolby.mobile.1": { "source": "iana" },
  "application/vnd.dolby.mobile.2": { "source": "iana" },
  "application/vnd.doremir.scorecloud-binary-document": { "source": "iana" },
  "application/vnd.dpgraph": { "source": "iana", "extensions": ["dpg"] },
  "application/vnd.dreamfactory": { "source": "iana", "extensions": ["dfac"] },
  "application/vnd.drive+json": { "source": "iana", "compressible": true },
  "application/vnd.ds-keypoint": { "source": "apache", "extensions": ["kpxx"] },
  "application/vnd.dtg.local": { "source": "iana" },
  "application/vnd.dtg.local.flash": { "source": "iana" },
  "application/vnd.dtg.local.html": { "source": "iana" },
  "application/vnd.dvb.ait": { "source": "iana", "extensions": ["ait"] },
  "application/vnd.dvb.dvbisl+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.dvbj": { "source": "iana" },
  "application/vnd.dvb.esgcontainer": { "source": "iana" },
  "application/vnd.dvb.ipdcdftnotifaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess2": { "source": "iana" },
  "application/vnd.dvb.ipdcesgpdd": { "source": "iana" },
  "application/vnd.dvb.ipdcroaming": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-base": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-enhancement": { "source": "iana" },
  "application/vnd.dvb.notif-aggregate-root+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-container+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-generic+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-msglist+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-response+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-init+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.pfr": { "source": "iana" },
  "application/vnd.dvb.service": { "source": "iana", "extensions": ["svc"] },
  "application/vnd.dxr": { "source": "iana" },
  "application/vnd.dynageo": { "source": "iana", "extensions": ["geo"] },
  "application/vnd.dzr": { "source": "iana" },
  "application/vnd.easykaraoke.cdgdownload": { "source": "iana" },
  "application/vnd.ecdis-update": { "source": "iana" },
  "application/vnd.ecip.rlp": { "source": "iana" },
  "application/vnd.eclipse.ditto+json": { "source": "iana", "compressible": true },
  "application/vnd.ecowin.chart": { "source": "iana", "extensions": ["mag"] },
  "application/vnd.ecowin.filerequest": { "source": "iana" },
  "application/vnd.ecowin.fileupdate": { "source": "iana" },
  "application/vnd.ecowin.series": { "source": "iana" },
  "application/vnd.ecowin.seriesrequest": { "source": "iana" },
  "application/vnd.ecowin.seriesupdate": { "source": "iana" },
  "application/vnd.efi.img": { "source": "iana" },
  "application/vnd.efi.iso": { "source": "iana" },
  "application/vnd.emclient.accessrequest+xml": { "source": "iana", "compressible": true },
  "application/vnd.enliven": { "source": "iana", "extensions": ["nml"] },
  "application/vnd.enphase.envoy": { "source": "iana" },
  "application/vnd.eprints.data+xml": { "source": "iana", "compressible": true },
  "application/vnd.epson.esf": { "source": "iana", "extensions": ["esf"] },
  "application/vnd.epson.msf": { "source": "iana", "extensions": ["msf"] },
  "application/vnd.epson.quickanime": { "source": "iana", "extensions": ["qam"] },
  "application/vnd.epson.salt": { "source": "iana", "extensions": ["slt"] },
  "application/vnd.epson.ssf": { "source": "iana", "extensions": ["ssf"] },
  "application/vnd.ericsson.quickcall": { "source": "iana" },
  "application/vnd.espass-espass+zip": { "source": "iana", "compressible": false },
  "application/vnd.eszigno3+xml": { "source": "iana", "compressible": true, "extensions": ["es3", "et3"] },
  "application/vnd.etsi.aoc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.asic-e+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.asic-s+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.cug+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvcommand+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-bc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-cod+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-npvr+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvservice+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsync+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mcid+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mheg5": { "source": "iana" },
  "application/vnd.etsi.overload-control-policy-dataset+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.pstn+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.sci+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.simservs+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.timestamp-token": { "source": "iana" },
  "application/vnd.etsi.tsl+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.tsl.der": { "source": "iana" },
  "application/vnd.eu.kasparian.car+json": { "source": "iana", "compressible": true },
  "application/vnd.eudora.data": { "source": "iana" },
  "application/vnd.evolv.ecig.profile": { "source": "iana" },
  "application/vnd.evolv.ecig.settings": { "source": "iana" },
  "application/vnd.evolv.ecig.theme": { "source": "iana" },
  "application/vnd.exstream-empower+zip": { "source": "iana", "compressible": false },
  "application/vnd.exstream-package": { "source": "iana" },
  "application/vnd.ezpix-album": { "source": "iana", "extensions": ["ez2"] },
  "application/vnd.ezpix-package": { "source": "iana", "extensions": ["ez3"] },
  "application/vnd.f-secure.mobile": { "source": "iana" },
  "application/vnd.familysearch.gedcom+zip": { "source": "iana", "compressible": false },
  "application/vnd.fastcopy-disk-image": { "source": "iana" },
  "application/vnd.fdf": { "source": "iana", "extensions": ["fdf"] },
  "application/vnd.fdsn.mseed": { "source": "iana", "extensions": ["mseed"] },
  "application/vnd.fdsn.seed": { "source": "iana", "extensions": ["seed", "dataless"] },
  "application/vnd.ffsns": { "source": "iana" },
  "application/vnd.ficlab.flb+zip": { "source": "iana", "compressible": false },
  "application/vnd.filmit.zfc": { "source": "iana" },
  "application/vnd.fints": { "source": "iana" },
  "application/vnd.firemonkeys.cloudcell": { "source": "iana" },
  "application/vnd.flographit": { "source": "iana", "extensions": ["gph"] },
  "application/vnd.fluxtime.clip": { "source": "iana", "extensions": ["ftc"] },
  "application/vnd.font-fontforge-sfd": { "source": "iana" },
  "application/vnd.framemaker": { "source": "iana", "extensions": ["fm", "frame", "maker", "book"] },
  "application/vnd.frogans.fnc": { "source": "iana", "extensions": ["fnc"] },
  "application/vnd.frogans.ltf": { "source": "iana", "extensions": ["ltf"] },
  "application/vnd.fsc.weblaunch": { "source": "iana", "extensions": ["fsc"] },
  "application/vnd.fujifilm.fb.docuworks": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.binder": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.container": { "source": "iana" },
  "application/vnd.fujifilm.fb.jfi+xml": { "source": "iana", "compressible": true },
  "application/vnd.fujitsu.oasys": { "source": "iana", "extensions": ["oas"] },
  "application/vnd.fujitsu.oasys2": { "source": "iana", "extensions": ["oa2"] },
  "application/vnd.fujitsu.oasys3": { "source": "iana", "extensions": ["oa3"] },
  "application/vnd.fujitsu.oasysgp": { "source": "iana", "extensions": ["fg5"] },
  "application/vnd.fujitsu.oasysprs": { "source": "iana", "extensions": ["bh2"] },
  "application/vnd.fujixerox.art-ex": { "source": "iana" },
  "application/vnd.fujixerox.art4": { "source": "iana" },
  "application/vnd.fujixerox.ddd": { "source": "iana", "extensions": ["ddd"] },
  "application/vnd.fujixerox.docuworks": { "source": "iana", "extensions": ["xdw"] },
  "application/vnd.fujixerox.docuworks.binder": { "source": "iana", "extensions": ["xbd"] },
  "application/vnd.fujixerox.docuworks.container": { "source": "iana" },
  "application/vnd.fujixerox.hbpl": { "source": "iana" },
  "application/vnd.fut-misnet": { "source": "iana" },
  "application/vnd.futoin+cbor": { "source": "iana" },
  "application/vnd.futoin+json": { "source": "iana", "compressible": true },
  "application/vnd.fuzzysheet": { "source": "iana", "extensions": ["fzs"] },
  "application/vnd.genomatix.tuxedo": { "source": "iana", "extensions": ["txd"] },
  "application/vnd.gentics.grd+json": { "source": "iana", "compressible": true },
  "application/vnd.geo+json": { "source": "iana", "compressible": true },
  "application/vnd.geocube+xml": { "source": "iana", "compressible": true },
  "application/vnd.geogebra.file": { "source": "iana", "extensions": ["ggb"] },
  "application/vnd.geogebra.slides": { "source": "iana" },
  "application/vnd.geogebra.tool": { "source": "iana", "extensions": ["ggt"] },
  "application/vnd.geometry-explorer": { "source": "iana", "extensions": ["gex", "gre"] },
  "application/vnd.geonext": { "source": "iana", "extensions": ["gxt"] },
  "application/vnd.geoplan": { "source": "iana", "extensions": ["g2w"] },
  "application/vnd.geospace": { "source": "iana", "extensions": ["g3w"] },
  "application/vnd.gerber": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt-response": { "source": "iana" },
  "application/vnd.gmx": { "source": "iana", "extensions": ["gmx"] },
  "application/vnd.google-apps.document": { "compressible": false, "extensions": ["gdoc"] },
  "application/vnd.google-apps.presentation": { "compressible": false, "extensions": ["gslides"] },
  "application/vnd.google-apps.spreadsheet": { "compressible": false, "extensions": ["gsheet"] },
  "application/vnd.google-earth.kml+xml": { "source": "iana", "compressible": true, "extensions": ["kml"] },
  "application/vnd.google-earth.kmz": { "source": "iana", "compressible": false, "extensions": ["kmz"] },
  "application/vnd.gov.sk.e-form+xml": { "source": "iana", "compressible": true },
  "application/vnd.gov.sk.e-form+zip": { "source": "iana", "compressible": false },
  "application/vnd.gov.sk.xmldatacontainer+xml": { "source": "iana", "compressible": true },
  "application/vnd.grafeq": { "source": "iana", "extensions": ["gqf", "gqs"] },
  "application/vnd.gridmp": { "source": "iana" },
  "application/vnd.groove-account": { "source": "iana", "extensions": ["gac"] },
  "application/vnd.groove-help": { "source": "iana", "extensions": ["ghf"] },
  "application/vnd.groove-identity-message": { "source": "iana", "extensions": ["gim"] },
  "application/vnd.groove-injector": { "source": "iana", "extensions": ["grv"] },
  "application/vnd.groove-tool-message": { "source": "iana", "extensions": ["gtm"] },
  "application/vnd.groove-tool-template": { "source": "iana", "extensions": ["tpl"] },
  "application/vnd.groove-vcard": { "source": "iana", "extensions": ["vcg"] },
  "application/vnd.hal+json": { "source": "iana", "compressible": true },
  "application/vnd.hal+xml": { "source": "iana", "compressible": true, "extensions": ["hal"] },
  "application/vnd.handheld-entertainment+xml": { "source": "iana", "compressible": true, "extensions": ["zmm"] },
  "application/vnd.hbci": { "source": "iana", "extensions": ["hbci"] },
  "application/vnd.hc+json": { "source": "iana", "compressible": true },
  "application/vnd.hcl-bireports": { "source": "iana" },
  "application/vnd.hdt": { "source": "iana" },
  "application/vnd.heroku+json": { "source": "iana", "compressible": true },
  "application/vnd.hhe.lesson-player": { "source": "iana", "extensions": ["les"] },
  "application/vnd.hl7cda+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.hl7v2+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.hp-hpgl": { "source": "iana", "extensions": ["hpgl"] },
  "application/vnd.hp-hpid": { "source": "iana", "extensions": ["hpid"] },
  "application/vnd.hp-hps": { "source": "iana", "extensions": ["hps"] },
  "application/vnd.hp-jlyt": { "source": "iana", "extensions": ["jlt"] },
  "application/vnd.hp-pcl": { "source": "iana", "extensions": ["pcl"] },
  "application/vnd.hp-pclxl": { "source": "iana", "extensions": ["pclxl"] },
  "application/vnd.httphone": { "source": "iana" },
  "application/vnd.hydrostatix.sof-data": { "source": "iana", "extensions": ["sfd-hdstx"] },
  "application/vnd.hyper+json": { "source": "iana", "compressible": true },
  "application/vnd.hyper-item+json": { "source": "iana", "compressible": true },
  "application/vnd.hyperdrive+json": { "source": "iana", "compressible": true },
  "application/vnd.hzn-3d-crossword": { "source": "iana" },
  "application/vnd.ibm.afplinedata": { "source": "iana" },
  "application/vnd.ibm.electronic-media": { "source": "iana" },
  "application/vnd.ibm.minipay": { "source": "iana", "extensions": ["mpy"] },
  "application/vnd.ibm.modcap": { "source": "iana", "extensions": ["afp", "listafp", "list3820"] },
  "application/vnd.ibm.rights-management": { "source": "iana", "extensions": ["irm"] },
  "application/vnd.ibm.secure-container": { "source": "iana", "extensions": ["sc"] },
  "application/vnd.iccprofile": { "source": "iana", "extensions": ["icc", "icm"] },
  "application/vnd.ieee.1905": { "source": "iana" },
  "application/vnd.igloader": { "source": "iana", "extensions": ["igl"] },
  "application/vnd.imagemeter.folder+zip": { "source": "iana", "compressible": false },
  "application/vnd.imagemeter.image+zip": { "source": "iana", "compressible": false },
  "application/vnd.immervision-ivp": { "source": "iana", "extensions": ["ivp"] },
  "application/vnd.immervision-ivu": { "source": "iana", "extensions": ["ivu"] },
  "application/vnd.ims.imsccv1p1": { "source": "iana" },
  "application/vnd.ims.imsccv1p2": { "source": "iana" },
  "application/vnd.ims.imsccv1p3": { "source": "iana" },
  "application/vnd.ims.lis.v2.result+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy.id+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": { "source": "iana", "compressible": true },
  "application/vnd.informedcontrol.rms+xml": { "source": "iana", "compressible": true },
  "application/vnd.informix-visionary": { "source": "iana" },
  "application/vnd.infotech.project": { "source": "iana" },
  "application/vnd.infotech.project+xml": { "source": "iana", "compressible": true },
  "application/vnd.innopath.wamp.notification": { "source": "iana" },
  "application/vnd.insors.igm": { "source": "iana", "extensions": ["igm"] },
  "application/vnd.intercon.formnet": { "source": "iana", "extensions": ["xpw", "xpx"] },
  "application/vnd.intergeo": { "source": "iana", "extensions": ["i2g"] },
  "application/vnd.intertrust.digibox": { "source": "iana" },
  "application/vnd.intertrust.nncp": { "source": "iana" },
  "application/vnd.intu.qbo": { "source": "iana", "extensions": ["qbo"] },
  "application/vnd.intu.qfx": { "source": "iana", "extensions": ["qfx"] },
  "application/vnd.iptc.g2.catalogitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.conceptitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.knowledgeitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.packageitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.planningitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.ipunplugged.rcprofile": { "source": "iana", "extensions": ["rcprofile"] },
  "application/vnd.irepository.package+xml": { "source": "iana", "compressible": true, "extensions": ["irp"] },
  "application/vnd.is-xpr": { "source": "iana", "extensions": ["xpr"] },
  "application/vnd.isac.fcs": { "source": "iana", "extensions": ["fcs"] },
  "application/vnd.iso11783-10+zip": { "source": "iana", "compressible": false },
  "application/vnd.jam": { "source": "iana", "extensions": ["jam"] },
  "application/vnd.japannet-directory-service": { "source": "iana" },
  "application/vnd.japannet-jpnstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-payment-wakeup": { "source": "iana" },
  "application/vnd.japannet-registration": { "source": "iana" },
  "application/vnd.japannet-registration-wakeup": { "source": "iana" },
  "application/vnd.japannet-setstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-verification": { "source": "iana" },
  "application/vnd.japannet-verification-wakeup": { "source": "iana" },
  "application/vnd.jcp.javame.midlet-rms": { "source": "iana", "extensions": ["rms"] },
  "application/vnd.jisp": { "source": "iana", "extensions": ["jisp"] },
  "application/vnd.joost.joda-archive": { "source": "iana", "extensions": ["joda"] },
  "application/vnd.jsk.isdn-ngn": { "source": "iana" },
  "application/vnd.kahootz": { "source": "iana", "extensions": ["ktz", "ktr"] },
  "application/vnd.kde.karbon": { "source": "iana", "extensions": ["karbon"] },
  "application/vnd.kde.kchart": { "source": "iana", "extensions": ["chrt"] },
  "application/vnd.kde.kformula": { "source": "iana", "extensions": ["kfo"] },
  "application/vnd.kde.kivio": { "source": "iana", "extensions": ["flw"] },
  "application/vnd.kde.kontour": { "source": "iana", "extensions": ["kon"] },
  "application/vnd.kde.kpresenter": { "source": "iana", "extensions": ["kpr", "kpt"] },
  "application/vnd.kde.kspread": { "source": "iana", "extensions": ["ksp"] },
  "application/vnd.kde.kword": { "source": "iana", "extensions": ["kwd", "kwt"] },
  "application/vnd.kenameaapp": { "source": "iana", "extensions": ["htke"] },
  "application/vnd.kidspiration": { "source": "iana", "extensions": ["kia"] },
  "application/vnd.kinar": { "source": "iana", "extensions": ["kne", "knp"] },
  "application/vnd.koan": { "source": "iana", "extensions": ["skp", "skd", "skt", "skm"] },
  "application/vnd.kodak-descriptor": { "source": "iana", "extensions": ["sse"] },
  "application/vnd.las": { "source": "iana" },
  "application/vnd.las.las+json": { "source": "iana", "compressible": true },
  "application/vnd.las.las+xml": { "source": "iana", "compressible": true, "extensions": ["lasxml"] },
  "application/vnd.laszip": { "source": "iana" },
  "application/vnd.leap+json": { "source": "iana", "compressible": true },
  "application/vnd.liberty-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.llamagraphics.life-balance.desktop": { "source": "iana", "extensions": ["lbd"] },
  "application/vnd.llamagraphics.life-balance.exchange+xml": { "source": "iana", "compressible": true, "extensions": ["lbe"] },
  "application/vnd.logipipe.circuit+zip": { "source": "iana", "compressible": false },
  "application/vnd.loom": { "source": "iana" },
  "application/vnd.lotus-1-2-3": { "source": "iana", "extensions": ["123"] },
  "application/vnd.lotus-approach": { "source": "iana", "extensions": ["apr"] },
  "application/vnd.lotus-freelance": { "source": "iana", "extensions": ["pre"] },
  "application/vnd.lotus-notes": { "source": "iana", "extensions": ["nsf"] },
  "application/vnd.lotus-organizer": { "source": "iana", "extensions": ["org"] },
  "application/vnd.lotus-screencam": { "source": "iana", "extensions": ["scm"] },
  "application/vnd.lotus-wordpro": { "source": "iana", "extensions": ["lwp"] },
  "application/vnd.macports.portpkg": { "source": "iana", "extensions": ["portpkg"] },
  "application/vnd.mapbox-vector-tile": { "source": "iana", "extensions": ["mvt"] },
  "application/vnd.marlin.drm.actiontoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.conftoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.license+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.mdcf": { "source": "iana" },
  "application/vnd.mason+json": { "source": "iana", "compressible": true },
  "application/vnd.maxar.archive.3tz+zip": { "source": "iana", "compressible": false },
  "application/vnd.maxmind.maxmind-db": { "source": "iana" },
  "application/vnd.mcd": { "source": "iana", "extensions": ["mcd"] },
  "application/vnd.medcalcdata": { "source": "iana", "extensions": ["mc1"] },
  "application/vnd.mediastation.cdkey": { "source": "iana", "extensions": ["cdkey"] },
  "application/vnd.meridian-slingshot": { "source": "iana" },
  "application/vnd.mfer": { "source": "iana", "extensions": ["mwf"] },
  "application/vnd.mfmp": { "source": "iana", "extensions": ["mfm"] },
  "application/vnd.micro+json": { "source": "iana", "compressible": true },
  "application/vnd.micrografx.flo": { "source": "iana", "extensions": ["flo"] },
  "application/vnd.micrografx.igx": { "source": "iana", "extensions": ["igx"] },
  "application/vnd.microsoft.portable-executable": { "source": "iana" },
  "application/vnd.microsoft.windows.thumbnail-cache": { "source": "iana" },
  "application/vnd.miele+json": { "source": "iana", "compressible": true },
  "application/vnd.mif": { "source": "iana", "extensions": ["mif"] },
  "application/vnd.minisoft-hp3000-save": { "source": "iana" },
  "application/vnd.mitsubishi.misty-guard.trustweb": { "source": "iana" },
  "application/vnd.mobius.daf": { "source": "iana", "extensions": ["daf"] },
  "application/vnd.mobius.dis": { "source": "iana", "extensions": ["dis"] },
  "application/vnd.mobius.mbk": { "source": "iana", "extensions": ["mbk"] },
  "application/vnd.mobius.mqy": { "source": "iana", "extensions": ["mqy"] },
  "application/vnd.mobius.msl": { "source": "iana", "extensions": ["msl"] },
  "application/vnd.mobius.plc": { "source": "iana", "extensions": ["plc"] },
  "application/vnd.mobius.txf": { "source": "iana", "extensions": ["txf"] },
  "application/vnd.mophun.application": { "source": "iana", "extensions": ["mpn"] },
  "application/vnd.mophun.certificate": { "source": "iana", "extensions": ["mpc"] },
  "application/vnd.motorola.flexsuite": { "source": "iana" },
  "application/vnd.motorola.flexsuite.adsi": { "source": "iana" },
  "application/vnd.motorola.flexsuite.fis": { "source": "iana" },
  "application/vnd.motorola.flexsuite.gotap": { "source": "iana" },
  "application/vnd.motorola.flexsuite.kmr": { "source": "iana" },
  "application/vnd.motorola.flexsuite.ttc": { "source": "iana" },
  "application/vnd.motorola.flexsuite.wem": { "source": "iana" },
  "application/vnd.motorola.iprm": { "source": "iana" },
  "application/vnd.mozilla.xul+xml": { "source": "iana", "compressible": true, "extensions": ["xul"] },
  "application/vnd.ms-3mfdocument": { "source": "iana" },
  "application/vnd.ms-artgalry": { "source": "iana", "extensions": ["cil"] },
  "application/vnd.ms-asf": { "source": "iana" },
  "application/vnd.ms-cab-compressed": { "source": "iana", "extensions": ["cab"] },
  "application/vnd.ms-color.iccprofile": { "source": "apache" },
  "application/vnd.ms-excel": { "source": "iana", "compressible": false, "extensions": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"] },
  "application/vnd.ms-excel.addin.macroenabled.12": { "source": "iana", "extensions": ["xlam"] },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": { "source": "iana", "extensions": ["xlsb"] },
  "application/vnd.ms-excel.sheet.macroenabled.12": { "source": "iana", "extensions": ["xlsm"] },
  "application/vnd.ms-excel.template.macroenabled.12": { "source": "iana", "extensions": ["xltm"] },
  "application/vnd.ms-fontobject": { "source": "iana", "compressible": true, "extensions": ["eot"] },
  "application/vnd.ms-htmlhelp": { "source": "iana", "extensions": ["chm"] },
  "application/vnd.ms-ims": { "source": "iana", "extensions": ["ims"] },
  "application/vnd.ms-lrm": { "source": "iana", "extensions": ["lrm"] },
  "application/vnd.ms-office.activex+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-officetheme": { "source": "iana", "extensions": ["thmx"] },
  "application/vnd.ms-opentype": { "source": "apache", "compressible": true },
  "application/vnd.ms-outlook": { "compressible": false, "extensions": ["msg"] },
  "application/vnd.ms-package.obfuscated-opentype": { "source": "apache" },
  "application/vnd.ms-pki.seccat": { "source": "apache", "extensions": ["cat"] },
  "application/vnd.ms-pki.stl": { "source": "apache", "extensions": ["stl"] },
  "application/vnd.ms-playready.initiator+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-powerpoint": { "source": "iana", "compressible": false, "extensions": ["ppt", "pps", "pot"] },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": { "source": "iana", "extensions": ["ppam"] },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": { "source": "iana", "extensions": ["pptm"] },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": { "source": "iana", "extensions": ["sldm"] },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": { "source": "iana", "extensions": ["ppsm"] },
  "application/vnd.ms-powerpoint.template.macroenabled.12": { "source": "iana", "extensions": ["potm"] },
  "application/vnd.ms-printdevicecapabilities+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-printing.printticket+xml": { "source": "apache", "compressible": true },
  "application/vnd.ms-printschematicket+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-project": { "source": "iana", "extensions": ["mpp", "mpt"] },
  "application/vnd.ms-tnef": { "source": "iana" },
  "application/vnd.ms-windows.devicepairing": { "source": "iana" },
  "application/vnd.ms-windows.nwprinting.oob": { "source": "iana" },
  "application/vnd.ms-windows.printerpairing": { "source": "iana" },
  "application/vnd.ms-windows.wsd.oob": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-resp": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-resp": { "source": "iana" },
  "application/vnd.ms-word.document.macroenabled.12": { "source": "iana", "extensions": ["docm"] },
  "application/vnd.ms-word.template.macroenabled.12": { "source": "iana", "extensions": ["dotm"] },
  "application/vnd.ms-works": { "source": "iana", "extensions": ["wps", "wks", "wcm", "wdb"] },
  "application/vnd.ms-wpl": { "source": "iana", "extensions": ["wpl"] },
  "application/vnd.ms-xpsdocument": { "source": "iana", "compressible": false, "extensions": ["xps"] },
  "application/vnd.msa-disk-image": { "source": "iana" },
  "application/vnd.mseq": { "source": "iana", "extensions": ["mseq"] },
  "application/vnd.msign": { "source": "iana" },
  "application/vnd.multiad.creator": { "source": "iana" },
  "application/vnd.multiad.creator.cif": { "source": "iana" },
  "application/vnd.music-niff": { "source": "iana" },
  "application/vnd.musician": { "source": "iana", "extensions": ["mus"] },
  "application/vnd.muvee.style": { "source": "iana", "extensions": ["msty"] },
  "application/vnd.mynfc": { "source": "iana", "extensions": ["taglet"] },
  "application/vnd.nacamar.ybrid+json": { "source": "iana", "compressible": true },
  "application/vnd.ncd.control": { "source": "iana" },
  "application/vnd.ncd.reference": { "source": "iana" },
  "application/vnd.nearst.inv+json": { "source": "iana", "compressible": true },
  "application/vnd.nebumind.line": { "source": "iana" },
  "application/vnd.nervana": { "source": "iana" },
  "application/vnd.netfpx": { "source": "iana" },
  "application/vnd.neurolanguage.nlu": { "source": "iana", "extensions": ["nlu"] },
  "application/vnd.nimn": { "source": "iana" },
  "application/vnd.nintendo.nitro.rom": { "source": "iana" },
  "application/vnd.nintendo.snes.rom": { "source": "iana" },
  "application/vnd.nitf": { "source": "iana", "extensions": ["ntf", "nitf"] },
  "application/vnd.noblenet-directory": { "source": "iana", "extensions": ["nnd"] },
  "application/vnd.noblenet-sealer": { "source": "iana", "extensions": ["nns"] },
  "application/vnd.noblenet-web": { "source": "iana", "extensions": ["nnw"] },
  "application/vnd.nokia.catalogs": { "source": "iana" },
  "application/vnd.nokia.conml+wbxml": { "source": "iana" },
  "application/vnd.nokia.conml+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.iptv.config+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.isds-radio-presets": { "source": "iana" },
  "application/vnd.nokia.landmark+wbxml": { "source": "iana" },
  "application/vnd.nokia.landmark+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.landmarkcollection+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.n-gage.ac+xml": { "source": "iana", "compressible": true, "extensions": ["ac"] },
  "application/vnd.nokia.n-gage.data": { "source": "iana", "extensions": ["ngdat"] },
  "application/vnd.nokia.n-gage.symbian.install": { "source": "iana", "extensions": ["n-gage"] },
  "application/vnd.nokia.ncd": { "source": "iana" },
  "application/vnd.nokia.pcd+wbxml": { "source": "iana" },
  "application/vnd.nokia.pcd+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.radio-preset": { "source": "iana", "extensions": ["rpst"] },
  "application/vnd.nokia.radio-presets": { "source": "iana", "extensions": ["rpss"] },
  "application/vnd.novadigm.edm": { "source": "iana", "extensions": ["edm"] },
  "application/vnd.novadigm.edx": { "source": "iana", "extensions": ["edx"] },
  "application/vnd.novadigm.ext": { "source": "iana", "extensions": ["ext"] },
  "application/vnd.ntt-local.content-share": { "source": "iana" },
  "application/vnd.ntt-local.file-transfer": { "source": "iana" },
  "application/vnd.ntt-local.ogw_remote-access": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_remote": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_tcp_stream": { "source": "iana" },
  "application/vnd.oasis.opendocument.chart": { "source": "iana", "extensions": ["odc"] },
  "application/vnd.oasis.opendocument.chart-template": { "source": "iana", "extensions": ["otc"] },
  "application/vnd.oasis.opendocument.database": { "source": "iana", "extensions": ["odb"] },
  "application/vnd.oasis.opendocument.formula": { "source": "iana", "extensions": ["odf"] },
  "application/vnd.oasis.opendocument.formula-template": { "source": "iana", "extensions": ["odft"] },
  "application/vnd.oasis.opendocument.graphics": { "source": "iana", "compressible": false, "extensions": ["odg"] },
  "application/vnd.oasis.opendocument.graphics-template": { "source": "iana", "extensions": ["otg"] },
  "application/vnd.oasis.opendocument.image": { "source": "iana", "extensions": ["odi"] },
  "application/vnd.oasis.opendocument.image-template": { "source": "iana", "extensions": ["oti"] },
  "application/vnd.oasis.opendocument.presentation": { "source": "iana", "compressible": false, "extensions": ["odp"] },
  "application/vnd.oasis.opendocument.presentation-template": { "source": "iana", "extensions": ["otp"] },
  "application/vnd.oasis.opendocument.spreadsheet": { "source": "iana", "compressible": false, "extensions": ["ods"] },
  "application/vnd.oasis.opendocument.spreadsheet-template": { "source": "iana", "extensions": ["ots"] },
  "application/vnd.oasis.opendocument.text": { "source": "iana", "compressible": false, "extensions": ["odt"] },
  "application/vnd.oasis.opendocument.text-master": { "source": "iana", "extensions": ["odm"] },
  "application/vnd.oasis.opendocument.text-template": { "source": "iana", "extensions": ["ott"] },
  "application/vnd.oasis.opendocument.text-web": { "source": "iana", "extensions": ["oth"] },
  "application/vnd.obn": { "source": "iana" },
  "application/vnd.ocf+cbor": { "source": "iana" },
  "application/vnd.oci.image.manifest.v1+json": { "source": "iana", "compressible": true },
  "application/vnd.oftn.l10n+json": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessdownload+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessstreaming+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.cspg-hexbinary": { "source": "iana" },
  "application/vnd.oipf.dae.svg+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.dae.xhtml+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.mippvcontrolmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.pae.gem": { "source": "iana" },
  "application/vnd.oipf.spdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.spdlist+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.ueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.userprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.olpc-sugar": { "source": "iana", "extensions": ["xo"] },
  "application/vnd.oma-scws-config": { "source": "iana" },
  "application/vnd.oma-scws-http-request": { "source": "iana" },
  "application/vnd.oma-scws-http-response": { "source": "iana" },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.drm-trigger+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.imd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.ltkm": { "source": "iana" },
  "application/vnd.oma.bcast.notification+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.provisioningtrigger": { "source": "iana" },
  "application/vnd.oma.bcast.sgboot": { "source": "iana" },
  "application/vnd.oma.bcast.sgdd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.sgdu": { "source": "iana" },
  "application/vnd.oma.bcast.simple-symbol-container": { "source": "iana" },
  "application/vnd.oma.bcast.smartcard-trigger+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.sprov+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.stkm": { "source": "iana" },
  "application/vnd.oma.cab-address-book+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-feature-handler+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-pcc+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-subs-invite+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-user-prefs+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.dcd": { "source": "iana" },
  "application/vnd.oma.dcdc": { "source": "iana" },
  "application/vnd.oma.dd2+xml": { "source": "iana", "compressible": true, "extensions": ["dd2"] },
  "application/vnd.oma.drm.risd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.group-usage-list+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+cbor": { "source": "iana" },
  "application/vnd.oma.lwm2m+json": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+tlv": { "source": "iana" },
  "application/vnd.oma.pal+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.detailed-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.final-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.groups+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.invocation-descriptor+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.optimized-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.push": { "source": "iana" },
  "application/vnd.oma.scidm.messages+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.xcap-directory+xml": { "source": "iana", "compressible": true },
  "application/vnd.omads-email+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-file+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-folder+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omaloc-supl-init": { "source": "iana" },
  "application/vnd.onepager": { "source": "iana" },
  "application/vnd.onepagertamp": { "source": "iana" },
  "application/vnd.onepagertamx": { "source": "iana" },
  "application/vnd.onepagertat": { "source": "iana" },
  "application/vnd.onepagertatp": { "source": "iana" },
  "application/vnd.onepagertatx": { "source": "iana" },
  "application/vnd.openblox.game+xml": { "source": "iana", "compressible": true, "extensions": ["obgx"] },
  "application/vnd.openblox.game-binary": { "source": "iana" },
  "application/vnd.openeye.oeb": { "source": "iana" },
  "application/vnd.openofficeorg.extension": { "source": "apache", "extensions": ["oxt"] },
  "application/vnd.openstreetmap.data+xml": { "source": "iana", "compressible": true, "extensions": ["osm"] },
  "application/vnd.opentimestamps.ots": { "source": "iana" },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawing+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": { "source": "iana", "compressible": false, "extensions": ["pptx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": { "source": "iana", "extensions": ["sldx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": { "source": "iana", "extensions": ["ppsx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.template": { "source": "iana", "extensions": ["potx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": { "source": "iana", "compressible": false, "extensions": ["xlsx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": { "source": "iana", "extensions": ["xltx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.theme+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.vmldrawing": { "source": "iana" },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": { "source": "iana", "compressible": false, "extensions": ["docx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": { "source": "iana", "extensions": ["dotx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.core-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.relationships+xml": { "source": "iana", "compressible": true },
  "application/vnd.oracle.resource+json": { "source": "iana", "compressible": true },
  "application/vnd.orange.indata": { "source": "iana" },
  "application/vnd.osa.netdeploy": { "source": "iana" },
  "application/vnd.osgeo.mapguide.package": { "source": "iana", "extensions": ["mgp"] },
  "application/vnd.osgi.bundle": { "source": "iana" },
  "application/vnd.osgi.dp": { "source": "iana", "extensions": ["dp"] },
  "application/vnd.osgi.subsystem": { "source": "iana", "extensions": ["esa"] },
  "application/vnd.otps.ct-kip+xml": { "source": "iana", "compressible": true },
  "application/vnd.oxli.countgraph": { "source": "iana" },
  "application/vnd.pagerduty+json": { "source": "iana", "compressible": true },
  "application/vnd.palm": { "source": "iana", "extensions": ["pdb", "pqa", "oprc"] },
  "application/vnd.panoply": { "source": "iana" },
  "application/vnd.paos.xml": { "source": "iana" },
  "application/vnd.patentdive": { "source": "iana" },
  "application/vnd.patientecommsdoc": { "source": "iana" },
  "application/vnd.pawaafile": { "source": "iana", "extensions": ["paw"] },
  "application/vnd.pcos": { "source": "iana" },
  "application/vnd.pg.format": { "source": "iana", "extensions": ["str"] },
  "application/vnd.pg.osasli": { "source": "iana", "extensions": ["ei6"] },
  "application/vnd.piaccess.application-licence": { "source": "iana" },
  "application/vnd.picsel": { "source": "iana", "extensions": ["efif"] },
  "application/vnd.pmi.widget": { "source": "iana", "extensions": ["wg"] },
  "application/vnd.poc.group-advertisement+xml": { "source": "iana", "compressible": true },
  "application/vnd.pocketlearn": { "source": "iana", "extensions": ["plf"] },
  "application/vnd.powerbuilder6": { "source": "iana", "extensions": ["pbd"] },
  "application/vnd.powerbuilder6-s": { "source": "iana" },
  "application/vnd.powerbuilder7": { "source": "iana" },
  "application/vnd.powerbuilder7-s": { "source": "iana" },
  "application/vnd.powerbuilder75": { "source": "iana" },
  "application/vnd.powerbuilder75-s": { "source": "iana" },
  "application/vnd.preminet": { "source": "iana" },
  "application/vnd.previewsystems.box": { "source": "iana", "extensions": ["box"] },
  "application/vnd.proteus.magazine": { "source": "iana", "extensions": ["mgz"] },
  "application/vnd.psfs": { "source": "iana" },
  "application/vnd.publishare-delta-tree": { "source": "iana", "extensions": ["qps"] },
  "application/vnd.pvi.ptid1": { "source": "iana", "extensions": ["ptid"] },
  "application/vnd.pwg-multiplexed": { "source": "iana" },
  "application/vnd.pwg-xhtml-print+xml": { "source": "iana", "compressible": true },
  "application/vnd.qualcomm.brew-app-res": { "source": "iana" },
  "application/vnd.quarantainenet": { "source": "iana" },
  "application/vnd.quark.quarkxpress": { "source": "iana", "extensions": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"] },
  "application/vnd.quobject-quoxdocument": { "source": "iana" },
  "application/vnd.radisys.moml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conn+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-stream+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-base+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-group+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-speech+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-transform+xml": { "source": "iana", "compressible": true },
  "application/vnd.rainstor.data": { "source": "iana" },
  "application/vnd.rapid": { "source": "iana" },
  "application/vnd.rar": { "source": "iana", "extensions": ["rar"] },
  "application/vnd.realvnc.bed": { "source": "iana", "extensions": ["bed"] },
  "application/vnd.recordare.musicxml": { "source": "iana", "extensions": ["mxl"] },
  "application/vnd.recordare.musicxml+xml": { "source": "iana", "compressible": true, "extensions": ["musicxml"] },
  "application/vnd.renlearn.rlprint": { "source": "iana" },
  "application/vnd.resilient.logic": { "source": "iana" },
  "application/vnd.restful+json": { "source": "iana", "compressible": true },
  "application/vnd.rig.cryptonote": { "source": "iana", "extensions": ["cryptonote"] },
  "application/vnd.rim.cod": { "source": "apache", "extensions": ["cod"] },
  "application/vnd.rn-realmedia": { "source": "apache", "extensions": ["rm"] },
  "application/vnd.rn-realmedia-vbr": { "source": "apache", "extensions": ["rmvb"] },
  "application/vnd.route66.link66+xml": { "source": "iana", "compressible": true, "extensions": ["link66"] },
  "application/vnd.rs-274x": { "source": "iana" },
  "application/vnd.ruckus.download": { "source": "iana" },
  "application/vnd.s3sms": { "source": "iana" },
  "application/vnd.sailingtracker.track": { "source": "iana", "extensions": ["st"] },
  "application/vnd.sar": { "source": "iana" },
  "application/vnd.sbm.cid": { "source": "iana" },
  "application/vnd.sbm.mid2": { "source": "iana" },
  "application/vnd.scribus": { "source": "iana" },
  "application/vnd.sealed.3df": { "source": "iana" },
  "application/vnd.sealed.csf": { "source": "iana" },
  "application/vnd.sealed.doc": { "source": "iana" },
  "application/vnd.sealed.eml": { "source": "iana" },
  "application/vnd.sealed.mht": { "source": "iana" },
  "application/vnd.sealed.net": { "source": "iana" },
  "application/vnd.sealed.ppt": { "source": "iana" },
  "application/vnd.sealed.tiff": { "source": "iana" },
  "application/vnd.sealed.xls": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.html": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.pdf": { "source": "iana" },
  "application/vnd.seemail": { "source": "iana", "extensions": ["see"] },
  "application/vnd.seis+json": { "source": "iana", "compressible": true },
  "application/vnd.sema": { "source": "iana", "extensions": ["sema"] },
  "application/vnd.semd": { "source": "iana", "extensions": ["semd"] },
  "application/vnd.semf": { "source": "iana", "extensions": ["semf"] },
  "application/vnd.shade-save-file": { "source": "iana" },
  "application/vnd.shana.informed.formdata": { "source": "iana", "extensions": ["ifm"] },
  "application/vnd.shana.informed.formtemplate": { "source": "iana", "extensions": ["itp"] },
  "application/vnd.shana.informed.interchange": { "source": "iana", "extensions": ["iif"] },
  "application/vnd.shana.informed.package": { "source": "iana", "extensions": ["ipk"] },
  "application/vnd.shootproof+json": { "source": "iana", "compressible": true },
  "application/vnd.shopkick+json": { "source": "iana", "compressible": true },
  "application/vnd.shp": { "source": "iana" },
  "application/vnd.shx": { "source": "iana" },
  "application/vnd.sigrok.session": { "source": "iana" },
  "application/vnd.simtech-mindmapper": { "source": "iana", "extensions": ["twd", "twds"] },
  "application/vnd.siren+json": { "source": "iana", "compressible": true },
  "application/vnd.smaf": { "source": "iana", "extensions": ["mmf"] },
  "application/vnd.smart.notebook": { "source": "iana" },
  "application/vnd.smart.teacher": { "source": "iana", "extensions": ["teacher"] },
  "application/vnd.snesdev-page-table": { "source": "iana" },
  "application/vnd.software602.filler.form+xml": { "source": "iana", "compressible": true, "extensions": ["fo"] },
  "application/vnd.software602.filler.form-xml-zip": { "source": "iana" },
  "application/vnd.solent.sdkm+xml": { "source": "iana", "compressible": true, "extensions": ["sdkm", "sdkd"] },
  "application/vnd.spotfire.dxp": { "source": "iana", "extensions": ["dxp"] },
  "application/vnd.spotfire.sfs": { "source": "iana", "extensions": ["sfs"] },
  "application/vnd.sqlite3": { "source": "iana" },
  "application/vnd.sss-cod": { "source": "iana" },
  "application/vnd.sss-dtf": { "source": "iana" },
  "application/vnd.sss-ntf": { "source": "iana" },
  "application/vnd.stardivision.calc": { "source": "apache", "extensions": ["sdc"] },
  "application/vnd.stardivision.draw": { "source": "apache", "extensions": ["sda"] },
  "application/vnd.stardivision.impress": { "source": "apache", "extensions": ["sdd"] },
  "application/vnd.stardivision.math": { "source": "apache", "extensions": ["smf"] },
  "application/vnd.stardivision.writer": { "source": "apache", "extensions": ["sdw", "vor"] },
  "application/vnd.stardivision.writer-global": { "source": "apache", "extensions": ["sgl"] },
  "application/vnd.stepmania.package": { "source": "iana", "extensions": ["smzip"] },
  "application/vnd.stepmania.stepchart": { "source": "iana", "extensions": ["sm"] },
  "application/vnd.street-stream": { "source": "iana" },
  "application/vnd.sun.wadl+xml": { "source": "iana", "compressible": true, "extensions": ["wadl"] },
  "application/vnd.sun.xml.calc": { "source": "apache", "extensions": ["sxc"] },
  "application/vnd.sun.xml.calc.template": { "source": "apache", "extensions": ["stc"] },
  "application/vnd.sun.xml.draw": { "source": "apache", "extensions": ["sxd"] },
  "application/vnd.sun.xml.draw.template": { "source": "apache", "extensions": ["std"] },
  "application/vnd.sun.xml.impress": { "source": "apache", "extensions": ["sxi"] },
  "application/vnd.sun.xml.impress.template": { "source": "apache", "extensions": ["sti"] },
  "application/vnd.sun.xml.math": { "source": "apache", "extensions": ["sxm"] },
  "application/vnd.sun.xml.writer": { "source": "apache", "extensions": ["sxw"] },
  "application/vnd.sun.xml.writer.global": { "source": "apache", "extensions": ["sxg"] },
  "application/vnd.sun.xml.writer.template": { "source": "apache", "extensions": ["stw"] },
  "application/vnd.sus-calendar": { "source": "iana", "extensions": ["sus", "susp"] },
  "application/vnd.svd": { "source": "iana", "extensions": ["svd"] },
  "application/vnd.swiftview-ics": { "source": "iana" },
  "application/vnd.sycle+xml": { "source": "iana", "compressible": true },
  "application/vnd.syft+json": { "source": "iana", "compressible": true },
  "application/vnd.symbian.install": { "source": "apache", "extensions": ["sis", "sisx"] },
  "application/vnd.syncml+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xsm"] },
  "application/vnd.syncml.dm+wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["bdm"] },
  "application/vnd.syncml.dm+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xdm"] },
  "application/vnd.syncml.dm.notification": { "source": "iana" },
  "application/vnd.syncml.dmddf+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmddf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["ddf"] },
  "application/vnd.syncml.dmtnds+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmtnds+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.syncml.ds.notification": { "source": "iana" },
  "application/vnd.tableschema+json": { "source": "iana", "compressible": true },
  "application/vnd.tao.intent-module-archive": { "source": "iana", "extensions": ["tao"] },
  "application/vnd.tcpdump.pcap": { "source": "iana", "extensions": ["pcap", "cap", "dmp"] },
  "application/vnd.think-cell.ppttc+json": { "source": "iana", "compressible": true },
  "application/vnd.tmd.mediaflex.api+xml": { "source": "iana", "compressible": true },
  "application/vnd.tml": { "source": "iana" },
  "application/vnd.tmobile-livetv": { "source": "iana", "extensions": ["tmo"] },
  "application/vnd.tri.onesource": { "source": "iana" },
  "application/vnd.trid.tpt": { "source": "iana", "extensions": ["tpt"] },
  "application/vnd.triscape.mxs": { "source": "iana", "extensions": ["mxs"] },
  "application/vnd.trueapp": { "source": "iana", "extensions": ["tra"] },
  "application/vnd.truedoc": { "source": "iana" },
  "application/vnd.ubisoft.webplayer": { "source": "iana" },
  "application/vnd.ufdl": { "source": "iana", "extensions": ["ufd", "ufdl"] },
  "application/vnd.uiq.theme": { "source": "iana", "extensions": ["utz"] },
  "application/vnd.umajin": { "source": "iana", "extensions": ["umj"] },
  "application/vnd.unity": { "source": "iana", "extensions": ["unityweb"] },
  "application/vnd.uoml+xml": { "source": "iana", "compressible": true, "extensions": ["uoml"] },
  "application/vnd.uplanet.alert": { "source": "iana" },
  "application/vnd.uplanet.alert-wbxml": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice-wbxml": { "source": "iana" },
  "application/vnd.uplanet.cacheop": { "source": "iana" },
  "application/vnd.uplanet.cacheop-wbxml": { "source": "iana" },
  "application/vnd.uplanet.channel": { "source": "iana" },
  "application/vnd.uplanet.channel-wbxml": { "source": "iana" },
  "application/vnd.uplanet.list": { "source": "iana" },
  "application/vnd.uplanet.list-wbxml": { "source": "iana" },
  "application/vnd.uplanet.listcmd": { "source": "iana" },
  "application/vnd.uplanet.listcmd-wbxml": { "source": "iana" },
  "application/vnd.uplanet.signal": { "source": "iana" },
  "application/vnd.uri-map": { "source": "iana" },
  "application/vnd.valve.source.material": { "source": "iana" },
  "application/vnd.vcx": { "source": "iana", "extensions": ["vcx"] },
  "application/vnd.vd-study": { "source": "iana" },
  "application/vnd.vectorworks": { "source": "iana" },
  "application/vnd.vel+json": { "source": "iana", "compressible": true },
  "application/vnd.verimatrix.vcas": { "source": "iana" },
  "application/vnd.veritone.aion+json": { "source": "iana", "compressible": true },
  "application/vnd.veryant.thin": { "source": "iana" },
  "application/vnd.ves.encrypted": { "source": "iana" },
  "application/vnd.vidsoft.vidconference": { "source": "iana" },
  "application/vnd.visio": { "source": "iana", "extensions": ["vsd", "vst", "vss", "vsw"] },
  "application/vnd.visionary": { "source": "iana", "extensions": ["vis"] },
  "application/vnd.vividence.scriptfile": { "source": "iana" },
  "application/vnd.vsf": { "source": "iana", "extensions": ["vsf"] },
  "application/vnd.wap.sic": { "source": "iana" },
  "application/vnd.wap.slc": { "source": "iana" },
  "application/vnd.wap.wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["wbxml"] },
  "application/vnd.wap.wmlc": { "source": "iana", "extensions": ["wmlc"] },
  "application/vnd.wap.wmlscriptc": { "source": "iana", "extensions": ["wmlsc"] },
  "application/vnd.webturbo": { "source": "iana", "extensions": ["wtb"] },
  "application/vnd.wfa.dpp": { "source": "iana" },
  "application/vnd.wfa.p2p": { "source": "iana" },
  "application/vnd.wfa.wsc": { "source": "iana" },
  "application/vnd.windows.devicepairing": { "source": "iana" },
  "application/vnd.wmc": { "source": "iana" },
  "application/vnd.wmf.bootstrap": { "source": "iana" },
  "application/vnd.wolfram.mathematica": { "source": "iana" },
  "application/vnd.wolfram.mathematica.package": { "source": "iana" },
  "application/vnd.wolfram.player": { "source": "iana", "extensions": ["nbp"] },
  "application/vnd.wordperfect": { "source": "iana", "extensions": ["wpd"] },
  "application/vnd.wqd": { "source": "iana", "extensions": ["wqd"] },
  "application/vnd.wrq-hp3000-labelled": { "source": "iana" },
  "application/vnd.wt.stf": { "source": "iana", "extensions": ["stf"] },
  "application/vnd.wv.csp+wbxml": { "source": "iana" },
  "application/vnd.wv.csp+xml": { "source": "iana", "compressible": true },
  "application/vnd.wv.ssp+xml": { "source": "iana", "compressible": true },
  "application/vnd.xacml+json": { "source": "iana", "compressible": true },
  "application/vnd.xara": { "source": "iana", "extensions": ["xar"] },
  "application/vnd.xfdl": { "source": "iana", "extensions": ["xfdl"] },
  "application/vnd.xfdl.webform": { "source": "iana" },
  "application/vnd.xmi+xml": { "source": "iana", "compressible": true },
  "application/vnd.xmpie.cpkg": { "source": "iana" },
  "application/vnd.xmpie.dpkg": { "source": "iana" },
  "application/vnd.xmpie.plan": { "source": "iana" },
  "application/vnd.xmpie.ppkg": { "source": "iana" },
  "application/vnd.xmpie.xlim": { "source": "iana" },
  "application/vnd.yamaha.hv-dic": { "source": "iana", "extensions": ["hvd"] },
  "application/vnd.yamaha.hv-script": { "source": "iana", "extensions": ["hvs"] },
  "application/vnd.yamaha.hv-voice": { "source": "iana", "extensions": ["hvp"] },
  "application/vnd.yamaha.openscoreformat": { "source": "iana", "extensions": ["osf"] },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": { "source": "iana", "compressible": true, "extensions": ["osfpvg"] },
  "application/vnd.yamaha.remote-setup": { "source": "iana" },
  "application/vnd.yamaha.smaf-audio": { "source": "iana", "extensions": ["saf"] },
  "application/vnd.yamaha.smaf-phrase": { "source": "iana", "extensions": ["spf"] },
  "application/vnd.yamaha.through-ngn": { "source": "iana" },
  "application/vnd.yamaha.tunnel-udpencap": { "source": "iana" },
  "application/vnd.yaoweme": { "source": "iana" },
  "application/vnd.yellowriver-custom-menu": { "source": "iana", "extensions": ["cmp"] },
  "application/vnd.youtube.yt": { "source": "iana" },
  "application/vnd.zul": { "source": "iana", "extensions": ["zir", "zirz"] },
  "application/vnd.zzazz.deck+xml": { "source": "iana", "compressible": true, "extensions": ["zaz"] },
  "application/voicexml+xml": { "source": "iana", "compressible": true, "extensions": ["vxml"] },
  "application/voucher-cms+json": { "source": "iana", "compressible": true },
  "application/vq-rtcpxr": { "source": "iana" },
  "application/wasm": { "source": "iana", "compressible": true, "extensions": ["wasm"] },
  "application/watcherinfo+xml": { "source": "iana", "compressible": true, "extensions": ["wif"] },
  "application/webpush-options+json": { "source": "iana", "compressible": true },
  "application/whoispp-query": { "source": "iana" },
  "application/whoispp-response": { "source": "iana" },
  "application/widget": { "source": "iana", "extensions": ["wgt"] },
  "application/winhlp": { "source": "apache", "extensions": ["hlp"] },
  "application/wita": { "source": "iana" },
  "application/wordperfect5.1": { "source": "iana" },
  "application/wsdl+xml": { "source": "iana", "compressible": true, "extensions": ["wsdl"] },
  "application/wspolicy+xml": { "source": "iana", "compressible": true, "extensions": ["wspolicy"] },
  "application/x-7z-compressed": { "source": "apache", "compressible": false, "extensions": ["7z"] },
  "application/x-abiword": { "source": "apache", "extensions": ["abw"] },
  "application/x-ace-compressed": { "source": "apache", "extensions": ["ace"] },
  "application/x-amf": { "source": "apache" },
  "application/x-apple-diskimage": { "source": "apache", "extensions": ["dmg"] },
  "application/x-arj": { "compressible": false, "extensions": ["arj"] },
  "application/x-authorware-bin": { "source": "apache", "extensions": ["aab", "x32", "u32", "vox"] },
  "application/x-authorware-map": { "source": "apache", "extensions": ["aam"] },
  "application/x-authorware-seg": { "source": "apache", "extensions": ["aas"] },
  "application/x-bcpio": { "source": "apache", "extensions": ["bcpio"] },
  "application/x-bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/x-bittorrent": { "source": "apache", "extensions": ["torrent"] },
  "application/x-blorb": { "source": "apache", "extensions": ["blb", "blorb"] },
  "application/x-bzip": { "source": "apache", "compressible": false, "extensions": ["bz"] },
  "application/x-bzip2": { "source": "apache", "compressible": false, "extensions": ["bz2", "boz"] },
  "application/x-cbr": { "source": "apache", "extensions": ["cbr", "cba", "cbt", "cbz", "cb7"] },
  "application/x-cdlink": { "source": "apache", "extensions": ["vcd"] },
  "application/x-cfs-compressed": { "source": "apache", "extensions": ["cfs"] },
  "application/x-chat": { "source": "apache", "extensions": ["chat"] },
  "application/x-chess-pgn": { "source": "apache", "extensions": ["pgn"] },
  "application/x-chrome-extension": { "extensions": ["crx"] },
  "application/x-cocoa": { "source": "nginx", "extensions": ["cco"] },
  "application/x-compress": { "source": "apache" },
  "application/x-conference": { "source": "apache", "extensions": ["nsc"] },
  "application/x-cpio": { "source": "apache", "extensions": ["cpio"] },
  "application/x-csh": { "source": "apache", "extensions": ["csh"] },
  "application/x-deb": { "compressible": false },
  "application/x-debian-package": { "source": "apache", "extensions": ["deb", "udeb"] },
  "application/x-dgc-compressed": { "source": "apache", "extensions": ["dgc"] },
  "application/x-director": { "source": "apache", "extensions": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"] },
  "application/x-doom": { "source": "apache", "extensions": ["wad"] },
  "application/x-dtbncx+xml": { "source": "apache", "compressible": true, "extensions": ["ncx"] },
  "application/x-dtbook+xml": { "source": "apache", "compressible": true, "extensions": ["dtb"] },
  "application/x-dtbresource+xml": { "source": "apache", "compressible": true, "extensions": ["res"] },
  "application/x-dvi": { "source": "apache", "compressible": false, "extensions": ["dvi"] },
  "application/x-envoy": { "source": "apache", "extensions": ["evy"] },
  "application/x-eva": { "source": "apache", "extensions": ["eva"] },
  "application/x-font-bdf": { "source": "apache", "extensions": ["bdf"] },
  "application/x-font-dos": { "source": "apache" },
  "application/x-font-framemaker": { "source": "apache" },
  "application/x-font-ghostscript": { "source": "apache", "extensions": ["gsf"] },
  "application/x-font-libgrx": { "source": "apache" },
  "application/x-font-linux-psf": { "source": "apache", "extensions": ["psf"] },
  "application/x-font-pcf": { "source": "apache", "extensions": ["pcf"] },
  "application/x-font-snf": { "source": "apache", "extensions": ["snf"] },
  "application/x-font-speedo": { "source": "apache" },
  "application/x-font-sunos-news": { "source": "apache" },
  "application/x-font-type1": { "source": "apache", "extensions": ["pfa", "pfb", "pfm", "afm"] },
  "application/x-font-vfont": { "source": "apache" },
  "application/x-freearc": { "source": "apache", "extensions": ["arc"] },
  "application/x-futuresplash": { "source": "apache", "extensions": ["spl"] },
  "application/x-gca-compressed": { "source": "apache", "extensions": ["gca"] },
  "application/x-glulx": { "source": "apache", "extensions": ["ulx"] },
  "application/x-gnumeric": { "source": "apache", "extensions": ["gnumeric"] },
  "application/x-gramps-xml": { "source": "apache", "extensions": ["gramps"] },
  "application/x-gtar": { "source": "apache", "extensions": ["gtar"] },
  "application/x-gzip": { "source": "apache" },
  "application/x-hdf": { "source": "apache", "extensions": ["hdf"] },
  "application/x-httpd-php": { "compressible": true, "extensions": ["php"] },
  "application/x-install-instructions": { "source": "apache", "extensions": ["install"] },
  "application/x-iso9660-image": { "source": "apache", "extensions": ["iso"] },
  "application/x-iwork-keynote-sffkey": { "extensions": ["key"] },
  "application/x-iwork-numbers-sffnumbers": { "extensions": ["numbers"] },
  "application/x-iwork-pages-sffpages": { "extensions": ["pages"] },
  "application/x-java-archive-diff": { "source": "nginx", "extensions": ["jardiff"] },
  "application/x-java-jnlp-file": { "source": "apache", "compressible": false, "extensions": ["jnlp"] },
  "application/x-javascript": { "compressible": true },
  "application/x-keepass2": { "extensions": ["kdbx"] },
  "application/x-latex": { "source": "apache", "compressible": false, "extensions": ["latex"] },
  "application/x-lua-bytecode": { "extensions": ["luac"] },
  "application/x-lzh-compressed": { "source": "apache", "extensions": ["lzh", "lha"] },
  "application/x-makeself": { "source": "nginx", "extensions": ["run"] },
  "application/x-mie": { "source": "apache", "extensions": ["mie"] },
  "application/x-mobipocket-ebook": { "source": "apache", "extensions": ["prc", "mobi"] },
  "application/x-mpegurl": { "compressible": false },
  "application/x-ms-application": { "source": "apache", "extensions": ["application"] },
  "application/x-ms-shortcut": { "source": "apache", "extensions": ["lnk"] },
  "application/x-ms-wmd": { "source": "apache", "extensions": ["wmd"] },
  "application/x-ms-wmz": { "source": "apache", "extensions": ["wmz"] },
  "application/x-ms-xbap": { "source": "apache", "extensions": ["xbap"] },
  "application/x-msaccess": { "source": "apache", "extensions": ["mdb"] },
  "application/x-msbinder": { "source": "apache", "extensions": ["obd"] },
  "application/x-mscardfile": { "source": "apache", "extensions": ["crd"] },
  "application/x-msclip": { "source": "apache", "extensions": ["clp"] },
  "application/x-msdos-program": { "extensions": ["exe"] },
  "application/x-msdownload": { "source": "apache", "extensions": ["exe", "dll", "com", "bat", "msi"] },
  "application/x-msmediaview": { "source": "apache", "extensions": ["mvb", "m13", "m14"] },
  "application/x-msmetafile": { "source": "apache", "extensions": ["wmf", "wmz", "emf", "emz"] },
  "application/x-msmoney": { "source": "apache", "extensions": ["mny"] },
  "application/x-mspublisher": { "source": "apache", "extensions": ["pub"] },
  "application/x-msschedule": { "source": "apache", "extensions": ["scd"] },
  "application/x-msterminal": { "source": "apache", "extensions": ["trm"] },
  "application/x-mswrite": { "source": "apache", "extensions": ["wri"] },
  "application/x-netcdf": { "source": "apache", "extensions": ["nc", "cdf"] },
  "application/x-ns-proxy-autoconfig": { "compressible": true, "extensions": ["pac"] },
  "application/x-nzb": { "source": "apache", "extensions": ["nzb"] },
  "application/x-perl": { "source": "nginx", "extensions": ["pl", "pm"] },
  "application/x-pilot": { "source": "nginx", "extensions": ["prc", "pdb"] },
  "application/x-pkcs12": { "source": "apache", "compressible": false, "extensions": ["p12", "pfx"] },
  "application/x-pkcs7-certificates": { "source": "apache", "extensions": ["p7b", "spc"] },
  "application/x-pkcs7-certreqresp": { "source": "apache", "extensions": ["p7r"] },
  "application/x-pki-message": { "source": "iana" },
  "application/x-rar-compressed": { "source": "apache", "compressible": false, "extensions": ["rar"] },
  "application/x-redhat-package-manager": { "source": "nginx", "extensions": ["rpm"] },
  "application/x-research-info-systems": { "source": "apache", "extensions": ["ris"] },
  "application/x-sea": { "source": "nginx", "extensions": ["sea"] },
  "application/x-sh": { "source": "apache", "compressible": true, "extensions": ["sh"] },
  "application/x-shar": { "source": "apache", "extensions": ["shar"] },
  "application/x-shockwave-flash": { "source": "apache", "compressible": false, "extensions": ["swf"] },
  "application/x-silverlight-app": { "source": "apache", "extensions": ["xap"] },
  "application/x-sql": { "source": "apache", "extensions": ["sql"] },
  "application/x-stuffit": { "source": "apache", "compressible": false, "extensions": ["sit"] },
  "application/x-stuffitx": { "source": "apache", "extensions": ["sitx"] },
  "application/x-subrip": { "source": "apache", "extensions": ["srt"] },
  "application/x-sv4cpio": { "source": "apache", "extensions": ["sv4cpio"] },
  "application/x-sv4crc": { "source": "apache", "extensions": ["sv4crc"] },
  "application/x-t3vm-image": { "source": "apache", "extensions": ["t3"] },
  "application/x-tads": { "source": "apache", "extensions": ["gam"] },
  "application/x-tar": { "source": "apache", "compressible": true, "extensions": ["tar"] },
  "application/x-tcl": { "source": "apache", "extensions": ["tcl", "tk"] },
  "application/x-tex": { "source": "apache", "extensions": ["tex"] },
  "application/x-tex-tfm": { "source": "apache", "extensions": ["tfm"] },
  "application/x-texinfo": { "source": "apache", "extensions": ["texinfo", "texi"] },
  "application/x-tgif": { "source": "apache", "extensions": ["obj"] },
  "application/x-ustar": { "source": "apache", "extensions": ["ustar"] },
  "application/x-virtualbox-hdd": { "compressible": true, "extensions": ["hdd"] },
  "application/x-virtualbox-ova": { "compressible": true, "extensions": ["ova"] },
  "application/x-virtualbox-ovf": { "compressible": true, "extensions": ["ovf"] },
  "application/x-virtualbox-vbox": { "compressible": true, "extensions": ["vbox"] },
  "application/x-virtualbox-vbox-extpack": { "compressible": false, "extensions": ["vbox-extpack"] },
  "application/x-virtualbox-vdi": { "compressible": true, "extensions": ["vdi"] },
  "application/x-virtualbox-vhd": { "compressible": true, "extensions": ["vhd"] },
  "application/x-virtualbox-vmdk": { "compressible": true, "extensions": ["vmdk"] },
  "application/x-wais-source": { "source": "apache", "extensions": ["src"] },
  "application/x-web-app-manifest+json": { "compressible": true, "extensions": ["webapp"] },
  "application/x-www-form-urlencoded": { "source": "iana", "compressible": true },
  "application/x-x509-ca-cert": { "source": "iana", "extensions": ["der", "crt", "pem"] },
  "application/x-x509-ca-ra-cert": { "source": "iana" },
  "application/x-x509-next-ca-cert": { "source": "iana" },
  "application/x-xfig": { "source": "apache", "extensions": ["fig"] },
  "application/x-xliff+xml": { "source": "apache", "compressible": true, "extensions": ["xlf"] },
  "application/x-xpinstall": { "source": "apache", "compressible": false, "extensions": ["xpi"] },
  "application/x-xz": { "source": "apache", "extensions": ["xz"] },
  "application/x-zmachine": { "source": "apache", "extensions": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"] },
  "application/x400-bp": { "source": "iana" },
  "application/xacml+xml": { "source": "iana", "compressible": true },
  "application/xaml+xml": { "source": "apache", "compressible": true, "extensions": ["xaml"] },
  "application/xcap-att+xml": { "source": "iana", "compressible": true, "extensions": ["xav"] },
  "application/xcap-caps+xml": { "source": "iana", "compressible": true, "extensions": ["xca"] },
  "application/xcap-diff+xml": { "source": "iana", "compressible": true, "extensions": ["xdf"] },
  "application/xcap-el+xml": { "source": "iana", "compressible": true, "extensions": ["xel"] },
  "application/xcap-error+xml": { "source": "iana", "compressible": true },
  "application/xcap-ns+xml": { "source": "iana", "compressible": true, "extensions": ["xns"] },
  "application/xcon-conference-info+xml": { "source": "iana", "compressible": true },
  "application/xcon-conference-info-diff+xml": { "source": "iana", "compressible": true },
  "application/xenc+xml": { "source": "iana", "compressible": true, "extensions": ["xenc"] },
  "application/xhtml+xml": { "source": "iana", "compressible": true, "extensions": ["xhtml", "xht"] },
  "application/xhtml-voice+xml": { "source": "apache", "compressible": true },
  "application/xliff+xml": { "source": "iana", "compressible": true, "extensions": ["xlf"] },
  "application/xml": { "source": "iana", "compressible": true, "extensions": ["xml", "xsl", "xsd", "rng"] },
  "application/xml-dtd": { "source": "iana", "compressible": true, "extensions": ["dtd"] },
  "application/xml-external-parsed-entity": { "source": "iana" },
  "application/xml-patch+xml": { "source": "iana", "compressible": true },
  "application/xmpp+xml": { "source": "iana", "compressible": true },
  "application/xop+xml": { "source": "iana", "compressible": true, "extensions": ["xop"] },
  "application/xproc+xml": { "source": "apache", "compressible": true, "extensions": ["xpl"] },
  "application/xslt+xml": { "source": "iana", "compressible": true, "extensions": ["xsl", "xslt"] },
  "application/xspf+xml": { "source": "apache", "compressible": true, "extensions": ["xspf"] },
  "application/xv+xml": { "source": "iana", "compressible": true, "extensions": ["mxml", "xhvml", "xvml", "xvm"] },
  "application/yang": { "source": "iana", "extensions": ["yang"] },
  "application/yang-data+json": { "source": "iana", "compressible": true },
  "application/yang-data+xml": { "source": "iana", "compressible": true },
  "application/yang-patch+json": { "source": "iana", "compressible": true },
  "application/yang-patch+xml": { "source": "iana", "compressible": true },
  "application/yin+xml": { "source": "iana", "compressible": true, "extensions": ["yin"] },
  "application/zip": { "source": "iana", "compressible": false, "extensions": ["zip"] },
  "application/zlib": { "source": "iana" },
  "application/zstd": { "source": "iana" },
  "audio/1d-interleaved-parityfec": { "source": "iana" },
  "audio/32kadpcm": { "source": "iana" },
  "audio/3gpp": { "source": "iana", "compressible": false, "extensions": ["3gpp"] },
  "audio/3gpp2": { "source": "iana" },
  "audio/aac": { "source": "iana" },
  "audio/ac3": { "source": "iana" },
  "audio/adpcm": { "source": "apache", "extensions": ["adp"] },
  "audio/amr": { "source": "iana", "extensions": ["amr"] },
  "audio/amr-wb": { "source": "iana" },
  "audio/amr-wb+": { "source": "iana" },
  "audio/aptx": { "source": "iana" },
  "audio/asc": { "source": "iana" },
  "audio/atrac-advanced-lossless": { "source": "iana" },
  "audio/atrac-x": { "source": "iana" },
  "audio/atrac3": { "source": "iana" },
  "audio/basic": { "source": "iana", "compressible": false, "extensions": ["au", "snd"] },
  "audio/bv16": { "source": "iana" },
  "audio/bv32": { "source": "iana" },
  "audio/clearmode": { "source": "iana" },
  "audio/cn": { "source": "iana" },
  "audio/dat12": { "source": "iana" },
  "audio/dls": { "source": "iana" },
  "audio/dsr-es201108": { "source": "iana" },
  "audio/dsr-es202050": { "source": "iana" },
  "audio/dsr-es202211": { "source": "iana" },
  "audio/dsr-es202212": { "source": "iana" },
  "audio/dv": { "source": "iana" },
  "audio/dvi4": { "source": "iana" },
  "audio/eac3": { "source": "iana" },
  "audio/encaprtp": { "source": "iana" },
  "audio/evrc": { "source": "iana" },
  "audio/evrc-qcp": { "source": "iana" },
  "audio/evrc0": { "source": "iana" },
  "audio/evrc1": { "source": "iana" },
  "audio/evrcb": { "source": "iana" },
  "audio/evrcb0": { "source": "iana" },
  "audio/evrcb1": { "source": "iana" },
  "audio/evrcnw": { "source": "iana" },
  "audio/evrcnw0": { "source": "iana" },
  "audio/evrcnw1": { "source": "iana" },
  "audio/evrcwb": { "source": "iana" },
  "audio/evrcwb0": { "source": "iana" },
  "audio/evrcwb1": { "source": "iana" },
  "audio/evs": { "source": "iana" },
  "audio/flexfec": { "source": "iana" },
  "audio/fwdred": { "source": "iana" },
  "audio/g711-0": { "source": "iana" },
  "audio/g719": { "source": "iana" },
  "audio/g722": { "source": "iana" },
  "audio/g7221": { "source": "iana" },
  "audio/g723": { "source": "iana" },
  "audio/g726-16": { "source": "iana" },
  "audio/g726-24": { "source": "iana" },
  "audio/g726-32": { "source": "iana" },
  "audio/g726-40": { "source": "iana" },
  "audio/g728": { "source": "iana" },
  "audio/g729": { "source": "iana" },
  "audio/g7291": { "source": "iana" },
  "audio/g729d": { "source": "iana" },
  "audio/g729e": { "source": "iana" },
  "audio/gsm": { "source": "iana" },
  "audio/gsm-efr": { "source": "iana" },
  "audio/gsm-hr-08": { "source": "iana" },
  "audio/ilbc": { "source": "iana" },
  "audio/ip-mr_v2.5": { "source": "iana" },
  "audio/isac": { "source": "apache" },
  "audio/l16": { "source": "iana" },
  "audio/l20": { "source": "iana" },
  "audio/l24": { "source": "iana", "compressible": false },
  "audio/l8": { "source": "iana" },
  "audio/lpc": { "source": "iana" },
  "audio/melp": { "source": "iana" },
  "audio/melp1200": { "source": "iana" },
  "audio/melp2400": { "source": "iana" },
  "audio/melp600": { "source": "iana" },
  "audio/mhas": { "source": "iana" },
  "audio/midi": { "source": "apache", "extensions": ["mid", "midi", "kar", "rmi"] },
  "audio/mobile-xmf": { "source": "iana", "extensions": ["mxmf"] },
  "audio/mp3": { "compressible": false, "extensions": ["mp3"] },
  "audio/mp4": { "source": "iana", "compressible": false, "extensions": ["m4a", "mp4a"] },
  "audio/mp4a-latm": { "source": "iana" },
  "audio/mpa": { "source": "iana" },
  "audio/mpa-robust": { "source": "iana" },
  "audio/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"] },
  "audio/mpeg4-generic": { "source": "iana" },
  "audio/musepack": { "source": "apache" },
  "audio/ogg": { "source": "iana", "compressible": false, "extensions": ["oga", "ogg", "spx", "opus"] },
  "audio/opus": { "source": "iana" },
  "audio/parityfec": { "source": "iana" },
  "audio/pcma": { "source": "iana" },
  "audio/pcma-wb": { "source": "iana" },
  "audio/pcmu": { "source": "iana" },
  "audio/pcmu-wb": { "source": "iana" },
  "audio/prs.sid": { "source": "iana" },
  "audio/qcelp": { "source": "iana" },
  "audio/raptorfec": { "source": "iana" },
  "audio/red": { "source": "iana" },
  "audio/rtp-enc-aescm128": { "source": "iana" },
  "audio/rtp-midi": { "source": "iana" },
  "audio/rtploopback": { "source": "iana" },
  "audio/rtx": { "source": "iana" },
  "audio/s3m": { "source": "apache", "extensions": ["s3m"] },
  "audio/scip": { "source": "iana" },
  "audio/silk": { "source": "apache", "extensions": ["sil"] },
  "audio/smv": { "source": "iana" },
  "audio/smv-qcp": { "source": "iana" },
  "audio/smv0": { "source": "iana" },
  "audio/sofa": { "source": "iana" },
  "audio/sp-midi": { "source": "iana" },
  "audio/speex": { "source": "iana" },
  "audio/t140c": { "source": "iana" },
  "audio/t38": { "source": "iana" },
  "audio/telephone-event": { "source": "iana" },
  "audio/tetra_acelp": { "source": "iana" },
  "audio/tetra_acelp_bb": { "source": "iana" },
  "audio/tone": { "source": "iana" },
  "audio/tsvcis": { "source": "iana" },
  "audio/uemclip": { "source": "iana" },
  "audio/ulpfec": { "source": "iana" },
  "audio/usac": { "source": "iana" },
  "audio/vdvi": { "source": "iana" },
  "audio/vmr-wb": { "source": "iana" },
  "audio/vnd.3gpp.iufp": { "source": "iana" },
  "audio/vnd.4sb": { "source": "iana" },
  "audio/vnd.audiokoz": { "source": "iana" },
  "audio/vnd.celp": { "source": "iana" },
  "audio/vnd.cisco.nse": { "source": "iana" },
  "audio/vnd.cmles.radio-events": { "source": "iana" },
  "audio/vnd.cns.anp1": { "source": "iana" },
  "audio/vnd.cns.inf1": { "source": "iana" },
  "audio/vnd.dece.audio": { "source": "iana", "extensions": ["uva", "uvva"] },
  "audio/vnd.digital-winds": { "source": "iana", "extensions": ["eol"] },
  "audio/vnd.dlna.adts": { "source": "iana" },
  "audio/vnd.dolby.heaac.1": { "source": "iana" },
  "audio/vnd.dolby.heaac.2": { "source": "iana" },
  "audio/vnd.dolby.mlp": { "source": "iana" },
  "audio/vnd.dolby.mps": { "source": "iana" },
  "audio/vnd.dolby.pl2": { "source": "iana" },
  "audio/vnd.dolby.pl2x": { "source": "iana" },
  "audio/vnd.dolby.pl2z": { "source": "iana" },
  "audio/vnd.dolby.pulse.1": { "source": "iana" },
  "audio/vnd.dra": { "source": "iana", "extensions": ["dra"] },
  "audio/vnd.dts": { "source": "iana", "extensions": ["dts"] },
  "audio/vnd.dts.hd": { "source": "iana", "extensions": ["dtshd"] },
  "audio/vnd.dts.uhd": { "source": "iana" },
  "audio/vnd.dvb.file": { "source": "iana" },
  "audio/vnd.everad.plj": { "source": "iana" },
  "audio/vnd.hns.audio": { "source": "iana" },
  "audio/vnd.lucent.voice": { "source": "iana", "extensions": ["lvp"] },
  "audio/vnd.ms-playready.media.pya": { "source": "iana", "extensions": ["pya"] },
  "audio/vnd.nokia.mobile-xmf": { "source": "iana" },
  "audio/vnd.nortel.vbk": { "source": "iana" },
  "audio/vnd.nuera.ecelp4800": { "source": "iana", "extensions": ["ecelp4800"] },
  "audio/vnd.nuera.ecelp7470": { "source": "iana", "extensions": ["ecelp7470"] },
  "audio/vnd.nuera.ecelp9600": { "source": "iana", "extensions": ["ecelp9600"] },
  "audio/vnd.octel.sbc": { "source": "iana" },
  "audio/vnd.presonus.multitrack": { "source": "iana" },
  "audio/vnd.qcelp": { "source": "iana" },
  "audio/vnd.rhetorex.32kadpcm": { "source": "iana" },
  "audio/vnd.rip": { "source": "iana", "extensions": ["rip"] },
  "audio/vnd.rn-realaudio": { "compressible": false },
  "audio/vnd.sealedmedia.softseal.mpeg": { "source": "iana" },
  "audio/vnd.vmx.cvsd": { "source": "iana" },
  "audio/vnd.wave": { "compressible": false },
  "audio/vorbis": { "source": "iana", "compressible": false },
  "audio/vorbis-config": { "source": "iana" },
  "audio/wav": { "compressible": false, "extensions": ["wav"] },
  "audio/wave": { "compressible": false, "extensions": ["wav"] },
  "audio/webm": { "source": "apache", "compressible": false, "extensions": ["weba"] },
  "audio/x-aac": { "source": "apache", "compressible": false, "extensions": ["aac"] },
  "audio/x-aiff": { "source": "apache", "extensions": ["aif", "aiff", "aifc"] },
  "audio/x-caf": { "source": "apache", "compressible": false, "extensions": ["caf"] },
  "audio/x-flac": { "source": "apache", "extensions": ["flac"] },
  "audio/x-m4a": { "source": "nginx", "extensions": ["m4a"] },
  "audio/x-matroska": { "source": "apache", "extensions": ["mka"] },
  "audio/x-mpegurl": { "source": "apache", "extensions": ["m3u"] },
  "audio/x-ms-wax": { "source": "apache", "extensions": ["wax"] },
  "audio/x-ms-wma": { "source": "apache", "extensions": ["wma"] },
  "audio/x-pn-realaudio": { "source": "apache", "extensions": ["ram", "ra"] },
  "audio/x-pn-realaudio-plugin": { "source": "apache", "extensions": ["rmp"] },
  "audio/x-realaudio": { "source": "nginx", "extensions": ["ra"] },
  "audio/x-tta": { "source": "apache" },
  "audio/x-wav": { "source": "apache", "extensions": ["wav"] },
  "audio/xm": { "source": "apache", "extensions": ["xm"] },
  "chemical/x-cdx": { "source": "apache", "extensions": ["cdx"] },
  "chemical/x-cif": { "source": "apache", "extensions": ["cif"] },
  "chemical/x-cmdf": { "source": "apache", "extensions": ["cmdf"] },
  "chemical/x-cml": { "source": "apache", "extensions": ["cml"] },
  "chemical/x-csml": { "source": "apache", "extensions": ["csml"] },
  "chemical/x-pdb": { "source": "apache" },
  "chemical/x-xyz": { "source": "apache", "extensions": ["xyz"] },
  "font/collection": { "source": "iana", "extensions": ["ttc"] },
  "font/otf": { "source": "iana", "compressible": true, "extensions": ["otf"] },
  "font/sfnt": { "source": "iana" },
  "font/ttf": { "source": "iana", "compressible": true, "extensions": ["ttf"] },
  "font/woff": { "source": "iana", "extensions": ["woff"] },
  "font/woff2": { "source": "iana", "extensions": ["woff2"] },
  "image/aces": { "source": "iana", "extensions": ["exr"] },
  "image/apng": { "compressible": false, "extensions": ["apng"] },
  "image/avci": { "source": "iana", "extensions": ["avci"] },
  "image/avcs": { "source": "iana", "extensions": ["avcs"] },
  "image/avif": { "source": "iana", "compressible": false, "extensions": ["avif"] },
  "image/bmp": { "source": "iana", "compressible": true, "extensions": ["bmp"] },
  "image/cgm": { "source": "iana", "extensions": ["cgm"] },
  "image/dicom-rle": { "source": "iana", "extensions": ["drle"] },
  "image/emf": { "source": "iana", "extensions": ["emf"] },
  "image/fits": { "source": "iana", "extensions": ["fits"] },
  "image/g3fax": { "source": "iana", "extensions": ["g3"] },
  "image/gif": { "source": "iana", "compressible": false, "extensions": ["gif"] },
  "image/heic": { "source": "iana", "extensions": ["heic"] },
  "image/heic-sequence": { "source": "iana", "extensions": ["heics"] },
  "image/heif": { "source": "iana", "extensions": ["heif"] },
  "image/heif-sequence": { "source": "iana", "extensions": ["heifs"] },
  "image/hej2k": { "source": "iana", "extensions": ["hej2"] },
  "image/hsj2": { "source": "iana", "extensions": ["hsj2"] },
  "image/ief": { "source": "iana", "extensions": ["ief"] },
  "image/jls": { "source": "iana", "extensions": ["jls"] },
  "image/jp2": { "source": "iana", "compressible": false, "extensions": ["jp2", "jpg2"] },
  "image/jpeg": { "source": "iana", "compressible": false, "extensions": ["jpeg", "jpg", "jpe"] },
  "image/jph": { "source": "iana", "extensions": ["jph"] },
  "image/jphc": { "source": "iana", "extensions": ["jhc"] },
  "image/jpm": { "source": "iana", "compressible": false, "extensions": ["jpm"] },
  "image/jpx": { "source": "iana", "compressible": false, "extensions": ["jpx", "jpf"] },
  "image/jxr": { "source": "iana", "extensions": ["jxr"] },
  "image/jxra": { "source": "iana", "extensions": ["jxra"] },
  "image/jxrs": { "source": "iana", "extensions": ["jxrs"] },
  "image/jxs": { "source": "iana", "extensions": ["jxs"] },
  "image/jxsc": { "source": "iana", "extensions": ["jxsc"] },
  "image/jxsi": { "source": "iana", "extensions": ["jxsi"] },
  "image/jxss": { "source": "iana", "extensions": ["jxss"] },
  "image/ktx": { "source": "iana", "extensions": ["ktx"] },
  "image/ktx2": { "source": "iana", "extensions": ["ktx2"] },
  "image/naplps": { "source": "iana" },
  "image/pjpeg": { "compressible": false },
  "image/png": { "source": "iana", "compressible": false, "extensions": ["png"] },
  "image/prs.btif": { "source": "iana", "extensions": ["btif"] },
  "image/prs.pti": { "source": "iana", "extensions": ["pti"] },
  "image/pwg-raster": { "source": "iana" },
  "image/sgi": { "source": "apache", "extensions": ["sgi"] },
  "image/svg+xml": { "source": "iana", "compressible": true, "extensions": ["svg", "svgz"] },
  "image/t38": { "source": "iana", "extensions": ["t38"] },
  "image/tiff": { "source": "iana", "compressible": false, "extensions": ["tif", "tiff"] },
  "image/tiff-fx": { "source": "iana", "extensions": ["tfx"] },
  "image/vnd.adobe.photoshop": { "source": "iana", "compressible": true, "extensions": ["psd"] },
  "image/vnd.airzip.accelerator.azv": { "source": "iana", "extensions": ["azv"] },
  "image/vnd.cns.inf2": { "source": "iana" },
  "image/vnd.dece.graphic": { "source": "iana", "extensions": ["uvi", "uvvi", "uvg", "uvvg"] },
  "image/vnd.djvu": { "source": "iana", "extensions": ["djvu", "djv"] },
  "image/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "image/vnd.dwg": { "source": "iana", "extensions": ["dwg"] },
  "image/vnd.dxf": { "source": "iana", "extensions": ["dxf"] },
  "image/vnd.fastbidsheet": { "source": "iana", "extensions": ["fbs"] },
  "image/vnd.fpx": { "source": "iana", "extensions": ["fpx"] },
  "image/vnd.fst": { "source": "iana", "extensions": ["fst"] },
  "image/vnd.fujixerox.edmics-mmr": { "source": "iana", "extensions": ["mmr"] },
  "image/vnd.fujixerox.edmics-rlc": { "source": "iana", "extensions": ["rlc"] },
  "image/vnd.globalgraphics.pgb": { "source": "iana" },
  "image/vnd.microsoft.icon": { "source": "iana", "compressible": true, "extensions": ["ico"] },
  "image/vnd.mix": { "source": "iana" },
  "image/vnd.mozilla.apng": { "source": "iana" },
  "image/vnd.ms-dds": { "compressible": true, "extensions": ["dds"] },
  "image/vnd.ms-modi": { "source": "iana", "extensions": ["mdi"] },
  "image/vnd.ms-photo": { "source": "apache", "extensions": ["wdp"] },
  "image/vnd.net-fpx": { "source": "iana", "extensions": ["npx"] },
  "image/vnd.pco.b16": { "source": "iana", "extensions": ["b16"] },
  "image/vnd.radiance": { "source": "iana" },
  "image/vnd.sealed.png": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.gif": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.jpg": { "source": "iana" },
  "image/vnd.svf": { "source": "iana" },
  "image/vnd.tencent.tap": { "source": "iana", "extensions": ["tap"] },
  "image/vnd.valve.source.texture": { "source": "iana", "extensions": ["vtf"] },
  "image/vnd.wap.wbmp": { "source": "iana", "extensions": ["wbmp"] },
  "image/vnd.xiff": { "source": "iana", "extensions": ["xif"] },
  "image/vnd.zbrush.pcx": { "source": "iana", "extensions": ["pcx"] },
  "image/webp": { "source": "apache", "extensions": ["webp"] },
  "image/wmf": { "source": "iana", "extensions": ["wmf"] },
  "image/x-3ds": { "source": "apache", "extensions": ["3ds"] },
  "image/x-cmu-raster": { "source": "apache", "extensions": ["ras"] },
  "image/x-cmx": { "source": "apache", "extensions": ["cmx"] },
  "image/x-freehand": { "source": "apache", "extensions": ["fh", "fhc", "fh4", "fh5", "fh7"] },
  "image/x-icon": { "source": "apache", "compressible": true, "extensions": ["ico"] },
  "image/x-jng": { "source": "nginx", "extensions": ["jng"] },
  "image/x-mrsid-image": { "source": "apache", "extensions": ["sid"] },
  "image/x-ms-bmp": { "source": "nginx", "compressible": true, "extensions": ["bmp"] },
  "image/x-pcx": { "source": "apache", "extensions": ["pcx"] },
  "image/x-pict": { "source": "apache", "extensions": ["pic", "pct"] },
  "image/x-portable-anymap": { "source": "apache", "extensions": ["pnm"] },
  "image/x-portable-bitmap": { "source": "apache", "extensions": ["pbm"] },
  "image/x-portable-graymap": { "source": "apache", "extensions": ["pgm"] },
  "image/x-portable-pixmap": { "source": "apache", "extensions": ["ppm"] },
  "image/x-rgb": { "source": "apache", "extensions": ["rgb"] },
  "image/x-tga": { "source": "apache", "extensions": ["tga"] },
  "image/x-xbitmap": { "source": "apache", "extensions": ["xbm"] },
  "image/x-xcf": { "compressible": false },
  "image/x-xpixmap": { "source": "apache", "extensions": ["xpm"] },
  "image/x-xwindowdump": { "source": "apache", "extensions": ["xwd"] },
  "message/cpim": { "source": "iana" },
  "message/delivery-status": { "source": "iana" },
  "message/disposition-notification": { "source": "iana", "extensions": ["disposition-notification"] },
  "message/external-body": { "source": "iana" },
  "message/feedback-report": { "source": "iana" },
  "message/global": { "source": "iana", "extensions": ["u8msg"] },
  "message/global-delivery-status": { "source": "iana", "extensions": ["u8dsn"] },
  "message/global-disposition-notification": { "source": "iana", "extensions": ["u8mdn"] },
  "message/global-headers": { "source": "iana", "extensions": ["u8hdr"] },
  "message/http": { "source": "iana", "compressible": false },
  "message/imdn+xml": { "source": "iana", "compressible": true },
  "message/news": { "source": "iana" },
  "message/partial": { "source": "iana", "compressible": false },
  "message/rfc822": { "source": "iana", "compressible": true, "extensions": ["eml", "mime"] },
  "message/s-http": { "source": "iana" },
  "message/sip": { "source": "iana" },
  "message/sipfrag": { "source": "iana" },
  "message/tracking-status": { "source": "iana" },
  "message/vnd.si.simp": { "source": "iana" },
  "message/vnd.wfa.wsc": { "source": "iana", "extensions": ["wsc"] },
  "model/3mf": { "source": "iana", "extensions": ["3mf"] },
  "model/e57": { "source": "iana" },
  "model/gltf+json": { "source": "iana", "compressible": true, "extensions": ["gltf"] },
  "model/gltf-binary": { "source": "iana", "compressible": true, "extensions": ["glb"] },
  "model/iges": { "source": "iana", "compressible": false, "extensions": ["igs", "iges"] },
  "model/mesh": { "source": "iana", "compressible": false, "extensions": ["msh", "mesh", "silo"] },
  "model/mtl": { "source": "iana", "extensions": ["mtl"] },
  "model/obj": { "source": "iana", "extensions": ["obj"] },
  "model/step": { "source": "iana" },
  "model/step+xml": { "source": "iana", "compressible": true, "extensions": ["stpx"] },
  "model/step+zip": { "source": "iana", "compressible": false, "extensions": ["stpz"] },
  "model/step-xml+zip": { "source": "iana", "compressible": false, "extensions": ["stpxz"] },
  "model/stl": { "source": "iana", "extensions": ["stl"] },
  "model/vnd.collada+xml": { "source": "iana", "compressible": true, "extensions": ["dae"] },
  "model/vnd.dwf": { "source": "iana", "extensions": ["dwf"] },
  "model/vnd.flatland.3dml": { "source": "iana" },
  "model/vnd.gdl": { "source": "iana", "extensions": ["gdl"] },
  "model/vnd.gs-gdl": { "source": "apache" },
  "model/vnd.gs.gdl": { "source": "iana" },
  "model/vnd.gtw": { "source": "iana", "extensions": ["gtw"] },
  "model/vnd.moml+xml": { "source": "iana", "compressible": true },
  "model/vnd.mts": { "source": "iana", "extensions": ["mts"] },
  "model/vnd.opengex": { "source": "iana", "extensions": ["ogex"] },
  "model/vnd.parasolid.transmit.binary": { "source": "iana", "extensions": ["x_b"] },
  "model/vnd.parasolid.transmit.text": { "source": "iana", "extensions": ["x_t"] },
  "model/vnd.pytha.pyox": { "source": "iana" },
  "model/vnd.rosette.annotated-data-model": { "source": "iana" },
  "model/vnd.sap.vds": { "source": "iana", "extensions": ["vds"] },
  "model/vnd.usdz+zip": { "source": "iana", "compressible": false, "extensions": ["usdz"] },
  "model/vnd.valve.source.compiled-map": { "source": "iana", "extensions": ["bsp"] },
  "model/vnd.vtu": { "source": "iana", "extensions": ["vtu"] },
  "model/vrml": { "source": "iana", "compressible": false, "extensions": ["wrl", "vrml"] },
  "model/x3d+binary": { "source": "apache", "compressible": false, "extensions": ["x3db", "x3dbz"] },
  "model/x3d+fastinfoset": { "source": "iana", "extensions": ["x3db"] },
  "model/x3d+vrml": { "source": "apache", "compressible": false, "extensions": ["x3dv", "x3dvz"] },
  "model/x3d+xml": { "source": "iana", "compressible": true, "extensions": ["x3d", "x3dz"] },
  "model/x3d-vrml": { "source": "iana", "extensions": ["x3dv"] },
  "multipart/alternative": { "source": "iana", "compressible": false },
  "multipart/appledouble": { "source": "iana" },
  "multipart/byteranges": { "source": "iana" },
  "multipart/digest": { "source": "iana" },
  "multipart/encrypted": { "source": "iana", "compressible": false },
  "multipart/form-data": { "source": "iana", "compressible": false },
  "multipart/header-set": { "source": "iana" },
  "multipart/mixed": { "source": "iana" },
  "multipart/multilingual": { "source": "iana" },
  "multipart/parallel": { "source": "iana" },
  "multipart/related": { "source": "iana", "compressible": false },
  "multipart/report": { "source": "iana" },
  "multipart/signed": { "source": "iana", "compressible": false },
  "multipart/vnd.bint.med-plus": { "source": "iana" },
  "multipart/voice-message": { "source": "iana" },
  "multipart/x-mixed-replace": { "source": "iana" },
  "text/1d-interleaved-parityfec": { "source": "iana" },
  "text/cache-manifest": { "source": "iana", "compressible": true, "extensions": ["appcache", "manifest"] },
  "text/calendar": { "source": "iana", "extensions": ["ics", "ifb"] },
  "text/calender": { "compressible": true },
  "text/cmd": { "compressible": true },
  "text/coffeescript": { "extensions": ["coffee", "litcoffee"] },
  "text/cql": { "source": "iana" },
  "text/cql-expression": { "source": "iana" },
  "text/cql-identifier": { "source": "iana" },
  "text/css": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["css"] },
  "text/csv": { "source": "iana", "compressible": true, "extensions": ["csv"] },
  "text/csv-schema": { "source": "iana" },
  "text/directory": { "source": "iana" },
  "text/dns": { "source": "iana" },
  "text/ecmascript": { "source": "iana" },
  "text/encaprtp": { "source": "iana" },
  "text/enriched": { "source": "iana" },
  "text/fhirpath": { "source": "iana" },
  "text/flexfec": { "source": "iana" },
  "text/fwdred": { "source": "iana" },
  "text/gff3": { "source": "iana" },
  "text/grammar-ref-list": { "source": "iana" },
  "text/html": { "source": "iana", "compressible": true, "extensions": ["html", "htm", "shtml"] },
  "text/jade": { "extensions": ["jade"] },
  "text/javascript": { "source": "iana", "compressible": true },
  "text/jcr-cnd": { "source": "iana" },
  "text/jsx": { "compressible": true, "extensions": ["jsx"] },
  "text/less": { "compressible": true, "extensions": ["less"] },
  "text/markdown": { "source": "iana", "compressible": true, "extensions": ["markdown", "md"] },
  "text/mathml": { "source": "nginx", "extensions": ["mml"] },
  "text/mdx": { "compressible": true, "extensions": ["mdx"] },
  "text/mizar": { "source": "iana" },
  "text/n3": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["n3"] },
  "text/parameters": { "source": "iana", "charset": "UTF-8" },
  "text/parityfec": { "source": "iana" },
  "text/plain": { "source": "iana", "compressible": true, "extensions": ["txt", "text", "conf", "def", "list", "log", "in", "ini"] },
  "text/provenance-notation": { "source": "iana", "charset": "UTF-8" },
  "text/prs.fallenstein.rst": { "source": "iana" },
  "text/prs.lines.tag": { "source": "iana", "extensions": ["dsc"] },
  "text/prs.prop.logic": { "source": "iana" },
  "text/raptorfec": { "source": "iana" },
  "text/red": { "source": "iana" },
  "text/rfc822-headers": { "source": "iana" },
  "text/richtext": { "source": "iana", "compressible": true, "extensions": ["rtx"] },
  "text/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "text/rtp-enc-aescm128": { "source": "iana" },
  "text/rtploopback": { "source": "iana" },
  "text/rtx": { "source": "iana" },
  "text/sgml": { "source": "iana", "extensions": ["sgml", "sgm"] },
  "text/shaclc": { "source": "iana" },
  "text/shex": { "source": "iana", "extensions": ["shex"] },
  "text/slim": { "extensions": ["slim", "slm"] },
  "text/spdx": { "source": "iana", "extensions": ["spdx"] },
  "text/strings": { "source": "iana" },
  "text/stylus": { "extensions": ["stylus", "styl"] },
  "text/t140": { "source": "iana" },
  "text/tab-separated-values": { "source": "iana", "compressible": true, "extensions": ["tsv"] },
  "text/troff": { "source": "iana", "extensions": ["t", "tr", "roff", "man", "me", "ms"] },
  "text/turtle": { "source": "iana", "charset": "UTF-8", "extensions": ["ttl"] },
  "text/ulpfec": { "source": "iana" },
  "text/uri-list": { "source": "iana", "compressible": true, "extensions": ["uri", "uris", "urls"] },
  "text/vcard": { "source": "iana", "compressible": true, "extensions": ["vcard"] },
  "text/vnd.a": { "source": "iana" },
  "text/vnd.abc": { "source": "iana" },
  "text/vnd.ascii-art": { "source": "iana" },
  "text/vnd.curl": { "source": "iana", "extensions": ["curl"] },
  "text/vnd.curl.dcurl": { "source": "apache", "extensions": ["dcurl"] },
  "text/vnd.curl.mcurl": { "source": "apache", "extensions": ["mcurl"] },
  "text/vnd.curl.scurl": { "source": "apache", "extensions": ["scurl"] },
  "text/vnd.debian.copyright": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.dmclientscript": { "source": "iana" },
  "text/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "text/vnd.esmertec.theme-descriptor": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.familysearch.gedcom": { "source": "iana", "extensions": ["ged"] },
  "text/vnd.ficlab.flt": { "source": "iana" },
  "text/vnd.fly": { "source": "iana", "extensions": ["fly"] },
  "text/vnd.fmi.flexstor": { "source": "iana", "extensions": ["flx"] },
  "text/vnd.gml": { "source": "iana" },
  "text/vnd.graphviz": { "source": "iana", "extensions": ["gv"] },
  "text/vnd.hans": { "source": "iana" },
  "text/vnd.hgl": { "source": "iana" },
  "text/vnd.in3d.3dml": { "source": "iana", "extensions": ["3dml"] },
  "text/vnd.in3d.spot": { "source": "iana", "extensions": ["spot"] },
  "text/vnd.iptc.newsml": { "source": "iana" },
  "text/vnd.iptc.nitf": { "source": "iana" },
  "text/vnd.latex-z": { "source": "iana" },
  "text/vnd.motorola.reflex": { "source": "iana" },
  "text/vnd.ms-mediapackage": { "source": "iana" },
  "text/vnd.net2phone.commcenter.command": { "source": "iana" },
  "text/vnd.radisys.msml-basic-layout": { "source": "iana" },
  "text/vnd.senx.warpscript": { "source": "iana" },
  "text/vnd.si.uricatalogue": { "source": "iana" },
  "text/vnd.sosi": { "source": "iana" },
  "text/vnd.sun.j2me.app-descriptor": { "source": "iana", "charset": "UTF-8", "extensions": ["jad"] },
  "text/vnd.trolltech.linguist": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.wap.si": { "source": "iana" },
  "text/vnd.wap.sl": { "source": "iana" },
  "text/vnd.wap.wml": { "source": "iana", "extensions": ["wml"] },
  "text/vnd.wap.wmlscript": { "source": "iana", "extensions": ["wmls"] },
  "text/vtt": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["vtt"] },
  "text/x-asm": { "source": "apache", "extensions": ["s", "asm"] },
  "text/x-c": { "source": "apache", "extensions": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"] },
  "text/x-component": { "source": "nginx", "extensions": ["htc"] },
  "text/x-fortran": { "source": "apache", "extensions": ["f", "for", "f77", "f90"] },
  "text/x-gwt-rpc": { "compressible": true },
  "text/x-handlebars-template": { "extensions": ["hbs"] },
  "text/x-java-source": { "source": "apache", "extensions": ["java"] },
  "text/x-jquery-tmpl": { "compressible": true },
  "text/x-lua": { "extensions": ["lua"] },
  "text/x-markdown": { "compressible": true, "extensions": ["mkd"] },
  "text/x-nfo": { "source": "apache", "extensions": ["nfo"] },
  "text/x-opml": { "source": "apache", "extensions": ["opml"] },
  "text/x-org": { "compressible": true, "extensions": ["org"] },
  "text/x-pascal": { "source": "apache", "extensions": ["p", "pas"] },
  "text/x-processing": { "compressible": true, "extensions": ["pde"] },
  "text/x-sass": { "extensions": ["sass"] },
  "text/x-scss": { "extensions": ["scss"] },
  "text/x-setext": { "source": "apache", "extensions": ["etx"] },
  "text/x-sfv": { "source": "apache", "extensions": ["sfv"] },
  "text/x-suse-ymp": { "compressible": true, "extensions": ["ymp"] },
  "text/x-uuencode": { "source": "apache", "extensions": ["uu"] },
  "text/x-vcalendar": { "source": "apache", "extensions": ["vcs"] },
  "text/x-vcard": { "source": "apache", "extensions": ["vcf"] },
  "text/xml": { "source": "iana", "compressible": true, "extensions": ["xml"] },
  "text/xml-external-parsed-entity": { "source": "iana" },
  "text/yaml": { "compressible": true, "extensions": ["yaml", "yml"] },
  "video/1d-interleaved-parityfec": { "source": "iana" },
  "video/3gpp": { "source": "iana", "extensions": ["3gp", "3gpp"] },
  "video/3gpp-tt": { "source": "iana" },
  "video/3gpp2": { "source": "iana", "extensions": ["3g2"] },
  "video/av1": { "source": "iana" },
  "video/bmpeg": { "source": "iana" },
  "video/bt656": { "source": "iana" },
  "video/celb": { "source": "iana" },
  "video/dv": { "source": "iana" },
  "video/encaprtp": { "source": "iana" },
  "video/ffv1": { "source": "iana" },
  "video/flexfec": { "source": "iana" },
  "video/h261": { "source": "iana", "extensions": ["h261"] },
  "video/h263": { "source": "iana", "extensions": ["h263"] },
  "video/h263-1998": { "source": "iana" },
  "video/h263-2000": { "source": "iana" },
  "video/h264": { "source": "iana", "extensions": ["h264"] },
  "video/h264-rcdo": { "source": "iana" },
  "video/h264-svc": { "source": "iana" },
  "video/h265": { "source": "iana" },
  "video/iso.segment": { "source": "iana", "extensions": ["m4s"] },
  "video/jpeg": { "source": "iana", "extensions": ["jpgv"] },
  "video/jpeg2000": { "source": "iana" },
  "video/jpm": { "source": "apache", "extensions": ["jpm", "jpgm"] },
  "video/jxsv": { "source": "iana" },
  "video/mj2": { "source": "iana", "extensions": ["mj2", "mjp2"] },
  "video/mp1s": { "source": "iana" },
  "video/mp2p": { "source": "iana" },
  "video/mp2t": { "source": "iana", "extensions": ["ts"] },
  "video/mp4": { "source": "iana", "compressible": false, "extensions": ["mp4", "mp4v", "mpg4"] },
  "video/mp4v-es": { "source": "iana" },
  "video/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpeg", "mpg", "mpe", "m1v", "m2v"] },
  "video/mpeg4-generic": { "source": "iana" },
  "video/mpv": { "source": "iana" },
  "video/nv": { "source": "iana" },
  "video/ogg": { "source": "iana", "compressible": false, "extensions": ["ogv"] },
  "video/parityfec": { "source": "iana" },
  "video/pointer": { "source": "iana" },
  "video/quicktime": { "source": "iana", "compressible": false, "extensions": ["qt", "mov"] },
  "video/raptorfec": { "source": "iana" },
  "video/raw": { "source": "iana" },
  "video/rtp-enc-aescm128": { "source": "iana" },
  "video/rtploopback": { "source": "iana" },
  "video/rtx": { "source": "iana" },
  "video/scip": { "source": "iana" },
  "video/smpte291": { "source": "iana" },
  "video/smpte292m": { "source": "iana" },
  "video/ulpfec": { "source": "iana" },
  "video/vc1": { "source": "iana" },
  "video/vc2": { "source": "iana" },
  "video/vnd.cctv": { "source": "iana" },
  "video/vnd.dece.hd": { "source": "iana", "extensions": ["uvh", "uvvh"] },
  "video/vnd.dece.mobile": { "source": "iana", "extensions": ["uvm", "uvvm"] },
  "video/vnd.dece.mp4": { "source": "iana" },
  "video/vnd.dece.pd": { "source": "iana", "extensions": ["uvp", "uvvp"] },
  "video/vnd.dece.sd": { "source": "iana", "extensions": ["uvs", "uvvs"] },
  "video/vnd.dece.video": { "source": "iana", "extensions": ["uvv", "uvvv"] },
  "video/vnd.directv.mpeg": { "source": "iana" },
  "video/vnd.directv.mpeg-tts": { "source": "iana" },
  "video/vnd.dlna.mpeg-tts": { "source": "iana" },
  "video/vnd.dvb.file": { "source": "iana", "extensions": ["dvb"] },
  "video/vnd.fvt": { "source": "iana", "extensions": ["fvt"] },
  "video/vnd.hns.video": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.ttsavc": { "source": "iana" },
  "video/vnd.iptvforum.ttsmpeg2": { "source": "iana" },
  "video/vnd.motorola.video": { "source": "iana" },
  "video/vnd.motorola.videop": { "source": "iana" },
  "video/vnd.mpegurl": { "source": "iana", "extensions": ["mxu", "m4u"] },
  "video/vnd.ms-playready.media.pyv": { "source": "iana", "extensions": ["pyv"] },
  "video/vnd.nokia.interleaved-multimedia": { "source": "iana" },
  "video/vnd.nokia.mp4vr": { "source": "iana" },
  "video/vnd.nokia.videovoip": { "source": "iana" },
  "video/vnd.objectvideo": { "source": "iana" },
  "video/vnd.radgamettools.bink": { "source": "iana" },
  "video/vnd.radgamettools.smacker": { "source": "iana" },
  "video/vnd.sealed.mpeg1": { "source": "iana" },
  "video/vnd.sealed.mpeg4": { "source": "iana" },
  "video/vnd.sealed.swf": { "source": "iana" },
  "video/vnd.sealedmedia.softseal.mov": { "source": "iana" },
  "video/vnd.uvvu.mp4": { "source": "iana", "extensions": ["uvu", "uvvu"] },
  "video/vnd.vivo": { "source": "iana", "extensions": ["viv"] },
  "video/vnd.youtube.yt": { "source": "iana" },
  "video/vp8": { "source": "iana" },
  "video/vp9": { "source": "iana" },
  "video/webm": { "source": "apache", "compressible": false, "extensions": ["webm"] },
  "video/x-f4v": { "source": "apache", "extensions": ["f4v"] },
  "video/x-fli": { "source": "apache", "extensions": ["fli"] },
  "video/x-flv": { "source": "apache", "compressible": false, "extensions": ["flv"] },
  "video/x-m4v": { "source": "apache", "extensions": ["m4v"] },
  "video/x-matroska": { "source": "apache", "compressible": false, "extensions": ["mkv", "mk3d", "mks"] },
  "video/x-mng": { "source": "apache", "extensions": ["mng"] },
  "video/x-ms-asf": { "source": "apache", "extensions": ["asf", "asx"] },
  "video/x-ms-vob": { "source": "apache", "extensions": ["vob"] },
  "video/x-ms-wm": { "source": "apache", "extensions": ["wm"] },
  "video/x-ms-wmv": { "source": "apache", "compressible": false, "extensions": ["wmv"] },
  "video/x-ms-wmx": { "source": "apache", "extensions": ["wmx"] },
  "video/x-ms-wvx": { "source": "apache", "extensions": ["wvx"] },
  "video/x-msvideo": { "source": "apache", "extensions": ["avi"] },
  "video/x-sgi-movie": { "source": "apache", "extensions": ["movie"] },
  "video/x-smv": { "source": "apache", "extensions": ["smv"] },
  "x-conference/x-cooltalk": { "source": "apache", "extensions": ["ice"] },
  "x-shader/x-fragment": { "compressible": true },
  "x-shader/x-vertex": { "compressible": true }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var mimeDb$1;
var hasRequiredMimeDb$1;
function requireMimeDb$1() {
  if (hasRequiredMimeDb$1) return mimeDb$1;
  hasRequiredMimeDb$1 = 1;
  mimeDb$1 = require$$0$4;
  return mimeDb$1;
}
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredMimeTypes$1;
function requireMimeTypes$1() {
  if (hasRequiredMimeTypes$1) return mimeTypes$1;
  hasRequiredMimeTypes$1 = 1;
  (function(exports) {
    var db = requireMimeDb$1();
    var extname = require$$1$3.extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset2;
    exports.charsets = { lookup: charset2 };
    exports.contentType = contentType2;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup;
    exports.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset2(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType2(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset22 = exports.charset(mime);
        if (charset22) mime += "; charset=" + charset22.toLowerCase();
      }
      return mime;
    }
    function extension(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path2) {
      if (!path2 || typeof path2 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path2).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type2) {
        var mime = db[type2];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type2] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type2;
        }
      });
    }
  })(mimeTypes$1);
  return mimeTypes$1;
}
var defer_1;
var hasRequiredDefer;
function requireDefer() {
  if (hasRequiredDefer) return defer_1;
  hasRequiredDefer = 1;
  defer_1 = defer;
  function defer(fn) {
    var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
    if (nextTick) {
      nextTick(fn);
    } else {
      setTimeout(fn, 0);
    }
  }
  return defer_1;
}
var async_1;
var hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async_1;
  hasRequiredAsync = 1;
  var defer = requireDefer();
  async_1 = async;
  function async(callback) {
    var isAsync2 = false;
    defer(function() {
      isAsync2 = true;
    });
    return function async_callback(err, result) {
      if (isAsync2) {
        callback(err, result);
      } else {
        defer(function nextTick_callback() {
          callback(err, result);
        });
      }
    };
  }
  return async_1;
}
var abort_1;
var hasRequiredAbort;
function requireAbort() {
  if (hasRequiredAbort) return abort_1;
  hasRequiredAbort = 1;
  abort_1 = abort;
  function abort(state) {
    Object.keys(state.jobs).forEach(clean.bind(state));
    state.jobs = {};
  }
  function clean(key) {
    if (typeof this.jobs[key] == "function") {
      this.jobs[key]();
    }
  }
  return abort_1;
}
var iterate_1;
var hasRequiredIterate;
function requireIterate() {
  if (hasRequiredIterate) return iterate_1;
  hasRequiredIterate = 1;
  var async = requireAsync(), abort = requireAbort();
  iterate_1 = iterate;
  function iterate(list, iterator2, state, callback) {
    var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
    state.jobs[key] = runJob(iterator2, key, list[key], function(error, output2) {
      if (!(key in state.jobs)) {
        return;
      }
      delete state.jobs[key];
      if (error) {
        abort(state);
      } else {
        state.results[key] = output2;
      }
      callback(error, state.results);
    });
  }
  function runJob(iterator2, key, item, callback) {
    var aborter;
    if (iterator2.length == 2) {
      aborter = iterator2(item, async(callback));
    } else {
      aborter = iterator2(item, key, async(callback));
    }
    return aborter;
  }
  return iterate_1;
}
var state_1;
var hasRequiredState;
function requireState() {
  if (hasRequiredState) return state_1;
  hasRequiredState = 1;
  state_1 = state;
  function state(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
      index: 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs: {},
      results: isNamedList ? {} : [],
      size: isNamedList ? Object.keys(list).length : list.length
    };
    if (sortMethod) {
      initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
        return sortMethod(list[a], list[b]);
      });
    }
    return initState;
  }
  return state_1;
}
var terminator_1;
var hasRequiredTerminator;
function requireTerminator() {
  if (hasRequiredTerminator) return terminator_1;
  hasRequiredTerminator = 1;
  var abort = requireAbort(), async = requireAsync();
  terminator_1 = terminator;
  function terminator(callback) {
    if (!Object.keys(this.jobs).length) {
      return;
    }
    this.index = this.size;
    abort(this);
    async(callback)(null, this.results);
  }
  return terminator_1;
}
var parallel_1;
var hasRequiredParallel;
function requireParallel() {
  if (hasRequiredParallel) return parallel_1;
  hasRequiredParallel = 1;
  var iterate = requireIterate(), initState = requireState(), terminator = requireTerminator();
  parallel_1 = parallel;
  function parallel(list, iterator2, callback) {
    var state = initState(list);
    while (state.index < (state["keyedList"] || list).length) {
      iterate(list, iterator2, state, function(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        if (Object.keys(state.jobs).length === 0) {
          callback(null, state.results);
          return;
        }
      });
      state.index++;
    }
    return terminator.bind(state, callback);
  }
  return parallel_1;
}
var serialOrdered = { exports: {} };
var hasRequiredSerialOrdered;
function requireSerialOrdered() {
  if (hasRequiredSerialOrdered) return serialOrdered.exports;
  hasRequiredSerialOrdered = 1;
  var iterate = requireIterate(), initState = requireState(), terminator = requireTerminator();
  serialOrdered.exports = serialOrdered$1;
  serialOrdered.exports.ascending = ascending;
  serialOrdered.exports.descending = descending;
  function serialOrdered$1(list, iterator2, sortMethod, callback) {
    var state = initState(list, sortMethod);
    iterate(list, iterator2, state, function iteratorHandler(error, result) {
      if (error) {
        callback(error, result);
        return;
      }
      state.index++;
      if (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator2, state, iteratorHandler);
        return;
      }
      callback(null, state.results);
    });
    return terminator.bind(state, callback);
  }
  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  function descending(a, b) {
    return -1 * ascending(a, b);
  }
  return serialOrdered.exports;
}
var serial_1;
var hasRequiredSerial;
function requireSerial() {
  if (hasRequiredSerial) return serial_1;
  hasRequiredSerial = 1;
  var serialOrdered2 = requireSerialOrdered();
  serial_1 = serial;
  function serial(list, iterator2, callback) {
    return serialOrdered2(list, iterator2, null, callback);
  }
  return serial_1;
}
var asynckit;
var hasRequiredAsynckit;
function requireAsynckit() {
  if (hasRequiredAsynckit) return asynckit;
  hasRequiredAsynckit = 1;
  asynckit = {
    parallel: requireParallel(),
    serial: requireSerial(),
    serialOrdered: requireSerialOrdered()
  };
  return asynckit;
}
var esObjectAtoms$1;
var hasRequiredEsObjectAtoms$1;
function requireEsObjectAtoms$1() {
  if (hasRequiredEsObjectAtoms$1) return esObjectAtoms$1;
  hasRequiredEsObjectAtoms$1 = 1;
  esObjectAtoms$1 = Object;
  return esObjectAtoms$1;
}
var esErrors$1;
var hasRequiredEsErrors$1;
function requireEsErrors$1() {
  if (hasRequiredEsErrors$1) return esErrors$1;
  hasRequiredEsErrors$1 = 1;
  esErrors$1 = Error;
  return esErrors$1;
}
var _eval$1;
var hasRequired_eval$1;
function require_eval$1() {
  if (hasRequired_eval$1) return _eval$1;
  hasRequired_eval$1 = 1;
  _eval$1 = EvalError;
  return _eval$1;
}
var range$1;
var hasRequiredRange$1;
function requireRange$1() {
  if (hasRequiredRange$1) return range$1;
  hasRequiredRange$1 = 1;
  range$1 = RangeError;
  return range$1;
}
var ref$1;
var hasRequiredRef$1;
function requireRef$1() {
  if (hasRequiredRef$1) return ref$1;
  hasRequiredRef$1 = 1;
  ref$1 = ReferenceError;
  return ref$1;
}
var syntax$1;
var hasRequiredSyntax$1;
function requireSyntax$1() {
  if (hasRequiredSyntax$1) return syntax$1;
  hasRequiredSyntax$1 = 1;
  syntax$1 = SyntaxError;
  return syntax$1;
}
var type$1;
var hasRequiredType$1;
function requireType$1() {
  if (hasRequiredType$1) return type$1;
  hasRequiredType$1 = 1;
  type$1 = TypeError;
  return type$1;
}
var uri$1;
var hasRequiredUri$1;
function requireUri$1() {
  if (hasRequiredUri$1) return uri$1;
  hasRequiredUri$1 = 1;
  uri$1 = URIError;
  return uri$1;
}
var abs$1;
var hasRequiredAbs$1;
function requireAbs$1() {
  if (hasRequiredAbs$1) return abs$1;
  hasRequiredAbs$1 = 1;
  abs$1 = Math.abs;
  return abs$1;
}
var floor$1;
var hasRequiredFloor$1;
function requireFloor$1() {
  if (hasRequiredFloor$1) return floor$1;
  hasRequiredFloor$1 = 1;
  floor$1 = Math.floor;
  return floor$1;
}
var max$1;
var hasRequiredMax$1;
function requireMax$1() {
  if (hasRequiredMax$1) return max$1;
  hasRequiredMax$1 = 1;
  max$1 = Math.max;
  return max$1;
}
var min$1;
var hasRequiredMin$1;
function requireMin$1() {
  if (hasRequiredMin$1) return min$1;
  hasRequiredMin$1 = 1;
  min$1 = Math.min;
  return min$1;
}
var pow$1;
var hasRequiredPow$1;
function requirePow$1() {
  if (hasRequiredPow$1) return pow$1;
  hasRequiredPow$1 = 1;
  pow$1 = Math.pow;
  return pow$1;
}
var round$1;
var hasRequiredRound$1;
function requireRound$1() {
  if (hasRequiredRound$1) return round$1;
  hasRequiredRound$1 = 1;
  round$1 = Math.round;
  return round$1;
}
var _isNaN$1;
var hasRequired_isNaN$1;
function require_isNaN$1() {
  if (hasRequired_isNaN$1) return _isNaN$1;
  hasRequired_isNaN$1 = 1;
  _isNaN$1 = Number.isNaN || function isNaN2(a) {
    return a !== a;
  };
  return _isNaN$1;
}
var sign$1;
var hasRequiredSign$1;
function requireSign$1() {
  if (hasRequiredSign$1) return sign$1;
  hasRequiredSign$1 = 1;
  var $isNaN = /* @__PURE__ */ require_isNaN$1();
  sign$1 = function sign2(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
  return sign$1;
}
var gOPD$1;
var hasRequiredGOPD$1;
function requireGOPD$1() {
  if (hasRequiredGOPD$1) return gOPD$1;
  hasRequiredGOPD$1 = 1;
  gOPD$1 = Object.getOwnPropertyDescriptor;
  return gOPD$1;
}
var gopd$1;
var hasRequiredGopd$1;
function requireGopd$1() {
  if (hasRequiredGopd$1) return gopd$1;
  hasRequiredGopd$1 = 1;
  var $gOPD = /* @__PURE__ */ requireGOPD$1();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  gopd$1 = $gOPD;
  return gopd$1;
}
var esDefineProperty$1;
var hasRequiredEsDefineProperty$1;
function requireEsDefineProperty$1() {
  if (hasRequiredEsDefineProperty$1) return esDefineProperty$1;
  hasRequiredEsDefineProperty$1 = 1;
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  esDefineProperty$1 = $defineProperty;
  return esDefineProperty$1;
}
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
  if (hasRequiredShams$1) return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams$1;
}
var hasSymbols$1;
var hasRequiredHasSymbols$1;
function requireHasSymbols$1() {
  if (hasRequiredHasSymbols$1) return hasSymbols$1;
  hasRequiredHasSymbols$1 = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols$1 = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols$1;
}
var Reflect_getPrototypeOf$1;
var hasRequiredReflect_getPrototypeOf$1;
function requireReflect_getPrototypeOf$1() {
  if (hasRequiredReflect_getPrototypeOf$1) return Reflect_getPrototypeOf$1;
  hasRequiredReflect_getPrototypeOf$1 = 1;
  Reflect_getPrototypeOf$1 = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf$1;
}
var Object_getPrototypeOf$1;
var hasRequiredObject_getPrototypeOf$1;
function requireObject_getPrototypeOf$1() {
  if (hasRequiredObject_getPrototypeOf$1) return Object_getPrototypeOf$1;
  hasRequiredObject_getPrototypeOf$1 = 1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms$1();
  Object_getPrototypeOf$1 = $Object.getPrototypeOf || null;
  return Object_getPrototypeOf$1;
}
var implementation$1;
var hasRequiredImplementation$1;
function requireImplementation$1() {
  if (hasRequiredImplementation$1) return implementation$1;
  hasRequiredImplementation$1 = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b) {
    var arr = [];
    for (var i = 0; i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0; i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation$1 = function bind2(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation$1;
}
var functionBind$1;
var hasRequiredFunctionBind$1;
function requireFunctionBind$1() {
  if (hasRequiredFunctionBind$1) return functionBind$1;
  hasRequiredFunctionBind$1 = 1;
  var implementation2 = requireImplementation$1();
  functionBind$1 = Function.prototype.bind || implementation2;
  return functionBind$1;
}
var functionCall$1;
var hasRequiredFunctionCall$1;
function requireFunctionCall$1() {
  if (hasRequiredFunctionCall$1) return functionCall$1;
  hasRequiredFunctionCall$1 = 1;
  functionCall$1 = Function.prototype.call;
  return functionCall$1;
}
var functionApply$1;
var hasRequiredFunctionApply$1;
function requireFunctionApply$1() {
  if (hasRequiredFunctionApply$1) return functionApply$1;
  hasRequiredFunctionApply$1 = 1;
  functionApply$1 = Function.prototype.apply;
  return functionApply$1;
}
var reflectApply$1;
var hasRequiredReflectApply$1;
function requireReflectApply$1() {
  if (hasRequiredReflectApply$1) return reflectApply$1;
  hasRequiredReflectApply$1 = 1;
  reflectApply$1 = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply$1;
}
var actualApply$1;
var hasRequiredActualApply$1;
function requireActualApply$1() {
  if (hasRequiredActualApply$1) return actualApply$1;
  hasRequiredActualApply$1 = 1;
  var bind2 = requireFunctionBind$1();
  var $apply = requireFunctionApply$1();
  var $call = requireFunctionCall$1();
  var $reflectApply = requireReflectApply$1();
  actualApply$1 = $reflectApply || bind2.call($call, $apply);
  return actualApply$1;
}
var callBindApplyHelpers$1;
var hasRequiredCallBindApplyHelpers$1;
function requireCallBindApplyHelpers$1() {
  if (hasRequiredCallBindApplyHelpers$1) return callBindApplyHelpers$1;
  hasRequiredCallBindApplyHelpers$1 = 1;
  var bind2 = requireFunctionBind$1();
  var $TypeError = /* @__PURE__ */ requireType$1();
  var $call = requireFunctionCall$1();
  var $actualApply = requireActualApply$1();
  callBindApplyHelpers$1 = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind2, $call, args);
  };
  return callBindApplyHelpers$1;
}
var get$1;
var hasRequiredGet$1;
function requireGet$1() {
  if (hasRequiredGet$1) return get$1;
  hasRequiredGet$1 = 1;
  var callBind = requireCallBindApplyHelpers$1();
  var gOPD2 = /* @__PURE__ */ requireGopd$1();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  get$1 = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object(value));
    }
  ) : false;
  return get$1;
}
var getProto$1;
var hasRequiredGetProto$1;
function requireGetProto$1() {
  if (hasRequiredGetProto$1) return getProto$1;
  hasRequiredGetProto$1 = 1;
  var reflectGetProto = requireReflect_getPrototypeOf$1();
  var originalGetProto = requireObject_getPrototypeOf$1();
  var getDunderProto = /* @__PURE__ */ requireGet$1();
  getProto$1 = reflectGetProto ? function getProto2(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto2(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto2(O) {
    return getDunderProto(O);
  } : null;
  return getProto$1;
}
var hasown$1;
var hasRequiredHasown$1;
function requireHasown$1() {
  if (hasRequiredHasown$1) return hasown$1;
  hasRequiredHasown$1 = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind2 = requireFunctionBind$1();
  hasown$1 = bind2.call(call, $hasOwn);
  return hasown$1;
}
var getIntrinsic$1;
var hasRequiredGetIntrinsic$1;
function requireGetIntrinsic$1() {
  if (hasRequiredGetIntrinsic$1) return getIntrinsic$1;
  hasRequiredGetIntrinsic$1 = 1;
  var undefined$1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms$1();
  var $Error = /* @__PURE__ */ requireEsErrors$1();
  var $EvalError = /* @__PURE__ */ require_eval$1();
  var $RangeError = /* @__PURE__ */ requireRange$1();
  var $ReferenceError = /* @__PURE__ */ requireRef$1();
  var $SyntaxError = /* @__PURE__ */ requireSyntax$1();
  var $TypeError = /* @__PURE__ */ requireType$1();
  var $URIError = /* @__PURE__ */ requireUri$1();
  var abs2 = /* @__PURE__ */ requireAbs$1();
  var floor2 = /* @__PURE__ */ requireFloor$1();
  var max2 = /* @__PURE__ */ requireMax$1();
  var min2 = /* @__PURE__ */ requireMin$1();
  var pow2 = /* @__PURE__ */ requirePow$1();
  var round2 = /* @__PURE__ */ requireRound$1();
  var sign2 = /* @__PURE__ */ requireSign$1();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = /* @__PURE__ */ requireGopd$1();
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty$1();
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols2 = requireHasSymbols$1()();
  var getProto2 = requireGetProto$1();
  var $ObjectGPO = requireObject_getPrototypeOf$1();
  var $ReflectGPO = requireReflect_getPrototypeOf$1();
  var $apply = requireFunctionApply$1();
  var $call = requireFunctionCall$1();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs2,
    "%Math.floor%": floor2,
    "%Math.max%": max2,
    "%Math.min%": min2,
    "%Math.pow%": pow2,
    "%Math.round%": round2,
    "%Math.sign%": sign2,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto2) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto2(getProto2(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto2) {
        value = getProto2(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind2 = requireFunctionBind$1();
  var hasOwn = /* @__PURE__ */ requireHasown$1();
  var $concat = bind2.call($call, Array.prototype.concat);
  var $spliceApply = bind2.call($apply, Array.prototype.splice);
  var $replace = bind2.call($call, String.prototype.replace);
  var $strSlice = bind2.call($call, String.prototype.slice);
  var $exec = bind2.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic$1 = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void 0;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic$1;
}
var shams$2;
var hasRequiredShams$2;
function requireShams$2() {
  if (hasRequiredShams$2) return shams$2;
  hasRequiredShams$2 = 1;
  var hasSymbols2 = requireShams$1();
  shams$2 = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams$2;
}
var esSetTostringtag;
var hasRequiredEsSetTostringtag;
function requireEsSetTostringtag() {
  if (hasRequiredEsSetTostringtag) return esSetTostringtag;
  hasRequiredEsSetTostringtag = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic$1();
  var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
  var hasToStringTag = requireShams$2()();
  var hasOwn = /* @__PURE__ */ requireHasown$1();
  var $TypeError = /* @__PURE__ */ requireType$1();
  var toStringTag2 = hasToStringTag ? Symbol.toStringTag : null;
  esSetTostringtag = function setToStringTag(object, value) {
    var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
    var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
    if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
      throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
    }
    if (toStringTag2 && (overrideIfSet || !hasOwn(object, toStringTag2))) {
      if ($defineProperty) {
        $defineProperty(object, toStringTag2, {
          configurable: !nonConfigurable,
          enumerable: false,
          value,
          writable: false
        });
      } else {
        object[toStringTag2] = value;
      }
    }
  };
  return esSetTostringtag;
}
var populate;
var hasRequiredPopulate;
function requirePopulate() {
  if (hasRequiredPopulate) return populate;
  hasRequiredPopulate = 1;
  populate = function(dst, src) {
    Object.keys(src).forEach(function(prop) {
      dst[prop] = dst[prop] || src[prop];
    });
    return dst;
  };
  return populate;
}
var form_data;
var hasRequiredForm_data;
function requireForm_data() {
  if (hasRequiredForm_data) return form_data;
  hasRequiredForm_data = 1;
  var CombinedStream = requireCombined_stream();
  var util2 = require$$0$5;
  var path2 = require$$1$3;
  var http = require$$1$4;
  var https = require$$2$1;
  var parseUrl = require$$0$6.parse;
  var fs2 = require$$1$2;
  var Stream = stream.Stream;
  var mime = requireMimeTypes$1();
  var asynckit2 = requireAsynckit();
  var setToStringTag = /* @__PURE__ */ requireEsSetTostringtag();
  var populate2 = requirePopulate();
  form_data = FormData2;
  util2.inherits(FormData2, CombinedStream);
  function FormData2(options) {
    if (!(this instanceof FormData2)) {
      return new FormData2(options);
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {};
    for (var option in options) {
      this[option] = options[option];
    }
  }
  FormData2.LINE_BREAK = "\r\n";
  FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
  FormData2.prototype.append = function(field, value, options) {
    options = options || {};
    if (typeof options == "string") {
      options = { filename: options };
    }
    var append2 = CombinedStream.prototype.append.bind(this);
    if (typeof value == "number") {
      value = "" + value;
    }
    if (Array.isArray(value)) {
      this._error(new Error("Arrays are not supported."));
      return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append2(header);
    append2(value);
    append2(footer);
    this._trackLength(header, value, options);
  };
  FormData2.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    if (options.knownLength != null) {
      valueLength += +options.knownLength;
    } else if (Buffer.isBuffer(value)) {
      valueLength = value.length;
    } else if (typeof value === "string") {
      valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
    if (!value || !value.path && !(value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) && !(value instanceof Stream)) {
      return;
    }
    if (!options.knownLength) {
      this._valuesToMeasure.push(value);
    }
  };
  FormData2.prototype._lengthRetriever = function(value, callback) {
    if (Object.prototype.hasOwnProperty.call(value, "fd")) {
      if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
        callback(null, value.end + 1 - (value.start ? value.start : 0));
      } else {
        fs2.stat(value.path, function(err, stat2) {
          var fileSize;
          if (err) {
            callback(err);
            return;
          }
          fileSize = stat2.size - (value.start ? value.start : 0);
          callback(null, fileSize);
        });
      }
    } else if (Object.prototype.hasOwnProperty.call(value, "httpVersion")) {
      callback(null, +value.headers["content-length"]);
    } else if (Object.prototype.hasOwnProperty.call(value, "httpModule")) {
      value.on("response", function(response2) {
        value.pause();
        callback(null, +response2.headers["content-length"]);
      });
      value.resume();
    } else {
      callback("Unknown stream");
    }
  };
  FormData2.prototype._multiPartHeader = function(field, value, options) {
    if (typeof options.header == "string") {
      return options.header;
    }
    var contentDisposition2 = this._getContentDisposition(value, options);
    var contentType2 = this._getContentType(value, options);
    var contents = "";
    var headers2 = {
      // add custom disposition as third element or keep it two elements if not
      "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition2 || []),
      // if no content type. allow it to be empty array
      "Content-Type": [].concat(contentType2 || [])
    };
    if (typeof options.header == "object") {
      populate2(headers2, options.header);
    }
    var header;
    for (var prop in headers2) {
      if (Object.prototype.hasOwnProperty.call(headers2, prop)) {
        header = headers2[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
        }
      }
    }
    return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
  };
  FormData2.prototype._getContentDisposition = function(value, options) {
    var filename, contentDisposition2;
    if (typeof options.filepath === "string") {
      filename = path2.normalize(options.filepath).replace(/\\/g, "/");
    } else if (options.filename || value.name || value.path) {
      filename = path2.basename(options.filename || value.name || value.path);
    } else if (value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) {
      filename = path2.basename(value.client._httpMessage.path || "");
    }
    if (filename) {
      contentDisposition2 = 'filename="' + filename + '"';
    }
    return contentDisposition2;
  };
  FormData2.prototype._getContentType = function(value, options) {
    var contentType2 = options.contentType;
    if (!contentType2 && value.name) {
      contentType2 = mime.lookup(value.name);
    }
    if (!contentType2 && value.path) {
      contentType2 = mime.lookup(value.path);
    }
    if (!contentType2 && value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) {
      contentType2 = value.headers["content-type"];
    }
    if (!contentType2 && (options.filepath || options.filename)) {
      contentType2 = mime.lookup(options.filepath || options.filename);
    }
    if (!contentType2 && typeof value == "object") {
      contentType2 = FormData2.DEFAULT_CONTENT_TYPE;
    }
    return contentType2;
  };
  FormData2.prototype._multiPartFooter = function() {
    return function(next) {
      var footer = FormData2.LINE_BREAK;
      var lastPart = this._streams.length === 0;
      if (lastPart) {
        footer += this._lastBoundary();
      }
      next(footer);
    }.bind(this);
  };
  FormData2.prototype._lastBoundary = function() {
    return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
  };
  FormData2.prototype.getHeaders = function(userHeaders) {
    var header;
    var formHeaders = {
      "content-type": "multipart/form-data; boundary=" + this.getBoundary()
    };
    for (header in userHeaders) {
      if (Object.prototype.hasOwnProperty.call(userHeaders, header)) {
        formHeaders[header.toLowerCase()] = userHeaders[header];
      }
    }
    return formHeaders;
  };
  FormData2.prototype.setBoundary = function(boundary) {
    this._boundary = boundary;
  };
  FormData2.prototype.getBoundary = function() {
    if (!this._boundary) {
      this._generateBoundary();
    }
    return this._boundary;
  };
  FormData2.prototype.getBuffer = function() {
    var dataBuffer = new Buffer.alloc(0);
    var boundary = this.getBoundary();
    for (var i = 0, len = this._streams.length; i < len; i++) {
      if (typeof this._streams[i] !== "function") {
        if (Buffer.isBuffer(this._streams[i])) {
          dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
        } else {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
        }
        if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
        }
      }
    }
    return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
  };
  FormData2.prototype._generateBoundary = function() {
    var boundary = "--------------------------";
    for (var i = 0; i < 24; i++) {
      boundary += Math.floor(Math.random() * 10).toString(16);
    }
    this._boundary = boundary;
  };
  FormData2.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this.hasKnownLength()) {
      this._error(new Error("Cannot calculate proper length in synchronous way."));
    }
    return knownLength;
  };
  FormData2.prototype.hasKnownLength = function() {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
      hasKnownLength = false;
    }
    return hasKnownLength;
  };
  FormData2.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
      process.nextTick(cb.bind(this, null, knownLength));
      return;
    }
    asynckit2.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
      if (err) {
        cb(err);
        return;
      }
      values.forEach(function(length) {
        knownLength += length;
      });
      cb(null, knownLength);
    });
  };
  FormData2.prototype.submit = function(params, cb) {
    var request2, options, defaults2 = { method: "post" };
    if (typeof params == "string") {
      params = parseUrl(params);
      options = populate2({
        port: params.port,
        path: params.pathname,
        host: params.hostname,
        protocol: params.protocol
      }, defaults2);
    } else {
      options = populate2(params, defaults2);
      if (!options.port) {
        options.port = options.protocol == "https:" ? 443 : 80;
      }
    }
    options.headers = this.getHeaders(params.headers);
    if (options.protocol == "https:") {
      request2 = https.request(options);
    } else {
      request2 = http.request(options);
    }
    this.getLength(function(err, length) {
      if (err && err !== "Unknown stream") {
        this._error(err);
        return;
      }
      if (length) {
        request2.setHeader("Content-Length", length);
      }
      this.pipe(request2);
      if (cb) {
        var onResponse;
        var callback = function(error, responce) {
          request2.removeListener("error", callback);
          request2.removeListener("response", onResponse);
          return cb.call(this, error, responce);
        };
        onResponse = callback.bind(this, null);
        request2.on("error", callback);
        request2.on("response", onResponse);
      }
    }.bind(this));
    return request2;
  };
  FormData2.prototype._error = function(err) {
    if (!this.error) {
      this.error = err;
      this.pause();
      this.emit("error", err);
    }
  };
  FormData2.prototype.toString = function() {
    return "[object FormData]";
  };
  setToStringTag(FormData2, "FormData");
  return form_data;
}
var form_dataExports = requireForm_data();
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const { iterator, toStringTag } = Symbol;
const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type2) => {
  type2 = type2.toLowerCase();
  return (thing) => kindOf(thing) === type2;
};
const typeOfTest = (type2) => (thing) => typeof thing === type2;
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber$1 = typeOfTest("number");
const isObject = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject$1 = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject$1(result[targetKey]) && isPlainObject$1(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject$1(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber$1(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data: data2 }) => {
      if (source === _global && data2 === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
const isIterable = (thing) => thing != null && isFunction(thing[iterator]);
const utils$1$2 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber: isNumber$1,
  isBoolean,
  isObject,
  isPlainObject: isPlainObject$1,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};
function AxiosError$1(message, code, config, request2, response2) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request2 && (this.request = request2);
  if (response2) {
    this.response = response2;
    this.status = response2.status ? response2.status : null;
  }
}
utils$1$2.inherits(AxiosError$1, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1$2.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const prototype$1 = AxiosError$1.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError$1, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError$1.from = (error, code, config, request2, response2, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1$2.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError$1.call(axiosError, error.message, code, config, request2, response2);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
function isVisitable(thing) {
  return utils$1$2.isPlainObject(thing) || utils$1$2.isArray(thing);
}
function removeBrackets(key) {
  return utils$1$2.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2) return key;
  return path2.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$1$2.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$1$2.toFlatObject(utils$1$2, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData$1(obj, formData, options) {
  if (!utils$1$2.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (form_dataExports || FormData)();
  options = utils$1$2.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$1$2.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$1$2.isSpecCompliantForm(formData);
  if (!utils$1$2.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils$1$2.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$1$2.isBlob(value)) {
      throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1$2.isArrayBuffer(value) || utils$1$2.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils$1$2.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$1$2.isArray(value) && isFlatArray(value) || (utils$1$2.isFileList(value) || utils$1$2.endsWith(key, "[]")) && (arr = utils$1$2.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index2) {
          !(utils$1$2.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path2) {
    if (utils$1$2.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils$1$2.forEach(value, function each(el, key) {
      const result = !(utils$1$2.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$1$2.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$1$2.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData$1(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString2(encoder2) {
  const _encode = encoder2 ? function(value) {
    return encoder2.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  if (utils$1$2.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1$2.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1$2.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = require$$0$6.URLSearchParams;
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  const randomValues = new Uint32Array(size);
  crypto$1.randomFillSync(randomValues);
  for (let i = 0; i < size; i++) {
    str += alphabet[randomValues[i] % length];
  }
  return str;
};
const platform$1 = {
  isNode: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: form_dataExports,
    Blob: typeof Blob !== "undefined" && Blob || null
  },
  ALPHABET,
  generateString,
  protocols: ["http", "https", "file", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const _navigator = typeof navigator === "object" && navigator || void 0;
const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils$5,
  ...platform$1
};
function toURLEncodedForm(data2, options) {
  return toFormData$1(data2, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path2, helpers) {
      if (platform.isNode && utils$1$2.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils$1$2.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index2) {
    let name = path2[index2++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path2.length;
    name = !name && utils$1$2.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$1$2.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$1$2.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path2, value, target[name], index2);
    if (result && utils$1$2.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$1$2.isFormData(formData) && utils$1$2.isFunction(formData.entries)) {
    const obj = {};
    utils$1$2.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser2, encoder2) {
  if (utils$1$2.isString(rawValue)) {
    try {
      (parser2 || JSON.parse)(rawValue);
      return utils$1$2.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder2 || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data2, headers2) {
    const contentType2 = headers2.getContentType() || "";
    const hasJSONContentType = contentType2.indexOf("application/json") > -1;
    const isObjectPayload = utils$1$2.isObject(data2);
    if (isObjectPayload && utils$1$2.isHTMLForm(data2)) {
      data2 = new FormData(data2);
    }
    const isFormData2 = utils$1$2.isFormData(data2);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data2)) : data2;
    }
    if (utils$1$2.isArrayBuffer(data2) || utils$1$2.isBuffer(data2) || utils$1$2.isStream(data2) || utils$1$2.isFile(data2) || utils$1$2.isBlob(data2) || utils$1$2.isReadableStream(data2)) {
      return data2;
    }
    if (utils$1$2.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils$1$2.isURLSearchParams(data2)) {
      headers2.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data2.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType2.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data2, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1$2.isFileList(data2)) || contentType2.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData$1(
          isFileList2 ? { "files[]": data2 } : data2,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers2.setContentType("application/json", false);
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$1$2.isResponse(data2) || utils$1$2.isReadableStream(data2)) {
      return data2;
    }
    if (data2 && utils$1$2.isString(data2) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data2);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data2;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1$2.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
const ignoreDuplicateOf = utils$1$2.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser2(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$1$2.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils$1$2.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$1$2.isString(value)) return;
  if (utils$1$2.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils$1$2.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$1$2.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
let AxiosHeaders$1 = class AxiosHeaders {
  constructor(headers2) {
    headers2 && this.set(headers2);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$1$2.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers2, _rewrite) => utils$1$2.forEach(headers2, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$1$2.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$1$2.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$1$2.isObject(header) && utils$1$2.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils$1$2.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils$1$2.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser2) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1$2.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser2) {
          return value;
        }
        if (parser2 === true) {
          return parseTokens(value);
        }
        if (utils$1$2.isFunction(parser2)) {
          return parser2.call(this, value, key);
        }
        if (utils$1$2.isRegExp(parser2)) {
          return parser2.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1$2.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$1$2.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$1$2.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers2 = {};
    utils$1$2.forEach(this, (value, header) => {
      const key = utils$1$2.findKey(headers2, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers2[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1$2.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1$2.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$1$2.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1$2.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1$2.freezeMethods(AxiosHeaders$1);
function transformData(fns, response2) {
  const config = this || defaults;
  const context = response2 || config;
  const headers2 = AxiosHeaders$1.from(context.headers);
  let data2 = context.data;
  utils$1$2.forEach(fns, function transform(fn) {
    data2 = fn.call(config, data2, headers2.normalize(), response2 ? response2.status : void 0);
  });
  headers2.normalize();
  return data2;
}
function isCancel$1(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError$1(message, config, request2) {
  AxiosError$1.call(this, message == null ? "canceled" : message, AxiosError$1.ERR_CANCELED, config, request2);
  this.name = "CanceledError";
}
utils$1$2.inherits(CanceledError$1, AxiosError$1, {
  __CANCEL__: true
});
function settle(resolve, reject, response2) {
  const validateStatus2 = response2.config.validateStatus;
  if (!response2.status || !validateStatus2 || validateStatus2(response2.status)) {
    resolve(response2);
  } else {
    reject(new AxiosError$1(
      "Request failed with status code " + response2.status,
      [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response2.status / 100) - 4],
      response2.config,
      response2.request,
      response2
    ));
  }
}
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
var proxyFromEnv = {};
var hasRequiredProxyFromEnv;
function requireProxyFromEnv() {
  if (hasRequiredProxyFromEnv) return proxyFromEnv;
  hasRequiredProxyFromEnv = 1;
  var parseUrl = require$$0$6.parse;
  var DEFAULT_PORTS = {
    ftp: 21,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var stringEndsWith = String.prototype.endsWith || function(s) {
    return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
  };
  function getProxyForUrl(url) {
    var parsedUrl = typeof url === "string" ? parseUrl(url) : url || {};
    var proto2 = parsedUrl.protocol;
    var hostname = parsedUrl.host;
    var port = parsedUrl.port;
    if (typeof hostname !== "string" || !hostname || typeof proto2 !== "string") {
      return "";
    }
    proto2 = proto2.split(":", 1)[0];
    hostname = hostname.replace(/:\d*$/, "");
    port = parseInt(port) || DEFAULT_PORTS[proto2] || 0;
    if (!shouldProxy(hostname, port)) {
      return "";
    }
    var proxy = getEnv("npm_config_" + proto2 + "_proxy") || getEnv(proto2 + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
    if (proxy && proxy.indexOf("://") === -1) {
      proxy = proto2 + "://" + proxy;
    }
    return proxy;
  }
  function shouldProxy(hostname, port) {
    var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
    if (!NO_PROXY) {
      return true;
    }
    if (NO_PROXY === "*") {
      return false;
    }
    return NO_PROXY.split(/[,\s]/).every(function(proxy) {
      if (!proxy) {
        return true;
      }
      var parsedProxy = proxy.match(/^(.+):(\d+)$/);
      var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
      var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
      if (parsedProxyPort && parsedProxyPort !== port) {
        return true;
      }
      if (!/^[.*]/.test(parsedProxyHostname)) {
        return hostname !== parsedProxyHostname;
      }
      if (parsedProxyHostname.charAt(0) === "*") {
        parsedProxyHostname = parsedProxyHostname.slice(1);
      }
      return !stringEndsWith.call(hostname, parsedProxyHostname);
    });
  }
  function getEnv(key) {
    return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
  }
  proxyFromEnv.getProxyForUrl = getProxyForUrl;
  return proxyFromEnv;
}
var proxyFromEnvExports = requireProxyFromEnv();
var followRedirects$1 = { exports: {} };
var browser$3 = { exports: {} };
var ms$2;
var hasRequiredMs$2;
function requireMs$2() {
  if (hasRequiredMs$2) return ms$2;
  hasRequiredMs$2 = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms$2 = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms$2;
}
var common$3;
var hasRequiredCommon$3;
function requireCommon$3() {
  if (hasRequiredCommon$3) return common$3;
  hasRequiredCommon$3 = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs$2();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index2++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index2];
            match = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend2;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common$3 = setup;
  return common$3;
}
var hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3) return browser$3.exports;
  hasRequiredBrowser$3 = 1;
  (function(module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = requireCommon$3()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser$3, browser$3.exports);
  return browser$3.exports;
}
var debug_1$1;
var hasRequiredDebug$2;
function requireDebug$2() {
  if (hasRequiredDebug$2) return debug_1$1;
  hasRequiredDebug$2 = 1;
  var debug2;
  debug_1$1 = function() {
    if (!debug2) {
      try {
        debug2 = requireBrowser$3()("follow-redirects");
      } catch (error) {
      }
      if (typeof debug2 !== "function") {
        debug2 = function() {
        };
      }
    }
    debug2.apply(null, arguments);
  };
  return debug_1$1;
}
var hasRequiredFollowRedirects$1;
function requireFollowRedirects$1() {
  if (hasRequiredFollowRedirects$1) return followRedirects$1.exports;
  hasRequiredFollowRedirects$1 = 1;
  var url = require$$0$6;
  var URL2 = url.URL;
  var http = require$$1$4;
  var https = require$$2$1;
  var Writable = stream.Writable;
  var assert = require$$5$1;
  var debug2 = requireDebug$2();
  (function detectUnsupportedEnvironment() {
    var looksLikeNode = typeof process !== "undefined";
    var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
    var looksLikeV8 = isFunction2(Error.captureStackTrace);
    if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
      console.warn("The follow-redirects package should be excluded from browser builds.");
    }
  })();
  var useNativeURL = false;
  try {
    assert(new URL2(""));
  } catch (error) {
    useNativeURL = error.code === "ERR_INVALID_URL";
  }
  var preservedUrlFields = [
    "auth",
    "host",
    "hostname",
    "href",
    "path",
    "pathname",
    "port",
    "protocol",
    "query",
    "search",
    "hash"
  ];
  var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
  var eventHandlers = /* @__PURE__ */ Object.create(null);
  events.forEach(function(event) {
    eventHandlers[event] = function(arg1, arg2, arg3) {
      this._redirectable.emit(event, arg1, arg2, arg3);
    };
  });
  var InvalidUrlError = createErrorType(
    "ERR_INVALID_URL",
    "Invalid URL",
    TypeError
  );
  var RedirectionError = createErrorType(
    "ERR_FR_REDIRECTION_FAILURE",
    "Redirected request failed"
  );
  var TooManyRedirectsError = createErrorType(
    "ERR_FR_TOO_MANY_REDIRECTS",
    "Maximum number of redirects exceeded",
    RedirectionError
  );
  var MaxBodyLengthExceededError = createErrorType(
    "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
    "Request body larger than maxBodyLength limit"
  );
  var WriteAfterEndError = createErrorType(
    "ERR_STREAM_WRITE_AFTER_END",
    "write after end"
  );
  var destroy = Writable.prototype.destroy || noop2;
  function RedirectableRequest(options, responseCallback) {
    Writable.call(this);
    this._sanitizeOptions(options);
    this._options = options;
    this._ended = false;
    this._ending = false;
    this._redirectCount = 0;
    this._redirects = [];
    this._requestBodyLength = 0;
    this._requestBodyBuffers = [];
    if (responseCallback) {
      this.on("response", responseCallback);
    }
    var self2 = this;
    this._onNativeResponse = function(response2) {
      try {
        self2._processResponse(response2);
      } catch (cause) {
        self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
      }
    };
    this._performRequest();
  }
  RedirectableRequest.prototype = Object.create(Writable.prototype);
  RedirectableRequest.prototype.abort = function() {
    destroyRequest(this._currentRequest);
    this._currentRequest.abort();
    this.emit("abort");
  };
  RedirectableRequest.prototype.destroy = function(error) {
    destroyRequest(this._currentRequest, error);
    destroy.call(this, error);
    return this;
  };
  RedirectableRequest.prototype.write = function(data2, encoding2, callback) {
    if (this._ending) {
      throw new WriteAfterEndError();
    }
    if (!isString2(data2) && !isBuffer2(data2)) {
      throw new TypeError("data should be a string, Buffer or Uint8Array");
    }
    if (isFunction2(encoding2)) {
      callback = encoding2;
      encoding2 = null;
    }
    if (data2.length === 0) {
      if (callback) {
        callback();
      }
      return;
    }
    if (this._requestBodyLength + data2.length <= this._options.maxBodyLength) {
      this._requestBodyLength += data2.length;
      this._requestBodyBuffers.push({ data: data2, encoding: encoding2 });
      this._currentRequest.write(data2, encoding2, callback);
    } else {
      this.emit("error", new MaxBodyLengthExceededError());
      this.abort();
    }
  };
  RedirectableRequest.prototype.end = function(data2, encoding2, callback) {
    if (isFunction2(data2)) {
      callback = data2;
      data2 = encoding2 = null;
    } else if (isFunction2(encoding2)) {
      callback = encoding2;
      encoding2 = null;
    }
    if (!data2) {
      this._ended = this._ending = true;
      this._currentRequest.end(null, null, callback);
    } else {
      var self2 = this;
      var currentRequest = this._currentRequest;
      this.write(data2, encoding2, function() {
        self2._ended = true;
        currentRequest.end(null, null, callback);
      });
      this._ending = true;
    }
  };
  RedirectableRequest.prototype.setHeader = function(name, value) {
    this._options.headers[name] = value;
    this._currentRequest.setHeader(name, value);
  };
  RedirectableRequest.prototype.removeHeader = function(name) {
    delete this._options.headers[name];
    this._currentRequest.removeHeader(name);
  };
  RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
    var self2 = this;
    function destroyOnTimeout(socket) {
      socket.setTimeout(msecs);
      socket.removeListener("timeout", socket.destroy);
      socket.addListener("timeout", socket.destroy);
    }
    function startTimer(socket) {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
      }
      self2._timeout = setTimeout(function() {
        self2.emit("timeout");
        clearTimer();
      }, msecs);
      destroyOnTimeout(socket);
    }
    function clearTimer() {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
        self2._timeout = null;
      }
      self2.removeListener("abort", clearTimer);
      self2.removeListener("error", clearTimer);
      self2.removeListener("response", clearTimer);
      self2.removeListener("close", clearTimer);
      if (callback) {
        self2.removeListener("timeout", callback);
      }
      if (!self2.socket) {
        self2._currentRequest.removeListener("socket", startTimer);
      }
    }
    if (callback) {
      this.on("timeout", callback);
    }
    if (this.socket) {
      startTimer(this.socket);
    } else {
      this._currentRequest.once("socket", startTimer);
    }
    this.on("socket", destroyOnTimeout);
    this.on("abort", clearTimer);
    this.on("error", clearTimer);
    this.on("response", clearTimer);
    this.on("close", clearTimer);
    return this;
  };
  [
    "flushHeaders",
    "getHeader",
    "setNoDelay",
    "setSocketKeepAlive"
  ].forEach(function(method) {
    RedirectableRequest.prototype[method] = function(a, b) {
      return this._currentRequest[method](a, b);
    };
  });
  ["aborted", "connection", "socket"].forEach(function(property) {
    Object.defineProperty(RedirectableRequest.prototype, property, {
      get: function() {
        return this._currentRequest[property];
      }
    });
  });
  RedirectableRequest.prototype._sanitizeOptions = function(options) {
    if (!options.headers) {
      options.headers = {};
    }
    if (options.host) {
      if (!options.hostname) {
        options.hostname = options.host;
      }
      delete options.host;
    }
    if (!options.pathname && options.path) {
      var searchPos = options.path.indexOf("?");
      if (searchPos < 0) {
        options.pathname = options.path;
      } else {
        options.pathname = options.path.substring(0, searchPos);
        options.search = options.path.substring(searchPos);
      }
    }
  };
  RedirectableRequest.prototype._performRequest = function() {
    var protocol = this._options.protocol;
    var nativeProtocol = this._options.nativeProtocols[protocol];
    if (!nativeProtocol) {
      throw new TypeError("Unsupported protocol " + protocol);
    }
    if (this._options.agents) {
      var scheme = protocol.slice(0, -1);
      this._options.agent = this._options.agents[scheme];
    }
    var request2 = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
    request2._redirectable = this;
    for (var event of events) {
      request2.on(event, eventHandlers[event]);
    }
    this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
      // When making a request to a proxy, []
      // a client MUST send the target URI in absolute-form [].
      this._options.path
    );
    if (this._isRedirect) {
      var i = 0;
      var self2 = this;
      var buffers = this._requestBodyBuffers;
      (function writeNext(error) {
        if (request2 === self2._currentRequest) {
          if (error) {
            self2.emit("error", error);
          } else if (i < buffers.length) {
            var buffer2 = buffers[i++];
            if (!request2.finished) {
              request2.write(buffer2.data, buffer2.encoding, writeNext);
            }
          } else if (self2._ended) {
            request2.end();
          }
        }
      })();
    }
  };
  RedirectableRequest.prototype._processResponse = function(response2) {
    var statusCode2 = response2.statusCode;
    if (this._options.trackRedirects) {
      this._redirects.push({
        url: this._currentUrl,
        headers: response2.headers,
        statusCode: statusCode2
      });
    }
    var location = response2.headers.location;
    if (!location || this._options.followRedirects === false || statusCode2 < 300 || statusCode2 >= 400) {
      response2.responseUrl = this._currentUrl;
      response2.redirects = this._redirects;
      this.emit("response", response2);
      this._requestBodyBuffers = [];
      return;
    }
    destroyRequest(this._currentRequest);
    response2.destroy();
    if (++this._redirectCount > this._options.maxRedirects) {
      throw new TooManyRedirectsError();
    }
    var requestHeaders;
    var beforeRedirect = this._options.beforeRedirect;
    if (beforeRedirect) {
      requestHeaders = Object.assign({
        // The Host header was set by nativeProtocol.request
        Host: response2.req.getHeader("host")
      }, this._options.headers);
    }
    var method = this._options.method;
    if ((statusCode2 === 301 || statusCode2 === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
    // the server is redirecting the user agent to a different resource []
    // A user agent can perform a retrieval request targeting that URI
    // (a GET or HEAD request if using HTTP) []
    statusCode2 === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
      this._options.method = "GET";
      this._requestBodyBuffers = [];
      removeMatchingHeaders(/^content-/i, this._options.headers);
    }
    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
    var currentUrlParts = parseUrl(this._currentUrl);
    var currentHost = currentHostHeader || currentUrlParts.host;
    var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
    var redirectUrl = resolveUrl(location, currentUrl);
    debug2("redirecting to", redirectUrl.href);
    this._isRedirect = true;
    spreadUrlObject(redirectUrl, this._options);
    if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
      removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
    }
    if (isFunction2(beforeRedirect)) {
      var responseDetails = {
        headers: response2.headers,
        statusCode: statusCode2
      };
      var requestDetails = {
        url: currentUrl,
        method,
        headers: requestHeaders
      };
      beforeRedirect(this._options, responseDetails, requestDetails);
      this._sanitizeOptions(this._options);
    }
    this._performRequest();
  };
  function wrap(protocols) {
    var exports = {
      maxRedirects: 21,
      maxBodyLength: 10 * 1024 * 1024
    };
    var nativeProtocols = {};
    Object.keys(protocols).forEach(function(scheme) {
      var protocol = scheme + ":";
      var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
      var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);
      function request2(input, options, callback) {
        if (isURL(input)) {
          input = spreadUrlObject(input);
        } else if (isString2(input)) {
          input = spreadUrlObject(parseUrl(input));
        } else {
          callback = options;
          options = validateUrl(input);
          input = { protocol };
        }
        if (isFunction2(options)) {
          callback = options;
          options = null;
        }
        options = Object.assign({
          maxRedirects: exports.maxRedirects,
          maxBodyLength: exports.maxBodyLength
        }, input, options);
        options.nativeProtocols = nativeProtocols;
        if (!isString2(options.host) && !isString2(options.hostname)) {
          options.hostname = "::1";
        }
        assert.equal(options.protocol, protocol, "protocol mismatch");
        debug2("options", options);
        return new RedirectableRequest(options, callback);
      }
      function get2(input, options, callback) {
        var wrappedRequest = wrappedProtocol.request(input, options, callback);
        wrappedRequest.end();
        return wrappedRequest;
      }
      Object.defineProperties(wrappedProtocol, {
        request: { value: request2, configurable: true, enumerable: true, writable: true },
        get: { value: get2, configurable: true, enumerable: true, writable: true }
      });
    });
    return exports;
  }
  function noop2() {
  }
  function parseUrl(input) {
    var parsed;
    if (useNativeURL) {
      parsed = new URL2(input);
    } else {
      parsed = validateUrl(url.parse(input));
      if (!isString2(parsed.protocol)) {
        throw new InvalidUrlError({ input });
      }
    }
    return parsed;
  }
  function resolveUrl(relative, base) {
    return useNativeURL ? new URL2(relative, base) : parseUrl(url.resolve(base, relative));
  }
  function validateUrl(input) {
    if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    return input;
  }
  function spreadUrlObject(urlObject, target) {
    var spread2 = target || {};
    for (var key of preservedUrlFields) {
      spread2[key] = urlObject[key];
    }
    if (spread2.hostname.startsWith("[")) {
      spread2.hostname = spread2.hostname.slice(1, -1);
    }
    if (spread2.port !== "") {
      spread2.port = Number(spread2.port);
    }
    spread2.path = spread2.search ? spread2.pathname + spread2.search : spread2.pathname;
    return spread2;
  }
  function removeMatchingHeaders(regex2, headers2) {
    var lastValue;
    for (var header in headers2) {
      if (regex2.test(header)) {
        lastValue = headers2[header];
        delete headers2[header];
      }
    }
    return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
  }
  function createErrorType(code, message, baseClass) {
    function CustomError(properties) {
      if (isFunction2(Error.captureStackTrace)) {
        Error.captureStackTrace(this, this.constructor);
      }
      Object.assign(this, properties || {});
      this.code = code;
      this.message = this.cause ? message + ": " + this.cause.message : message;
    }
    CustomError.prototype = new (baseClass || Error)();
    Object.defineProperties(CustomError.prototype, {
      constructor: {
        value: CustomError,
        enumerable: false
      },
      name: {
        value: "Error [" + code + "]",
        enumerable: false
      }
    });
    return CustomError;
  }
  function destroyRequest(request2, error) {
    for (var event of events) {
      request2.removeListener(event, eventHandlers[event]);
    }
    request2.on("error", noop2);
    request2.destroy(error);
  }
  function isSubdomain(subdomain, domain) {
    assert(isString2(subdomain) && isString2(domain));
    var dot = subdomain.length - domain.length - 1;
    return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
  }
  function isString2(value) {
    return typeof value === "string" || value instanceof String;
  }
  function isFunction2(value) {
    return typeof value === "function";
  }
  function isBuffer2(value) {
    return typeof value === "object" && "length" in value;
  }
  function isURL(value) {
    return URL2 && value instanceof URL2;
  }
  followRedirects$1.exports = wrap({ http, https });
  followRedirects$1.exports.wrap = wrap;
  return followRedirects$1.exports;
}
var followRedirectsExports = requireFollowRedirects$1();
const VERSION$1 = "1.9.0";
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
const DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri2, asBlob, options) {
  const _Blob = options && options.Blob || platform.classes.Blob;
  const protocol = parseProtocol(uri2);
  if (asBlob === void 0 && _Blob) {
    asBlob = true;
  }
  if (protocol === "data") {
    uri2 = protocol.length ? uri2.slice(protocol.length + 1) : uri2;
    const match = DATA_URL_PATTERN.exec(uri2);
    if (!match) {
      throw new AxiosError$1("Invalid URL", AxiosError$1.ERR_INVALID_URL);
    }
    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer2 = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError$1("Blob is not supported", AxiosError$1.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer2], { type: mime });
    }
    return buffer2;
  }
  throw new AxiosError$1("Unsupported protocol " + protocol, AxiosError$1.ERR_NOT_SUPPORT);
}
const kInternals = Symbol("internals");
class AxiosTransformStream extends stream.Transform {
  constructor(options) {
    options = utils$1$2.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils$1$2.isUndefined(source[prop]);
    });
    super({
      readableHighWaterMark: options.chunkSize
    });
    const internals = this[kInternals] = {
      timeWindow: options.timeWindow,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    this.on("newListener", (event) => {
      if (event === "progress") {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
  }
  _read(size) {
    const internals = this[kInternals];
    if (internals.onReadCallback) {
      internals.onReadCallback();
    }
    return super._read(size);
  }
  _transform(chunk, encoding2, callback) {
    const internals = this[kInternals];
    const maxRate = internals.maxRate;
    const readableHighWaterMark = this.readableHighWaterMark;
    const timeWindow = internals.timeWindow;
    const divider = 1e3 / timeWindow;
    const bytesThreshold = maxRate / divider;
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
    const pushChunk = (_chunk, _callback) => {
      const bytes2 = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes2;
      internals.bytes += bytes2;
      internals.isCaptured && this.emit("progress", internals.bytesSeen);
      if (this.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    };
    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;
      if (maxRate) {
        const now2 = Date.now();
        if (!internals.ts || (passed = now2 - internals.ts) >= timeWindow) {
          internals.ts = now2;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }
        bytesLeft = bytesThreshold - internals.bytes;
      }
      if (maxRate) {
        if (bytesLeft <= 0) {
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }
        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }
      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }
      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };
    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }
      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
}
const { asyncIterator } = Symbol;
const readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};
const BOUNDARY_ALPHABET = platform.ALPHABET.ALPHA_DIGIT + "-_";
const textEncoder = typeof TextEncoder === "function" ? new TextEncoder() : new require$$0$5.TextEncoder();
const CRLF = "\r\n";
const CRLF_BYTES = textEncoder.encode(CRLF);
const CRLF_BYTES_COUNT = 2;
class FormDataPart {
  constructor(name, value) {
    const { escapeName } = this.constructor;
    const isStringValue = utils$1$2.isString(value);
    let headers2 = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers2 += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }
    this.headers = textEncoder.encode(headers2 + CRLF);
    this.contentLength = isStringValue ? value.byteLength : value.size;
    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
    this.name = name;
    this.value = value;
  }
  async *encode() {
    yield this.headers;
    const { value } = this;
    if (utils$1$2.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob(value);
    }
    yield CRLF_BYTES;
  }
  static escapeName(name) {
    return String(name).replace(/[\r\n"]/g, (match) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[match]);
  }
}
const formDataToStream = (form, headersHandler, options) => {
  const {
    tag = "form-data-boundary",
    size = 25,
    boundary = tag + "-" + platform.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils$1$2.isFormData(form)) {
    throw TypeError("FormData instance required");
  }
  if (boundary.length < 1 || boundary.length > 70) {
    throw Error("boundary must be 10-70 characters long");
  }
  const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
  const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF);
  let contentLength = footerBytes.byteLength;
  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });
  contentLength += boundaryBytes.byteLength * parts.length;
  contentLength = utils$1$2.toFiniteNumber(contentLength);
  const computedHeaders = {
    "Content-Type": `multipart/form-data; boundary=${boundary}`
  };
  if (Number.isFinite(contentLength)) {
    computedHeaders["Content-Length"] = contentLength;
  }
  headersHandler && headersHandler(computedHeaders);
  return Readable.from(async function* () {
    for (const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }
    yield footerBytes;
  }());
};
class ZlibHeaderTransformStream extends stream.Transform {
  __transform(chunk, encoding2, callback) {
    this.push(chunk);
    callback();
  }
  _transform(chunk, encoding2, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;
      if (chunk[0] !== 120) {
        const header = Buffer.alloc(2);
        header[0] = 120;
        header[1] = 156;
        this.push(header, encoding2);
      }
    }
    this.__transform(chunk, encoding2, callback);
  }
}
const callbackify = (fn, reducer) => {
  return utils$1$2.isAsyncFn(fn) ? function(...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes2 = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return function push(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes2[head] = chunkLength;
    timestamps[head] = now2;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes2[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now2 = Date.now()) => {
    timestamp = now2;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now2 = Date.now();
    const passed = now2 - timestamp;
    if (passed >= threshold) {
      invoke(args, now2);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data2 = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data2);
  }, freq);
};
const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
const asyncDecorator = (fn) => (...args) => utils$1$2.asap(() => fn(...args));
const zlibOptions = {
  flush: zlib.constants.Z_SYNC_FLUSH,
  finishFlush: zlib.constants.Z_SYNC_FLUSH
};
const brotliOptions = {
  flush: zlib.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
};
const isBrotliSupported = utils$1$2.isFunction(zlib.createBrotliDecompress);
const { http: httpFollow, https: httpsFollow } = followRedirectsExports;
const isHttps = /https:?/;
const supportedProtocols = platform.protocols.map((protocol) => {
  return protocol + ":";
});
const flushOnFinish = (stream2, [throttled, flush]) => {
  stream2.on("end", flush).on("error", flush);
  return throttled;
};
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = proxyFromEnvExports.getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
const isHttpAdapterSupported = typeof process !== "undefined" && utils$1$2.kindOf(process) === "process";
const wrapAsync = (asyncExecutor) => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;
    const done = (value, isRejected) => {
      if (isDone) return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };
    const _resolve = (value) => {
      done(value);
      resolve(value);
    };
    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };
    asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
  });
};
const resolveFamily = ({ address, family }) => {
  if (!utils$1$2.isString(address)) {
    throw TypeError("address must be a string");
  }
  return {
    address,
    family: family || (address.indexOf(".") < 0 ? 6 : 4)
  };
};
const buildAddressEntry = (address, family) => resolveFamily(utils$1$2.isObject(address) ? address : { address, family });
const httpAdapter = isHttpAdapterSupported && function httpAdapter2(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
    let { data: data2, lookup, family } = config;
    const { responseType, responseEncoding } = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;
    if (lookup) {
      const _lookup = callbackify(lookup, (value) => utils$1$2.isArray(value) ? value : [value]);
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }
          const addresses = utils$1$2.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }
    const emitter = new EventEmitter();
    const onFinished2 = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", abort);
      }
      emitter.removeAllListeners();
    };
    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished2();
      }
    });
    function abort(reason) {
      emitter.emit("abort", !reason || reason.type ? new CanceledError$1(null, config, req) : reason);
    }
    emitter.once("abort", reject);
    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);
      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
      }
    }
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : void 0);
    const protocol = parsed.protocol || supportedProtocols[0];
    if (protocol === "data:") {
      let convertedData;
      if (method !== "GET") {
        return settle(resolve, reject, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config
        });
      }
      try {
        convertedData = fromDataURI(config.url, responseType === "blob", {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError$1.from(err, AxiosError$1.ERR_BAD_REQUEST, config);
      }
      if (responseType === "text") {
        convertedData = convertedData.toString(responseEncoding);
        if (!responseEncoding || responseEncoding === "utf8") {
          convertedData = utils$1$2.stripBOM(convertedData);
        }
      } else if (responseType === "stream") {
        convertedData = stream.Readable.from(convertedData);
      }
      return settle(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: "OK",
        headers: new AxiosHeaders$1(),
        config
      });
    }
    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError$1(
        "Unsupported protocol " + protocol,
        AxiosError$1.ERR_BAD_REQUEST,
        config
      ));
    }
    const headers2 = AxiosHeaders$1.from(config.headers).normalize();
    headers2.set("User-Agent", "axios/" + VERSION$1, false);
    const { onUploadProgress, onDownloadProgress } = config;
    const maxRate = config.maxRate;
    let maxUploadRate = void 0;
    let maxDownloadRate = void 0;
    if (utils$1$2.isSpecCompliantForm(data2)) {
      const userBoundary = headers2.getContentType(/boundary=([-_\w\d]{10,70})/i);
      data2 = formDataToStream(data2, (formHeaders) => {
        headers2.set(formHeaders);
      }, {
        tag: `axios-${VERSION$1}-boundary`,
        boundary: userBoundary && userBoundary[1] || void 0
      });
    } else if (utils$1$2.isFormData(data2) && utils$1$2.isFunction(data2.getHeaders)) {
      headers2.set(data2.getHeaders());
      if (!headers2.hasContentLength()) {
        try {
          const knownLength = await require$$0$5.promisify(data2.getLength).call(data2);
          Number.isFinite(knownLength) && knownLength >= 0 && headers2.setContentLength(knownLength);
        } catch (e) {
        }
      }
    } else if (utils$1$2.isBlob(data2) || utils$1$2.isFile(data2)) {
      data2.size && headers2.setContentType(data2.type || "application/octet-stream");
      headers2.setContentLength(data2.size || 0);
      data2 = stream.Readable.from(readBlob(data2));
    } else if (data2 && !utils$1$2.isStream(data2)) {
      if (Buffer.isBuffer(data2)) ;
      else if (utils$1$2.isArrayBuffer(data2)) {
        data2 = Buffer.from(new Uint8Array(data2));
      } else if (utils$1$2.isString(data2)) {
        data2 = Buffer.from(data2, "utf-8");
      } else {
        return reject(new AxiosError$1(
          "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
          AxiosError$1.ERR_BAD_REQUEST,
          config
        ));
      }
      headers2.setContentLength(data2.length, false);
      if (config.maxBodyLength > -1 && data2.length > config.maxBodyLength) {
        return reject(new AxiosError$1(
          "Request body larger than maxBodyLength limit",
          AxiosError$1.ERR_BAD_REQUEST,
          config
        ));
      }
    }
    const contentLength = utils$1$2.toFiniteNumber(headers2.getContentLength());
    if (utils$1$2.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }
    if (data2 && (onUploadProgress || maxUploadRate)) {
      if (!utils$1$2.isStream(data2)) {
        data2 = stream.Readable.from(data2, { objectMode: false });
      }
      data2 = stream.pipeline([data2, new AxiosTransformStream({
        maxRate: utils$1$2.toFiniteNumber(maxUploadRate)
      })], utils$1$2.noop);
      onUploadProgress && data2.on("progress", flushOnFinish(
        data2,
        progressEventDecorator(
          contentLength,
          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
        )
      ));
    }
    let auth = void 0;
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password || "";
      auth = username + ":" + password;
    }
    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ":" + urlPassword;
    }
    auth && headers2.delete("authorization");
    let path2;
    try {
      path2 = buildURL(
        parsed.pathname + parsed.search,
        config.params,
        config.paramsSerializer
      ).replace(/^\?/, "");
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }
    headers2.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
      false
    );
    const options = {
      path: path2,
      method,
      headers: headers2.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };
    !utils$1$2.isUndefined(lookup) && (options.lookup = lookup);
    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
    }
    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? require$$2$1 : require$$1$4;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }
    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      options.maxBodyLength = Infinity;
    }
    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed) return;
      const streams2 = [res];
      const responseLength = +res.headers["content-length"];
      if (onDownloadProgress || maxDownloadRate) {
        const transformStream = new AxiosTransformStream({
          maxRate: utils$1$2.toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on("progress", flushOnFinish(
          transformStream,
          progressEventDecorator(
            responseLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
          )
        ));
        streams2.push(transformStream);
      }
      let responseStream = res;
      const lastRequest = res.req || req;
      if (config.decompress !== false && res.headers["content-encoding"]) {
        if (method === "HEAD" || res.statusCode === 204) {
          delete res.headers["content-encoding"];
        }
        switch ((res.headers["content-encoding"] || "").toLowerCase()) {
          /*eslint default-case:0*/
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
            streams2.push(zlib.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "deflate":
            streams2.push(new ZlibHeaderTransformStream());
            streams2.push(zlib.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "br":
            if (isBrotliSupported) {
              streams2.push(zlib.createBrotliDecompress(brotliOptions));
              delete res.headers["content-encoding"];
            }
        }
      }
      responseStream = streams2.length > 1 ? stream.pipeline(streams2, utils$1$2.noop) : streams2[0];
      const offListeners = stream.finished(responseStream, () => {
        offListeners();
        onFinished2();
      });
      const response2 = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders$1(res.headers),
        config,
        request: lastRequest
      };
      if (responseType === "stream") {
        response2.data = responseStream;
        settle(resolve, reject, response2);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;
        responseStream.on("data", function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError$1(
              "maxContentLength size of " + config.maxContentLength + " exceeded",
              AxiosError$1.ERR_BAD_RESPONSE,
              config,
              lastRequest
            ));
          }
        });
        responseStream.on("aborted", function handlerStreamAborted() {
          if (rejected) {
            return;
          }
          const err = new AxiosError$1(
            "stream has been aborted",
            AxiosError$1.ERR_BAD_RESPONSE,
            config,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });
        responseStream.on("error", function handleStreamError(err) {
          if (req.destroyed) return;
          reject(AxiosError$1.from(err, null, config, lastRequest));
        });
        responseStream.on("end", function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== "arraybuffer") {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === "utf8") {
                responseData = utils$1$2.stripBOM(responseData);
              }
            }
            response2.data = responseData;
          } catch (err) {
            return reject(AxiosError$1.from(err, null, config, response2.request, response2));
          }
          settle(resolve, reject, response2);
        });
      }
      emitter.once("abort", (err) => {
        if (!responseStream.destroyed) {
          responseStream.emit("error", err);
          responseStream.destroy();
        }
      });
    });
    emitter.once("abort", (err) => {
      reject(err);
      req.destroy(err);
    });
    req.on("error", function handleRequestError(err) {
      reject(AxiosError$1.from(err, null, config, req));
    });
    req.on("socket", function handleRequestSocket(socket) {
      socket.setKeepAlive(true, 1e3 * 60);
    });
    if (config.timeout) {
      const timeout = parseInt(config.timeout, 10);
      if (Number.isNaN(timeout)) {
        reject(new AxiosError$1(
          "error trying to parse `config.timeout` to int",
          AxiosError$1.ERR_BAD_OPTION_VALUE,
          config,
          req
        ));
        return;
      }
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone) return;
        let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional2 = config.transitional || transitionalDefaults;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError$1(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
          config,
          req
        ));
        abort();
      });
    }
    if (utils$1$2.isStream(data2)) {
      let ended = false;
      let errored = false;
      data2.on("end", () => {
        ended = true;
      });
      data2.once("error", (err) => {
        errored = true;
        req.destroy(err);
      });
      data2.on("close", () => {
        if (!ended && !errored) {
          abort(new CanceledError$1("Request stream has been aborted", config, req));
        }
      });
      data2.pipe(req);
    } else {
      req.end(data2);
    }
  });
};
const isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform.origin),
  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
) : () => true;
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path2, domain, secure) {
      const cookie2 = [name + "=" + encodeURIComponent(value)];
      utils$1$2.isNumber(expires) && cookie2.push("expires=" + new Date(expires).toGMTString());
      utils$1$2.isString(path2) && cookie2.push("path=" + path2);
      utils$1$2.isString(domain) && cookie2.push("domain=" + domain);
      secure === true && cookie2.push("secure");
      document.cookie = cookie2.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
function mergeConfig$1(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils$1$2.isPlainObject(target) && utils$1$2.isPlainObject(source)) {
      return utils$1$2.merge.call({ caseless }, target, source);
    } else if (utils$1$2.isPlainObject(source)) {
      return utils$1$2.merge({}, source);
    } else if (utils$1$2.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, prop, caseless) {
    if (!utils$1$2.isUndefined(b)) {
      return getMergedValue(a, b, prop, caseless);
    } else if (!utils$1$2.isUndefined(a)) {
      return getMergedValue(void 0, a, prop, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils$1$2.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils$1$2.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils$1$2.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
  };
  utils$1$2.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$1$2.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const resolveConfig = (config) => {
  const newConfig = mergeConfig$1({}, config);
  let { data: data2, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers: headers2, auth } = newConfig;
  newConfig.headers = headers2 = AxiosHeaders$1.from(headers2);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers2.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType2;
  if (utils$1$2.isFormData(data2)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers2.setContentType(void 0);
    } else if ((contentType2 = headers2.getContentType()) !== false) {
      const [type2, ...tokens] = contentType2 ? contentType2.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers2.setContentType([type2 || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$1$2.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers2.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request2 = new XMLHttpRequest();
    request2.open(_config.method.toUpperCase(), _config.url, true);
    request2.timeout = _config.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      const response2 = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config,
        request: request2
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response2);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config, request2));
      request2 = null;
    };
    request2.onerror = function handleError2() {
      reject(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError$1(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
        config,
        request2
      ));
      request2 = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request2) {
      utils$1$2.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request2.setRequestHeader(key, val);
      });
    }
    if (!utils$1$2.isUndefined(_config.withCredentials)) {
      request2.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request2.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request2.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request2.upload.addEventListener("progress", uploadThrottled);
      request2.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError$1(null, config, request2) : cancel);
        request2.abort();
        request2 = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config));
      return;
    }
    request2.send(requestData || null);
  });
};
const composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError$1(`timeout ${timeout} of ms exceeded`, AxiosError$1.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils$1$2.asap(unsubscribe);
    return signal;
  }
};
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
const readStream = async function* (stream2) {
  if (stream2[Symbol.asyncIterator]) {
    yield* stream2;
    return;
  }
  const reader = stream2.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
const trackStream = (stream2, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream2, chunkSize);
  let bytes2 = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes2 += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator2.return();
    }
  }, {
    highWaterMark: 2
  });
};
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder2) => (str) => encoder2.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
};
const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && test(() => utils$1$2.isReadableStream(new Response("").body));
const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type2) => {
    !resolvers[type2] && (resolvers[type2] = utils$1$2.isFunction(res[type2]) ? (res2) => res2[type2]() : (_, config) => {
      throw new AxiosError$1(`Response type '${type2}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils$1$2.isBlob(body)) {
    return body.size;
  }
  if (utils$1$2.isSpecCompliantForm(body)) {
    const _request = new Request(platform.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils$1$2.isArrayBufferView(body) || utils$1$2.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils$1$2.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils$1$2.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
const resolveBodyLength = async (headers2, body) => {
  const length = utils$1$2.toFiniteNumber(headers2.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
const fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data: data2,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers: headers2,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request2;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers2, data2)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data2,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils$1$2.isFormData(data2) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers2.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data2 = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils$1$2.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request2 = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers2.normalize().toJSON(),
      body: data2,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response2 = await fetch(request2);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response2[prop];
      });
      const responseContentLength = utils$1$2.toFiniteNumber(response2.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response2 = new Response(
        trackStream(response2.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils$1$2.findKey(resolvers, responseType) || "text"](response2, config);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders$1.from(response2.headers),
        status: response2.status,
        statusText: response2.statusText,
        config,
        request: request2
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request2),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError$1.from(err, err && err.code, config, request2);
  }
});
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$1$2.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$1$2.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$1$2.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError$1(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError$1(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError$1(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults.adapter);
  return adapter(config).then(function onAdapterResolution(response2) {
    throwIfCancellationRequested(config);
    response2.data = transformData.call(
      config,
      config.transformResponse,
      response2
    );
    response2.headers = AxiosHeaders$1.from(response2.headers);
    return response2;
  }, function onAdapterRejection(reason) {
    if (!isCancel$1(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i) => {
  validators$1[type2] = function validator2(thing) {
    return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError$1(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError$1.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
validators$1.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
let Axios$1 = class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig$1(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers: headers2 } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1$2.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== void 0) ;
    else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator.assertOptions(config, {
      baseUrl: validators.spelling("baseURL"),
      withXsrfToken: validators.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers2 && utils$1$2.merge(
      headers2.common,
      headers2[config.method]
    );
    headers2 && utils$1$2.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers2[method];
      }
    );
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers2);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig$1(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils$1$2.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios$1.prototype[method] = function(url, config) {
    return this.request(mergeConfig$1(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils$1$2.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data2, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data: data2
      }));
    };
  }
  Axios$1.prototype[method] = generateHTTPMethod();
  Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
});
let CancelToken$1 = class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request2) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError$1(message, config, request2);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
function spread$1(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError$1(payload) {
  return utils$1$2.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode$1 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
  HttpStatusCode$1[value] = key;
});
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);
  utils$1$2.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils$1$2.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError$1;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel$1;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData$1;
axios.AxiosError = AxiosError$1;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread$1;
axios.isAxiosError = isAxiosError$1;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$1$2.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const {
  Axios: Axios2,
  AxiosError,
  CanceledError,
  isCancel,
  CancelToken: CancelToken2,
  VERSION,
  all: all2,
  Cancel,
  isAxiosError,
  spread,
  toFormData,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode,
  formToJSON,
  getAdapter,
  mergeConfig
} = axios;
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data2) => {
  const t = typeof data2;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data2) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data2)) {
        return ZodParsedType.array;
      }
      if (data2 === null) {
        return ZodParsedType.null;
      }
      if (data2.then && typeof data2.then === "function" && data2.catch && typeof data2.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data2 instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data2 instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data2 instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data: data2, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data: data2, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data2, params) {
    const result = this.safeParse(data2, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data2, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data2,
      parsedType: getParsedType(data2)
    };
    const result = this._parseSync({ data: data2, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data2) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data2,
      parsedType: getParsedType(data2)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data: data2, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data: data2, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data2, params) {
    const result = await this.safeParseAsync(data2, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data2, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data2,
      parsedType: getParsedType(data2)
    };
    const maybeAsyncResult = this._parse({ data: data2, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data2) => {
          if (!data2) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data2) => this["~validate"](data2)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex2 = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex2 = `${regex2}(${opts.join("|")})`;
  return new RegExp(`^${regex2}$`);
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex2 = datetimeRegex(check);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex2 = dateRegex;
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex2 = timeRegex(check);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex2, validation, message) {
    return this.refinement((data2) => regex2.test(data2), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex2, message) {
    return this._addCheck({
      kind: "regex",
      regex: regex2,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max2 = null;
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      } else if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a.length; index2++) {
      const itemA = a[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data2) => {
      return this._def.type.parseAsync(data2, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type2, params) => {
  return new ZodOptional({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type2, params) => {
  return new ZodNullable({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data2 = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data2 = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data: data2,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type2, params) => {
  return new ZodDefault({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type2, params) => {
  return new ZodCatch({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data2 = ctx.data;
    return this._def.type._parse({
      data: data2,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data2) => {
      if (isValid(data2)) {
        data2.value = Object.freeze(data2.value);
      }
      return data2;
    };
    return isAsync(result) ? result.then((data2) => freeze(data2)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type2, params) => {
  return new ZodReadonly({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const stringType = ZodString.create;
ZodNumber.create;
ZodBigInt.create;
ZodBoolean.create;
ZodDate.create;
ZodNever.create;
ZodArray.create;
const objectType = ZodObject.create;
ZodUnion.create;
ZodIntersection.create;
ZodTuple.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
ZodPromise.create;
ZodOptional.create;
ZodNullable.create;
const coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var express$1 = { exports: {} };
var bodyParser = { exports: {} };
var httpErrors = { exports: {} };
/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var browser$1$1;
var hasRequiredBrowser$1$1;
function requireBrowser$1$1() {
  if (hasRequiredBrowser$1$1) return browser$1$1;
  hasRequiredBrowser$1$1 = 1;
  browser$1$1 = depd;
  function depd(namespace) {
    if (!namespace) {
      throw new TypeError("argument namespace is required");
    }
    function deprecate(message) {
    }
    deprecate._file = void 0;
    deprecate._ignored = true;
    deprecate._namespace = namespace;
    deprecate._traced = false;
    deprecate._warned = /* @__PURE__ */ Object.create(null);
    deprecate.function = wrapfunction;
    deprecate.property = wrapproperty;
    return deprecate;
  }
  function wrapfunction(fn, message) {
    if (typeof fn !== "function") {
      throw new TypeError("argument fn must be a function");
    }
    return fn;
  }
  function wrapproperty(obj, prop, message) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new TypeError("argument obj must be object");
    }
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    if (!descriptor) {
      throw new TypeError("must call property on owner object");
    }
    if (!descriptor.configurable) {
      throw new TypeError("property must be configurable");
    }
  }
  return browser$1$1;
}
var setprototypeof;
var hasRequiredSetprototypeof;
function requireSetprototypeof() {
  if (hasRequiredSetprototypeof) return setprototypeof;
  hasRequiredSetprototypeof = 1;
  setprototypeof = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
  function setProtoOf(obj, proto2) {
    obj.__proto__ = proto2;
    return obj;
  }
  function mixinProperties(obj, proto2) {
    for (var prop in proto2) {
      if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
        obj[prop] = proto2[prop];
      }
    }
    return obj;
  }
  return setprototypeof;
}
const require$$0$3 = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a Teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Too Early",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var statuses;
var hasRequiredStatuses;
function requireStatuses() {
  if (hasRequiredStatuses) return statuses;
  hasRequiredStatuses = 1;
  var codes = require$$0$3;
  statuses = status;
  status.message = codes;
  status.code = createMessageToStatusCodeMap(codes);
  status.codes = createStatusCodeList(codes);
  status.redirect = {
    300: true,
    301: true,
    302: true,
    303: true,
    305: true,
    307: true,
    308: true
  };
  status.empty = {
    204: true,
    205: true,
    304: true
  };
  status.retry = {
    502: true,
    503: true,
    504: true
  };
  function createMessageToStatusCodeMap(codes2) {
    var map = {};
    Object.keys(codes2).forEach(function forEachCode(code) {
      var message = codes2[code];
      var status2 = Number(code);
      map[message.toLowerCase()] = status2;
    });
    return map;
  }
  function createStatusCodeList(codes2) {
    return Object.keys(codes2).map(function mapCode(code) {
      return Number(code);
    });
  }
  function getStatusCode(message) {
    var msg = message.toLowerCase();
    if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
      throw new Error('invalid status message: "' + message + '"');
    }
    return status.code[msg];
  }
  function getStatusMessage(code) {
    if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
      throw new Error("invalid status code: " + code);
    }
    return status.message[code];
  }
  function status(code) {
    if (typeof code === "number") {
      return getStatusMessage(code);
    }
    if (typeof code !== "string") {
      throw new TypeError("code must be a number or string");
    }
    var n = parseInt(code, 10);
    if (!isNaN(n)) {
      return getStatusMessage(n);
    }
    return getStatusCode(code);
  }
  return statuses;
}
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var toidentifier;
var hasRequiredToidentifier;
function requireToidentifier() {
  if (hasRequiredToidentifier) return toidentifier;
  hasRequiredToidentifier = 1;
  toidentifier = toIdentifier;
  function toIdentifier(str) {
    return str.split(" ").map(function(token) {
      return token.slice(0, 1).toUpperCase() + token.slice(1);
    }).join("").replace(/[^ _0-9a-z]/gi, "");
  }
  return toidentifier;
}
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredHttpErrors;
function requireHttpErrors() {
  if (hasRequiredHttpErrors) return httpErrors.exports;
  hasRequiredHttpErrors = 1;
  (function(module) {
    var deprecate = requireBrowser$1$1()("http-errors");
    var setPrototypeOf = requireSetprototypeof();
    var statuses2 = requireStatuses();
    var inherits2 = requireInherits_browser();
    var toIdentifier = requireToidentifier();
    module.exports = createError;
    module.exports.HttpError = createHttpErrorConstructor();
    module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
    populateConstructorExports(module.exports, statuses2.codes, module.exports.HttpError);
    function codeClass(status) {
      return Number(String(status).charAt(0) + "00");
    }
    function createError() {
      var err;
      var msg;
      var status = 500;
      var props = {};
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        var type2 = typeof arg;
        if (type2 === "object" && arg instanceof Error) {
          err = arg;
          status = err.status || err.statusCode || status;
        } else if (type2 === "number" && i === 0) {
          status = arg;
        } else if (type2 === "string") {
          msg = arg;
        } else if (type2 === "object") {
          props = arg;
        } else {
          throw new TypeError("argument #" + (i + 1) + " unsupported type " + type2);
        }
      }
      if (typeof status === "number" && (status < 400 || status >= 600)) {
        deprecate("non-error status code; use only 4xx or 5xx status codes");
      }
      if (typeof status !== "number" || !statuses2.message[status] && (status < 400 || status >= 600)) {
        status = 500;
      }
      var HttpError = createError[status] || createError[codeClass(status)];
      if (!err) {
        err = HttpError ? new HttpError(msg) : new Error(msg || statuses2.message[status]);
        Error.captureStackTrace(err, createError);
      }
      if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
        err.expose = status < 500;
        err.status = err.statusCode = status;
      }
      for (var key in props) {
        if (key !== "status" && key !== "statusCode") {
          err[key] = props[key];
        }
      }
      return err;
    }
    function createHttpErrorConstructor() {
      function HttpError() {
        throw new TypeError("cannot construct abstract class");
      }
      inherits2(HttpError, Error);
      return HttpError;
    }
    function createClientErrorConstructor(HttpError, name, code) {
      var className = toClassName(name);
      function ClientError(message) {
        var msg = message != null ? message : statuses2.message[code];
        var err = new Error(msg);
        Error.captureStackTrace(err, ClientError);
        setPrototypeOf(err, ClientError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits2(ClientError, HttpError);
      nameFunc(ClientError, className);
      ClientError.prototype.status = code;
      ClientError.prototype.statusCode = code;
      ClientError.prototype.expose = true;
      return ClientError;
    }
    function createIsHttpErrorFunction(HttpError) {
      return function isHttpError(val) {
        if (!val || typeof val !== "object") {
          return false;
        }
        if (val instanceof HttpError) {
          return true;
        }
        return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
      };
    }
    function createServerErrorConstructor(HttpError, name, code) {
      var className = toClassName(name);
      function ServerError(message) {
        var msg = message != null ? message : statuses2.message[code];
        var err = new Error(msg);
        Error.captureStackTrace(err, ServerError);
        setPrototypeOf(err, ServerError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits2(ServerError, HttpError);
      nameFunc(ServerError, className);
      ServerError.prototype.status = code;
      ServerError.prototype.statusCode = code;
      ServerError.prototype.expose = false;
      return ServerError;
    }
    function nameFunc(func, name) {
      var desc = Object.getOwnPropertyDescriptor(func, "name");
      if (desc && desc.configurable) {
        desc.value = name;
        Object.defineProperty(func, "name", desc);
      }
    }
    function populateConstructorExports(exports, codes, HttpError) {
      codes.forEach(function forEachCode(code) {
        var CodeError;
        var name = toIdentifier(statuses2.message[code]);
        switch (codeClass(code)) {
          case 400:
            CodeError = createClientErrorConstructor(HttpError, name, code);
            break;
          case 500:
            CodeError = createServerErrorConstructor(HttpError, name, code);
            break;
        }
        if (CodeError) {
          exports[code] = CodeError;
          exports[name] = CodeError;
        }
      });
    }
    function toClassName(name) {
      return name.substr(-5) !== "Error" ? name + "Error" : name;
    }
  })(httpErrors);
  return httpErrors.exports;
}
var browser$2 = { exports: {} };
var ms$1;
var hasRequiredMs$1;
function requireMs$1() {
  if (hasRequiredMs$1) return ms$1;
  hasRequiredMs$1 = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms$1 = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms$1;
}
var common$2;
var hasRequiredCommon$2;
function requireCommon$2() {
  if (hasRequiredCommon$2) return common$2;
  hasRequiredCommon$2 = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs$1();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index2++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index2];
            match = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend2;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common$2 = setup;
  return common$2;
}
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$2.exports;
  hasRequiredBrowser$2 = 1;
  (function(module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = requireCommon$2()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser$2, browser$2.exports);
  return browser$2.exports;
}
var onFinished = { exports: {} };
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
var eeFirst;
var hasRequiredEeFirst;
function requireEeFirst() {
  if (hasRequiredEeFirst) return eeFirst;
  hasRequiredEeFirst = 1;
  eeFirst = first;
  function first(stuff, done) {
    if (!Array.isArray(stuff))
      throw new TypeError("arg must be an array of [ee, events...] arrays");
    var cleanups = [];
    for (var i = 0; i < stuff.length; i++) {
      var arr = stuff[i];
      if (!Array.isArray(arr) || arr.length < 2)
        throw new TypeError("each array member must be [ee, events...]");
      var ee = arr[0];
      for (var j = 1; j < arr.length; j++) {
        var event = arr[j];
        var fn = listener(event, callback);
        ee.on(event, fn);
        cleanups.push({
          ee,
          event,
          fn
        });
      }
    }
    function callback() {
      cleanup();
      done.apply(null, arguments);
    }
    function cleanup() {
      var x;
      for (var i2 = 0; i2 < cleanups.length; i2++) {
        x = cleanups[i2];
        x.ee.removeListener(x.event, x.fn);
      }
    }
    function thunk(fn2) {
      done = fn2;
    }
    thunk.cancel = cleanup;
    return thunk;
  }
  function listener(event, done) {
    return function onevent(arg1) {
      var args = new Array(arguments.length);
      var ee = this;
      var err = event === "error" ? arg1 : null;
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      done(err, ee, event, args);
    };
  }
  return eeFirst;
}
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredOnFinished;
function requireOnFinished() {
  if (hasRequiredOnFinished) return onFinished.exports;
  hasRequiredOnFinished = 1;
  onFinished.exports = onFinished$1;
  onFinished.exports.isFinished = isFinished;
  var asyncHooks = tryRequireAsyncHooks();
  var first = requireEeFirst();
  var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
    process.nextTick(fn.bind.apply(fn, arguments));
  };
  function onFinished$1(msg, listener) {
    if (isFinished(msg) !== false) {
      defer(listener, null, msg);
      return msg;
    }
    attachListener(msg, wrap(listener));
    return msg;
  }
  function isFinished(msg) {
    var socket = msg.socket;
    if (typeof msg.finished === "boolean") {
      return Boolean(msg.finished || socket && !socket.writable);
    }
    if (typeof msg.complete === "boolean") {
      return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
    }
    return void 0;
  }
  function attachFinishedListener(msg, callback) {
    var eeMsg;
    var eeSocket;
    var finished = false;
    function onFinish(error) {
      eeMsg.cancel();
      eeSocket.cancel();
      finished = true;
      callback(error);
    }
    eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
    function onSocket(socket) {
      msg.removeListener("socket", onSocket);
      if (finished) return;
      if (eeMsg !== eeSocket) return;
      eeSocket = first([[socket, "error", "close"]], onFinish);
    }
    if (msg.socket) {
      onSocket(msg.socket);
      return;
    }
    msg.on("socket", onSocket);
    if (msg.socket === void 0) {
      patchAssignSocket(msg, onSocket);
    }
  }
  function attachListener(msg, listener) {
    var attached = msg.__onFinished;
    if (!attached || !attached.queue) {
      attached = msg.__onFinished = createListener(msg);
      attachFinishedListener(msg, attached);
    }
    attached.queue.push(listener);
  }
  function createListener(msg) {
    function listener(err) {
      if (msg.__onFinished === listener) msg.__onFinished = null;
      if (!listener.queue) return;
      var queue = listener.queue;
      listener.queue = null;
      for (var i = 0; i < queue.length; i++) {
        queue[i](err, msg);
      }
    }
    listener.queue = [];
    return listener;
  }
  function patchAssignSocket(res, callback) {
    var assignSocket = res.assignSocket;
    if (typeof assignSocket !== "function") return;
    res.assignSocket = function _assignSocket(socket) {
      assignSocket.call(this, socket);
      callback(socket);
    };
  }
  function tryRequireAsyncHooks() {
    try {
      return require("async_hooks");
    } catch (e) {
      return {};
    }
  }
  function wrap(fn) {
    var res;
    if (asyncHooks.AsyncResource) {
      res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
    }
    if (!res || !res.runInAsyncScope) {
      return fn;
    }
    return res.runInAsyncScope.bind(res, fn, null);
  }
  return onFinished.exports;
}
var bytes = { exports: {} };
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
var hasRequiredBytes;
function requireBytes() {
  if (hasRequiredBytes) return bytes.exports;
  hasRequiredBytes = 1;
  bytes.exports = bytes$1;
  bytes.exports.format = format;
  bytes.exports.parse = parse2;
  var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
  var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
  var map = {
    b: 1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5)
  };
  var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
  function bytes$1(value, options) {
    if (typeof value === "string") {
      return parse2(value);
    }
    if (typeof value === "number") {
      return format(value, options);
    }
    return null;
  }
  function format(value, options) {
    if (!Number.isFinite(value)) {
      return null;
    }
    var mag = Math.abs(value);
    var thousandsSeparator = options && options.thousandsSeparator || "";
    var unitSeparator = options && options.unitSeparator || "";
    var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
    var fixedDecimals = Boolean(options && options.fixedDecimals);
    var unit = options && options.unit || "";
    if (!unit || !map[unit.toLowerCase()]) {
      if (mag >= map.pb) {
        unit = "PB";
      } else if (mag >= map.tb) {
        unit = "TB";
      } else if (mag >= map.gb) {
        unit = "GB";
      } else if (mag >= map.mb) {
        unit = "MB";
      } else if (mag >= map.kb) {
        unit = "KB";
      } else {
        unit = "B";
      }
    }
    var val = value / map[unit.toLowerCase()];
    var str = val.toFixed(decimalPlaces);
    if (!fixedDecimals) {
      str = str.replace(formatDecimalsRegExp, "$1");
    }
    if (thousandsSeparator) {
      str = str.split(".").map(function(s, i) {
        return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
      }).join(".");
    }
    return str + unitSeparator + unit;
  }
  function parse2(val) {
    if (typeof val === "number" && !isNaN(val)) {
      return val;
    }
    if (typeof val !== "string") {
      return null;
    }
    var results = parseRegExp.exec(val);
    var floatValue;
    var unit = "b";
    if (!results) {
      floatValue = parseInt(val, 10);
      unit = "b";
    } else {
      floatValue = parseFloat(results[1]);
      unit = results[4].toLowerCase();
    }
    if (isNaN(floatValue)) {
      return null;
    }
    return Math.floor(map[unit] * floatValue);
  }
  return bytes.exports;
}
var lib$1$1 = { exports: {} };
var safer_1;
var hasRequiredSafer;
function requireSafer() {
  if (hasRequiredSafer) return safer_1;
  hasRequiredSafer = 1;
  var buffer2 = require$$0$4$1;
  var Buffer2 = buffer2.Buffer;
  var safer = {};
  var key;
  for (key in buffer2) {
    if (!buffer2.hasOwnProperty(key)) continue;
    if (key === "SlowBuffer" || key === "Buffer") continue;
    safer[key] = buffer2[key];
  }
  var Safer = safer.Buffer = {};
  for (key in Buffer2) {
    if (!Buffer2.hasOwnProperty(key)) continue;
    if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
    Safer[key] = Buffer2[key];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding2) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding2 === "string") {
        buf.fill(fill, encoding2);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e) {
    }
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  safer_1 = safer;
  return safer_1;
}
var bomHandling = {};
var hasRequiredBomHandling;
function requireBomHandling() {
  if (hasRequiredBomHandling) return bomHandling;
  hasRequiredBomHandling = 1;
  var BOMChar = "\uFEFF";
  bomHandling.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder2, options) {
    this.encoder = encoder2;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
      str = BOMChar + str;
      this.addBOM = false;
    }
    return this.encoder.write(str);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  bomHandling.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder2, options) {
    this.decoder = decoder2;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
      return res;
    if (res[0] === BOMChar) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === "function")
        this.options.stripBOM();
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
  return bomHandling;
}
var encodings = {};
var internal;
var hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal) return internal;
  hasRequiredInternal = 1;
  var Buffer2 = requireSafer().Buffer;
  internal = {
    // Encodings
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    // Codec.
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = require$$1$1$1.StringDecoder;
  if (!StringDecoder.prototype.end)
    StringDecoder.prototype.end = function() {
    };
  function InternalDecoder(options, codec) {
    this.decoder = new StringDecoder(codec.enc);
  }
  InternalDecoder.prototype.write = function(buf) {
    if (!Buffer2.isBuffer(buf)) {
      buf = Buffer2.from(buf);
    }
    return this.decoder.write(buf);
  };
  InternalDecoder.prototype.end = function() {
    return this.decoder.end();
  };
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str) {
    return Buffer2.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer2.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {
  }
  InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
      var charCode = str.charCodeAt(i);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
    for (var i = 0; i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res += this.defaultCharUnicode;
            else
              res += String.fromCharCode(acc);
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
      res += this.defaultCharUnicode;
    return res;
  };
  return internal;
}
var utf32 = {};
var hasRequiredUtf32;
function requireUtf32() {
  if (hasRequiredUtf32) return utf32;
  hasRequiredUtf32 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf32._utf32 = Utf32Codec;
  function Utf32Codec(codecOptions, iconv) {
    this.iconv = iconv;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
  }
  utf32.utf32le = { type: "_utf32", isLE: true };
  utf32.utf32be = { type: "_utf32", isLE: false };
  utf32.ucs4le = "utf32le";
  utf32.ucs4be = "utf32be";
  Utf32Codec.prototype.encoder = Utf32Encoder;
  Utf32Codec.prototype.decoder = Utf32Decoder;
  function Utf32Encoder(options, codec) {
    this.isLE = codec.isLE;
    this.highSurrogate = 0;
  }
  Utf32Encoder.prototype.write = function(str) {
    var src = Buffer2.from(str, "ucs2");
    var dst = Buffer2.alloc(src.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset = 0;
    for (var i = 0; i < src.length; i += 2) {
      var code = src.readUInt16LE(i);
      var isHighSurrogate = 55296 <= code && code < 56320;
      var isLowSurrogate = 56320 <= code && code < 57344;
      if (this.highSurrogate) {
        if (isHighSurrogate || !isLowSurrogate) {
          write32.call(dst, this.highSurrogate, offset);
          offset += 4;
        } else {
          var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
          write32.call(dst, codepoint, offset);
          offset += 4;
          this.highSurrogate = 0;
          continue;
        }
      }
      if (isHighSurrogate)
        this.highSurrogate = code;
      else {
        write32.call(dst, code, offset);
        offset += 4;
        this.highSurrogate = 0;
      }
    }
    if (offset < dst.length)
      dst = dst.slice(0, offset);
    return dst;
  };
  Utf32Encoder.prototype.end = function() {
    if (!this.highSurrogate)
      return;
    var buf = Buffer2.alloc(4);
    if (this.isLE)
      buf.writeUInt32LE(this.highSurrogate, 0);
    else
      buf.writeUInt32BE(this.highSurrogate, 0);
    this.highSurrogate = 0;
    return buf;
  };
  function Utf32Decoder(options, codec) {
    this.isLE = codec.isLE;
    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = [];
  }
  Utf32Decoder.prototype.write = function(src) {
    if (src.length === 0)
      return "";
    var i = 0;
    var codepoint = 0;
    var dst = Buffer2.alloc(src.length + 4);
    var offset = 0;
    var isLE = this.isLE;
    var overflow = this.overflow;
    var badChar = this.badChar;
    if (overflow.length > 0) {
      for (; i < src.length && overflow.length < 4; i++)
        overflow.push(src[i]);
      if (overflow.length === 4) {
        if (isLE) {
          codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
        } else {
          codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
        }
        overflow.length = 0;
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
    }
    for (; i < src.length - 3; i += 4) {
      if (isLE) {
        codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;
      } else {
        codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;
      }
      offset = _writeCodepoint(dst, offset, codepoint, badChar);
    }
    for (; i < src.length; i++) {
      overflow.push(src[i]);
    }
    return dst.slice(0, offset).toString("ucs2");
  };
  function _writeCodepoint(dst, offset, codepoint, badChar) {
    if (codepoint < 0 || codepoint > 1114111) {
      codepoint = badChar;
    }
    if (codepoint >= 65536) {
      codepoint -= 65536;
      var high = 55296 | codepoint >> 10;
      dst[offset++] = high & 255;
      dst[offset++] = high >> 8;
      var codepoint = 56320 | codepoint & 1023;
    }
    dst[offset++] = codepoint & 255;
    dst[offset++] = codepoint >> 8;
    return offset;
  }
  Utf32Decoder.prototype.end = function() {
    this.overflow.length = 0;
  };
  utf32.utf32 = Utf32AutoCodec;
  utf32.ucs4 = "utf32";
  function Utf32AutoCodec(options, iconv) {
    this.iconv = iconv;
  }
  Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
  Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
  function Utf32AutoEncoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
  }
  Utf32AutoEncoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf32AutoEncoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf32AutoDecoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf32AutoDecoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 32)
        return "";
      var encoding2 = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding2, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf32AutoDecoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding2 = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding2, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var invalidLE = 0, invalidBE = 0;
    var bmpCharsLE = 0, bmpCharsBE = 0;
    outer_loop:
      for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 4) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) {
                return "utf-32le";
              }
              if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) {
                return "utf-32be";
              }
            }
            if (b[0] !== 0 || b[1] > 16) invalidBE++;
            if (b[3] !== 0 || b[2] > 16) invalidLE++;
            if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
            if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be";
    if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le";
    return defaultEncoding || "utf-32le";
  }
  return utf32;
}
var utf16 = {};
var hasRequiredUtf16;
function requireUtf16() {
  if (hasRequiredUtf16) return utf16;
  hasRequiredUtf16 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf16.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer2.from(str, "ucs2");
    for (var i = 0; i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (; i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
    this.overflowByte = -1;
  };
  utf16.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 16)
        return "";
      var encoding2 = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding2, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding2 = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding2, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var asciiCharsLE = 0, asciiCharsBE = 0;
    outer_loop:
      for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 2) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254) return "utf-16le";
              if (b[0] === 254 && b[1] === 255) return "utf-16be";
            }
            if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
            if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (asciiCharsBE > asciiCharsLE) return "utf-16be";
    if (asciiCharsBE < asciiCharsLE) return "utf-16le";
    return defaultEncoding || "utf-16le";
  }
  return utf16;
}
var utf7 = {};
var hasRequiredUtf7;
function requireUtf7() {
  if (hasRequiredUtf7) return utf7;
  hasRequiredUtf7 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf7.utf7 = Utf7Codec;
  utf7.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str) {
    return Buffer2.from(str.replace(nonDirectChars, function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }.bind(this)));
  };
  Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex2 = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex2.test(String.fromCharCode(i));
  var plusChar = "+".charCodeAt(0), minusChar = "-".charCodeAt(0), andChar = "&".charCodeAt(0);
  Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "+";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  utf7.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
    for (var i2 = 0; i2 < str.length; i2++) {
      var uChar = str.charCodeAt(i2);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[",".charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "&";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii").replace(/,/g, "/");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  return utf7;
}
var sbcsCodec = {};
var hasRequiredSbcsCodec;
function requireSbcsCodec() {
  if (hasRequiredSbcsCodec) return sbcsCodec;
  hasRequiredSbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  sbcsCodec._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0; i < 128; i++)
        asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0; i < codecOptions.chars.length; i++)
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length);
    for (var i = 0; i < str.length; i++)
      buf[i] = this.encodeBuf[str.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
  return sbcsCodec;
}
var sbcsData;
var hasRequiredSbcsData;
function requireSbcsData() {
  if (hasRequiredSbcsData) return sbcsData;
  hasRequiredSbcsData = 1;
  sbcsData = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
      "type": "_sbcs",
      "chars": ""
    },
    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
      "type": "_sbcs",
      "chars": ""
    },
    "mik": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp720": {
      "type": "_sbcs",
      "chars": ""
    },
    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",
    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",
    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek": "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",
    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",
    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",
    "cp819": "iso88591",
    "ibm819": "iso88591",
    "cyrillic": "iso88595",
    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",
    "greek": "iso88597",
    "greek8": "iso88597",
    "ecma118": "iso88597",
    "elot928": "iso88597",
    "hebrew": "iso88598",
    "hebrew8": "iso88598",
    "turkish": "iso88599",
    "turkish8": "iso88599",
    "thai": "iso885911",
    "thai8": "iso885911",
    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",
    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",
    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",
    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",
    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",
    "strk10482002": "rk1048",
    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",
    "gb198880": "iso646cn",
    "cn": "iso646cn",
    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",
    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",
    "mac": "macintosh",
    "csmacintosh": "macintosh"
  };
  return sbcsData;
}
var sbcsDataGenerated;
var hasRequiredSbcsDataGenerated;
function requireSbcsDataGenerated() {
  if (hasRequiredSbcsDataGenerated) return sbcsDataGenerated;
  hasRequiredSbcsDataGenerated = 1;
  sbcsDataGenerated = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
      "type": "_sbcs",
      "chars": ""
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28591": "iso88591",
    "iso88592": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28592": "iso88592",
    "iso88593": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28593": "iso88593",
    "iso88594": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28594": "iso88594",
    "iso88595": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28595": "iso88595",
    "iso88596": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28596": "iso88596",
    "iso88597": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28597": "iso88597",
    "iso88598": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28598": "iso88598",
    "iso88599": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28599": "iso88599",
    "iso885910": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28600": "iso885910",
    "iso885911": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28601": "iso885911",
    "iso885913": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28603": "iso885913",
    "iso885914": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28604": "iso885914",
    "iso885915": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28605": "iso885915",
    "iso885916": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28606": "iso885916",
    "cp437": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
      "type": "_sbcs",
      "chars": ""
    },
    "maccyrillic": {
      "type": "_sbcs",
      "chars": ""
    },
    "macgreek": {
      "type": "_sbcs",
      "chars": ""
    },
    "maciceland": {
      "type": "_sbcs",
      "chars": ""
    },
    "macroman": {
      "type": "_sbcs",
      "chars": ""
    },
    "macromania": {
      "type": "_sbcs",
      "chars": ""
    },
    "macthai": {
      "type": "_sbcs",
      "chars": "\uFEFF"
    },
    "macturkish": {
      "type": "_sbcs",
      "chars": ""
    },
    "macukraine": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8r": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8u": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8ru": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8t": {
      "type": "_sbcs",
      "chars": ""
    },
    "armscii8": {
      "type": "_sbcs",
      "chars": ")(.,-"
    },
    "rk1048": {
      "type": "_sbcs",
      "chars": ""
    },
    "tcvn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "georgianacademy": {
      "type": "_sbcs",
      "chars": ""
    },
    "georgianps": {
      "type": "_sbcs",
      "chars": ""
    },
    "pt154": {
      "type": "_sbcs",
      "chars": ""
    },
    "viscii": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "iso646cn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "iso646jp": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "hproman8": {
      "type": "_sbcs",
      "chars": ""
    },
    "macintosh": {
      "type": "_sbcs",
      "chars": ""
    },
    "ascii": {
      "type": "_sbcs",
      "chars": ""
    },
    "tis620": {
      "type": "_sbcs",
      "chars": ""
    }
  };
  return sbcsDataGenerated;
}
var dbcsCodec = {};
var hasRequiredDbcsCodec;
function requireDbcsCodec() {
  if (hasRequiredDbcsCodec) return dbcsCodec;
  hasRequiredDbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  dbcsCodec._dbcs = DBCSCodec;
  var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
  for (var i = 0; i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0; i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var commonThirdByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var commonFourthByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var firstByteNode = this.decodeTables[0];
      for (var i2 = 129; i2 <= 254; i2++) {
        var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i2]];
        for (var j = 48; j <= 57; j++) {
          if (secondByteNode[j] === UNASSIGNED) {
            secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
          } else if (secondByteNode[j] > NODE_START) {
            throw new Error("gb18030 decode tables conflict at byte 2");
          }
          var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
          for (var k = 129; k <= 254; k++) {
            if (thirdByteNode[k] === UNASSIGNED) {
              thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
            } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
              continue;
            } else if (thirdByteNode[k] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 3");
            }
            var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
            for (var l = 48; l <= 57; l++) {
              if (fourthByteNode[l] === UNASSIGNED)
                fourthByteNode[l] = GB18030_CODE;
            }
          }
        }
      }
    }
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j = val.from; j <= val.to; j++)
            skipEncodeChars[j] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes2 = [];
    for (; addr > 0; addr >>>= 8)
      bytes2.push(addr & 255);
    if (bytes2.length == 0)
      bytes2.push(0);
    var node = this.decodeTables[0];
    for (var i2 = bytes2.length - 1; i2 > 0; i2--) {
      var val = node[bytes2[i2]];
      if (val == UNASSIGNED) {
        node[bytes2[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1; k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        for (var l = 0; l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            var len = 4095 - code + 2;
            var seq = [];
            for (var m = 0; m < len; m++)
              seq.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else
            writeTable[curAddr++] = code;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0; l < part; l++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === void 0)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node;
    if (bucket[low] <= SEQ_START) {
      node = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node = {};
      if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node);
    }
    for (var j = 1; j < seq.length - 1; j++) {
      var oldVal = node[uCode];
      if (typeof oldVal === "object")
        node = oldVal;
      else {
        node = node[uCode] = {};
        if (oldVal !== void 0)
          node[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq[seq.length - 1];
    node[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    var hasValues = false;
    var subNodeEmpty = {};
    for (var i2 = 0; i2 < 256; i2++) {
      var uCode = node[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0) {
        this._setEncodeChar(uCode, mbCode);
        hasValues = true;
      } else if (uCode <= NODE_START) {
        var subNodeIdx = NODE_START - uCode;
        if (!subNodeEmpty[subNodeIdx]) {
          var newPrefix = mbCode << 8 >>> 0;
          if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
            hasValues = true;
          else
            subNodeEmpty[subNodeIdx] = true;
        }
      } else if (uCode <= SEQ_START) {
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        hasValues = true;
      }
    }
    return hasValues;
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = void 0;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str.length) break;
        var uCode = str.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== void 0 && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == void 0) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== void 0) {
            dbcsCode = resCode;
            nextChar = uCode;
          }
        }
        seqObj = void 0;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== void 0)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j++] = dbcsCode >> 8;
        newBuf[j++] = dbcsCode & 255;
      } else if (dbcsCode < 16777216) {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      } else {
        newBuf[j++] = dbcsCode >>> 24;
        newBuf[j++] = dbcsCode >>> 16 & 255;
        newBuf[j++] = dbcsCode >>> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === void 0)
      return;
    var newBuf = Buffer2.alloc(10), j = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== void 0) {
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = void 0;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBytes = [];
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBytes = this.prevBytes, prevOffset = this.prevBytes.length, seqStart = -this.prevBytes.length, uCode;
    for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBytes[i2 + prevOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) ;
      else if (uCode === UNASSIGNED) {
        uCode = this.defaultCharUnicode.charCodeAt(0);
        i2 = seqStart;
      } else if (uCode === GB18030_CODE) {
        if (i2 >= 3) {
          var ptr = (buf[i2 - 3] - 129) * 12600 + (buf[i2 - 2] - 48) * 1260 + (buf[i2 - 1] - 129) * 10 + (curByte - 48);
        } else {
          var ptr = (prevBytes[i2 - 3 + prevOffset] - 129) * 12600 + ((i2 - 2 >= 0 ? buf[i2 - 2] : prevBytes[i2 - 2 + prevOffset]) - 48) * 1260 + ((i2 - 1 >= 0 ? buf[i2 - 1] : prevBytes[i2 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
        }
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0; k < seq.length - 1; k++) {
          uCode = seq[k];
          newBuf[j++] = uCode & 255;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode >= 65536) {
        uCode -= 65536;
        var uCodeLead = 55296 | uCode >> 10;
        newBuf[j++] = uCodeLead & 255;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 56320 | uCode & 1023;
      }
      newBuf[j++] = uCode & 255;
      newBuf[j++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
    return newBuf.slice(0, j).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBytes.length > 0) {
      ret += this.defaultCharUnicode;
      var bytesArr = this.prevBytes.slice(1);
      this.prevBytes = [];
      this.nodeIdx = 0;
      if (bytesArr.length > 0)
        ret += this.write(bytesArr);
    }
    this.prevBytes = [];
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    var l = 0, r = table.length;
    while (l < r - 1) {
      var mid = l + (r - l + 1 >> 1);
      if (table[mid] <= val)
        l = mid;
      else
        r = mid;
    }
    return l;
  }
  return dbcsCodec;
}
const require$$0$2 = [
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "",
    62
  ],
  [
    "8140",
    "",
    9,
    ""
  ],
  [
    "8180",
    ""
  ],
  [
    "81b8",
    ""
  ],
  [
    "81c8",
    ""
  ],
  [
    "81da",
    ""
  ],
  [
    "81f0",
    ""
  ],
  [
    "81fc",
    ""
  ],
  [
    "824f",
    "",
    9
  ],
  [
    "8260",
    "",
    25
  ],
  [
    "8281",
    "",
    25
  ],
  [
    "829f",
    "",
    82
  ],
  [
    "8340",
    "",
    62
  ],
  [
    "8380",
    "",
    22
  ],
  [
    "839f",
    "",
    16,
    "",
    6
  ],
  [
    "83bf",
    "",
    16,
    "",
    6
  ],
  [
    "8440",
    "",
    5,
    "",
    25
  ],
  [
    "8470",
    "",
    5,
    "",
    7
  ],
  [
    "8480",
    "",
    17
  ],
  [
    "849f",
    ""
  ],
  [
    "8740",
    "",
    19,
    "",
    9
  ],
  [
    "875f",
    ""
  ],
  [
    "877e",
    ""
  ],
  [
    "8780",
    "",
    4,
    ""
  ],
  [
    "889f",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8980",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a80",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b80",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8c80",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d80",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8e80",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8f80",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "9080",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "9180",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "9280",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "9380",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "9480",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "9580",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "9680",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "9780",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "989f",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "9980",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9a80",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b80",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9c80",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9d80",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9e80",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f80",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e080",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e180",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e280",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e380",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e480",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e580",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e680",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e780",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e880",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e980",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "ea80",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "ed80",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "ee80",
    ""
  ],
  [
    "eeef",
    "",
    9,
    ""
  ],
  [
    "f040",
    "",
    62
  ],
  [
    "f080",
    "",
    124
  ],
  [
    "f140",
    "",
    62
  ],
  [
    "f180",
    "",
    124
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    124
  ],
  [
    "f340",
    "",
    62
  ],
  [
    "f380",
    "",
    124
  ],
  [
    "f440",
    "",
    62
  ],
  [
    "f480",
    "",
    124
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    124
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    124
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    124
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    124
  ],
  [
    "f940",
    ""
  ],
  [
    "fa40",
    "",
    9,
    "",
    9,
    ""
  ],
  [
    "fa80",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fb80",
    ""
  ],
  [
    "fc40",
    ""
  ]
];
const require$$1 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127],["8ea1","",62],["a1a1","",9,""],["a2a1",""],["a2ba",""],["a2ca",""],["a2dc",""],["a2f2",""],["a2fe",""],["a3b0","",9],["a3c1","",25],["a3e1","",25],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a7a1","",5,"",25],["a7d1","",5,"",25],["a8a1",""],["ada1","",19,"",9],["adc0",""],["addf","",4,""],["b0a1",""],["b1a1",""],["b2a1",""],["b3a1",""],["b4a1",""],["b5a1",""],["b6a1",""],["b7a1",""],["b8a1",""],["b9a1",""],["baa1",""],["bba1",""],["bca1",""],["bda1",""],["bea1",""],["bfa1",""],["c0a1",""],["c1a1",""],["c2a1",""],["c3a1",""],["c4a1",""],["c5a1",""],["c6a1",""],["c7a1",""],["c8a1",""],["c9a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1",""],["d2a1",""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fcf1","",9,""],["8fa2af",""],["8fa2c2",""],["8fa2eb",""],["8fa6e1",""],["8fa6e7",""],["8fa6e9",""],["8fa6ec",""],["8fa6f1",""],["8fa7c2","",10,""],["8fa7f2","",10,""],["8fa9a1",""],["8fa9a4",""],["8fa9a6",""],["8fa9a8",""],["8fa9ab",""],["8fa9af",""],["8fa9c1",""],["8faaa1",""],["8faaba",""],["8faba1",""],["8fabbd",""],["8fabc5",""],["8fb0a1",""],["8fb1a1",""],["8fb2a1","",4,""],["8fb3a1",""],["8fb4a1",""],["8fb5a1",""],["8fb6a1","",5,"",4,""],["8fb7a1","",4,""],["8fb8a1",""],["8fb9a1",""],["8fbaa1","",4,""],["8fbba1",""],["8fbca1","",4,""],["8fbda1","",4,""],["8fbea1","",4,""],["8fbfa1",""],["8fc0a1",""],["8fc1a1",""],["8fc2a1",""],["8fc3a1","",4,""],["8fc4a1",""],["8fc5a1",""],["8fc6a1",""],["8fc7a1",""],["8fc8a1",""],["8fc9a1","",4,"",4,""],["8fcaa1",""],["8fcba1",""],["8fcca1","",9,""],["8fcda1","",5,""],["8fcea1","",6,""],["8fcfa1",""],["8fd0a1",""],["8fd1a1",""],["8fd2a1","",5],["8fd3a1",""],["8fd4a1","",4,""],["8fd5a1",""],["8fd6a1",""],["8fd7a1",""],["8fd8a1",""],["8fd9a1","",4,"",6,""],["8fdaa1","",4,""],["8fdba1","",6,""],["8fdca1","",4,""],["8fdda1","",4,""],["8fdea1","",4,""],["8fdfa1",""],["8fe0a1",""],["8fe1a1","",4,""],["8fe2a1",""],["8fe3a1","",5,"",4,""],["8fe4a1","",4,""],["8fe5a1","",4,""],["8fe6a1",""],["8fe7a1",""],["8fe8a1","",4,""],["8fe9a1","",4],["8feaa1","",4,""],["8feba1","",4,""],["8feca1",""],["8feda1","",4,"",4,""]]');
const require$$2 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127,""],["8140","",5,"",9,"",6,""],["8180","",6,"",4,"",4,"",5,""],["8240","",4,"",8,"",4,"",11],["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],["8340","",17,"",5,"",10,"",4,"",9,""],["8380","",5,"",13,"",28,"",4,"",4,"",5],["8440","",5,"",5,""],["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],["8540","",9,""],["8580","",4,"",6,"",4,"",4,"",7,""],["8640","",4,"",5,"",4,"",5,""],["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],["8740","",7,"",11,"",4,"",4],["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],["8840","",9,"",4,"",4,""],["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],["8940","",5,"",6,"",4,"",5,"",4,"",16,""],["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],["8a40","",4,"",12,""],["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],["8b40","",8,"",17,"",6,"",13,""],["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],["8c40","",7,""],["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],["8d40","",5,"",5,"",5,"",6,"",9,"",4],["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],["8e40","",21,"",12,"",6,"",12,""],["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],["8f40","",5,"",11,"",8,""],["8f80","",6,"",14,"",5,"",5,"",4,""],["9040","",4,"",4,"",6,""],["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],["9140","",6,"",6,"",18,"",4,""],["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],["9240","",6,"",5,""],["9280","",5,"",7,"",6,""],["9340","",6,"",4,"",4,"",5,""],["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],["9440","",24,"",7,"",7,"",4,"",8],["9480","",4,"",4,"",14,"",7,"",7,""],["9540","",4,"",4,"",6,""],["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],["9640","",5,"",4,""],["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],["9740","",7,"",8,"",7,"",9,""],["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],["9840","",4,"",5,"",9,""],["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],["9980","",114,"",6],["9a40","",11,"",7,"",13,""],["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],["9b40","",4,""],["9b80","",5,"",4,"",4,"",5,""],["9c40","",7,""],["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],["9d40","",7,"",4,"",9,"",6,""],["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],["9e40","",7,"",32,"",7,"",6,"",6],["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],["9f40","",6,"",10,"",4,"",10,"",7,""],["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],["a040","",9,"",5,"",9,"",11,"",19],["a080","",9,"",6,"",4,"",11,"",11,"",6,""],["a1a1","",7,""],["a2a1","",9],["a2b1","",19,"",19,"",9],["a2e5","",9],["a2f1","",11],["a3a1","",88,""],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a6e0",""],["a6ee",""],["a6f4",""],["a7a1","",5,"",25],["a7d1","",5,"",25],["a840","",35,"",6],["a880","",7,""],["a8a1",""],["a8bd",""],["a8c0",""],["a8c5","",36],["a940","",8,""],["a959",""],["a95c",""],["a960","",9,"",8],["a980","",4,""],["a996",""],["a9a4","",75],["aa40","",5,"",5,"",8],["aa80","",7,"",10,""],["ab40","",11,"",4,"",5,"",4],["ab80","",6,"",4],["ac40","",10,"",8,"",5,"",4,"",11],["ac80","",6,"",12,"",4,""],["ad40","",10,"",7,"",15,"",12],["ad80","",9,"",8,"",6,""],["ae40","",6,"",7,"",4,""],["ae80","",7,"",6,"",4,""],["af40","",4,""],["af80",""],["b040","",6,"",5,"",4,"",6,"",7,""],["b080","",7,"",8,"",9,""],["b140","",4,"",7,"",10,""],["b180","",4,"",7,"",7,""],["b240","",11,"",5,"",11,"",4],["b280","",12,"",8,"",4,""],["b340","",5,""],["b380","",11,"",7,"",6,""],["b440","",7,"",9],["b480","",4,"",5,"",6,""],["b540","",5,"",9,"",4,"",14,"",4,"",8,""],["b580","",6,"",4,""],["b640","",6,"",11,"",10,"",4,"",5,""],["b680","",6,"",4,""],["b740","",14,"",5,"",9,"",4,"",16],["b780","",6,""],["b840","",4,"",10,"",10,"",9,"",5,""],["b880","",4,""],["b940","",5,"",10,"",6,""],["b980","",7,""],["ba40","",4,"",4,"",7,"",5,""],["ba80","",4,"",5,"",12,"",5,""],["bb40","",9,"",36,"",5,"",9],["bb80","",6,"",4,""],["bc40","",6,"",6,"",5,"",7,"",13,"",5],["bc80","",14,"",6,""],["bd40","",54,"",7],["bd80","",32,""],["be40","",12,"",6,"",42],["be80","",32,""],["bf40","",62],["bf80","",4,"",4,"",21,""],["c040","",35,"",23,""],["c080","",6,"",9,""],["c140","",4,"",7,"",4,"",4,"",6,""],["c180","",4,"",4,"",5,""],["c240","",6,"",5,""],["c280","",13,"",5,"",11,""],["c340","",5,"",4,"",6,""],["c380","",12,"",4,""],["c440","",5,"",4,"",4,"",5,"",4,""],["c480","",7,"",5,"",6,""],["c540","",14,"",4,"",5,"",4,"",5,""],["c580","",7,"",7,""],["c640",""],["c680","",4,"",9,""],["c740","",4,"",4,"",6,"",6,"",6,""],["c780",""],["c840","",4,"",5,"",5,"",7,"",5,"",7,""],["c880","",6,"",4,"",4,""],["c940","",4,"",7,"",12,""],["c980","",4,"",4,"",10,""],["ca40","",8,"",8,"",9,"",4,"",10],["ca80","",4,"",8,""],["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],["cb80","",5,"",6,"",14,""],["cc40","",4,"",10,"",15,"",13,""],["cc80","",11,"",4,"",7,""],["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],["cd80",""],["ce40","",6,"",5,"",7,""],["ce80","",4,"",6,"",4,""],["cf40","",4,"",4,"",6,"",9],["cf80","",5,"",7,"",4,""],["d040","",13,"",5,"",5,"",5,"",6,""],["d080","",4,"",4,"",5,""],["d140","",4,"",4,"",6,"",5],["d180","",4,"",4,"",4,""],["d240","",8,"",24,"",5,"",19,""],["d280","",26,""],["d340","",30,"",6],["d380","",4,"",5,"",21,""],["d440","",31,"",8,"",21],["d480","",25,"",6,""],["d540","",7,"",7,"",46],["d580","",32,""],["d640","",34,"",27],["d680","",30,""],["d740","",31,"",4,"",25],["d780","",24,""],["d840","",8,"",7,"",5,"",6,"",6,"",6,""],["d880","",6,"",20,""],["d940","",62],["d980","",32,""],["da40","",14,"",8,"",4,"",9,""],["da80","",12,""],["db40","",6,"",7,"",4,""],["db80","",4,"",5,"",11,""],["dc40","",4,"",6,"",6,"",11,"",6,"",7],["dc80","",10,"",21,""],["dd40","",62],["dd80","",32,""],["de40","",32,""],["de80","",4,""],["df40","",5,"",4,"",4,"",5,"",4,"",6,""],["df80","",4,""],["e040","",19,""],["e080","",10,"",6,"",8,""],["e140","",4,"",6,"",5,"",5,""],["e180","",10,"",9,"",8,""],["e240","",62],["e280","",32,"",5,""],["e340","",45,"",16],["e380","",7,"",24,""],["e440","",5,"",24,"",31],["e480","",32,""],["e540","",51,"",10],["e580","",31,""],["e640","",34,"",27],["e680","",29,""],["e740","",7,"",54],["e780","",32,"",6,"",4,""],["e840","",14,"",43,""],["e880","",20,""],["e940","",7,"",42],["e980","",32,""],["ea40","",27,"",6,""],["ea80","",4,"",12,""],["eb40","",9,"",7,"",9,"",6,""],["eb80","",4,""],["ec40","",8,"",4,"",18,"",7],["ec80","",4,"",7,"",4,"",4,""],["ed40","",6,"",46],["ed80","",4,"",23,""],["ee40","",62],["ee80","",32,"",4,"",6,""],["ef40","",5,"",37,"",4],["ef80","",30,"",4,"",8,""],["f040","",4,"",28,"",26],["f080","",9,"",12,"",4,"",6,""],["f140","",10,"",47],["f180","",32,""],["f240","",62],["f280","",32,""],["f340","",17,"",6,"",4,""],["f380","",8,"",6,""],["f440","",5,"",10,"",10,"",7,"",5],["f480","",32,""],["f540","",62],["f580","",32,""],["f640","",62],["f680","",32,"",5,"",5,"",4,"",7,""],["f740","",62],["f780","",4,"",4,""],["f840","",62],["f880","",32],["f940","",62],["f980","",32],["fa40","",62],["fa80","",32],["fb40","",27,"",9,""],["fb80","",5,"",8,"",5,""],["fc40","",8,"",4,"",8,"",6],["fc80","",4,"",5,"",8,""],["fd40","",4,"",4,"",10,"",38],["fd80","",5,"",11,"",4,""],["fe40",""]]');
const require$$3 = [
  [
    "a140",
    "",
    62
  ],
  [
    "a180",
    "",
    32
  ],
  [
    "a240",
    "",
    62
  ],
  [
    "a280",
    "",
    32
  ],
  [
    "a2ab",
    "",
    5
  ],
  [
    "a2e3",
    ""
  ],
  [
    "a2ef",
    ""
  ],
  [
    "a2fd",
    ""
  ],
  [
    "a340",
    "",
    62
  ],
  [
    "a380",
    "",
    31,
    ""
  ],
  [
    "a440",
    "",
    62
  ],
  [
    "a480",
    "",
    32
  ],
  [
    "a4f4",
    "",
    10
  ],
  [
    "a540",
    "",
    62
  ],
  [
    "a580",
    "",
    32
  ],
  [
    "a5f7",
    "",
    7
  ],
  [
    "a640",
    "",
    62
  ],
  [
    "a680",
    "",
    32
  ],
  [
    "a6b9",
    "",
    7
  ],
  [
    "a6d9",
    "",
    6
  ],
  [
    "a6ec",
    ""
  ],
  [
    "a6f3",
    ""
  ],
  [
    "a6f6",
    "",
    8
  ],
  [
    "a740",
    "",
    62
  ],
  [
    "a780",
    "",
    32
  ],
  [
    "a7c2",
    "",
    14
  ],
  [
    "a7f2",
    "",
    12
  ],
  [
    "a896",
    "",
    10
  ],
  [
    "a8bc",
    ""
  ],
  [
    "a8bf",
    ""
  ],
  [
    "a8c1",
    ""
  ],
  [
    "a8ea",
    "",
    20
  ],
  [
    "a958",
    ""
  ],
  [
    "a95b",
    ""
  ],
  [
    "a95d",
    ""
  ],
  [
    "a989",
    "",
    11
  ],
  [
    "a997",
    "",
    12
  ],
  [
    "a9f0",
    "",
    14
  ],
  [
    "aaa1",
    "",
    93
  ],
  [
    "aba1",
    "",
    93
  ],
  [
    "aca1",
    "",
    93
  ],
  [
    "ada1",
    "",
    93
  ],
  [
    "aea1",
    "",
    93
  ],
  [
    "afa1",
    "",
    93
  ],
  [
    "d7fa",
    "",
    4
  ],
  [
    "f8a1",
    "",
    93
  ],
  [
    "f9a1",
    "",
    93
  ],
  [
    "faa1",
    "",
    93
  ],
  [
    "fba1",
    "",
    93
  ],
  [
    "fca1",
    "",
    93
  ],
  [
    "fda1",
    "",
    93
  ],
  [
    "fe50",
    ""
  ],
  [
    "fe80",
    "",
    6,
    "",
    93
  ],
  [
    "8135f437",
    ""
  ]
];
const uChars = [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536];
const gbChars = [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189e3];
const require$$4 = {
  uChars,
  gbChars
};
const require$$5 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127],["8141","",4,"",6,""],["8161","",9,"",5,""],["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],["8241","",7,"",5],["8261","",6,"",5,""],["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],["8341","",5,"",5,"",7],["8361","",18,""],["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],["8441","",5,"",8],["8461","",18],["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],["8541","",5,"",4,"",6,"",4],["8561","",5,"",5,"",6,""],["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],["8641","",6,"",5,""],["8661","",6,"",10],["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],["8741","",9,"",15],["8761","",18,""],["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],["8841","",4,"",5,"",6,"",4],["8861","",4,""],["8881","",15,"",4,"",6,"",5,"",54,""],["8941","",6,"",5,""],["8961","",10,"",5,""],["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],["8a41","",10,"",6,""],["8a61","",4,"",18,""],["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],["8b41","",5,"",4,"",6,""],["8b61","",6,"",8],["8b81","",52,"",4,"",6,"",5,"",18,"",18],["8c41","",15,"",4],["8c61","",6,"",5,"",6,"",5],["8c81","",12,"",26,"",50,"",5,"",16],["8d41","",16,"",8],["8d61","",17,""],["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],["8e41","",6,"",5,"",8],["8e61","",4,"",19],["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],["8f41","",7,"",17],["8f61","",7,"",6,"",4],["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],["9041","",6,"",5,""],["9061","",5,"",15],["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],["9141","",6,"",5],["9161","",9,"",5],["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],["9241","",7,"",4,""],["9261","",7,"",7,"",4],["9281","",21,"",18,"",6,"",7,"",6,"",35,""],["9341","",4,""],["9361","",6,"",8],["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],["9441","",5,"",5,"",8],["9461","",5,"",6,"",12],["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],["9541","",11,"",5,""],["9561","",6,"",5,""],["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],["9641","",23,""],["9661","",6,"",5,"",8],["9681","",10,"",5,"",13,"",33,"",6,"",44],["9741","",16,"",8],["9761","",17,"",7],["9781","",11,"",5,"",6,"",89,""],["9841","",16,"",5,""],["9861","",6,"",15],["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],["9941","",6,"",5,""],["9961","",6,"",5,""],["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],["9a41","",16],["9a61","",6,"",6,""],["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],["9b41","",6,"",8],["9b61","",17,"",7],["9b81","",25,"",4,"",5,"",50,"",22,""],["9c41","",4,"",5,"",5],["9c61","",8,"",6,"",9],["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],["9d41","",13,"",8],["9d61","",25],["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],["9e41","",7,"",9,""],["9e61","",4,"",6,""],["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],["9f41","",5,"",4,"",5,""],["9f61","",6,"",5,""],["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],["a041","",5,"",6,""],["a061","",5,"",13],["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],["a141","",18,""],["a161","",6,"",5,""],["a181","",14,"",5,"",4,"",9,""],["a241","",5,"",18],["a261","",6,"",18],["a281","",7,"",6,"",7,""],["a341","",6,"",10,""],["a361","",6,"",16],["a381","",16,"",4,"",58,"",32,""],["a441","",5,""],["a461","",5,"",12],["a481","",28,"",93],["a541","",4,"",6,"",5,""],["a561","",17,"",5,""],["a581","",16,"",14,"",9],["a5b0","",9],["a5c1","",16,"",6],["a5e1","",16,"",6],["a641","",19,""],["a661","",5,"",5,"",6],["a681","",6,"",18,"",7],["a741","",4,"",6,"",7],["a761","",22,""],["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],["a841","",10,"",14],["a861","",18,"",6],["a881","",19,"",11,""],["a8a6",""],["a8a8",""],["a8b1","",27,"",25,"",14,""],["a941","",14,"",10],["a961","",18],["a981","",14,"",6,"",27,"",25,"",14,""],["aa41","",6,"",4,""],["aa61","",4,"",5,"",6,""],["aa81","",29,"",82],["ab41","",6,"",5,""],["ab61","",6,"",5,"",5],["ab81","",8,"",6,"",12,"",85],["ac41","",5,"",6,""],["ac61","",11,"",4],["ac81","",28,"",5,"",25],["acd1","",5,"",25],["ad41","",6,"",5,"",7],["ad61","",6,"",10,""],["ad81","",5,"",18,""],["ae41","",5,"",16],["ae61","",5,"",6,"",4],["ae81","",6,"",5,""],["af41","",19],["af61","",13,"",5,""],["af81","",5,"",6,"",5,""],["b041","",5,"",5,"",12],["b061","",5,"",19],["b081","",13,"",6,"",5,"",7,"",4,""],["b141","",6,"",5,""],["b161","",6,"",5,"",11],["b181","",14,"",6,""],["b241","",6,"",5,""],["b261","",18,"",5,""],["b281","",5,"",18,"",6,""],["b341","",19,""],["b361","",5,"",5,"",5],["b381","",5,"",5,"",19,"",4,""],["b441","",5,"",6,"",5],["b461","",6,"",10,""],["b481","",6,"",18,"",4,"",4,""],["b541","",14,"",5],["b561","",5,"",5,"",4],["b581","",6,"",5,"",11,""],["b641","",7,"",17],["b661","",15,""],["b681","",5,"",6,"",5,""],["b741","",13,"",6,""],["b761","",20,""],["b781","",6,"",14,""],["b841","",7,"",17],["b861","",8,"",13],["b881","",5,"",24,"",4,""],["b941","",6,"",5,""],["b961","",14,"",6,""],["b981","",22,"",4,"",4,""],["ba41","",5,"",6,""],["ba61","",5,"",4,"",5],["ba81","",6,"",9,""],["bb41","",4,"",5,"",4,""],["bb61","",6,"",5,""],["bb81","",31,""],["bc41","",17,""],["bc61","",5,"",6,""],["bc81","",4,"",6,"",5,"",5,"",4,""],["bd41","",7,"",7,""],["bd61","",5,"",13],["bd81","",5,"",25,""],["be41","",7,"",14],["be61","",7,"",7,""],["be81","",4,"",4,"",5,"",8,"",6,""],["bf41","",10,"",14],["bf61","",18,""],["bf81","",5,"",7,"",6,"",5,""],["c041","",5,"",6,"",5],["c061","",25],["c081","",6,"",5,"",7,""],["c141","",5,"",6,""],["c161","",19,""],["c181","",31,""],["c241","",4,"",5,""],["c261","",4,"",5,"",6,""],["c281","",5,"",7,"",9,""],["c341","",4],["c361","",4,"",5,"",11],["c381","",5,"",7,"",5,""],["c441","",7,"",7,""],["c461","",5,"",4],["c481","",5,"",11,""],["c541","",6,"",5,""],["c561","",6,"",5,"",4],["c581","",6,"",5,""],["c641","",6,"",5],["c6a1",""],["c7a1",""],["c8a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1","",5,"",4,""],["d2a1","",4,"",5,"",10,"",7,"",5,""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f5a1",""],["f6a1",""],["f7a1",""],["f8a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fda1",""]]');
const require$$6 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127],["a140",""],["a1a1","",4,""],["a240","",7,""],["a2a1","",9,"",9,"",8,"",25,"",21],["a340","",16,"",6,"",16,"",6,"",10],["a3a1","",25,""],["a3e1",""],["a440",""],["a4a1",""],["a540",""],["a5a1",""],["a640",""],["a6a1",""],["a740",""],["a7a1",""],["a840",""],["a8a1",""],["a940",""],["a9a1",""],["aa40",""],["aaa1",""],["ab40",""],["aba1",""],["ac40",""],["aca1",""],["ad40",""],["ada1",""],["ae40",""],["aea1",""],["af40",""],["afa1",""],["b040",""],["b0a1",""],["b140",""],["b1a1",""],["b240",""],["b2a1",""],["b340",""],["b3a1",""],["b440",""],["b4a1",""],["b540",""],["b5a1",""],["b640",""],["b6a1",""],["b740",""],["b7a1",""],["b840",""],["b8a1",""],["b940",""],["b9a1",""],["ba40",""],["baa1",""],["bb40",""],["bba1",""],["bc40",""],["bca1",""],["bd40",""],["bda1",""],["be40",""],["bea1",""],["bf40",""],["bfa1",""],["c040",""],["c0a1",""],["c140",""],["c1a1",""],["c240",""],["c2a1",""],["c340",""],["c3a1",""],["c440",""],["c4a1",""],["c540",""],["c5a1",""],["c640",""],["c940",""],["c9a1",""],["ca40",""],["caa1",""],["cb40",""],["cba1",""],["cc40",""],["cca1",""],["cd40",""],["cda1",""],["ce40",""],["cea1",""],["cf40",""],["cfa1",""],["d040",""],["d0a1",""],["d140",""],["d1a1",""],["d240",""],["d2a1",""],["d340",""],["d3a1",""],["d440",""],["d4a1",""],["d540",""],["d5a1",""],["d640",""],["d6a1",""],["d740",""],["d7a1",""],["d840",""],["d8a1",""],["d940",""],["d9a1",""],["da40",""],["daa1",""],["db40",""],["dba1",""],["dc40",""],["dca1",""],["dd40",""],["dda1",""],["de40",""],["dea1",""],["df40",""],["dfa1",""],["e040",""],["e0a1",""],["e140",""],["e1a1",""],["e240",""],["e2a1",""],["e340",""],["e3a1",""],["e440",""],["e4a1",""],["e540",""],["e5a1",""],["e640",""],["e6a1",""],["e740",""],["e7a1",""],["e840",""],["e8a1",""],["e940",""],["e9a1",""],["ea40",""],["eaa1",""],["eb40",""],["eba1",""],["ec40",""],["eca1",""],["ed40",""],["eda1",""],["ee40",""],["eea1",""],["ef40",""],["efa1",""],["f040",""],["f0a1",""],["f140",""],["f1a1",""],["f240",""],["f2a1",""],["f340",""],["f3a1",""],["f440",""],["f4a1",""],["f540",""],["f5a1",""],["f640",""],["f6a1",""],["f740",""],["f7a1",""],["f840",""],["f8a1",""],["f940",""],["f9a1",""]]');
const require$$7 = [
  [
    "8740",
    ""
  ],
  [
    "8767",
    ""
  ],
  [
    "87a1",
    ""
  ],
  [
    "8840",
    "",
    4,
    ""
  ],
  [
    "88a1",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8943",
    ""
  ],
  [
    "8946",
    ""
  ],
  [
    "894c",
    ""
  ],
  [
    "89a1",
    ""
  ],
  [
    "89ab",
    ""
  ],
  [
    "89b0",
    ""
  ],
  [
    "89b5",
    ""
  ],
  [
    "89c1",
    ""
  ],
  [
    "89c5",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a43",
    ""
  ],
  [
    "8a64",
    ""
  ],
  [
    "8a76",
    ""
  ],
  [
    "8aa1",
    ""
  ],
  [
    "8aac",
    ""
  ],
  [
    "8ab2",
    ""
  ],
  [
    "8abb",
    ""
  ],
  [
    "8ac9",
    ""
  ],
  [
    "8ace",
    ""
  ],
  [
    "8adf",
    ""
  ],
  [
    "8af6",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b55",
    ""
  ],
  [
    "8ba1",
    ""
  ],
  [
    "8bde",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8ca1",
    ""
  ],
  [
    "8ca7",
    ""
  ],
  [
    "8cc9",
    ""
  ],
  [
    "8cce",
    ""
  ],
  [
    "8ce6",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d42",
    ""
  ],
  [
    "8da1",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8ea1",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8fa1",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "90a1",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "91a1",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "92a1",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "93a1",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "94a1",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "95a1",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "96a1",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "97a1",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "98a1",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "99a1",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9aa1",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b62",
    ""
  ],
  [
    "9ba1",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9ca1",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9da1",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9ea1",
    ""
  ],
  [
    "9ead",
    ""
  ],
  [
    "9ec5",
    ""
  ],
  [
    "9ef5",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f4f",
    ""
  ],
  [
    "9fa1",
    ""
  ],
  [
    "9fae",
    ""
  ],
  [
    "9fb2",
    ""
  ],
  [
    "9fc1",
    ""
  ],
  [
    "9fc9",
    ""
  ],
  [
    "9fdb",
    ""
  ],
  [
    "9fe7",
    ""
  ],
  [
    "9feb",
    ""
  ],
  [
    "9ff0",
    ""
  ],
  [
    "a040",
    ""
  ],
  [
    "a055",
    ""
  ],
  [
    "a058",
    ""
  ],
  [
    "a05b",
    ""
  ],
  [
    "a063",
    ""
  ],
  [
    "a073",
    ""
  ],
  [
    "a0a1",
    ""
  ],
  [
    "a0a6",
    ""
  ],
  [
    "a0ae",
    ""
  ],
  [
    "a0b0",
    ""
  ],
  [
    "a0d4",
    ""
  ],
  [
    "a0e2",
    ""
  ],
  [
    "a3c0",
    "",
    31,
    ""
  ],
  [
    "c6a1",
    "",
    9,
    "",
    9,
    "",
    9,
    "",
    23
  ],
  [
    "c740",
    "",
    58,
    ""
  ],
  [
    "c7a1",
    "",
    81,
    "",
    5,
    "",
    4
  ],
  [
    "c840",
    "",
    26,
    "",
    25,
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c8cd",
    ""
  ],
  [
    "c8f5",
    ""
  ],
  [
    "f9fe",
    ""
  ],
  [
    "fa40",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fc40",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fd40",
    ""
  ],
  [
    "fda1",
    ""
  ],
  [
    "fe40",
    ""
  ],
  [
    "fea1",
    ""
  ]
];
var dbcsData;
var hasRequiredDbcsData;
function requireDbcsData() {
  if (hasRequiredDbcsData) return dbcsData;
  hasRequiredDbcsData = 1;
  dbcsData = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    "shiftjis": {
      type: "_dbcs",
      table: function() {
        return require$$0$2;
      },
      encodeAdd: { "": 92, "": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    "csshiftjis": "shiftjis",
    "mskanji": "shiftjis",
    "sjis": "shiftjis",
    "windows31j": "shiftjis",
    "ms31j": "shiftjis",
    "xsjis": "shiftjis",
    "windows932": "shiftjis",
    "ms932": "shiftjis",
    "932": "shiftjis",
    "cp932": "shiftjis",
    "eucjp": {
      type: "_dbcs",
      table: function() {
        return require$$1;
      },
      encodeAdd: { "": 92, "": 126 }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    "gb2312": "cp936",
    "gb231280": "cp936",
    "gb23121980": "cp936",
    "csgb2312": "cp936",
    "csiso58gb231280": "cp936",
    "euccn": "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    "windows936": "cp936",
    "ms936": "cp936",
    "936": "cp936",
    "cp936": {
      type: "_dbcs",
      table: function() {
        return require$$2;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    "gbk": {
      type: "_dbcs",
      table: function() {
        return require$$2.concat(require$$3);
      }
    },
    "xgbk": "gbk",
    "isoir58": "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    "gb18030": {
      type: "_dbcs",
      table: function() {
        return require$$2.concat(require$$3);
      },
      gb18030: function() {
        return require$$4;
      },
      encodeSkipVals: [128],
      encodeAdd: { "": 41699 }
    },
    "chinese": "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    "windows949": "cp949",
    "ms949": "cp949",
    "949": "cp949",
    "cp949": {
      type: "_dbcs",
      table: function() {
        return require$$5;
      }
    },
    "cseuckr": "cp949",
    "csksc56011987": "cp949",
    "euckr": "cp949",
    "isoir149": "cp949",
    "korean": "cp949",
    "ksc56011987": "cp949",
    "ksc56011989": "cp949",
    "ksc5601": "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    "windows950": "cp950",
    "ms950": "cp950",
    "950": "cp950",
    "cp950": {
      type: "_dbcs",
      table: function() {
        return require$$6;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    "big5": "big5hkscs",
    "big5hkscs": {
      type: "_dbcs",
      table: function() {
        return require$$6.concat(require$$7);
      },
      encodeSkipVals: [
        // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
        // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
        // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
        36457,
        36463,
        36478,
        36523,
        36532,
        36557,
        36560,
        36695,
        36713,
        36718,
        36811,
        36862,
        36973,
        36986,
        37060,
        37084,
        37105,
        37311,
        37551,
        37552,
        37553,
        37554,
        37585,
        37959,
        38090,
        38361,
        38652,
        39285,
        39798,
        39800,
        39803,
        39878,
        39902,
        39916,
        39926,
        40002,
        40019,
        40034,
        40040,
        40043,
        40055,
        40124,
        40125,
        40144,
        40279,
        40282,
        40388,
        40431,
        40443,
        40617,
        40687,
        40701,
        40800,
        40907,
        41079,
        41180,
        41183,
        36812,
        37576,
        38468,
        38637,
        // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
        41636,
        41637,
        41639,
        41638,
        41676,
        41678
      ]
    },
    "cnbig5": "big5hkscs",
    "csbig5": "big5hkscs",
    "xxbig5": "big5hkscs"
  };
  return dbcsData;
}
var hasRequiredEncodings;
function requireEncodings() {
  if (hasRequiredEncodings) return encodings;
  hasRequiredEncodings = 1;
  (function(exports) {
    var modules = [
      requireInternal(),
      requireUtf32(),
      requireUtf16(),
      requireUtf7(),
      requireSbcsCodec(),
      requireSbcsData(),
      requireSbcsDataGenerated(),
      requireDbcsCodec(),
      requireDbcsData()
    ];
    for (var i = 0; i < modules.length; i++) {
      var module = modules[i];
      for (var enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
          exports[enc] = module[enc];
    }
  })(encodings);
  return encodings;
}
var streams;
var hasRequiredStreams;
function requireStreams() {
  if (hasRequiredStreams) return streams;
  hasRequiredStreams = 1;
  var Buffer2 = requireSafer().Buffer;
  streams = function(stream_module) {
    var Transform = stream_module.Transform;
    function IconvLiteEncoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.decodeStrings = false;
      Transform.call(this, options);
    }
    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteEncoderStream }
    });
    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding2, done) {
      if (typeof chunk != "string")
        return done(new Error("Iconv encoding stream needs strings as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype.collect = function(cb) {
      var chunks = [];
      this.on("error", cb);
      this.on("data", function(chunk) {
        chunks.push(chunk);
      });
      this.on("end", function() {
        cb(null, Buffer2.concat(chunks));
      });
      return this;
    };
    function IconvLiteDecoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.encoding = this.encoding = "utf8";
      Transform.call(this, options);
    }
    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteDecoderStream }
    });
    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding2, done) {
      if (!Buffer2.isBuffer(chunk) && !(chunk instanceof Uint8Array))
        return done(new Error("Iconv decoding stream needs buffers as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype.collect = function(cb) {
      var res = "";
      this.on("error", cb);
      this.on("data", function(chunk) {
        res += chunk;
      });
      this.on("end", function() {
        cb(null, res);
      });
      return this;
    };
    return {
      IconvLiteEncoderStream,
      IconvLiteDecoderStream
    };
  };
  return streams;
}
var hasRequiredLib$1$1;
function requireLib$1$1() {
  if (hasRequiredLib$1$1) return lib$1$1.exports;
  hasRequiredLib$1$1 = 1;
  (function(module) {
    var Buffer2 = requireSafer().Buffer;
    var bomHandling2 = requireBomHandling(), iconv = module.exports;
    iconv.encodings = null;
    iconv.defaultCharUnicode = "";
    iconv.defaultCharSingleByte = "?";
    iconv.encode = function encode2(str, encoding2, options) {
      str = "" + (str || "");
      var encoder2 = iconv.getEncoder(encoding2, options);
      var res = encoder2.write(str);
      var trail = encoder2.end();
      return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
    };
    iconv.decode = function decode(buf, encoding2, options) {
      if (typeof buf === "string") {
        if (!iconv.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer2.from("" + (buf || ""), "binary");
      }
      var decoder2 = iconv.getDecoder(encoding2, options);
      var res = decoder2.write(buf);
      var trail = decoder2.end();
      return trail ? res + trail : res;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding2) {
      if (!iconv.encodings)
        iconv.encodings = requireEncodings();
      var enc = iconv._canonicalizeEncoding(encoding2);
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key in codecDef)
              codecOptions[key] = codecDef[key];
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding2 + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function(encoding2) {
      return ("" + encoding2).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding2, options) {
      var codec = iconv.getCodec(encoding2), encoder2 = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM)
        encoder2 = new bomHandling2.PrependBOM(encoder2, options);
      return encoder2;
    };
    iconv.getDecoder = function getDecoder(encoding2, options) {
      var codec = iconv.getCodec(encoding2), decoder2 = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false))
        decoder2 = new bomHandling2.StripBOM(decoder2, options);
      return decoder2;
    };
    iconv.enableStreamingAPI = function enableStreamingAPI(stream_module2) {
      if (iconv.supportsStreams)
        return;
      var streams2 = requireStreams()(stream_module2);
      iconv.IconvLiteEncoderStream = streams2.IconvLiteEncoderStream;
      iconv.IconvLiteDecoderStream = streams2.IconvLiteDecoderStream;
      iconv.encodeStream = function encodeStream(encoding2, options) {
        return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding2, options), options);
      };
      iconv.decodeStream = function decodeStream(encoding2, options) {
        return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding2, options), options);
      };
      iconv.supportsStreams = true;
    };
    var stream_module;
    try {
      stream_module = require("stream");
    } catch (e) {
    }
    if (stream_module && stream_module.Transform) {
      iconv.enableStreamingAPI(stream_module);
    } else {
      iconv.encodeStream = iconv.decodeStream = function() {
        throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
      };
    }
  })(lib$1$1);
  return lib$1$1.exports;
}
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var unpipe_1;
var hasRequiredUnpipe;
function requireUnpipe() {
  if (hasRequiredUnpipe) return unpipe_1;
  hasRequiredUnpipe = 1;
  unpipe_1 = unpipe;
  function hasPipeDataListeners(stream2) {
    var listeners = stream2.listeners("data");
    for (var i = 0; i < listeners.length; i++) {
      if (listeners[i].name === "ondata") {
        return true;
      }
    }
    return false;
  }
  function unpipe(stream2) {
    if (!stream2) {
      throw new TypeError("argument stream is required");
    }
    if (typeof stream2.unpipe === "function") {
      stream2.unpipe();
      return;
    }
    if (!hasPipeDataListeners(stream2)) {
      return;
    }
    var listener;
    var listeners = stream2.listeners("close");
    for (var i = 0; i < listeners.length; i++) {
      listener = listeners[i];
      if (listener.name !== "cleanup" && listener.name !== "onclose") {
        continue;
      }
      listener.call(stream2);
    }
  }
  return unpipe_1;
}
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var rawBody;
var hasRequiredRawBody;
function requireRawBody() {
  if (hasRequiredRawBody) return rawBody;
  hasRequiredRawBody = 1;
  var asyncHooks = tryRequireAsyncHooks();
  var bytes2 = requireBytes();
  var createError = requireHttpErrors();
  var iconv = requireLib$1$1();
  var unpipe = requireUnpipe();
  rawBody = getRawBody;
  var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
  function getDecoder(encoding2) {
    if (!encoding2) return null;
    try {
      return iconv.getDecoder(encoding2);
    } catch (e) {
      if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e;
      throw createError(415, "specified encoding unsupported", {
        encoding: encoding2,
        type: "encoding.unsupported"
      });
    }
  }
  function getRawBody(stream2, options, callback) {
    var done = callback;
    var opts = options || {};
    if (stream2 === void 0) {
      throw new TypeError("argument stream is required");
    } else if (typeof stream2 !== "object" || stream2 === null || typeof stream2.on !== "function") {
      throw new TypeError("argument stream must be a stream");
    }
    if (options === true || typeof options === "string") {
      opts = {
        encoding: options
      };
    }
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    if (done !== void 0 && typeof done !== "function") {
      throw new TypeError("argument callback must be a function");
    }
    if (!done && !commonjsGlobal.Promise) {
      throw new TypeError("argument callback is required");
    }
    var encoding2 = opts.encoding !== true ? opts.encoding : "utf-8";
    var limit = bytes2.parse(opts.limit);
    var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
    if (done) {
      return readStream2(stream2, encoding2, length, limit, wrap(done));
    }
    return new Promise(function executor(resolve, reject) {
      readStream2(stream2, encoding2, length, limit, function onRead(err, buf) {
        if (err) return reject(err);
        resolve(buf);
      });
    });
  }
  function halt(stream2) {
    unpipe(stream2);
    if (typeof stream2.pause === "function") {
      stream2.pause();
    }
  }
  function readStream2(stream2, encoding2, length, limit, callback) {
    var complete = false;
    var sync = true;
    if (limit !== null && length !== null && length > limit) {
      return done(createError(413, "request entity too large", {
        expected: length,
        length,
        limit,
        type: "entity.too.large"
      }));
    }
    var state = stream2._readableState;
    if (stream2._decoder || state && (state.encoding || state.decoder)) {
      return done(createError(500, "stream encoding should not be set", {
        type: "stream.encoding.set"
      }));
    }
    if (typeof stream2.readable !== "undefined" && !stream2.readable) {
      return done(createError(500, "stream is not readable", {
        type: "stream.not.readable"
      }));
    }
    var received = 0;
    var decoder2;
    try {
      decoder2 = getDecoder(encoding2);
    } catch (err) {
      return done(err);
    }
    var buffer2 = decoder2 ? "" : [];
    stream2.on("aborted", onAborted);
    stream2.on("close", cleanup);
    stream2.on("data", onData);
    stream2.on("end", onEnd);
    stream2.on("error", onEnd);
    sync = false;
    function done() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      complete = true;
      if (sync) {
        process.nextTick(invokeCallback);
      } else {
        invokeCallback();
      }
      function invokeCallback() {
        cleanup();
        if (args[0]) {
          halt(stream2);
        }
        callback.apply(null, args);
      }
    }
    function onAborted() {
      if (complete) return;
      done(createError(400, "request aborted", {
        code: "ECONNABORTED",
        expected: length,
        length,
        received,
        type: "request.aborted"
      }));
    }
    function onData(chunk) {
      if (complete) return;
      received += chunk.length;
      if (limit !== null && received > limit) {
        done(createError(413, "request entity too large", {
          limit,
          received,
          type: "entity.too.large"
        }));
      } else if (decoder2) {
        buffer2 += decoder2.write(chunk);
      } else {
        buffer2.push(chunk);
      }
    }
    function onEnd(err) {
      if (complete) return;
      if (err) return done(err);
      if (length !== null && received !== length) {
        done(createError(400, "request size did not match content length", {
          expected: length,
          length,
          received,
          type: "request.size.invalid"
        }));
      } else {
        var string = decoder2 ? buffer2 + (decoder2.end() || "") : Buffer.concat(buffer2);
        done(null, string);
      }
    }
    function cleanup() {
      buffer2 = null;
      stream2.removeListener("aborted", onAborted);
      stream2.removeListener("data", onData);
      stream2.removeListener("end", onEnd);
      stream2.removeListener("error", onEnd);
      stream2.removeListener("close", cleanup);
    }
  }
  function tryRequireAsyncHooks() {
    try {
      return require("async_hooks");
    } catch (e) {
      return {};
    }
  }
  function wrap(fn) {
    var res;
    if (asyncHooks.AsyncResource) {
      res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
    }
    if (!res || !res.runInAsyncScope) {
      return fn;
    }
    return res.runInAsyncScope.bind(res, fn, null);
  }
  return rawBody;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var read_1;
var hasRequiredRead;
function requireRead() {
  if (hasRequiredRead) return read_1;
  hasRequiredRead = 1;
  var createError = requireHttpErrors();
  var getBody = requireRawBody();
  var iconv = requireLib$1$1();
  var onFinished2 = requireOnFinished();
  var zlib2 = require$$4$1;
  read_1 = read;
  function read(req, res, next, parse2, debug2, options) {
    var length;
    var opts = options;
    var stream2;
    var encoding2 = opts.encoding !== null ? opts.encoding : null;
    var verify = opts.verify;
    try {
      stream2 = contentstream(req, debug2, opts.inflate);
      length = stream2.length;
      stream2.length = void 0;
    } catch (err) {
      return next(err);
    }
    opts.length = length;
    opts.encoding = verify ? null : encoding2;
    if (opts.encoding === null && encoding2 !== null && !iconv.encodingExists(encoding2)) {
      return next(createError(415, 'unsupported charset "' + encoding2.toUpperCase() + '"', {
        charset: encoding2.toLowerCase(),
        type: "charset.unsupported"
      }));
    }
    debug2("read body");
    getBody(stream2, opts, function(error, body) {
      if (error) {
        var _error;
        if (error.type === "encoding.unsupported") {
          _error = createError(415, 'unsupported charset "' + encoding2.toUpperCase() + '"', {
            charset: encoding2.toLowerCase(),
            type: "charset.unsupported"
          });
        } else {
          _error = createError(400, error);
        }
        if (stream2 !== req) {
          req.unpipe();
          stream2.destroy();
        }
        dump(req, function onfinished() {
          next(createError(400, _error));
        });
        return;
      }
      if (verify) {
        try {
          debug2("verify body");
          verify(req, res, body, encoding2);
        } catch (err) {
          next(createError(403, err, {
            body,
            type: err.type || "entity.verify.failed"
          }));
          return;
        }
      }
      var str = body;
      try {
        debug2("parse body");
        str = typeof body !== "string" && encoding2 !== null ? iconv.decode(body, encoding2) : body;
        req.body = parse2(str, encoding2);
      } catch (err) {
        next(createError(400, err, {
          body: str,
          type: err.type || "entity.parse.failed"
        }));
        return;
      }
      next();
    });
  }
  function contentstream(req, debug2, inflate) {
    var encoding2 = (req.headers["content-encoding"] || "identity").toLowerCase();
    var length = req.headers["content-length"];
    debug2('content-encoding "%s"', encoding2);
    if (inflate === false && encoding2 !== "identity") {
      throw createError(415, "content encoding unsupported", {
        encoding: encoding2,
        type: "encoding.unsupported"
      });
    }
    if (encoding2 === "identity") {
      req.length = length;
      return req;
    }
    var stream2 = createDecompressionStream(encoding2, debug2);
    req.pipe(stream2);
    return stream2;
  }
  function createDecompressionStream(encoding2, debug2) {
    switch (encoding2) {
      case "deflate":
        debug2("inflate body");
        return zlib2.createInflate();
      case "gzip":
        debug2("gunzip body");
        return zlib2.createGunzip();
      case "br":
        debug2("brotli decompress body");
        return zlib2.createBrotliDecompress();
      default:
        throw createError(415, 'unsupported content encoding "' + encoding2 + '"', {
          encoding: encoding2,
          type: "encoding.unsupported"
        });
    }
  }
  function dump(req, callback) {
    if (onFinished2.isFinished(req)) {
      callback(null);
    } else {
      onFinished2(req, callback);
      req.resume();
    }
  }
  return read_1;
}
var typeIs = { exports: {} };
var contentType = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredContentType;
function requireContentType() {
  if (hasRequiredContentType) return contentType;
  hasRequiredContentType = 1;
  var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
  var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
  var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
  var QUOTE_REGEXP = /([\\"])/g;
  var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  contentType.format = format;
  contentType.parse = parse2;
  function format(obj) {
    if (!obj || typeof obj !== "object") {
      throw new TypeError("argument obj is required");
    }
    var parameters = obj.parameters;
    var type2 = obj.type;
    if (!type2 || !TYPE_REGEXP.test(type2)) {
      throw new TypeError("invalid type");
    }
    var string = type2;
    if (parameters && typeof parameters === "object") {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0; i < params.length; i++) {
        param = params[i];
        if (!TOKEN_REGEXP.test(param)) {
          throw new TypeError("invalid parameter name");
        }
        string += "; " + param + "=" + qstring(parameters[param]);
      }
    }
    return string;
  }
  function parse2(string) {
    if (!string) {
      throw new TypeError("argument string is required");
    }
    var header = typeof string === "object" ? getcontenttype(string) : string;
    if (typeof header !== "string") {
      throw new TypeError("argument string is required to be a string");
    }
    var index2 = header.indexOf(";");
    var type2 = index2 !== -1 ? header.slice(0, index2).trim() : header.trim();
    if (!TYPE_REGEXP.test(type2)) {
      throw new TypeError("invalid media type");
    }
    var obj = new ContentType(type2.toLowerCase());
    if (index2 !== -1) {
      var key;
      var match;
      var value;
      PARAM_REGEXP.lastIndex = index2;
      while (match = PARAM_REGEXP.exec(header)) {
        if (match.index !== index2) {
          throw new TypeError("invalid parameter format");
        }
        index2 += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value.charCodeAt(0) === 34) {
          value = value.slice(1, -1);
          if (value.indexOf("\\") !== -1) {
            value = value.replace(QESC_REGEXP, "$1");
          }
        }
        obj.parameters[key] = value;
      }
      if (index2 !== header.length) {
        throw new TypeError("invalid parameter format");
      }
    }
    return obj;
  }
  function getcontenttype(obj) {
    var header;
    if (typeof obj.getHeader === "function") {
      header = obj.getHeader("content-type");
    } else if (typeof obj.headers === "object") {
      header = obj.headers && obj.headers["content-type"];
    }
    if (typeof header !== "string") {
      throw new TypeError("content-type header is missing from object");
    }
    return header;
  }
  function qstring(val) {
    var str = String(val);
    if (TOKEN_REGEXP.test(str)) {
      return str;
    }
    if (str.length > 0 && !TEXT_REGEXP.test(str)) {
      throw new TypeError("invalid parameter value");
    }
    return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
  }
  function ContentType(type2) {
    this.parameters = /* @__PURE__ */ Object.create(null);
    this.type = type2;
  }
  return contentType;
}
var mimeTypes = {};
const require$$0$1 = {
  "application/1d-interleaved-parityfec": { "source": "iana" },
  "application/3gpdash-qoe-report+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/3gpp-ims+xml": { "source": "iana", "compressible": true },
  "application/3gpphal+json": { "source": "iana", "compressible": true },
  "application/3gpphalforms+json": { "source": "iana", "compressible": true },
  "application/a2l": { "source": "iana" },
  "application/ace+cbor": { "source": "iana" },
  "application/ace+json": { "source": "iana", "compressible": true },
  "application/ace-groupcomm+cbor": { "source": "iana" },
  "application/ace-trl+cbor": { "source": "iana" },
  "application/activemessage": { "source": "iana" },
  "application/activity+json": { "source": "iana", "compressible": true },
  "application/aif+cbor": { "source": "iana" },
  "application/aif+json": { "source": "iana", "compressible": true },
  "application/alto-cdni+json": { "source": "iana", "compressible": true },
  "application/alto-cdnifilter+json": { "source": "iana", "compressible": true },
  "application/alto-costmap+json": { "source": "iana", "compressible": true },
  "application/alto-costmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-directory+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcost+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcostparams+json": { "source": "iana", "compressible": true },
  "application/alto-endpointprop+json": { "source": "iana", "compressible": true },
  "application/alto-endpointpropparams+json": { "source": "iana", "compressible": true },
  "application/alto-error+json": { "source": "iana", "compressible": true },
  "application/alto-networkmap+json": { "source": "iana", "compressible": true },
  "application/alto-networkmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-propmap+json": { "source": "iana", "compressible": true },
  "application/alto-propmapparams+json": { "source": "iana", "compressible": true },
  "application/alto-tips+json": { "source": "iana", "compressible": true },
  "application/alto-tipsparams+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamcontrol+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamparams+json": { "source": "iana", "compressible": true },
  "application/aml": { "source": "iana" },
  "application/andrew-inset": { "source": "iana", "extensions": ["ez"] },
  "application/appinstaller": { "compressible": false, "extensions": ["appinstaller"] },
  "application/applefile": { "source": "iana" },
  "application/applixware": { "source": "apache", "extensions": ["aw"] },
  "application/appx": { "compressible": false, "extensions": ["appx"] },
  "application/appxbundle": { "compressible": false, "extensions": ["appxbundle"] },
  "application/at+jwt": { "source": "iana" },
  "application/atf": { "source": "iana" },
  "application/atfx": { "source": "iana" },
  "application/atom+xml": { "source": "iana", "compressible": true, "extensions": ["atom"] },
  "application/atomcat+xml": { "source": "iana", "compressible": true, "extensions": ["atomcat"] },
  "application/atomdeleted+xml": { "source": "iana", "compressible": true, "extensions": ["atomdeleted"] },
  "application/atomicmail": { "source": "iana" },
  "application/atomsvc+xml": { "source": "iana", "compressible": true, "extensions": ["atomsvc"] },
  "application/atsc-dwd+xml": { "source": "iana", "compressible": true, "extensions": ["dwd"] },
  "application/atsc-dynamic-event-message": { "source": "iana" },
  "application/atsc-held+xml": { "source": "iana", "compressible": true, "extensions": ["held"] },
  "application/atsc-rdt+json": { "source": "iana", "compressible": true },
  "application/atsc-rsat+xml": { "source": "iana", "compressible": true, "extensions": ["rsat"] },
  "application/atxml": { "source": "iana" },
  "application/auth-policy+xml": { "source": "iana", "compressible": true },
  "application/automationml-aml+xml": { "source": "iana", "compressible": true, "extensions": ["aml"] },
  "application/automationml-amlx+zip": { "source": "iana", "compressible": false, "extensions": ["amlx"] },
  "application/bacnet-xdd+zip": { "source": "iana", "compressible": false },
  "application/batch-smtp": { "source": "iana" },
  "application/bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/beep+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/bufr": { "source": "iana" },
  "application/c2pa": { "source": "iana" },
  "application/calendar+json": { "source": "iana", "compressible": true },
  "application/calendar+xml": { "source": "iana", "compressible": true, "extensions": ["xcs"] },
  "application/call-completion": { "source": "iana" },
  "application/cals-1840": { "source": "iana" },
  "application/captive+json": { "source": "iana", "compressible": true },
  "application/cbor": { "source": "iana" },
  "application/cbor-seq": { "source": "iana" },
  "application/cccex": { "source": "iana" },
  "application/ccmp+xml": { "source": "iana", "compressible": true },
  "application/ccxml+xml": { "source": "iana", "compressible": true, "extensions": ["ccxml"] },
  "application/cda+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/cdfx+xml": { "source": "iana", "compressible": true, "extensions": ["cdfx"] },
  "application/cdmi-capability": { "source": "iana", "extensions": ["cdmia"] },
  "application/cdmi-container": { "source": "iana", "extensions": ["cdmic"] },
  "application/cdmi-domain": { "source": "iana", "extensions": ["cdmid"] },
  "application/cdmi-object": { "source": "iana", "extensions": ["cdmio"] },
  "application/cdmi-queue": { "source": "iana", "extensions": ["cdmiq"] },
  "application/cdni": { "source": "iana" },
  "application/ce+cbor": { "source": "iana" },
  "application/cea": { "source": "iana" },
  "application/cea-2018+xml": { "source": "iana", "compressible": true },
  "application/cellml+xml": { "source": "iana", "compressible": true },
  "application/cfw": { "source": "iana" },
  "application/cid-edhoc+cbor-seq": { "source": "iana" },
  "application/city+json": { "source": "iana", "compressible": true },
  "application/city+json-seq": { "source": "iana" },
  "application/clr": { "source": "iana" },
  "application/clue+xml": { "source": "iana", "compressible": true },
  "application/clue_info+xml": { "source": "iana", "compressible": true },
  "application/cms": { "source": "iana" },
  "application/cnrp+xml": { "source": "iana", "compressible": true },
  "application/coap-eap": { "source": "iana" },
  "application/coap-group+json": { "source": "iana", "compressible": true },
  "application/coap-payload": { "source": "iana" },
  "application/commonground": { "source": "iana" },
  "application/concise-problem-details+cbor": { "source": "iana" },
  "application/conference-info+xml": { "source": "iana", "compressible": true },
  "application/cose": { "source": "iana" },
  "application/cose-key": { "source": "iana" },
  "application/cose-key-set": { "source": "iana" },
  "application/cose-x509": { "source": "iana" },
  "application/cpl+xml": { "source": "iana", "compressible": true, "extensions": ["cpl"] },
  "application/csrattrs": { "source": "iana" },
  "application/csta+xml": { "source": "iana", "compressible": true },
  "application/cstadata+xml": { "source": "iana", "compressible": true },
  "application/csvm+json": { "source": "iana", "compressible": true },
  "application/cu-seeme": { "source": "apache", "extensions": ["cu"] },
  "application/cwl": { "source": "iana", "extensions": ["cwl"] },
  "application/cwl+json": { "source": "iana", "compressible": true },
  "application/cwl+yaml": { "source": "iana" },
  "application/cwt": { "source": "iana" },
  "application/cybercash": { "source": "iana" },
  "application/dart": { "compressible": true },
  "application/dash+xml": { "source": "iana", "compressible": true, "extensions": ["mpd"] },
  "application/dash-patch+xml": { "source": "iana", "compressible": true, "extensions": ["mpp"] },
  "application/dashdelta": { "source": "iana" },
  "application/davmount+xml": { "source": "iana", "compressible": true, "extensions": ["davmount"] },
  "application/dca-rft": { "source": "iana" },
  "application/dcd": { "source": "iana" },
  "application/dec-dx": { "source": "iana" },
  "application/dialog-info+xml": { "source": "iana", "compressible": true },
  "application/dicom": { "source": "iana", "extensions": ["dcm"] },
  "application/dicom+json": { "source": "iana", "compressible": true },
  "application/dicom+xml": { "source": "iana", "compressible": true },
  "application/dii": { "source": "iana" },
  "application/dit": { "source": "iana" },
  "application/dns": { "source": "iana" },
  "application/dns+json": { "source": "iana", "compressible": true },
  "application/dns-message": { "source": "iana" },
  "application/docbook+xml": { "source": "apache", "compressible": true, "extensions": ["dbk"] },
  "application/dots+cbor": { "source": "iana" },
  "application/dpop+jwt": { "source": "iana" },
  "application/dskpp+xml": { "source": "iana", "compressible": true },
  "application/dssc+der": { "source": "iana", "extensions": ["dssc"] },
  "application/dssc+xml": { "source": "iana", "compressible": true, "extensions": ["xdssc"] },
  "application/dvcs": { "source": "iana" },
  "application/eat+cwt": { "source": "iana" },
  "application/eat+jwt": { "source": "iana" },
  "application/eat-bun+cbor": { "source": "iana" },
  "application/eat-bun+json": { "source": "iana", "compressible": true },
  "application/eat-ucs+cbor": { "source": "iana" },
  "application/eat-ucs+json": { "source": "iana", "compressible": true },
  "application/ecmascript": { "source": "apache", "compressible": true, "extensions": ["ecma"] },
  "application/edhoc+cbor-seq": { "source": "iana" },
  "application/edi-consent": { "source": "iana" },
  "application/edi-x12": { "source": "iana", "compressible": false },
  "application/edifact": { "source": "iana", "compressible": false },
  "application/efi": { "source": "iana" },
  "application/elm+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/elm+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.cap+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/emergencycalldata.comment+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.control+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.deviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.ecall.msd": { "source": "iana" },
  "application/emergencycalldata.legacyesn+json": { "source": "iana", "compressible": true },
  "application/emergencycalldata.providerinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.serviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.subscriberinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.veds+xml": { "source": "iana", "compressible": true },
  "application/emma+xml": { "source": "iana", "compressible": true, "extensions": ["emma"] },
  "application/emotionml+xml": { "source": "iana", "compressible": true, "extensions": ["emotionml"] },
  "application/encaprtp": { "source": "iana" },
  "application/entity-statement+jwt": { "source": "iana" },
  "application/epp+xml": { "source": "iana", "compressible": true },
  "application/epub+zip": { "source": "iana", "compressible": false, "extensions": ["epub"] },
  "application/eshop": { "source": "iana" },
  "application/exi": { "source": "iana", "extensions": ["exi"] },
  "application/expect-ct-report+json": { "source": "iana", "compressible": true },
  "application/express": { "source": "iana", "extensions": ["exp"] },
  "application/fastinfoset": { "source": "iana" },
  "application/fastsoap": { "source": "iana" },
  "application/fdf": { "source": "iana", "extensions": ["fdf"] },
  "application/fdt+xml": { "source": "iana", "compressible": true, "extensions": ["fdt"] },
  "application/fhir+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fhir+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fido.trusted-apps+json": { "compressible": true },
  "application/fits": { "source": "iana" },
  "application/flexfec": { "source": "iana" },
  "application/font-sfnt": { "source": "iana" },
  "application/font-tdpfr": { "source": "iana", "extensions": ["pfr"] },
  "application/font-woff": { "source": "iana", "compressible": false },
  "application/framework-attributes+xml": { "source": "iana", "compressible": true },
  "application/geo+json": { "source": "iana", "compressible": true, "extensions": ["geojson"] },
  "application/geo+json-seq": { "source": "iana" },
  "application/geopackage+sqlite3": { "source": "iana" },
  "application/geopose+json": { "source": "iana", "compressible": true },
  "application/geoxacml+json": { "source": "iana", "compressible": true },
  "application/geoxacml+xml": { "source": "iana", "compressible": true },
  "application/gltf-buffer": { "source": "iana" },
  "application/gml+xml": { "source": "iana", "compressible": true, "extensions": ["gml"] },
  "application/gnap-binding-jws": { "source": "iana" },
  "application/gnap-binding-jwsd": { "source": "iana" },
  "application/gnap-binding-rotation-jws": { "source": "iana" },
  "application/gnap-binding-rotation-jwsd": { "source": "iana" },
  "application/gpx+xml": { "source": "apache", "compressible": true, "extensions": ["gpx"] },
  "application/grib": { "source": "iana" },
  "application/gxf": { "source": "apache", "extensions": ["gxf"] },
  "application/gzip": { "source": "iana", "compressible": false, "extensions": ["gz"] },
  "application/h224": { "source": "iana" },
  "application/held+xml": { "source": "iana", "compressible": true },
  "application/hjson": { "extensions": ["hjson"] },
  "application/hl7v2+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/http": { "source": "iana" },
  "application/hyperstudio": { "source": "iana", "extensions": ["stk"] },
  "application/ibe-key-request+xml": { "source": "iana", "compressible": true },
  "application/ibe-pkg-reply+xml": { "source": "iana", "compressible": true },
  "application/ibe-pp-data": { "source": "iana" },
  "application/iges": { "source": "iana" },
  "application/im-iscomposing+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/index": { "source": "iana" },
  "application/index.cmd": { "source": "iana" },
  "application/index.obj": { "source": "iana" },
  "application/index.response": { "source": "iana" },
  "application/index.vnd": { "source": "iana" },
  "application/inkml+xml": { "source": "iana", "compressible": true, "extensions": ["ink", "inkml"] },
  "application/iotp": { "source": "iana" },
  "application/ipfix": { "source": "iana", "extensions": ["ipfix"] },
  "application/ipp": { "source": "iana" },
  "application/isup": { "source": "iana" },
  "application/its+xml": { "source": "iana", "compressible": true, "extensions": ["its"] },
  "application/java-archive": { "source": "iana", "compressible": false, "extensions": ["jar", "war", "ear"] },
  "application/java-serialized-object": { "source": "apache", "compressible": false, "extensions": ["ser"] },
  "application/java-vm": { "source": "apache", "compressible": false, "extensions": ["class"] },
  "application/javascript": { "source": "apache", "charset": "UTF-8", "compressible": true, "extensions": ["js"] },
  "application/jf2feed+json": { "source": "iana", "compressible": true },
  "application/jose": { "source": "iana" },
  "application/jose+json": { "source": "iana", "compressible": true },
  "application/jrd+json": { "source": "iana", "compressible": true },
  "application/jscalendar+json": { "source": "iana", "compressible": true },
  "application/jscontact+json": { "source": "iana", "compressible": true },
  "application/json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["json", "map"] },
  "application/json-patch+json": { "source": "iana", "compressible": true },
  "application/json-seq": { "source": "iana" },
  "application/json5": { "extensions": ["json5"] },
  "application/jsonml+json": { "source": "apache", "compressible": true, "extensions": ["jsonml"] },
  "application/jsonpath": { "source": "iana" },
  "application/jwk+json": { "source": "iana", "compressible": true },
  "application/jwk-set+json": { "source": "iana", "compressible": true },
  "application/jwk-set+jwt": { "source": "iana" },
  "application/jwt": { "source": "iana" },
  "application/kpml-request+xml": { "source": "iana", "compressible": true },
  "application/kpml-response+xml": { "source": "iana", "compressible": true },
  "application/ld+json": { "source": "iana", "compressible": true, "extensions": ["jsonld"] },
  "application/lgr+xml": { "source": "iana", "compressible": true, "extensions": ["lgr"] },
  "application/link-format": { "source": "iana" },
  "application/linkset": { "source": "iana" },
  "application/linkset+json": { "source": "iana", "compressible": true },
  "application/load-control+xml": { "source": "iana", "compressible": true },
  "application/logout+jwt": { "source": "iana" },
  "application/lost+xml": { "source": "iana", "compressible": true, "extensions": ["lostxml"] },
  "application/lostsync+xml": { "source": "iana", "compressible": true },
  "application/lpf+zip": { "source": "iana", "compressible": false },
  "application/lxf": { "source": "iana" },
  "application/mac-binhex40": { "source": "iana", "extensions": ["hqx"] },
  "application/mac-compactpro": { "source": "apache", "extensions": ["cpt"] },
  "application/macwriteii": { "source": "iana" },
  "application/mads+xml": { "source": "iana", "compressible": true, "extensions": ["mads"] },
  "application/manifest+json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["webmanifest"] },
  "application/marc": { "source": "iana", "extensions": ["mrc"] },
  "application/marcxml+xml": { "source": "iana", "compressible": true, "extensions": ["mrcx"] },
  "application/mathematica": { "source": "iana", "extensions": ["ma", "nb", "mb"] },
  "application/mathml+xml": { "source": "iana", "compressible": true, "extensions": ["mathml"] },
  "application/mathml-content+xml": { "source": "iana", "compressible": true },
  "application/mathml-presentation+xml": { "source": "iana", "compressible": true },
  "application/mbms-associated-procedure-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-deregister+xml": { "source": "iana", "compressible": true },
  "application/mbms-envelope+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-protection-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-reception-report+xml": { "source": "iana", "compressible": true },
  "application/mbms-register+xml": { "source": "iana", "compressible": true },
  "application/mbms-register-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-schedule+xml": { "source": "iana", "compressible": true },
  "application/mbms-user-service-description+xml": { "source": "iana", "compressible": true },
  "application/mbox": { "source": "iana", "extensions": ["mbox"] },
  "application/media-policy-dataset+xml": { "source": "iana", "compressible": true, "extensions": ["mpf"] },
  "application/media_control+xml": { "source": "iana", "compressible": true },
  "application/mediaservercontrol+xml": { "source": "iana", "compressible": true, "extensions": ["mscml"] },
  "application/merge-patch+json": { "source": "iana", "compressible": true },
  "application/metalink+xml": { "source": "apache", "compressible": true, "extensions": ["metalink"] },
  "application/metalink4+xml": { "source": "iana", "compressible": true, "extensions": ["meta4"] },
  "application/mets+xml": { "source": "iana", "compressible": true, "extensions": ["mets"] },
  "application/mf4": { "source": "iana" },
  "application/mikey": { "source": "iana" },
  "application/mipc": { "source": "iana" },
  "application/missing-blocks+cbor-seq": { "source": "iana" },
  "application/mmt-aei+xml": { "source": "iana", "compressible": true, "extensions": ["maei"] },
  "application/mmt-usd+xml": { "source": "iana", "compressible": true, "extensions": ["musd"] },
  "application/mods+xml": { "source": "iana", "compressible": true, "extensions": ["mods"] },
  "application/moss-keys": { "source": "iana" },
  "application/moss-signature": { "source": "iana" },
  "application/mosskey-data": { "source": "iana" },
  "application/mosskey-request": { "source": "iana" },
  "application/mp21": { "source": "iana", "extensions": ["m21", "mp21"] },
  "application/mp4": { "source": "iana", "extensions": ["mp4", "mpg4", "mp4s", "m4p"] },
  "application/mpeg4-generic": { "source": "iana" },
  "application/mpeg4-iod": { "source": "iana" },
  "application/mpeg4-iod-xmt": { "source": "iana" },
  "application/mrb-consumer+xml": { "source": "iana", "compressible": true },
  "application/mrb-publish+xml": { "source": "iana", "compressible": true },
  "application/msc-ivr+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msc-mixer+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msix": { "compressible": false, "extensions": ["msix"] },
  "application/msixbundle": { "compressible": false, "extensions": ["msixbundle"] },
  "application/msword": { "source": "iana", "compressible": false, "extensions": ["doc", "dot"] },
  "application/mud+json": { "source": "iana", "compressible": true },
  "application/multipart-core": { "source": "iana" },
  "application/mxf": { "source": "iana", "extensions": ["mxf"] },
  "application/n-quads": { "source": "iana", "extensions": ["nq"] },
  "application/n-triples": { "source": "iana", "extensions": ["nt"] },
  "application/nasdata": { "source": "iana" },
  "application/news-checkgroups": { "source": "iana", "charset": "US-ASCII" },
  "application/news-groupinfo": { "source": "iana", "charset": "US-ASCII" },
  "application/news-transmission": { "source": "iana" },
  "application/nlsml+xml": { "source": "iana", "compressible": true },
  "application/node": { "source": "iana", "extensions": ["cjs"] },
  "application/nss": { "source": "iana" },
  "application/oauth-authz-req+jwt": { "source": "iana" },
  "application/oblivious-dns-message": { "source": "iana" },
  "application/ocsp-request": { "source": "iana" },
  "application/ocsp-response": { "source": "iana" },
  "application/octet-stream": { "source": "iana", "compressible": true, "extensions": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"] },
  "application/oda": { "source": "iana", "extensions": ["oda"] },
  "application/odm+xml": { "source": "iana", "compressible": true },
  "application/odx": { "source": "iana" },
  "application/oebps-package+xml": { "source": "iana", "compressible": true, "extensions": ["opf"] },
  "application/ogg": { "source": "iana", "compressible": false, "extensions": ["ogx"] },
  "application/ohttp-keys": { "source": "iana" },
  "application/omdoc+xml": { "source": "apache", "compressible": true, "extensions": ["omdoc"] },
  "application/onenote": { "source": "apache", "extensions": ["onetoc", "onetoc2", "onetmp", "onepkg", "one", "onea"] },
  "application/opc-nodeset+xml": { "source": "iana", "compressible": true },
  "application/oscore": { "source": "iana" },
  "application/oxps": { "source": "iana", "extensions": ["oxps"] },
  "application/p21": { "source": "iana" },
  "application/p21+zip": { "source": "iana", "compressible": false },
  "application/p2p-overlay+xml": { "source": "iana", "compressible": true, "extensions": ["relo"] },
  "application/parityfec": { "source": "iana" },
  "application/passport": { "source": "iana" },
  "application/patch-ops-error+xml": { "source": "iana", "compressible": true, "extensions": ["xer"] },
  "application/pdf": { "source": "iana", "compressible": false, "extensions": ["pdf"] },
  "application/pdx": { "source": "iana" },
  "application/pem-certificate-chain": { "source": "iana" },
  "application/pgp-encrypted": { "source": "iana", "compressible": false, "extensions": ["pgp"] },
  "application/pgp-keys": { "source": "iana", "extensions": ["asc"] },
  "application/pgp-signature": { "source": "iana", "extensions": ["sig", "asc"] },
  "application/pics-rules": { "source": "apache", "extensions": ["prf"] },
  "application/pidf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pidf-diff+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pkcs10": { "source": "iana", "extensions": ["p10"] },
  "application/pkcs12": { "source": "iana" },
  "application/pkcs7-mime": { "source": "iana", "extensions": ["p7m", "p7c"] },
  "application/pkcs7-signature": { "source": "iana", "extensions": ["p7s"] },
  "application/pkcs8": { "source": "iana", "extensions": ["p8"] },
  "application/pkcs8-encrypted": { "source": "iana" },
  "application/pkix-attr-cert": { "source": "iana", "extensions": ["ac"] },
  "application/pkix-cert": { "source": "iana", "extensions": ["cer"] },
  "application/pkix-crl": { "source": "iana", "extensions": ["crl"] },
  "application/pkix-pkipath": { "source": "iana", "extensions": ["pkipath"] },
  "application/pkixcmp": { "source": "iana", "extensions": ["pki"] },
  "application/pls+xml": { "source": "iana", "compressible": true, "extensions": ["pls"] },
  "application/poc-settings+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/postscript": { "source": "iana", "compressible": true, "extensions": ["ai", "eps", "ps"] },
  "application/ppsp-tracker+json": { "source": "iana", "compressible": true },
  "application/private-token-issuer-directory": { "source": "iana" },
  "application/private-token-request": { "source": "iana" },
  "application/private-token-response": { "source": "iana" },
  "application/problem+json": { "source": "iana", "compressible": true },
  "application/problem+xml": { "source": "iana", "compressible": true },
  "application/provenance+xml": { "source": "iana", "compressible": true, "extensions": ["provx"] },
  "application/provided-claims+jwt": { "source": "iana" },
  "application/prs.alvestrand.titrax-sheet": { "source": "iana" },
  "application/prs.cww": { "source": "iana", "extensions": ["cww"] },
  "application/prs.cyn": { "source": "iana", "charset": "7-BIT" },
  "application/prs.hpub+zip": { "source": "iana", "compressible": false },
  "application/prs.implied-document+xml": { "source": "iana", "compressible": true },
  "application/prs.implied-executable": { "source": "iana" },
  "application/prs.implied-object+json": { "source": "iana", "compressible": true },
  "application/prs.implied-object+json-seq": { "source": "iana" },
  "application/prs.implied-object+yaml": { "source": "iana" },
  "application/prs.implied-structure": { "source": "iana" },
  "application/prs.mayfile": { "source": "iana" },
  "application/prs.nprend": { "source": "iana" },
  "application/prs.plucker": { "source": "iana" },
  "application/prs.rdf-xml-crypt": { "source": "iana" },
  "application/prs.vcfbzip2": { "source": "iana" },
  "application/prs.xsf+xml": { "source": "iana", "compressible": true, "extensions": ["xsf"] },
  "application/pskc+xml": { "source": "iana", "compressible": true, "extensions": ["pskcxml"] },
  "application/pvd+json": { "source": "iana", "compressible": true },
  "application/qsig": { "source": "iana" },
  "application/raml+yaml": { "compressible": true, "extensions": ["raml"] },
  "application/raptorfec": { "source": "iana" },
  "application/rdap+json": { "source": "iana", "compressible": true },
  "application/rdf+xml": { "source": "iana", "compressible": true, "extensions": ["rdf", "owl"] },
  "application/reginfo+xml": { "source": "iana", "compressible": true, "extensions": ["rif"] },
  "application/relax-ng-compact-syntax": { "source": "iana", "extensions": ["rnc"] },
  "application/remote-printing": { "source": "apache" },
  "application/reputon+json": { "source": "iana", "compressible": true },
  "application/resolve-response+jwt": { "source": "iana" },
  "application/resource-lists+xml": { "source": "iana", "compressible": true, "extensions": ["rl"] },
  "application/resource-lists-diff+xml": { "source": "iana", "compressible": true, "extensions": ["rld"] },
  "application/rfc+xml": { "source": "iana", "compressible": true },
  "application/riscos": { "source": "iana" },
  "application/rlmi+xml": { "source": "iana", "compressible": true },
  "application/rls-services+xml": { "source": "iana", "compressible": true, "extensions": ["rs"] },
  "application/route-apd+xml": { "source": "iana", "compressible": true, "extensions": ["rapd"] },
  "application/route-s-tsid+xml": { "source": "iana", "compressible": true, "extensions": ["sls"] },
  "application/route-usd+xml": { "source": "iana", "compressible": true, "extensions": ["rusd"] },
  "application/rpki-checklist": { "source": "iana" },
  "application/rpki-ghostbusters": { "source": "iana", "extensions": ["gbr"] },
  "application/rpki-manifest": { "source": "iana", "extensions": ["mft"] },
  "application/rpki-publication": { "source": "iana" },
  "application/rpki-roa": { "source": "iana", "extensions": ["roa"] },
  "application/rpki-signed-tal": { "source": "iana" },
  "application/rpki-updown": { "source": "iana" },
  "application/rsd+xml": { "source": "apache", "compressible": true, "extensions": ["rsd"] },
  "application/rss+xml": { "source": "apache", "compressible": true, "extensions": ["rss"] },
  "application/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "application/rtploopback": { "source": "iana" },
  "application/rtx": { "source": "iana" },
  "application/samlassertion+xml": { "source": "iana", "compressible": true },
  "application/samlmetadata+xml": { "source": "iana", "compressible": true },
  "application/sarif+json": { "source": "iana", "compressible": true },
  "application/sarif-external-properties+json": { "source": "iana", "compressible": true },
  "application/sbe": { "source": "iana" },
  "application/sbml+xml": { "source": "iana", "compressible": true, "extensions": ["sbml"] },
  "application/scaip+xml": { "source": "iana", "compressible": true },
  "application/scim+json": { "source": "iana", "compressible": true },
  "application/scvp-cv-request": { "source": "iana", "extensions": ["scq"] },
  "application/scvp-cv-response": { "source": "iana", "extensions": ["scs"] },
  "application/scvp-vp-request": { "source": "iana", "extensions": ["spq"] },
  "application/scvp-vp-response": { "source": "iana", "extensions": ["spp"] },
  "application/sdp": { "source": "iana", "extensions": ["sdp"] },
  "application/secevent+jwt": { "source": "iana" },
  "application/senml+cbor": { "source": "iana" },
  "application/senml+json": { "source": "iana", "compressible": true },
  "application/senml+xml": { "source": "iana", "compressible": true, "extensions": ["senmlx"] },
  "application/senml-etch+cbor": { "source": "iana" },
  "application/senml-etch+json": { "source": "iana", "compressible": true },
  "application/senml-exi": { "source": "iana" },
  "application/sensml+cbor": { "source": "iana" },
  "application/sensml+json": { "source": "iana", "compressible": true },
  "application/sensml+xml": { "source": "iana", "compressible": true, "extensions": ["sensmlx"] },
  "application/sensml-exi": { "source": "iana" },
  "application/sep+xml": { "source": "iana", "compressible": true },
  "application/sep-exi": { "source": "iana" },
  "application/session-info": { "source": "iana" },
  "application/set-payment": { "source": "iana" },
  "application/set-payment-initiation": { "source": "iana", "extensions": ["setpay"] },
  "application/set-registration": { "source": "iana" },
  "application/set-registration-initiation": { "source": "iana", "extensions": ["setreg"] },
  "application/sgml": { "source": "iana" },
  "application/sgml-open-catalog": { "source": "iana" },
  "application/shf+xml": { "source": "iana", "compressible": true, "extensions": ["shf"] },
  "application/sieve": { "source": "iana", "extensions": ["siv", "sieve"] },
  "application/simple-filter+xml": { "source": "iana", "compressible": true },
  "application/simple-message-summary": { "source": "iana" },
  "application/simplesymbolcontainer": { "source": "iana" },
  "application/sipc": { "source": "iana" },
  "application/slate": { "source": "iana" },
  "application/smil": { "source": "apache" },
  "application/smil+xml": { "source": "iana", "compressible": true, "extensions": ["smi", "smil"] },
  "application/smpte336m": { "source": "iana" },
  "application/soap+fastinfoset": { "source": "iana" },
  "application/soap+xml": { "source": "iana", "compressible": true },
  "application/sparql-query": { "source": "iana", "extensions": ["rq"] },
  "application/sparql-results+xml": { "source": "iana", "compressible": true, "extensions": ["srx"] },
  "application/spdx+json": { "source": "iana", "compressible": true },
  "application/spirits-event+xml": { "source": "iana", "compressible": true },
  "application/sql": { "source": "iana", "extensions": ["sql"] },
  "application/srgs": { "source": "iana", "extensions": ["gram"] },
  "application/srgs+xml": { "source": "iana", "compressible": true, "extensions": ["grxml"] },
  "application/sru+xml": { "source": "iana", "compressible": true, "extensions": ["sru"] },
  "application/ssdl+xml": { "source": "apache", "compressible": true, "extensions": ["ssdl"] },
  "application/sslkeylogfile": { "source": "iana" },
  "application/ssml+xml": { "source": "iana", "compressible": true, "extensions": ["ssml"] },
  "application/st2110-41": { "source": "iana" },
  "application/stix+json": { "source": "iana", "compressible": true },
  "application/stratum": { "source": "iana" },
  "application/swid+cbor": { "source": "iana" },
  "application/swid+xml": { "source": "iana", "compressible": true, "extensions": ["swidtag"] },
  "application/tamp-apex-update": { "source": "iana" },
  "application/tamp-apex-update-confirm": { "source": "iana" },
  "application/tamp-community-update": { "source": "iana" },
  "application/tamp-community-update-confirm": { "source": "iana" },
  "application/tamp-error": { "source": "iana" },
  "application/tamp-sequence-adjust": { "source": "iana" },
  "application/tamp-sequence-adjust-confirm": { "source": "iana" },
  "application/tamp-status-query": { "source": "iana" },
  "application/tamp-status-response": { "source": "iana" },
  "application/tamp-update": { "source": "iana" },
  "application/tamp-update-confirm": { "source": "iana" },
  "application/tar": { "compressible": true },
  "application/taxii+json": { "source": "iana", "compressible": true },
  "application/td+json": { "source": "iana", "compressible": true },
  "application/tei+xml": { "source": "iana", "compressible": true, "extensions": ["tei", "teicorpus"] },
  "application/tetra_isi": { "source": "iana" },
  "application/thraud+xml": { "source": "iana", "compressible": true, "extensions": ["tfi"] },
  "application/timestamp-query": { "source": "iana" },
  "application/timestamp-reply": { "source": "iana" },
  "application/timestamped-data": { "source": "iana", "extensions": ["tsd"] },
  "application/tlsrpt+gzip": { "source": "iana" },
  "application/tlsrpt+json": { "source": "iana", "compressible": true },
  "application/tm+json": { "source": "iana", "compressible": true },
  "application/tnauthlist": { "source": "iana" },
  "application/toc+cbor": { "source": "iana" },
  "application/token-introspection+jwt": { "source": "iana" },
  "application/toml": { "source": "iana", "compressible": true, "extensions": ["toml"] },
  "application/trickle-ice-sdpfrag": { "source": "iana" },
  "application/trig": { "source": "iana", "extensions": ["trig"] },
  "application/trust-chain+json": { "source": "iana", "compressible": true },
  "application/trust-mark+jwt": { "source": "iana" },
  "application/trust-mark-delegation+jwt": { "source": "iana" },
  "application/ttml+xml": { "source": "iana", "compressible": true, "extensions": ["ttml"] },
  "application/tve-trigger": { "source": "iana" },
  "application/tzif": { "source": "iana" },
  "application/tzif-leap": { "source": "iana" },
  "application/ubjson": { "compressible": false, "extensions": ["ubj"] },
  "application/uccs+cbor": { "source": "iana" },
  "application/ujcs+json": { "source": "iana", "compressible": true },
  "application/ulpfec": { "source": "iana" },
  "application/urc-grpsheet+xml": { "source": "iana", "compressible": true },
  "application/urc-ressheet+xml": { "source": "iana", "compressible": true, "extensions": ["rsheet"] },
  "application/urc-targetdesc+xml": { "source": "iana", "compressible": true, "extensions": ["td"] },
  "application/urc-uisocketdesc+xml": { "source": "iana", "compressible": true },
  "application/vc": { "source": "iana" },
  "application/vc+cose": { "source": "iana" },
  "application/vc+jwt": { "source": "iana" },
  "application/vcard+json": { "source": "iana", "compressible": true },
  "application/vcard+xml": { "source": "iana", "compressible": true },
  "application/vemmi": { "source": "iana" },
  "application/vividence.scriptfile": { "source": "apache" },
  "application/vnd.1000minds.decision-model+xml": { "source": "iana", "compressible": true, "extensions": ["1km"] },
  "application/vnd.1ob": { "source": "iana" },
  "application/vnd.3gpp-prose+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc3a+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc3ach+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc3ch+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc8+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-v2x-local-service-information": { "source": "iana" },
  "application/vnd.3gpp.5gnas": { "source": "iana" },
  "application/vnd.3gpp.5gsa2x": { "source": "iana" },
  "application/vnd.3gpp.5gsa2x-local-service-information": { "source": "iana" },
  "application/vnd.3gpp.5gsv2x": { "source": "iana" },
  "application/vnd.3gpp.5gsv2x-local-service-information": { "source": "iana" },
  "application/vnd.3gpp.access-transfer-events+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.bsf+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.crs+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.current-location-discovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gmop+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gtpc": { "source": "iana" },
  "application/vnd.3gpp.interworking-data": { "source": "iana" },
  "application/vnd.3gpp.lpp": { "source": "iana" },
  "application/vnd.3gpp.mc-signalling-ear": { "source": "iana" },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-msgstore-ctrl-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-payload": { "source": "iana" },
  "application/vnd.3gpp.mcdata-regroup+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-signalling": { "source": "iana" },
  "application/vnd.3gpp.mcdata-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-floor-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-regroup+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-signed+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-regroup+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mid-call+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ngap": { "source": "iana" },
  "application/vnd.3gpp.pfcp": { "source": "iana" },
  "application/vnd.3gpp.pic-bw-large": { "source": "iana", "extensions": ["plb"] },
  "application/vnd.3gpp.pic-bw-small": { "source": "iana", "extensions": ["psb"] },
  "application/vnd.3gpp.pic-bw-var": { "source": "iana", "extensions": ["pvb"] },
  "application/vnd.3gpp.pinapp-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.s1ap": { "source": "iana" },
  "application/vnd.3gpp.seal-group-doc+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-network-qos-management-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-ue-config-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-unicast-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-user-profile-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.sms": { "source": "iana" },
  "application/vnd.3gpp.sms+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-ext+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.state-and-event-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ussd+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.v2x": { "source": "iana" },
  "application/vnd.3gpp.vae-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.bcmcsinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.sms": { "source": "iana" },
  "application/vnd.3gpp2.tcap": { "source": "iana", "extensions": ["tcap"] },
  "application/vnd.3lightssoftware.imagescal": { "source": "iana" },
  "application/vnd.3m.post-it-notes": { "source": "iana", "extensions": ["pwn"] },
  "application/vnd.accpac.simply.aso": { "source": "iana", "extensions": ["aso"] },
  "application/vnd.accpac.simply.imp": { "source": "iana", "extensions": ["imp"] },
  "application/vnd.acm.addressxfer+json": { "source": "iana", "compressible": true },
  "application/vnd.acm.chatbot+json": { "source": "iana", "compressible": true },
  "application/vnd.acucobol": { "source": "iana", "extensions": ["acu"] },
  "application/vnd.acucorp": { "source": "iana", "extensions": ["atc", "acutc"] },
  "application/vnd.adobe.air-application-installer-package+zip": { "source": "apache", "compressible": false, "extensions": ["air"] },
  "application/vnd.adobe.flash.movie": { "source": "iana" },
  "application/vnd.adobe.formscentral.fcdt": { "source": "iana", "extensions": ["fcdt"] },
  "application/vnd.adobe.fxp": { "source": "iana", "extensions": ["fxp", "fxpl"] },
  "application/vnd.adobe.partial-upload": { "source": "iana" },
  "application/vnd.adobe.xdp+xml": { "source": "iana", "compressible": true, "extensions": ["xdp"] },
  "application/vnd.adobe.xfdf": { "source": "apache", "extensions": ["xfdf"] },
  "application/vnd.aether.imp": { "source": "iana" },
  "application/vnd.afpc.afplinedata": { "source": "iana" },
  "application/vnd.afpc.afplinedata-pagedef": { "source": "iana" },
  "application/vnd.afpc.cmoca-cmresource": { "source": "iana" },
  "application/vnd.afpc.foca-charset": { "source": "iana" },
  "application/vnd.afpc.foca-codedfont": { "source": "iana" },
  "application/vnd.afpc.foca-codepage": { "source": "iana" },
  "application/vnd.afpc.modca": { "source": "iana" },
  "application/vnd.afpc.modca-cmtable": { "source": "iana" },
  "application/vnd.afpc.modca-formdef": { "source": "iana" },
  "application/vnd.afpc.modca-mediummap": { "source": "iana" },
  "application/vnd.afpc.modca-objectcontainer": { "source": "iana" },
  "application/vnd.afpc.modca-overlay": { "source": "iana" },
  "application/vnd.afpc.modca-pagesegment": { "source": "iana" },
  "application/vnd.age": { "source": "iana", "extensions": ["age"] },
  "application/vnd.ah-barcode": { "source": "apache" },
  "application/vnd.ahead.space": { "source": "iana", "extensions": ["ahead"] },
  "application/vnd.airzip.filesecure.azf": { "source": "iana", "extensions": ["azf"] },
  "application/vnd.airzip.filesecure.azs": { "source": "iana", "extensions": ["azs"] },
  "application/vnd.amadeus+json": { "source": "iana", "compressible": true },
  "application/vnd.amazon.ebook": { "source": "apache", "extensions": ["azw"] },
  "application/vnd.amazon.mobi8-ebook": { "source": "iana" },
  "application/vnd.americandynamics.acc": { "source": "iana", "extensions": ["acc"] },
  "application/vnd.amiga.ami": { "source": "iana", "extensions": ["ami"] },
  "application/vnd.amundsen.maze+xml": { "source": "iana", "compressible": true },
  "application/vnd.android.ota": { "source": "iana" },
  "application/vnd.android.package-archive": { "source": "apache", "compressible": false, "extensions": ["apk"] },
  "application/vnd.anki": { "source": "iana" },
  "application/vnd.anser-web-certificate-issue-initiation": { "source": "iana", "extensions": ["cii"] },
  "application/vnd.anser-web-funds-transfer-initiation": { "source": "apache", "extensions": ["fti"] },
  "application/vnd.antix.game-component": { "source": "iana", "extensions": ["atx"] },
  "application/vnd.apache.arrow.file": { "source": "iana" },
  "application/vnd.apache.arrow.stream": { "source": "iana" },
  "application/vnd.apache.parquet": { "source": "iana" },
  "application/vnd.apache.thrift.binary": { "source": "iana" },
  "application/vnd.apache.thrift.compact": { "source": "iana" },
  "application/vnd.apache.thrift.json": { "source": "iana" },
  "application/vnd.apexlang": { "source": "iana" },
  "application/vnd.api+json": { "source": "iana", "compressible": true },
  "application/vnd.aplextor.warrp+json": { "source": "iana", "compressible": true },
  "application/vnd.apothekende.reservation+json": { "source": "iana", "compressible": true },
  "application/vnd.apple.installer+xml": { "source": "iana", "compressible": true, "extensions": ["mpkg"] },
  "application/vnd.apple.keynote": { "source": "iana", "extensions": ["key"] },
  "application/vnd.apple.mpegurl": { "source": "iana", "extensions": ["m3u8"] },
  "application/vnd.apple.numbers": { "source": "iana", "extensions": ["numbers"] },
  "application/vnd.apple.pages": { "source": "iana", "extensions": ["pages"] },
  "application/vnd.apple.pkpass": { "compressible": false, "extensions": ["pkpass"] },
  "application/vnd.arastra.swi": { "source": "apache" },
  "application/vnd.aristanetworks.swi": { "source": "iana", "extensions": ["swi"] },
  "application/vnd.artisan+json": { "source": "iana", "compressible": true },
  "application/vnd.artsquare": { "source": "iana" },
  "application/vnd.astraea-software.iota": { "source": "iana", "extensions": ["iota"] },
  "application/vnd.audiograph": { "source": "iana", "extensions": ["aep"] },
  "application/vnd.autodesk.fbx": { "extensions": ["fbx"] },
  "application/vnd.autopackage": { "source": "iana" },
  "application/vnd.avalon+json": { "source": "iana", "compressible": true },
  "application/vnd.avistar+xml": { "source": "iana", "compressible": true },
  "application/vnd.balsamiq.bmml+xml": { "source": "iana", "compressible": true, "extensions": ["bmml"] },
  "application/vnd.balsamiq.bmpr": { "source": "iana" },
  "application/vnd.banana-accounting": { "source": "iana" },
  "application/vnd.bbf.usp.error": { "source": "iana" },
  "application/vnd.bbf.usp.msg": { "source": "iana" },
  "application/vnd.bbf.usp.msg+json": { "source": "iana", "compressible": true },
  "application/vnd.bekitzur-stech+json": { "source": "iana", "compressible": true },
  "application/vnd.belightsoft.lhzd+zip": { "source": "iana", "compressible": false },
  "application/vnd.belightsoft.lhzl+zip": { "source": "iana", "compressible": false },
  "application/vnd.bint.med-content": { "source": "iana" },
  "application/vnd.biopax.rdf+xml": { "source": "iana", "compressible": true },
  "application/vnd.blink-idb-value-wrapper": { "source": "iana" },
  "application/vnd.blueice.multipass": { "source": "iana", "extensions": ["mpm"] },
  "application/vnd.bluetooth.ep.oob": { "source": "iana" },
  "application/vnd.bluetooth.le.oob": { "source": "iana" },
  "application/vnd.bmi": { "source": "iana", "extensions": ["bmi"] },
  "application/vnd.bpf": { "source": "iana" },
  "application/vnd.bpf3": { "source": "iana" },
  "application/vnd.businessobjects": { "source": "iana", "extensions": ["rep"] },
  "application/vnd.byu.uapi+json": { "source": "iana", "compressible": true },
  "application/vnd.bzip3": { "source": "iana" },
  "application/vnd.c3voc.schedule+xml": { "source": "iana", "compressible": true },
  "application/vnd.cab-jscript": { "source": "iana" },
  "application/vnd.canon-cpdl": { "source": "iana" },
  "application/vnd.canon-lips": { "source": "iana" },
  "application/vnd.capasystems-pg+json": { "source": "iana", "compressible": true },
  "application/vnd.cendio.thinlinc.clientconf": { "source": "iana" },
  "application/vnd.century-systems.tcp_stream": { "source": "iana" },
  "application/vnd.chemdraw+xml": { "source": "iana", "compressible": true, "extensions": ["cdxml"] },
  "application/vnd.chess-pgn": { "source": "iana" },
  "application/vnd.chipnuts.karaoke-mmd": { "source": "iana", "extensions": ["mmd"] },
  "application/vnd.ciedi": { "source": "iana" },
  "application/vnd.cinderella": { "source": "iana", "extensions": ["cdy"] },
  "application/vnd.cirpack.isdn-ext": { "source": "iana" },
  "application/vnd.citationstyles.style+xml": { "source": "iana", "compressible": true, "extensions": ["csl"] },
  "application/vnd.claymore": { "source": "iana", "extensions": ["cla"] },
  "application/vnd.cloanto.rp9": { "source": "iana", "extensions": ["rp9"] },
  "application/vnd.clonk.c4group": { "source": "iana", "extensions": ["c4g", "c4d", "c4f", "c4p", "c4u"] },
  "application/vnd.cluetrust.cartomobile-config": { "source": "iana", "extensions": ["c11amc"] },
  "application/vnd.cluetrust.cartomobile-config-pkg": { "source": "iana", "extensions": ["c11amz"] },
  "application/vnd.cncf.helm.chart.content.v1.tar+gzip": { "source": "iana" },
  "application/vnd.cncf.helm.chart.provenance.v1.prov": { "source": "iana" },
  "application/vnd.cncf.helm.config.v1+json": { "source": "iana", "compressible": true },
  "application/vnd.coffeescript": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet-template": { "source": "iana" },
  "application/vnd.collection+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.doc+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.next+json": { "source": "iana", "compressible": true },
  "application/vnd.comicbook+zip": { "source": "iana", "compressible": false },
  "application/vnd.comicbook-rar": { "source": "iana" },
  "application/vnd.commerce-battelle": { "source": "iana" },
  "application/vnd.commonspace": { "source": "iana", "extensions": ["csp"] },
  "application/vnd.contact.cmsg": { "source": "iana", "extensions": ["cdbcmsg"] },
  "application/vnd.coreos.ignition+json": { "source": "iana", "compressible": true },
  "application/vnd.cosmocaller": { "source": "iana", "extensions": ["cmc"] },
  "application/vnd.crick.clicker": { "source": "iana", "extensions": ["clkx"] },
  "application/vnd.crick.clicker.keyboard": { "source": "iana", "extensions": ["clkk"] },
  "application/vnd.crick.clicker.palette": { "source": "iana", "extensions": ["clkp"] },
  "application/vnd.crick.clicker.template": { "source": "iana", "extensions": ["clkt"] },
  "application/vnd.crick.clicker.wordbank": { "source": "iana", "extensions": ["clkw"] },
  "application/vnd.criticaltools.wbs+xml": { "source": "iana", "compressible": true, "extensions": ["wbs"] },
  "application/vnd.cryptii.pipe+json": { "source": "iana", "compressible": true },
  "application/vnd.crypto-shade-file": { "source": "iana" },
  "application/vnd.cryptomator.encrypted": { "source": "iana" },
  "application/vnd.cryptomator.vault": { "source": "iana" },
  "application/vnd.ctc-posml": { "source": "iana", "extensions": ["pml"] },
  "application/vnd.ctct.ws+xml": { "source": "iana", "compressible": true },
  "application/vnd.cups-pdf": { "source": "iana" },
  "application/vnd.cups-postscript": { "source": "iana" },
  "application/vnd.cups-ppd": { "source": "iana", "extensions": ["ppd"] },
  "application/vnd.cups-raster": { "source": "iana" },
  "application/vnd.cups-raw": { "source": "iana" },
  "application/vnd.curl": { "source": "iana" },
  "application/vnd.curl.car": { "source": "apache", "extensions": ["car"] },
  "application/vnd.curl.pcurl": { "source": "apache", "extensions": ["pcurl"] },
  "application/vnd.cyan.dean.root+xml": { "source": "iana", "compressible": true },
  "application/vnd.cybank": { "source": "iana" },
  "application/vnd.cyclonedx+json": { "source": "iana", "compressible": true },
  "application/vnd.cyclonedx+xml": { "source": "iana", "compressible": true },
  "application/vnd.d2l.coursepackage1p0+zip": { "source": "iana", "compressible": false },
  "application/vnd.d3m-dataset": { "source": "iana" },
  "application/vnd.d3m-problem": { "source": "iana" },
  "application/vnd.dart": { "source": "iana", "compressible": true, "extensions": ["dart"] },
  "application/vnd.data-vision.rdz": { "source": "iana", "extensions": ["rdz"] },
  "application/vnd.datalog": { "source": "iana" },
  "application/vnd.datapackage+json": { "source": "iana", "compressible": true },
  "application/vnd.dataresource+json": { "source": "iana", "compressible": true },
  "application/vnd.dbf": { "source": "iana", "extensions": ["dbf"] },
  "application/vnd.dcmp+xml": { "source": "iana", "compressible": true, "extensions": ["dcmp"] },
  "application/vnd.debian.binary-package": { "source": "iana" },
  "application/vnd.dece.data": { "source": "iana", "extensions": ["uvf", "uvvf", "uvd", "uvvd"] },
  "application/vnd.dece.ttml+xml": { "source": "iana", "compressible": true, "extensions": ["uvt", "uvvt"] },
  "application/vnd.dece.unspecified": { "source": "iana", "extensions": ["uvx", "uvvx"] },
  "application/vnd.dece.zip": { "source": "iana", "extensions": ["uvz", "uvvz"] },
  "application/vnd.denovo.fcselayout-link": { "source": "iana", "extensions": ["fe_launch"] },
  "application/vnd.desmume.movie": { "source": "iana" },
  "application/vnd.dir-bi.plate-dl-nosuffix": { "source": "iana" },
  "application/vnd.dm.delegation+xml": { "source": "iana", "compressible": true },
  "application/vnd.dna": { "source": "iana", "extensions": ["dna"] },
  "application/vnd.document+json": { "source": "iana", "compressible": true },
  "application/vnd.dolby.mlp": { "source": "apache", "extensions": ["mlp"] },
  "application/vnd.dolby.mobile.1": { "source": "iana" },
  "application/vnd.dolby.mobile.2": { "source": "iana" },
  "application/vnd.doremir.scorecloud-binary-document": { "source": "iana" },
  "application/vnd.dpgraph": { "source": "iana", "extensions": ["dpg"] },
  "application/vnd.dreamfactory": { "source": "iana", "extensions": ["dfac"] },
  "application/vnd.drive+json": { "source": "iana", "compressible": true },
  "application/vnd.ds-keypoint": { "source": "apache", "extensions": ["kpxx"] },
  "application/vnd.dtg.local": { "source": "iana" },
  "application/vnd.dtg.local.flash": { "source": "iana" },
  "application/vnd.dtg.local.html": { "source": "iana" },
  "application/vnd.dvb.ait": { "source": "iana", "extensions": ["ait"] },
  "application/vnd.dvb.dvbisl+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.dvbj": { "source": "iana" },
  "application/vnd.dvb.esgcontainer": { "source": "iana" },
  "application/vnd.dvb.ipdcdftnotifaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess2": { "source": "iana" },
  "application/vnd.dvb.ipdcesgpdd": { "source": "iana" },
  "application/vnd.dvb.ipdcroaming": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-base": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-enhancement": { "source": "iana" },
  "application/vnd.dvb.notif-aggregate-root+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-container+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-generic+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-msglist+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-response+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-init+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.pfr": { "source": "iana" },
  "application/vnd.dvb.service": { "source": "iana", "extensions": ["svc"] },
  "application/vnd.dxr": { "source": "iana" },
  "application/vnd.dynageo": { "source": "iana", "extensions": ["geo"] },
  "application/vnd.dzr": { "source": "iana" },
  "application/vnd.easykaraoke.cdgdownload": { "source": "iana" },
  "application/vnd.ecdis-update": { "source": "iana" },
  "application/vnd.ecip.rlp": { "source": "iana" },
  "application/vnd.eclipse.ditto+json": { "source": "iana", "compressible": true },
  "application/vnd.ecowin.chart": { "source": "iana", "extensions": ["mag"] },
  "application/vnd.ecowin.filerequest": { "source": "iana" },
  "application/vnd.ecowin.fileupdate": { "source": "iana" },
  "application/vnd.ecowin.series": { "source": "iana" },
  "application/vnd.ecowin.seriesrequest": { "source": "iana" },
  "application/vnd.ecowin.seriesupdate": { "source": "iana" },
  "application/vnd.efi.img": { "source": "iana" },
  "application/vnd.efi.iso": { "source": "iana" },
  "application/vnd.eln+zip": { "source": "iana", "compressible": false },
  "application/vnd.emclient.accessrequest+xml": { "source": "iana", "compressible": true },
  "application/vnd.enliven": { "source": "iana", "extensions": ["nml"] },
  "application/vnd.enphase.envoy": { "source": "iana" },
  "application/vnd.eprints.data+xml": { "source": "iana", "compressible": true },
  "application/vnd.epson.esf": { "source": "iana", "extensions": ["esf"] },
  "application/vnd.epson.msf": { "source": "iana", "extensions": ["msf"] },
  "application/vnd.epson.quickanime": { "source": "iana", "extensions": ["qam"] },
  "application/vnd.epson.salt": { "source": "iana", "extensions": ["slt"] },
  "application/vnd.epson.ssf": { "source": "iana", "extensions": ["ssf"] },
  "application/vnd.ericsson.quickcall": { "source": "iana" },
  "application/vnd.erofs": { "source": "iana" },
  "application/vnd.espass-espass+zip": { "source": "iana", "compressible": false },
  "application/vnd.eszigno3+xml": { "source": "iana", "compressible": true, "extensions": ["es3", "et3"] },
  "application/vnd.etsi.aoc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.asic-e+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.asic-s+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.cug+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvcommand+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-bc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-cod+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-npvr+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvservice+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsync+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mcid+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mheg5": { "source": "iana" },
  "application/vnd.etsi.overload-control-policy-dataset+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.pstn+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.sci+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.simservs+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.timestamp-token": { "source": "iana" },
  "application/vnd.etsi.tsl+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.tsl.der": { "source": "iana" },
  "application/vnd.eu.kasparian.car+json": { "source": "iana", "compressible": true },
  "application/vnd.eudora.data": { "source": "iana" },
  "application/vnd.evolv.ecig.profile": { "source": "iana" },
  "application/vnd.evolv.ecig.settings": { "source": "iana" },
  "application/vnd.evolv.ecig.theme": { "source": "iana" },
  "application/vnd.exstream-empower+zip": { "source": "iana", "compressible": false },
  "application/vnd.exstream-package": { "source": "iana" },
  "application/vnd.ezpix-album": { "source": "iana", "extensions": ["ez2"] },
  "application/vnd.ezpix-package": { "source": "iana", "extensions": ["ez3"] },
  "application/vnd.f-secure.mobile": { "source": "iana" },
  "application/vnd.familysearch.gedcom+zip": { "source": "iana", "compressible": false },
  "application/vnd.fastcopy-disk-image": { "source": "iana" },
  "application/vnd.fdf": { "source": "apache", "extensions": ["fdf"] },
  "application/vnd.fdsn.mseed": { "source": "iana", "extensions": ["mseed"] },
  "application/vnd.fdsn.seed": { "source": "iana", "extensions": ["seed", "dataless"] },
  "application/vnd.fdsn.stationxml+xml": { "source": "iana", "charset": "XML-BASED", "compressible": true },
  "application/vnd.ffsns": { "source": "iana" },
  "application/vnd.ficlab.flb+zip": { "source": "iana", "compressible": false },
  "application/vnd.filmit.zfc": { "source": "iana" },
  "application/vnd.fints": { "source": "iana" },
  "application/vnd.firemonkeys.cloudcell": { "source": "iana" },
  "application/vnd.flographit": { "source": "iana", "extensions": ["gph"] },
  "application/vnd.fluxtime.clip": { "source": "iana", "extensions": ["ftc"] },
  "application/vnd.font-fontforge-sfd": { "source": "iana" },
  "application/vnd.framemaker": { "source": "iana", "extensions": ["fm", "frame", "maker", "book"] },
  "application/vnd.freelog.comic": { "source": "iana" },
  "application/vnd.frogans.fnc": { "source": "apache", "extensions": ["fnc"] },
  "application/vnd.frogans.ltf": { "source": "apache", "extensions": ["ltf"] },
  "application/vnd.fsc.weblaunch": { "source": "iana", "extensions": ["fsc"] },
  "application/vnd.fujifilm.fb.docuworks": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.binder": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.container": { "source": "iana" },
  "application/vnd.fujifilm.fb.jfi+xml": { "source": "iana", "compressible": true },
  "application/vnd.fujitsu.oasys": { "source": "iana", "extensions": ["oas"] },
  "application/vnd.fujitsu.oasys2": { "source": "iana", "extensions": ["oa2"] },
  "application/vnd.fujitsu.oasys3": { "source": "iana", "extensions": ["oa3"] },
  "application/vnd.fujitsu.oasysgp": { "source": "iana", "extensions": ["fg5"] },
  "application/vnd.fujitsu.oasysprs": { "source": "iana", "extensions": ["bh2"] },
  "application/vnd.fujixerox.art-ex": { "source": "iana" },
  "application/vnd.fujixerox.art4": { "source": "iana" },
  "application/vnd.fujixerox.ddd": { "source": "iana", "extensions": ["ddd"] },
  "application/vnd.fujixerox.docuworks": { "source": "iana", "extensions": ["xdw"] },
  "application/vnd.fujixerox.docuworks.binder": { "source": "iana", "extensions": ["xbd"] },
  "application/vnd.fujixerox.docuworks.container": { "source": "iana" },
  "application/vnd.fujixerox.hbpl": { "source": "iana" },
  "application/vnd.fut-misnet": { "source": "iana" },
  "application/vnd.futoin+cbor": { "source": "iana" },
  "application/vnd.futoin+json": { "source": "iana", "compressible": true },
  "application/vnd.fuzzysheet": { "source": "iana", "extensions": ["fzs"] },
  "application/vnd.ga4gh.passport+jwt": { "source": "iana" },
  "application/vnd.genomatix.tuxedo": { "source": "iana", "extensions": ["txd"] },
  "application/vnd.genozip": { "source": "iana" },
  "application/vnd.gentics.grd+json": { "source": "iana", "compressible": true },
  "application/vnd.gentoo.catmetadata+xml": { "source": "iana", "compressible": true },
  "application/vnd.gentoo.ebuild": { "source": "iana" },
  "application/vnd.gentoo.eclass": { "source": "iana" },
  "application/vnd.gentoo.gpkg": { "source": "iana" },
  "application/vnd.gentoo.manifest": { "source": "iana" },
  "application/vnd.gentoo.pkgmetadata+xml": { "source": "iana", "compressible": true },
  "application/vnd.gentoo.xpak": { "source": "iana" },
  "application/vnd.geo+json": { "source": "apache", "compressible": true },
  "application/vnd.geocube+xml": { "source": "apache", "compressible": true },
  "application/vnd.geogebra.file": { "source": "iana", "extensions": ["ggb"] },
  "application/vnd.geogebra.pinboard": { "source": "iana" },
  "application/vnd.geogebra.slides": { "source": "iana", "extensions": ["ggs"] },
  "application/vnd.geogebra.tool": { "source": "iana", "extensions": ["ggt"] },
  "application/vnd.geometry-explorer": { "source": "iana", "extensions": ["gex", "gre"] },
  "application/vnd.geonext": { "source": "iana", "extensions": ["gxt"] },
  "application/vnd.geoplan": { "source": "iana", "extensions": ["g2w"] },
  "application/vnd.geospace": { "source": "iana", "extensions": ["g3w"] },
  "application/vnd.gerber": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt-response": { "source": "iana" },
  "application/vnd.gmx": { "source": "iana", "extensions": ["gmx"] },
  "application/vnd.gnu.taler.exchange+json": { "source": "iana", "compressible": true },
  "application/vnd.gnu.taler.merchant+json": { "source": "iana", "compressible": true },
  "application/vnd.google-apps.audio": {},
  "application/vnd.google-apps.document": { "compressible": false, "extensions": ["gdoc"] },
  "application/vnd.google-apps.drawing": { "compressible": false, "extensions": ["gdraw"] },
  "application/vnd.google-apps.drive-sdk": { "compressible": false },
  "application/vnd.google-apps.file": {},
  "application/vnd.google-apps.folder": { "compressible": false },
  "application/vnd.google-apps.form": { "compressible": false, "extensions": ["gform"] },
  "application/vnd.google-apps.fusiontable": {},
  "application/vnd.google-apps.jam": { "compressible": false, "extensions": ["gjam"] },
  "application/vnd.google-apps.mail-layout": {},
  "application/vnd.google-apps.map": { "compressible": false, "extensions": ["gmap"] },
  "application/vnd.google-apps.photo": {},
  "application/vnd.google-apps.presentation": { "compressible": false, "extensions": ["gslides"] },
  "application/vnd.google-apps.script": { "compressible": false, "extensions": ["gscript"] },
  "application/vnd.google-apps.shortcut": {},
  "application/vnd.google-apps.site": { "compressible": false, "extensions": ["gsite"] },
  "application/vnd.google-apps.spreadsheet": { "compressible": false, "extensions": ["gsheet"] },
  "application/vnd.google-apps.unknown": {},
  "application/vnd.google-apps.video": {},
  "application/vnd.google-earth.kml+xml": { "source": "iana", "compressible": true, "extensions": ["kml"] },
  "application/vnd.google-earth.kmz": { "source": "iana", "compressible": false, "extensions": ["kmz"] },
  "application/vnd.gov.sk.e-form+xml": { "source": "apache", "compressible": true },
  "application/vnd.gov.sk.e-form+zip": { "source": "iana", "compressible": false },
  "application/vnd.gov.sk.xmldatacontainer+xml": { "source": "iana", "compressible": true, "extensions": ["xdcf"] },
  "application/vnd.gpxsee.map+xml": { "source": "iana", "compressible": true },
  "application/vnd.grafeq": { "source": "iana", "extensions": ["gqf", "gqs"] },
  "application/vnd.gridmp": { "source": "iana" },
  "application/vnd.groove-account": { "source": "iana", "extensions": ["gac"] },
  "application/vnd.groove-help": { "source": "iana", "extensions": ["ghf"] },
  "application/vnd.groove-identity-message": { "source": "iana", "extensions": ["gim"] },
  "application/vnd.groove-injector": { "source": "iana", "extensions": ["grv"] },
  "application/vnd.groove-tool-message": { "source": "iana", "extensions": ["gtm"] },
  "application/vnd.groove-tool-template": { "source": "iana", "extensions": ["tpl"] },
  "application/vnd.groove-vcard": { "source": "iana", "extensions": ["vcg"] },
  "application/vnd.hal+json": { "source": "iana", "compressible": true },
  "application/vnd.hal+xml": { "source": "iana", "compressible": true, "extensions": ["hal"] },
  "application/vnd.handheld-entertainment+xml": { "source": "iana", "compressible": true, "extensions": ["zmm"] },
  "application/vnd.hbci": { "source": "iana", "extensions": ["hbci"] },
  "application/vnd.hc+json": { "source": "iana", "compressible": true },
  "application/vnd.hcl-bireports": { "source": "iana" },
  "application/vnd.hdt": { "source": "iana" },
  "application/vnd.heroku+json": { "source": "iana", "compressible": true },
  "application/vnd.hhe.lesson-player": { "source": "iana", "extensions": ["les"] },
  "application/vnd.hp-hpgl": { "source": "iana", "extensions": ["hpgl"] },
  "application/vnd.hp-hpid": { "source": "iana", "extensions": ["hpid"] },
  "application/vnd.hp-hps": { "source": "iana", "extensions": ["hps"] },
  "application/vnd.hp-jlyt": { "source": "iana", "extensions": ["jlt"] },
  "application/vnd.hp-pcl": { "source": "iana", "extensions": ["pcl"] },
  "application/vnd.hp-pclxl": { "source": "iana", "extensions": ["pclxl"] },
  "application/vnd.hsl": { "source": "iana" },
  "application/vnd.httphone": { "source": "iana" },
  "application/vnd.hydrostatix.sof-data": { "source": "iana", "extensions": ["sfd-hdstx"] },
  "application/vnd.hyper+json": { "source": "iana", "compressible": true },
  "application/vnd.hyper-item+json": { "source": "iana", "compressible": true },
  "application/vnd.hyperdrive+json": { "source": "iana", "compressible": true },
  "application/vnd.hzn-3d-crossword": { "source": "iana" },
  "application/vnd.ibm.afplinedata": { "source": "apache" },
  "application/vnd.ibm.electronic-media": { "source": "iana" },
  "application/vnd.ibm.minipay": { "source": "iana", "extensions": ["mpy"] },
  "application/vnd.ibm.modcap": { "source": "apache", "extensions": ["afp", "listafp", "list3820"] },
  "application/vnd.ibm.rights-management": { "source": "iana", "extensions": ["irm"] },
  "application/vnd.ibm.secure-container": { "source": "iana", "extensions": ["sc"] },
  "application/vnd.iccprofile": { "source": "iana", "extensions": ["icc", "icm"] },
  "application/vnd.ieee.1905": { "source": "iana" },
  "application/vnd.igloader": { "source": "iana", "extensions": ["igl"] },
  "application/vnd.imagemeter.folder+zip": { "source": "iana", "compressible": false },
  "application/vnd.imagemeter.image+zip": { "source": "iana", "compressible": false },
  "application/vnd.immervision-ivp": { "source": "iana", "extensions": ["ivp"] },
  "application/vnd.immervision-ivu": { "source": "iana", "extensions": ["ivu"] },
  "application/vnd.ims.imsccv1p1": { "source": "iana" },
  "application/vnd.ims.imsccv1p2": { "source": "iana" },
  "application/vnd.ims.imsccv1p3": { "source": "iana" },
  "application/vnd.ims.lis.v2.result+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy.id+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": { "source": "iana", "compressible": true },
  "application/vnd.informedcontrol.rms+xml": { "source": "iana", "compressible": true },
  "application/vnd.informix-visionary": { "source": "apache" },
  "application/vnd.infotech.project": { "source": "iana" },
  "application/vnd.infotech.project+xml": { "source": "iana", "compressible": true },
  "application/vnd.innopath.wamp.notification": { "source": "iana" },
  "application/vnd.insors.igm": { "source": "iana", "extensions": ["igm"] },
  "application/vnd.intercon.formnet": { "source": "iana", "extensions": ["xpw", "xpx"] },
  "application/vnd.intergeo": { "source": "iana", "extensions": ["i2g"] },
  "application/vnd.intertrust.digibox": { "source": "iana" },
  "application/vnd.intertrust.nncp": { "source": "iana" },
  "application/vnd.intu.qbo": { "source": "iana", "extensions": ["qbo"] },
  "application/vnd.intu.qfx": { "source": "iana", "extensions": ["qfx"] },
  "application/vnd.ipfs.ipns-record": { "source": "iana" },
  "application/vnd.ipld.car": { "source": "iana" },
  "application/vnd.ipld.dag-cbor": { "source": "iana" },
  "application/vnd.ipld.dag-json": { "source": "iana" },
  "application/vnd.ipld.raw": { "source": "iana" },
  "application/vnd.iptc.g2.catalogitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.conceptitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.knowledgeitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.packageitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.planningitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.ipunplugged.rcprofile": { "source": "iana", "extensions": ["rcprofile"] },
  "application/vnd.irepository.package+xml": { "source": "iana", "compressible": true, "extensions": ["irp"] },
  "application/vnd.is-xpr": { "source": "iana", "extensions": ["xpr"] },
  "application/vnd.isac.fcs": { "source": "iana", "extensions": ["fcs"] },
  "application/vnd.iso11783-10+zip": { "source": "iana", "compressible": false },
  "application/vnd.jam": { "source": "iana", "extensions": ["jam"] },
  "application/vnd.japannet-directory-service": { "source": "iana" },
  "application/vnd.japannet-jpnstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-payment-wakeup": { "source": "iana" },
  "application/vnd.japannet-registration": { "source": "iana" },
  "application/vnd.japannet-registration-wakeup": { "source": "iana" },
  "application/vnd.japannet-setstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-verification": { "source": "iana" },
  "application/vnd.japannet-verification-wakeup": { "source": "iana" },
  "application/vnd.jcp.javame.midlet-rms": { "source": "iana", "extensions": ["rms"] },
  "application/vnd.jisp": { "source": "iana", "extensions": ["jisp"] },
  "application/vnd.joost.joda-archive": { "source": "iana", "extensions": ["joda"] },
  "application/vnd.jsk.isdn-ngn": { "source": "iana" },
  "application/vnd.kahootz": { "source": "iana", "extensions": ["ktz", "ktr"] },
  "application/vnd.kde.karbon": { "source": "iana", "extensions": ["karbon"] },
  "application/vnd.kde.kchart": { "source": "iana", "extensions": ["chrt"] },
  "application/vnd.kde.kformula": { "source": "iana", "extensions": ["kfo"] },
  "application/vnd.kde.kivio": { "source": "iana", "extensions": ["flw"] },
  "application/vnd.kde.kontour": { "source": "iana", "extensions": ["kon"] },
  "application/vnd.kde.kpresenter": { "source": "iana", "extensions": ["kpr", "kpt"] },
  "application/vnd.kde.kspread": { "source": "iana", "extensions": ["ksp"] },
  "application/vnd.kde.kword": { "source": "iana", "extensions": ["kwd", "kwt"] },
  "application/vnd.kdl": { "source": "iana" },
  "application/vnd.kenameaapp": { "source": "iana", "extensions": ["htke"] },
  "application/vnd.keyman.kmp+zip": { "source": "iana", "compressible": false },
  "application/vnd.keyman.kmx": { "source": "iana" },
  "application/vnd.kidspiration": { "source": "iana", "extensions": ["kia"] },
  "application/vnd.kinar": { "source": "iana", "extensions": ["kne", "knp"] },
  "application/vnd.koan": { "source": "iana", "extensions": ["skp", "skd", "skt", "skm"] },
  "application/vnd.kodak-descriptor": { "source": "iana", "extensions": ["sse"] },
  "application/vnd.las": { "source": "iana" },
  "application/vnd.las.las+json": { "source": "iana", "compressible": true },
  "application/vnd.las.las+xml": { "source": "iana", "compressible": true, "extensions": ["lasxml"] },
  "application/vnd.laszip": { "source": "iana" },
  "application/vnd.ldev.productlicensing": { "source": "iana" },
  "application/vnd.leap+json": { "source": "iana", "compressible": true },
  "application/vnd.liberty-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.llamagraphics.life-balance.desktop": { "source": "iana", "extensions": ["lbd"] },
  "application/vnd.llamagraphics.life-balance.exchange+xml": { "source": "iana", "compressible": true, "extensions": ["lbe"] },
  "application/vnd.logipipe.circuit+zip": { "source": "iana", "compressible": false },
  "application/vnd.loom": { "source": "iana" },
  "application/vnd.lotus-1-2-3": { "source": "iana", "extensions": ["123"] },
  "application/vnd.lotus-approach": { "source": "iana", "extensions": ["apr"] },
  "application/vnd.lotus-freelance": { "source": "iana", "extensions": ["pre"] },
  "application/vnd.lotus-notes": { "source": "iana", "extensions": ["nsf"] },
  "application/vnd.lotus-organizer": { "source": "iana", "extensions": ["org"] },
  "application/vnd.lotus-screencam": { "source": "iana", "extensions": ["scm"] },
  "application/vnd.lotus-wordpro": { "source": "iana", "extensions": ["lwp"] },
  "application/vnd.macports.portpkg": { "source": "iana", "extensions": ["portpkg"] },
  "application/vnd.mapbox-vector-tile": { "source": "iana", "extensions": ["mvt"] },
  "application/vnd.marlin.drm.actiontoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.conftoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.license+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.mdcf": { "source": "iana" },
  "application/vnd.mason+json": { "source": "iana", "compressible": true },
  "application/vnd.maxar.archive.3tz+zip": { "source": "iana", "compressible": false },
  "application/vnd.maxmind.maxmind-db": { "source": "iana" },
  "application/vnd.mcd": { "source": "iana", "extensions": ["mcd"] },
  "application/vnd.mdl": { "source": "iana" },
  "application/vnd.mdl-mbsdf": { "source": "iana" },
  "application/vnd.medcalcdata": { "source": "iana", "extensions": ["mc1"] },
  "application/vnd.mediastation.cdkey": { "source": "iana", "extensions": ["cdkey"] },
  "application/vnd.medicalholodeck.recordxr": { "source": "iana" },
  "application/vnd.meridian-slingshot": { "source": "iana" },
  "application/vnd.mermaid": { "source": "iana" },
  "application/vnd.mfer": { "source": "iana", "extensions": ["mwf"] },
  "application/vnd.mfmp": { "source": "iana", "extensions": ["mfm"] },
  "application/vnd.micro+json": { "source": "iana", "compressible": true },
  "application/vnd.micrografx.flo": { "source": "iana", "extensions": ["flo"] },
  "application/vnd.micrografx.igx": { "source": "iana", "extensions": ["igx"] },
  "application/vnd.microsoft.portable-executable": { "source": "iana" },
  "application/vnd.microsoft.windows.thumbnail-cache": { "source": "iana" },
  "application/vnd.miele+json": { "source": "iana", "compressible": true },
  "application/vnd.mif": { "source": "iana", "extensions": ["mif"] },
  "application/vnd.minisoft-hp3000-save": { "source": "iana" },
  "application/vnd.mitsubishi.misty-guard.trustweb": { "source": "iana" },
  "application/vnd.mobius.daf": { "source": "iana", "extensions": ["daf"] },
  "application/vnd.mobius.dis": { "source": "iana", "extensions": ["dis"] },
  "application/vnd.mobius.mbk": { "source": "iana", "extensions": ["mbk"] },
  "application/vnd.mobius.mqy": { "source": "iana", "extensions": ["mqy"] },
  "application/vnd.mobius.msl": { "source": "iana", "extensions": ["msl"] },
  "application/vnd.mobius.plc": { "source": "iana", "extensions": ["plc"] },
  "application/vnd.mobius.txf": { "source": "iana", "extensions": ["txf"] },
  "application/vnd.modl": { "source": "iana" },
  "application/vnd.mophun.application": { "source": "iana", "extensions": ["mpn"] },
  "application/vnd.mophun.certificate": { "source": "iana", "extensions": ["mpc"] },
  "application/vnd.motorola.flexsuite": { "source": "iana" },
  "application/vnd.motorola.flexsuite.adsi": { "source": "iana" },
  "application/vnd.motorola.flexsuite.fis": { "source": "iana" },
  "application/vnd.motorola.flexsuite.gotap": { "source": "iana" },
  "application/vnd.motorola.flexsuite.kmr": { "source": "iana" },
  "application/vnd.motorola.flexsuite.ttc": { "source": "iana" },
  "application/vnd.motorola.flexsuite.wem": { "source": "iana" },
  "application/vnd.motorola.iprm": { "source": "iana" },
  "application/vnd.mozilla.xul+xml": { "source": "iana", "compressible": true, "extensions": ["xul"] },
  "application/vnd.ms-3mfdocument": { "source": "iana" },
  "application/vnd.ms-artgalry": { "source": "iana", "extensions": ["cil"] },
  "application/vnd.ms-asf": { "source": "iana" },
  "application/vnd.ms-cab-compressed": { "source": "iana", "extensions": ["cab"] },
  "application/vnd.ms-color.iccprofile": { "source": "apache" },
  "application/vnd.ms-excel": { "source": "iana", "compressible": false, "extensions": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"] },
  "application/vnd.ms-excel.addin.macroenabled.12": { "source": "iana", "extensions": ["xlam"] },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": { "source": "iana", "extensions": ["xlsb"] },
  "application/vnd.ms-excel.sheet.macroenabled.12": { "source": "iana", "extensions": ["xlsm"] },
  "application/vnd.ms-excel.template.macroenabled.12": { "source": "iana", "extensions": ["xltm"] },
  "application/vnd.ms-fontobject": { "source": "iana", "compressible": true, "extensions": ["eot"] },
  "application/vnd.ms-htmlhelp": { "source": "iana", "extensions": ["chm"] },
  "application/vnd.ms-ims": { "source": "iana", "extensions": ["ims"] },
  "application/vnd.ms-lrm": { "source": "iana", "extensions": ["lrm"] },
  "application/vnd.ms-office.activex+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-officetheme": { "source": "iana", "extensions": ["thmx"] },
  "application/vnd.ms-opentype": { "source": "apache", "compressible": true },
  "application/vnd.ms-outlook": { "compressible": false, "extensions": ["msg"] },
  "application/vnd.ms-package.obfuscated-opentype": { "source": "apache" },
  "application/vnd.ms-pki.seccat": { "source": "apache", "extensions": ["cat"] },
  "application/vnd.ms-pki.stl": { "source": "apache", "extensions": ["stl"] },
  "application/vnd.ms-playready.initiator+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-powerpoint": { "source": "iana", "compressible": false, "extensions": ["ppt", "pps", "pot"] },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": { "source": "iana", "extensions": ["ppam"] },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": { "source": "iana", "extensions": ["pptm"] },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": { "source": "iana", "extensions": ["sldm"] },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": { "source": "iana", "extensions": ["ppsm"] },
  "application/vnd.ms-powerpoint.template.macroenabled.12": { "source": "iana", "extensions": ["potm"] },
  "application/vnd.ms-printdevicecapabilities+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-printing.printticket+xml": { "source": "apache", "compressible": true },
  "application/vnd.ms-printschematicket+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-project": { "source": "iana", "extensions": ["mpp", "mpt"] },
  "application/vnd.ms-tnef": { "source": "iana" },
  "application/vnd.ms-visio.viewer": { "extensions": ["vdx"] },
  "application/vnd.ms-windows.devicepairing": { "source": "iana" },
  "application/vnd.ms-windows.nwprinting.oob": { "source": "iana" },
  "application/vnd.ms-windows.printerpairing": { "source": "iana" },
  "application/vnd.ms-windows.wsd.oob": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-resp": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-resp": { "source": "iana" },
  "application/vnd.ms-word.document.macroenabled.12": { "source": "iana", "extensions": ["docm"] },
  "application/vnd.ms-word.template.macroenabled.12": { "source": "iana", "extensions": ["dotm"] },
  "application/vnd.ms-works": { "source": "iana", "extensions": ["wps", "wks", "wcm", "wdb"] },
  "application/vnd.ms-wpl": { "source": "iana", "extensions": ["wpl"] },
  "application/vnd.ms-xpsdocument": { "source": "iana", "compressible": false, "extensions": ["xps"] },
  "application/vnd.msa-disk-image": { "source": "iana" },
  "application/vnd.mseq": { "source": "iana", "extensions": ["mseq"] },
  "application/vnd.msgpack": { "source": "iana" },
  "application/vnd.msign": { "source": "iana" },
  "application/vnd.multiad.creator": { "source": "iana" },
  "application/vnd.multiad.creator.cif": { "source": "iana" },
  "application/vnd.music-niff": { "source": "iana" },
  "application/vnd.musician": { "source": "iana", "extensions": ["mus"] },
  "application/vnd.muvee.style": { "source": "iana", "extensions": ["msty"] },
  "application/vnd.mynfc": { "source": "iana", "extensions": ["taglet"] },
  "application/vnd.nacamar.ybrid+json": { "source": "iana", "compressible": true },
  "application/vnd.nato.bindingdataobject+cbor": { "source": "iana" },
  "application/vnd.nato.bindingdataobject+json": { "source": "iana", "compressible": true },
  "application/vnd.nato.bindingdataobject+xml": { "source": "iana", "compressible": true, "extensions": ["bdo"] },
  "application/vnd.nato.openxmlformats-package.iepd+zip": { "source": "iana", "compressible": false },
  "application/vnd.ncd.control": { "source": "iana" },
  "application/vnd.ncd.reference": { "source": "iana" },
  "application/vnd.nearst.inv+json": { "source": "iana", "compressible": true },
  "application/vnd.nebumind.line": { "source": "iana" },
  "application/vnd.nervana": { "source": "iana" },
  "application/vnd.netfpx": { "source": "iana" },
  "application/vnd.neurolanguage.nlu": { "source": "iana", "extensions": ["nlu"] },
  "application/vnd.nimn": { "source": "iana" },
  "application/vnd.nintendo.nitro.rom": { "source": "iana" },
  "application/vnd.nintendo.snes.rom": { "source": "iana" },
  "application/vnd.nitf": { "source": "iana", "extensions": ["ntf", "nitf"] },
  "application/vnd.noblenet-directory": { "source": "iana", "extensions": ["nnd"] },
  "application/vnd.noblenet-sealer": { "source": "iana", "extensions": ["nns"] },
  "application/vnd.noblenet-web": { "source": "iana", "extensions": ["nnw"] },
  "application/vnd.nokia.catalogs": { "source": "iana" },
  "application/vnd.nokia.conml+wbxml": { "source": "iana" },
  "application/vnd.nokia.conml+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.iptv.config+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.isds-radio-presets": { "source": "iana" },
  "application/vnd.nokia.landmark+wbxml": { "source": "iana" },
  "application/vnd.nokia.landmark+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.landmarkcollection+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.n-gage.ac+xml": { "source": "iana", "compressible": true, "extensions": ["ac"] },
  "application/vnd.nokia.n-gage.data": { "source": "iana", "extensions": ["ngdat"] },
  "application/vnd.nokia.n-gage.symbian.install": { "source": "apache", "extensions": ["n-gage"] },
  "application/vnd.nokia.ncd": { "source": "iana" },
  "application/vnd.nokia.pcd+wbxml": { "source": "iana" },
  "application/vnd.nokia.pcd+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.radio-preset": { "source": "iana", "extensions": ["rpst"] },
  "application/vnd.nokia.radio-presets": { "source": "iana", "extensions": ["rpss"] },
  "application/vnd.novadigm.edm": { "source": "iana", "extensions": ["edm"] },
  "application/vnd.novadigm.edx": { "source": "iana", "extensions": ["edx"] },
  "application/vnd.novadigm.ext": { "source": "iana", "extensions": ["ext"] },
  "application/vnd.ntt-local.content-share": { "source": "iana" },
  "application/vnd.ntt-local.file-transfer": { "source": "iana" },
  "application/vnd.ntt-local.ogw_remote-access": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_remote": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_tcp_stream": { "source": "iana" },
  "application/vnd.oai.workflows": { "source": "iana" },
  "application/vnd.oai.workflows+json": { "source": "iana", "compressible": true },
  "application/vnd.oai.workflows+yaml": { "source": "iana" },
  "application/vnd.oasis.opendocument.base": { "source": "iana" },
  "application/vnd.oasis.opendocument.chart": { "source": "iana", "extensions": ["odc"] },
  "application/vnd.oasis.opendocument.chart-template": { "source": "iana", "extensions": ["otc"] },
  "application/vnd.oasis.opendocument.database": { "source": "apache", "extensions": ["odb"] },
  "application/vnd.oasis.opendocument.formula": { "source": "iana", "extensions": ["odf"] },
  "application/vnd.oasis.opendocument.formula-template": { "source": "iana", "extensions": ["odft"] },
  "application/vnd.oasis.opendocument.graphics": { "source": "iana", "compressible": false, "extensions": ["odg"] },
  "application/vnd.oasis.opendocument.graphics-template": { "source": "iana", "extensions": ["otg"] },
  "application/vnd.oasis.opendocument.image": { "source": "iana", "extensions": ["odi"] },
  "application/vnd.oasis.opendocument.image-template": { "source": "iana", "extensions": ["oti"] },
  "application/vnd.oasis.opendocument.presentation": { "source": "iana", "compressible": false, "extensions": ["odp"] },
  "application/vnd.oasis.opendocument.presentation-template": { "source": "iana", "extensions": ["otp"] },
  "application/vnd.oasis.opendocument.spreadsheet": { "source": "iana", "compressible": false, "extensions": ["ods"] },
  "application/vnd.oasis.opendocument.spreadsheet-template": { "source": "iana", "extensions": ["ots"] },
  "application/vnd.oasis.opendocument.text": { "source": "iana", "compressible": false, "extensions": ["odt"] },
  "application/vnd.oasis.opendocument.text-master": { "source": "iana", "extensions": ["odm"] },
  "application/vnd.oasis.opendocument.text-master-template": { "source": "iana" },
  "application/vnd.oasis.opendocument.text-template": { "source": "iana", "extensions": ["ott"] },
  "application/vnd.oasis.opendocument.text-web": { "source": "iana", "extensions": ["oth"] },
  "application/vnd.obn": { "source": "iana" },
  "application/vnd.ocf+cbor": { "source": "iana" },
  "application/vnd.oci.image.manifest.v1+json": { "source": "iana", "compressible": true },
  "application/vnd.oftn.l10n+json": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessdownload+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessstreaming+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.cspg-hexbinary": { "source": "iana" },
  "application/vnd.oipf.dae.svg+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.dae.xhtml+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.mippvcontrolmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.pae.gem": { "source": "iana" },
  "application/vnd.oipf.spdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.spdlist+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.ueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.userprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.olpc-sugar": { "source": "iana", "extensions": ["xo"] },
  "application/vnd.oma-scws-config": { "source": "iana" },
  "application/vnd.oma-scws-http-request": { "source": "iana" },
  "application/vnd.oma-scws-http-response": { "source": "iana" },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.drm-trigger+xml": { "source": "apache", "compressible": true },
  "application/vnd.oma.bcast.imd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.ltkm": { "source": "iana" },
  "application/vnd.oma.bcast.notification+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.provisioningtrigger": { "source": "iana" },
  "application/vnd.oma.bcast.sgboot": { "source": "iana" },
  "application/vnd.oma.bcast.sgdd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.sgdu": { "source": "iana" },
  "application/vnd.oma.bcast.simple-symbol-container": { "source": "iana" },
  "application/vnd.oma.bcast.smartcard-trigger+xml": { "source": "apache", "compressible": true },
  "application/vnd.oma.bcast.sprov+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.stkm": { "source": "iana" },
  "application/vnd.oma.cab-address-book+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-feature-handler+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-pcc+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-subs-invite+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-user-prefs+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.dcd": { "source": "iana" },
  "application/vnd.oma.dcdc": { "source": "iana" },
  "application/vnd.oma.dd2+xml": { "source": "iana", "compressible": true, "extensions": ["dd2"] },
  "application/vnd.oma.drm.risd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.group-usage-list+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+cbor": { "source": "iana" },
  "application/vnd.oma.lwm2m+json": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+tlv": { "source": "iana" },
  "application/vnd.oma.pal+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.detailed-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.final-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.groups+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.invocation-descriptor+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.optimized-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.push": { "source": "iana" },
  "application/vnd.oma.scidm.messages+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.xcap-directory+xml": { "source": "iana", "compressible": true },
  "application/vnd.omads-email+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-file+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-folder+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omaloc-supl-init": { "source": "iana" },
  "application/vnd.onepager": { "source": "iana" },
  "application/vnd.onepagertamp": { "source": "iana" },
  "application/vnd.onepagertamx": { "source": "iana" },
  "application/vnd.onepagertat": { "source": "iana" },
  "application/vnd.onepagertatp": { "source": "iana" },
  "application/vnd.onepagertatx": { "source": "iana" },
  "application/vnd.onvif.metadata": { "source": "iana" },
  "application/vnd.openblox.game+xml": { "source": "iana", "compressible": true, "extensions": ["obgx"] },
  "application/vnd.openblox.game-binary": { "source": "iana" },
  "application/vnd.openeye.oeb": { "source": "iana" },
  "application/vnd.openofficeorg.extension": { "source": "apache", "extensions": ["oxt"] },
  "application/vnd.openstreetmap.data+xml": { "source": "iana", "compressible": true, "extensions": ["osm"] },
  "application/vnd.opentimestamps.ots": { "source": "iana" },
  "application/vnd.openvpi.dspx+json": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawing+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": { "source": "iana", "compressible": false, "extensions": ["pptx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": { "source": "iana", "extensions": ["sldx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": { "source": "iana", "extensions": ["ppsx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.template": { "source": "iana", "extensions": ["potx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": { "source": "iana", "compressible": false, "extensions": ["xlsx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": { "source": "iana", "extensions": ["xltx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.theme+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.vmldrawing": { "source": "iana" },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": { "source": "iana", "compressible": false, "extensions": ["docx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": { "source": "iana", "extensions": ["dotx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.core-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.relationships+xml": { "source": "iana", "compressible": true },
  "application/vnd.oracle.resource+json": { "source": "iana", "compressible": true },
  "application/vnd.orange.indata": { "source": "iana" },
  "application/vnd.osa.netdeploy": { "source": "iana" },
  "application/vnd.osgeo.mapguide.package": { "source": "iana", "extensions": ["mgp"] },
  "application/vnd.osgi.bundle": { "source": "iana" },
  "application/vnd.osgi.dp": { "source": "iana", "extensions": ["dp"] },
  "application/vnd.osgi.subsystem": { "source": "iana", "extensions": ["esa"] },
  "application/vnd.otps.ct-kip+xml": { "source": "iana", "compressible": true },
  "application/vnd.oxli.countgraph": { "source": "iana" },
  "application/vnd.pagerduty+json": { "source": "iana", "compressible": true },
  "application/vnd.palm": { "source": "iana", "extensions": ["pdb", "pqa", "oprc"] },
  "application/vnd.panoply": { "source": "iana" },
  "application/vnd.paos.xml": { "source": "iana" },
  "application/vnd.patentdive": { "source": "iana" },
  "application/vnd.patientecommsdoc": { "source": "iana" },
  "application/vnd.pawaafile": { "source": "iana", "extensions": ["paw"] },
  "application/vnd.pcos": { "source": "iana" },
  "application/vnd.pg.format": { "source": "iana", "extensions": ["str"] },
  "application/vnd.pg.osasli": { "source": "iana", "extensions": ["ei6"] },
  "application/vnd.piaccess.application-licence": { "source": "iana" },
  "application/vnd.picsel": { "source": "iana", "extensions": ["efif"] },
  "application/vnd.pmi.widget": { "source": "iana", "extensions": ["wg"] },
  "application/vnd.poc.group-advertisement+xml": { "source": "iana", "compressible": true },
  "application/vnd.pocketlearn": { "source": "iana", "extensions": ["plf"] },
  "application/vnd.powerbuilder6": { "source": "iana", "extensions": ["pbd"] },
  "application/vnd.powerbuilder6-s": { "source": "iana" },
  "application/vnd.powerbuilder7": { "source": "iana" },
  "application/vnd.powerbuilder7-s": { "source": "iana" },
  "application/vnd.powerbuilder75": { "source": "iana" },
  "application/vnd.powerbuilder75-s": { "source": "iana" },
  "application/vnd.preminet": { "source": "iana" },
  "application/vnd.previewsystems.box": { "source": "iana", "extensions": ["box"] },
  "application/vnd.procrate.brushset": { "extensions": ["brushset"] },
  "application/vnd.procreate.brush": { "extensions": ["brush"] },
  "application/vnd.procreate.dream": { "extensions": ["drm"] },
  "application/vnd.proteus.magazine": { "source": "iana", "extensions": ["mgz"] },
  "application/vnd.psfs": { "source": "iana" },
  "application/vnd.pt.mundusmundi": { "source": "iana" },
  "application/vnd.publishare-delta-tree": { "source": "iana", "extensions": ["qps"] },
  "application/vnd.pvi.ptid1": { "source": "iana", "extensions": ["ptid"] },
  "application/vnd.pwg-multiplexed": { "source": "iana" },
  "application/vnd.pwg-xhtml-print+xml": { "source": "iana", "compressible": true, "extensions": ["xhtm"] },
  "application/vnd.qualcomm.brew-app-res": { "source": "iana" },
  "application/vnd.quarantainenet": { "source": "iana" },
  "application/vnd.quark.quarkxpress": { "source": "iana", "extensions": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"] },
  "application/vnd.quobject-quoxdocument": { "source": "iana" },
  "application/vnd.radisys.moml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conn+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-stream+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-base+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-group+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-speech+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-transform+xml": { "source": "iana", "compressible": true },
  "application/vnd.rainstor.data": { "source": "iana" },
  "application/vnd.rapid": { "source": "iana" },
  "application/vnd.rar": { "source": "iana", "extensions": ["rar"] },
  "application/vnd.realvnc.bed": { "source": "iana", "extensions": ["bed"] },
  "application/vnd.recordare.musicxml": { "source": "iana", "extensions": ["mxl"] },
  "application/vnd.recordare.musicxml+xml": { "source": "iana", "compressible": true, "extensions": ["musicxml"] },
  "application/vnd.relpipe": { "source": "iana" },
  "application/vnd.renlearn.rlprint": { "source": "iana" },
  "application/vnd.resilient.logic": { "source": "iana" },
  "application/vnd.restful+json": { "source": "iana", "compressible": true },
  "application/vnd.rig.cryptonote": { "source": "iana", "extensions": ["cryptonote"] },
  "application/vnd.rim.cod": { "source": "apache", "extensions": ["cod"] },
  "application/vnd.rn-realmedia": { "source": "apache", "extensions": ["rm"] },
  "application/vnd.rn-realmedia-vbr": { "source": "apache", "extensions": ["rmvb"] },
  "application/vnd.route66.link66+xml": { "source": "iana", "compressible": true, "extensions": ["link66"] },
  "application/vnd.rs-274x": { "source": "iana" },
  "application/vnd.ruckus.download": { "source": "iana" },
  "application/vnd.s3sms": { "source": "iana" },
  "application/vnd.sailingtracker.track": { "source": "iana", "extensions": ["st"] },
  "application/vnd.sar": { "source": "iana" },
  "application/vnd.sbm.cid": { "source": "iana" },
  "application/vnd.sbm.mid2": { "source": "iana" },
  "application/vnd.scribus": { "source": "iana" },
  "application/vnd.sealed.3df": { "source": "iana" },
  "application/vnd.sealed.csf": { "source": "iana" },
  "application/vnd.sealed.doc": { "source": "iana" },
  "application/vnd.sealed.eml": { "source": "iana" },
  "application/vnd.sealed.mht": { "source": "iana" },
  "application/vnd.sealed.net": { "source": "iana" },
  "application/vnd.sealed.ppt": { "source": "iana" },
  "application/vnd.sealed.tiff": { "source": "iana" },
  "application/vnd.sealed.xls": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.html": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.pdf": { "source": "iana" },
  "application/vnd.seemail": { "source": "iana", "extensions": ["see"] },
  "application/vnd.seis+json": { "source": "iana", "compressible": true },
  "application/vnd.sema": { "source": "iana", "extensions": ["sema"] },
  "application/vnd.semd": { "source": "iana", "extensions": ["semd"] },
  "application/vnd.semf": { "source": "iana", "extensions": ["semf"] },
  "application/vnd.shade-save-file": { "source": "iana" },
  "application/vnd.shana.informed.formdata": { "source": "iana", "extensions": ["ifm"] },
  "application/vnd.shana.informed.formtemplate": { "source": "iana", "extensions": ["itp"] },
  "application/vnd.shana.informed.interchange": { "source": "iana", "extensions": ["iif"] },
  "application/vnd.shana.informed.package": { "source": "iana", "extensions": ["ipk"] },
  "application/vnd.shootproof+json": { "source": "iana", "compressible": true },
  "application/vnd.shopkick+json": { "source": "iana", "compressible": true },
  "application/vnd.shp": { "source": "iana" },
  "application/vnd.shx": { "source": "iana" },
  "application/vnd.sigrok.session": { "source": "iana" },
  "application/vnd.simtech-mindmapper": { "source": "iana", "extensions": ["twd", "twds"] },
  "application/vnd.siren+json": { "source": "iana", "compressible": true },
  "application/vnd.sketchometry": { "source": "iana" },
  "application/vnd.smaf": { "source": "iana", "extensions": ["mmf"] },
  "application/vnd.smart.notebook": { "source": "iana" },
  "application/vnd.smart.teacher": { "source": "iana", "extensions": ["teacher"] },
  "application/vnd.smintio.portals.archive": { "source": "iana" },
  "application/vnd.snesdev-page-table": { "source": "iana" },
  "application/vnd.software602.filler.form+xml": { "source": "iana", "compressible": true, "extensions": ["fo"] },
  "application/vnd.software602.filler.form-xml-zip": { "source": "iana" },
  "application/vnd.solent.sdkm+xml": { "source": "iana", "compressible": true, "extensions": ["sdkm", "sdkd"] },
  "application/vnd.spotfire.dxp": { "source": "iana", "extensions": ["dxp"] },
  "application/vnd.spotfire.sfs": { "source": "iana", "extensions": ["sfs"] },
  "application/vnd.sqlite3": { "source": "iana" },
  "application/vnd.sss-cod": { "source": "iana" },
  "application/vnd.sss-dtf": { "source": "iana" },
  "application/vnd.sss-ntf": { "source": "iana" },
  "application/vnd.stardivision.calc": { "source": "apache", "extensions": ["sdc"] },
  "application/vnd.stardivision.draw": { "source": "apache", "extensions": ["sda"] },
  "application/vnd.stardivision.impress": { "source": "apache", "extensions": ["sdd"] },
  "application/vnd.stardivision.math": { "source": "apache", "extensions": ["smf"] },
  "application/vnd.stardivision.writer": { "source": "apache", "extensions": ["sdw", "vor"] },
  "application/vnd.stardivision.writer-global": { "source": "apache", "extensions": ["sgl"] },
  "application/vnd.stepmania.package": { "source": "iana", "extensions": ["smzip"] },
  "application/vnd.stepmania.stepchart": { "source": "iana", "extensions": ["sm"] },
  "application/vnd.street-stream": { "source": "iana" },
  "application/vnd.sun.wadl+xml": { "source": "iana", "compressible": true, "extensions": ["wadl"] },
  "application/vnd.sun.xml.calc": { "source": "apache", "extensions": ["sxc"] },
  "application/vnd.sun.xml.calc.template": { "source": "apache", "extensions": ["stc"] },
  "application/vnd.sun.xml.draw": { "source": "apache", "extensions": ["sxd"] },
  "application/vnd.sun.xml.draw.template": { "source": "apache", "extensions": ["std"] },
  "application/vnd.sun.xml.impress": { "source": "apache", "extensions": ["sxi"] },
  "application/vnd.sun.xml.impress.template": { "source": "apache", "extensions": ["sti"] },
  "application/vnd.sun.xml.math": { "source": "apache", "extensions": ["sxm"] },
  "application/vnd.sun.xml.writer": { "source": "apache", "extensions": ["sxw"] },
  "application/vnd.sun.xml.writer.global": { "source": "apache", "extensions": ["sxg"] },
  "application/vnd.sun.xml.writer.template": { "source": "apache", "extensions": ["stw"] },
  "application/vnd.sus-calendar": { "source": "iana", "extensions": ["sus", "susp"] },
  "application/vnd.svd": { "source": "iana", "extensions": ["svd"] },
  "application/vnd.swiftview-ics": { "source": "iana" },
  "application/vnd.sybyl.mol2": { "source": "iana" },
  "application/vnd.sycle+xml": { "source": "iana", "compressible": true },
  "application/vnd.syft+json": { "source": "iana", "compressible": true },
  "application/vnd.symbian.install": { "source": "apache", "extensions": ["sis", "sisx"] },
  "application/vnd.syncml+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xsm"] },
  "application/vnd.syncml.dm+wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["bdm"] },
  "application/vnd.syncml.dm+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xdm"] },
  "application/vnd.syncml.dm.notification": { "source": "iana" },
  "application/vnd.syncml.dmddf+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmddf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["ddf"] },
  "application/vnd.syncml.dmtnds+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmtnds+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.syncml.ds.notification": { "source": "iana" },
  "application/vnd.tableschema+json": { "source": "iana", "compressible": true },
  "application/vnd.tao.intent-module-archive": { "source": "iana", "extensions": ["tao"] },
  "application/vnd.tcpdump.pcap": { "source": "iana", "extensions": ["pcap", "cap", "dmp"] },
  "application/vnd.think-cell.ppttc+json": { "source": "iana", "compressible": true },
  "application/vnd.tmd.mediaflex.api+xml": { "source": "iana", "compressible": true },
  "application/vnd.tml": { "source": "iana" },
  "application/vnd.tmobile-livetv": { "source": "iana", "extensions": ["tmo"] },
  "application/vnd.tri.onesource": { "source": "iana" },
  "application/vnd.trid.tpt": { "source": "iana", "extensions": ["tpt"] },
  "application/vnd.triscape.mxs": { "source": "iana", "extensions": ["mxs"] },
  "application/vnd.trueapp": { "source": "iana", "extensions": ["tra"] },
  "application/vnd.truedoc": { "source": "iana" },
  "application/vnd.ubisoft.webplayer": { "source": "iana" },
  "application/vnd.ufdl": { "source": "iana", "extensions": ["ufd", "ufdl"] },
  "application/vnd.uic.osdm+json": { "source": "iana", "compressible": true },
  "application/vnd.uiq.theme": { "source": "iana", "extensions": ["utz"] },
  "application/vnd.umajin": { "source": "iana", "extensions": ["umj"] },
  "application/vnd.unity": { "source": "iana", "extensions": ["unityweb"] },
  "application/vnd.uoml+xml": { "source": "iana", "compressible": true, "extensions": ["uoml", "uo"] },
  "application/vnd.uplanet.alert": { "source": "iana" },
  "application/vnd.uplanet.alert-wbxml": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice-wbxml": { "source": "iana" },
  "application/vnd.uplanet.cacheop": { "source": "iana" },
  "application/vnd.uplanet.cacheop-wbxml": { "source": "iana" },
  "application/vnd.uplanet.channel": { "source": "iana" },
  "application/vnd.uplanet.channel-wbxml": { "source": "iana" },
  "application/vnd.uplanet.list": { "source": "iana" },
  "application/vnd.uplanet.list-wbxml": { "source": "iana" },
  "application/vnd.uplanet.listcmd": { "source": "iana" },
  "application/vnd.uplanet.listcmd-wbxml": { "source": "iana" },
  "application/vnd.uplanet.signal": { "source": "iana" },
  "application/vnd.uri-map": { "source": "iana" },
  "application/vnd.valve.source.material": { "source": "iana" },
  "application/vnd.vcx": { "source": "iana", "extensions": ["vcx"] },
  "application/vnd.vd-study": { "source": "iana" },
  "application/vnd.vectorworks": { "source": "iana" },
  "application/vnd.vel+json": { "source": "iana", "compressible": true },
  "application/vnd.veraison.tsm-report+cbor": { "source": "iana" },
  "application/vnd.veraison.tsm-report+json": { "source": "iana", "compressible": true },
  "application/vnd.verimatrix.vcas": { "source": "iana" },
  "application/vnd.veritone.aion+json": { "source": "iana", "compressible": true },
  "application/vnd.veryant.thin": { "source": "iana" },
  "application/vnd.ves.encrypted": { "source": "iana" },
  "application/vnd.vidsoft.vidconference": { "source": "iana" },
  "application/vnd.visio": { "source": "iana", "extensions": ["vsd", "vst", "vss", "vsw", "vsdx", "vtx"] },
  "application/vnd.visionary": { "source": "iana", "extensions": ["vis"] },
  "application/vnd.vividence.scriptfile": { "source": "iana" },
  "application/vnd.vocalshaper.vsp4": { "source": "iana" },
  "application/vnd.vsf": { "source": "iana", "extensions": ["vsf"] },
  "application/vnd.wap.sic": { "source": "iana" },
  "application/vnd.wap.slc": { "source": "iana" },
  "application/vnd.wap.wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["wbxml"] },
  "application/vnd.wap.wmlc": { "source": "iana", "extensions": ["wmlc"] },
  "application/vnd.wap.wmlscriptc": { "source": "iana", "extensions": ["wmlsc"] },
  "application/vnd.wasmflow.wafl": { "source": "iana" },
  "application/vnd.webturbo": { "source": "iana", "extensions": ["wtb"] },
  "application/vnd.wfa.dpp": { "source": "iana" },
  "application/vnd.wfa.p2p": { "source": "iana" },
  "application/vnd.wfa.wsc": { "source": "iana" },
  "application/vnd.windows.devicepairing": { "source": "iana" },
  "application/vnd.wmc": { "source": "iana" },
  "application/vnd.wmf.bootstrap": { "source": "iana" },
  "application/vnd.wolfram.mathematica": { "source": "iana" },
  "application/vnd.wolfram.mathematica.package": { "source": "iana" },
  "application/vnd.wolfram.player": { "source": "iana", "extensions": ["nbp"] },
  "application/vnd.wordlift": { "source": "iana" },
  "application/vnd.wordperfect": { "source": "iana", "extensions": ["wpd"] },
  "application/vnd.wqd": { "source": "iana", "extensions": ["wqd"] },
  "application/vnd.wrq-hp3000-labelled": { "source": "iana" },
  "application/vnd.wt.stf": { "source": "iana", "extensions": ["stf"] },
  "application/vnd.wv.csp+wbxml": { "source": "iana" },
  "application/vnd.wv.csp+xml": { "source": "iana", "compressible": true },
  "application/vnd.wv.ssp+xml": { "source": "iana", "compressible": true },
  "application/vnd.xacml+json": { "source": "iana", "compressible": true },
  "application/vnd.xara": { "source": "iana", "extensions": ["xar"] },
  "application/vnd.xarin.cpj": { "source": "iana" },
  "application/vnd.xecrets-encrypted": { "source": "iana" },
  "application/vnd.xfdl": { "source": "iana", "extensions": ["xfdl"] },
  "application/vnd.xfdl.webform": { "source": "iana" },
  "application/vnd.xmi+xml": { "source": "iana", "compressible": true },
  "application/vnd.xmpie.cpkg": { "source": "iana" },
  "application/vnd.xmpie.dpkg": { "source": "iana" },
  "application/vnd.xmpie.plan": { "source": "iana" },
  "application/vnd.xmpie.ppkg": { "source": "iana" },
  "application/vnd.xmpie.xlim": { "source": "iana" },
  "application/vnd.yamaha.hv-dic": { "source": "iana", "extensions": ["hvd"] },
  "application/vnd.yamaha.hv-script": { "source": "iana", "extensions": ["hvs"] },
  "application/vnd.yamaha.hv-voice": { "source": "iana", "extensions": ["hvp"] },
  "application/vnd.yamaha.openscoreformat": { "source": "iana", "extensions": ["osf"] },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": { "source": "iana", "compressible": true, "extensions": ["osfpvg"] },
  "application/vnd.yamaha.remote-setup": { "source": "iana" },
  "application/vnd.yamaha.smaf-audio": { "source": "iana", "extensions": ["saf"] },
  "application/vnd.yamaha.smaf-phrase": { "source": "iana", "extensions": ["spf"] },
  "application/vnd.yamaha.through-ngn": { "source": "iana" },
  "application/vnd.yamaha.tunnel-udpencap": { "source": "iana" },
  "application/vnd.yaoweme": { "source": "iana" },
  "application/vnd.yellowriver-custom-menu": { "source": "iana", "extensions": ["cmp"] },
  "application/vnd.zul": { "source": "iana", "extensions": ["zir", "zirz"] },
  "application/vnd.zzazz.deck+xml": { "source": "iana", "compressible": true, "extensions": ["zaz"] },
  "application/voicexml+xml": { "source": "iana", "compressible": true, "extensions": ["vxml"] },
  "application/voucher-cms+json": { "source": "iana", "compressible": true },
  "application/voucher-jws+json": { "source": "iana", "compressible": true },
  "application/vp": { "source": "iana" },
  "application/vp+cose": { "source": "iana" },
  "application/vp+jwt": { "source": "iana" },
  "application/vq-rtcpxr": { "source": "iana" },
  "application/wasm": { "source": "iana", "compressible": true, "extensions": ["wasm"] },
  "application/watcherinfo+xml": { "source": "iana", "compressible": true, "extensions": ["wif"] },
  "application/webpush-options+json": { "source": "iana", "compressible": true },
  "application/whoispp-query": { "source": "iana" },
  "application/whoispp-response": { "source": "iana" },
  "application/widget": { "source": "iana", "extensions": ["wgt"] },
  "application/winhlp": { "source": "apache", "extensions": ["hlp"] },
  "application/wita": { "source": "iana" },
  "application/wordperfect5.1": { "source": "iana" },
  "application/wsdl+xml": { "source": "iana", "compressible": true, "extensions": ["wsdl"] },
  "application/wspolicy+xml": { "source": "iana", "compressible": true, "extensions": ["wspolicy"] },
  "application/x-7z-compressed": { "source": "apache", "compressible": false, "extensions": ["7z"] },
  "application/x-abiword": { "source": "apache", "extensions": ["abw"] },
  "application/x-ace-compressed": { "source": "apache", "extensions": ["ace"] },
  "application/x-amf": { "source": "apache" },
  "application/x-apple-diskimage": { "source": "apache", "extensions": ["dmg"] },
  "application/x-arj": { "compressible": false, "extensions": ["arj"] },
  "application/x-authorware-bin": { "source": "apache", "extensions": ["aab", "x32", "u32", "vox"] },
  "application/x-authorware-map": { "source": "apache", "extensions": ["aam"] },
  "application/x-authorware-seg": { "source": "apache", "extensions": ["aas"] },
  "application/x-bcpio": { "source": "apache", "extensions": ["bcpio"] },
  "application/x-bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/x-bittorrent": { "source": "apache", "extensions": ["torrent"] },
  "application/x-blender": { "extensions": ["blend"] },
  "application/x-blorb": { "source": "apache", "extensions": ["blb", "blorb"] },
  "application/x-bzip": { "source": "apache", "compressible": false, "extensions": ["bz"] },
  "application/x-bzip2": { "source": "apache", "compressible": false, "extensions": ["bz2", "boz"] },
  "application/x-cbr": { "source": "apache", "extensions": ["cbr", "cba", "cbt", "cbz", "cb7"] },
  "application/x-cdlink": { "source": "apache", "extensions": ["vcd"] },
  "application/x-cfs-compressed": { "source": "apache", "extensions": ["cfs"] },
  "application/x-chat": { "source": "apache", "extensions": ["chat"] },
  "application/x-chess-pgn": { "source": "apache", "extensions": ["pgn"] },
  "application/x-chrome-extension": { "extensions": ["crx"] },
  "application/x-cocoa": { "source": "nginx", "extensions": ["cco"] },
  "application/x-compress": { "source": "apache" },
  "application/x-compressed": { "extensions": ["rar"] },
  "application/x-conference": { "source": "apache", "extensions": ["nsc"] },
  "application/x-cpio": { "source": "apache", "extensions": ["cpio"] },
  "application/x-csh": { "source": "apache", "extensions": ["csh"] },
  "application/x-deb": { "compressible": false },
  "application/x-debian-package": { "source": "apache", "extensions": ["deb", "udeb"] },
  "application/x-dgc-compressed": { "source": "apache", "extensions": ["dgc"] },
  "application/x-director": { "source": "apache", "extensions": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"] },
  "application/x-doom": { "source": "apache", "extensions": ["wad"] },
  "application/x-dtbncx+xml": { "source": "apache", "compressible": true, "extensions": ["ncx"] },
  "application/x-dtbook+xml": { "source": "apache", "compressible": true, "extensions": ["dtb"] },
  "application/x-dtbresource+xml": { "source": "apache", "compressible": true, "extensions": ["res"] },
  "application/x-dvi": { "source": "apache", "compressible": false, "extensions": ["dvi"] },
  "application/x-envoy": { "source": "apache", "extensions": ["evy"] },
  "application/x-eva": { "source": "apache", "extensions": ["eva"] },
  "application/x-font-bdf": { "source": "apache", "extensions": ["bdf"] },
  "application/x-font-dos": { "source": "apache" },
  "application/x-font-framemaker": { "source": "apache" },
  "application/x-font-ghostscript": { "source": "apache", "extensions": ["gsf"] },
  "application/x-font-libgrx": { "source": "apache" },
  "application/x-font-linux-psf": { "source": "apache", "extensions": ["psf"] },
  "application/x-font-pcf": { "source": "apache", "extensions": ["pcf"] },
  "application/x-font-snf": { "source": "apache", "extensions": ["snf"] },
  "application/x-font-speedo": { "source": "apache" },
  "application/x-font-sunos-news": { "source": "apache" },
  "application/x-font-type1": { "source": "apache", "extensions": ["pfa", "pfb", "pfm", "afm"] },
  "application/x-font-vfont": { "source": "apache" },
  "application/x-freearc": { "source": "apache", "extensions": ["arc"] },
  "application/x-futuresplash": { "source": "apache", "extensions": ["spl"] },
  "application/x-gca-compressed": { "source": "apache", "extensions": ["gca"] },
  "application/x-glulx": { "source": "apache", "extensions": ["ulx"] },
  "application/x-gnumeric": { "source": "apache", "extensions": ["gnumeric"] },
  "application/x-gramps-xml": { "source": "apache", "extensions": ["gramps"] },
  "application/x-gtar": { "source": "apache", "extensions": ["gtar"] },
  "application/x-gzip": { "source": "apache" },
  "application/x-hdf": { "source": "apache", "extensions": ["hdf"] },
  "application/x-httpd-php": { "compressible": true, "extensions": ["php"] },
  "application/x-install-instructions": { "source": "apache", "extensions": ["install"] },
  "application/x-ipynb+json": { "compressible": true, "extensions": ["ipynb"] },
  "application/x-iso9660-image": { "source": "apache", "extensions": ["iso"] },
  "application/x-iwork-keynote-sffkey": { "extensions": ["key"] },
  "application/x-iwork-numbers-sffnumbers": { "extensions": ["numbers"] },
  "application/x-iwork-pages-sffpages": { "extensions": ["pages"] },
  "application/x-java-archive-diff": { "source": "nginx", "extensions": ["jardiff"] },
  "application/x-java-jnlp-file": { "source": "apache", "compressible": false, "extensions": ["jnlp"] },
  "application/x-javascript": { "compressible": true },
  "application/x-keepass2": { "extensions": ["kdbx"] },
  "application/x-latex": { "source": "apache", "compressible": false, "extensions": ["latex"] },
  "application/x-lua-bytecode": { "extensions": ["luac"] },
  "application/x-lzh-compressed": { "source": "apache", "extensions": ["lzh", "lha"] },
  "application/x-makeself": { "source": "nginx", "extensions": ["run"] },
  "application/x-mie": { "source": "apache", "extensions": ["mie"] },
  "application/x-mobipocket-ebook": { "source": "apache", "extensions": ["prc", "mobi"] },
  "application/x-mpegurl": { "compressible": false },
  "application/x-ms-application": { "source": "apache", "extensions": ["application"] },
  "application/x-ms-shortcut": { "source": "apache", "extensions": ["lnk"] },
  "application/x-ms-wmd": { "source": "apache", "extensions": ["wmd"] },
  "application/x-ms-wmz": { "source": "apache", "extensions": ["wmz"] },
  "application/x-ms-xbap": { "source": "apache", "extensions": ["xbap"] },
  "application/x-msaccess": { "source": "apache", "extensions": ["mdb"] },
  "application/x-msbinder": { "source": "apache", "extensions": ["obd"] },
  "application/x-mscardfile": { "source": "apache", "extensions": ["crd"] },
  "application/x-msclip": { "source": "apache", "extensions": ["clp"] },
  "application/x-msdos-program": { "extensions": ["exe"] },
  "application/x-msdownload": { "source": "apache", "extensions": ["exe", "dll", "com", "bat", "msi"] },
  "application/x-msmediaview": { "source": "apache", "extensions": ["mvb", "m13", "m14"] },
  "application/x-msmetafile": { "source": "apache", "extensions": ["wmf", "wmz", "emf", "emz"] },
  "application/x-msmoney": { "source": "apache", "extensions": ["mny"] },
  "application/x-mspublisher": { "source": "apache", "extensions": ["pub"] },
  "application/x-msschedule": { "source": "apache", "extensions": ["scd"] },
  "application/x-msterminal": { "source": "apache", "extensions": ["trm"] },
  "application/x-mswrite": { "source": "apache", "extensions": ["wri"] },
  "application/x-netcdf": { "source": "apache", "extensions": ["nc", "cdf"] },
  "application/x-ns-proxy-autoconfig": { "compressible": true, "extensions": ["pac"] },
  "application/x-nzb": { "source": "apache", "extensions": ["nzb"] },
  "application/x-perl": { "source": "nginx", "extensions": ["pl", "pm"] },
  "application/x-pilot": { "source": "nginx", "extensions": ["prc", "pdb"] },
  "application/x-pkcs12": { "source": "apache", "compressible": false, "extensions": ["p12", "pfx"] },
  "application/x-pkcs7-certificates": { "source": "apache", "extensions": ["p7b", "spc"] },
  "application/x-pkcs7-certreqresp": { "source": "apache", "extensions": ["p7r"] },
  "application/x-pki-message": { "source": "iana" },
  "application/x-rar-compressed": { "source": "apache", "compressible": false, "extensions": ["rar"] },
  "application/x-redhat-package-manager": { "source": "nginx", "extensions": ["rpm"] },
  "application/x-research-info-systems": { "source": "apache", "extensions": ["ris"] },
  "application/x-sea": { "source": "nginx", "extensions": ["sea"] },
  "application/x-sh": { "source": "apache", "compressible": true, "extensions": ["sh"] },
  "application/x-shar": { "source": "apache", "extensions": ["shar"] },
  "application/x-shockwave-flash": { "source": "apache", "compressible": false, "extensions": ["swf"] },
  "application/x-silverlight-app": { "source": "apache", "extensions": ["xap"] },
  "application/x-sql": { "source": "apache", "extensions": ["sql"] },
  "application/x-stuffit": { "source": "apache", "compressible": false, "extensions": ["sit"] },
  "application/x-stuffitx": { "source": "apache", "extensions": ["sitx"] },
  "application/x-subrip": { "source": "apache", "extensions": ["srt"] },
  "application/x-sv4cpio": { "source": "apache", "extensions": ["sv4cpio"] },
  "application/x-sv4crc": { "source": "apache", "extensions": ["sv4crc"] },
  "application/x-t3vm-image": { "source": "apache", "extensions": ["t3"] },
  "application/x-tads": { "source": "apache", "extensions": ["gam"] },
  "application/x-tar": { "source": "apache", "compressible": true, "extensions": ["tar"] },
  "application/x-tcl": { "source": "apache", "extensions": ["tcl", "tk"] },
  "application/x-tex": { "source": "apache", "extensions": ["tex"] },
  "application/x-tex-tfm": { "source": "apache", "extensions": ["tfm"] },
  "application/x-texinfo": { "source": "apache", "extensions": ["texinfo", "texi"] },
  "application/x-tgif": { "source": "apache", "extensions": ["obj"] },
  "application/x-ustar": { "source": "apache", "extensions": ["ustar"] },
  "application/x-virtualbox-hdd": { "compressible": true, "extensions": ["hdd"] },
  "application/x-virtualbox-ova": { "compressible": true, "extensions": ["ova"] },
  "application/x-virtualbox-ovf": { "compressible": true, "extensions": ["ovf"] },
  "application/x-virtualbox-vbox": { "compressible": true, "extensions": ["vbox"] },
  "application/x-virtualbox-vbox-extpack": { "compressible": false, "extensions": ["vbox-extpack"] },
  "application/x-virtualbox-vdi": { "compressible": true, "extensions": ["vdi"] },
  "application/x-virtualbox-vhd": { "compressible": true, "extensions": ["vhd"] },
  "application/x-virtualbox-vmdk": { "compressible": true, "extensions": ["vmdk"] },
  "application/x-wais-source": { "source": "apache", "extensions": ["src"] },
  "application/x-web-app-manifest+json": { "compressible": true, "extensions": ["webapp"] },
  "application/x-www-form-urlencoded": { "source": "iana", "compressible": true },
  "application/x-x509-ca-cert": { "source": "iana", "extensions": ["der", "crt", "pem"] },
  "application/x-x509-ca-ra-cert": { "source": "iana" },
  "application/x-x509-next-ca-cert": { "source": "iana" },
  "application/x-xfig": { "source": "apache", "extensions": ["fig"] },
  "application/x-xliff+xml": { "source": "apache", "compressible": true, "extensions": ["xlf"] },
  "application/x-xpinstall": { "source": "apache", "compressible": false, "extensions": ["xpi"] },
  "application/x-xz": { "source": "apache", "extensions": ["xz"] },
  "application/x-zip-compressed": { "extensions": ["zip"] },
  "application/x-zmachine": { "source": "apache", "extensions": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"] },
  "application/x400-bp": { "source": "iana" },
  "application/xacml+xml": { "source": "iana", "compressible": true },
  "application/xaml+xml": { "source": "apache", "compressible": true, "extensions": ["xaml"] },
  "application/xcap-att+xml": { "source": "iana", "compressible": true, "extensions": ["xav"] },
  "application/xcap-caps+xml": { "source": "iana", "compressible": true, "extensions": ["xca"] },
  "application/xcap-diff+xml": { "source": "iana", "compressible": true, "extensions": ["xdf"] },
  "application/xcap-el+xml": { "source": "iana", "compressible": true, "extensions": ["xel"] },
  "application/xcap-error+xml": { "source": "iana", "compressible": true },
  "application/xcap-ns+xml": { "source": "iana", "compressible": true, "extensions": ["xns"] },
  "application/xcon-conference-info+xml": { "source": "iana", "compressible": true },
  "application/xcon-conference-info-diff+xml": { "source": "iana", "compressible": true },
  "application/xenc+xml": { "source": "iana", "compressible": true, "extensions": ["xenc"] },
  "application/xfdf": { "source": "iana", "extensions": ["xfdf"] },
  "application/xhtml+xml": { "source": "iana", "compressible": true, "extensions": ["xhtml", "xht"] },
  "application/xhtml-voice+xml": { "source": "apache", "compressible": true },
  "application/xliff+xml": { "source": "iana", "compressible": true, "extensions": ["xlf"] },
  "application/xml": { "source": "iana", "compressible": true, "extensions": ["xml", "xsl", "xsd", "rng"] },
  "application/xml-dtd": { "source": "iana", "compressible": true, "extensions": ["dtd"] },
  "application/xml-external-parsed-entity": { "source": "iana" },
  "application/xml-patch+xml": { "source": "iana", "compressible": true },
  "application/xmpp+xml": { "source": "iana", "compressible": true },
  "application/xop+xml": { "source": "iana", "compressible": true, "extensions": ["xop"] },
  "application/xproc+xml": { "source": "apache", "compressible": true, "extensions": ["xpl"] },
  "application/xslt+xml": { "source": "iana", "compressible": true, "extensions": ["xsl", "xslt"] },
  "application/xspf+xml": { "source": "apache", "compressible": true, "extensions": ["xspf"] },
  "application/xv+xml": { "source": "iana", "compressible": true, "extensions": ["mxml", "xhvml", "xvml", "xvm"] },
  "application/yaml": { "source": "iana" },
  "application/yang": { "source": "iana", "extensions": ["yang"] },
  "application/yang-data+cbor": { "source": "iana" },
  "application/yang-data+json": { "source": "iana", "compressible": true },
  "application/yang-data+xml": { "source": "iana", "compressible": true },
  "application/yang-patch+json": { "source": "iana", "compressible": true },
  "application/yang-patch+xml": { "source": "iana", "compressible": true },
  "application/yang-sid+json": { "source": "iana", "compressible": true },
  "application/yin+xml": { "source": "iana", "compressible": true, "extensions": ["yin"] },
  "application/zip": { "source": "iana", "compressible": false, "extensions": ["zip"] },
  "application/zip+dotlottie": { "extensions": ["lottie"] },
  "application/zlib": { "source": "iana" },
  "application/zstd": { "source": "iana" },
  "audio/1d-interleaved-parityfec": { "source": "iana" },
  "audio/32kadpcm": { "source": "iana" },
  "audio/3gpp": { "source": "iana", "compressible": false, "extensions": ["3gpp"] },
  "audio/3gpp2": { "source": "iana" },
  "audio/aac": { "source": "iana", "extensions": ["adts", "aac"] },
  "audio/ac3": { "source": "iana" },
  "audio/adpcm": { "source": "apache", "extensions": ["adp"] },
  "audio/amr": { "source": "iana", "extensions": ["amr"] },
  "audio/amr-wb": { "source": "iana" },
  "audio/amr-wb+": { "source": "iana" },
  "audio/aptx": { "source": "iana" },
  "audio/asc": { "source": "iana" },
  "audio/atrac-advanced-lossless": { "source": "iana" },
  "audio/atrac-x": { "source": "iana" },
  "audio/atrac3": { "source": "iana" },
  "audio/basic": { "source": "iana", "compressible": false, "extensions": ["au", "snd"] },
  "audio/bv16": { "source": "iana" },
  "audio/bv32": { "source": "iana" },
  "audio/clearmode": { "source": "iana" },
  "audio/cn": { "source": "iana" },
  "audio/dat12": { "source": "iana" },
  "audio/dls": { "source": "iana" },
  "audio/dsr-es201108": { "source": "iana" },
  "audio/dsr-es202050": { "source": "iana" },
  "audio/dsr-es202211": { "source": "iana" },
  "audio/dsr-es202212": { "source": "iana" },
  "audio/dv": { "source": "iana" },
  "audio/dvi4": { "source": "iana" },
  "audio/eac3": { "source": "iana" },
  "audio/encaprtp": { "source": "iana" },
  "audio/evrc": { "source": "iana" },
  "audio/evrc-qcp": { "source": "iana" },
  "audio/evrc0": { "source": "iana" },
  "audio/evrc1": { "source": "iana" },
  "audio/evrcb": { "source": "iana" },
  "audio/evrcb0": { "source": "iana" },
  "audio/evrcb1": { "source": "iana" },
  "audio/evrcnw": { "source": "iana" },
  "audio/evrcnw0": { "source": "iana" },
  "audio/evrcnw1": { "source": "iana" },
  "audio/evrcwb": { "source": "iana" },
  "audio/evrcwb0": { "source": "iana" },
  "audio/evrcwb1": { "source": "iana" },
  "audio/evs": { "source": "iana" },
  "audio/flac": { "source": "iana" },
  "audio/flexfec": { "source": "iana" },
  "audio/fwdred": { "source": "iana" },
  "audio/g711-0": { "source": "iana" },
  "audio/g719": { "source": "iana" },
  "audio/g722": { "source": "iana" },
  "audio/g7221": { "source": "iana" },
  "audio/g723": { "source": "iana" },
  "audio/g726-16": { "source": "iana" },
  "audio/g726-24": { "source": "iana" },
  "audio/g726-32": { "source": "iana" },
  "audio/g726-40": { "source": "iana" },
  "audio/g728": { "source": "iana" },
  "audio/g729": { "source": "iana" },
  "audio/g7291": { "source": "iana" },
  "audio/g729d": { "source": "iana" },
  "audio/g729e": { "source": "iana" },
  "audio/gsm": { "source": "iana" },
  "audio/gsm-efr": { "source": "iana" },
  "audio/gsm-hr-08": { "source": "iana" },
  "audio/ilbc": { "source": "iana" },
  "audio/ip-mr_v2.5": { "source": "iana" },
  "audio/isac": { "source": "apache" },
  "audio/l16": { "source": "iana" },
  "audio/l20": { "source": "iana" },
  "audio/l24": { "source": "iana", "compressible": false },
  "audio/l8": { "source": "iana" },
  "audio/lpc": { "source": "iana" },
  "audio/matroska": { "source": "iana" },
  "audio/melp": { "source": "iana" },
  "audio/melp1200": { "source": "iana" },
  "audio/melp2400": { "source": "iana" },
  "audio/melp600": { "source": "iana" },
  "audio/mhas": { "source": "iana" },
  "audio/midi": { "source": "apache", "extensions": ["mid", "midi", "kar", "rmi"] },
  "audio/midi-clip": { "source": "iana" },
  "audio/mobile-xmf": { "source": "iana", "extensions": ["mxmf"] },
  "audio/mp3": { "compressible": false, "extensions": ["mp3"] },
  "audio/mp4": { "source": "iana", "compressible": false, "extensions": ["m4a", "mp4a", "m4b"] },
  "audio/mp4a-latm": { "source": "iana" },
  "audio/mpa": { "source": "iana" },
  "audio/mpa-robust": { "source": "iana" },
  "audio/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"] },
  "audio/mpeg4-generic": { "source": "iana" },
  "audio/musepack": { "source": "apache" },
  "audio/ogg": { "source": "iana", "compressible": false, "extensions": ["oga", "ogg", "spx", "opus"] },
  "audio/opus": { "source": "iana" },
  "audio/parityfec": { "source": "iana" },
  "audio/pcma": { "source": "iana" },
  "audio/pcma-wb": { "source": "iana" },
  "audio/pcmu": { "source": "iana" },
  "audio/pcmu-wb": { "source": "iana" },
  "audio/prs.sid": { "source": "iana" },
  "audio/qcelp": { "source": "iana" },
  "audio/raptorfec": { "source": "iana" },
  "audio/red": { "source": "iana" },
  "audio/rtp-enc-aescm128": { "source": "iana" },
  "audio/rtp-midi": { "source": "iana" },
  "audio/rtploopback": { "source": "iana" },
  "audio/rtx": { "source": "iana" },
  "audio/s3m": { "source": "apache", "extensions": ["s3m"] },
  "audio/scip": { "source": "iana" },
  "audio/silk": { "source": "apache", "extensions": ["sil"] },
  "audio/smv": { "source": "iana" },
  "audio/smv-qcp": { "source": "iana" },
  "audio/smv0": { "source": "iana" },
  "audio/sofa": { "source": "iana" },
  "audio/sp-midi": { "source": "iana" },
  "audio/speex": { "source": "iana" },
  "audio/t140c": { "source": "iana" },
  "audio/t38": { "source": "iana" },
  "audio/telephone-event": { "source": "iana" },
  "audio/tetra_acelp": { "source": "iana" },
  "audio/tetra_acelp_bb": { "source": "iana" },
  "audio/tone": { "source": "iana" },
  "audio/tsvcis": { "source": "iana" },
  "audio/uemclip": { "source": "iana" },
  "audio/ulpfec": { "source": "iana" },
  "audio/usac": { "source": "iana" },
  "audio/vdvi": { "source": "iana" },
  "audio/vmr-wb": { "source": "iana" },
  "audio/vnd.3gpp.iufp": { "source": "iana" },
  "audio/vnd.4sb": { "source": "iana" },
  "audio/vnd.audiokoz": { "source": "iana" },
  "audio/vnd.celp": { "source": "iana" },
  "audio/vnd.cisco.nse": { "source": "iana" },
  "audio/vnd.cmles.radio-events": { "source": "iana" },
  "audio/vnd.cns.anp1": { "source": "iana" },
  "audio/vnd.cns.inf1": { "source": "iana" },
  "audio/vnd.dece.audio": { "source": "iana", "extensions": ["uva", "uvva"] },
  "audio/vnd.digital-winds": { "source": "iana", "extensions": ["eol"] },
  "audio/vnd.dlna.adts": { "source": "iana" },
  "audio/vnd.dolby.heaac.1": { "source": "iana" },
  "audio/vnd.dolby.heaac.2": { "source": "iana" },
  "audio/vnd.dolby.mlp": { "source": "iana" },
  "audio/vnd.dolby.mps": { "source": "iana" },
  "audio/vnd.dolby.pl2": { "source": "iana" },
  "audio/vnd.dolby.pl2x": { "source": "iana" },
  "audio/vnd.dolby.pl2z": { "source": "iana" },
  "audio/vnd.dolby.pulse.1": { "source": "iana" },
  "audio/vnd.dra": { "source": "iana", "extensions": ["dra"] },
  "audio/vnd.dts": { "source": "iana", "extensions": ["dts"] },
  "audio/vnd.dts.hd": { "source": "iana", "extensions": ["dtshd"] },
  "audio/vnd.dts.uhd": { "source": "iana" },
  "audio/vnd.dvb.file": { "source": "iana" },
  "audio/vnd.everad.plj": { "source": "iana" },
  "audio/vnd.hns.audio": { "source": "iana" },
  "audio/vnd.lucent.voice": { "source": "iana", "extensions": ["lvp"] },
  "audio/vnd.ms-playready.media.pya": { "source": "iana", "extensions": ["pya"] },
  "audio/vnd.nokia.mobile-xmf": { "source": "iana" },
  "audio/vnd.nortel.vbk": { "source": "iana" },
  "audio/vnd.nuera.ecelp4800": { "source": "iana", "extensions": ["ecelp4800"] },
  "audio/vnd.nuera.ecelp7470": { "source": "iana", "extensions": ["ecelp7470"] },
  "audio/vnd.nuera.ecelp9600": { "source": "iana", "extensions": ["ecelp9600"] },
  "audio/vnd.octel.sbc": { "source": "iana" },
  "audio/vnd.presonus.multitrack": { "source": "iana" },
  "audio/vnd.qcelp": { "source": "apache" },
  "audio/vnd.rhetorex.32kadpcm": { "source": "iana" },
  "audio/vnd.rip": { "source": "iana", "extensions": ["rip"] },
  "audio/vnd.rn-realaudio": { "compressible": false },
  "audio/vnd.sealedmedia.softseal.mpeg": { "source": "iana" },
  "audio/vnd.vmx.cvsd": { "source": "iana" },
  "audio/vnd.wave": { "compressible": false },
  "audio/vorbis": { "source": "iana", "compressible": false },
  "audio/vorbis-config": { "source": "iana" },
  "audio/wav": { "compressible": false, "extensions": ["wav"] },
  "audio/wave": { "compressible": false, "extensions": ["wav"] },
  "audio/webm": { "source": "apache", "compressible": false, "extensions": ["weba"] },
  "audio/x-aac": { "source": "apache", "compressible": false, "extensions": ["aac"] },
  "audio/x-aiff": { "source": "apache", "extensions": ["aif", "aiff", "aifc"] },
  "audio/x-caf": { "source": "apache", "compressible": false, "extensions": ["caf"] },
  "audio/x-flac": { "source": "apache", "extensions": ["flac"] },
  "audio/x-m4a": { "source": "nginx", "extensions": ["m4a"] },
  "audio/x-matroska": { "source": "apache", "extensions": ["mka"] },
  "audio/x-mpegurl": { "source": "apache", "extensions": ["m3u"] },
  "audio/x-ms-wax": { "source": "apache", "extensions": ["wax"] },
  "audio/x-ms-wma": { "source": "apache", "extensions": ["wma"] },
  "audio/x-pn-realaudio": { "source": "apache", "extensions": ["ram", "ra"] },
  "audio/x-pn-realaudio-plugin": { "source": "apache", "extensions": ["rmp"] },
  "audio/x-realaudio": { "source": "nginx", "extensions": ["ra"] },
  "audio/x-tta": { "source": "apache" },
  "audio/x-wav": { "source": "apache", "extensions": ["wav"] },
  "audio/xm": { "source": "apache", "extensions": ["xm"] },
  "chemical/x-cdx": { "source": "apache", "extensions": ["cdx"] },
  "chemical/x-cif": { "source": "apache", "extensions": ["cif"] },
  "chemical/x-cmdf": { "source": "apache", "extensions": ["cmdf"] },
  "chemical/x-cml": { "source": "apache", "extensions": ["cml"] },
  "chemical/x-csml": { "source": "apache", "extensions": ["csml"] },
  "chemical/x-pdb": { "source": "apache" },
  "chemical/x-xyz": { "source": "apache", "extensions": ["xyz"] },
  "font/collection": { "source": "iana", "extensions": ["ttc"] },
  "font/otf": { "source": "iana", "compressible": true, "extensions": ["otf"] },
  "font/sfnt": { "source": "iana" },
  "font/ttf": { "source": "iana", "compressible": true, "extensions": ["ttf"] },
  "font/woff": { "source": "iana", "extensions": ["woff"] },
  "font/woff2": { "source": "iana", "extensions": ["woff2"] },
  "image/aces": { "source": "iana", "extensions": ["exr"] },
  "image/apng": { "source": "iana", "compressible": false, "extensions": ["apng"] },
  "image/avci": { "source": "iana", "extensions": ["avci"] },
  "image/avcs": { "source": "iana", "extensions": ["avcs"] },
  "image/avif": { "source": "iana", "compressible": false, "extensions": ["avif"] },
  "image/bmp": { "source": "iana", "compressible": true, "extensions": ["bmp", "dib"] },
  "image/cgm": { "source": "iana", "extensions": ["cgm"] },
  "image/dicom-rle": { "source": "iana", "extensions": ["drle"] },
  "image/dpx": { "source": "iana", "extensions": ["dpx"] },
  "image/emf": { "source": "iana", "extensions": ["emf"] },
  "image/fits": { "source": "iana", "extensions": ["fits"] },
  "image/g3fax": { "source": "iana", "extensions": ["g3"] },
  "image/gif": { "source": "iana", "compressible": false, "extensions": ["gif"] },
  "image/heic": { "source": "iana", "extensions": ["heic"] },
  "image/heic-sequence": { "source": "iana", "extensions": ["heics"] },
  "image/heif": { "source": "iana", "extensions": ["heif"] },
  "image/heif-sequence": { "source": "iana", "extensions": ["heifs"] },
  "image/hej2k": { "source": "iana", "extensions": ["hej2"] },
  "image/ief": { "source": "iana", "extensions": ["ief"] },
  "image/j2c": { "source": "iana" },
  "image/jaii": { "source": "iana", "extensions": ["jaii"] },
  "image/jais": { "source": "iana", "extensions": ["jais"] },
  "image/jls": { "source": "iana", "extensions": ["jls"] },
  "image/jp2": { "source": "iana", "compressible": false, "extensions": ["jp2", "jpg2"] },
  "image/jpeg": { "source": "iana", "compressible": false, "extensions": ["jpg", "jpeg", "jpe"] },
  "image/jph": { "source": "iana", "extensions": ["jph"] },
  "image/jphc": { "source": "iana", "extensions": ["jhc"] },
  "image/jpm": { "source": "iana", "compressible": false, "extensions": ["jpm", "jpgm"] },
  "image/jpx": { "source": "iana", "compressible": false, "extensions": ["jpx", "jpf"] },
  "image/jxl": { "source": "iana", "extensions": ["jxl"] },
  "image/jxr": { "source": "iana", "extensions": ["jxr"] },
  "image/jxra": { "source": "iana", "extensions": ["jxra"] },
  "image/jxrs": { "source": "iana", "extensions": ["jxrs"] },
  "image/jxs": { "source": "iana", "extensions": ["jxs"] },
  "image/jxsc": { "source": "iana", "extensions": ["jxsc"] },
  "image/jxsi": { "source": "iana", "extensions": ["jxsi"] },
  "image/jxss": { "source": "iana", "extensions": ["jxss"] },
  "image/ktx": { "source": "iana", "extensions": ["ktx"] },
  "image/ktx2": { "source": "iana", "extensions": ["ktx2"] },
  "image/naplps": { "source": "iana" },
  "image/pjpeg": { "compressible": false, "extensions": ["jfif"] },
  "image/png": { "source": "iana", "compressible": false, "extensions": ["png"] },
  "image/prs.btif": { "source": "iana", "extensions": ["btif", "btf"] },
  "image/prs.pti": { "source": "iana", "extensions": ["pti"] },
  "image/pwg-raster": { "source": "iana" },
  "image/sgi": { "source": "apache", "extensions": ["sgi"] },
  "image/svg+xml": { "source": "iana", "compressible": true, "extensions": ["svg", "svgz"] },
  "image/t38": { "source": "iana", "extensions": ["t38"] },
  "image/tiff": { "source": "iana", "compressible": false, "extensions": ["tif", "tiff"] },
  "image/tiff-fx": { "source": "iana", "extensions": ["tfx"] },
  "image/vnd.adobe.photoshop": { "source": "iana", "compressible": true, "extensions": ["psd"] },
  "image/vnd.airzip.accelerator.azv": { "source": "iana", "extensions": ["azv"] },
  "image/vnd.clip": { "source": "iana" },
  "image/vnd.cns.inf2": { "source": "iana" },
  "image/vnd.dece.graphic": { "source": "iana", "extensions": ["uvi", "uvvi", "uvg", "uvvg"] },
  "image/vnd.djvu": { "source": "iana", "extensions": ["djvu", "djv"] },
  "image/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "image/vnd.dwg": { "source": "iana", "extensions": ["dwg"] },
  "image/vnd.dxf": { "source": "iana", "extensions": ["dxf"] },
  "image/vnd.fastbidsheet": { "source": "iana", "extensions": ["fbs"] },
  "image/vnd.fpx": { "source": "iana", "extensions": ["fpx"] },
  "image/vnd.fst": { "source": "iana", "extensions": ["fst"] },
  "image/vnd.fujixerox.edmics-mmr": { "source": "iana", "extensions": ["mmr"] },
  "image/vnd.fujixerox.edmics-rlc": { "source": "iana", "extensions": ["rlc"] },
  "image/vnd.globalgraphics.pgb": { "source": "iana" },
  "image/vnd.microsoft.icon": { "source": "iana", "compressible": true, "extensions": ["ico"] },
  "image/vnd.mix": { "source": "iana" },
  "image/vnd.mozilla.apng": { "source": "iana" },
  "image/vnd.ms-dds": { "compressible": true, "extensions": ["dds"] },
  "image/vnd.ms-modi": { "source": "iana", "extensions": ["mdi"] },
  "image/vnd.ms-photo": { "source": "apache", "extensions": ["wdp"] },
  "image/vnd.net-fpx": { "source": "iana", "extensions": ["npx"] },
  "image/vnd.pco.b16": { "source": "iana", "extensions": ["b16"] },
  "image/vnd.radiance": { "source": "iana" },
  "image/vnd.sealed.png": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.gif": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.jpg": { "source": "iana" },
  "image/vnd.svf": { "source": "iana" },
  "image/vnd.tencent.tap": { "source": "iana", "extensions": ["tap"] },
  "image/vnd.valve.source.texture": { "source": "iana", "extensions": ["vtf"] },
  "image/vnd.wap.wbmp": { "source": "iana", "extensions": ["wbmp"] },
  "image/vnd.xiff": { "source": "iana", "extensions": ["xif"] },
  "image/vnd.zbrush.pcx": { "source": "iana", "extensions": ["pcx"] },
  "image/webp": { "source": "iana", "extensions": ["webp"] },
  "image/wmf": { "source": "iana", "extensions": ["wmf"] },
  "image/x-3ds": { "source": "apache", "extensions": ["3ds"] },
  "image/x-adobe-dng": { "extensions": ["dng"] },
  "image/x-cmu-raster": { "source": "apache", "extensions": ["ras"] },
  "image/x-cmx": { "source": "apache", "extensions": ["cmx"] },
  "image/x-emf": { "source": "iana" },
  "image/x-freehand": { "source": "apache", "extensions": ["fh", "fhc", "fh4", "fh5", "fh7"] },
  "image/x-icon": { "source": "apache", "compressible": true, "extensions": ["ico"] },
  "image/x-jng": { "source": "nginx", "extensions": ["jng"] },
  "image/x-mrsid-image": { "source": "apache", "extensions": ["sid"] },
  "image/x-ms-bmp": { "source": "nginx", "compressible": true, "extensions": ["bmp"] },
  "image/x-pcx": { "source": "apache", "extensions": ["pcx"] },
  "image/x-pict": { "source": "apache", "extensions": ["pic", "pct"] },
  "image/x-portable-anymap": { "source": "apache", "extensions": ["pnm"] },
  "image/x-portable-bitmap": { "source": "apache", "extensions": ["pbm"] },
  "image/x-portable-graymap": { "source": "apache", "extensions": ["pgm"] },
  "image/x-portable-pixmap": { "source": "apache", "extensions": ["ppm"] },
  "image/x-rgb": { "source": "apache", "extensions": ["rgb"] },
  "image/x-tga": { "source": "apache", "extensions": ["tga"] },
  "image/x-wmf": { "source": "iana" },
  "image/x-xbitmap": { "source": "apache", "extensions": ["xbm"] },
  "image/x-xcf": { "compressible": false },
  "image/x-xpixmap": { "source": "apache", "extensions": ["xpm"] },
  "image/x-xwindowdump": { "source": "apache", "extensions": ["xwd"] },
  "message/bhttp": { "source": "iana" },
  "message/cpim": { "source": "iana" },
  "message/delivery-status": { "source": "iana" },
  "message/disposition-notification": { "source": "iana", "extensions": ["disposition-notification"] },
  "message/external-body": { "source": "iana" },
  "message/feedback-report": { "source": "iana" },
  "message/global": { "source": "iana", "extensions": ["u8msg"] },
  "message/global-delivery-status": { "source": "iana", "extensions": ["u8dsn"] },
  "message/global-disposition-notification": { "source": "iana", "extensions": ["u8mdn"] },
  "message/global-headers": { "source": "iana", "extensions": ["u8hdr"] },
  "message/http": { "source": "iana", "compressible": false },
  "message/imdn+xml": { "source": "iana", "compressible": true },
  "message/mls": { "source": "iana" },
  "message/news": { "source": "apache" },
  "message/ohttp-req": { "source": "iana" },
  "message/ohttp-res": { "source": "iana" },
  "message/partial": { "source": "iana", "compressible": false },
  "message/rfc822": { "source": "iana", "compressible": true, "extensions": ["eml", "mime", "mht", "mhtml"] },
  "message/s-http": { "source": "apache" },
  "message/sip": { "source": "iana" },
  "message/sipfrag": { "source": "iana" },
  "message/tracking-status": { "source": "iana" },
  "message/vnd.si.simp": { "source": "apache" },
  "message/vnd.wfa.wsc": { "source": "iana", "extensions": ["wsc"] },
  "model/3mf": { "source": "iana", "extensions": ["3mf"] },
  "model/e57": { "source": "iana" },
  "model/gltf+json": { "source": "iana", "compressible": true, "extensions": ["gltf"] },
  "model/gltf-binary": { "source": "iana", "compressible": true, "extensions": ["glb"] },
  "model/iges": { "source": "iana", "compressible": false, "extensions": ["igs", "iges"] },
  "model/jt": { "source": "iana", "extensions": ["jt"] },
  "model/mesh": { "source": "iana", "compressible": false, "extensions": ["msh", "mesh", "silo"] },
  "model/mtl": { "source": "iana", "extensions": ["mtl"] },
  "model/obj": { "source": "iana", "extensions": ["obj"] },
  "model/prc": { "source": "iana", "extensions": ["prc"] },
  "model/step": { "source": "iana", "extensions": ["step", "stp", "stpnc", "p21", "210"] },
  "model/step+xml": { "source": "iana", "compressible": true, "extensions": ["stpx"] },
  "model/step+zip": { "source": "iana", "compressible": false, "extensions": ["stpz"] },
  "model/step-xml+zip": { "source": "iana", "compressible": false, "extensions": ["stpxz"] },
  "model/stl": { "source": "iana", "extensions": ["stl"] },
  "model/u3d": { "source": "iana", "extensions": ["u3d"] },
  "model/vnd.bary": { "source": "iana", "extensions": ["bary"] },
  "model/vnd.cld": { "source": "iana", "extensions": ["cld"] },
  "model/vnd.collada+xml": { "source": "iana", "compressible": true, "extensions": ["dae"] },
  "model/vnd.dwf": { "source": "iana", "extensions": ["dwf"] },
  "model/vnd.flatland.3dml": { "source": "iana" },
  "model/vnd.gdl": { "source": "iana", "extensions": ["gdl"] },
  "model/vnd.gs-gdl": { "source": "apache" },
  "model/vnd.gs.gdl": { "source": "iana" },
  "model/vnd.gtw": { "source": "iana", "extensions": ["gtw"] },
  "model/vnd.moml+xml": { "source": "iana", "compressible": true },
  "model/vnd.mts": { "source": "iana", "extensions": ["mts"] },
  "model/vnd.opengex": { "source": "iana", "extensions": ["ogex"] },
  "model/vnd.parasolid.transmit.binary": { "source": "iana", "extensions": ["x_b"] },
  "model/vnd.parasolid.transmit.text": { "source": "iana", "extensions": ["x_t"] },
  "model/vnd.pytha.pyox": { "source": "iana", "extensions": ["pyo", "pyox"] },
  "model/vnd.rosette.annotated-data-model": { "source": "iana" },
  "model/vnd.sap.vds": { "source": "iana", "extensions": ["vds"] },
  "model/vnd.usda": { "source": "iana", "extensions": ["usda"] },
  "model/vnd.usdz+zip": { "source": "iana", "compressible": false, "extensions": ["usdz"] },
  "model/vnd.valve.source.compiled-map": { "source": "iana", "extensions": ["bsp"] },
  "model/vnd.vtu": { "source": "iana", "extensions": ["vtu"] },
  "model/vrml": { "source": "iana", "compressible": false, "extensions": ["wrl", "vrml"] },
  "model/x3d+binary": { "source": "apache", "compressible": false, "extensions": ["x3db", "x3dbz"] },
  "model/x3d+fastinfoset": { "source": "iana", "extensions": ["x3db"] },
  "model/x3d+vrml": { "source": "apache", "compressible": false, "extensions": ["x3dv", "x3dvz"] },
  "model/x3d+xml": { "source": "iana", "compressible": true, "extensions": ["x3d", "x3dz"] },
  "model/x3d-vrml": { "source": "iana", "extensions": ["x3dv"] },
  "multipart/alternative": { "source": "iana", "compressible": false },
  "multipart/appledouble": { "source": "iana" },
  "multipart/byteranges": { "source": "iana" },
  "multipart/digest": { "source": "iana" },
  "multipart/encrypted": { "source": "iana", "compressible": false },
  "multipart/form-data": { "source": "iana", "compressible": false },
  "multipart/header-set": { "source": "iana" },
  "multipart/mixed": { "source": "iana" },
  "multipart/multilingual": { "source": "iana" },
  "multipart/parallel": { "source": "iana" },
  "multipart/related": { "source": "iana", "compressible": false },
  "multipart/report": { "source": "iana" },
  "multipart/signed": { "source": "iana", "compressible": false },
  "multipart/vnd.bint.med-plus": { "source": "iana" },
  "multipart/voice-message": { "source": "iana" },
  "multipart/x-mixed-replace": { "source": "iana" },
  "text/1d-interleaved-parityfec": { "source": "iana" },
  "text/cache-manifest": { "source": "iana", "compressible": true, "extensions": ["appcache", "manifest"] },
  "text/calendar": { "source": "iana", "extensions": ["ics", "ifb"] },
  "text/calender": { "compressible": true },
  "text/cmd": { "compressible": true },
  "text/coffeescript": { "extensions": ["coffee", "litcoffee"] },
  "text/cql": { "source": "iana" },
  "text/cql-expression": { "source": "iana" },
  "text/cql-identifier": { "source": "iana" },
  "text/css": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["css"] },
  "text/csv": { "source": "iana", "compressible": true, "extensions": ["csv"] },
  "text/csv-schema": { "source": "iana" },
  "text/directory": { "source": "iana" },
  "text/dns": { "source": "iana" },
  "text/ecmascript": { "source": "apache" },
  "text/encaprtp": { "source": "iana" },
  "text/enriched": { "source": "iana" },
  "text/fhirpath": { "source": "iana" },
  "text/flexfec": { "source": "iana" },
  "text/fwdred": { "source": "iana" },
  "text/gff3": { "source": "iana" },
  "text/grammar-ref-list": { "source": "iana" },
  "text/hl7v2": { "source": "iana" },
  "text/html": { "source": "iana", "compressible": true, "extensions": ["html", "htm", "shtml"] },
  "text/jade": { "extensions": ["jade"] },
  "text/javascript": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["js", "mjs"] },
  "text/jcr-cnd": { "source": "iana" },
  "text/jsx": { "compressible": true, "extensions": ["jsx"] },
  "text/less": { "compressible": true, "extensions": ["less"] },
  "text/markdown": { "source": "iana", "compressible": true, "extensions": ["md", "markdown"] },
  "text/mathml": { "source": "nginx", "extensions": ["mml"] },
  "text/mdx": { "compressible": true, "extensions": ["mdx"] },
  "text/mizar": { "source": "iana" },
  "text/n3": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["n3"] },
  "text/parameters": { "source": "iana", "charset": "UTF-8" },
  "text/parityfec": { "source": "iana" },
  "text/plain": { "source": "iana", "compressible": true, "extensions": ["txt", "text", "conf", "def", "list", "log", "in", "ini"] },
  "text/provenance-notation": { "source": "iana", "charset": "UTF-8" },
  "text/prs.fallenstein.rst": { "source": "iana" },
  "text/prs.lines.tag": { "source": "iana", "extensions": ["dsc"] },
  "text/prs.prop.logic": { "source": "iana" },
  "text/prs.texi": { "source": "iana" },
  "text/raptorfec": { "source": "iana" },
  "text/red": { "source": "iana" },
  "text/rfc822-headers": { "source": "iana" },
  "text/richtext": { "source": "iana", "compressible": true, "extensions": ["rtx"] },
  "text/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "text/rtp-enc-aescm128": { "source": "iana" },
  "text/rtploopback": { "source": "iana" },
  "text/rtx": { "source": "iana" },
  "text/sgml": { "source": "iana", "extensions": ["sgml", "sgm"] },
  "text/shaclc": { "source": "iana" },
  "text/shex": { "source": "iana", "extensions": ["shex"] },
  "text/slim": { "extensions": ["slim", "slm"] },
  "text/spdx": { "source": "iana", "extensions": ["spdx"] },
  "text/strings": { "source": "iana" },
  "text/stylus": { "extensions": ["stylus", "styl"] },
  "text/t140": { "source": "iana" },
  "text/tab-separated-values": { "source": "iana", "compressible": true, "extensions": ["tsv"] },
  "text/troff": { "source": "iana", "extensions": ["t", "tr", "roff", "man", "me", "ms"] },
  "text/turtle": { "source": "iana", "charset": "UTF-8", "extensions": ["ttl"] },
  "text/ulpfec": { "source": "iana" },
  "text/uri-list": { "source": "iana", "compressible": true, "extensions": ["uri", "uris", "urls"] },
  "text/vcard": { "source": "iana", "compressible": true, "extensions": ["vcard"] },
  "text/vnd.a": { "source": "iana" },
  "text/vnd.abc": { "source": "iana" },
  "text/vnd.ascii-art": { "source": "iana" },
  "text/vnd.curl": { "source": "iana", "extensions": ["curl"] },
  "text/vnd.curl.dcurl": { "source": "apache", "extensions": ["dcurl"] },
  "text/vnd.curl.mcurl": { "source": "apache", "extensions": ["mcurl"] },
  "text/vnd.curl.scurl": { "source": "apache", "extensions": ["scurl"] },
  "text/vnd.debian.copyright": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.dmclientscript": { "source": "iana" },
  "text/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "text/vnd.esmertec.theme-descriptor": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.exchangeable": { "source": "iana" },
  "text/vnd.familysearch.gedcom": { "source": "iana", "extensions": ["ged"] },
  "text/vnd.ficlab.flt": { "source": "iana" },
  "text/vnd.fly": { "source": "iana", "extensions": ["fly"] },
  "text/vnd.fmi.flexstor": { "source": "iana", "extensions": ["flx"] },
  "text/vnd.gml": { "source": "iana" },
  "text/vnd.graphviz": { "source": "iana", "extensions": ["gv"] },
  "text/vnd.hans": { "source": "iana" },
  "text/vnd.hgl": { "source": "iana" },
  "text/vnd.in3d.3dml": { "source": "iana", "extensions": ["3dml"] },
  "text/vnd.in3d.spot": { "source": "iana", "extensions": ["spot"] },
  "text/vnd.iptc.newsml": { "source": "iana" },
  "text/vnd.iptc.nitf": { "source": "iana" },
  "text/vnd.latex-z": { "source": "iana" },
  "text/vnd.motorola.reflex": { "source": "iana" },
  "text/vnd.ms-mediapackage": { "source": "iana" },
  "text/vnd.net2phone.commcenter.command": { "source": "iana" },
  "text/vnd.radisys.msml-basic-layout": { "source": "iana" },
  "text/vnd.senx.warpscript": { "source": "iana" },
  "text/vnd.si.uricatalogue": { "source": "apache" },
  "text/vnd.sosi": { "source": "iana" },
  "text/vnd.sun.j2me.app-descriptor": { "source": "iana", "charset": "UTF-8", "extensions": ["jad"] },
  "text/vnd.trolltech.linguist": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.vcf": { "source": "iana" },
  "text/vnd.wap.si": { "source": "iana" },
  "text/vnd.wap.sl": { "source": "iana" },
  "text/vnd.wap.wml": { "source": "iana", "extensions": ["wml"] },
  "text/vnd.wap.wmlscript": { "source": "iana", "extensions": ["wmls"] },
  "text/vnd.zoo.kcl": { "source": "iana" },
  "text/vtt": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["vtt"] },
  "text/wgsl": { "source": "iana", "extensions": ["wgsl"] },
  "text/x-asm": { "source": "apache", "extensions": ["s", "asm"] },
  "text/x-c": { "source": "apache", "extensions": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"] },
  "text/x-component": { "source": "nginx", "extensions": ["htc"] },
  "text/x-fortran": { "source": "apache", "extensions": ["f", "for", "f77", "f90"] },
  "text/x-gwt-rpc": { "compressible": true },
  "text/x-handlebars-template": { "extensions": ["hbs"] },
  "text/x-java-source": { "source": "apache", "extensions": ["java"] },
  "text/x-jquery-tmpl": { "compressible": true },
  "text/x-lua": { "extensions": ["lua"] },
  "text/x-markdown": { "compressible": true, "extensions": ["mkd"] },
  "text/x-nfo": { "source": "apache", "extensions": ["nfo"] },
  "text/x-opml": { "source": "apache", "extensions": ["opml"] },
  "text/x-org": { "compressible": true, "extensions": ["org"] },
  "text/x-pascal": { "source": "apache", "extensions": ["p", "pas"] },
  "text/x-processing": { "compressible": true, "extensions": ["pde"] },
  "text/x-sass": { "extensions": ["sass"] },
  "text/x-scss": { "extensions": ["scss"] },
  "text/x-setext": { "source": "apache", "extensions": ["etx"] },
  "text/x-sfv": { "source": "apache", "extensions": ["sfv"] },
  "text/x-suse-ymp": { "compressible": true, "extensions": ["ymp"] },
  "text/x-uuencode": { "source": "apache", "extensions": ["uu"] },
  "text/x-vcalendar": { "source": "apache", "extensions": ["vcs"] },
  "text/x-vcard": { "source": "apache", "extensions": ["vcf"] },
  "text/xml": { "source": "iana", "compressible": true, "extensions": ["xml"] },
  "text/xml-external-parsed-entity": { "source": "iana" },
  "text/yaml": { "compressible": true, "extensions": ["yaml", "yml"] },
  "video/1d-interleaved-parityfec": { "source": "iana" },
  "video/3gpp": { "source": "iana", "extensions": ["3gp", "3gpp"] },
  "video/3gpp-tt": { "source": "iana" },
  "video/3gpp2": { "source": "iana", "extensions": ["3g2"] },
  "video/av1": { "source": "iana" },
  "video/bmpeg": { "source": "iana" },
  "video/bt656": { "source": "iana" },
  "video/celb": { "source": "iana" },
  "video/dv": { "source": "iana" },
  "video/encaprtp": { "source": "iana" },
  "video/evc": { "source": "iana" },
  "video/ffv1": { "source": "iana" },
  "video/flexfec": { "source": "iana" },
  "video/h261": { "source": "iana", "extensions": ["h261"] },
  "video/h263": { "source": "iana", "extensions": ["h263"] },
  "video/h263-1998": { "source": "iana" },
  "video/h263-2000": { "source": "iana" },
  "video/h264": { "source": "iana", "extensions": ["h264"] },
  "video/h264-rcdo": { "source": "iana" },
  "video/h264-svc": { "source": "iana" },
  "video/h265": { "source": "iana" },
  "video/h266": { "source": "iana" },
  "video/iso.segment": { "source": "iana", "extensions": ["m4s"] },
  "video/jpeg": { "source": "iana", "extensions": ["jpgv"] },
  "video/jpeg2000": { "source": "iana" },
  "video/jpm": { "source": "apache", "extensions": ["jpm", "jpgm"] },
  "video/jxsv": { "source": "iana" },
  "video/lottie+json": { "source": "iana", "compressible": true },
  "video/matroska": { "source": "iana" },
  "video/matroska-3d": { "source": "iana" },
  "video/mj2": { "source": "iana", "extensions": ["mj2", "mjp2"] },
  "video/mp1s": { "source": "iana" },
  "video/mp2p": { "source": "iana" },
  "video/mp2t": { "source": "iana", "extensions": ["ts", "m2t", "m2ts", "mts"] },
  "video/mp4": { "source": "iana", "compressible": false, "extensions": ["mp4", "mp4v", "mpg4"] },
  "video/mp4v-es": { "source": "iana" },
  "video/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpeg", "mpg", "mpe", "m1v", "m2v"] },
  "video/mpeg4-generic": { "source": "iana" },
  "video/mpv": { "source": "iana" },
  "video/nv": { "source": "iana" },
  "video/ogg": { "source": "iana", "compressible": false, "extensions": ["ogv"] },
  "video/parityfec": { "source": "iana" },
  "video/pointer": { "source": "iana" },
  "video/quicktime": { "source": "iana", "compressible": false, "extensions": ["qt", "mov"] },
  "video/raptorfec": { "source": "iana" },
  "video/raw": { "source": "iana" },
  "video/rtp-enc-aescm128": { "source": "iana" },
  "video/rtploopback": { "source": "iana" },
  "video/rtx": { "source": "iana" },
  "video/scip": { "source": "iana" },
  "video/smpte291": { "source": "iana" },
  "video/smpte292m": { "source": "iana" },
  "video/ulpfec": { "source": "iana" },
  "video/vc1": { "source": "iana" },
  "video/vc2": { "source": "iana" },
  "video/vnd.cctv": { "source": "iana" },
  "video/vnd.dece.hd": { "source": "iana", "extensions": ["uvh", "uvvh"] },
  "video/vnd.dece.mobile": { "source": "iana", "extensions": ["uvm", "uvvm"] },
  "video/vnd.dece.mp4": { "source": "iana" },
  "video/vnd.dece.pd": { "source": "iana", "extensions": ["uvp", "uvvp"] },
  "video/vnd.dece.sd": { "source": "iana", "extensions": ["uvs", "uvvs"] },
  "video/vnd.dece.video": { "source": "iana", "extensions": ["uvv", "uvvv"] },
  "video/vnd.directv.mpeg": { "source": "iana" },
  "video/vnd.directv.mpeg-tts": { "source": "iana" },
  "video/vnd.dlna.mpeg-tts": { "source": "iana" },
  "video/vnd.dvb.file": { "source": "iana", "extensions": ["dvb"] },
  "video/vnd.fvt": { "source": "iana", "extensions": ["fvt"] },
  "video/vnd.hns.video": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.ttsavc": { "source": "iana" },
  "video/vnd.iptvforum.ttsmpeg2": { "source": "iana" },
  "video/vnd.motorola.video": { "source": "iana" },
  "video/vnd.motorola.videop": { "source": "iana" },
  "video/vnd.mpegurl": { "source": "iana", "extensions": ["mxu", "m4u"] },
  "video/vnd.ms-playready.media.pyv": { "source": "iana", "extensions": ["pyv"] },
  "video/vnd.nokia.interleaved-multimedia": { "source": "iana" },
  "video/vnd.nokia.mp4vr": { "source": "iana" },
  "video/vnd.nokia.videovoip": { "source": "iana" },
  "video/vnd.objectvideo": { "source": "iana" },
  "video/vnd.planar": { "source": "iana" },
  "video/vnd.radgamettools.bink": { "source": "iana" },
  "video/vnd.radgamettools.smacker": { "source": "apache" },
  "video/vnd.sealed.mpeg1": { "source": "iana" },
  "video/vnd.sealed.mpeg4": { "source": "iana" },
  "video/vnd.sealed.swf": { "source": "iana" },
  "video/vnd.sealedmedia.softseal.mov": { "source": "iana" },
  "video/vnd.uvvu.mp4": { "source": "iana", "extensions": ["uvu", "uvvu"] },
  "video/vnd.vivo": { "source": "iana", "extensions": ["viv"] },
  "video/vnd.youtube.yt": { "source": "iana" },
  "video/vp8": { "source": "iana" },
  "video/vp9": { "source": "iana" },
  "video/webm": { "source": "apache", "compressible": false, "extensions": ["webm"] },
  "video/x-f4v": { "source": "apache", "extensions": ["f4v"] },
  "video/x-fli": { "source": "apache", "extensions": ["fli"] },
  "video/x-flv": { "source": "apache", "compressible": false, "extensions": ["flv"] },
  "video/x-m4v": { "source": "apache", "extensions": ["m4v"] },
  "video/x-matroska": { "source": "apache", "compressible": false, "extensions": ["mkv", "mk3d", "mks"] },
  "video/x-mng": { "source": "apache", "extensions": ["mng"] },
  "video/x-ms-asf": { "source": "apache", "extensions": ["asf", "asx"] },
  "video/x-ms-vob": { "source": "apache", "extensions": ["vob"] },
  "video/x-ms-wm": { "source": "apache", "extensions": ["wm"] },
  "video/x-ms-wmv": { "source": "apache", "compressible": false, "extensions": ["wmv"] },
  "video/x-ms-wmx": { "source": "apache", "extensions": ["wmx"] },
  "video/x-ms-wvx": { "source": "apache", "extensions": ["wvx"] },
  "video/x-msvideo": { "source": "apache", "extensions": ["avi"] },
  "video/x-sgi-movie": { "source": "apache", "extensions": ["movie"] },
  "video/x-smv": { "source": "apache", "extensions": ["smv"] },
  "x-conference/x-cooltalk": { "source": "apache", "extensions": ["ice"] },
  "x-shader/x-fragment": { "compressible": true },
  "x-shader/x-vertex": { "compressible": true }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var mimeDb;
var hasRequiredMimeDb;
function requireMimeDb() {
  if (hasRequiredMimeDb) return mimeDb;
  hasRequiredMimeDb = 1;
  mimeDb = require$$0$1;
  return mimeDb;
}
var mimeScore;
var hasRequiredMimeScore;
function requireMimeScore() {
  if (hasRequiredMimeScore) return mimeScore;
  hasRequiredMimeScore = 1;
  var FACET_SCORES = {
    "prs.": 100,
    "x-": 200,
    "x.": 300,
    "vnd.": 400,
    default: 900
  };
  var SOURCE_SCORES = {
    nginx: 10,
    apache: 20,
    iana: 40,
    default: 30
    // definitions added by `jshttp/mime-db` project?
  };
  var TYPE_SCORES = {
    // prefer application/xml over text/xml
    // prefer application/rtf over text/rtf
    application: 1,
    // prefer font/woff over application/font-woff
    font: 2,
    default: 0
  };
  mimeScore = function mimeScore2(mimeType, source = "default") {
    if (mimeType === "application/octet-stream") {
      return 0;
    }
    const [type2, subtype] = mimeType.split("/");
    const facet = subtype.replace(/(\.|x-).*/, "$1");
    const facetScore = FACET_SCORES[facet] || FACET_SCORES.default;
    const sourceScore = SOURCE_SCORES[source] || SOURCE_SCORES.default;
    const typeScore = TYPE_SCORES[type2] || TYPE_SCORES.default;
    const lengthScore = 1 - mimeType.length / 100;
    return facetScore + sourceScore + typeScore + lengthScore;
  };
  return mimeScore;
}
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredMimeTypes;
function requireMimeTypes() {
  if (hasRequiredMimeTypes) return mimeTypes;
  hasRequiredMimeTypes = 1;
  (function(exports) {
    var db = requireMimeDb();
    var extname = require$$1$3.extname;
    var mimeScore2 = requireMimeScore();
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset2;
    exports.charsets = { lookup: charset2 };
    exports.contentType = contentType2;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup;
    exports.types = /* @__PURE__ */ Object.create(null);
    exports._extensionConflicts = [];
    populateMaps(exports.extensions, exports.types);
    function charset2(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType2(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset3 = exports.charset(mime);
        if (charset3) mime += "; charset=" + charset3.toLowerCase();
      }
      return mime;
    }
    function extension(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path2) {
      if (!path2 || typeof path2 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path2).toLowerCase().slice(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      Object.keys(db).forEach(function forEachMimeType(type2) {
        var mime = db[type2];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type2] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          types[extension2] = _preferredType(extension2, types[extension2], type2);
          const legacyType = _preferredTypeLegacy(
            extension2,
            types[extension2],
            type2
          );
          if (legacyType !== types[extension2]) {
            exports._extensionConflicts.push([extension2, legacyType, types[extension2]]);
          }
        }
      });
    }
    function _preferredType(ext, type0, type1) {
      var score0 = type0 ? mimeScore2(type0, db[type0].source) : 0;
      var score1 = type1 ? mimeScore2(type1, db[type1].source) : 0;
      return score0 > score1 ? type0 : type1;
    }
    function _preferredTypeLegacy(ext, type0, type1) {
      var SOURCE_RANK = ["nginx", "apache", void 0, "iana"];
      var score0 = type0 ? SOURCE_RANK.indexOf(db[type0].source) : 0;
      var score1 = type1 ? SOURCE_RANK.indexOf(db[type1].source) : 0;
      if (exports.types[extension] !== "application/octet-stream" && (score0 > score1 || score0 === score1 && exports.types[extension]?.slice(0, 12) === "application/")) {
        return type0;
      }
      return score0 > score1 ? type0 : type1;
    }
  })(mimeTypes);
  return mimeTypes;
}
var mediaTyper = {};
/*!
 * media-typer
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredMediaTyper;
function requireMediaTyper() {
  if (hasRequiredMediaTyper) return mediaTyper;
  hasRequiredMediaTyper = 1;
  var SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
  var TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
  var TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
  mediaTyper.format = format;
  mediaTyper.parse = parse2;
  mediaTyper.test = test2;
  function format(obj) {
    if (!obj || typeof obj !== "object") {
      throw new TypeError("argument obj is required");
    }
    var subtype = obj.subtype;
    var suffix = obj.suffix;
    var type2 = obj.type;
    if (!type2 || !TYPE_NAME_REGEXP.test(type2)) {
      throw new TypeError("invalid type");
    }
    if (!subtype || !SUBTYPE_NAME_REGEXP.test(subtype)) {
      throw new TypeError("invalid subtype");
    }
    var string = type2 + "/" + subtype;
    if (suffix) {
      if (!TYPE_NAME_REGEXP.test(suffix)) {
        throw new TypeError("invalid suffix");
      }
      string += "+" + suffix;
    }
    return string;
  }
  function test2(string) {
    if (!string) {
      throw new TypeError("argument string is required");
    }
    if (typeof string !== "string") {
      throw new TypeError("argument string is required to be a string");
    }
    return TYPE_REGEXP.test(string.toLowerCase());
  }
  function parse2(string) {
    if (!string) {
      throw new TypeError("argument string is required");
    }
    if (typeof string !== "string") {
      throw new TypeError("argument string is required to be a string");
    }
    var match = TYPE_REGEXP.exec(string.toLowerCase());
    if (!match) {
      throw new TypeError("invalid media type");
    }
    var type2 = match[1];
    var subtype = match[2];
    var suffix;
    var index2 = subtype.lastIndexOf("+");
    if (index2 !== -1) {
      suffix = subtype.substr(index2 + 1);
      subtype = subtype.substr(0, index2);
    }
    return new MediaType(type2, subtype, suffix);
  }
  function MediaType(type2, subtype, suffix) {
    this.type = type2;
    this.subtype = subtype;
    this.suffix = suffix;
  }
  return mediaTyper;
}
/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredTypeIs;
function requireTypeIs() {
  if (hasRequiredTypeIs) return typeIs.exports;
  hasRequiredTypeIs = 1;
  var contentType2 = requireContentType();
  var mime = requireMimeTypes();
  var typer = requireMediaTyper();
  typeIs.exports = typeofrequest;
  typeIs.exports.is = typeis;
  typeIs.exports.hasBody = hasbody;
  typeIs.exports.normalize = normalize;
  typeIs.exports.match = mimeMatch;
  function typeis(value, types_) {
    var i;
    var types = types_;
    var val = tryNormalizeType(value);
    if (!val) {
      return false;
    }
    if (types && !Array.isArray(types)) {
      types = new Array(arguments.length - 1);
      for (i = 0; i < types.length; i++) {
        types[i] = arguments[i + 1];
      }
    }
    if (!types || !types.length) {
      return val;
    }
    var type2;
    for (i = 0; i < types.length; i++) {
      if (mimeMatch(normalize(type2 = types[i]), val)) {
        return type2[0] === "+" || type2.indexOf("*") !== -1 ? val : type2;
      }
    }
    return false;
  }
  function hasbody(req) {
    return req.headers["transfer-encoding"] !== void 0 || !isNaN(req.headers["content-length"]);
  }
  function typeofrequest(req, types_) {
    if (!hasbody(req)) return null;
    var types = arguments.length > 2 ? Array.prototype.slice.call(arguments, 1) : types_;
    var value = req.headers["content-type"];
    return typeis(value, types);
  }
  function normalize(type2) {
    if (typeof type2 !== "string") {
      return false;
    }
    switch (type2) {
      case "urlencoded":
        return "application/x-www-form-urlencoded";
      case "multipart":
        return "multipart/*";
    }
    if (type2[0] === "+") {
      return "*/*" + type2;
    }
    return type2.indexOf("/") === -1 ? mime.lookup(type2) : type2;
  }
  function mimeMatch(expected, actual) {
    if (expected === false) {
      return false;
    }
    var actualParts = actual.split("/");
    var expectedParts = expected.split("/");
    if (actualParts.length !== 2 || expectedParts.length !== 2) {
      return false;
    }
    if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) {
      return false;
    }
    if (expectedParts[1].slice(0, 2) === "*+") {
      return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].slice(1) === actualParts[1].slice(1 - expectedParts[1].length);
    }
    if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) {
      return false;
    }
    return true;
  }
  function normalizeType(value) {
    var type2 = contentType2.parse(value).type;
    return typer.test(type2) ? type2 : null;
  }
  function tryNormalizeType(value) {
    try {
      return value ? normalizeType(value) : null;
    } catch (err) {
      return null;
    }
  }
  return typeIs.exports;
}
var utils$2$1;
var hasRequiredUtils$2$1;
function requireUtils$2$1() {
  if (hasRequiredUtils$2$1) return utils$2$1;
  hasRequiredUtils$2$1 = 1;
  var bytes2 = requireBytes();
  var contentType2 = requireContentType();
  var typeis = requireTypeIs();
  utils$2$1 = {
    getCharset,
    normalizeOptions
  };
  function getCharset(req) {
    try {
      return (contentType2.parse(req).parameters.charset || "").toLowerCase();
    } catch {
      return void 0;
    }
  }
  function typeChecker(type2) {
    return function checkType(req) {
      return Boolean(typeis(req, type2));
    };
  }
  function normalizeOptions(options, defaultType) {
    if (!defaultType) {
      throw new TypeError("defaultType must be provided");
    }
    var inflate = options?.inflate !== false;
    var limit = typeof options?.limit !== "number" ? bytes2.parse(options?.limit || "100kb") : options?.limit;
    var type2 = options?.type || defaultType;
    var verify = options?.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type2 !== "function" ? typeChecker(type2) : type2;
    return {
      inflate,
      limit,
      verify,
      shouldParse
    };
  }
  return utils$2$1;
}
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var json_1;
var hasRequiredJson;
function requireJson() {
  if (hasRequiredJson) return json_1;
  hasRequiredJson = 1;
  var createError = requireHttpErrors();
  var debug2 = requireBrowser$2()("body-parser:json");
  var isFinished = requireOnFinished().isFinished;
  var read = requireRead();
  var typeis = requireTypeIs();
  var { getCharset, normalizeOptions } = requireUtils$2$1();
  json_1 = json2;
  var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
  var JSON_SYNTAX_CHAR = "#";
  var JSON_SYNTAX_REGEXP = /#+/g;
  function json2(options) {
    var { inflate, limit, verify, shouldParse } = normalizeOptions(options, "application/json");
    var reviver = options?.reviver;
    var strict = options?.strict !== false;
    function parse2(body) {
      if (body.length === 0) {
        return {};
      }
      if (strict) {
        var first = firstchar(body);
        if (first !== "{" && first !== "[") {
          debug2("strict violation");
          throw createStrictSyntaxError(body, first);
        }
      }
      try {
        debug2("parse json");
        return JSON.parse(body, reviver);
      } catch (e) {
        throw normalizeJsonSyntaxError(e, {
          message: e.message,
          stack: e.stack
        });
      }
    }
    return function jsonParser(req, res, next) {
      if (isFinished(req)) {
        debug2("body already parsed");
        next();
        return;
      }
      if (!("body" in req)) {
        req.body = void 0;
      }
      if (!typeis.hasBody(req)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug2("skip parsing");
        next();
        return;
      }
      var charset2 = getCharset(req) || "utf-8";
      if (charset2.slice(0, 4) !== "utf-") {
        debug2("invalid charset");
        next(createError(415, 'unsupported charset "' + charset2.toUpperCase() + '"', {
          charset: charset2,
          type: "charset.unsupported"
        }));
        return;
      }
      read(req, res, next, parse2, debug2, {
        encoding: charset2,
        inflate,
        limit,
        verify
      });
    };
  }
  function createStrictSyntaxError(str, char) {
    var index2 = str.indexOf(char);
    var partial = "";
    if (index2 !== -1) {
      partial = str.substring(0, index2) + JSON_SYNTAX_CHAR;
      for (var i = index2 + 1; i < str.length; i++) {
        partial += JSON_SYNTAX_CHAR;
      }
    }
    try {
      JSON.parse(partial);
      throw new SyntaxError("strict violation");
    } catch (e) {
      return normalizeJsonSyntaxError(e, {
        message: e.message.replace(JSON_SYNTAX_REGEXP, function(placeholder) {
          return str.substring(index2, index2 + placeholder.length);
        }),
        stack: e.stack
      });
    }
  }
  function firstchar(str) {
    var match = FIRST_CHAR_REGEXP.exec(str);
    return match ? match[1] : void 0;
  }
  function normalizeJsonSyntaxError(error, obj) {
    var keys = Object.getOwnPropertyNames(error);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (key !== "stack" && key !== "message") {
        delete error[key];
      }
    }
    error.stack = obj.stack.replace(error.message, obj.message);
    error.message = obj.message;
    return error;
  }
  return json_1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var raw_1;
var hasRequiredRaw;
function requireRaw() {
  if (hasRequiredRaw) return raw_1;
  hasRequiredRaw = 1;
  var debug2 = requireBrowser$2()("body-parser:raw");
  var isFinished = requireOnFinished().isFinished;
  var read = requireRead();
  var typeis = requireTypeIs();
  var { normalizeOptions } = requireUtils$2$1();
  raw_1 = raw2;
  function raw2(options) {
    var { inflate, limit, verify, shouldParse } = normalizeOptions(options, "application/octet-stream");
    function parse2(buf) {
      return buf;
    }
    return function rawParser(req, res, next) {
      if (isFinished(req)) {
        debug2("body already parsed");
        next();
        return;
      }
      if (!("body" in req)) {
        req.body = void 0;
      }
      if (!typeis.hasBody(req)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug2("skip parsing");
        next();
        return;
      }
      read(req, res, next, parse2, debug2, {
        encoding: null,
        inflate,
        limit,
        verify
      });
    };
  }
  return raw_1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var text_1;
var hasRequiredText;
function requireText() {
  if (hasRequiredText) return text_1;
  hasRequiredText = 1;
  var debug2 = requireBrowser$2()("body-parser:text");
  var isFinished = requireOnFinished().isFinished;
  var read = requireRead();
  var typeis = requireTypeIs();
  var { getCharset, normalizeOptions } = requireUtils$2$1();
  text_1 = text2;
  function text2(options) {
    var { inflate, limit, verify, shouldParse } = normalizeOptions(options, "text/plain");
    var defaultCharset = options?.defaultCharset || "utf-8";
    function parse2(buf) {
      return buf;
    }
    return function textParser(req, res, next) {
      if (isFinished(req)) {
        debug2("body already parsed");
        next();
        return;
      }
      if (!("body" in req)) {
        req.body = void 0;
      }
      if (!typeis.hasBody(req)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug2("skip parsing");
        next();
        return;
      }
      var charset2 = getCharset(req) || defaultCharset;
      read(req, res, next, parse2, debug2, {
        encoding: charset2,
        inflate,
        limit,
        verify
      });
    };
  }
  return text_1;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = TypeError;
  return type;
}
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var objectInspect;
var hasRequiredObjectInspect;
function requireObjectInspect() {
  if (hasRequiredObjectInspect) return objectInspect;
  hasRequiredObjectInspect = 1;
  var hasMap = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice = String.prototype.slice;
  var $replace = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
  var toStringTag2 = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
    return O.__proto__;
  } : null);
  function addNumericSeparator(num, str) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
      return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === "number") {
      var int = num < 0 ? -$floor(-num) : $floor(num);
      if (int !== num) {
        var intStr = String(int);
        var dec = $slice.call(str, intStr.length + 1);
        return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return $replace.call(str, sepRegex, "$&_");
  }
  var utilInspect = require$$0;
  var inspectCustom = utilInspect.custom;
  var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
  var quotes = {
    __proto__: null,
    "double": '"',
    single: "'"
  };
  var quoteREs = {
    __proto__: null,
    "double": /(["\\])/g,
    single: /(['\\])/g
  };
  objectInspect = function inspect_(obj, options, depth, seen) {
    var opts = options || {};
    if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    }
    if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === "undefined") {
      return "undefined";
    }
    if (obj === null) {
      return "null";
    }
    if (typeof obj === "boolean") {
      return obj ? "true" : "false";
    }
    if (typeof obj === "string") {
      return inspectString(obj, opts);
    }
    if (typeof obj === "number") {
      if (obj === 0) {
        return Infinity / obj > 0 ? "0" : "-0";
      }
      var str = String(obj);
      return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === "bigint") {
      var bigIntStr = String(obj) + "n";
      return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
      return isArray2(obj) ? "[Array]" : "[Object]";
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === "undefined") {
      seen = [];
    } else if (indexOf(seen, obj) >= 0) {
      return "[Circular]";
    }
    function inspect(value, from, noIndent) {
      if (from) {
        seen = $arrSlice.call(seen);
        seen.push(from);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has(opts, "quoteStyle")) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value, newOpts, depth + 1, seen);
      }
      return inspect_(value, opts, depth + 1, seen);
    }
    if (typeof obj === "function" && !isRegExp2(obj)) {
      var name = nameOf(obj);
      var keys = arrObjKeys(obj, inspect);
      return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
    }
    if (isSymbol(obj)) {
      var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
      return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
      var s = "<" + $toLowerCase.call(String(obj.nodeName));
      var attrs = obj.attributes || [];
      for (var i = 0; i < attrs.length; i++) {
        s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
      }
      s += ">";
      if (obj.childNodes && obj.childNodes.length) {
        s += "...";
      }
      s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
      return s;
    }
    if (isArray2(obj)) {
      if (obj.length === 0) {
        return "[]";
      }
      var xs = arrObjKeys(obj, inspect);
      if (indent && !singleLineValues(xs)) {
        return "[" + indentedJoin(xs, indent) + "]";
      }
      return "[ " + $join.call(xs, ", ") + " ]";
    }
    if (isError(obj)) {
      var parts = arrObjKeys(obj, inspect);
      if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
        return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
      }
      if (parts.length === 0) {
        return "[" + String(obj) + "]";
      }
      return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
    }
    if (typeof obj === "object" && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
        return utilInspect(obj, { depth: maxDepth - depth });
      } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
        return obj.inspect();
      }
    }
    if (isMap(obj)) {
      var mapParts = [];
      if (mapForEach) {
        mapForEach.call(obj, function(value, key) {
          mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
        });
      }
      return collectionOf("Map", mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
      var setParts = [];
      if (setForEach) {
        setForEach.call(obj, function(value) {
          setParts.push(inspect(value, obj));
        });
      }
      return collectionOf("Set", setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
      return weakCollectionOf("WeakMap");
    }
    if (isWeakSet(obj)) {
      return weakCollectionOf("WeakSet");
    }
    if (isWeakRef(obj)) {
      return weakCollectionOf("WeakRef");
    }
    if (isNumber2(obj)) {
      return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
      return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean2(obj)) {
      return markBoxed(booleanValueOf.call(obj));
    }
    if (isString2(obj)) {
      return markBoxed(inspect(String(obj)));
    }
    if (typeof window !== "undefined" && obj === window) {
      return "{ [object Window] }";
    }
    if (typeof globalThis !== "undefined" && obj === globalThis || typeof commonjsGlobal !== "undefined" && obj === commonjsGlobal) {
      return "{ [object globalThis] }";
    }
    if (!isDate2(obj) && !isRegExp2(obj)) {
      var ys = arrObjKeys(obj, inspect);
      var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
      var protoTag = obj instanceof Object ? "" : "null prototype";
      var stringTag = !isPlainObject2 && toStringTag2 && Object(obj) === obj && toStringTag2 in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
      var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
      var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
      if (ys.length === 0) {
        return tag + "{}";
      }
      if (indent) {
        return tag + "{" + indentedJoin(ys, indent) + "}";
      }
      return tag + "{ " + $join.call(ys, ", ") + " }";
    }
    return String(obj);
  };
  function wrapQuotes(s, defaultStyle, opts) {
    var style = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style];
    return quoteChar + s + quoteChar;
  }
  function quote(s) {
    return $replace.call(String(s), /"/g, "&quot;");
  }
  function canTrustToString(obj) {
    return !toStringTag2 || !(typeof obj === "object" && (toStringTag2 in obj || typeof obj[toStringTag2] !== "undefined"));
  }
  function isArray2(obj) {
    return toStr(obj) === "[object Array]" && canTrustToString(obj);
  }
  function isDate2(obj) {
    return toStr(obj) === "[object Date]" && canTrustToString(obj);
  }
  function isRegExp2(obj) {
    return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
  }
  function isError(obj) {
    return toStr(obj) === "[object Error]" && canTrustToString(obj);
  }
  function isString2(obj) {
    return toStr(obj) === "[object String]" && canTrustToString(obj);
  }
  function isNumber2(obj) {
    return toStr(obj) === "[object Number]" && canTrustToString(obj);
  }
  function isBoolean2(obj) {
    return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
  }
  function isSymbol(obj) {
    if (hasShammedSymbols) {
      return obj && typeof obj === "object" && obj instanceof Symbol;
    }
    if (typeof obj === "symbol") {
      return true;
    }
    if (!obj || typeof obj !== "object" || !symToString) {
      return false;
    }
    try {
      symToString.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isBigInt(obj) {
    if (!obj || typeof obj !== "object" || !bigIntValueOf) {
      return false;
    }
    try {
      bigIntValueOf.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  var hasOwn = Object.prototype.hasOwnProperty || function(key) {
    return key in this;
  };
  function has(obj, key) {
    return hasOwn.call(obj, key);
  }
  function toStr(obj) {
    return objectToString.call(obj);
  }
  function nameOf(f) {
    if (f.name) {
      return f.name;
    }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) {
      return m[1];
    }
    return null;
  }
  function indexOf(xs, x) {
    if (xs.indexOf) {
      return xs.indexOf(x);
    }
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) {
        return i;
      }
    }
    return -1;
  }
  function isMap(x) {
    if (!mapSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      mapSize.call(x);
      try {
        setSize.call(x);
      } catch (s) {
        return true;
      }
      return x instanceof Map;
    } catch (e) {
    }
    return false;
  }
  function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakMapHas.call(x, weakMapHas);
      try {
        weakSetHas.call(x, weakSetHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakMap;
    } catch (e) {
    }
    return false;
  }
  function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakRefDeref.call(x);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isSet(x) {
    if (!setSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      setSize.call(x);
      try {
        mapSize.call(x);
      } catch (m) {
        return true;
      }
      return x instanceof Set;
    } catch (e) {
    }
    return false;
  }
  function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakSetHas.call(x, weakSetHas);
      try {
        weakMapHas.call(x, weakMapHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakSet;
    } catch (e) {
    }
    return false;
  }
  function isElement(x) {
    if (!x || typeof x !== "object") {
      return false;
    }
    if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
      return true;
    }
    return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
  }
  function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
      var remaining = str.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || "single"];
    quoteRE.lastIndex = 0;
    var s = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, "single", opts);
  }
  function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n];
    if (x) {
      return "\\" + x;
    }
    return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
  }
  function markBoxed(str) {
    return "Object(" + str + ")";
  }
  function weakCollectionOf(type2) {
    return type2 + " { ? }";
  }
  function collectionOf(type2, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type2 + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
      if (indexOf(xs[i], "\n") >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "	") {
      baseIndent = "	";
    } else if (typeof opts.indent === "number" && opts.indent > 0) {
      baseIndent = $join.call(Array(opts.indent + 1), " ");
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0) {
      return "";
    }
    var lineJoiner = "\n" + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
  }
  function arrObjKeys(obj, inspect) {
    var isArr = isArray2(obj);
    var xs = [];
    if (isArr) {
      xs.length = obj.length;
      for (var i = 0; i < obj.length; i++) {
        xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
      }
    }
    var syms = typeof gOPS === "function" ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k = 0; k < syms.length; k++) {
        symMap["$" + syms[k]] = syms[k];
      }
    }
    for (var key in obj) {
      if (!has(obj, key)) {
        continue;
      }
      if (isArr && String(Number(key)) === key && key < obj.length) {
        continue;
      }
      if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
        continue;
      } else if ($test.call(/[^\w$]/, key)) {
        xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
      } else {
        xs.push(key + ": " + inspect(obj[key], obj));
      }
    }
    if (typeof gOPS === "function") {
      for (var j = 0; j < syms.length; j++) {
        if (isEnumerable.call(obj, syms[j])) {
          xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
        }
      }
    }
    return xs;
  }
  return objectInspect;
}
var sideChannelList;
var hasRequiredSideChannelList;
function requireSideChannelList() {
  if (hasRequiredSideChannelList) return sideChannelList;
  hasRequiredSideChannelList = 1;
  var inspect = /* @__PURE__ */ requireObjectInspect();
  var $TypeError = /* @__PURE__ */ requireType();
  var listGetNode = function(list, key, isDelete) {
    var prev = list;
    var curr;
    for (; (curr = prev.next) != null; prev = curr) {
      if (curr.key === key) {
        prev.next = curr.next;
        if (!isDelete) {
          curr.next = /** @type {NonNullable<typeof list.next>} */
          list.next;
          list.next = curr;
        }
        return curr;
      }
    }
  };
  var listGet = function(objects, key) {
    if (!objects) {
      return void 0;
    }
    var node = listGetNode(objects, key);
    return node && node.value;
  };
  var listSet = function(objects, key, value) {
    var node = listGetNode(objects, key);
    if (node) {
      node.value = value;
    } else {
      objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
      {
        // eslint-disable-line no-param-reassign, no-extra-parens
        key,
        next: objects.next,
        value
      };
    }
  };
  var listHas = function(objects, key) {
    if (!objects) {
      return false;
    }
    return !!listGetNode(objects, key);
  };
  var listDelete = function(objects, key) {
    if (objects) {
      return listGetNode(objects, key, true);
    }
  };
  sideChannelList = function getSideChannelList() {
    var $o;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      "delete": function(key) {
        var root = $o && $o.next;
        var deletedNode = listDelete($o, key);
        if (deletedNode && root && root === deletedNode) {
          $o = void 0;
        }
        return !!deletedNode;
      },
      get: function(key) {
        return listGet($o, key);
      },
      has: function(key) {
        return listHas($o, key);
      },
      set: function(key, value) {
        if (!$o) {
          $o = {
            next: void 0
          };
        }
        listSet(
          /** @type {NonNullable<typeof $o>} */
          $o,
          key,
          value
        );
      }
    };
    return channel;
  };
  return sideChannelList;
}
var esObjectAtoms;
var hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  if (hasRequiredEsObjectAtoms) return esObjectAtoms;
  hasRequiredEsObjectAtoms = 1;
  esObjectAtoms = Object;
  return esObjectAtoms;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
  if (hasRequiredEsErrors) return esErrors;
  hasRequiredEsErrors = 1;
  esErrors = Error;
  return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
  if (hasRequired_eval) return _eval;
  hasRequired_eval = 1;
  _eval = EvalError;
  return _eval;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  range = RangeError;
  return range;
}
var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  ref = ReferenceError;
  return ref;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;
  syntax = SyntaxError;
  return syntax;
}
var uri;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  uri = URIError;
  return uri;
}
var abs;
var hasRequiredAbs;
function requireAbs() {
  if (hasRequiredAbs) return abs;
  hasRequiredAbs = 1;
  abs = Math.abs;
  return abs;
}
var floor;
var hasRequiredFloor;
function requireFloor() {
  if (hasRequiredFloor) return floor;
  hasRequiredFloor = 1;
  floor = Math.floor;
  return floor;
}
var max;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max;
  hasRequiredMax = 1;
  max = Math.max;
  return max;
}
var min;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min;
  hasRequiredMin = 1;
  min = Math.min;
  return min;
}
var pow;
var hasRequiredPow;
function requirePow() {
  if (hasRequiredPow) return pow;
  hasRequiredPow = 1;
  pow = Math.pow;
  return pow;
}
var round;
var hasRequiredRound;
function requireRound() {
  if (hasRequiredRound) return round;
  hasRequiredRound = 1;
  round = Math.round;
  return round;
}
var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
  if (hasRequired_isNaN) return _isNaN;
  hasRequired_isNaN = 1;
  _isNaN = Number.isNaN || function isNaN2(a) {
    return a !== a;
  };
  return _isNaN;
}
var sign;
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign;
  hasRequiredSign = 1;
  var $isNaN = /* @__PURE__ */ require_isNaN();
  sign = function sign2(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
  return sign;
}
var gOPD;
var hasRequiredGOPD;
function requireGOPD() {
  if (hasRequiredGOPD) return gOPD;
  hasRequiredGOPD = 1;
  gOPD = Object.getOwnPropertyDescriptor;
  return gOPD;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var $gOPD = /* @__PURE__ */ requireGOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  shams = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  Object_getPrototypeOf = $Object.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b) {
    var arr = [];
    for (var i = 0; i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0; i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation = function bind2(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind2 = requireFunctionBind();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind2.call($call, $apply);
  return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind2 = requireFunctionBind();
  var $TypeError = /* @__PURE__ */ requireType();
  var $call = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind2, $call, args);
  };
  return callBindApplyHelpers;
}
var get;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var callBind = requireCallBindApplyHelpers();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  get = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object(value));
    }
  ) : false;
  return get;
}
var getProto;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = /* @__PURE__ */ requireGet();
  getProto = reflectGetProto ? function getProto2(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto2(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto2(O) {
    return getDunderProto(O);
  } : null;
  return getProto;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind2 = requireFunctionBind();
  hasown = bind2.call(call, $hasOwn);
  return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  var $Error = /* @__PURE__ */ requireEsErrors();
  var $EvalError = /* @__PURE__ */ require_eval();
  var $RangeError = /* @__PURE__ */ requireRange();
  var $ReferenceError = /* @__PURE__ */ requireRef();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var $URIError = /* @__PURE__ */ requireUri();
  var abs2 = /* @__PURE__ */ requireAbs();
  var floor2 = /* @__PURE__ */ requireFloor();
  var max2 = /* @__PURE__ */ requireMax();
  var min2 = /* @__PURE__ */ requireMin();
  var pow2 = /* @__PURE__ */ requirePow();
  var round2 = /* @__PURE__ */ requireRound();
  var sign2 = /* @__PURE__ */ requireSign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = /* @__PURE__ */ requireGopd();
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var getProto2 = requireGetProto();
  var $ObjectGPO = requireObject_getPrototypeOf();
  var $ReflectGPO = requireReflect_getPrototypeOf();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs2,
    "%Math.floor%": floor2,
    "%Math.max%": max2,
    "%Math.min%": min2,
    "%Math.pow%": pow2,
    "%Math.round%": round2,
    "%Math.sign%": sign2,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto2) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto2(getProto2(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto2) {
        value = getProto2(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind2 = requireFunctionBind();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var $concat = bind2.call($call, Array.prototype.concat);
  var $spliceApply = bind2.call($apply, Array.prototype.splice);
  var $replace = bind2.call($call, String.prototype.replace);
  var $strSlice = bind2.call($call, String.prototype.slice);
  var $exec = bind2.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void 0;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBindBasic = requireCallBindApplyHelpers();
  var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
  callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = (
      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
      GetIntrinsic(name, !!allowMissing)
    );
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBindBasic(
        /** @type {const} */
        [intrinsic]
      );
    }
    return intrinsic;
  };
  return callBound;
}
var sideChannelMap;
var hasRequiredSideChannelMap;
function requireSideChannelMap() {
  if (hasRequiredSideChannelMap) return sideChannelMap;
  hasRequiredSideChannelMap = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var inspect = /* @__PURE__ */ requireObjectInspect();
  var $TypeError = /* @__PURE__ */ requireType();
  var $Map = GetIntrinsic("%Map%", true);
  var $mapGet = callBound2("Map.prototype.get", true);
  var $mapSet = callBound2("Map.prototype.set", true);
  var $mapHas = callBound2("Map.prototype.has", true);
  var $mapDelete = callBound2("Map.prototype.delete", true);
  var $mapSize = callBound2("Map.prototype.size", true);
  sideChannelMap = !!$Map && /** @type {Exclude<import('.'), false>} */
  function getSideChannelMap() {
    var $m;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      "delete": function(key) {
        if ($m) {
          var result = $mapDelete($m, key);
          if ($mapSize($m) === 0) {
            $m = void 0;
          }
          return result;
        }
        return false;
      },
      get: function(key) {
        if ($m) {
          return $mapGet($m, key);
        }
      },
      has: function(key) {
        if ($m) {
          return $mapHas($m, key);
        }
        return false;
      },
      set: function(key, value) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key, value);
      }
    };
    return channel;
  };
  return sideChannelMap;
}
var sideChannelWeakmap;
var hasRequiredSideChannelWeakmap;
function requireSideChannelWeakmap() {
  if (hasRequiredSideChannelWeakmap) return sideChannelWeakmap;
  hasRequiredSideChannelWeakmap = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var inspect = /* @__PURE__ */ requireObjectInspect();
  var getSideChannelMap = requireSideChannelMap();
  var $TypeError = /* @__PURE__ */ requireType();
  var $WeakMap = GetIntrinsic("%WeakMap%", true);
  var $weakMapGet = callBound2("WeakMap.prototype.get", true);
  var $weakMapSet = callBound2("WeakMap.prototype.set", true);
  var $weakMapHas = callBound2("WeakMap.prototype.has", true);
  var $weakMapDelete = callBound2("WeakMap.prototype.delete", true);
  sideChannelWeakmap = $WeakMap ? (
    /** @type {Exclude<import('.'), false>} */
    function getSideChannelWeakMap() {
      var $wm;
      var $m;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapDelete($wm, key);
            }
          } else if (getSideChannelMap) {
            if ($m) {
              return $m["delete"](key);
            }
          }
          return false;
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          }
          return $m && $m.get(key);
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          }
          return !!$m && $m.has(key);
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if (getSideChannelMap) {
            if (!$m) {
              $m = getSideChannelMap();
            }
            $m.set(key, value);
          }
        }
      };
      return channel;
    }
  ) : getSideChannelMap;
  return sideChannelWeakmap;
}
var sideChannel;
var hasRequiredSideChannel;
function requireSideChannel() {
  if (hasRequiredSideChannel) return sideChannel;
  hasRequiredSideChannel = 1;
  var $TypeError = /* @__PURE__ */ requireType();
  var inspect = /* @__PURE__ */ requireObjectInspect();
  var getSideChannelList = requireSideChannelList();
  var getSideChannelMap = requireSideChannelMap();
  var getSideChannelWeakMap = requireSideChannelWeakmap();
  var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
  sideChannel = function getSideChannel() {
    var $channelData;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      "delete": function(key) {
        return !!$channelData && $channelData["delete"](key);
      },
      get: function(key) {
        return $channelData && $channelData.get(key);
      },
      has: function(key) {
        return !!$channelData && $channelData.has(key);
      },
      set: function(key, value) {
        if (!$channelData) {
          $channelData = makeChannel();
        }
        $channelData.set(key, value);
      }
    };
    return channel;
  };
  return sideChannel;
}
var formats;
var hasRequiredFormats;
function requireFormats() {
  if (hasRequiredFormats) return formats;
  hasRequiredFormats = 1;
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  var Format = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  formats = {
    "default": Format.RFC3986,
    formatters: {
      RFC1738: function(value) {
        return replace.call(value, percentTwenties, "+");
      },
      RFC3986: function(value) {
        return String(value);
      }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
  };
  return formats;
}
var utils$1$1;
var hasRequiredUtils$1$1;
function requireUtils$1$1() {
  if (hasRequiredUtils$1$1) return utils$1$1;
  hasRequiredUtils$1$1 = 1;
  var formats2 = /* @__PURE__ */ requireFormats();
  var has = Object.prototype.hasOwnProperty;
  var isArray2 = Array.isArray;
  var hexTable = function() {
    var array = [];
    for (var i = 0; i < 256; ++i) {
      array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
    }
    return array;
  }();
  var compactQueue = function compactQueue2(queue) {
    while (queue.length > 1) {
      var item = queue.pop();
      var obj = item.obj[item.prop];
      if (isArray2(obj)) {
        var compacted = [];
        for (var j = 0; j < obj.length; ++j) {
          if (typeof obj[j] !== "undefined") {
            compacted.push(obj[j]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
  };
  var arrayToObject2 = function arrayToObject22(source, options) {
    var obj = options && options.plainObjects ? { __proto__: null } : {};
    for (var i = 0; i < source.length; ++i) {
      if (typeof source[i] !== "undefined") {
        obj[i] = source[i];
      }
    }
    return obj;
  };
  var merge2 = function merge22(target, source, options) {
    if (!source) {
      return target;
    }
    if (typeof source !== "object" && typeof source !== "function") {
      if (isArray2(target)) {
        target.push(source);
      } else if (target && typeof target === "object") {
        if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (!target || typeof target !== "object") {
      return [target].concat(source);
    }
    var mergeTarget = target;
    if (isArray2(target) && !isArray2(source)) {
      mergeTarget = arrayToObject2(target, options);
    }
    if (isArray2(target) && isArray2(source)) {
      source.forEach(function(item, i) {
        if (has.call(target, i)) {
          var targetItem = target[i];
          if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
            target[i] = merge22(targetItem, item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i] = item;
        }
      });
      return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
      var value = source[key];
      if (has.call(acc, key)) {
        acc[key] = merge22(acc[key], value, options);
      } else {
        acc[key] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  };
  var decode = function(str, defaultDecoder, charset2) {
    var strWithoutPlus = str.replace(/\+/g, " ");
    if (charset2 === "iso-8859-1") {
      return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    try {
      return decodeURIComponent(strWithoutPlus);
    } catch (e) {
      return strWithoutPlus;
    }
  };
  var limit = 1024;
  var encode2 = function encode22(str, defaultEncoder, charset2, kind, format) {
    if (str.length === 0) {
      return str;
    }
    var string = str;
    if (typeof str === "symbol") {
      string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== "string") {
      string = String(str);
    }
    if (charset2 === "iso-8859-1") {
      return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    var out = "";
    for (var j = 0; j < string.length; j += limit) {
      var segment = string.length >= limit ? string.slice(j, j + limit) : string;
      var arr = [];
      for (var i = 0; i < segment.length; ++i) {
        var c = segment.charCodeAt(i);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats2.RFC1738 && (c === 40 || c === 41)) {
          arr[arr.length] = segment.charAt(i);
          continue;
        }
        if (c < 128) {
          arr[arr.length] = hexTable[c];
          continue;
        }
        if (c < 2048) {
          arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          continue;
        }
        i += 1;
        c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
        arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      out += arr.join("");
    }
    return out;
  };
  var compact = function compact2(value) {
    var queue = [{ obj: { o: value }, prop: "o" }];
    var refs = [];
    for (var i = 0; i < queue.length; ++i) {
      var item = queue[i];
      var obj = item.obj[item.prop];
      var keys = Object.keys(obj);
      for (var j = 0; j < keys.length; ++j) {
        var key = keys[j];
        var val = obj[key];
        if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
          queue.push({ obj, prop: key });
          refs.push(val);
        }
      }
    }
    compactQueue(queue);
    return value;
  };
  var isRegExp2 = function isRegExp22(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var isBuffer2 = function isBuffer22(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  var combine = function combine2(a, b) {
    return [].concat(a, b);
  };
  var maybeMap = function maybeMap2(val, fn) {
    if (isArray2(val)) {
      var mapped = [];
      for (var i = 0; i < val.length; i += 1) {
        mapped.push(fn(val[i]));
      }
      return mapped;
    }
    return fn(val);
  };
  utils$1$1 = {
    arrayToObject: arrayToObject2,
    assign,
    combine,
    compact,
    decode,
    encode: encode2,
    isBuffer: isBuffer2,
    isRegExp: isRegExp2,
    maybeMap,
    merge: merge2
  };
  return utils$1$1;
}
var stringify_1;
var hasRequiredStringify$1;
function requireStringify$1() {
  if (hasRequiredStringify$1) return stringify_1;
  hasRequiredStringify$1 = 1;
  var getSideChannel = requireSideChannel();
  var utils2 = /* @__PURE__ */ requireUtils$1$1();
  var formats2 = /* @__PURE__ */ requireFormats();
  var has = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + "[]";
    },
    comma: "comma",
    indices: function indices(prefix, key) {
      return prefix + "[" + key + "]";
    },
    repeat: function repeat(prefix) {
      return prefix;
    }
  };
  var isArray2 = Array.isArray;
  var push = Array.prototype.push;
  var pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray2(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaultFormat = formats2["default"];
  var defaults2 = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: false,
    commaRoundTrip: false,
    delimiter: "&",
    encode: true,
    encodeDotInKeys: false,
    encoder: utils2.encode,
    encodeValuesOnly: false,
    filter: void 0,
    format: defaultFormat,
    formatter: formats2.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
    return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
  };
  var sentinel = {};
  var stringify2 = function stringify22(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder2, filter2, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset2, sideChannel2) {
    var obj = object;
    var tmpSc = sideChannel2;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
      var pos = tmpSc.get(object);
      step += 1;
      if (typeof pos !== "undefined") {
        if (pos === step) {
          throw new RangeError("Cyclic object value");
        } else {
          findFlag = true;
        }
      }
      if (typeof tmpSc.get(sentinel) === "undefined") {
        step = 0;
      }
    }
    if (typeof filter2 === "function") {
      obj = filter2(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (generateArrayPrefix === "comma" && isArray2(obj)) {
      obj = utils2.maybeMap(obj, function(value2) {
        if (value2 instanceof Date) {
          return serializeDate(value2);
        }
        return value2;
      });
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder2 && !encodeValuesOnly ? encoder2(prefix, defaults2.encoder, charset2, "key", format) : prefix;
      }
      obj = "";
    }
    if (isNonNullishPrimitive(obj) || utils2.isBuffer(obj)) {
      if (encoder2) {
        var keyValue = encodeValuesOnly ? prefix : encoder2(prefix, defaults2.encoder, charset2, "key", format);
        return [formatter(keyValue) + "=" + formatter(encoder2(obj, defaults2.encoder, charset2, "value", format))];
      }
      return [formatter(prefix) + "=" + formatter(String(obj))];
    }
    var values = [];
    if (typeof obj === "undefined") {
      return values;
    }
    var objKeys;
    if (generateArrayPrefix === "comma" && isArray2(obj)) {
      if (encodeValuesOnly && encoder2) {
        obj = utils2.maybeMap(obj, encoder2);
      }
      objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
    } else if (isArray2(filter2)) {
      objKeys = filter2;
    } else {
      var keys = Object.keys(obj);
      objKeys = sort ? keys.sort(sort) : keys;
    }
    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
    var adjustedPrefix = commaRoundTrip && isArray2(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
    if (allowEmptyArrays && isArray2(obj) && obj.length === 0) {
      return adjustedPrefix + "[]";
    }
    for (var j = 0; j < objKeys.length; ++j) {
      var key = objKeys[j];
      var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj[key];
      if (skipNulls && value === null) {
        continue;
      }
      var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
      var keyPrefix = isArray2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
      sideChannel2.set(object, step);
      var valueSideChannel = getSideChannel();
      valueSideChannel.set(sentinel, sideChannel2);
      pushToArray(values, stringify22(
        value,
        keyPrefix,
        generateArrayPrefix,
        commaRoundTrip,
        allowEmptyArrays,
        strictNullHandling,
        skipNulls,
        encodeDotInKeys,
        generateArrayPrefix === "comma" && encodeValuesOnly && isArray2(obj) ? null : encoder2,
        filter2,
        sort,
        allowDots,
        serializeDate,
        format,
        formatter,
        encodeValuesOnly,
        charset2,
        valueSideChannel
      ));
    }
    return values;
  };
  var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
    if (!opts) {
      return defaults2;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
      throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    var charset2 = opts.charset || defaults2.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var format = formats2["default"];
    if (typeof opts.format !== "undefined") {
      if (!has.call(formats2.formatters, opts.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      format = opts.format;
    }
    var formatter = formats2.formatters[format];
    var filter2 = defaults2.filter;
    if (typeof opts.filter === "function" || isArray2(opts.filter)) {
      filter2 = opts.filter;
    }
    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = opts.arrayFormat;
    } else if ("indices" in opts) {
      arrayFormat = opts.indices ? "indices" : "repeat";
    } else {
      arrayFormat = defaults2.arrayFormat;
    }
    if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults2.allowDots : !!opts.allowDots;
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults2.addQueryPrefix,
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults2.allowEmptyArrays,
      arrayFormat,
      charset: charset2,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
      commaRoundTrip: !!opts.commaRoundTrip,
      delimiter: typeof opts.delimiter === "undefined" ? defaults2.delimiter : opts.delimiter,
      encode: typeof opts.encode === "boolean" ? opts.encode : defaults2.encode,
      encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults2.encodeDotInKeys,
      encoder: typeof opts.encoder === "function" ? opts.encoder : defaults2.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults2.encodeValuesOnly,
      filter: filter2,
      format,
      formatter,
      serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults2.serializeDate,
      skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults2.skipNulls,
      sort: typeof opts.sort === "function" ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling
    };
  };
  stringify_1 = function(object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter2;
    if (typeof options.filter === "function") {
      filter2 = options.filter;
      obj = filter2("", obj);
    } else if (isArray2(options.filter)) {
      filter2 = options.filter;
      objKeys = filter2;
    }
    var keys = [];
    if (typeof obj !== "object" || obj === null) {
      return "";
    }
    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (options.sort) {
      objKeys.sort(options.sort);
    }
    var sideChannel2 = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
      var key = objKeys[i];
      var value = obj[key];
      if (options.skipNulls && value === null) {
        continue;
      }
      pushToArray(keys, stringify2(
        value,
        key,
        generateArrayPrefix,
        commaRoundTrip,
        options.allowEmptyArrays,
        options.strictNullHandling,
        options.skipNulls,
        options.encodeDotInKeys,
        options.encode ? options.encoder : null,
        options.filter,
        options.sort,
        options.allowDots,
        options.serializeDate,
        options.format,
        options.formatter,
        options.encodeValuesOnly,
        options.charset,
        sideChannel2
      ));
    }
    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? "?" : "";
    if (options.charsetSentinel) {
      if (options.charset === "iso-8859-1") {
        prefix += "utf8=%26%2310003%3B&";
      } else {
        prefix += "utf8=%E2%9C%93&";
      }
    }
    return joined.length > 0 ? prefix + joined : "";
  };
  return stringify_1;
}
var parse;
var hasRequiredParse$2;
function requireParse$2() {
  if (hasRequiredParse$2) return parse;
  hasRequiredParse$2 = 1;
  var utils2 = /* @__PURE__ */ requireUtils$1$1();
  var has = Object.prototype.hasOwnProperty;
  var isArray2 = Array.isArray;
  var defaults2 = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils2.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1e3,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false,
    throwOnLimitExceeded: false
  };
  var interpretNumericEntities = function(str) {
    return str.replace(/&#(\d+);/g, function($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  };
  var parseArrayValue = function(val, options, currentArrayLength) {
    if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
      return val.split(",");
    }
    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
      throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
    }
    return val;
  };
  var isoSentinel = "utf8=%26%2310003%3B";
  var charsetSentinel = "utf8=%E2%9C%93";
  var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
    cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
    var parts = cleanStr.split(
      options.delimiter,
      options.throwOnLimitExceeded ? limit + 1 : limit
    );
    if (options.throwOnLimitExceeded && parts.length > limit) {
      throw new RangeError("Parameter limit exceeded. Only " + limit + " parameter" + (limit === 1 ? "" : "s") + " allowed.");
    }
    var skipIndex = -1;
    var i;
    var charset2 = options.charset;
    if (options.charsetSentinel) {
      for (i = 0; i < parts.length; ++i) {
        if (parts[i].indexOf("utf8=") === 0) {
          if (parts[i] === charsetSentinel) {
            charset2 = "utf-8";
          } else if (parts[i] === isoSentinel) {
            charset2 = "iso-8859-1";
          }
          skipIndex = i;
          i = parts.length;
        }
      }
    }
    for (i = 0; i < parts.length; ++i) {
      if (i === skipIndex) {
        continue;
      }
      var part = parts[i];
      var bracketEqualsPos = part.indexOf("]=");
      var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
      var key;
      var val;
      if (pos === -1) {
        key = options.decoder(part, defaults2.decoder, charset2, "key");
        val = options.strictNullHandling ? null : "";
      } else {
        key = options.decoder(part.slice(0, pos), defaults2.decoder, charset2, "key");
        val = utils2.maybeMap(
          parseArrayValue(
            part.slice(pos + 1),
            options,
            isArray2(obj[key]) ? obj[key].length : 0
          ),
          function(encodedVal) {
            return options.decoder(encodedVal, defaults2.decoder, charset2, "value");
          }
        );
      }
      if (val && options.interpretNumericEntities && charset2 === "iso-8859-1") {
        val = interpretNumericEntities(String(val));
      }
      if (part.indexOf("[]=") > -1) {
        val = isArray2(val) ? [val] : val;
      }
      var existing = has.call(obj, key);
      if (existing && options.duplicates === "combine") {
        obj[key] = utils2.combine(obj[key], val);
      } else if (!existing || options.duplicates === "last") {
        obj[key] = val;
      }
    }
    return obj;
  };
  var parseObject = function(chain, val, options, valuesParsed) {
    var currentArrayLength = 0;
    if (chain.length > 0 && chain[chain.length - 1] === "[]") {
      var parentKey = chain.slice(0, -1).join("");
      currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
    }
    var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
    for (var i = chain.length - 1; i >= 0; --i) {
      var obj;
      var root = chain[i];
      if (root === "[]" && options.parseArrays) {
        obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : utils2.combine([], leaf);
      } else {
        obj = options.plainObjects ? { __proto__: null } : {};
        var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
        var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
        var index2 = parseInt(decodedRoot, 10);
        if (!options.parseArrays && decodedRoot === "") {
          obj = { 0: leaf };
        } else if (!isNaN(index2) && root !== decodedRoot && String(index2) === decodedRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
          obj = [];
          obj[index2] = leaf;
        } else if (decodedRoot !== "__proto__") {
          obj[decodedRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
      return;
    }
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;
    var keys = [];
    if (parent) {
      if (!options.plainObjects && has.call(Object.prototype, parent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(parent);
    }
    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
      i += 1;
      if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }
    if (segment) {
      if (options.strictDepth === true) {
        throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
      }
      keys.push("[" + key.slice(segment.index) + "]");
    }
    return parseObject(keys, val, options, valuesParsed);
  };
  var normalizeParseOptions = function normalizeParseOptions2(opts) {
    if (!opts) {
      return defaults2;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
      throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
      throw new TypeError("Decoder has to be a function.");
    }
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") {
      throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
    }
    var charset2 = typeof opts.charset === "undefined" ? defaults2.charset : opts.charset;
    var duplicates = typeof opts.duplicates === "undefined" ? defaults2.duplicates : opts.duplicates;
    if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
      throw new TypeError("The duplicates option must be either combine, first, or last");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults2.allowDots : !!opts.allowDots;
    return {
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults2.allowEmptyArrays,
      allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults2.allowPrototypes,
      allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults2.allowSparse,
      arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults2.arrayLimit,
      charset: charset2,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
      comma: typeof opts.comma === "boolean" ? opts.comma : defaults2.comma,
      decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults2.decodeDotInKeys,
      decoder: typeof opts.decoder === "function" ? opts.decoder : defaults2.decoder,
      delimiter: typeof opts.delimiter === "string" || utils2.isRegExp(opts.delimiter) ? opts.delimiter : defaults2.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults2.depth,
      duplicates,
      ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults2.interpretNumericEntities,
      parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults2.parameterLimit,
      parseArrays: opts.parseArrays !== false,
      plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults2.plainObjects,
      strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults2.strictDepth,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling,
      throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
    };
  };
  parse = function(str, opts) {
    var options = normalizeParseOptions(opts);
    if (str === "" || str === null || typeof str === "undefined") {
      return options.plainObjects ? { __proto__: null } : {};
    }
    var tempObj = typeof str === "string" ? parseValues(str, options) : str;
    var obj = options.plainObjects ? { __proto__: null } : {};
    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
      obj = utils2.merge(obj, newObj, options);
    }
    if (options.allowSparse === true) {
      return obj;
    }
    return utils2.compact(obj);
  };
  return parse;
}
var lib$3;
var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3) return lib$3;
  hasRequiredLib$3 = 1;
  var stringify2 = /* @__PURE__ */ requireStringify$1();
  var parse2 = /* @__PURE__ */ requireParse$2();
  var formats2 = /* @__PURE__ */ requireFormats();
  lib$3 = {
    formats: formats2,
    parse: parse2,
    stringify: stringify2
  };
  return lib$3;
}
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var urlencoded_1;
var hasRequiredUrlencoded;
function requireUrlencoded() {
  if (hasRequiredUrlencoded) return urlencoded_1;
  hasRequiredUrlencoded = 1;
  var createError = requireHttpErrors();
  var debug2 = requireBrowser$2()("body-parser:urlencoded");
  var isFinished = requireOnFinished().isFinished;
  var read = requireRead();
  var typeis = requireTypeIs();
  var qs = /* @__PURE__ */ requireLib$3();
  var { getCharset, normalizeOptions } = requireUtils$2$1();
  urlencoded_1 = urlencoded2;
  function urlencoded2(options) {
    var { inflate, limit, verify, shouldParse } = normalizeOptions(options, "application/x-www-form-urlencoded");
    var defaultCharset = options?.defaultCharset || "utf-8";
    if (defaultCharset !== "utf-8" && defaultCharset !== "iso-8859-1") {
      throw new TypeError("option defaultCharset must be either utf-8 or iso-8859-1");
    }
    var queryparse = createQueryParser(options);
    function parse2(body, encoding2) {
      return body.length ? queryparse(body, encoding2) : {};
    }
    return function urlencodedParser(req, res, next) {
      if (isFinished(req)) {
        debug2("body already parsed");
        next();
        return;
      }
      if (!("body" in req)) {
        req.body = void 0;
      }
      if (!typeis.hasBody(req)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug2("skip parsing");
        next();
        return;
      }
      var charset2 = getCharset(req) || defaultCharset;
      if (charset2 !== "utf-8" && charset2 !== "iso-8859-1") {
        debug2("invalid charset");
        next(createError(415, 'unsupported charset "' + charset2.toUpperCase() + '"', {
          charset: charset2,
          type: "charset.unsupported"
        }));
        return;
      }
      read(req, res, next, parse2, debug2, {
        encoding: charset2,
        inflate,
        limit,
        verify
      });
    };
  }
  function createQueryParser(options) {
    var extended = Boolean(options?.extended);
    var parameterLimit = options?.parameterLimit !== void 0 ? options?.parameterLimit : 1e3;
    var charsetSentinel = options?.charsetSentinel;
    var interpretNumericEntities = options?.interpretNumericEntities;
    var depth = extended ? options?.depth !== void 0 ? options?.depth : 32 : 0;
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError("option parameterLimit must be a positive number");
    }
    if (isNaN(depth) || depth < 0) {
      throw new TypeError("option depth must be a zero or a positive number");
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body, encoding2) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === void 0) {
        debug2("too many parameters");
        throw createError(413, "too many parameters", {
          type: "parameters.too.many"
        });
      }
      var arrayLimit = extended ? Math.max(100, paramCount) : 0;
      debug2("parse " + (extended ? "extended " : "") + "urlencoding");
      try {
        return qs.parse(body, {
          allowPrototypes: true,
          arrayLimit,
          depth,
          charsetSentinel,
          interpretNumericEntities,
          charset: encoding2,
          parameterLimit,
          strictDepth: true
        });
      } catch (err) {
        if (err instanceof RangeError) {
          throw createError(400, "The input exceeded the depth", {
            type: "querystring.parse.rangeError"
          });
        } else {
          throw err;
        }
      }
    };
  }
  function parameterCount(body, limit) {
    var len = body.split("&").length;
    return len > limit ? void 0 : len - 1;
  }
  return urlencoded_1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredBodyParser;
function requireBodyParser() {
  if (hasRequiredBodyParser) return bodyParser.exports;
  hasRequiredBodyParser = 1;
  (function(module, exports) {
    exports = module.exports = bodyParser2;
    Object.defineProperty(exports, "json", {
      configurable: true,
      enumerable: true,
      get: () => requireJson()
    });
    Object.defineProperty(exports, "raw", {
      configurable: true,
      enumerable: true,
      get: () => requireRaw()
    });
    Object.defineProperty(exports, "text", {
      configurable: true,
      enumerable: true,
      get: () => requireText()
    });
    Object.defineProperty(exports, "urlencoded", {
      configurable: true,
      enumerable: true,
      get: () => requireUrlencoded()
    });
    function bodyParser2() {
      throw new Error("The bodyParser() generic has been split into individual middleware to use instead.");
    }
  })(bodyParser, bodyParser.exports);
  return bodyParser.exports;
}
var mergeDescriptors_1;
var hasRequiredMergeDescriptors;
function requireMergeDescriptors() {
  if (hasRequiredMergeDescriptors) return mergeDescriptors_1;
  hasRequiredMergeDescriptors = 1;
  function mergeDescriptors(destination, source, overwrite = true) {
    if (!destination) {
      throw new TypeError("The `destination` argument is required.");
    }
    if (!source) {
      throw new TypeError("The `source` argument is required.");
    }
    for (const name of Object.getOwnPropertyNames(source)) {
      if (!overwrite && Object.hasOwn(destination, name)) {
        continue;
      }
      const descriptor = Object.getOwnPropertyDescriptor(source, name);
      Object.defineProperty(destination, name, descriptor);
    }
    return destination;
  }
  mergeDescriptors_1 = mergeDescriptors;
  return mergeDescriptors_1;
}
var application = { exports: {} };
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var encodeurl;
var hasRequiredEncodeurl;
function requireEncodeurl() {
  if (hasRequiredEncodeurl) return encodeurl;
  hasRequiredEncodeurl = 1;
  encodeurl = encodeUrl;
  var ENCODE_CHARS_REGEXP = /(?:[^\x21\x23-\x3B\x3D\x3F-\x5F\x61-\x7A\x7C\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
  var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
  var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1$2";
  function encodeUrl(url) {
    return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
  }
  return encodeurl;
}
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
var escapeHtml_1;
var hasRequiredEscapeHtml;
function requireEscapeHtml() {
  if (hasRequiredEscapeHtml) return escapeHtml_1;
  hasRequiredEscapeHtml = 1;
  var matchHtmlRegExp = /["'&<>]/;
  escapeHtml_1 = escapeHtml;
  function escapeHtml(string) {
    var str = "" + string;
    var match = matchHtmlRegExp.exec(str);
    if (!match) {
      return str;
    }
    var escape2;
    var html = "";
    var index2 = 0;
    var lastIndex = 0;
    for (index2 = match.index; index2 < str.length; index2++) {
      switch (str.charCodeAt(index2)) {
        case 34:
          escape2 = "&quot;";
          break;
        case 38:
          escape2 = "&amp;";
          break;
        case 39:
          escape2 = "&#39;";
          break;
        case 60:
          escape2 = "&lt;";
          break;
        case 62:
          escape2 = "&gt;";
          break;
        default:
          continue;
      }
      if (lastIndex !== index2) {
        html += str.substring(lastIndex, index2);
      }
      lastIndex = index2 + 1;
      html += escape2;
    }
    return lastIndex !== index2 ? html + str.substring(lastIndex, index2) : html;
  }
  return escapeHtml_1;
}
var parseurl = { exports: {} };
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredParseurl;
function requireParseurl() {
  if (hasRequiredParseurl) return parseurl.exports;
  hasRequiredParseurl = 1;
  var url = require$$0$6;
  var parse2 = url.parse;
  var Url = url.Url;
  parseurl.exports = parseurl$1;
  parseurl.exports.original = originalurl;
  function parseurl$1(req) {
    var url2 = req.url;
    if (url2 === void 0) {
      return void 0;
    }
    var parsed = req._parsedUrl;
    if (fresh(url2, parsed)) {
      return parsed;
    }
    parsed = fastparse(url2);
    parsed._raw = url2;
    return req._parsedUrl = parsed;
  }
  function originalurl(req) {
    var url2 = req.originalUrl;
    if (typeof url2 !== "string") {
      return parseurl$1(req);
    }
    var parsed = req._parsedOriginalUrl;
    if (fresh(url2, parsed)) {
      return parsed;
    }
    parsed = fastparse(url2);
    parsed._raw = url2;
    return req._parsedOriginalUrl = parsed;
  }
  function fastparse(str) {
    if (typeof str !== "string" || str.charCodeAt(0) !== 47) {
      return parse2(str);
    }
    var pathname = str;
    var query = null;
    var search = null;
    for (var i = 1; i < str.length; i++) {
      switch (str.charCodeAt(i)) {
        case 63:
          if (search === null) {
            pathname = str.substring(0, i);
            query = str.substring(i + 1);
            search = str.substring(i);
          }
          break;
        case 9:
        /* \t */
        case 10:
        /* \n */
        case 12:
        /* \f */
        case 13:
        /* \r */
        case 32:
        /*    */
        case 35:
        /* #  */
        case 160:
        case 65279:
          return parse2(str);
      }
    }
    var url2 = Url !== void 0 ? new Url() : {};
    url2.path = str;
    url2.href = str;
    url2.pathname = pathname;
    if (search !== null) {
      url2.query = query;
      url2.search = search;
    }
    return url2;
  }
  function fresh(url2, parsedUrl) {
    return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url2;
  }
  return parseurl.exports;
}
/*!
 * finalhandler
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var finalhandler_1;
var hasRequiredFinalhandler;
function requireFinalhandler() {
  if (hasRequiredFinalhandler) return finalhandler_1;
  hasRequiredFinalhandler = 1;
  var debug2 = requireBrowser$2()("finalhandler");
  var encodeUrl = requireEncodeurl();
  var escapeHtml = requireEscapeHtml();
  var onFinished2 = requireOnFinished();
  var parseUrl = requireParseurl();
  var statuses2 = requireStatuses();
  var isFinished = onFinished2.isFinished;
  function createHtmlDocument(message) {
    var body = escapeHtml(message).replaceAll("\n", "<br>").replaceAll("  ", " &nbsp;");
    return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
  }
  finalhandler_1 = finalhandler;
  function finalhandler(req, res, options) {
    var opts = options || {};
    var env = opts.env || process.env.NODE_ENV || "development";
    var onerror = opts.onerror;
    return function(err) {
      var headers2;
      var msg;
      var status;
      if (!err && res.headersSent) {
        debug2("cannot 404 after headers sent");
        return;
      }
      if (err) {
        status = getErrorStatusCode(err);
        if (status === void 0) {
          status = getResponseStatusCode(res);
        } else {
          headers2 = getErrorHeaders(err);
        }
        msg = getErrorMessage(err, status, env);
      } else {
        status = 404;
        msg = "Cannot " + req.method + " " + encodeUrl(getResourceName(req));
      }
      debug2("default %s", status);
      if (err && onerror) {
        setImmediate(onerror, err, req, res);
      }
      if (res.headersSent) {
        debug2("cannot %d after headers sent", status);
        if (req.socket) {
          req.socket.destroy();
        }
        return;
      }
      send(req, res, status, headers2, msg);
    };
  }
  function getErrorHeaders(err) {
    if (!err.headers || typeof err.headers !== "object") {
      return void 0;
    }
    return { ...err.headers };
  }
  function getErrorMessage(err, status, env) {
    var msg;
    if (env !== "production") {
      msg = err.stack;
      if (!msg && typeof err.toString === "function") {
        msg = err.toString();
      }
    }
    return msg || statuses2.message[status];
  }
  function getErrorStatusCode(err) {
    if (typeof err.status === "number" && err.status >= 400 && err.status < 600) {
      return err.status;
    }
    if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) {
      return err.statusCode;
    }
    return void 0;
  }
  function getResourceName(req) {
    try {
      return parseUrl.original(req).pathname;
    } catch (e) {
      return "resource";
    }
  }
  function getResponseStatusCode(res) {
    var status = res.statusCode;
    if (typeof status !== "number" || status < 400 || status > 599) {
      status = 500;
    }
    return status;
  }
  function send(req, res, status, headers2, message) {
    function write() {
      var body = createHtmlDocument(message);
      res.statusCode = status;
      if (req.httpVersionMajor < 2) {
        res.statusMessage = statuses2.message[status];
      }
      res.removeHeader("Content-Encoding");
      res.removeHeader("Content-Language");
      res.removeHeader("Content-Range");
      for (const [key, value] of Object.entries(headers2 ?? {})) {
        res.setHeader(key, value);
      }
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.setHeader("Content-Type", "text/html; charset=utf-8");
      res.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
      if (req.method === "HEAD") {
        res.end();
        return;
      }
      res.end(body, "utf8");
    }
    if (isFinished(req)) {
      write();
      return;
    }
    req.unpipe();
    onFinished2(req, write);
    req.resume();
  }
  return finalhandler_1;
}
function commonjsRequire$1(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var view;
var hasRequiredView;
function requireView() {
  if (hasRequiredView) return view;
  hasRequiredView = 1;
  var debug2 = requireBrowser$2()("express:view");
  var path$1 = path;
  var fs2 = fs$1;
  var dirname = path$1.dirname;
  var basename = path$1.basename;
  var extname = path$1.extname;
  var join = path$1.join;
  var resolve = path$1.resolve;
  view = View;
  function View(name, options) {
    var opts = options || {};
    this.defaultEngine = opts.defaultEngine;
    this.ext = extname(name);
    this.name = name;
    this.root = opts.root;
    if (!this.ext && !this.defaultEngine) {
      throw new Error("No default engine was specified and no extension was provided.");
    }
    var fileName = name;
    if (!this.ext) {
      this.ext = this.defaultEngine[0] !== "." ? "." + this.defaultEngine : this.defaultEngine;
      fileName += this.ext;
    }
    if (!opts.engines[this.ext]) {
      var mod = this.ext.slice(1);
      debug2('require "%s"', mod);
      var fn = commonjsRequire$1(mod).__express;
      if (typeof fn !== "function") {
        throw new Error('Module "' + mod + '" does not provide a view engine.');
      }
      opts.engines[this.ext] = fn;
    }
    this.engine = opts.engines[this.ext];
    this.path = this.lookup(fileName);
  }
  View.prototype.lookup = function lookup(name) {
    var path2;
    var roots = [].concat(this.root);
    debug2('lookup "%s"', name);
    for (var i = 0; i < roots.length && !path2; i++) {
      var root = roots[i];
      var loc = resolve(root, name);
      var dir = dirname(loc);
      var file2 = basename(loc);
      path2 = this.resolve(dir, file2);
    }
    return path2;
  };
  View.prototype.render = function render(options, callback) {
    var sync = true;
    debug2('render "%s"', this.path);
    this.engine(this.path, options, function onRender() {
      if (!sync) {
        return callback.apply(this, arguments);
      }
      var args = new Array(arguments.length);
      var cntx = this;
      for (var i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      return process.nextTick(function renderTick() {
        return callback.apply(cntx, args);
      });
    });
    sync = false;
  };
  View.prototype.resolve = function resolve2(dir, file2) {
    var ext = this.ext;
    var path2 = join(dir, file2);
    var stat2 = tryStat(path2);
    if (stat2 && stat2.isFile()) {
      return path2;
    }
    path2 = join(dir, basename(file2, ext), "index" + ext);
    stat2 = tryStat(path2);
    if (stat2 && stat2.isFile()) {
      return path2;
    }
  };
  function tryStat(path2) {
    debug2('stat "%s"', path2);
    try {
      return fs2.statSync(path2);
    } catch (e) {
      return void 0;
    }
  }
  return view;
}
var utils$4 = {};
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var etag_1;
var hasRequiredEtag;
function requireEtag() {
  if (hasRequiredEtag) return etag_1;
  hasRequiredEtag = 1;
  etag_1 = etag;
  var crypto2 = crypto$1;
  var Stats = require$$1$2.Stats;
  var toString3 = Object.prototype.toString;
  function entitytag(entity) {
    if (entity.length === 0) {
      return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
    }
    var hash = crypto2.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
    var len = typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length;
    return '"' + len.toString(16) + "-" + hash + '"';
  }
  function etag(entity, options) {
    if (entity == null) {
      throw new TypeError("argument entity is required");
    }
    var isStats = isstats(entity);
    var weak = options && typeof options.weak === "boolean" ? options.weak : isStats;
    if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) {
      throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
    }
    var tag = isStats ? stattag(entity) : entitytag(entity);
    return weak ? "W/" + tag : tag;
  }
  function isstats(obj) {
    if (typeof Stats === "function" && obj instanceof Stats) {
      return true;
    }
    return obj && typeof obj === "object" && "ctime" in obj && toString3.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString3.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
  }
  function stattag(stat2) {
    var mtime = stat2.mtime.getTime().toString(16);
    var size = stat2.size.toString(16);
    return '"' + size + "-" + mtime + '"';
  }
  return etag_1;
}
var proxyAddr = { exports: {} };
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var forwarded_1;
var hasRequiredForwarded;
function requireForwarded() {
  if (hasRequiredForwarded) return forwarded_1;
  hasRequiredForwarded = 1;
  forwarded_1 = forwarded;
  function forwarded(req) {
    if (!req) {
      throw new TypeError("argument req is required");
    }
    var proxyAddrs = parse2(req.headers["x-forwarded-for"] || "");
    var socketAddr = getSocketAddr(req);
    var addrs = [socketAddr].concat(proxyAddrs);
    return addrs;
  }
  function getSocketAddr(req) {
    return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
  }
  function parse2(header) {
    var end = header.length;
    var list = [];
    var start = header.length;
    for (var i = header.length - 1; i >= 0; i--) {
      switch (header.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i;
          }
          break;
        case 44:
          if (start !== end) {
            list.push(header.substring(start, end));
          }
          start = end = i;
          break;
        default:
          start = i;
          break;
      }
    }
    if (start !== end) {
      list.push(header.substring(start, end));
    }
    return list;
  }
  return forwarded_1;
}
var ipaddr$1 = { exports: {} };
var ipaddr = ipaddr$1.exports;
var hasRequiredIpaddr;
function requireIpaddr() {
  if (hasRequiredIpaddr) return ipaddr$1.exports;
  hasRequiredIpaddr = 1;
  (function(module) {
    (function() {
      var expandIPv6, ipaddr2, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;
      ipaddr2 = {};
      root = this;
      if (module !== null && module.exports) {
        module.exports = ipaddr2;
      } else {
        root["ipaddr"] = ipaddr2;
      }
      matchCIDR = function(first, second, partSize, cidrBits) {
        var part, shift;
        if (first.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        part = 0;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      };
      ipaddr2.subnetMatch = function(address, rangeList, defaultName) {
        var k, len, rangeName, rangeSubnets, subnet;
        if (defaultName == null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          rangeSubnets = rangeList[rangeName];
          if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
            rangeSubnets = [rangeSubnets];
          }
          for (k = 0, len = rangeSubnets.length; k < len; k++) {
            subnet = rangeSubnets[k];
            if (address.kind() === subnet[0].kind()) {
              if (address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      ipaddr2.IPv4 = function() {
        function IPv4(octets) {
          var k, len, octet;
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          for (k = 0, len = octets.length; k < len; k++) {
            octet = octets[k];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.match = function(other, cidrRange) {
          var ref2;
          if (cidrRange === void 0) {
            ref2 = other, other = ref2[0], cidrRange = ref2[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
          reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
        };
        IPv4.prototype.range = function() {
          return ipaddr2.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr2.IPv6.parse("::ffff:" + this.toString());
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          var cidr, i, k, octet, stop, zeros, zerotable;
          zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 3; k >= 0; i = k += -1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        return IPv4;
      }();
      ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      ipv4Regexes = {
        fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
        longValue: new RegExp("^" + ipv4Part + "$", "i")
      };
      ipaddr2.IPv4.parser = function(string) {
        var match, parseIntAuto, part, shift, value;
        parseIntAuto = function(string2) {
          if (string2[0] === "0" && string2[1] !== "x") {
            return parseInt(string2, 8);
          } else {
            return parseInt(string2);
          }
        };
        if (match = string.match(ipv4Regexes.fourOctet)) {
          return function() {
            var k, len, ref2, results;
            ref2 = match.slice(1, 6);
            results = [];
            for (k = 0, len = ref2.length; k < len; k++) {
              part = ref2[k];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function() {
            var k, results;
            results = [];
            for (shift = k = 0; k <= 24; shift = k += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          }().reverse();
        } else {
          return null;
        }
      };
      ipaddr2.IPv6 = function() {
        function IPv6(parts, zoneId) {
          var i, k, l, len, part, ref2;
          if (parts.length === 16) {
            this.parts = [];
            for (i = k = 0; k <= 14; i = k += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          ref2 = this.parts;
          for (l = 0, len = ref2.length; l < len; l++) {
            part = ref2[l];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.toString = function() {
          return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
        };
        IPv6.prototype.toRFC5952String = function() {
          var bestMatchIndex, bestMatchLength, match, regex2, string;
          regex2 = /((^|:)(0(:|$)){2,})/g;
          string = this.toNormalizedString();
          bestMatchIndex = 0;
          bestMatchLength = -1;
          while (match = regex2.exec(string)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string;
          }
          return string.substring(0, bestMatchIndex) + "::" + string.substring(bestMatchIndex + bestMatchLength);
        };
        IPv6.prototype.toByteArray = function() {
          var bytes2, k, len, part, ref2;
          bytes2 = [];
          ref2 = this.parts;
          for (k = 0, len = ref2.length; k < len; k++) {
            part = ref2[k];
            bytes2.push(part >> 8);
            bytes2.push(part & 255);
          }
          return bytes2;
        };
        IPv6.prototype.toNormalizedString = function() {
          var addr, part, suffix;
          addr = function() {
            var k, len, ref2, results;
            ref2 = this.parts;
            results = [];
            for (k = 0, len = ref2.length; k < len; k++) {
              part = ref2[k];
              results.push(part.toString(16));
            }
            return results;
          }.call(this).join(":");
          suffix = "";
          if (this.zoneId) {
            suffix = "%" + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.toFixedLengthString = function() {
          var addr, part, suffix;
          addr = function() {
            var k, len, ref2, results;
            ref2 = this.parts;
            results = [];
            for (k = 0, len = ref2.length; k < len; k++) {
              part = ref2[k];
              results.push(part.toString(16).padStart(4, "0"));
            }
            return results;
          }.call(this).join(":");
          suffix = "";
          if (this.zoneId) {
            suffix = "%" + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.match = function(other, cidrRange) {
          var ref2;
          if (cidrRange === void 0) {
            ref2 = other, other = ref2[0], cidrRange = ref2[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.SpecialRanges = {
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
        };
        IPv6.prototype.range = function() {
          return ipaddr2.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.toIPv4Address = function() {
          var high, low, ref2;
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          ref2 = this.parts.slice(-2), high = ref2[0], low = ref2[1];
          return new ipaddr2.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          var cidr, i, k, part, stop, zeros, zerotable;
          zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 7; k >= 0; i = k += -1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        return IPv6;
      }();
      ipv6Part = "(?:[0-9a-f]+::?)+";
      zoneIndex = "%[0-9a-z]{1,}";
      ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", "i"),
        transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), "i")
      };
      expandIPv6 = function(string, parts) {
        var colonCount, lastColon, part, replacement, replacementCount, zoneId;
        if (string.indexOf("::") !== string.lastIndexOf("::")) {
          return null;
        }
        zoneId = (string.match(ipv6Regexes["zoneIndex"]) || [])[0];
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string = string.replace(/%.+$/, "");
        }
        colonCount = 0;
        lastColon = -1;
        while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string = string.replace("::", replacement);
        if (string[0] === ":") {
          string = string.slice(1);
        }
        if (string[string.length - 1] === ":") {
          string = string.slice(0, -1);
        }
        parts = function() {
          var k, len, ref2, results;
          ref2 = string.split(":");
          results = [];
          for (k = 0, len = ref2.length; k < len; k++) {
            part = ref2[k];
            results.push(parseInt(part, 16));
          }
          return results;
        }();
        return {
          parts,
          zoneId
        };
      };
      ipaddr2.IPv6.parser = function(string) {
        var addr, k, len, match, octet, octets, zoneId;
        if (ipv6Regexes["native"].test(string)) {
          return expandIPv6(string, 8);
        } else if (match = string.match(ipv6Regexes["transitional"])) {
          zoneId = match[6] || "";
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
            for (k = 0, len = octets.length; k < len; k++) {
              octet = octets[k];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr2.IPv4.isIPv4 = ipaddr2.IPv6.isIPv6 = function(string) {
        return this.parser(string) !== null;
      };
      ipaddr2.IPv4.isValid = function(string) {
        try {
          new this(this.parser(string));
          return true;
        } catch (error1) {
          return false;
        }
      };
      ipaddr2.IPv4.isValidFourPartDecimal = function(string) {
        if (ipaddr2.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr2.IPv6.isValid = function(string) {
        var addr;
        if (typeof string === "string" && string.indexOf(":") === -1) {
          return false;
        }
        try {
          addr = this.parser(string);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (error1) {
          return false;
        }
      };
      ipaddr2.IPv4.parse = function(string) {
        var parts;
        parts = this.parser(string);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(parts);
      };
      ipaddr2.IPv6.parse = function(string) {
        var addr;
        addr = this.parser(string);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr2.IPv4.parseCIDR = function(string) {
        var maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr2.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        var filledOctetCount, j, octets;
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        octets = [0, 0, 0, 0];
        j = 0;
        filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr2.IPv4.broadcastAddressFromCIDR = function(string) {
        var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (error1) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr2.IPv4.networkAddressFromCIDR = function(string) {
        var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (error1) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr2.IPv6.parseCIDR = function(string) {
        var maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr2.isValid = function(string) {
        return ipaddr2.IPv6.isValid(string) || ipaddr2.IPv4.isValid(string);
      };
      ipaddr2.parse = function(string) {
        if (ipaddr2.IPv6.isValid(string)) {
          return ipaddr2.IPv6.parse(string);
        } else if (ipaddr2.IPv4.isValid(string)) {
          return ipaddr2.IPv4.parse(string);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr2.parseCIDR = function(string) {
        try {
          return ipaddr2.IPv6.parseCIDR(string);
        } catch (error1) {
          try {
            return ipaddr2.IPv4.parseCIDR(string);
          } catch (error12) {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr2.fromByteArray = function(bytes2) {
        var length;
        length = bytes2.length;
        if (length === 4) {
          return new ipaddr2.IPv4(bytes2);
        } else if (length === 16) {
          return new ipaddr2.IPv6(bytes2);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr2.process = function(string) {
        var addr;
        addr = this.parse(string);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
    }).call(ipaddr);
  })(ipaddr$1);
  return ipaddr$1.exports;
}
/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredProxyAddr;
function requireProxyAddr() {
  if (hasRequiredProxyAddr) return proxyAddr.exports;
  hasRequiredProxyAddr = 1;
  proxyAddr.exports = proxyaddr;
  proxyAddr.exports.all = alladdrs;
  proxyAddr.exports.compile = compile;
  var forwarded = requireForwarded();
  var ipaddr2 = requireIpaddr();
  var DIGIT_REGEXP = /^[0-9]+$/;
  var isip = ipaddr2.isValid;
  var parseip = ipaddr2.parse;
  var IP_RANGES = {
    linklocal: ["169.254.0.0/16", "fe80::/10"],
    loopback: ["127.0.0.1/8", "::1/128"],
    uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
  };
  function alladdrs(req, trust) {
    var addrs = forwarded(req);
    if (!trust) {
      return addrs;
    }
    if (typeof trust !== "function") {
      trust = compile(trust);
    }
    for (var i = 0; i < addrs.length - 1; i++) {
      if (trust(addrs[i], i)) continue;
      addrs.length = i + 1;
    }
    return addrs;
  }
  function compile(val) {
    if (!val) {
      throw new TypeError("argument is required");
    }
    var trust;
    if (typeof val === "string") {
      trust = [val];
    } else if (Array.isArray(val)) {
      trust = val.slice();
    } else {
      throw new TypeError("unsupported trust argument");
    }
    for (var i = 0; i < trust.length; i++) {
      val = trust[i];
      if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
        continue;
      }
      val = IP_RANGES[val];
      trust.splice.apply(trust, [i, 1].concat(val));
      i += val.length - 1;
    }
    return compileTrust(compileRangeSubnets(trust));
  }
  function compileRangeSubnets(arr) {
    var rangeSubnets = new Array(arr.length);
    for (var i = 0; i < arr.length; i++) {
      rangeSubnets[i] = parseipNotation(arr[i]);
    }
    return rangeSubnets;
  }
  function compileTrust(rangeSubnets) {
    var len = rangeSubnets.length;
    return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
  }
  function parseipNotation(note) {
    var pos = note.lastIndexOf("/");
    var str = pos !== -1 ? note.substring(0, pos) : note;
    if (!isip(str)) {
      throw new TypeError("invalid IP address: " + str);
    }
    var ip = parseip(str);
    if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) {
      ip = ip.toIPv4Address();
    }
    var max2 = ip.kind() === "ipv6" ? 128 : 32;
    var range2 = pos !== -1 ? note.substring(pos + 1, note.length) : null;
    if (range2 === null) {
      range2 = max2;
    } else if (DIGIT_REGEXP.test(range2)) {
      range2 = parseInt(range2, 10);
    } else if (ip.kind() === "ipv4" && isip(range2)) {
      range2 = parseNetmask(range2);
    } else {
      range2 = null;
    }
    if (range2 <= 0 || range2 > max2) {
      throw new TypeError("invalid range on address: " + note);
    }
    return [ip, range2];
  }
  function parseNetmask(netmask) {
    var ip = parseip(netmask);
    var kind = ip.kind();
    return kind === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
  }
  function proxyaddr(req, trust) {
    if (!req) {
      throw new TypeError("req argument is required");
    }
    if (!trust) {
      throw new TypeError("trust argument is required");
    }
    var addrs = alladdrs(req, trust);
    var addr = addrs[addrs.length - 1];
    return addr;
  }
  function trustNone() {
    return false;
  }
  function trustMulti(subnets) {
    return function trust(addr) {
      if (!isip(addr)) return false;
      var ip = parseip(addr);
      var ipconv;
      var kind = ip.kind();
      for (var i = 0; i < subnets.length; i++) {
        var subnet = subnets[i];
        var subnetip = subnet[0];
        var subnetkind = subnetip.kind();
        var subnetrange = subnet[1];
        var trusted = ip;
        if (kind !== subnetkind) {
          if (subnetkind === "ipv4" && !ip.isIPv4MappedAddress()) {
            continue;
          }
          if (!ipconv) {
            ipconv = subnetkind === "ipv4" ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
          }
          trusted = ipconv;
        }
        if (trusted.match(subnetip, subnetrange)) {
          return true;
        }
      }
      return false;
    };
  }
  function trustSingle(subnet) {
    var subnetip = subnet[0];
    var subnetkind = subnetip.kind();
    var subnetisipv4 = subnetkind === "ipv4";
    var subnetrange = subnet[1];
    return function trust(addr) {
      if (!isip(addr)) return false;
      var ip = parseip(addr);
      var kind = ip.kind();
      if (kind !== subnetkind) {
        if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
          return false;
        }
        ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
      }
      return ip.match(subnetip, subnetrange);
    };
  }
  return proxyAddr.exports;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredUtils$4;
function requireUtils$4() {
  if (hasRequiredUtils$4) return utils$4;
  hasRequiredUtils$4 = 1;
  (function(exports) {
    var { METHODS } = require$$2$2;
    var contentType2 = requireContentType();
    var etag = requireEtag();
    var mime = requireMimeTypes();
    var proxyaddr = requireProxyAddr();
    var qs = /* @__PURE__ */ requireLib$3();
    var querystring = require$$6$1;
    exports.methods = METHODS.map((method) => method.toLowerCase());
    exports.etag = createETagGenerator({ weak: false });
    exports.wetag = createETagGenerator({ weak: true });
    exports.normalizeType = function(type2) {
      return ~type2.indexOf("/") ? acceptParams(type2) : { value: mime.lookup(type2) || "application/octet-stream", params: {} };
    };
    exports.normalizeTypes = function(types) {
      return types.map(exports.normalizeType);
    };
    function acceptParams(str) {
      var length = str.length;
      var colonIndex = str.indexOf(";");
      var index2 = colonIndex === -1 ? length : colonIndex;
      var ret = { value: str.slice(0, index2).trim(), quality: 1, params: {} };
      while (index2 < length) {
        var splitIndex = str.indexOf("=", index2);
        if (splitIndex === -1) break;
        var colonIndex = str.indexOf(";", index2);
        var endIndex = colonIndex === -1 ? length : colonIndex;
        if (splitIndex > endIndex) {
          index2 = str.lastIndexOf(";", splitIndex - 1) + 1;
          continue;
        }
        var key = str.slice(index2, splitIndex).trim();
        var value = str.slice(splitIndex + 1, endIndex).trim();
        if (key === "q") {
          ret.quality = parseFloat(value);
        } else {
          ret.params[key] = value;
        }
        index2 = endIndex + 1;
      }
      return ret;
    }
    exports.compileETag = function(val) {
      var fn;
      if (typeof val === "function") {
        return val;
      }
      switch (val) {
        case true:
        case "weak":
          fn = exports.wetag;
          break;
        case false:
          break;
        case "strong":
          fn = exports.etag;
          break;
        default:
          throw new TypeError("unknown value for etag function: " + val);
      }
      return fn;
    };
    exports.compileQueryParser = function compileQueryParser(val) {
      var fn;
      if (typeof val === "function") {
        return val;
      }
      switch (val) {
        case true:
        case "simple":
          fn = querystring.parse;
          break;
        case false:
          break;
        case "extended":
          fn = parseExtendedQueryString;
          break;
        default:
          throw new TypeError("unknown value for query parser function: " + val);
      }
      return fn;
    };
    exports.compileTrust = function(val) {
      if (typeof val === "function") return val;
      if (val === true) {
        return function() {
          return true;
        };
      }
      if (typeof val === "number") {
        return function(a, i) {
          return i < val;
        };
      }
      if (typeof val === "string") {
        val = val.split(",").map(function(v) {
          return v.trim();
        });
      }
      return proxyaddr.compile(val || []);
    };
    exports.setCharset = function setCharset(type2, charset2) {
      if (!type2 || !charset2) {
        return type2;
      }
      var parsed = contentType2.parse(type2);
      parsed.parameters.charset = charset2;
      return contentType2.format(parsed);
    };
    function createETagGenerator(options) {
      return function generateETag(body, encoding2) {
        var buf = !Buffer.isBuffer(body) ? Buffer.from(body, encoding2) : body;
        return etag(buf, options);
      };
    }
    function parseExtendedQueryString(str) {
      return qs.parse(str, {
        allowPrototypes: true
      });
    }
  })(utils$4);
  return utils$4;
}
var once = { exports: {} };
var wrappy_1;
var hasRequiredWrappy;
function requireWrappy() {
  if (hasRequiredWrappy) return wrappy_1;
  hasRequiredWrappy = 1;
  wrappy_1 = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb) return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret = fn.apply(this, args);
      var cb2 = args[args.length - 1];
      if (typeof ret === "function" && ret !== cb2) {
        Object.keys(cb2).forEach(function(k) {
          ret[k] = cb2[k];
        });
      }
      return ret;
    }
  }
  return wrappy_1;
}
var hasRequiredOnce;
function requireOnce() {
  if (hasRequiredOnce) return once.exports;
  hasRequiredOnce = 1;
  var wrappy = requireWrappy();
  once.exports = wrappy(once$1);
  once.exports.strict = wrappy(onceStrict);
  once$1.proto = once$1(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once$1(this);
      },
      configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: true
    });
  });
  function once$1(fn) {
    var f = function() {
      if (f.called) return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
  }
  function onceStrict(fn) {
    var f = function() {
      if (f.called)
        throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || "Function wrapped with `once`";
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
  }
  return once.exports;
}
var router$1 = { exports: {} };
var isPromise = { exports: {} };
var hasRequiredIsPromise;
function requireIsPromise() {
  if (hasRequiredIsPromise) return isPromise.exports;
  hasRequiredIsPromise = 1;
  isPromise.exports = isPromise$1;
  isPromise.exports.default = isPromise$1;
  function isPromise$1(obj) {
    return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
  }
  return isPromise.exports;
}
var dist$1 = {};
var hasRequiredDist$1;
function requireDist$1() {
  if (hasRequiredDist$1) return dist$1;
  hasRequiredDist$1 = 1;
  Object.defineProperty(dist$1, "__esModule", { value: true });
  dist$1.TokenData = void 0;
  dist$1.parse = parse2;
  dist$1.compile = compile;
  dist$1.match = match;
  dist$1.pathToRegexp = pathToRegexp;
  dist$1.stringify = stringify2;
  const DEFAULT_DELIMITER = "/";
  const NOOP_VALUE = (value) => value;
  const ID_START = /^[$_\p{ID_Start}]$/u;
  const ID_CONTINUE = /^[$\u200c\u200d\p{ID_Continue}]$/u;
  const DEBUG_URL = "https://git.new/pathToRegexpError";
  const SIMPLE_TOKENS = {
    // Groups.
    "{": "{",
    "}": "}",
    // Reserved.
    "(": "(",
    ")": ")",
    "[": "[",
    "]": "]",
    "+": "+",
    "?": "?",
    "!": "!"
  };
  function escapeText(str) {
    return str.replace(/[{}()\[\]+?!:*]/g, "\\$&");
  }
  function escape2(str) {
    return str.replace(/[.+*?^${}()[\]|/\\]/g, "\\$&");
  }
  function* lexer(str) {
    const chars = [...str];
    let i = 0;
    function name() {
      let value = "";
      if (ID_START.test(chars[++i])) {
        value += chars[i];
        while (ID_CONTINUE.test(chars[++i])) {
          value += chars[i];
        }
      } else if (chars[i] === '"') {
        let pos = i;
        while (i < chars.length) {
          if (chars[++i] === '"') {
            i++;
            pos = 0;
            break;
          }
          if (chars[i] === "\\") {
            value += chars[++i];
          } else {
            value += chars[i];
          }
        }
        if (pos) {
          throw new TypeError(`Unterminated quote at ${pos}: ${DEBUG_URL}`);
        }
      }
      if (!value) {
        throw new TypeError(`Missing parameter name at ${i}: ${DEBUG_URL}`);
      }
      return value;
    }
    while (i < chars.length) {
      const value = chars[i];
      const type2 = SIMPLE_TOKENS[value];
      if (type2) {
        yield { type: type2, index: i++, value };
      } else if (value === "\\") {
        yield { type: "ESCAPED", index: i++, value: chars[i++] };
      } else if (value === ":") {
        const value2 = name();
        yield { type: "PARAM", index: i, value: value2 };
      } else if (value === "*") {
        const value2 = name();
        yield { type: "WILDCARD", index: i, value: value2 };
      } else {
        yield { type: "CHAR", index: i, value: chars[i++] };
      }
    }
    return { type: "END", index: i, value: "" };
  }
  class Iter {
    constructor(tokens) {
      this.tokens = tokens;
    }
    peek() {
      if (!this._peek) {
        const next = this.tokens.next();
        this._peek = next.value;
      }
      return this._peek;
    }
    tryConsume(type2) {
      const token = this.peek();
      if (token.type !== type2)
        return;
      this._peek = void 0;
      return token.value;
    }
    consume(type2) {
      const value = this.tryConsume(type2);
      if (value !== void 0)
        return value;
      const { type: nextType, index: index2 } = this.peek();
      throw new TypeError(`Unexpected ${nextType} at ${index2}, expected ${type2}: ${DEBUG_URL}`);
    }
    text() {
      let result = "";
      let value;
      while (value = this.tryConsume("CHAR") || this.tryConsume("ESCAPED")) {
        result += value;
      }
      return result;
    }
  }
  class TokenData {
    constructor(tokens) {
      this.tokens = tokens;
    }
  }
  dist$1.TokenData = TokenData;
  function parse2(str, options = {}) {
    const { encodePath = NOOP_VALUE } = options;
    const it = new Iter(lexer(str));
    function consume(endType) {
      const tokens2 = [];
      while (true) {
        const path2 = it.text();
        if (path2)
          tokens2.push({ type: "text", value: encodePath(path2) });
        const param = it.tryConsume("PARAM");
        if (param) {
          tokens2.push({
            type: "param",
            name: param
          });
          continue;
        }
        const wildcard = it.tryConsume("WILDCARD");
        if (wildcard) {
          tokens2.push({
            type: "wildcard",
            name: wildcard
          });
          continue;
        }
        const open = it.tryConsume("{");
        if (open) {
          tokens2.push({
            type: "group",
            tokens: consume("}")
          });
          continue;
        }
        it.consume(endType);
        return tokens2;
      }
    }
    const tokens = consume("END");
    return new TokenData(tokens);
  }
  function compile(path2, options = {}) {
    const { encode: encode2 = encodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;
    const data2 = path2 instanceof TokenData ? path2 : parse2(path2, options);
    const fn = tokensToFunction(data2.tokens, delimiter, encode2);
    return function path22(data22 = {}) {
      const [path3, ...missing] = fn(data22);
      if (missing.length) {
        throw new TypeError(`Missing parameters: ${missing.join(", ")}`);
      }
      return path3;
    };
  }
  function tokensToFunction(tokens, delimiter, encode2) {
    const encoders = tokens.map((token) => tokenToFunction(token, delimiter, encode2));
    return (data2) => {
      const result = [""];
      for (const encoder2 of encoders) {
        const [value, ...extras] = encoder2(data2);
        result[0] += value;
        result.push(...extras);
      }
      return result;
    };
  }
  function tokenToFunction(token, delimiter, encode2) {
    if (token.type === "text")
      return () => [token.value];
    if (token.type === "group") {
      const fn = tokensToFunction(token.tokens, delimiter, encode2);
      return (data2) => {
        const [value, ...missing] = fn(data2);
        if (!missing.length)
          return [value];
        return [""];
      };
    }
    const encodeValue = encode2 || NOOP_VALUE;
    if (token.type === "wildcard" && encode2 !== false) {
      return (data2) => {
        const value = data2[token.name];
        if (value == null)
          return ["", token.name];
        if (!Array.isArray(value) || value.length === 0) {
          throw new TypeError(`Expected "${token.name}" to be a non-empty array`);
        }
        return [
          value.map((value2, index2) => {
            if (typeof value2 !== "string") {
              throw new TypeError(`Expected "${token.name}/${index2}" to be a string`);
            }
            return encodeValue(value2);
          }).join(delimiter)
        ];
      };
    }
    return (data2) => {
      const value = data2[token.name];
      if (value == null)
        return ["", token.name];
      if (typeof value !== "string") {
        throw new TypeError(`Expected "${token.name}" to be a string`);
      }
      return [encodeValue(value)];
    };
  }
  function match(path2, options = {}) {
    const { decode = decodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;
    const { regexp, keys } = pathToRegexp(path2, options);
    const decoders = keys.map((key) => {
      if (decode === false)
        return NOOP_VALUE;
      if (key.type === "param")
        return decode;
      return (value) => value.split(delimiter).map(decode);
    });
    return function match2(input) {
      const m = regexp.exec(input);
      if (!m)
        return false;
      const path22 = m[0];
      const params = /* @__PURE__ */ Object.create(null);
      for (let i = 1; i < m.length; i++) {
        if (m[i] === void 0)
          continue;
        const key = keys[i - 1];
        const decoder2 = decoders[i - 1];
        params[key.name] = decoder2(m[i]);
      }
      return { path: path22, params };
    };
  }
  function pathToRegexp(path2, options = {}) {
    const { delimiter = DEFAULT_DELIMITER, end = true, sensitive = false, trailing = true } = options;
    const keys = [];
    const sources = [];
    const flags = sensitive ? "" : "i";
    const paths = Array.isArray(path2) ? path2 : [path2];
    const items = paths.map((path22) => path22 instanceof TokenData ? path22 : parse2(path22, options));
    for (const { tokens } of items) {
      for (const seq of flatten(tokens, 0, [])) {
        const regexp2 = sequenceToRegExp(seq, delimiter, keys);
        sources.push(regexp2);
      }
    }
    let pattern = `^(?:${sources.join("|")})`;
    if (trailing)
      pattern += `(?:${escape2(delimiter)}$)?`;
    pattern += end ? "$" : `(?=${escape2(delimiter)}|$)`;
    const regexp = new RegExp(pattern, flags);
    return { regexp, keys };
  }
  function* flatten(tokens, index2, init) {
    if (index2 === tokens.length) {
      return yield init;
    }
    const token = tokens[index2];
    if (token.type === "group") {
      const fork = init.slice();
      for (const seq of flatten(token.tokens, 0, fork)) {
        yield* flatten(tokens, index2 + 1, seq);
      }
    } else {
      init.push(token);
    }
    yield* flatten(tokens, index2 + 1, init);
  }
  function sequenceToRegExp(tokens, delimiter, keys) {
    let result = "";
    let backtrack = "";
    let isSafeSegmentParam = true;
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (token.type === "text") {
        result += escape2(token.value);
        backtrack += token.value;
        isSafeSegmentParam || (isSafeSegmentParam = token.value.includes(delimiter));
        continue;
      }
      if (token.type === "param" || token.type === "wildcard") {
        if (!isSafeSegmentParam && !backtrack) {
          throw new TypeError(`Missing text after "${token.name}": ${DEBUG_URL}`);
        }
        if (token.type === "param") {
          result += `(${negate(delimiter, isSafeSegmentParam ? "" : backtrack)}+)`;
        } else {
          result += `([\\s\\S]+)`;
        }
        keys.push(token);
        backtrack = "";
        isSafeSegmentParam = false;
        continue;
      }
    }
    return result;
  }
  function negate(delimiter, backtrack) {
    if (backtrack.length < 2) {
      if (delimiter.length < 2)
        return `[^${escape2(delimiter + backtrack)}]`;
      return `(?:(?!${escape2(delimiter)})[^${escape2(backtrack)}])`;
    }
    if (delimiter.length < 2) {
      return `(?:(?!${escape2(backtrack)})[^${escape2(delimiter)}])`;
    }
    return `(?:(?!${escape2(backtrack)}|${escape2(delimiter)})[\\s\\S])`;
  }
  function stringify2(data2) {
    return data2.tokens.map(function stringifyToken(token, index2, tokens) {
      if (token.type === "text")
        return escapeText(token.value);
      if (token.type === "group") {
        return `{${token.tokens.map(stringifyToken).join("")}}`;
      }
      const isSafe = isNameSafe(token.name) && isNextNameSafe(tokens[index2 + 1]);
      const key = isSafe ? token.name : JSON.stringify(token.name);
      if (token.type === "param")
        return `:${key}`;
      if (token.type === "wildcard")
        return `*${key}`;
      throw new TypeError(`Unexpected token: ${token}`);
    }).join("");
  }
  function isNameSafe(name) {
    const [first, ...rest] = name;
    if (!ID_START.test(first))
      return false;
    return rest.every((char) => ID_CONTINUE.test(char));
  }
  function isNextNameSafe(token) {
    if ((token === null || token === void 0 ? void 0 : token.type) !== "text")
      return true;
    return !ID_CONTINUE.test(token.value[0]);
  }
  return dist$1;
}
/*!
 * router
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var layer;
var hasRequiredLayer;
function requireLayer() {
  if (hasRequiredLayer) return layer;
  hasRequiredLayer = 1;
  const isPromise2 = requireIsPromise();
  const pathRegexp = requireDist$1();
  const debug2 = requireBrowser$2()("router:layer");
  const deprecate = requireBrowser$1$1()("router");
  const TRAILING_SLASH_REGEXP = /\/+$/;
  const MATCHING_GROUP_REGEXP = /\((?:\?<(.*?)>)?(?!\?)/g;
  layer = Layer;
  function Layer(path2, options, fn) {
    if (!(this instanceof Layer)) {
      return new Layer(path2, options, fn);
    }
    debug2("new %o", path2);
    const opts = options || {};
    this.handle = fn;
    this.keys = [];
    this.name = fn.name || "<anonymous>";
    this.params = void 0;
    this.path = void 0;
    this.slash = path2 === "/" && opts.end === false;
    function matcher(_path) {
      if (_path instanceof RegExp) {
        const keys = [];
        let name = 0;
        let m;
        while (m = MATCHING_GROUP_REGEXP.exec(_path.source)) {
          keys.push({
            name: m[1] || name++,
            offset: m.index
          });
        }
        return function regexpMatcher(p) {
          const match = _path.exec(p);
          if (!match) {
            return false;
          }
          const params = {};
          for (let i = 1; i < match.length; i++) {
            const key = keys[i - 1];
            const prop = key.name;
            const val = decodeParam(match[i]);
            if (val !== void 0) {
              params[prop] = val;
            }
          }
          return {
            params,
            path: match[0]
          };
        };
      }
      return pathRegexp.match(opts.strict ? _path : loosen(_path), {
        sensitive: opts.sensitive,
        end: opts.end,
        trailing: !opts.strict,
        decode: decodeParam
      });
    }
    this.matchers = Array.isArray(path2) ? path2.map(matcher) : [matcher(path2)];
  }
  Layer.prototype.handleError = function handleError2(error, req, res, next) {
    const fn = this.handle;
    if (fn.length !== 4) {
      return next(error);
    }
    try {
      const ret = fn(error, req, res, next);
      if (isPromise2(ret)) {
        if (!(ret instanceof Promise)) {
          deprecate("handlers that are Promise-like are deprecated, use a native Promise instead");
        }
        ret.then(null, function(error2) {
          next(error2 || new Error("Rejected promise"));
        });
      }
    } catch (err) {
      next(err);
    }
  };
  Layer.prototype.handleRequest = function handleRequest(req, res, next) {
    const fn = this.handle;
    if (fn.length > 3) {
      return next();
    }
    try {
      const ret = fn(req, res, next);
      if (isPromise2(ret)) {
        if (!(ret instanceof Promise)) {
          deprecate("handlers that are Promise-like are deprecated, use a native Promise instead");
        }
        ret.then(null, function(error) {
          next(error || new Error("Rejected promise"));
        });
      }
    } catch (err) {
      next(err);
    }
  };
  Layer.prototype.match = function match(path2) {
    let match2;
    if (path2 != null) {
      if (this.slash) {
        this.params = {};
        this.path = "";
        return true;
      }
      let i = 0;
      while (!match2 && i < this.matchers.length) {
        match2 = this.matchers[i](path2);
        i++;
      }
    }
    if (!match2) {
      this.params = void 0;
      this.path = void 0;
      return false;
    }
    this.params = match2.params;
    this.path = match2.path;
    this.keys = Object.keys(match2.params);
    return true;
  };
  function decodeParam(val) {
    if (typeof val !== "string" || val.length === 0) {
      return val;
    }
    try {
      return decodeURIComponent(val);
    } catch (err) {
      if (err instanceof URIError) {
        err.message = "Failed to decode param '" + val + "'";
        err.status = 400;
      }
      throw err;
    }
  }
  function loosen(path2) {
    if (path2 instanceof RegExp || path2 === "/") {
      return path2;
    }
    return Array.isArray(path2) ? path2.map(function(p) {
      return loosen(p);
    }) : String(path2).replace(TRAILING_SLASH_REGEXP, "");
  }
  return layer;
}
/*!
 * router
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var route;
var hasRequiredRoute;
function requireRoute() {
  if (hasRequiredRoute) return route;
  hasRequiredRoute = 1;
  const debug2 = requireBrowser$2()("router:route");
  const Layer = requireLayer();
  const { METHODS } = require$$2$2;
  const slice = Array.prototype.slice;
  const flatten = Array.prototype.flat;
  const methods = METHODS.map((method) => method.toLowerCase());
  route = Route2;
  function Route2(path2) {
    debug2("new %o", path2);
    this.path = path2;
    this.stack = [];
    this.methods = /* @__PURE__ */ Object.create(null);
  }
  Route2.prototype._handlesMethod = function _handlesMethod(method) {
    if (this.methods._all) {
      return true;
    }
    let name = typeof method === "string" ? method.toLowerCase() : method;
    if (name === "head" && !this.methods.head) {
      name = "get";
    }
    return Boolean(this.methods[name]);
  };
  Route2.prototype._methods = function _methods() {
    const methods2 = Object.keys(this.methods);
    if (this.methods.get && !this.methods.head) {
      methods2.push("head");
    }
    for (let i = 0; i < methods2.length; i++) {
      methods2[i] = methods2[i].toUpperCase();
    }
    return methods2;
  };
  Route2.prototype.dispatch = function dispatch(req, res, done) {
    let idx = 0;
    const stack = this.stack;
    let sync = 0;
    if (stack.length === 0) {
      return done();
    }
    let method = typeof req.method === "string" ? req.method.toLowerCase() : req.method;
    if (method === "head" && !this.methods.head) {
      method = "get";
    }
    req.route = this;
    next();
    function next(err) {
      if (err && err === "route") {
        return done();
      }
      if (err && err === "router") {
        return done(err);
      }
      if (idx >= stack.length) {
        return done(err);
      }
      if (++sync > 100) {
        return setImmediate(next, err);
      }
      let layer2;
      let match;
      while (match !== true && idx < stack.length) {
        layer2 = stack[idx++];
        match = !layer2.method || layer2.method === method;
      }
      if (match !== true) {
        return done(err);
      }
      if (err) {
        layer2.handleError(err, req, res, next);
      } else {
        layer2.handleRequest(req, res, next);
      }
      sync = 0;
    }
  };
  Route2.prototype.all = function all3(handler) {
    const callbacks = flatten.call(slice.call(arguments), Infinity);
    if (callbacks.length === 0) {
      throw new TypeError("argument handler is required");
    }
    for (let i = 0; i < callbacks.length; i++) {
      const fn = callbacks[i];
      if (typeof fn !== "function") {
        throw new TypeError("argument handler must be a function");
      }
      const layer2 = Layer("/", {}, fn);
      layer2.method = void 0;
      this.methods._all = true;
      this.stack.push(layer2);
    }
    return this;
  };
  methods.forEach(function(method) {
    Route2.prototype[method] = function(handler) {
      const callbacks = flatten.call(slice.call(arguments), Infinity);
      if (callbacks.length === 0) {
        throw new TypeError("argument handler is required");
      }
      for (let i = 0; i < callbacks.length; i++) {
        const fn = callbacks[i];
        if (typeof fn !== "function") {
          throw new TypeError("argument handler must be a function");
        }
        debug2("%s %s", method, this.path);
        const layer2 = Layer("/", {}, fn);
        layer2.method = method;
        this.methods[method] = true;
        this.stack.push(layer2);
      }
      return this;
    };
  });
  return route;
}
/*!
 * router
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredRouter$1;
function requireRouter$1() {
  if (hasRequiredRouter$1) return router$1.exports;
  hasRequiredRouter$1 = 1;
  const isPromise2 = requireIsPromise();
  const Layer = requireLayer();
  const { METHODS } = require$$2$2;
  const parseUrl = requireParseurl();
  const Route2 = requireRoute();
  const debug2 = requireBrowser$2()("router");
  const deprecate = requireBrowser$1$1()("router");
  const slice = Array.prototype.slice;
  const flatten = Array.prototype.flat;
  const methods = METHODS.map((method) => method.toLowerCase());
  router$1.exports = Router2;
  router$1.exports.Route = Route2;
  function Router2(options) {
    if (!(this instanceof Router2)) {
      return new Router2(options);
    }
    const opts = options || {};
    function router2(req, res, next) {
      router2.handle(req, res, next);
    }
    Object.setPrototypeOf(router2, this);
    router2.caseSensitive = opts.caseSensitive;
    router2.mergeParams = opts.mergeParams;
    router2.params = {};
    router2.strict = opts.strict;
    router2.stack = [];
    return router2;
  }
  Router2.prototype = function() {
  };
  Router2.prototype.param = function param(name, fn) {
    if (!name) {
      throw new TypeError("argument name is required");
    }
    if (typeof name !== "string") {
      throw new TypeError("argument name must be a string");
    }
    if (!fn) {
      throw new TypeError("argument fn is required");
    }
    if (typeof fn !== "function") {
      throw new TypeError("argument fn must be a function");
    }
    let params = this.params[name];
    if (!params) {
      params = this.params[name] = [];
    }
    params.push(fn);
    return this;
  };
  Router2.prototype.handle = function handle(req, res, callback) {
    if (!callback) {
      throw new TypeError("argument callback is required");
    }
    debug2("dispatching %s %s", req.method, req.url);
    let idx = 0;
    let methods2;
    const protohost = getProtohost(req.url) || "";
    let removed = "";
    const self2 = this;
    let slashAdded = false;
    let sync = 0;
    const paramcalled = {};
    const stack = this.stack;
    const parentParams = req.params;
    const parentUrl = req.baseUrl || "";
    let done = restore(callback, req, "baseUrl", "next", "params");
    req.next = next;
    if (req.method === "OPTIONS") {
      methods2 = [];
      done = wrap(done, generateOptionsResponder(res, methods2));
    }
    req.baseUrl = parentUrl;
    req.originalUrl = req.originalUrl || req.url;
    next();
    function next(err) {
      let layerError = err === "route" ? null : err;
      if (slashAdded) {
        req.url = req.url.slice(1);
        slashAdded = false;
      }
      if (removed.length !== 0) {
        req.baseUrl = parentUrl;
        req.url = protohost + removed + req.url.slice(protohost.length);
        removed = "";
      }
      if (layerError === "router") {
        setImmediate(done, null);
        return;
      }
      if (idx >= stack.length) {
        setImmediate(done, layerError);
        return;
      }
      if (++sync > 100) {
        return setImmediate(next, err);
      }
      const path2 = getPathname(req);
      if (path2 == null) {
        return done(layerError);
      }
      let layer2;
      let match;
      let route2;
      while (match !== true && idx < stack.length) {
        layer2 = stack[idx++];
        match = matchLayer(layer2, path2);
        route2 = layer2.route;
        if (typeof match !== "boolean") {
          layerError = layerError || match;
        }
        if (match !== true) {
          continue;
        }
        if (!route2) {
          continue;
        }
        if (layerError) {
          match = false;
          continue;
        }
        const method = req.method;
        const hasMethod = route2._handlesMethod(method);
        if (!hasMethod && method === "OPTIONS" && methods2) {
          methods2.push.apply(methods2, route2._methods());
        }
        if (!hasMethod && method !== "HEAD") {
          match = false;
        }
      }
      if (match !== true) {
        return done(layerError);
      }
      if (route2) {
        req.route = route2;
      }
      req.params = self2.mergeParams ? mergeParams(layer2.params, parentParams) : layer2.params;
      const layerPath = layer2.path;
      processParams(self2.params, layer2, paramcalled, req, res, function(err2) {
        if (err2) {
          next(layerError || err2);
        } else if (route2) {
          layer2.handleRequest(req, res, next);
        } else {
          trimPrefix(layer2, layerError, layerPath, path2);
        }
        sync = 0;
      });
    }
    function trimPrefix(layer2, layerError, layerPath, path2) {
      if (layerPath.length !== 0) {
        if (layerPath !== path2.substring(0, layerPath.length)) {
          next(layerError);
          return;
        }
        const c = path2[layerPath.length];
        if (c && c !== "/") {
          next(layerError);
          return;
        }
        debug2("trim prefix (%s) from url %s", layerPath, req.url);
        removed = layerPath;
        req.url = protohost + req.url.slice(protohost.length + removed.length);
        if (!protohost && req.url[0] !== "/") {
          req.url = "/" + req.url;
          slashAdded = true;
        }
        req.baseUrl = parentUrl + (removed[removed.length - 1] === "/" ? removed.substring(0, removed.length - 1) : removed);
      }
      debug2("%s %s : %s", layer2.name, layerPath, req.originalUrl);
      if (layerError) {
        layer2.handleError(layerError, req, res, next);
      } else {
        layer2.handleRequest(req, res, next);
      }
    }
  };
  Router2.prototype.use = function use(handler) {
    let offset = 0;
    let path2 = "/";
    if (typeof handler !== "function") {
      let arg = handler;
      while (Array.isArray(arg) && arg.length !== 0) {
        arg = arg[0];
      }
      if (typeof arg !== "function") {
        offset = 1;
        path2 = handler;
      }
    }
    const callbacks = flatten.call(slice.call(arguments, offset), Infinity);
    if (callbacks.length === 0) {
      throw new TypeError("argument handler is required");
    }
    for (let i = 0; i < callbacks.length; i++) {
      const fn = callbacks[i];
      if (typeof fn !== "function") {
        throw new TypeError("argument handler must be a function");
      }
      debug2("use %o %s", path2, fn.name || "<anonymous>");
      const layer2 = new Layer(path2, {
        sensitive: this.caseSensitive,
        strict: false,
        end: false
      }, fn);
      layer2.route = void 0;
      this.stack.push(layer2);
    }
    return this;
  };
  Router2.prototype.route = function route2(path2) {
    const route3 = new Route2(path2);
    const layer2 = new Layer(path2, {
      sensitive: this.caseSensitive,
      strict: this.strict,
      end: true
    }, handle);
    function handle(req, res, next) {
      route3.dispatch(req, res, next);
    }
    layer2.route = route3;
    this.stack.push(layer2);
    return route3;
  };
  methods.concat("all").forEach(function(method) {
    Router2.prototype[method] = function(path2) {
      const route2 = this.route(path2);
      route2[method].apply(route2, slice.call(arguments, 1));
      return this;
    };
  });
  function generateOptionsResponder(res, methods2) {
    return function onDone(fn, err) {
      if (err || methods2.length === 0) {
        return fn(err);
      }
      trySendOptionsResponse(res, methods2, fn);
    };
  }
  function getPathname(req) {
    try {
      return parseUrl(req).pathname;
    } catch (err) {
      return void 0;
    }
  }
  function getProtohost(url) {
    if (typeof url !== "string" || url.length === 0 || url[0] === "/") {
      return void 0;
    }
    const searchIndex = url.indexOf("?");
    const pathLength = searchIndex !== -1 ? searchIndex : url.length;
    const fqdnIndex = url.substring(0, pathLength).indexOf("://");
    return fqdnIndex !== -1 ? url.substring(0, url.indexOf("/", 3 + fqdnIndex)) : void 0;
  }
  function matchLayer(layer2, path2) {
    try {
      return layer2.match(path2);
    } catch (err) {
      return err;
    }
  }
  function mergeParams(params, parent) {
    if (typeof parent !== "object" || !parent) {
      return params;
    }
    const obj = Object.assign({}, parent);
    if (!(0 in params) || !(0 in parent)) {
      return Object.assign(obj, params);
    }
    let i = 0;
    let o = 0;
    while (i in params) {
      i++;
    }
    while (o in parent) {
      o++;
    }
    for (i--; i >= 0; i--) {
      params[i + o] = params[i];
      if (i < o) {
        delete params[i];
      }
    }
    return Object.assign(obj, params);
  }
  function processParams(params, layer2, called, req, res, done) {
    const keys = layer2.keys;
    if (!keys || keys.length === 0) {
      return done();
    }
    let i = 0;
    let paramIndex = 0;
    let key;
    let paramVal;
    let paramCallbacks;
    let paramCalled;
    function param(err) {
      if (err) {
        return done(err);
      }
      if (i >= keys.length) {
        return done();
      }
      paramIndex = 0;
      key = keys[i++];
      paramVal = req.params[key];
      paramCallbacks = params[key];
      paramCalled = called[key];
      if (paramVal === void 0 || !paramCallbacks) {
        return param();
      }
      if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== "route")) {
        req.params[key] = paramCalled.value;
        return param(paramCalled.error);
      }
      called[key] = paramCalled = {
        error: null,
        match: paramVal,
        value: paramVal
      };
      paramCallback();
    }
    function paramCallback(err) {
      const fn = paramCallbacks[paramIndex++];
      paramCalled.value = req.params[key];
      if (err) {
        paramCalled.error = err;
        param(err);
        return;
      }
      if (!fn) return param();
      try {
        const ret = fn(req, res, paramCallback, paramVal, key);
        if (isPromise2(ret)) {
          if (!(ret instanceof Promise)) {
            deprecate("parameters that are Promise-like are deprecated, use a native Promise instead");
          }
          ret.then(null, function(error) {
            paramCallback(error || new Error("Rejected promise"));
          });
        }
      } catch (e) {
        paramCallback(e);
      }
    }
    param();
  }
  function restore(fn, obj) {
    const props = new Array(arguments.length - 2);
    const vals = new Array(arguments.length - 2);
    for (let i = 0; i < props.length; i++) {
      props[i] = arguments[i + 2];
      vals[i] = obj[props[i]];
    }
    return function() {
      for (let i = 0; i < props.length; i++) {
        obj[props[i]] = vals[i];
      }
      return fn.apply(this, arguments);
    };
  }
  function sendOptionsResponse(res, methods2) {
    const options = /* @__PURE__ */ Object.create(null);
    for (let i = 0; i < methods2.length; i++) {
      options[methods2[i]] = true;
    }
    const allow = Object.keys(options).sort().join(", ");
    res.setHeader("Allow", allow);
    res.setHeader("Content-Length", Buffer.byteLength(allow));
    res.setHeader("Content-Type", "text/plain");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.end(allow);
  }
  function trySendOptionsResponse(res, methods2, next) {
    try {
      sendOptionsResponse(res, methods2);
    } catch (err) {
      next(err);
    }
  }
  function wrap(old, fn) {
    return function proxy() {
      const args = new Array(arguments.length + 1);
      args[0] = old;
      for (let i = 0, len = arguments.length; i < len; i++) {
        args[i + 1] = arguments[i];
      }
      fn.apply(this, args);
    };
  }
  return router$1.exports;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredApplication;
function requireApplication() {
  if (hasRequiredApplication) return application.exports;
  hasRequiredApplication = 1;
  (function(module, exports) {
    var finalhandler = requireFinalhandler();
    var debug2 = requireBrowser$2()("express:application");
    var View = requireView();
    var http = require$$2$2;
    var methods = requireUtils$4().methods;
    var compileETag = requireUtils$4().compileETag;
    var compileQueryParser = requireUtils$4().compileQueryParser;
    var compileTrust = requireUtils$4().compileTrust;
    var resolve = path.resolve;
    var once2 = requireOnce();
    var Router2 = requireRouter$1();
    var slice = Array.prototype.slice;
    var flatten = Array.prototype.flat;
    var app2 = module.exports = {};
    var trustProxyDefaultSymbol = "@@symbol:trust_proxy_default";
    app2.init = function init() {
      var router2 = null;
      this.cache = /* @__PURE__ */ Object.create(null);
      this.engines = /* @__PURE__ */ Object.create(null);
      this.settings = /* @__PURE__ */ Object.create(null);
      this.defaultConfiguration();
      Object.defineProperty(this, "router", {
        configurable: true,
        enumerable: true,
        get: function getrouter() {
          if (router2 === null) {
            router2 = new Router2({
              caseSensitive: this.enabled("case sensitive routing"),
              strict: this.enabled("strict routing")
            });
          }
          return router2;
        }
      });
    };
    app2.defaultConfiguration = function defaultConfiguration() {
      var env = process.env.NODE_ENV || "development";
      this.enable("x-powered-by");
      this.set("etag", "weak");
      this.set("env", env);
      this.set("query parser", "simple");
      this.set("subdomain offset", 2);
      this.set("trust proxy", false);
      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
        configurable: true,
        value: true
      });
      debug2("booting in %s mode", env);
      this.on("mount", function onmount(parent) {
        if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings["trust proxy fn"] === "function") {
          delete this.settings["trust proxy"];
          delete this.settings["trust proxy fn"];
        }
        Object.setPrototypeOf(this.request, parent.request);
        Object.setPrototypeOf(this.response, parent.response);
        Object.setPrototypeOf(this.engines, parent.engines);
        Object.setPrototypeOf(this.settings, parent.settings);
      });
      this.locals = /* @__PURE__ */ Object.create(null);
      this.mountpath = "/";
      this.locals.settings = this.settings;
      this.set("view", View);
      this.set("views", resolve("views"));
      this.set("jsonp callback name", "callback");
      if (env === "production") {
        this.enable("view cache");
      }
    };
    app2.handle = function handle(req, res, callback) {
      var done = callback || finalhandler(req, res, {
        env: this.get("env"),
        onerror: logerror.bind(this)
      });
      if (this.enabled("x-powered-by")) {
        res.setHeader("X-Powered-By", "Express");
      }
      req.res = res;
      res.req = req;
      Object.setPrototypeOf(req, this.request);
      Object.setPrototypeOf(res, this.response);
      if (!res.locals) {
        res.locals = /* @__PURE__ */ Object.create(null);
      }
      this.router.handle(req, res, done);
    };
    app2.use = function use(fn) {
      var offset = 0;
      var path2 = "/";
      if (typeof fn !== "function") {
        var arg = fn;
        while (Array.isArray(arg) && arg.length !== 0) {
          arg = arg[0];
        }
        if (typeof arg !== "function") {
          offset = 1;
          path2 = fn;
        }
      }
      var fns = flatten.call(slice.call(arguments, offset), Infinity);
      if (fns.length === 0) {
        throw new TypeError("app.use() requires a middleware function");
      }
      var router2 = this.router;
      fns.forEach(function(fn2) {
        if (!fn2 || !fn2.handle || !fn2.set) {
          return router2.use(path2, fn2);
        }
        debug2(".use app under %s", path2);
        fn2.mountpath = path2;
        fn2.parent = this;
        router2.use(path2, function mounted_app(req, res, next) {
          var orig = req.app;
          fn2.handle(req, res, function(err) {
            Object.setPrototypeOf(req, orig.request);
            Object.setPrototypeOf(res, orig.response);
            next(err);
          });
        });
        fn2.emit("mount", this);
      }, this);
      return this;
    };
    app2.route = function route2(path2) {
      return this.router.route(path2);
    };
    app2.engine = function engine(ext, fn) {
      if (typeof fn !== "function") {
        throw new Error("callback function required");
      }
      var extension = ext[0] !== "." ? "." + ext : ext;
      this.engines[extension] = fn;
      return this;
    };
    app2.param = function param(name, fn) {
      if (Array.isArray(name)) {
        for (var i = 0; i < name.length; i++) {
          this.param(name[i], fn);
        }
        return this;
      }
      this.router.param(name, fn);
      return this;
    };
    app2.set = function set(setting, val) {
      if (arguments.length === 1) {
        return this.settings[setting];
      }
      debug2('set "%s" to %o', setting, val);
      this.settings[setting] = val;
      switch (setting) {
        case "etag":
          this.set("etag fn", compileETag(val));
          break;
        case "query parser":
          this.set("query parser fn", compileQueryParser(val));
          break;
        case "trust proxy":
          this.set("trust proxy fn", compileTrust(val));
          Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
            configurable: true,
            value: false
          });
          break;
      }
      return this;
    };
    app2.path = function path2() {
      return this.parent ? this.parent.path() + this.mountpath : "";
    };
    app2.enabled = function enabled(setting) {
      return Boolean(this.set(setting));
    };
    app2.disabled = function disabled(setting) {
      return !this.set(setting);
    };
    app2.enable = function enable(setting) {
      return this.set(setting, true);
    };
    app2.disable = function disable(setting) {
      return this.set(setting, false);
    };
    methods.forEach(function(method) {
      app2[method] = function(path2) {
        if (method === "get" && arguments.length === 1) {
          return this.set(path2);
        }
        var route2 = this.route(path2);
        route2[method].apply(route2, slice.call(arguments, 1));
        return this;
      };
    });
    app2.all = function all3(path2) {
      var route2 = this.route(path2);
      var args = slice.call(arguments, 1);
      for (var i = 0; i < methods.length; i++) {
        route2[methods[i]].apply(route2, args);
      }
      return this;
    };
    app2.render = function render(name, options, callback) {
      var cache = this.cache;
      var done = callback;
      var engines = this.engines;
      var opts = options;
      var view2;
      if (typeof options === "function") {
        done = options;
        opts = {};
      }
      var renderOptions = { ...this.locals, ...opts._locals, ...opts };
      if (renderOptions.cache == null) {
        renderOptions.cache = this.enabled("view cache");
      }
      if (renderOptions.cache) {
        view2 = cache[name];
      }
      if (!view2) {
        var View2 = this.get("view");
        view2 = new View2(name, {
          defaultEngine: this.get("view engine"),
          root: this.get("views"),
          engines
        });
        if (!view2.path) {
          var dirs = Array.isArray(view2.root) && view2.root.length > 1 ? 'directories "' + view2.root.slice(0, -1).join('", "') + '" or "' + view2.root[view2.root.length - 1] + '"' : 'directory "' + view2.root + '"';
          var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
          err.view = view2;
          return done(err);
        }
        if (renderOptions.cache) {
          cache[name] = view2;
        }
      }
      tryRender(view2, renderOptions, done);
    };
    app2.listen = function listen() {
      var server = http.createServer(this);
      var args = Array.prototype.slice.call(arguments);
      if (typeof args[args.length - 1] === "function") {
        var done = args[args.length - 1] = once2(args[args.length - 1]);
        server.once("error", done);
      }
      return server.listen.apply(server, args);
    };
    function logerror(err) {
      if (this.get("env") !== "test") console.error(err.stack || err.toString());
    }
    function tryRender(view2, options, callback) {
      try {
        view2.render(options, callback);
      } catch (err) {
        callback(err);
      }
    }
  })(application);
  return application.exports;
}
var negotiator = { exports: {} };
var charset = { exports: {} };
var hasRequiredCharset;
function requireCharset() {
  if (hasRequiredCharset) return charset.exports;
  hasRequiredCharset = 1;
  charset.exports = preferredCharsets;
  charset.exports.preferredCharsets = preferredCharsets;
  var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
  function parseAcceptCharset(accept) {
    var accepts2 = accept.split(",");
    for (var i = 0, j = 0; i < accepts2.length; i++) {
      var charset2 = parseCharset(accepts2[i].trim(), i);
      if (charset2) {
        accepts2[j++] = charset2;
      }
    }
    accepts2.length = j;
    return accepts2;
  }
  function parseCharset(str, i) {
    var match = simpleCharsetRegExp.exec(str);
    if (!match) return null;
    var charset2 = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(";");
      for (var j = 0; j < params.length; j++) {
        var p = params[j].trim().split("=");
        if (p[0] === "q") {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      charset: charset2,
      q,
      i
    };
  }
  function getCharsetPriority(charset2, accepted, index2) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(charset2, accepted[i], index2);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(charset2, spec, index2) {
    var s = 0;
    if (spec.charset.toLowerCase() === charset2.toLowerCase()) {
      s |= 1;
    } else if (spec.charset !== "*") {
      return null;
    }
    return {
      i: index2,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredCharsets(accept, provided) {
    var accepts2 = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
    if (!provided) {
      return accepts2.filter(isQuality).sort(compareSpecs).map(getFullCharset);
    }
    var priorities = provided.map(function getPriority(type2, index2) {
      return getCharsetPriority(type2, accepts2, index2);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullCharset(spec) {
    return spec.charset;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  return charset.exports;
}
var encoding = { exports: {} };
var hasRequiredEncoding;
function requireEncoding() {
  if (hasRequiredEncoding) return encoding.exports;
  hasRequiredEncoding = 1;
  encoding.exports = preferredEncodings;
  encoding.exports.preferredEncodings = preferredEncodings;
  var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
  function parseAcceptEncoding(accept) {
    var accepts2 = accept.split(",");
    var hasIdentity = false;
    var minQuality = 1;
    for (var i = 0, j = 0; i < accepts2.length; i++) {
      var encoding2 = parseEncoding(accepts2[i].trim(), i);
      if (encoding2) {
        accepts2[j++] = encoding2;
        hasIdentity = hasIdentity || specify("identity", encoding2);
        minQuality = Math.min(minQuality, encoding2.q || 1);
      }
    }
    if (!hasIdentity) {
      accepts2[j++] = {
        encoding: "identity",
        q: minQuality,
        i
      };
    }
    accepts2.length = j;
    return accepts2;
  }
  function parseEncoding(str, i) {
    var match = simpleEncodingRegExp.exec(str);
    if (!match) return null;
    var encoding2 = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(";");
      for (var j = 0; j < params.length; j++) {
        var p = params[j].trim().split("=");
        if (p[0] === "q") {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      encoding: encoding2,
      q,
      i
    };
  }
  function getEncodingPriority(encoding2, accepted, index2) {
    var priority = { encoding: encoding2, o: -1, q: 0, s: 0 };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(encoding2, accepted[i], index2);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(encoding2, spec, index2) {
    var s = 0;
    if (spec.encoding.toLowerCase() === encoding2.toLowerCase()) {
      s |= 1;
    } else if (spec.encoding !== "*") {
      return null;
    }
    return {
      encoding: encoding2,
      i: index2,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredEncodings(accept, provided, preferred) {
    var accepts2 = parseAcceptEncoding(accept || "");
    var comparator = preferred ? function comparator2(a, b) {
      if (a.q !== b.q) {
        return b.q - a.q;
      }
      var aPreferred = preferred.indexOf(a.encoding);
      var bPreferred = preferred.indexOf(b.encoding);
      if (aPreferred === -1 && bPreferred === -1) {
        return b.s - a.s || a.o - b.o || a.i - b.i;
      }
      if (aPreferred !== -1 && bPreferred !== -1) {
        return aPreferred - bPreferred;
      }
      return aPreferred === -1 ? 1 : -1;
    } : compareSpecs;
    if (!provided) {
      return accepts2.filter(isQuality).sort(comparator).map(getFullEncoding);
    }
    var priorities = provided.map(function getPriority(type2, index2) {
      return getEncodingPriority(type2, accepts2, index2);
    });
    return priorities.filter(isQuality).sort(comparator).map(function getEncoding(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i;
  }
  function getFullEncoding(spec) {
    return spec.encoding;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  return encoding.exports;
}
var language = { exports: {} };
var hasRequiredLanguage;
function requireLanguage() {
  if (hasRequiredLanguage) return language.exports;
  hasRequiredLanguage = 1;
  language.exports = preferredLanguages;
  language.exports.preferredLanguages = preferredLanguages;
  var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
  function parseAcceptLanguage(accept) {
    var accepts2 = accept.split(",");
    for (var i = 0, j = 0; i < accepts2.length; i++) {
      var language2 = parseLanguage(accepts2[i].trim(), i);
      if (language2) {
        accepts2[j++] = language2;
      }
    }
    accepts2.length = j;
    return accepts2;
  }
  function parseLanguage(str, i) {
    var match = simpleLanguageRegExp.exec(str);
    if (!match) return null;
    var prefix = match[1];
    var suffix = match[2];
    var full = prefix;
    if (suffix) full += "-" + suffix;
    var q = 1;
    if (match[3]) {
      var params = match[3].split(";");
      for (var j = 0; j < params.length; j++) {
        var p = params[j].split("=");
        if (p[0] === "q") q = parseFloat(p[1]);
      }
    }
    return {
      prefix,
      suffix,
      q,
      i,
      full
    };
  }
  function getLanguagePriority(language2, accepted, index2) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(language2, accepted[i], index2);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(language2, spec, index2) {
    var p = parseLanguage(language2);
    if (!p) return null;
    var s = 0;
    if (spec.full.toLowerCase() === p.full.toLowerCase()) {
      s |= 4;
    } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
      s |= 2;
    } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
      s |= 1;
    } else if (spec.full !== "*") {
      return null;
    }
    return {
      i: index2,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredLanguages(accept, provided) {
    var accepts2 = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
    if (!provided) {
      return accepts2.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
    }
    var priorities = provided.map(function getPriority(type2, index2) {
      return getLanguagePriority(type2, accepts2, index2);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullLanguage(spec) {
    return spec.full;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  return language.exports;
}
var mediaType = { exports: {} };
var hasRequiredMediaType;
function requireMediaType() {
  if (hasRequiredMediaType) return mediaType.exports;
  hasRequiredMediaType = 1;
  mediaType.exports = preferredMediaTypes;
  mediaType.exports.preferredMediaTypes = preferredMediaTypes;
  var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
  function parseAccept(accept) {
    var accepts2 = splitMediaTypes(accept);
    for (var i = 0, j = 0; i < accepts2.length; i++) {
      var mediaType2 = parseMediaType(accepts2[i].trim(), i);
      if (mediaType2) {
        accepts2[j++] = mediaType2;
      }
    }
    accepts2.length = j;
    return accepts2;
  }
  function parseMediaType(str, i) {
    var match = simpleMediaTypeRegExp.exec(str);
    if (!match) return null;
    var params = /* @__PURE__ */ Object.create(null);
    var q = 1;
    var subtype = match[2];
    var type2 = match[1];
    if (match[3]) {
      var kvps = splitParameters(match[3]).map(splitKeyValuePair);
      for (var j = 0; j < kvps.length; j++) {
        var pair = kvps[j];
        var key = pair[0].toLowerCase();
        var val = pair[1];
        var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.slice(1, -1) : val;
        if (key === "q") {
          q = parseFloat(value);
          break;
        }
        params[key] = value;
      }
    }
    return {
      type: type2,
      subtype,
      params,
      q,
      i
    };
  }
  function getMediaTypePriority(type2, accepted, index2) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(type2, accepted[i], index2);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(type2, spec, index2) {
    var p = parseMediaType(type2);
    var s = 0;
    if (!p) {
      return null;
    }
    if (spec.type.toLowerCase() == p.type.toLowerCase()) {
      s |= 4;
    } else if (spec.type != "*") {
      return null;
    }
    if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
      s |= 2;
    } else if (spec.subtype != "*") {
      return null;
    }
    var keys = Object.keys(spec.params);
    if (keys.length > 0) {
      if (keys.every(function(k) {
        return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
      })) {
        s |= 1;
      } else {
        return null;
      }
    }
    return {
      i: index2,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredMediaTypes(accept, provided) {
    var accepts2 = parseAccept(accept === void 0 ? "*/*" : accept || "");
    if (!provided) {
      return accepts2.filter(isQuality).sort(compareSpecs).map(getFullType);
    }
    var priorities = provided.map(function getPriority(type2, index2) {
      return getMediaTypePriority(type2, accepts2, index2);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullType(spec) {
    return spec.type + "/" + spec.subtype;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  function quoteCount(string) {
    var count = 0;
    var index2 = 0;
    while ((index2 = string.indexOf('"', index2)) !== -1) {
      count++;
      index2++;
    }
    return count;
  }
  function splitKeyValuePair(str) {
    var index2 = str.indexOf("=");
    var key;
    var val;
    if (index2 === -1) {
      key = str;
    } else {
      key = str.slice(0, index2);
      val = str.slice(index2 + 1);
    }
    return [key, val];
  }
  function splitMediaTypes(accept) {
    var accepts2 = accept.split(",");
    for (var i = 1, j = 0; i < accepts2.length; i++) {
      if (quoteCount(accepts2[j]) % 2 == 0) {
        accepts2[++j] = accepts2[i];
      } else {
        accepts2[j] += "," + accepts2[i];
      }
    }
    accepts2.length = j + 1;
    return accepts2;
  }
  function splitParameters(str) {
    var parameters = str.split(";");
    for (var i = 1, j = 0; i < parameters.length; i++) {
      if (quoteCount(parameters[j]) % 2 == 0) {
        parameters[++j] = parameters[i];
      } else {
        parameters[j] += ";" + parameters[i];
      }
    }
    parameters.length = j + 1;
    for (var i = 0; i < parameters.length; i++) {
      parameters[i] = parameters[i].trim();
    }
    return parameters;
  }
  return mediaType.exports;
}
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredNegotiator;
function requireNegotiator() {
  if (hasRequiredNegotiator) return negotiator.exports;
  hasRequiredNegotiator = 1;
  var preferredCharsets = requireCharset();
  var preferredEncodings = requireEncoding();
  var preferredLanguages = requireLanguage();
  var preferredMediaTypes = requireMediaType();
  negotiator.exports = Negotiator;
  negotiator.exports.Negotiator = Negotiator;
  function Negotiator(request2) {
    if (!(this instanceof Negotiator)) {
      return new Negotiator(request2);
    }
    this.request = request2;
  }
  Negotiator.prototype.charset = function charset2(available) {
    var set = this.charsets(available);
    return set && set[0];
  };
  Negotiator.prototype.charsets = function charsets(available) {
    return preferredCharsets(this.request.headers["accept-charset"], available);
  };
  Negotiator.prototype.encoding = function encoding2(available, opts) {
    var set = this.encodings(available, opts);
    return set && set[0];
  };
  Negotiator.prototype.encodings = function encodings2(available, options) {
    var opts = options || {};
    return preferredEncodings(this.request.headers["accept-encoding"], available, opts.preferred);
  };
  Negotiator.prototype.language = function language2(available) {
    var set = this.languages(available);
    return set && set[0];
  };
  Negotiator.prototype.languages = function languages(available) {
    return preferredLanguages(this.request.headers["accept-language"], available);
  };
  Negotiator.prototype.mediaType = function mediaType2(available) {
    var set = this.mediaTypes(available);
    return set && set[0];
  };
  Negotiator.prototype.mediaTypes = function mediaTypes(available) {
    return preferredMediaTypes(this.request.headers.accept, available);
  };
  Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
  Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
  Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
  Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
  Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
  Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
  Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
  Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
  return negotiator.exports;
}
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var accepts;
var hasRequiredAccepts;
function requireAccepts() {
  if (hasRequiredAccepts) return accepts;
  hasRequiredAccepts = 1;
  var Negotiator = requireNegotiator();
  var mime = requireMimeTypes();
  accepts = Accepts;
  function Accepts(req) {
    if (!(this instanceof Accepts)) {
      return new Accepts(req);
    }
    this.headers = req.headers;
    this.negotiator = new Negotiator(req);
  }
  Accepts.prototype.type = Accepts.prototype.types = function(types_) {
    var types = types_;
    if (types && !Array.isArray(types)) {
      types = new Array(arguments.length);
      for (var i = 0; i < types.length; i++) {
        types[i] = arguments[i];
      }
    }
    if (!types || types.length === 0) {
      return this.negotiator.mediaTypes();
    }
    if (!this.headers.accept) {
      return types[0];
    }
    var mimes = types.map(extToMime);
    var accepts2 = this.negotiator.mediaTypes(mimes.filter(validMime));
    var first = accepts2[0];
    return first ? types[mimes.indexOf(first)] : false;
  };
  Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
    var encodings2 = encodings_;
    if (encodings2 && !Array.isArray(encodings2)) {
      encodings2 = new Array(arguments.length);
      for (var i = 0; i < encodings2.length; i++) {
        encodings2[i] = arguments[i];
      }
    }
    if (!encodings2 || encodings2.length === 0) {
      return this.negotiator.encodings();
    }
    return this.negotiator.encodings(encodings2)[0] || false;
  };
  Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
    var charsets = charsets_;
    if (charsets && !Array.isArray(charsets)) {
      charsets = new Array(arguments.length);
      for (var i = 0; i < charsets.length; i++) {
        charsets[i] = arguments[i];
      }
    }
    if (!charsets || charsets.length === 0) {
      return this.negotiator.charsets();
    }
    return this.negotiator.charsets(charsets)[0] || false;
  };
  Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
    var languages = languages_;
    if (languages && !Array.isArray(languages)) {
      languages = new Array(arguments.length);
      for (var i = 0; i < languages.length; i++) {
        languages[i] = arguments[i];
      }
    }
    if (!languages || languages.length === 0) {
      return this.negotiator.languages();
    }
    return this.negotiator.languages(languages)[0] || false;
  };
  function extToMime(type2) {
    return type2.indexOf("/") === -1 ? mime.lookup(type2) : type2;
  }
  function validMime(type2) {
    return typeof type2 === "string";
  }
  return accepts;
}
/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var fresh_1;
var hasRequiredFresh;
function requireFresh() {
  if (hasRequiredFresh) return fresh_1;
  hasRequiredFresh = 1;
  var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
  fresh_1 = fresh;
  function fresh(reqHeaders, resHeaders) {
    var modifiedSince = reqHeaders["if-modified-since"];
    var noneMatch = reqHeaders["if-none-match"];
    if (!modifiedSince && !noneMatch) {
      return false;
    }
    var cacheControl = reqHeaders["cache-control"];
    if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
      return false;
    }
    if (noneMatch) {
      if (noneMatch === "*") {
        return true;
      }
      var etag = resHeaders.etag;
      if (!etag) {
        return false;
      }
      var matches = parseTokenList(noneMatch);
      for (var i = 0; i < matches.length; i++) {
        var match = matches[i];
        if (match === etag || match === "W/" + etag || "W/" + match === etag) {
          return true;
        }
      }
      return false;
    }
    if (modifiedSince) {
      var lastModified = resHeaders["last-modified"];
      var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));
      if (modifiedStale) {
        return false;
      }
    }
    return true;
  }
  function parseHttpDate(date) {
    var timestamp = date && Date.parse(date);
    return typeof timestamp === "number" ? timestamp : NaN;
  }
  function parseTokenList(str) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = str.length; i < len; i++) {
      switch (str.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          list.push(str.substring(start, end));
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    list.push(str.substring(start, end));
    return list;
  }
  return fresh_1;
}
/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var rangeParser_1;
var hasRequiredRangeParser;
function requireRangeParser() {
  if (hasRequiredRangeParser) return rangeParser_1;
  hasRequiredRangeParser = 1;
  rangeParser_1 = rangeParser;
  function rangeParser(size, str, options) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var index2 = str.indexOf("=");
    if (index2 === -1) {
      return -2;
    }
    var arr = str.slice(index2 + 1).split(",");
    var ranges = [];
    ranges.type = str.slice(0, index2);
    for (var i = 0; i < arr.length; i++) {
      var range2 = arr[i].split("-");
      var start = parseInt(range2[0], 10);
      var end = parseInt(range2[1], 10);
      if (isNaN(start)) {
        start = size - end;
        end = size - 1;
      } else if (isNaN(end)) {
        end = size - 1;
      }
      if (end > size - 1) {
        end = size - 1;
      }
      if (isNaN(start) || isNaN(end) || start > end || start < 0) {
        continue;
      }
      ranges.push({
        start,
        end
      });
    }
    if (ranges.length < 1) {
      return -1;
    }
    return options && options.combine ? combineRanges(ranges) : ranges;
  }
  function combineRanges(ranges) {
    var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
    for (var j = 0, i = 1; i < ordered.length; i++) {
      var range2 = ordered[i];
      var current = ordered[j];
      if (range2.start > current.end + 1) {
        ordered[++j] = range2;
      } else if (range2.end > current.end) {
        current.end = range2.end;
        current.index = Math.min(current.index, range2.index);
      }
    }
    ordered.length = j + 1;
    var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
    combined.type = ranges.type;
    return combined;
  }
  function mapWithIndex(range2, index2) {
    return {
      start: range2.start,
      end: range2.end,
      index: index2
    };
  }
  function mapWithoutIndex(range2) {
    return {
      start: range2.start,
      end: range2.end
    };
  }
  function sortByRangeIndex(a, b) {
    return a.index - b.index;
  }
  function sortByRangeStart(a, b) {
    return a.start - b.start;
  }
  return rangeParser_1;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var request;
var hasRequiredRequest;
function requireRequest() {
  if (hasRequiredRequest) return request;
  hasRequiredRequest = 1;
  var accepts2 = requireAccepts();
  var isIP = require$$1$4$1.isIP;
  var typeis = requireTypeIs();
  var http = require$$2$2;
  var fresh = requireFresh();
  var parseRange = requireRangeParser();
  var parse2 = requireParseurl();
  var proxyaddr = requireProxyAddr();
  var req = Object.create(http.IncomingMessage.prototype);
  request = req;
  req.get = req.header = function header(name) {
    if (!name) {
      throw new TypeError("name argument is required to req.get");
    }
    if (typeof name !== "string") {
      throw new TypeError("name must be a string to req.get");
    }
    var lc = name.toLowerCase();
    switch (lc) {
      case "referer":
      case "referrer":
        return this.headers.referrer || this.headers.referer;
      default:
        return this.headers[lc];
    }
  };
  req.accepts = function() {
    var accept = accepts2(this);
    return accept.types.apply(accept, arguments);
  };
  req.acceptsEncodings = function() {
    var accept = accepts2(this);
    return accept.encodings.apply(accept, arguments);
  };
  req.acceptsCharsets = function() {
    var accept = accepts2(this);
    return accept.charsets.apply(accept, arguments);
  };
  req.acceptsLanguages = function() {
    var accept = accepts2(this);
    return accept.languages.apply(accept, arguments);
  };
  req.range = function range2(size, options) {
    var range3 = this.get("Range");
    if (!range3) return;
    return parseRange(size, range3, options);
  };
  defineGetter(req, "query", function query() {
    var queryparse = this.app.get("query parser fn");
    if (!queryparse) {
      return /* @__PURE__ */ Object.create(null);
    }
    var querystring = parse2(this).query;
    return queryparse(querystring);
  });
  req.is = function is(types) {
    var arr = types;
    if (!Array.isArray(types)) {
      arr = new Array(arguments.length);
      for (var i = 0; i < arr.length; i++) {
        arr[i] = arguments[i];
      }
    }
    return typeis(this, arr);
  };
  defineGetter(req, "protocol", function protocol() {
    var proto2 = this.connection.encrypted ? "https" : "http";
    var trust = this.app.get("trust proxy fn");
    if (!trust(this.connection.remoteAddress, 0)) {
      return proto2;
    }
    var header = this.get("X-Forwarded-Proto") || proto2;
    var index2 = header.indexOf(",");
    return index2 !== -1 ? header.substring(0, index2).trim() : header.trim();
  });
  defineGetter(req, "secure", function secure() {
    return this.protocol === "https";
  });
  defineGetter(req, "ip", function ip() {
    var trust = this.app.get("trust proxy fn");
    return proxyaddr(this, trust);
  });
  defineGetter(req, "ips", function ips() {
    var trust = this.app.get("trust proxy fn");
    var addrs = proxyaddr.all(this, trust);
    addrs.reverse().pop();
    return addrs;
  });
  defineGetter(req, "subdomains", function subdomains() {
    var hostname = this.hostname;
    if (!hostname) return [];
    var offset = this.app.get("subdomain offset");
    var subdomains2 = !isIP(hostname) ? hostname.split(".").reverse() : [hostname];
    return subdomains2.slice(offset);
  });
  defineGetter(req, "path", function path2() {
    return parse2(this).pathname;
  });
  defineGetter(req, "host", function host() {
    var trust = this.app.get("trust proxy fn");
    var val = this.get("X-Forwarded-Host");
    if (!val || !trust(this.connection.remoteAddress, 0)) {
      val = this.get("Host");
    } else if (val.indexOf(",") !== -1) {
      val = val.substring(0, val.indexOf(",")).trimRight();
    }
    return val || void 0;
  });
  defineGetter(req, "hostname", function hostname() {
    var host = this.host;
    if (!host) return;
    var offset = host[0] === "[" ? host.indexOf("]") + 1 : 0;
    var index2 = host.indexOf(":", offset);
    return index2 !== -1 ? host.substring(0, index2) : host;
  });
  defineGetter(req, "fresh", function() {
    var method = this.method;
    var res = this.res;
    var status = res.statusCode;
    if ("GET" !== method && "HEAD" !== method) return false;
    if (status >= 200 && status < 300 || 304 === status) {
      return fresh(this.headers, {
        "etag": res.get("ETag"),
        "last-modified": res.get("Last-Modified")
      });
    }
    return false;
  });
  defineGetter(req, "stale", function stale() {
    return !this.fresh;
  });
  defineGetter(req, "xhr", function xhr() {
    var val = this.get("X-Requested-With") || "";
    return val.toLowerCase() === "xmlhttprequest";
  });
  function defineGetter(obj, name, getter) {
    Object.defineProperty(obj, name, {
      configurable: true,
      enumerable: true,
      get: getter
    });
  }
  return request;
}
var contentDisposition = { exports: {} };
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module, exports) {
    var buffer2 = require$$0$4$1;
    var Buffer2 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding2) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding2 === "string") {
          buf.fill(fill, encoding2);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredContentDisposition;
function requireContentDisposition() {
  if (hasRequiredContentDisposition) return contentDisposition.exports;
  hasRequiredContentDisposition = 1;
  contentDisposition.exports = contentDisposition$1;
  contentDisposition.exports.parse = parse2;
  var basename = require$$1$3.basename;
  var Buffer2 = requireSafeBuffer().Buffer;
  var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
  var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
  var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
  var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
  var QESC_REGEXP = /\\([\u0000-\u007f])/g;
  var QUOTE_REGEXP = /([\\"])/g;
  var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
  var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
  var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
  var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
  var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
  function contentDisposition$1(filename, options) {
    var opts = options || {};
    var type2 = opts.type || "attachment";
    var params = createparams(filename, opts.fallback);
    return format(new ContentDisposition(type2, params));
  }
  function createparams(filename, fallback) {
    if (filename === void 0) {
      return;
    }
    var params = {};
    if (typeof filename !== "string") {
      throw new TypeError("filename must be a string");
    }
    if (fallback === void 0) {
      fallback = true;
    }
    if (typeof fallback !== "string" && typeof fallback !== "boolean") {
      throw new TypeError("fallback must be a string or boolean");
    }
    if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
      throw new TypeError("fallback must be ISO-8859-1 string");
    }
    var name = basename(filename);
    var isQuotedString = TEXT_REGEXP.test(name);
    var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name) : basename(fallback);
    var hasFallback = typeof fallbackName === "string" && fallbackName !== name;
    if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
      params["filename*"] = name;
    }
    if (isQuotedString || hasFallback) {
      params.filename = hasFallback ? fallbackName : name;
    }
    return params;
  }
  function format(obj) {
    var parameters = obj.parameters;
    var type2 = obj.type;
    if (!type2 || typeof type2 !== "string" || !TOKEN_REGEXP.test(type2)) {
      throw new TypeError("invalid type");
    }
    var string = String(type2).toLowerCase();
    if (parameters && typeof parameters === "object") {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0; i < params.length; i++) {
        param = params[i];
        var val = param.slice(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
        string += "; " + param + "=" + val;
      }
    }
    return string;
  }
  function decodefield(str) {
    var match = EXT_VALUE_REGEXP.exec(str);
    if (!match) {
      throw new TypeError("invalid extended field value");
    }
    var charset2 = match[1].toLowerCase();
    var encoded = match[2];
    var value;
    var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
    switch (charset2) {
      case "iso-8859-1":
        value = getlatin1(binary);
        break;
      case "utf-8":
      case "utf8":
        value = Buffer2.from(binary, "binary").toString("utf8");
        break;
      default:
        throw new TypeError("unsupported charset in extended field");
    }
    return value;
  }
  function getlatin1(val) {
    return String(val).replace(NON_LATIN1_REGEXP, "?");
  }
  function parse2(string) {
    if (!string || typeof string !== "string") {
      throw new TypeError("argument string is required");
    }
    var match = DISPOSITION_TYPE_REGEXP.exec(string);
    if (!match) {
      throw new TypeError("invalid type format");
    }
    var index2 = match[0].length;
    var type2 = match[1].toLowerCase();
    var key;
    var names = [];
    var params = {};
    var value;
    index2 = PARAM_REGEXP.lastIndex = match[0].slice(-1) === ";" ? index2 - 1 : index2;
    while (match = PARAM_REGEXP.exec(string)) {
      if (match.index !== index2) {
        throw new TypeError("invalid parameter format");
      }
      index2 += match[0].length;
      key = match[1].toLowerCase();
      value = match[2];
      if (names.indexOf(key) !== -1) {
        throw new TypeError("invalid duplicate parameter");
      }
      names.push(key);
      if (key.indexOf("*") + 1 === key.length) {
        key = key.slice(0, -1);
        value = decodefield(value);
        params[key] = value;
        continue;
      }
      if (typeof params[key] === "string") {
        continue;
      }
      if (value[0] === '"') {
        value = value.slice(1, -1).replace(QESC_REGEXP, "$1");
      }
      params[key] = value;
    }
    if (index2 !== -1 && index2 !== string.length) {
      throw new TypeError("invalid parameter format");
    }
    return new ContentDisposition(type2, params);
  }
  function pdecode(str, hex) {
    return String.fromCharCode(parseInt(hex, 16));
  }
  function pencode(char) {
    return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
  }
  function qstring(val) {
    var str = String(val);
    return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
  }
  function ustring(val) {
    var str = String(val);
    var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
    return "UTF-8''" + encoded;
  }
  function ContentDisposition(type2, parameters) {
    this.type = type2;
    this.parameters = parameters;
  }
  return contentDisposition.exports;
}
var cookieSignature = {};
var hasRequiredCookieSignature;
function requireCookieSignature() {
  if (hasRequiredCookieSignature) return cookieSignature;
  hasRequiredCookieSignature = 1;
  (function(exports) {
    var crypto2 = crypto$1;
    exports.sign = function(val, secret) {
      if ("string" != typeof val) throw new TypeError("Cookie value must be provided as a string.");
      if (null == secret) throw new TypeError("Secret key must be provided.");
      return val + "." + crypto2.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
    };
    exports.unsign = function(input, secret) {
      if ("string" != typeof input) throw new TypeError("Signed cookie string must be provided.");
      if (null == secret) throw new TypeError("Secret key must be provided.");
      var tentativeValue = input.slice(0, input.lastIndexOf(".")), expectedInput = exports.sign(tentativeValue, secret), expectedBuffer = Buffer.from(expectedInput), inputBuffer = Buffer.from(input);
      return expectedBuffer.length === inputBuffer.length && crypto2.timingSafeEqual(expectedBuffer, inputBuffer) ? tentativeValue : false;
    };
  })(cookieSignature);
  return cookieSignature;
}
var cookie = {};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredCookie;
function requireCookie() {
  if (hasRequiredCookie) return cookie;
  hasRequiredCookie = 1;
  cookie.parse = parse2;
  cookie.serialize = serialize;
  var __toString = Object.prototype.toString;
  var __hasOwnProperty = Object.prototype.hasOwnProperty;
  var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
  var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;
  var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
  var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
  function parse2(str, opt) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var obj = {};
    var len = str.length;
    if (len < 2) return obj;
    var dec = opt && opt.decode || decode;
    var index2 = 0;
    var eqIdx = 0;
    var endIdx = 0;
    do {
      eqIdx = str.indexOf("=", index2);
      if (eqIdx === -1) break;
      endIdx = str.indexOf(";", index2);
      if (endIdx === -1) {
        endIdx = len;
      } else if (eqIdx > endIdx) {
        index2 = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      var keyStartIdx = startIndex(str, index2, eqIdx);
      var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
      var key = str.slice(keyStartIdx, keyEndIdx);
      if (!__hasOwnProperty.call(obj, key)) {
        var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
        var valEndIdx = endIndex(str, endIdx, valStartIdx);
        if (str.charCodeAt(valStartIdx) === 34 && str.charCodeAt(valEndIdx - 1) === 34) {
          valStartIdx++;
          valEndIdx--;
        }
        var val = str.slice(valStartIdx, valEndIdx);
        obj[key] = tryDecode(val, dec);
      }
      index2 = endIdx + 1;
    } while (index2 < len);
    return obj;
  }
  function startIndex(str, index2, max2) {
    do {
      var code = str.charCodeAt(index2);
      if (code !== 32 && code !== 9) return index2;
    } while (++index2 < max2);
    return max2;
  }
  function endIndex(str, index2, min2) {
    while (index2 > min2) {
      var code = str.charCodeAt(--index2);
      if (code !== 32 && code !== 9) return index2 + 1;
    }
    return min2;
  }
  function serialize(name, val, opt) {
    var enc = opt && opt.encode || encodeURIComponent;
    if (typeof enc !== "function") {
      throw new TypeError("option encode is invalid");
    }
    if (!cookieNameRegExp.test(name)) {
      throw new TypeError("argument name is invalid");
    }
    var value = enc(val);
    if (!cookieValueRegExp.test(value)) {
      throw new TypeError("argument val is invalid");
    }
    var str = name + "=" + value;
    if (!opt) return str;
    if (null != opt.maxAge) {
      var maxAge = Math.floor(opt.maxAge);
      if (!isFinite(maxAge)) {
        throw new TypeError("option maxAge is invalid");
      }
      str += "; Max-Age=" + maxAge;
    }
    if (opt.domain) {
      if (!domainValueRegExp.test(opt.domain)) {
        throw new TypeError("option domain is invalid");
      }
      str += "; Domain=" + opt.domain;
    }
    if (opt.path) {
      if (!pathValueRegExp.test(opt.path)) {
        throw new TypeError("option path is invalid");
      }
      str += "; Path=" + opt.path;
    }
    if (opt.expires) {
      var expires = opt.expires;
      if (!isDate2(expires) || isNaN(expires.valueOf())) {
        throw new TypeError("option expires is invalid");
      }
      str += "; Expires=" + expires.toUTCString();
    }
    if (opt.httpOnly) {
      str += "; HttpOnly";
    }
    if (opt.secure) {
      str += "; Secure";
    }
    if (opt.partitioned) {
      str += "; Partitioned";
    }
    if (opt.priority) {
      var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError("option priority is invalid");
      }
    }
    if (opt.sameSite) {
      var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
      switch (sameSite) {
        case true:
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError("option sameSite is invalid");
      }
    }
    return str;
  }
  function decode(str) {
    return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
  }
  function isDate2(val) {
    return __toString.call(val) === "[object Date]";
  }
  function tryDecode(str, decode2) {
    try {
      return decode2(str);
    } catch (e) {
      return str;
    }
  }
  return cookie;
}
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var send_1;
var hasRequiredSend;
function requireSend() {
  if (hasRequiredSend) return send_1;
  hasRequiredSend = 1;
  var createError = requireHttpErrors();
  var debug2 = requireBrowser$2()("send");
  var encodeUrl = requireEncodeurl();
  var escapeHtml = requireEscapeHtml();
  var etag = requireEtag();
  var fresh = requireFresh();
  var fs2 = require$$1$2;
  var mime = requireMimeTypes();
  var ms2 = requireMs$1();
  var onFinished2 = requireOnFinished();
  var parseRange = requireRangeParser();
  var path2 = require$$1$3;
  var statuses2 = requireStatuses();
  var Stream = stream;
  var util2 = require$$0$5;
  var extname = path2.extname;
  var join = path2.join;
  var normalize = path2.normalize;
  var resolve = path2.resolve;
  var sep = path2.sep;
  var BYTES_RANGE_REGEXP = /^ *bytes=/;
  var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1e3;
  var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
  send_1 = send;
  function send(req, path22, options) {
    return new SendStream(req, path22, options);
  }
  function SendStream(req, path22, options) {
    Stream.call(this);
    var opts = options || {};
    this.options = opts;
    this.path = path22;
    this.req = req;
    this._acceptRanges = opts.acceptRanges !== void 0 ? Boolean(opts.acceptRanges) : true;
    this._cacheControl = opts.cacheControl !== void 0 ? Boolean(opts.cacheControl) : true;
    this._etag = opts.etag !== void 0 ? Boolean(opts.etag) : true;
    this._dotfiles = opts.dotfiles !== void 0 ? opts.dotfiles : "ignore";
    if (this._dotfiles !== "ignore" && this._dotfiles !== "allow" && this._dotfiles !== "deny") {
      throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
    }
    this._extensions = opts.extensions !== void 0 ? normalizeList(opts.extensions, "extensions option") : [];
    this._immutable = opts.immutable !== void 0 ? Boolean(opts.immutable) : false;
    this._index = opts.index !== void 0 ? normalizeList(opts.index, "index option") : ["index.html"];
    this._lastModified = opts.lastModified !== void 0 ? Boolean(opts.lastModified) : true;
    this._maxage = opts.maxAge || opts.maxage;
    this._maxage = typeof this._maxage === "string" ? ms2(this._maxage) : Number(this._maxage);
    this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
    this._root = opts.root ? resolve(opts.root) : null;
  }
  util2.inherits(SendStream, Stream);
  SendStream.prototype.error = function error(status, err) {
    if (hasListeners(this, "error")) {
      return this.emit("error", createHttpError(status, err));
    }
    var res = this.res;
    var msg = statuses2.message[status] || String(status);
    var doc = createHtmlDocument("Error", escapeHtml(msg));
    clearHeaders(res);
    if (err && err.headers) {
      setHeaders(res, err.headers);
    }
    res.statusCode = status;
    res.setHeader("Content-Type", "text/html; charset=UTF-8");
    res.setHeader("Content-Length", Buffer.byteLength(doc));
    res.setHeader("Content-Security-Policy", "default-src 'none'");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.end(doc);
  };
  SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
    return this.path[this.path.length - 1] === "/";
  };
  SendStream.prototype.isConditionalGET = function isConditionalGET() {
    return this.req.headers["if-match"] || this.req.headers["if-unmodified-since"] || this.req.headers["if-none-match"] || this.req.headers["if-modified-since"];
  };
  SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
    var req = this.req;
    var res = this.res;
    var match = req.headers["if-match"];
    if (match) {
      var etag2 = res.getHeader("ETag");
      return !etag2 || match !== "*" && parseTokenList(match).every(function(match2) {
        return match2 !== etag2 && match2 !== "W/" + etag2 && "W/" + match2 !== etag2;
      });
    }
    var unmodifiedSince = parseHttpDate(req.headers["if-unmodified-since"]);
    if (!isNaN(unmodifiedSince)) {
      var lastModified = parseHttpDate(res.getHeader("Last-Modified"));
      return isNaN(lastModified) || lastModified > unmodifiedSince;
    }
    return false;
  };
  SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
    var res = this.res;
    res.removeHeader("Content-Encoding");
    res.removeHeader("Content-Language");
    res.removeHeader("Content-Length");
    res.removeHeader("Content-Range");
    res.removeHeader("Content-Type");
  };
  SendStream.prototype.notModified = function notModified() {
    var res = this.res;
    debug2("not modified");
    this.removeContentHeaderFields();
    res.statusCode = 304;
    res.end();
  };
  SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
    var err = new Error("Can't set headers after they are sent.");
    debug2("headers already sent");
    this.error(500, err);
  };
  SendStream.prototype.isCachable = function isCachable() {
    var statusCode2 = this.res.statusCode;
    return statusCode2 >= 200 && statusCode2 < 300 || statusCode2 === 304;
  };
  SendStream.prototype.onStatError = function onStatError(error) {
    switch (error.code) {
      case "ENAMETOOLONG":
      case "ENOENT":
      case "ENOTDIR":
        this.error(404, error);
        break;
      default:
        this.error(500, error);
        break;
    }
  };
  SendStream.prototype.isFresh = function isFresh() {
    return fresh(this.req.headers, {
      etag: this.res.getHeader("ETag"),
      "last-modified": this.res.getHeader("Last-Modified")
    });
  };
  SendStream.prototype.isRangeFresh = function isRangeFresh() {
    var ifRange = this.req.headers["if-range"];
    if (!ifRange) {
      return true;
    }
    if (ifRange.indexOf('"') !== -1) {
      var etag2 = this.res.getHeader("ETag");
      return Boolean(etag2 && ifRange.indexOf(etag2) !== -1);
    }
    var lastModified = this.res.getHeader("Last-Modified");
    return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
  };
  SendStream.prototype.redirect = function redirect(path22) {
    var res = this.res;
    if (hasListeners(this, "directory")) {
      this.emit("directory", res, path22);
      return;
    }
    if (this.hasTrailingSlash()) {
      this.error(403);
      return;
    }
    var loc = encodeUrl(collapseLeadingSlashes(this.path + "/"));
    var doc = createHtmlDocument("Redirecting", "Redirecting to " + escapeHtml(loc));
    res.statusCode = 301;
    res.setHeader("Content-Type", "text/html; charset=UTF-8");
    res.setHeader("Content-Length", Buffer.byteLength(doc));
    res.setHeader("Content-Security-Policy", "default-src 'none'");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.setHeader("Location", loc);
    res.end(doc);
  };
  SendStream.prototype.pipe = function pipe(res) {
    var root = this._root;
    this.res = res;
    var path22 = decode(this.path);
    if (path22 === -1) {
      this.error(400);
      return res;
    }
    if (~path22.indexOf("\0")) {
      this.error(400);
      return res;
    }
    var parts;
    if (root !== null) {
      if (path22) {
        path22 = normalize("." + sep + path22);
      }
      if (UP_PATH_REGEXP.test(path22)) {
        debug2('malicious path "%s"', path22);
        this.error(403);
        return res;
      }
      parts = path22.split(sep);
      path22 = normalize(join(root, path22));
    } else {
      if (UP_PATH_REGEXP.test(path22)) {
        debug2('malicious path "%s"', path22);
        this.error(403);
        return res;
      }
      parts = normalize(path22).split(sep);
      path22 = resolve(path22);
    }
    if (containsDotFile(parts)) {
      debug2('%s dotfile "%s"', this._dotfiles, path22);
      switch (this._dotfiles) {
        case "allow":
          break;
        case "deny":
          this.error(403);
          return res;
        case "ignore":
        default:
          this.error(404);
          return res;
      }
    }
    if (this._index.length && this.hasTrailingSlash()) {
      this.sendIndex(path22);
      return res;
    }
    this.sendFile(path22);
    return res;
  };
  SendStream.prototype.send = function send2(path22, stat2) {
    var len = stat2.size;
    var options = this.options;
    var opts = {};
    var res = this.res;
    var req = this.req;
    var ranges = req.headers.range;
    var offset = options.start || 0;
    if (res.headersSent) {
      this.headersAlreadySent();
      return;
    }
    debug2('pipe "%s"', path22);
    this.setHeader(path22, stat2);
    this.type(path22);
    if (this.isConditionalGET()) {
      if (this.isPreconditionFailure()) {
        this.error(412);
        return;
      }
      if (this.isCachable() && this.isFresh()) {
        this.notModified();
        return;
      }
    }
    len = Math.max(0, len - offset);
    if (options.end !== void 0) {
      var bytes2 = options.end - offset + 1;
      if (len > bytes2) len = bytes2;
    }
    if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
      ranges = parseRange(len, ranges, {
        combine: true
      });
      if (!this.isRangeFresh()) {
        debug2("range stale");
        ranges = -2;
      }
      if (ranges === -1) {
        debug2("range unsatisfiable");
        res.setHeader("Content-Range", contentRange("bytes", len));
        return this.error(416, {
          headers: { "Content-Range": res.getHeader("Content-Range") }
        });
      }
      if (ranges !== -2 && ranges.length === 1) {
        debug2("range %j", ranges);
        res.statusCode = 206;
        res.setHeader("Content-Range", contentRange("bytes", len, ranges[0]));
        offset += ranges[0].start;
        len = ranges[0].end - ranges[0].start + 1;
      }
    }
    for (var prop in options) {
      opts[prop] = options[prop];
    }
    opts.start = offset;
    opts.end = Math.max(offset, offset + len - 1);
    res.setHeader("Content-Length", len);
    if (req.method === "HEAD") {
      res.end();
      return;
    }
    this.stream(path22, opts);
  };
  SendStream.prototype.sendFile = function sendFile(path22) {
    var i = 0;
    var self2 = this;
    debug2('stat "%s"', path22);
    fs2.stat(path22, function onstat(err, stat2) {
      var pathEndsWithSep = path22[path22.length - 1] === sep;
      if (err && err.code === "ENOENT" && !extname(path22) && !pathEndsWithSep) {
        return next(err);
      }
      if (err) return self2.onStatError(err);
      if (stat2.isDirectory()) return self2.redirect(path22);
      if (pathEndsWithSep) return self2.error(404);
      self2.emit("file", path22, stat2);
      self2.send(path22, stat2);
    });
    function next(err) {
      if (self2._extensions.length <= i) {
        return err ? self2.onStatError(err) : self2.error(404);
      }
      var p = path22 + "." + self2._extensions[i++];
      debug2('stat "%s"', p);
      fs2.stat(p, function(err2, stat2) {
        if (err2) return next(err2);
        if (stat2.isDirectory()) return next();
        self2.emit("file", p, stat2);
        self2.send(p, stat2);
      });
    }
  };
  SendStream.prototype.sendIndex = function sendIndex(path22) {
    var i = -1;
    var self2 = this;
    function next(err) {
      if (++i >= self2._index.length) {
        if (err) return self2.onStatError(err);
        return self2.error(404);
      }
      var p = join(path22, self2._index[i]);
      debug2('stat "%s"', p);
      fs2.stat(p, function(err2, stat2) {
        if (err2) return next(err2);
        if (stat2.isDirectory()) return next();
        self2.emit("file", p, stat2);
        self2.send(p, stat2);
      });
    }
    next();
  };
  SendStream.prototype.stream = function stream2(path22, options) {
    var self2 = this;
    var res = this.res;
    var stream22 = fs2.createReadStream(path22, options);
    this.emit("stream", stream22);
    stream22.pipe(res);
    function cleanup() {
      stream22.destroy();
    }
    onFinished2(res, cleanup);
    stream22.on("error", function onerror(err) {
      cleanup();
      self2.onStatError(err);
    });
    stream22.on("end", function onend() {
      self2.emit("end");
    });
  };
  SendStream.prototype.type = function type2(path22) {
    var res = this.res;
    if (res.getHeader("Content-Type")) return;
    var ext = extname(path22);
    var type3 = mime.contentType(ext) || "application/octet-stream";
    debug2("content-type %s", type3);
    res.setHeader("Content-Type", type3);
  };
  SendStream.prototype.setHeader = function setHeader(path22, stat2) {
    var res = this.res;
    this.emit("headers", res, path22, stat2);
    if (this._acceptRanges && !res.getHeader("Accept-Ranges")) {
      debug2("accept ranges");
      res.setHeader("Accept-Ranges", "bytes");
    }
    if (this._cacheControl && !res.getHeader("Cache-Control")) {
      var cacheControl = "public, max-age=" + Math.floor(this._maxage / 1e3);
      if (this._immutable) {
        cacheControl += ", immutable";
      }
      debug2("cache-control %s", cacheControl);
      res.setHeader("Cache-Control", cacheControl);
    }
    if (this._lastModified && !res.getHeader("Last-Modified")) {
      var modified = stat2.mtime.toUTCString();
      debug2("modified %s", modified);
      res.setHeader("Last-Modified", modified);
    }
    if (this._etag && !res.getHeader("ETag")) {
      var val = etag(stat2);
      debug2("etag %s", val);
      res.setHeader("ETag", val);
    }
  };
  function clearHeaders(res) {
    for (const header of res.getHeaderNames()) {
      res.removeHeader(header);
    }
  }
  function collapseLeadingSlashes(str) {
    for (var i = 0; i < str.length; i++) {
      if (str[i] !== "/") {
        break;
      }
    }
    return i > 1 ? "/" + str.substr(i) : str;
  }
  function containsDotFile(parts) {
    for (var i = 0; i < parts.length; i++) {
      var part = parts[i];
      if (part.length > 1 && part[0] === ".") {
        return true;
      }
    }
    return false;
  }
  function contentRange(type2, size, range2) {
    return type2 + " " + (range2 ? range2.start + "-" + range2.end : "*") + "/" + size;
  }
  function createHtmlDocument(title, body) {
    return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
  }
  function createHttpError(status, err) {
    if (!err) {
      return createError(status);
    }
    return err instanceof Error ? createError(status, err, { expose: false }) : createError(status, err);
  }
  function decode(path22) {
    try {
      return decodeURIComponent(path22);
    } catch (err) {
      return -1;
    }
  }
  function hasListeners(emitter, type2) {
    var count = typeof emitter.listenerCount !== "function" ? emitter.listeners(type2).length : emitter.listenerCount(type2);
    return count > 0;
  }
  function normalizeList(val, name) {
    var list = [].concat(val || []);
    for (var i = 0; i < list.length; i++) {
      if (typeof list[i] !== "string") {
        throw new TypeError(name + " must be array of strings or false");
      }
    }
    return list;
  }
  function parseHttpDate(date) {
    var timestamp = date && Date.parse(date);
    return typeof timestamp === "number" ? timestamp : NaN;
  }
  function parseTokenList(str) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = str.length; i < len; i++) {
      switch (str.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          if (start !== end) {
            list.push(str.substring(start, end));
          }
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    if (start !== end) {
      list.push(str.substring(start, end));
    }
    return list;
  }
  function setHeaders(res, headers2) {
    var keys = Object.keys(headers2);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      res.setHeader(key, headers2[key]);
    }
  }
  return send_1;
}
var vary$1 = { exports: {} };
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredVary$1;
function requireVary$1() {
  if (hasRequiredVary$1) return vary$1.exports;
  hasRequiredVary$1 = 1;
  vary$1.exports = vary$1$1;
  vary$1.exports.append = append2;
  var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
  function append2(header, field) {
    if (typeof header !== "string") {
      throw new TypeError("header argument is required");
    }
    if (!field) {
      throw new TypeError("field argument is required");
    }
    var fields = !Array.isArray(field) ? parse2(String(field)) : field;
    for (var j = 0; j < fields.length; j++) {
      if (!FIELD_NAME_REGEXP.test(fields[j])) {
        throw new TypeError("field argument contains an invalid header name");
      }
    }
    if (header === "*") {
      return header;
    }
    var val = header;
    var vals = parse2(header.toLowerCase());
    if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
      return "*";
    }
    for (var i = 0; i < fields.length; i++) {
      var fld = fields[i].toLowerCase();
      if (vals.indexOf(fld) === -1) {
        vals.push(fld);
        val = val ? val + ", " + fields[i] : fields[i];
      }
    }
    return val;
  }
  function parse2(header) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = header.length; i < len; i++) {
      switch (header.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          list.push(header.substring(start, end));
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    list.push(header.substring(start, end));
    return list;
  }
  function vary$1$1(res, field) {
    if (!res || !res.getHeader || !res.setHeader) {
      throw new TypeError("res argument is required");
    }
    var val = res.getHeader("Vary") || "";
    var header = Array.isArray(val) ? val.join(", ") : String(val);
    if (val = append2(header, field)) {
      res.setHeader("Vary", val);
    }
  }
  return vary$1.exports;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var response;
var hasRequiredResponse;
function requireResponse() {
  if (hasRequiredResponse) return response;
  hasRequiredResponse = 1;
  var contentDisposition2 = requireContentDisposition();
  var createError = requireHttpErrors();
  var encodeUrl = requireEncodeurl();
  var escapeHtml = requireEscapeHtml();
  var http = require$$2$2;
  var onFinished2 = requireOnFinished();
  var mime = requireMimeTypes();
  var path$1 = path;
  var pathIsAbsolute = path.isAbsolute;
  var statuses2 = requireStatuses();
  var sign2 = requireCookieSignature().sign;
  var normalizeType = requireUtils$4().normalizeType;
  var normalizeTypes = requireUtils$4().normalizeTypes;
  var setCharset = requireUtils$4().setCharset;
  var cookie2 = requireCookie();
  var send = requireSend();
  var extname = path$1.extname;
  var resolve = path$1.resolve;
  var vary2 = requireVary$1();
  var res = Object.create(http.ServerResponse.prototype);
  response = res;
  res.status = function status(code) {
    if (!Number.isInteger(code)) {
      throw new TypeError(`Invalid status code: ${JSON.stringify(code)}. Status code must be an integer.`);
    }
    if (code < 100 || code > 999) {
      throw new RangeError(`Invalid status code: ${JSON.stringify(code)}. Status code must be greater than 99 and less than 1000.`);
    }
    this.statusCode = code;
    return this;
  };
  res.links = function(links) {
    var link2 = this.get("Link") || "";
    if (link2) link2 += ", ";
    return this.set("Link", link2 + Object.keys(links).map(function(rel) {
      if (Array.isArray(links[rel])) {
        return links[rel].map(function(singleLink) {
          return `<${singleLink}>; rel="${rel}"`;
        }).join(", ");
      } else {
        return `<${links[rel]}>; rel="${rel}"`;
      }
    }).join(", "));
  };
  res.send = function send2(body) {
    var chunk = body;
    var encoding2;
    var req = this.req;
    var type2;
    var app2 = this.app;
    switch (typeof chunk) {
      // string defaulting to html
      case "string":
        if (!this.get("Content-Type")) {
          this.type("html");
        }
        break;
      case "boolean":
      case "number":
      case "object":
        if (chunk === null) {
          chunk = "";
        } else if (ArrayBuffer.isView(chunk)) {
          if (!this.get("Content-Type")) {
            this.type("bin");
          }
        } else {
          return this.json(chunk);
        }
        break;
    }
    if (typeof chunk === "string") {
      encoding2 = "utf8";
      type2 = this.get("Content-Type");
      if (typeof type2 === "string") {
        this.set("Content-Type", setCharset(type2, "utf-8"));
      }
    }
    var etagFn = app2.get("etag fn");
    var generateETag = !this.get("ETag") && typeof etagFn === "function";
    var len;
    if (chunk !== void 0) {
      if (Buffer.isBuffer(chunk)) {
        len = chunk.length;
      } else if (!generateETag && chunk.length < 1e3) {
        len = Buffer.byteLength(chunk, encoding2);
      } else {
        chunk = Buffer.from(chunk, encoding2);
        encoding2 = void 0;
        len = chunk.length;
      }
      this.set("Content-Length", len);
    }
    var etag;
    if (generateETag && len !== void 0) {
      if (etag = etagFn(chunk, encoding2)) {
        this.set("ETag", etag);
      }
    }
    if (req.fresh) this.status(304);
    if (204 === this.statusCode || 304 === this.statusCode) {
      this.removeHeader("Content-Type");
      this.removeHeader("Content-Length");
      this.removeHeader("Transfer-Encoding");
      chunk = "";
    }
    if (this.statusCode === 205) {
      this.set("Content-Length", "0");
      this.removeHeader("Transfer-Encoding");
      chunk = "";
    }
    if (req.method === "HEAD") {
      this.end();
    } else {
      this.end(chunk, encoding2);
    }
    return this;
  };
  res.json = function json2(obj) {
    var app2 = this.app;
    var escape2 = app2.get("json escape");
    var replacer = app2.get("json replacer");
    var spaces = app2.get("json spaces");
    var body = stringify2(obj, replacer, spaces, escape2);
    if (!this.get("Content-Type")) {
      this.set("Content-Type", "application/json");
    }
    return this.send(body);
  };
  res.jsonp = function jsonp(obj) {
    var app2 = this.app;
    var escape2 = app2.get("json escape");
    var replacer = app2.get("json replacer");
    var spaces = app2.get("json spaces");
    var body = stringify2(obj, replacer, spaces, escape2);
    var callback = this.req.query[app2.get("jsonp callback name")];
    if (!this.get("Content-Type")) {
      this.set("X-Content-Type-Options", "nosniff");
      this.set("Content-Type", "application/json");
    }
    if (Array.isArray(callback)) {
      callback = callback[0];
    }
    if (typeof callback === "string" && callback.length !== 0) {
      this.set("X-Content-Type-Options", "nosniff");
      this.set("Content-Type", "text/javascript");
      callback = callback.replace(/[^\[\]\w$.]/g, "");
      if (body === void 0) {
        body = "";
      } else if (typeof body === "string") {
        body = body.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      }
      body = "/**/ typeof " + callback + " === 'function' && " + callback + "(" + body + ");";
    }
    return this.send(body);
  };
  res.sendStatus = function sendStatus(statusCode2) {
    var body = statuses2.message[statusCode2] || String(statusCode2);
    this.status(statusCode2);
    this.type("txt");
    return this.send(body);
  };
  res.sendFile = function sendFile(path2, options, callback) {
    var done = callback;
    var req = this.req;
    var res2 = this;
    var next = req.next;
    var opts = options || {};
    if (!path2) {
      throw new TypeError("path argument is required to res.sendFile");
    }
    if (typeof path2 !== "string") {
      throw new TypeError("path must be a string to res.sendFile");
    }
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    if (!opts.root && !pathIsAbsolute(path2)) {
      throw new TypeError("path must be absolute or specify root to res.sendFile");
    }
    var pathname = encodeURI(path2);
    opts.etag = this.app.enabled("etag");
    var file2 = send(req, pathname, opts);
    sendfile(res2, file2, opts, function(err) {
      if (done) return done(err);
      if (err && err.code === "EISDIR") return next();
      if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
        next(err);
      }
    });
  };
  res.download = function download(path2, filename, options, callback) {
    var done = callback;
    var name = filename;
    var opts = options || null;
    if (typeof filename === "function") {
      done = filename;
      name = null;
      opts = null;
    } else if (typeof options === "function") {
      done = options;
      opts = null;
    }
    if (typeof filename === "object" && (typeof options === "function" || options === void 0)) {
      name = null;
      opts = filename;
    }
    var headers2 = {
      "Content-Disposition": contentDisposition2(name || path2)
    };
    if (opts && opts.headers) {
      var keys = Object.keys(opts.headers);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.toLowerCase() !== "content-disposition") {
          headers2[key] = opts.headers[key];
        }
      }
    }
    opts = Object.create(opts);
    opts.headers = headers2;
    var fullPath = !opts.root ? resolve(path2) : path2;
    return this.sendFile(fullPath, opts, done);
  };
  res.contentType = res.type = function contentType2(type2) {
    var ct = type2.indexOf("/") === -1 ? mime.contentType(type2) || "application/octet-stream" : type2;
    return this.set("Content-Type", ct);
  };
  res.format = function(obj) {
    var req = this.req;
    var next = req.next;
    var keys = Object.keys(obj).filter(function(v) {
      return v !== "default";
    });
    var key = keys.length > 0 ? req.accepts(keys) : false;
    this.vary("Accept");
    if (key) {
      this.set("Content-Type", normalizeType(key).value);
      obj[key](req, this, next);
    } else if (obj.default) {
      obj.default(req, this, next);
    } else {
      next(createError(406, {
        types: normalizeTypes(keys).map(function(o) {
          return o.value;
        })
      }));
    }
    return this;
  };
  res.attachment = function attachment(filename) {
    if (filename) {
      this.type(extname(filename));
    }
    this.set("Content-Disposition", contentDisposition2(filename));
    return this;
  };
  res.append = function append2(field, val) {
    var prev = this.get(field);
    var value = val;
    if (prev) {
      value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
    }
    return this.set(field, value);
  };
  res.set = res.header = function header(field, val) {
    if (arguments.length === 2) {
      var value = Array.isArray(val) ? val.map(String) : String(val);
      if (field.toLowerCase() === "content-type") {
        if (Array.isArray(value)) {
          throw new TypeError("Content-Type cannot be set to an Array");
        }
        value = mime.contentType(value);
      }
      this.setHeader(field, value);
    } else {
      for (var key in field) {
        this.set(key, field[key]);
      }
    }
    return this;
  };
  res.get = function(field) {
    return this.getHeader(field);
  };
  res.clearCookie = function clearCookie(name, options) {
    const opts = { path: "/", ...options, expires: /* @__PURE__ */ new Date(1) };
    delete opts.maxAge;
    return this.cookie(name, "", opts);
  };
  res.cookie = function(name, value, options) {
    var opts = { ...options };
    var secret = this.req.secret;
    var signed = opts.signed;
    if (signed && !secret) {
      throw new Error('cookieParser("secret") required for signed cookies');
    }
    var val = typeof value === "object" ? "j:" + JSON.stringify(value) : String(value);
    if (signed) {
      val = "s:" + sign2(val, secret);
    }
    if (opts.maxAge != null) {
      var maxAge = opts.maxAge - 0;
      if (!isNaN(maxAge)) {
        opts.expires = new Date(Date.now() + maxAge);
        opts.maxAge = Math.floor(maxAge / 1e3);
      }
    }
    if (opts.path == null) {
      opts.path = "/";
    }
    this.append("Set-Cookie", cookie2.serialize(name, String(val), opts));
    return this;
  };
  res.location = function location(url) {
    return this.set("Location", encodeUrl(url));
  };
  res.redirect = function redirect(url) {
    var address = url;
    var body;
    var status = 302;
    if (arguments.length === 2) {
      status = arguments[0];
      address = arguments[1];
    }
    address = this.location(address).get("Location");
    this.format({
      text: function() {
        body = statuses2.message[status] + ". Redirecting to " + address;
      },
      html: function() {
        var u = escapeHtml(address);
        body = "<p>" + statuses2.message[status] + ". Redirecting to " + u + "</p>";
      },
      default: function() {
        body = "";
      }
    });
    this.status(status);
    this.set("Content-Length", Buffer.byteLength(body));
    if (this.req.method === "HEAD") {
      this.end();
    } else {
      this.end(body);
    }
  };
  res.vary = function(field) {
    vary2(this, field);
    return this;
  };
  res.render = function render(view2, options, callback) {
    var app2 = this.req.app;
    var done = callback;
    var opts = options || {};
    var req = this.req;
    var self2 = this;
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    opts._locals = self2.locals;
    done = done || function(err, str) {
      if (err) return req.next(err);
      self2.send(str);
    };
    app2.render(view2, opts, done);
  };
  function sendfile(res2, file2, options, callback) {
    var done = false;
    var streaming;
    function onaborted() {
      if (done) return;
      done = true;
      var err = new Error("Request aborted");
      err.code = "ECONNABORTED";
      callback(err);
    }
    function ondirectory() {
      if (done) return;
      done = true;
      var err = new Error("EISDIR, read");
      err.code = "EISDIR";
      callback(err);
    }
    function onerror(err) {
      if (done) return;
      done = true;
      callback(err);
    }
    function onend() {
      if (done) return;
      done = true;
      callback();
    }
    function onfile() {
      streaming = false;
    }
    function onfinish(err) {
      if (err && err.code === "ECONNRESET") return onaborted();
      if (err) return onerror(err);
      if (done) return;
      setImmediate(function() {
        if (streaming !== false && !done) {
          onaborted();
          return;
        }
        if (done) return;
        done = true;
        callback();
      });
    }
    function onstream() {
      streaming = true;
    }
    file2.on("directory", ondirectory);
    file2.on("end", onend);
    file2.on("error", onerror);
    file2.on("file", onfile);
    file2.on("stream", onstream);
    onFinished2(res2, onfinish);
    if (options.headers) {
      file2.on("headers", function headers2(res3) {
        var obj = options.headers;
        var keys = Object.keys(obj);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          res3.setHeader(k, obj[k]);
        }
      });
    }
    file2.pipe(res2);
  }
  function stringify2(value, replacer, spaces, escape2) {
    var json2 = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
    if (escape2 && typeof json2 === "string") {
      json2 = json2.replace(/[<>&]/g, function(c) {
        switch (c.charCodeAt(0)) {
          case 60:
            return "\\u003c";
          case 62:
            return "\\u003e";
          case 38:
            return "\\u0026";
          /* istanbul ignore next: unreachable default */
          default:
            return c;
        }
      });
    }
    return json2;
  }
  return response;
}
/*!
 * serve-static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var serveStatic_1;
var hasRequiredServeStatic;
function requireServeStatic() {
  if (hasRequiredServeStatic) return serveStatic_1;
  hasRequiredServeStatic = 1;
  var encodeUrl = requireEncodeurl();
  var escapeHtml = requireEscapeHtml();
  var parseUrl = requireParseurl();
  var resolve = require$$1$3.resolve;
  var send = requireSend();
  var url = require$$0$6;
  serveStatic_1 = serveStatic;
  function serveStatic(root, options) {
    if (!root) {
      throw new TypeError("root path required");
    }
    if (typeof root !== "string") {
      throw new TypeError("root path must be a string");
    }
    var opts = Object.create(options || null);
    var fallthrough = opts.fallthrough !== false;
    var redirect = opts.redirect !== false;
    var setHeaders = opts.setHeaders;
    if (setHeaders && typeof setHeaders !== "function") {
      throw new TypeError("option setHeaders must be function");
    }
    opts.maxage = opts.maxage || opts.maxAge || 0;
    opts.root = resolve(root);
    var onDirectory = redirect ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
    return function serveStatic2(req, res, next) {
      if (req.method !== "GET" && req.method !== "HEAD") {
        if (fallthrough) {
          return next();
        }
        res.statusCode = 405;
        res.setHeader("Allow", "GET, HEAD");
        res.setHeader("Content-Length", "0");
        res.end();
        return;
      }
      var forwardError = !fallthrough;
      var originalUrl = parseUrl.original(req);
      var path2 = parseUrl(req).pathname;
      if (path2 === "/" && originalUrl.pathname.substr(-1) !== "/") {
        path2 = "";
      }
      var stream2 = send(req, path2, opts);
      stream2.on("directory", onDirectory);
      if (setHeaders) {
        stream2.on("headers", setHeaders);
      }
      if (fallthrough) {
        stream2.on("file", function onFile() {
          forwardError = true;
        });
      }
      stream2.on("error", function error(err) {
        if (forwardError || !(err.statusCode < 500)) {
          next(err);
          return;
        }
        next();
      });
      stream2.pipe(res);
    };
  }
  function collapseLeadingSlashes(str) {
    for (var i = 0; i < str.length; i++) {
      if (str.charCodeAt(i) !== 47) {
        break;
      }
    }
    return i > 1 ? "/" + str.substr(i) : str;
  }
  function createHtmlDocument(title, body) {
    return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
  }
  function createNotFoundDirectoryListener() {
    return function notFound() {
      this.error(404);
    };
  }
  function createRedirectDirectoryListener() {
    return function redirect(res) {
      if (this.hasTrailingSlash()) {
        this.error(404);
        return;
      }
      var originalUrl = parseUrl.original(this.req);
      originalUrl.path = null;
      originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + "/");
      var loc = encodeUrl(url.format(originalUrl));
      var doc = createHtmlDocument("Redirecting", "Redirecting to " + escapeHtml(loc));
      res.statusCode = 301;
      res.setHeader("Content-Type", "text/html; charset=UTF-8");
      res.setHeader("Content-Length", Buffer.byteLength(doc));
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.setHeader("Location", loc);
      res.end(doc);
    };
  }
  return serveStatic_1;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredExpress$1;
function requireExpress$1() {
  if (hasRequiredExpress$1) return express$1.exports;
  hasRequiredExpress$1 = 1;
  (function(module, exports) {
    var bodyParser2 = requireBodyParser();
    var EventEmitter2 = require$$1$5.EventEmitter;
    var mixin = /* @__PURE__ */ requireMergeDescriptors();
    var proto2 = requireApplication();
    var Router2 = requireRouter$1();
    var req = requireRequest();
    var res = requireResponse();
    exports = module.exports = createApplication;
    function createApplication() {
      var app2 = function(req2, res2, next) {
        app2.handle(req2, res2, next);
      };
      mixin(app2, EventEmitter2.prototype, false);
      mixin(app2, proto2, false);
      app2.request = Object.create(req, {
        app: { configurable: true, enumerable: true, writable: true, value: app2 }
      });
      app2.response = Object.create(res, {
        app: { configurable: true, enumerable: true, writable: true, value: app2 }
      });
      app2.init();
      return app2;
    }
    exports.application = proto2;
    exports.request = req;
    exports.response = res;
    exports.Route = Router2.Route;
    exports.Router = Router2;
    exports.json = bodyParser2.json;
    exports.raw = bodyParser2.raw;
    exports.static = requireServeStatic();
    exports.text = bodyParser2.text;
    exports.urlencoded = bodyParser2.urlencoded;
  })(express$1, express$1.exports);
  return express$1.exports;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var express;
var hasRequiredExpress;
function requireExpress() {
  if (hasRequiredExpress) return express;
  hasRequiredExpress = 1;
  express = requireExpress$1();
  return express;
}
var expressExports = requireExpress();
const index = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: expressExports
}, [expressExports]);
expressExports.Route;
const Router = expressExports.Router;
expressExports.application;
expressExports.json;
expressExports.raw;
expressExports.request;
expressExports.response;
expressExports.text;
expressExports.urlencoded;
const app = index.default;
/*!
 * @ikenxuan/amagi
 * Copyright(c) 2023 ikenxuan
 * GPL-3.0 Licensed
 */
var getPackageLogsPath = () => {
  const currentFileUrl = import.meta.url;
  const currentFilePath = fileURLToPath(currentFileUrl);
  const currentDir = require$$1$3.dirname(currentFilePath);
  let packageRoot = currentDir;
  while (packageRoot !== require$$1$3.dirname(packageRoot)) {
    if (require$$1$2.existsSync(require$$1$3.join(packageRoot, "package.json"))) {
      break;
    }
    packageRoot = require$$1$3.dirname(packageRoot);
  }
  return require$$1$3.join(packageRoot, "logs");
};
var logsPath = getPackageLogsPath();
app$1.configure({
  appenders: {
    console: {
      type: "stdout",
      layout: {
        type: "pattern",
        pattern: "%[[amagi][%d{hh:mm:ss.SSS}][%4.4p]%] %m"
      }
    },
    command: {
      type: "dateFile",
      filename: require$$1$3.join(logsPath, "application", "command"),
      pattern: "yyyy-MM-dd.log",
      numBackups: 15,
      alwaysIncludePattern: true,
      layout: {
        type: "pattern",
        pattern: "[%d{hh:mm:ss.SSS}][%4.4p] %m"
      }
    },
    httpConsole: {
      type: "stdout",
      layout: {
        type: "pattern",
        pattern: "%[[amagi][%d{hh:mm:ss.SSS}][HTTP]%] %m"
      }
    },
    httpRequest: {
      type: "dateFile",
      filename: require$$1$3.join(logsPath, "http", "requests"),
      pattern: "yyyy-MM-dd.log",
      numBackups: 30,
      alwaysIncludePattern: true,
      layout: {
        type: "pattern",
        pattern: "[%d{hh:mm:ss.SSS}][%4.4p] %m"
      }
    }
  },
  categories: {
    default: { appenders: ["console", "command"], level: "info" },
    http: { appenders: ["httpConsole", "httpRequest"], level: "debug" }
  },
  pm2: true
});
var CustomLogger = class {
  logger;
  chalk;
  red;
  green;
  yellow;
  blue;
  magenta;
  cyan;
  white;
  gray;
  constructor(name) {
    this.logger = app$1.getLogger(name);
    this.chalk = new Chalk();
    this.red = this.chalk.red;
    this.green = this.chalk.green;
    this.yellow = this.chalk.yellow;
    this.blue = this.chalk.blue;
    this.magenta = this.chalk.magenta;
    this.cyan = this.chalk.cyan;
    this.white = this.chalk.white;
    this.gray = this.chalk.gray;
  }
  //  log4js.Logger 
  info(message, ...args) {
    this.logger.info(message, ...args);
  }
  warn(message, ...args) {
    this.logger.warn(message, ...args);
  }
  error(message, ...args) {
    this.logger.error(message, ...args);
  }
  mark(message, ...args) {
    this.logger.mark(message, ...args);
  }
  debug(message, ...args) {
    this.logger.debug(message, ...args);
  }
};
var logger$1 = new CustomLogger("default");
var httpLogger = new CustomLogger("http");
var logMiddleware = (pathsToLog) => {
  return (req, res, next) => {
    if (!pathsToLog || pathsToLog.some((path2) => req.url.startsWith(path2))) {
      const startTime = Date.now();
      const url = req.url;
      const method = req.method;
      const clientIP = req.headers["x-forwarded-for"] || req.socket.remoteAddress;
      const referer = req.headers["referer"] || req.headers["referrer"] || "-";
      const contentType2 = req.headers["content-type"] || "-";
      const requestSize = req.headers["content-length"] || "0";
      const protocol = req.protocol;
      const httpVersion = req.httpVersion;
      res.on("finish", () => {
        const responseTime = Date.now() - startTime;
        const statusCode2 = res.statusCode;
        const responseSize = res.get("content-length") || "0";
        const logData = {
          method,
          url,
          statusCode: statusCode2,
          responseTime: `${responseTime}ms`,
          clientIP,
          referer,
          contentType: contentType2,
          requestSize: `${requestSize}B`,
          responseSize: `${responseSize}B`,
          protocol,
          httpVersion,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        };
        httpLogger.debug(JSON.stringify(logData));
      });
    }
    next();
  };
};
var Networks = class {
  url;
  method;
  headers;
  type;
  body;
  axiosInstance;
  isGetResult;
  timeout;
  timer;
  data;
  constructor(data2) {
    this.headers = data2.headers ?? {};
    this.url = data2.url ?? "";
    this.type = data2.responseType ?? "json";
    this.method = data2.method ?? "GET";
    this.body = data2.body ?? null;
    this.data = {};
    this.timeout = data2.timeout ?? 15e3;
    this.isGetResult = false;
    this.timer = void 0;
    this.axiosInstance = axios.create({
      timeout: this.timeout,
      headers: this.headers,
      maxRedirects: 5,
      validateStatus: (status) => {
        return status >= 200 && status < 600;
      }
    });
  }
  get config() {
    let config = {
      url: this.url,
      method: this.method,
      headers: this.headers
    };
    if (this.method === "POST" && this.body) {
      config.data = this.body;
    }
    return config;
  }
  async getfetch() {
    try {
      const result = await this.returnResult();
      if (result.status === 504) {
        return result;
      }
      this.isGetResult = true;
      return result;
    } catch (error) {
      logger$1.info(error);
      return false;
    }
  }
  async returnResult() {
    return await this.axiosInstance(this.config);
  }
  /**  */
  async getLongLink() {
    try {
      const response2 = await this.axiosInstance({
        method: "GET",
        url: this.url
      });
      return response2.request.res.responseUrl;
    } catch (error) {
      if (error instanceof AxiosError) {
        throw new Error(error.stack);
      }
      return "";
    }
  }
  /** 302 */
  async getLocation() {
    try {
      const response2 = await this.axiosInstance({
        method: "GET",
        url: this.url,
        maxRedirects: 0,
        // 
        validateStatus: (status) => status >= 300 && status < 400
        // 3xx
      });
      return response2.headers["location"];
    } catch (error) {
      if (error instanceof AxiosError) {
        throw new Error(error.stack);
      }
      return "";
    }
  }
  /** json */
  async getData(new_fetch = "") {
    try {
      if (!new_fetch) {
        const result = await this.returnResult();
        if (result.status === 504) {
          return result;
        }
        if (result.status === 429) {
          logger$1.error("HTTP : 429");
          throw new Error("ratelimit triggered,  https://www.douyin.com/ ");
        }
        this.axiosInstance = result;
        this.isGetResult = true;
      } else {
        this.axiosInstance = new_fetch;
      }
      return this.axiosInstance.data;
    } catch (error) {
      if (error instanceof AxiosError) {
        throw new Error(error.stack);
      }
      return false;
    }
  }
  async getHeadersAndData() {
    try {
      const result = await this.axiosInstance(this.config);
      let headers2 = {};
      const fetchHeaders = result.headers;
      for (const [key, value] of Object.entries(fetchHeaders)) {
        headers2[key] = value;
      }
      return { headers: headers2, data: result.data };
    } catch (error) {
      console.error(":", error);
      return { headers: null, data: null };
    }
  }
};
var qtparam = async (BASEURL, cookie2) => {
  if (cookie2 === "") return { QUERY: "&platform=html5", STATUS: "!isLogin" };
  const logininfo = await new Networks({ url: bilibiliApiUrls.(), headers: { Cookie: cookie2 } }).getData();
  const sign2 = await wbi_sign(BASEURL, cookie2);
  const qn = [6, 16, 32, 64, 74, 80, 112, 116, 120, 125, 126, 127];
  let isvip;
  logininfo.data.vipStatus === 1 ? isvip = true : isvip = false;
  if (isvip) {
    return { QUERY: `&fnval=16&fourk=1&${sign2}`, STATUS: "isLogin", isvip };
  } else return { QUERY: `&qn=${qn[3]}&fnval=16`, STATUS: "isLogin", isvip };
};
var XOR_CODE = 23442827791579n;
var MASK_CODE = 2251799813685247n;
var MAX_AID = 1n << 51n;
var BASE = 58n;
var data = "FcwAPNKTMug3GV5Lj7EJnHpWsx4tb8haYeviqBz6rkCy12mUSDQX9RdoZf";
var av2bv = (aid) => {
  const bytes2 = ["B", "V", "1", "0", "0", "0", "0", "0", "0", "0", "0", "0"];
  let bvIndex = bytes2.length - 1;
  let tmp = (MAX_AID | BigInt(aid)) ^ XOR_CODE;
  while (tmp > 0) {
    bytes2[bvIndex] = data[Number(tmp % BigInt(BASE))];
    tmp = tmp / BASE;
    bvIndex -= 1;
  }
  [bytes2[3], bytes2[9]] = [bytes2[9], bytes2[3]];
  [bytes2[4], bytes2[7]] = [bytes2[7], bytes2[4]];
  return bytes2.join("");
};
var bv2av = (bvid) => {
  const bvidArr = Array.from(bvid);
  [bvidArr[3], bvidArr[9]] = [bvidArr[9], bvidArr[3]];
  [bvidArr[4], bvidArr[7]] = [bvidArr[7], bvidArr[4]];
  bvidArr.splice(0, 3);
  const tmp = bvidArr.reduce((pre, bvidChar) => pre * BASE + BigInt(data.indexOf(bvidChar)), 0n);
  return Number(tmp & MASK_CODE ^ XOR_CODE);
};
var BiLiBiLiAPI = class {
  () {
    return "https://api.bilibili.com/x/web-interface/nav";
  }
  (data2) {
    return `https://api.bilibili.com/x/web-interface/view?bvid=${data2.bvid}`;
  }
  (data2) {
    return `https://api.bilibili.com/x/player/playurl?avid=${data2.avid}&cid=${data2.cid}`;
  }
  /** type [](https://github.com/SocialSisterYi/bilibili-API-collect/blob/master/docs/comment/readme.md#) */
  (data2) {
    const params = new URLSearchParams({
      oid: data2.oid.toString(),
      type: data2.type.toString(),
      mode: (data2.mode ?? 3).toString(),
      plat: "1",
      seek_rpid: "",
      web_location: "1315875"
    });
    if (data2.pagination_str) {
      params.append("pagination_str", JSON.stringify({ offset: data2.pagination_str }));
    } else {
      params.append("pagination_str", JSON.stringify({ offset: "" }));
    }
    return `https://api.bilibili.com/x/v2/reply/wbi/main?${params.toString()}`;
  }
  (data2) {
    return `https://api.bilibili.com/x/v2/reply/subject/description?type=${data2.type}&oid=${data2.oid}`;
  }
  () {
    return "https://api.bilibili.com/x/emote/user/panel/web?business=reply&web_location=0.0";
  }
  (data2) {
    if (data2.ep_id) {
      return `https://api.bilibili.com/pgc/view/web/season?ep_id=${data2.ep_id}`;
    } else if (data2.season_id) {
      return `https://api.bilibili.com/pgc/view/web/season?season_id=${data2.season_id}`;
    } else {
      throw new Error(" ep_id  season_id ");
    }
  }
  (data2) {
    return `https://api.bilibili.com/pgc/player/web/playurl?cid=${data2.cid}&ep_id=${data2.ep_id}`;
  }
  (data2) {
    return `https://api.bilibili.com/x/polymer/web-dynamic/v1/feed/space?host_mid=${data2.host_mid}`;
  }
  (data2) {
    return `https://api.bilibili.com/x/polymer/web-dynamic/v1/detail?id=${data2.dynamic_id}`;
  }
  (data2) {
    return `https://api.vc.bilibili.com/dynamic_svr/v1/dynamic_svr/get_dynamic_detail?dynamic_id=${data2.dynamic_id}`;
  }
  (data2) {
    return `https://api.bilibili.com/x/web-interface/card?mid=${data2.host_mid}&photo=true`;
  }
  (data2) {
    return `https://api.live.bilibili.com/room/v1/Room/get_info?room_id=${data2.room_id}`;
  }
  (data2) {
    return `https://api.live.bilibili.com/room/v1/Room/room_init?id=${data2.room_id}`;
  }
  () {
    return "https://passport.bilibili.com/x/passport-login/web/qrcode/generate";
  }
  (data2) {
    return `https://passport.bilibili.com/x/passport-login/web/qrcode/poll?qrcode_key=${data2.qrcode_key}`;
  }
  UP(data2) {
    return `https://api.bilibili.com/x/space/upstat?mid=${data2.host_mid}`;
  }
};
var bilibiliApiUrls = new BiLiBiLiAPI();
var kuaishouAPIErrorCode = /* @__PURE__ */ ((kuaishouAPIErrorCode2) => {
  kuaishouAPIErrorCode2["COOKIE"] = "INVALID_COOKIE";
  kuaishouAPIErrorCode2["UNKNOWN"] = "UNKNOWN_ERROR";
  return kuaishouAPIErrorCode2;
})(kuaishouAPIErrorCode || {});
var mixinKeyEncTab = [
  46,
  47,
  18,
  2,
  53,
  8,
  23,
  32,
  15,
  50,
  10,
  31,
  58,
  3,
  45,
  35,
  27,
  43,
  5,
  49,
  33,
  9,
  42,
  19,
  29,
  28,
  14,
  39,
  12,
  38,
  41,
  13,
  37,
  48,
  7,
  16,
  24,
  55,
  40,
  61,
  26,
  17,
  0,
  1,
  60,
  51,
  30,
  4,
  22,
  25,
  54,
  21,
  56,
  59,
  6,
  63,
  57,
  62,
  11,
  36,
  20,
  34,
  44,
  52
];
var getMixinKey = (orig) => mixinKeyEncTab.map((n) => orig[n]).join("").slice(0, 32);
var encWbi = (params, img_key, sub_key) => {
  const mixin_key = getMixinKey(img_key + sub_key);
  const curr_time = Math.round(Date.now() / 1e3);
  const chr_filter = /[!'()*]/g;
  Object.assign(params, { wts: curr_time });
  const query = Object.keys(params).sort().map((key) => {
    const value = params[key].toString().replace(chr_filter, "");
    return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
  }).join("&");
  const wbi_sign2 = crypto$1.createHash("md5").update(query + mixin_key).digest("hex");
  return `&wts=${curr_time}&w_rid=${wbi_sign2}`;
};
var getWbiKeys = async (cookie2) => {
  const res = await axios("https://api.bilibili.com/x/web-interface/nav", {
    headers: {
      Cookie: cookie2
    }
  });
  const response2 = res.data;
  const {
    data: {
      wbi_img: { img_url, sub_url }
    }
  } = response2;
  return {
    img_key: img_url.slice(img_url.lastIndexOf("/") + 1, img_url.lastIndexOf(".")),
    sub_key: sub_url.slice(sub_url.lastIndexOf("/") + 1, sub_url.lastIndexOf("."))
  };
};
var wbi_sign = async (BASEURL, cookie2) => {
  const web_keys = await getWbiKeys(cookie2);
  const url = new URL(BASEURL);
  const params = {};
  for (const [key, value] of url.searchParams.entries()) {
    params[key] = value;
  }
  const query = encWbi(params, web_keys.img_key, web_keys.sub_key);
  return query;
};
var defheaders = {
  accept: "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
  "accept-language": "zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6",
  "cache-control": "max-age=0",
  priority: "u=0, i",
  "sec-ch-ua": "'Microsoft Edge';v='131', 'Chromium';v='131', 'Not_A Brand';v='24'",
  "sec-ch-ua-mobile": "?0",
  "sec-ch-ua-platform": "'Windows'",
  "sec-fetch-dest": "document",
  "sec-fetch-mode": "navigate",
  "sec-fetch-site": "none",
  "sec-fetch-user": "?1",
  "upgrade-insecure-requests": "1",
  referer: "https://www.bilibili.com/"
};
var fetchBilibili = async (data2, cookie2) => {
  var _a, _b, _c;
  const headers2 = {
    ...defheaders,
    cookie: cookie2 ? cookie2.replace(/\s+/g, "") : ""
  };
  switch (data2.methodType) {
    case "": {
      const INFODATA = await GlobalGetData({
        url: bilibiliApiUrls.({ bvid: data2.bvid }),
        ...data2
      });
      return INFODATA;
    }
    case "": {
      const BASEURL = bilibiliApiUrls.({ avid: data2.avid, cid: data2.cid });
      const SIGN = await qtparam(BASEURL, headers2.cookie);
      const DATA = await GlobalGetData({
        url: bilibiliApiUrls.({ avid: data2.avid, cid: data2.cid }) + SIGN.QUERY,
        headers: headers2,
        ...data2
      });
      return DATA;
    }
    case "": {
      let { oid, number, type: type2, mode: mode2, pagination_str, plat, seek_rpid, web_location } = data2;
      let fetchedComments = [];
      const maxRequestCount = 100;
      let requestCount = 0;
      let tmpresp;
      let nextPaginationStr = pagination_str;
      let isEnd = false;
      const checkStatusUrl = bilibiliApiUrls.({ oid, type: type2 });
      const checkStatusRes = await GlobalGetData({
        url: checkStatusUrl,
        headers: headers2,
        ...data2
      });
      if (checkStatusRes.data === null) {
        logger$1.error("");
        return {
          code: 404,
          message: "",
          data: null
        };
      }
      while (fetchedComments.length < Number(number ?? 20) && requestCount < maxRequestCount && !isEnd) {
        const baseUrl = bilibiliApiUrls.({
          type: type2,
          oid,
          mode: mode2 ?? 3,
          pagination_str: nextPaginationStr,
          plat: plat ?? 1,
          seek_rpid,
          web_location: web_location ?? "1315875"
        });
        const wbiSignQuery = await wbi_sign(baseUrl, headers2.cookie);
        const finalUrl = baseUrl + wbiSignQuery;
        const response2 = await GlobalGetData({
          url: finalUrl,
          headers: headers2,
          ...data2
        });
        tmpresp = response2;
        const currentComments = ((_a = response2.data) == null ? void 0 : _a.replies) || [];
        fetchedComments.push(...currentComments);
        if ((_b = response2.data) == null ? void 0 : _b.cursor) {
          nextPaginationStr = (_c = response2.data.cursor.pagination_reply) == null ? void 0 : _c.next_offset;
          isEnd = response2.data.cursor.is_end;
        } else {
          isEnd = true;
        }
        requestCount++;
        if (isEnd || currentComments.length === 0 || !nextPaginationStr) {
          logger$1.info("");
          break;
        }
      }
      const finalResponse = {
        ...tmpresp,
        data: {
          ...tmpresp.data,
          // 
          replies: Array.from(new Map(fetchedComments.map((item) => [item.rpid, item])).values()).slice(0, Number(data2.number || 20))
        }
      };
      return finalResponse;
    }
    case "Emoji": {
      return await GlobalGetData({
        url: bilibiliApiUrls.(),
        ...data2
      });
    }
    case "": {
      let id = data2.ep_id ? data2.ep_id : data2.season_id;
      if (!id) {
        return false;
      }
      const idType = id ? id.startsWith("ep") ? "ep_id" : "season_id" : "ep_id";
      const newId = idType === "ep_id" ? id.replace("ep", "") : id.replace("ss", "");
      const INFO = await GlobalGetData({
        url: bilibiliApiUrls.({ [idType]: newId }),
        headers: headers2,
        ...data2
      });
      return INFO;
    }
    case "": {
      const BASEURL = bilibiliApiUrls.({ cid: data2.cid, ep_id: data2.ep_id.replace("ep", "") });
      const SIGN = await qtparam(BASEURL, headers2.cookie);
      const DATA = await GlobalGetData({
        url: bilibiliApiUrls.({ cid: data2.cid, ep_id: data2.ep_id.replace("ep", "") }) + SIGN.QUERY,
        headers: headers2,
        ...data2
      });
      return DATA;
    }
    case "": {
      delete headers2.referer;
      const { host_mid } = data2;
      const result = await GlobalGetData({
        url: bilibiliApiUrls.({ host_mid }),
        headers: headers2,
        ...data2
      });
      return result;
    }
    case "": {
      delete headers2.referer;
      const dynamicINFO = await GlobalGetData({
        url: bilibiliApiUrls.({ dynamic_id: data2.dynamic_id }),
        headers: headers2,
        ...data2
      });
      return dynamicINFO;
    }
    case "": {
      delete headers2.referer;
      const { dynamic_id } = data2;
      const dynamicINFO_CARD = await GlobalGetData({
        url: bilibiliApiUrls.({ dynamic_id }),
        headers: headers2,
        ...data2
      });
      return dynamicINFO_CARD;
    }
    case "": {
      const { host_mid } = data2;
      const result = await GlobalGetData({
        url: bilibiliApiUrls.({ host_mid }),
        headers: headers2,
        ...data2
      });
      return result;
    }
    case "": {
      const result = await GlobalGetData({
        url: bilibiliApiUrls.({ room_id: data2.room_id }),
        headers: headers2,
        ...data2
      });
      return result;
    }
    case "": {
      const result = await GlobalGetData({
        url: bilibiliApiUrls.({ room_id: data2.room_id }),
        headers: headers2,
        ...data2
      });
      return result;
    }
    case "": {
      const result = await GlobalGetData({
        url: bilibiliApiUrls.(),
        headers: headers2,
        ...data2
      });
      return result;
    }
    case "": {
      const result = await new Networks({
        url: bilibiliApiUrls.({ qrcode_key: data2.qrcode_key }),
        headers: headers2,
        ...data2
      }).getHeadersAndData();
      return result;
    }
    case "": {
      const result = await GlobalGetData({
        url: bilibiliApiUrls.(),
        headers: headers2,
        ...data2
      });
      return result;
    }
    case "UP": {
      const result = await GlobalGetData({
        url: bilibiliApiUrls.UP({ host_mid: data2.host_mid }),
        headers: headers2,
        ...data2
      });
      return result;
    }
    case "AVBV": {
      const result = av2bv(Number(data2.avid.toString().replace(/^av/i, "")));
      return {
        code: 0,
        message: "success",
        data: {
          bvid: result
        }
      };
    }
    case "BVAV": {
      const result = "av" + bv2av(data2.bvid);
      return {
        code: 0,
        message: "success",
        data: {
          aid: result
        }
      };
    }
    default:
      logger$1.warn(`B${logger$1.red(data2.methodType)}`);
      return null;
  }
};
var GlobalGetData = async (options) => {
  let warningMessage = "";
  try {
    const result = await new Networks(options).getData();
    if (!result || result === "") {
      const Err = {
        errorDescription: "Bck",
        requestType: options.methodType ?? "",
        requestUrl: options.url
      };
      warningMessage = `
      ${logger$1.yellow("Bck")}
      ${options.methodType}
      URL${options.url}
      `;
      logger$1.warn(warningMessage);
      throw {
        code: "-352",
        data: result,
        amagiError: Err
      };
    }
    if (result.code !== 0) {
      const errorMessage = bilibiliErrorCodeMap[result.code] || result.message || "";
      const Err = {
        errorDescription: `${errorMessage}`,
        requestType: options.methodType ?? "",
        requestUrl: options.url
      };
      warningMessage = `
      ${logger$1.yellow(errorMessage)}
      ${result.code}
      ${options.methodType}
      URL${options.url}
      `;
      logger$1.warn(warningMessage);
      throw {
        code: result.code,
        data: result,
        amagiError: Err
      };
    }
    return result;
  } catch (error) {
    if (error && typeof error === "object") {
      const err = error;
      return { ...err, amagiMessage: warningMessage };
    }
    return {
      code: "UNKNOWN_ERROR",
      data: error.data,
      amagiError: {
        errorDescription: "",
        requestType: options.methodType,
        requestUrl: options.url
      },
      amagiMessage: warningMessage
    };
  }
};
var bilibiliErrorCodeMap = {
  "-1": "",
  "-2": "Access Key ",
  "-3": "API ",
  "-4": " Method ",
  "-101": "",
  "-102": "",
  "-103": "",
  "-104": "",
  "-105": "",
  "-106": "",
  "-107": "",
  "-108": "",
  "-110": "",
  "-111": "csrf ",
  "-112": "",
  "-113": "",
  "-114": "",
  "-115": "",
  "-304": "",
  "-307": "",
  "-352": " (UA  wbi )",
  "-400": "",
  "-401": " ()",
  "-403": "",
  "-404": "",
  "-405": "",
  "-409": "",
  "-412": " ( ip )",
  "-500": "",
  "-503": ",",
  "-504": "",
  "-509": "",
  "-616": "",
  "-617": "",
  "-625": "",
  "-626": "",
  "-628": "",
  "-629": "",
  "-632": "",
  "-643": "",
  "-650": "",
  "-652": "",
  "-658": "Token ",
  "-662": "",
  "-688": "",
  "-689": "",
  "-701": "",
  "-799": "",
  "-8888": "~ ()"
};
var SM3 = class {
  reg;
  chunk;
  size;
  constructor() {
    this.reg = [];
    this.chunk = [];
    this.size = 0;
    this.reset();
  }
  reset() {
    this.reg[0] = 1937774191;
    this.reg[1] = 1226093241;
    this.reg[2] = 388252375;
    this.reg[3] = 3666478592;
    this.reg[4] = 2842636476;
    this.reg[5] = 372324522;
    this.reg[6] = 3817729613;
    this.reg[7] = 2969243214;
    this.chunk = [];
    this.size = 0;
  }
  write(e) {
    const a = typeof e === "string" ? this.stringToBytes(e) : e;
    this.size += a.length;
    let f = 64 - this.chunk.length;
    if (a.length < f) {
      this.chunk = this.chunk.concat(a);
    } else {
      this.chunk = this.chunk.concat(a.slice(0, f));
      while (this.chunk.length >= 64) {
        this._compress(this.chunk);
        f < a.length ? this.chunk = a.slice(f, Math.min(f + 64, a.length)) : this.chunk = [];
        f += 64;
      }
    }
  }
  sum(e, t) {
    if (e) {
      this.reset();
      this.write(e);
    }
    this._fill();
    for (let f = 0; f < this.chunk.length; f += 64) {
      this._compress(this.chunk.slice(f, f + 64));
    }
    let i = null;
    if (t === "hex") {
      i = "";
      for (let f = 0; f < 8; f++) {
        i += this.padHex(this.reg[f].toString(16), 8);
      }
    } else {
      i = new Array(32);
      for (let f = 0; f < 8; f++) {
        let c = this.reg[f];
        i[4 * f + 3] = (255 & c) >>> 0;
        c >>>= 8;
        i[4 * f + 2] = (255 & c) >>> 0;
        c >>>= 8;
        i[4 * f + 1] = (255 & c) >>> 0;
        c >>>= 8;
        i[4 * f] = (255 & c) >>> 0;
      }
    }
    this.reset();
    return i;
  }
  _compress(t) {
    if (t.length < 64) {
      console.error("compress error: not enough data");
    } else {
      for (var f = ((e) => {
        for (var r = new Array(132), t2 = 0; t2 < 16; t2++) {
          r[t2] = e[4 * t2] << 24, r[t2] |= e[4 * t2 + 1] << 16, r[t2] |= e[4 * t2 + 2] << 8, r[t2] |= e[4 * t2 + 3], r[t2] >>>= 0;
        }
        for (var n = 16; n < 68; n++) {
          let a = r[n - 16] ^ r[n - 9] ^ this.le(r[n - 3], 15);
          a = a ^ this.le(a, 15) ^ this.le(a, 23), r[n] = (a ^ this.le(r[n - 13], 7) ^ r[n - 6]) >>> 0;
        }
        for (n = 0; n < 64; n++) r[n + 68] = (r[n] ^ r[n + 4]) >>> 0;
        return r;
      })(t), i = this.reg.slice(0), c = 0; c < 64; c++) {
        let o = this.le(i[0], 12) + i[4] + this.le(this.de(c), c);
        const s = ((o = this.le(o = (4294967295 & o) >>> 0, 7)) ^ this.le(i[0], 12)) >>> 0;
        let u = this.pe(c, i[0], i[1], i[2]);
        u = (4294967295 & (u = u + i[3] + s + f[c + 68])) >>> 0;
        let b = this.he(c, i[4], i[5], i[6]);
        b = (4294967295 & (b = b + i[7] + o + f[c])) >>> 0, i[3] = i[2], i[2] = this.le(i[1], 9), i[1] = i[0], i[0] = u, i[7] = i[6], i[6] = this.le(i[5], 19), i[5] = i[4], i[4] = (b ^ this.le(b, 9) ^ this.le(b, 17)) >>> 0;
      }
      for (let l = 0; l < 8; l++) this.reg[l] = (this.reg[l] ^ i[l]) >>> 0;
    }
  }
  _fill() {
    let a = 8 * this.size;
    let f = this.chunk.push(128) % 64;
    while (64 - f < 8) {
      f -= 64;
    }
    while (f < 56) {
      this.chunk.push(0);
      f++;
    }
    for (let i = 0; i < 4; i++) {
      const c = Math.floor(a / 4294967296);
      this.chunk.push(c >>> 8 * (3 - i) & 255);
    }
    for (let i = 0; i < 4; i++) {
      this.chunk.push(a >>> 8 * (3 - i) & 255);
    }
  }
  de(e) {
    return e >= 0 && e < 16 ? 2043430169 : e >= 16 && e < 64 ? 2055708042 : (console.error("invalid j for constant Tj"), 0);
  }
  pe(e, r, t, n) {
    return e >= 0 && e < 16 ? (r ^ t ^ n) >>> 0 : e >= 16 && e < 64 ? (r & t | r & n | t & n) >>> 0 : (console.error("invalid j for bool function FF"), 0);
  }
  he(e, r, t, n) {
    return e >= 0 && e < 16 ? (r ^ t ^ n) >>> 0 : e >= 16 && e < 64 ? (r & t | ~r & n) >>> 0 : (console.error("invalid j for bool function GG"), 0);
  }
  le(e, r) {
    return (e << (r %= 32) | e >>> 32 - r) >>> 0;
  }
  stringToBytes(str) {
    const n = encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (_, r) => String.fromCharCode(parseInt(r, 16)));
    const a = new Array(n.length);
    for (let i = 0; i < n.length; i++) {
      a[i] = n.charCodeAt(i);
    }
    return a;
  }
  padHex(num, size) {
    return num.padStart(size, "0");
  }
};
function rc4_encrypt(plaintext, key) {
  const s = [];
  for (var i = 0; i < 256; i++) {
    s[i] = i;
  }
  var j = 0;
  for (var i = 0; i < 256; i++) {
    j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;
    var temp = s[i];
    s[i] = s[j];
    s[j] = temp;
  }
  var i = 0;
  var j = 0;
  const cipher = [];
  for (let k = 0; k < plaintext.length; k++) {
    i = (i + 1) % 256;
    j = (j + s[i]) % 256;
    var temp = s[i];
    s[i] = s[j];
    s[j] = temp;
    const t = (s[i] + s[j]) % 256;
    cipher.push(String.fromCharCode(s[t] ^ plaintext.charCodeAt(k)));
  }
  return cipher.join("");
}
function result_encrypt(long_str, num) {
  const s_obj = {
    s0: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    s1: "Dkdpgh4ZKsQB80/Mfvw36XI1R25+WUAlEi7NLboqYTOPuzmFjJnryx9HVGcaStCe=",
    s2: "Dkdpgh4ZKsQB80/Mfvw36XI1R25-WUAlEi7NLboqYTOPuzmFjJnryx9HVGcaStCe=",
    s3: "ckdp1h4ZKsUB80/Mfvw36XIgR25+WQAlEi7NLboqYTOPuzmFjJnryx9HVGDaStCe",
    s4: "Dkdpgh2ZmsQB80/MfvV36XI1R45-WUAlEixNLwoqYTOPuzKFjJnry79HbGcaStCe"
  };
  const constant = {
    0: 16515072,
    1: 258048,
    2: 4032,
    str: s_obj[num]
  };
  let result = "";
  let lound = 0;
  let long_int = get_long_int(lound, long_str);
  for (let i = 0; i < long_str.length / 3 * 4; i++) {
    if (Math.floor(i / 4) !== lound) {
      lound += 1;
      long_int = get_long_int(lound, long_str);
    }
    let key = i % 4;
    let temp_int;
    switch (key) {
      case 0:
        temp_int = (long_int & constant["0"]) >> 18;
        result += constant["str"].charAt(temp_int);
        break;
      case 1:
        temp_int = (long_int & constant["1"]) >> 12;
        result += constant["str"].charAt(temp_int);
        break;
      case 2:
        temp_int = (long_int & constant["2"]) >> 6;
        result += constant["str"].charAt(temp_int);
        break;
      case 3:
        temp_int = long_int & 63;
        result += constant["str"].charAt(temp_int);
        break;
    }
  }
  return result;
}
function get_long_int(round2, long_str) {
  round2 = round2 * 3;
  return long_str.charCodeAt(round2) << 16 | long_str.charCodeAt(round2 + 1) << 8 | long_str.charCodeAt(round2 + 2);
}
function gener_random(random, option) {
  return [
    random & 255 & 170 | option[0] & 85,
    // 163
    random & 255 & 85 | option[0] & 170,
    // 87
    random >> 8 & 255 & 170 | option[1] & 85,
    // 37
    random >> 8 & 255 & 85 | option[1] & 170
    // 41
  ];
}
function generate_rc4_bb_str(url_search_params, user_agent, window_env_str, suffix = "cus", Arguments = [0, 1, 14]) {
  let sm3 = new SM3();
  let start_time = Date.now();
  const url_search_params_list = sm3.sum(sm3.sum(url_search_params + suffix));
  const cus = sm3.sum(sm3.sum(suffix));
  const ua = sm3.sum(result_encrypt(rc4_encrypt(user_agent, String.fromCharCode.apply(null, [390625e-8, 1, 14])), "s3"));
  const end_time = Date.now();
  let b = {
    8: 3,
    // 
    10: end_time,
    // 3
    15: {
      aid: 6383,
      pageId: 6241
    },
    16: start_time,
    // 3
    18: 44
  };
  b[20] = b[16] >> 24 & 255;
  b[21] = b[16] >> 16 & 255;
  b[22] = b[16] >> 8 & 255;
  b[23] = b[16] & 255;
  b[24] = b[16] / 256 / 256 / 256 / 256 >> 0;
  b[25] = b[16] / 256 / 256 / 256 / 256 / 256 >> 0;
  b[26] = Arguments[0] >> 24 & 255;
  b[27] = Arguments[0] >> 16 & 255;
  b[28] = Arguments[0] >> 8 & 255;
  b[29] = Arguments[0] & 255;
  b[30] = Arguments[1] / 256 & 255;
  b[31] = Arguments[1] % 256 & 255;
  b[32] = Arguments[1] >> 24 & 255;
  b[33] = Arguments[1] >> 16 & 255;
  b[34] = Arguments[2] >> 24 & 255;
  b[35] = Arguments[2] >> 16 & 255;
  b[36] = Arguments[2] >> 8 & 255;
  b[37] = Arguments[2] & 255;
  b[38] = url_search_params_list[21];
  b[39] = url_search_params_list[22];
  b[40] = cus[21];
  b[41] = cus[22];
  b[42] = ua[23];
  b[43] = ua[24];
  b[44] = b[10] >> 24 & 255;
  b[45] = b[10] >> 16 & 255;
  b[46] = b[10] >> 8 & 255;
  b[47] = b[10] & 255;
  b[48] = b[8];
  b[49] = b[10] / 256 / 256 / 256 / 256 >> 0;
  b[50] = b[10] / 256 / 256 / 256 / 256 / 256 >> 0;
  b[51] = b[15].pageId;
  b[52] = b[15].pageId >> 24 & 255;
  b[53] = b[15].pageId >> 16 & 255;
  b[54] = b[15].pageId >> 8 & 255;
  b[55] = b[15].pageId & 255;
  b[56] = b[15].aid;
  b[57] = b[15].aid & 255;
  b[58] = b[15].aid >> 8 & 255;
  b[59] = b[15].aid >> 16 & 255;
  b[60] = b[15].aid >> 24 & 255;
  const window_env_list = [];
  for (let index2 = 0; index2 < window_env_str.length; index2++) {
    window_env_list.push(window_env_str.charCodeAt(index2));
  }
  b[64] = window_env_list.length;
  b[65] = b[64] & 255;
  b[66] = b[64] >> 8 & 255;
  b[69] = [].length;
  b[70] = b[69] & 255;
  b[71] = b[69] >> 8 & 255;
  b[72] = b[18] ^ b[20] ^ b[26] ^ b[30] ^ b[38] ^ b[40] ^ b[42] ^ b[21] ^ b[27] ^ b[31] ^ b[35] ^ b[39] ^ b[41] ^ b[43] ^ b[22] ^ b[28] ^ b[32] ^ b[36] ^ b[23] ^ b[29] ^ b[33] ^ b[37] ^ b[44] ^ b[45] ^ b[46] ^ b[47] ^ b[48] ^ b[49] ^ b[50] ^ b[24] ^ b[25] ^ b[52] ^ b[53] ^ b[54] ^ b[55] ^ b[57] ^ b[58] ^ b[59] ^ b[60] ^ b[65] ^ b[66] ^ b[70] ^ b[71];
  let bb = [
    b[18],
    b[20],
    b[52],
    b[26],
    b[30],
    b[34],
    b[58],
    b[38],
    b[40],
    b[53],
    b[42],
    b[21],
    b[27],
    b[54],
    b[55],
    b[31],
    b[35],
    b[57],
    b[39],
    b[41],
    b[43],
    b[22],
    b[28],
    b[32],
    b[60],
    b[36],
    b[23],
    b[29],
    b[33],
    b[37],
    b[44],
    b[45],
    b[59],
    b[46],
    b[47],
    b[48],
    b[49],
    b[50],
    b[24],
    b[25],
    b[65],
    b[66],
    b[70],
    b[71]
  ];
  bb = bb.concat(window_env_list).concat(b[72]);
  return rc4_encrypt(String.fromCharCode.apply(null, bb), String.fromCharCode.apply(null, [121]));
}
function generate_random_str() {
  let random_str_list = [];
  random_str_list = random_str_list.concat(gener_random(Math.random() * 1e4, [3, 45]));
  random_str_list = random_str_list.concat(gener_random(Math.random() * 1e4, [1, 0]));
  random_str_list = random_str_list.concat(gener_random(Math.random() * 1e4, [1, 5]));
  return String.fromCharCode.apply(null, random_str_list);
}
var a_bogus_default = (url, user_agent) => {
  let result_str = generate_random_str() + generate_rc4_bb_str(new URLSearchParams(new URL(url).search).toString(), user_agent, "1536|747|1536|834|0|30|0|0|1536|834|1536|864|1525|747|24|24|Win32");
  return result_encrypt(result_str, "s4") + "=";
};
var headers = {
  "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36"
};
var douyinSign = class {
  /**
   * 
   * @param length 116
   * @returns 
   */
  static Mstoken(length) {
    const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    const randomBytes = crypto$1.randomBytes(length ?? 116);
    return Array.from(randomBytes, (byte) => characters[byte % characters.length]).join("");
  }
  /**
   * a_bogus 
   * @param url 
   * @returns URL
   */
  static AB(url) {
    return a_bogus_default(url, headers["User-Agent"]);
  }
  /**  */
  static VerifyFpManager() {
    const e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");
    const t = e.length;
    const n = (/* @__PURE__ */ new Date()).getTime().toString(36);
    const r = [];
    r[8] = "_";
    r[13] = "_";
    r[18] = "_";
    r[23] = "_";
    r[14] = "4";
    for (let o, i = 0; i < 36; i++) {
      if (!r[i]) {
        o = 0 | Math.random() * t;
        r[i] = e[i === 19 ? 3 & o | 8 : o];
      }
    }
    return "verify_" + n + "_" + r.join("");
  }
};
var fp = douyinSign.VerifyFpManager();
var DouyinAPI = class {
  (data2) {
    return `https://www.douyin.com/aweme/v1/web/aweme/detail/?device_platform=webapp&aid=6383&channel=channel_pc_web&aweme_id=${data2.aweme_id}&update_version_code=170400&pc_client_type=1&version_code=190500&version_name=19.5.0&cookie_enabled=true&screen_width=2328&screen_height=1310&browser_language=zh-CN&browser_platform=Win32&browser_name=Chrome&browser_version=125.0.0.0&browser_online=true&engine_name=Blink&engine_version=125.0.0.0&os_name=Windows&os_version=10&cpu_core_num=16&device_memory=8&platform=PC&downlink=10&effective_type=4g&round_trip_time=150&webid=7351848354471872041&msToken=${douyinSign.Mstoken(
      116
    )}&verifyFp=${fp}&fp=${fp}`;
  }
  (data2) {
    return `https://www.douyin.com/aweme/v1/web/comment/list/?device_platform=webapp&aid=6383&channel=channel_pc_web&aweme_id=${data2.aweme_id}&cursor=${data2.cursor ?? 0}&count=${data2.number ?? 50}&item_type=0&insert_ids=&whale_cut_token=&cut_version=1&rcFT=&pc_client_type=1&version_code=170400&version_name=17.4.0&cookie_enabled=true&screen_width=1552&screen_height=970&browser_language=zh-CN&browser_platform=Win32&browser_name=Chrome&browser_version=125.0.0.0&browser_online=true&engine_name=Blink&engine_version=125.0.0.0&os_name=Windows&os_version=10&cpu_core_num=16&device_memory=8&platform=PC&downlink=10&effective_type=4g&msToken=${douyinSign.Mstoken(
      116
    )}&verifyFp=${fp}&fp=${fp}`;
  }
  (data2) {
    return `https://www.douyin.com/aweme/v1/web/comment/list/reply/?device_platform=webapp&aid=6383&channel=channel_pc_web&item_id=${data2.aweme_id}&comment_id=${data2.comment_id}&cut_version=1&cursor=${data2.cursor}&count=${data2.number}&item_type=0&update_version_code=170400&pc_client_type=1&pc_libra_divert=Windows&support_h265=1&support_dash=1&version_code=170400&version_name=17.4.0&cookie_enabled=true&screen_width=1552&screen_height=970&browser_language=zh-CN&browser_platform=Win32&browser_name=Edge&browser_version=132.0.0.0&browser_online=true&engine_name=Blink&engine_version=132.0.0.0&os_name=Windows&os_version=10&cpu_core_num=16&device_memory=8&platform=PC&downlink=10&effective_type=4g&round_trip_time=50&webid=7386217876267796006&verifyFp=${fp}&fp=${fp}`;
  }
  (data2) {
    return `https://www.iesdouyin.com/web/api/v2/aweme/slidesinfo/?reflow_source=reflow_page&web_id=7326472315356857893&device_id=7326472315356857893&aweme_ids=[${data2.aweme_id}]&request_source=200&msToken=${douyinSign.Mstoken(
      116
    )}&verifyFp=${fp}&fp=${fp}`;
  }
  () {
    return "https://www.douyin.com/aweme/v1/web/emoji/list";
  }
  (data2) {
    return `https://www.douyin.com/aweme/v1/web/aweme/post/?device_platform=webapp&aid=6383&channel=channel_pc_web&sec_user_id=${data2.sec_uid}&max_cursor=0&locate_query=false&show_live_replay_strategy=1&need_time_list=1&time_list_query=0&whale_cut_token=&cut_version=1&count=18&publish_video_strategy_type=2&pc_client_type=1&version_code=170400&version_name=17.4.0&cookie_enabled=true&screen_width=1552&screen_height=970&browser_language=zh-CN&browser_platform=Win32&browser_name=Chrome&browser_version=125.0.0.0&browser_online=true&engine_name=Blink&engine_version=125.0.0.0&os_name=Windows&os_version=10&cpu_core_num=16&device_memory=8&platform=PC&downlink=10&effective_type=4g&round_trip_time=50&webid=7338423850134226495&msToken=${douyinSign.Mstoken(
      116
    )}&verifyFp=${fp}&fp=${fp}`;
  }
  (data2) {
    return `https://www.douyin.com/aweme/v1/web/user/profile/other/?device_platform=webapp&aid=6383&channel=channel_pc_web&publish_video_strategy_type=2&source=channel_pc_web&sec_user_id=${data2.sec_uid}&personal_center_strategy=1&pc_client_type=1&version_code=170400&version_name=17.4.0&cookie_enabled=true&screen_width=1552&screen_height=970&browser_language=zh-CN&browser_platform=Win32&browser_name=Chrome&browser_version=125.0.0.0&browser_online=true&engine_name=Blink&engine_version=125.0.0.0&os_name=Windows&os_version=10&cpu_core_num=16&device_memory=8&platform=PC&downlink=10&effective_type=4g&round_trip_time=0&webid=7327957959955580467&msToken=${douyinSign.Mstoken(
      116
    )}&verifyFp=${fp}&fp=${fp}`;
  }
  (data2) {
    return `https://www.douyin.com/aweme/v1/web/api/suggest_words/?device_platform=webapp&aid=6383&channel=channel_pc_web&query=${data2.query}&business_id=30088&from_group_id=7129543174929812767&pc_client_type=1&version_code=170400&version_name=17.4.0&cookie_enabled=true&screen_width=1552&screen_height=970&browser_language=zh - CN&browser_platform=Win32&browser_name=Chrome&browser_version=125.0.0.0&browser_online=true&engine_name=Blink&engine_version=125.0.0.0&os_name=Windows&os_version=10&cpu_core_num=16&device_memory=8&platform=PC&downlink=10&effective_type=4g&round_trip_time=50&webid=7327957959955580467&msToken=${douyinSign.Mstoken(
      116
    )}&verifyFp=${fp}&fp=${fp}`;
  }
  (data2) {
    return `https://www.douyin.com/aweme/v1/web/general/search/single/?device_platform=webapp&aid=6383&channel=channel_pc_web&search_channel=aweme_general&sort_type=0&publish_time=0&keyword=${data2.query}&search_source=normal_search&query_correct_type=1&is_filter_search=0&from_group_id=&offset=0&count=15&pc_client_type=1&version_code=190600&version_name=19.6.0&cookie_enabled=true&screen_width=1552&screen_height=970&browser_language=zh-CN&browser_platform=Win32&browser_name=Chrome&browser_version=125.0.0.0&browser_online=true&engine_name=Blink&engine_version=125.0.0.0&os_name=Windows&os_version=10&cpu_core_num=16&device_memory=8&platform=PC&downlink=10&effective_type=4g&round_trip_time=50&webid=7338423850134226495&msToken=${douyinSign.Mstoken(
      116
    )}&verifyFp=${fp}&fp=${fp}&search_id=${data2.search_id ?? ""}&count=${data2.number ?? 10}`;
  }
  () {
    return `https://www.douyin.com/aweme/v1/web/im/strategy/config?device_platform=webapp&aid=1128&channel=channel_pc_web&publish_video_strategy_type=2&app_id=1128&scenes=[%22interactive_resources%22]&pc_client_type=1&version_code=170400&version_name=17.4.0&cookie_enabled=true&screen_width=2328&screen_height=1310&browser_language=zh-CN&browser_platform=Win32&browser_name=Chrome&browser_version=126.0.0.0&browser_online=true&engine_name=Blink&engine_version=126.0.0.0&os_name=Windows&os_version=10&cpu_core_num=16&device_memory=8&platform=PC&downlink=1.5&effective_type=4g&round_trip_time=350&webid=7347329698282833447&msToken=${douyinSign.Mstoken(
      116
    )}&verifyFp=${fp}&fp=${fp}`;
  }
  (data2) {
    return `https://www.douyin.com/aweme/v1/web/music/detail/?device_platform=webapp&aid=6383&channel=channel_pc_web&music_id=${data2.music_id}&scene=1&pc_client_type=1&version_code=170400&version_name=17.4.0&cookie_enabled=true&screen_width=2328&screen_height=1310&browser_language=zh-CN&browser_platform=Win32&browser_name=Chrome&browser_version=126.0.0.0&browser_online=true&engine_name=Blink&engine_version=126.0.0.0&os_name=Windows&os_version=10&cpu_core_num=16&device_memory=8&platform=PC&downlink=1.5&effective_type=4g&round_trip_time=350&webid=7347329698282833447&msToken=${douyinSign.Mstoken(
      116
    )}&verifyFp=${fp}&fp=${fp}`;
  }
  (data2) {
    return `https://live.douyin.com/webcast/room/web/enter/?aid=6383&app_name=douyin_web&live_id=1&device_platform=web&language=zh-CN&enter_from=web_share_link&cookie_enabled=true&screen_width=2048&screen_height=1152&browser_language=zh-CN&browser_platform=Win32&browser_name=Chrome&browser_version=125.0.0.0&web_rid=${data2.web_rid}&room_id_str=${data2.room_id}&enter_source=&is_need_double_stream=false&insert_task_id=&live_reason=&msToken=${douyinSign.Mstoken(
      116
    )}&verifyFp=${fp}&fp=${fp}`;
  }
  (data2) {
    return `https://sso.douyin.com/get_qrcode/?verifyFp=${data2.verify_fp}&fp=${data2.verify_fp}`;
  }
};
var douyinApiUrls = new DouyinAPI();
var defheaders2 = {
  accept: "*/*",
  priority: "u=0, i",
  "content-type": "application/json; charset=utf-8",
  "accept-language": "zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6",
  "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36",
  referer: "https://www.douyin.com/",
  "accept-encoding": "gzip, deflate, br",
  connection: "keep-alive"
};
var DouyinData = async (data2, cookie2) => {
  var _a, _b;
  const headers2 = {
    ...defheaders2,
    cookie: cookie2 ? cookie2.replace(/\s+/g, "") : ""
  };
  switch (data2.methodType) {
    case "":
    case "":
    case "":
    case "": {
      const url = douyinApiUrls.({ aweme_id: data2.aweme_id });
      const VideoData = await GlobalGetData2({
        url: `${url}&a_bogus=${douyinSign.AB(url)}`,
        headers: headers2,
        ...data2
      });
      return VideoData;
    }
    case "": {
      const urlGenerator = (params) => douyinApiUrls.(params);
      const response2 = await fetchPaginatedData(urlGenerator, data2, 50, headers2);
      return response2;
    }
    case "": {
      const urlGenerator = (params) => douyinApiUrls.(params);
      const response2 = await fetchPaginatedData(
        urlGenerator,
        data2,
        3,
        {
          ...headers2,
          referer: `https://www.douyin.com/note/${data2.aweme_id}`
        }
      );
      return response2;
    }
    case "": {
      const url = douyinApiUrls.({ sec_uid: data2.sec_uid });
      const UserInfoData = await GlobalGetData2({
        url: `${url}&a_bogus=${douyinSign.AB(url)}`,
        headers: {
          ...headers2,
          Referer: `https://www.douyin.com/user/${data2.sec_uid}`
        },
        ...data2
      });
      return UserInfoData;
    }
    case "Emoji": {
      const url = douyinApiUrls.();
      const EmojiData = await GlobalGetData2({
        url,
        headers: headers2,
        ...data2
      });
      return EmojiData;
    }
    case "": {
      const url = douyinApiUrls.({ sec_uid: data2.sec_uid });
      const UserVideoListData = await GlobalGetData2({
        url: `${url}&a_bogus=${douyinSign.AB(url)}`,
        headers: {
          ...headers2,
          Referer: `https://www.douyin.com/user/${data2.sec_uid}`
        },
        ...data2
      });
      return UserVideoListData;
    }
    case "": {
      const url = douyinApiUrls.({ query: data2.query, number: data2.number ?? 10 });
      const SuggestWordsData = await GlobalGetData2({
        url: `${url}&a_bogus=${douyinSign.AB(url)}`,
        headers: {
          ...headers2,
          Referer: `https://www.douyin.com/search/${encodeURIComponent(String(data2.query))}`
        },
        ...data2
      });
      return SuggestWordsData;
    }
    case "": {
      let search_id = "";
      const maxPageSize = 15;
      let fetchedSearchList = [];
      let tmpresp = {};
      while (fetchedSearchList.length < Number(data2.number ?? 10)) {
        const requestCount = Math.min(Number(data2.number ?? 50) - fetchedSearchList.length, maxPageSize);
        const url = douyinApiUrls.({
          query: data2.query,
          number: requestCount,
          search_id: search_id === "" ? void 0 : search_id
        });
        const response2 = await GlobalGetData2({
          url: `${url}&a_bogus=${douyinSign.AB(url)}`,
          headers: {
            ...headers2,
            Referer: `https://www.douyin.com/search/${encodeURIComponent(String(data2.query))}`
          },
          ...data2
        });
        if (response2.data.length === 0) {
          logger$1.warn("\nck\n" + data2.methodType);
          return false;
        }
        if (!response2.data) {
          response2.data = [];
        }
        fetchedSearchList.push(...response2.data);
        tmpresp = response2;
        search_id = response2.log_pb.impr_id;
      }
      const finalResponse = {
        ...tmpresp,
        data: data2.number === 0 ? [] : fetchedSearchList.slice(0, Number(data2.number ?? 10))
      };
      return finalResponse;
    }
    case "": {
      const url = douyinApiUrls.();
      const ExpressionPlusData = await GlobalGetData2({
        url: `${url}&a_bogus=${douyinSign.AB(url)}`,
        headers: headers2,
        ...data2
      });
      return ExpressionPlusData;
    }
    case "": {
      const url = douyinApiUrls.({ music_id: data2.music_id });
      const MusicData = await GlobalGetData2({
        url: `${url}&a_bogus=${douyinSign.AB(url)}`,
        headers: headers2,
        ...data2
      });
      return MusicData;
    }
    case "": {
      let url = douyinApiUrls.({ sec_uid: data2.sec_uid });
      const fetchUrl = `${url}&a_bogus=${douyinSign.AB(url)}`;
      const UserInfoData = await GlobalGetData2({
        url: fetchUrl,
        headers: {
          ...headers2,
          Referer: `https://www.douyin.com/user/${data2.sec_uid}`
        },
        ...data2
      });
      if (!((_a = UserInfoData == null ? void 0 : UserInfoData.user) == null ? void 0 : _a.live_status) || UserInfoData.user.live_status !== 1) {
        logger$1.error((((_b = UserInfoData == null ? void 0 : UserInfoData.user) == null ? void 0 : _b.nickname) || "") + "");
        const Err = {
          errorDescription: " TypeError: Cannot read properties of undefined (reading 'live_status')",
          requestType: data2.methodType ?? "",
          requestUrl: fetchUrl
        };
        return {
          code: "USER_NOT_LIVE",
          data: UserInfoData,
          amagiError: Err,
          amagiMessage: Err.errorDescription
        };
      }
      if (!UserInfoData.user.room_data) {
        logger$1.error("");
        return {
          code: 500,
          message: "",
          data: null
        };
      }
      const room_data = JSON.parse(UserInfoData.user.room_data);
      url = douyinApiUrls.({ room_id: UserInfoData.user.room_id_str, web_rid: room_data.owner.web_rid });
      const LiveRoomData = await GlobalGetData2({
        url: `${url}&a_bogus=${douyinSign.AB(url)}`,
        headers: {
          ...headers2,
          Referer: `https://live.douyin.com/${room_data.owner.web_rid}`
        },
        ...data2
      });
      return LiveRoomData;
    }
    case "": {
      const url = douyinApiUrls.({ verify_fp: data2.verify_fp });
      const LoginQrcodeStatusData = await GlobalGetData2({
        url: `${url}&a_bogus=${douyinSign.AB(url)}`,
        headers: headers2,
        ...data2
      });
      return LoginQrcodeStatusData;
    }
    default:
      logger$1.warn(`B${logger$1.red(data2.methodType)}`);
      return null;
  }
};
var fetchPaginatedData = async (apiUrlGenerator, params, maxPageSize, headers2) => {
  let cursor = params.cursor ?? 0;
  let fetchedData = [];
  let tmpresp = {};
  while (fetchedData.length < Number(params.number ?? maxPageSize)) {
    const requestCount = Math.min(Number(params.number ?? maxPageSize) - fetchedData.length, maxPageSize);
    const url = apiUrlGenerator({
      ...params,
      number: requestCount,
      cursor
    });
    const response2 = await GlobalGetData2({
      url: `${url}&a_bogus=${douyinSign.AB(url)}`,
      headers: headers2,
      ...params
    });
    fetchedData.push(...response2.comments || response2.data || []);
    tmpresp = response2;
    if ((response2.comments || response2.data || []).length < requestCount) {
      break;
    }
    cursor = response2.cursor;
  }
  const finalResponse = {
    ...tmpresp,
    comments: params.number === 0 ? [] : fetchedData.slice(0, Number(params.number ?? maxPageSize)),
    cursor: params.number === 0 ? 0 : fetchedData.length
  };
  return finalResponse;
};
var GlobalGetData2 = async (options) => {
  let warningMessage = "";
  try {
    const result = await new Networks(options).getData();
    if (!result || result === "") {
      const Err = {
        errorDescription: "ck",
        requestType: options.methodType ?? "",
        requestUrl: options.url
      };
      warningMessage = `
      ${logger$1.yellow("ck")}
      ${options.methodType}
      URL${options.url}
      `;
      logger$1.warn(warningMessage);
      throw {
        code: "INVALID_COOKIE",
        data: result,
        amagiError: Err
      };
    }
    if (result.filter_detail && result.filter_detail.filter_reason) {
      const filterReason = result.filter_detail.filter_reason;
      const Err = {
        errorDescription: `${filterReason}`,
        requestType: options.methodType ?? "",
        requestUrl: options.url
      };
      warningMessage = `
      ${logger$1.yellow(filterReason)}
      ${options.methodType}
      URL${options.url}
      `;
      logger$1.warn(warningMessage);
      throw {
        code: "CONTENT_FILTERED",
        data: result,
        amagiError: Err
      };
    }
    return result;
  } catch (error) {
    if (error && typeof error === "object") {
      const err = error;
      return { ...err, amagiMessage: warningMessage };
    }
    return {
      code: "UNKNOWN_ERROR",
      data: null,
      amagiError: {
        errorDescription: "",
        requestType: options.methodType,
        requestUrl: options.url
      },
      amagiMessage: warningMessage
    };
  }
};
var API = class {
  (data2) {
    return {
      /**  */
      type: "visionVideoDetail",
      /** url */
      url: "https://www.kuaishou.com/graphql",
      /**  */
      body: {
        /**  */
        operationName: "visionVideoDetail",
        variables: {
          /** ID */
          photoId: data2.photoId,
          page: "detail"
        },
        query: "query visionVideoDetail($photoId: String, $type: String, $page: String, $webPageArea: String) {\n  visionVideoDetail(photoId: $photoId, type: $type, page: $page, webPageArea: $webPageArea) {\n    status\n    type\n    author {\n      id\n      name\n      following\n      headerUrl\n      __typename\n    }\n    photo {\n      id\n      duration\n      caption\n      likeCount\n      realLikeCount\n      coverUrl\n      photoUrl\n      liked\n      timestamp\n      expTag\n      llsid\n      viewCount\n      videoRatio\n      stereoType\n      musicBlocked\n      manifest {\n        mediaType\n        businessType\n        version\n        adaptationSet {\n          id\n          duration\n          representation {\n            id\n            defaultSelect\n            backupUrl\n            codecs\n            url\n            height\n            width\n            avgBitrate\n            maxBitrate\n            m3u8Slice\n            qualityType\n            qualityLabel\n            frameRate\n            featureP2sp\n            hidden\n            disableAdaptive\n            __typename\n          }\n          __typename\n        }\n        __typename\n      }\n      manifestH265\n      photoH265Url\n      coronaCropManifest\n      coronaCropManifestH265\n      croppedPhotoH265Url\n      croppedPhotoUrl\n      videoResource\n      __typename\n    }\n    tags {\n      type\n      name\n      __typename\n    }\n    commentLimit {\n      canAddComment\n      __typename\n    }\n    llsid\n    danmakuSwitch\n    __typename\n  }\n}\n"
      }
    };
  }
  (data2) {
    return {
      type: "commentListQuery",
      url: "https://www.kuaishou.com/graphql",
      body: {
        operationName: "commentListQuery",
        variables: {
          photoId: data2.photoId,
          pcursor: ""
        },
        query: "query commentListQuery($photoId: String, $pcursor: String) {\n  visionCommentList(photoId: $photoId, pcursor: $pcursor) {\n    commentCount\n    pcursor\n    rootComments {\n      commentId\n      authorId\n      authorName\n      content\n      headurl\n      timestamp\n      likedCount\n      realLikedCount\n      liked\n      status\n      authorLiked\n      subCommentCount\n      subCommentsPcursor\n      subComments {\n        commentId\n        authorId\n        authorName\n        content\n        headurl\n        timestamp\n        likedCount\n        realLikedCount\n        liked\n        status\n        authorLiked\n        replyToUserName\n        replyTo\n        __typename\n      }\n      __typename\n    }\n    __typename\n  }\n}\n"
      }
    };
  }
  () {
    return {
      type: "visionBaseEmoticons",
      url: "https://www.kuaishou.com/graphql",
      body: {
        operationName: "visionBaseEmoticons",
        variables: {},
        query: "query visionBaseEmoticons {\n  visionBaseEmoticons {\n    iconUrls\n    __typename\n  }\n}\n"
      }
    };
  }
};
var kuaishouApiUrls = new API();
var defheaders3 = {
  referer: "https://www.kuaishou.com/new-reco",
  origin: "https://www.kuaishou.com",
  accept: "*/*",
  "content-type": "application/json",
  "accept-language": "zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6",
  "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0"
};
var KuaishouData = async (data2, cookie2) => {
  const headers2 = {
    ...defheaders3,
    cookie: cookie2 ? cookie2.replace(/\s+/g, "") : ""
  };
  switch (data2.methodType) {
    case "": {
      const body = kuaishouApiUrls.({ photoId: data2.photoId });
      const VideoData = await GlobalGetData3({
        url: body.url,
        method: "POST",
        headers: headers2,
        body: body.body,
        ...data2
      });
      return VideoData;
    }
    case "": {
      const body = kuaishouApiUrls.({ photoId: data2.photoId });
      const VideoData = await GlobalGetData3({
        url: body.url,
        method: "POST",
        headers: headers2,
        body: body.body,
        ...data2
      });
      return VideoData;
    }
    case "Emoji": {
      const body = kuaishouApiUrls.();
      const EmojiData = await GlobalGetData3({
        url: body.url,
        method: "POST",
        headers: headers2,
        body: body.body,
        ...data2
      });
      return EmojiData;
    }
    default:
      logger$1.warn(`${logger$1.red(data2.methodType)}`);
      return null;
  }
};
var GlobalGetData3 = async (options) => {
  let warningMessage = "";
  try {
    const result = await new Networks(options).getData();
    if (result === "" || !result || result.result === 2) {
      const Err = {
        errorDescription: ``,
        requestType: options.methodType ?? "",
        requestUrl: options.url,
        requestBody: JSON.stringify(options.body)
      };
      warningMessage = `
      ${logger$1.yellow("ck")}
      ${options.methodType}
      URL${options.url}
      ${JSON.stringify(options.body, null, 2)}
      `;
      logger$1.warn(warningMessage);
      throw {
        code: "INVALID_COOKIE",
        data: result,
        amagiError: Err
      };
    }
    return result;
  } catch (error) {
    if (error && typeof error === "object") {
      const err = error;
      return { ...err, amagiMessage: warningMessage };
    }
    return {
      code: "UNKNOWN_ERROR",
      data: null,
      amagiError: {
        errorDescription: "",
        requestType: options.methodType,
        requestUrl: options.url
      },
      amagiMessage: warningMessage
    };
  }
};
function smartNumber(errorMessage, minValue = 1, isInteger = false) {
  if (isInteger) {
    return coerce.number({ required_error: errorMessage }).int(`${errorMessage.replace("", "")}`).min(minValue, `${errorMessage.replace("", "")}${minValue}`);
  } else {
    return coerce.number({ required_error: errorMessage }).min(minValue, `${errorMessage.replace("", "")}${minValue}`);
  }
}
var smartPositiveInteger = (errorMessage) => {
  return smartNumber(errorMessage, 1, true);
};
var DouyinWorkParamsSchema = objectType({
  methodType: enumType(["", "", "", ""]),
  aweme_id: stringType({ required_error: "ID" }).min(1, "ID")
});
var DouyinCommentParamsSchema = objectType({
  methodType: literalType(""),
  aweme_id: stringType({ required_error: "ID" }).min(1, "ID"),
  number: smartPositiveInteger("").optional().default(50),
  cursor: coerce.number().int().min(0).default(0).optional()
});
var DouyinSearchParamsSchema = objectType({
  methodType: enumType(["", ""]),
  query: stringType({ required_error: "" }).min(1, ""),
  number: smartPositiveInteger("").optional().default(10),
  search_id: stringType().optional()
});
var DouyinCommentReplyParamsSchema = objectType({
  methodType: literalType(""),
  aweme_id: stringType({ required_error: "ID" }).min(1, "ID"),
  comment_id: stringType({ required_error: "ID" }).min(1, "ID"),
  number: smartPositiveInteger("").optional().default(5),
  cursor: coerce.number().int().min(0).default(0).optional()
});
var DouyinUserParamsSchema = objectType({
  methodType: enumType(["", "", ""]),
  sec_uid: stringType({ required_error: "ID" }).min(1, "ID")
});
var DouyinMusicParamsSchema = objectType({
  methodType: literalType(""),
  music_id: stringType({ required_error: "ID" }).min(1, "ID")
});
var DouyinQrcodeParamsSchema = objectType({
  methodType: literalType(""),
  verify_fp: stringType({ required_error: "fp" }).min(1, "fp")
});
var DouyinEmojiListParamsSchema = objectType({
  methodType: literalType("Emoji")
});
var DouyinEmojiProParamsSchema = objectType({
  methodType: literalType("")
});
var DouyinValidationSchemas2 = {
  "": DouyinWorkParamsSchema,
  "": DouyinWorkParamsSchema,
  "": DouyinWorkParamsSchema,
  "": DouyinWorkParamsSchema,
  "": DouyinCommentParamsSchema,
  "": DouyinUserParamsSchema,
  "": DouyinUserParamsSchema,
  "": DouyinSearchParamsSchema,
  "": DouyinSearchParamsSchema,
  "": DouyinMusicParamsSchema,
  "": DouyinUserParamsSchema,
  "": DouyinQrcodeParamsSchema,
  "Emoji": DouyinEmojiListParamsSchema,
  "": DouyinEmojiProParamsSchema,
  "": DouyinCommentReplyParamsSchema
};
var BilibiliVideoParamsSchema = objectType({
  methodType: literalType(""),
  bvid: stringType({ required_error: "BVID" }).min(1, "BVID")
});
var BilibiliVideoDownloadParamsSchema = objectType({
  methodType: literalType(""),
  avid: smartNumber("AVID", 1, true),
  cid: smartNumber("CID", 1, true)
});
var BilibiliCommentParamsSchema = objectType({
  methodType: literalType(""),
  oid: stringType({ required_error: "OID" }).min(1, "OID"),
  type: smartNumber("", 1, true).refine(
    (val) => [1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 33].includes(val),
    { message: "" }
  ),
  number: coerce.number().int().positive().default(20).optional(),
  pn: coerce.number().int().positive().default(1).optional()
});
var BilibiliUserParamsSchema = objectType({
  methodType: enumType(["", "", "UP"]),
  host_mid: smartNumber("UPUID", 1, true)
});
var BilibiliEmojiParamsSchema = objectType({
  methodType: literalType("Emoji")
});
var BilibiliBangumiInfoParamsSchema = objectType({
  methodType: literalType(""),
  ep_id: stringType().min(1, "EP ID").optional(),
  season_id: stringType().optional()
}).refine(
  (data2) => data2.ep_id || data2.season_id,
  {
    message: "ep_id  season_id ",
    path: ["ep_id"]
  }
);
var BilibiliBangumiStreamParamsSchema = objectType({
  methodType: literalType(""),
  cid: smartNumber("CID", 1, true),
  ep_id: stringType({ required_error: "EP ID" }).min(1, "EP ID")
});
var BilibiliDynamicParamsSchema = objectType({
  methodType: enumType(["", ""]),
  dynamic_id: stringType({ required_error: "ID" }).min(1, "ID")
});
var BilibiliLiveParamsSchema = objectType({
  methodType: enumType(["", ""]),
  room_id: stringType({ required_error: "ID" }).min(1, "ID")
});
var BilibiliLoginParamsSchema = objectType({
  methodType: literalType("")
});
var BilibiliQrcodeParamsSchema = objectType({
  methodType: literalType("")
});
var BilibiliQrcodeStatusParamsSchema = objectType({
  methodType: literalType(""),
  qrcode_key: stringType({ required_error: "key" }).min(1, "key")
});
var BilibiliAv2BvParamsSchema = objectType({
  methodType: literalType("AVBV"),
  avid: coerce.number({ required_error: "AVID" }).int().positive()
});
var BilibiliBv2AvParamsSchema = objectType({
  methodType: literalType("BVAV"),
  bvid: stringType({ required_error: "BVID" }).min(1, "BVID")
});
var BilibiliValidationSchemas2 = {
  "": BilibiliVideoParamsSchema,
  "": BilibiliVideoDownloadParamsSchema,
  "": BilibiliCommentParamsSchema,
  "": BilibiliUserParamsSchema,
  "": BilibiliUserParamsSchema,
  "Emoji": BilibiliEmojiParamsSchema,
  "": BilibiliBangumiInfoParamsSchema,
  "": BilibiliBangumiStreamParamsSchema,
  "": BilibiliDynamicParamsSchema,
  "": BilibiliDynamicParamsSchema,
  "": BilibiliLiveParamsSchema,
  "": BilibiliLiveParamsSchema,
  "": BilibiliLoginParamsSchema,
  "": BilibiliQrcodeParamsSchema,
  "": BilibiliQrcodeStatusParamsSchema,
  "UP": BilibiliUserParamsSchema,
  "AVBV": BilibiliAv2BvParamsSchema,
  "BVAV": BilibiliBv2AvParamsSchema
};
var KuaishouVideoParamsSchema = objectType({
  methodType: literalType(""),
  photoId: stringType({ required_error: "ID" }).min(1, "ID")
});
var KuaishouCommentParamsSchema = objectType({
  methodType: literalType(""),
  photoId: stringType({ required_error: "ID" }).min(1, "ID")
});
var KuaishouEmojiParamsSchema = objectType({
  methodType: literalType("Emoji")
});
var KuaishouValidationSchemas2 = {
  "": KuaishouVideoParamsSchema,
  "": KuaishouCommentParamsSchema,
  "Emoji": KuaishouEmojiParamsSchema
};
var validateDouyinParams = (methodType, params) => {
  const schema = DouyinValidationSchemas2[methodType];
  const validated = schema.parse(
    typeof params === "object" && params !== null ? { methodType, ...params } : { methodType, params }
  );
  return validated;
};
var validateBilibiliParams = (methodType, params) => {
  const schema = BilibiliValidationSchemas2[methodType];
  const validated = schema.parse(
    typeof params === "object" && params !== null ? { methodType, ...params } : { methodType, params }
  );
  return validated;
};
var validateKuaishouParams = (methodType, params) => {
  const schema = KuaishouValidationSchemas2[methodType];
  const validated = schema.parse(
    typeof params === "object" && params !== null ? { methodType, ...params } : { methodType, params }
  );
  return validated;
};
var createSuccessResponse = (data2, message, code = 200) => {
  return {
    success: true,
    data: data2,
    message,
    code,
    error: void 0
  };
};
var createErrorResponse = (error, message, code = 500) => {
  return {
    success: false,
    error,
    message,
    code,
    data: void 0
  };
};
async function getDouyinData(methodType, optionsOrCookie, cookieOrOptions) {
  try {
    let options;
    let cookie2;
    if (typeof optionsOrCookie === "string") {
      cookie2 = optionsOrCookie;
      options = cookieOrOptions;
    } else {
      options = optionsOrCookie;
      cookie2 = cookieOrOptions;
    }
    const { typeMode: _, ...validationOptions } = options || {};
    const validatedParams = validateDouyinParams(methodType, validationOptions);
    const apiParams = {
      ...validatedParams
    };
    const rawData = await DouyinData(apiParams, cookie2);
    if (rawData.data === "") {
      return createErrorResponse(rawData.amagiError, "");
    }
    return createSuccessResponse(rawData, "", 200);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "";
    throw new Error(`: ${errorMessage}`);
  }
}
async function getBilibiliData(methodType, optionsOrCookie, cookieOrOptions) {
  try {
    let options;
    let cookie2;
    if (typeof optionsOrCookie === "string") {
      cookie2 = optionsOrCookie;
      options = cookieOrOptions;
    } else {
      options = optionsOrCookie;
      cookie2 = cookieOrOptions;
    }
    const { typeMode: _, ...validationOptions } = options || {};
    const validatedParams = validateBilibiliParams(methodType, validationOptions);
    const apiParams = {
      ...validatedParams
    };
    const rawData = await fetchBilibili(apiParams, cookie2);
    if (rawData.code !== 0) {
      return createErrorResponse(rawData.amagiError, "B");
    }
    return createSuccessResponse(rawData, "", 200);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "";
    throw new Error(`B: ${errorMessage}`);
  }
}
async function getKuaishouData(methodType, optionsOrCookie, cookieOrOptions) {
  try {
    let options;
    let cookie2;
    if (typeof optionsOrCookie === "string") {
      cookie2 = optionsOrCookie;
      options = cookieOrOptions;
    } else {
      options = optionsOrCookie;
      cookie2 = cookieOrOptions;
    }
    const { typeMode: _, ...validationOptions } = options || {};
    const validatedParams = validateKuaishouParams(methodType, validationOptions);
    const apiParams = {
      ...validatedParams
    };
    const rawData = await KuaishouData(apiParams, cookie2);
    if (rawData.code && Object.values(kuaishouAPIErrorCode).includes(rawData.code)) {
      return createErrorResponse(rawData.amagiError, "");
    }
    return createSuccessResponse(rawData, "", 200);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "";
    throw new Error(`: ${errorMessage}`);
  }
}
var createBilibiliApiMethod = (methodType) => {
  return async (options, cookie2) => {
    return await getBilibiliData(methodType, options, cookie2);
  };
};
var createBoundBilibiliApiMethod = (methodType, cookie2) => {
  return async (options) => {
    return await getBilibiliData(methodType, options, cookie2);
  };
};
var bilibili = {
  /**
   * 
   * @param options  bvid  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getVideoInfo: createBilibiliApiMethod(""),
  /**
   * 
   * @param options  avid, cid  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getVideoStream: createBilibiliApiMethod(""),
  /**
   * 
   * @param options  type, oid,  number, pn  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getComments: createBilibiliApiMethod(""),
  /**
   * 
   * @param options  host_mid  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getUserProfile: createBilibiliApiMethod(""),
  /**
   * 
   * @param options  host_mid  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getUserDynamic: createBilibiliApiMethod(""),
  /**
   *  Emoji 
   * @param options  ( typeMode)
   * @param cookie  Cookie
   * @returns API
   */
  getEmojiList: createBilibiliApiMethod("Emoji"),
  /**
   * 
   * @param options  season_id, ep_id  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getBangumiInfo: createBilibiliApiMethod(""),
  /**
   * 
   * @param options  cid, ep_id  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getBangumiStream: createBilibiliApiMethod(""),
  /**
   * 
   * @param options  dynamic_id  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getDynamicInfo: createBilibiliApiMethod(""),
  /**
   * 
   * @param options  dynamic_id  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getDynamicCard: createBilibiliApiMethod(""),
  /**
   * 
   * @param options  room_id  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getLiveRoomDetail: createBilibiliApiMethod(""),
  /**
   * 
   * @param options  room_id  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getLiveRoomInitInfo: createBilibiliApiMethod(""),
  /**
   * 
   * @param options  ( typeMode)
   * @param cookie  Cookie
   * @returns API
   */
  getLoginBasicInfo: createBilibiliApiMethod(""),
  /**
   * 
   * @param options  ( typeMode)
   * @param cookie  Cookie
   * @returns API
   */
  getLoginQrcode: createBilibiliApiMethod(""),
  /**
   * 
   * @param options  qrcode_key  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  checkQrcodeStatus: createBilibiliApiMethod(""),
  /**
   *  UP 
   * @param options  host_mid  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getUserTotalPlayCount: createBilibiliApiMethod("UP"),
  /**
   *  AV  BV 
   * @param options  avid  typeMode
   * @param cookie  Cookie ()
   * @returns API
   */
  convertAvToBv: createBilibiliApiMethod("AVBV"),
  /**
   *  BV  AV 
   * @param options  bvid  typeMode
   * @param cookie  Cookie ()
   * @returns API
   */
  convertBvToAv: createBilibiliApiMethod("BVAV")
};
var createBoundBilibiliApi = (cookie2) => {
  return {
    /**
     * 
     * @param options  bvid  typeMode
     * @returns API
     */
    getVideoInfo: createBoundBilibiliApiMethod("", cookie2),
    /**
     * 
     * @param options  avid, cid  typeMode
     * @returns API
     */
    getVideoStream: createBoundBilibiliApiMethod("", cookie2),
    /**
     * 
     * @param options  type, oid,  number, pn  typeMode
     * @returns API
     */
    getComments: createBoundBilibiliApiMethod("", cookie2),
    /**
     * 
     * @param options  host_mid  typeMode
     * @returns API
     */
    getUserProfile: createBoundBilibiliApiMethod("", cookie2),
    /**
     * 
     * @param options  host_mid  typeMode
     * @returns API
     */
    getUserDynamic: createBoundBilibiliApiMethod("", cookie2),
    /**
     *  Emoji 
     * @param options  ( typeMode)
     * @returns API
     */
    getEmojiList: createBoundBilibiliApiMethod("Emoji", cookie2),
    /**
     * 
     * @param options  season_id, ep_id  typeMode
     * @returns API
     */
    getBangumiInfo: createBoundBilibiliApiMethod("", cookie2),
    /**
     * 
     * @param options  cid, ep_id  typeMode
     * @returns API
     */
    getBangumiStream: createBoundBilibiliApiMethod("", cookie2),
    /**
     * 
     * @param options  dynamic_id  typeMode
     * @returns API
     */
    getDynamicInfo: createBoundBilibiliApiMethod("", cookie2),
    /**
     * 
     * @param options  dynamic_id  typeMode
     * @returns API
     */
    getDynamicCard: createBoundBilibiliApiMethod("", cookie2),
    /**
     * 
     * @param options  room_id  typeMode
     * @returns API
     */
    getLiveRoomDetail: createBoundBilibiliApiMethod("", cookie2),
    /**
     * 
     * @param options  room_id  typeMode
     * @returns API
     */
    getLiveRoomInitInfo: createBoundBilibiliApiMethod("", cookie2),
    /**
     * 
     * @param options  ( typeMode)
     * @returns API
     */
    getLoginBasicInfo: createBoundBilibiliApiMethod("", cookie2),
    /**
     * 
     * @param options  ( typeMode)
     * @returns API
     */
    getLoginQrcode: createBoundBilibiliApiMethod("", cookie2),
    /**
     * 
     * @param options  qrcode_key  typeMode
     * @returns API
     */
    checkQrcodeStatus: createBoundBilibiliApiMethod("", cookie2),
    /**
     *  UP 
     * @param options  host_mid  typeMode
     * @returns API
     */
    getUserTotalPlayCount: createBoundBilibiliApiMethod("UP", cookie2),
    /**
     *  AV  BV 
     * @param options  avid  typeMode
     * @returns API
     */
    convertAvToBv: createBoundBilibiliApiMethod("AVBV", cookie2),
    /**
     *  BV  AV 
     * @param options  bvid  typeMode
     * @returns API
     */
    convertBvToAv: createBoundBilibiliApiMethod("BVAV", cookie2)
  };
};
var ApiError = class extends Error {
  code;
  platform;
  /**
   * API
   * @param message - 
   * @param code - 
   * @param platform - 
   */
  constructor(message, code = 500, platform2 = "unknown") {
    super(message);
    this.name = "ApiError";
    this.code = code;
    this.platform = platform2;
  }
};
var ValidationError = class _ValidationError extends Error {
  errors;
  requestPath;
  /**
   * 
   * @param message - 
   * @param errors - 
   * @param requestPath - HTTP
   */
  constructor(message, errors2, requestPath) {
    super(message);
    this.name = "ValidationError";
    this.errors = errors2;
    this.requestPath = requestPath;
  }
  /**
   * Zod
   * @param zodError - Zod
   * @param requestPath - HTTP
   * @returns 
   */
  static fromZodError(zodError, requestPath) {
    const errors2 = zodError.errors.map((err) => ({
      field: err.path.join("."),
      message: err.message
    }));
    return new _ValidationError("", errors2, requestPath);
  }
};
var handleError = (error, requestPath) => {
  if (error instanceof ValidationError) {
    return {
      code: 400,
      message: error.message,
      data: null,
      errors: error.errors,
      requestPath: error.requestPath || requestPath
    };
  }
  if (error instanceof ApiError) {
    return {
      code: error.code,
      message: error.message,
      data: null,
      platform: error.platform,
      requestPath
    };
  }
  if (error instanceof ZodError) {
    const validationError = ValidationError.fromZodError(error, requestPath);
    return handleError(validationError, requestPath);
  }
  const errorMessage = error instanceof Error ? error.message : "";
  return {
    code: 500,
    message: errorMessage,
    data: null,
    requestPath
  };
};
var createValidationMiddleware = (validateFn, methodType) => {
  return (req, res, next) => {
    try {
      const params = { ...req.query, ...req.body };
      const validatedParams = validateFn(methodType, params);
      req.validatedParams = validatedParams;
      next();
    } catch (error) {
      const errorResponse = handleError(error, req.originalUrl);
      res.status(errorResponse.code || 500).json(errorResponse);
    }
  };
};
var createDouyinValidationMiddleware = (methodType) => createValidationMiddleware(validateDouyinParams, methodType);
var createBilibiliValidationMiddleware = (methodType) => createValidationMiddleware(validateBilibiliParams, methodType);
var createKuaishouValidationMiddleware = (methodType) => createValidationMiddleware(validateKuaishouParams, methodType);
var createBilibiliRouteHandler = (dataFetcher, methodType, cookie2) => {
  return async (req, res) => {
    try {
      const result = await dataFetcher(methodType, req.validatedParams, cookie2);
      res.json({
        ...result,
        requestPath: req.originalUrl
      });
    } catch (error) {
      const errorResponse = handleError(error);
      res.status(errorResponse.code || 500).json({
        ...errorResponse,
        requestPath: req.originalUrl
      });
    }
  };
};
var createBilibiliRoutes = (cookie2) => {
  const router2 = Router();
  router2.get(
    "/fetch_one_video",
    createBilibiliValidationMiddleware(""),
    createBilibiliRouteHandler(getBilibiliData, "", cookie2)
  );
  router2.get(
    "/fetch_video_playurl",
    createBilibiliValidationMiddleware(""),
    createBilibiliRouteHandler(getBilibiliData, "", cookie2)
  );
  router2.get(
    "/fetch_work_comments",
    createBilibiliValidationMiddleware(""),
    createBilibiliRouteHandler(getBilibiliData, "", cookie2)
  );
  router2.get(
    "/fetch_user_profile",
    createBilibiliValidationMiddleware(""),
    createBilibiliRouteHandler(getBilibiliData, "", cookie2)
  );
  router2.get(
    "/fetch_user_dynamic",
    createBilibiliValidationMiddleware(""),
    createBilibiliRouteHandler(getBilibiliData, "", cookie2)
  );
  router2.get(
    "/fetch_emoji_list",
    createBilibiliValidationMiddleware("Emoji"),
    createBilibiliRouteHandler(getBilibiliData, "Emoji", cookie2)
  );
  router2.get(
    "/fetch_bangumi_video_info",
    createBilibiliValidationMiddleware(""),
    createBilibiliRouteHandler(getBilibiliData, "", cookie2)
  );
  router2.get(
    "/fetch_bangumi_video_playurl",
    createBilibiliValidationMiddleware(""),
    createBilibiliRouteHandler(getBilibiliData, "", cookie2)
  );
  router2.get(
    "/fetch_dynamic_info",
    createBilibiliValidationMiddleware(""),
    createBilibiliRouteHandler(getBilibiliData, "", cookie2)
  );
  router2.get(
    "/fetch_dynamic_card",
    createBilibiliValidationMiddleware(""),
    createBilibiliRouteHandler(getBilibiliData, "", cookie2)
  );
  router2.get(
    "/fetch_live_room_detail",
    createBilibiliValidationMiddleware(""),
    createBilibiliRouteHandler(getBilibiliData, "", cookie2)
  );
  router2.get(
    "/fetch_liveroom_def",
    createBilibiliValidationMiddleware(""),
    createBilibiliRouteHandler(getBilibiliData, "", cookie2)
  );
  router2.get(
    "/login_basic_info",
    createBilibiliValidationMiddleware(""),
    createBilibiliRouteHandler(getBilibiliData, "", cookie2)
  );
  router2.get(
    "/new_login_qrcode",
    createBilibiliValidationMiddleware(""),
    createBilibiliRouteHandler(getBilibiliData, "", cookie2)
  );
  router2.get(
    "/check_qrcode",
    createBilibiliValidationMiddleware(""),
    createBilibiliRouteHandler(getBilibiliData, "", cookie2)
  );
  router2.get(
    "/fetch_user_full_view",
    createBilibiliValidationMiddleware("UP"),
    createBilibiliRouteHandler(getBilibiliData, "UP", cookie2)
  );
  router2.get(
    "/av_to_bv",
    createBilibiliValidationMiddleware("AVBV"),
    createBilibiliRouteHandler(getBilibiliData, "AVBV", cookie2)
  );
  router2.get(
    "/bv_to_av",
    createBilibiliValidationMiddleware("BVAV"),
    createBilibiliRouteHandler(getBilibiliData, "BVAV", cookie2)
  );
  return router2;
};
var bilibiliUtils = {
  sign: {
    wbi_sign,
    av2bv,
    bv2av
  },
  bilibiliApiUrls,
  api: bilibili
};
var createDouyinApiMethod = (methodType) => {
  return async (options, cookie2) => {
    return await getDouyinData(methodType, options, cookie2);
  };
};
var createBoundDouyinApiMethod = (methodType, cookie2) => {
  return async (options) => {
    return await getDouyinData(methodType, options, cookie2);
  };
};
var douyin = {
  /**
   *  (//)
   * @param options  aweme_id  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getWorkInfo: createDouyinApiMethod(""),
  /**
   * 
   * @param options  aweme_id  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getVideoWorkInfo: createDouyinApiMethod(""),
  /**
   * 
   * @param options  aweme_id  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getImageAlbumWorkInfo: createDouyinApiMethod(""),
  /**
   * 
   * @param options  aweme_id  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getSlidesWorkInfo: createDouyinApiMethod(""),
  /**
   * 
   * @param options  aweme_id,  number, cursor  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getComments: createDouyinApiMethod(""),
  /**
   * 
   * @param options  aweme_id, comment_id,  number, cursor  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getCommentReplies: createDouyinApiMethod(""),
  /**
   * 
   * @param options  sec_uid  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getUserProfile: createDouyinApiMethod(""),
  /**
   *  Emoji 
   * @param options  ( typeMode)
   * @param cookie  Cookie
   * @returns APIEmoji
   */
  getEmojiList: createDouyinApiMethod("Emoji"),
  /**
   * 
   * @param options  ( typeMode)
   * @param cookie  Cookie
   * @returns API
   */
  getEmojiProList: createDouyinApiMethod(""),
  /**
   * 
   * @param options  sec_uid,  number, max_cursor  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getUserVideos: createDouyinApiMethod(""),
  /**
   * 
   * @param options  music_id  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getMusicInfo: createDouyinApiMethod(""),
  /**
   * 
   * @param options  query,  number  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getSuggestWords: createDouyinApiMethod(""),
  /**
   * 
   * @param options  query,  number, search_id, cursor  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  search: createDouyinApiMethod(""),
  /**
   * 
   * @param options  sec_uid  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getLiveRoomInfo: createDouyinApiMethod("")
};
var createBoundDouyinApi = (cookie2) => {
  return {
    /**
     *  (//)
     * @param options  aweme_id  typeMode
     * @returns API
     */
    getWorkInfo: createBoundDouyinApiMethod("", cookie2),
    /**
     * 
     * @param options  aweme_id  typeMode
     * @returns API
     */
    getVideoWorkInfo: createBoundDouyinApiMethod("", cookie2),
    /**
     * 
     * @param options  aweme_id  typeMode
     * @returns API
     */
    getImageAlbumWorkInfo: createBoundDouyinApiMethod("", cookie2),
    /**
     * 
     * @param options  aweme_id  typeMode
     * @returns API
     */
    getSlidesWorkInfo: createBoundDouyinApiMethod("", cookie2),
    /**
     * 
     * @param options  aweme_id,  number, cursor  typeMode
     * @returns API
     */
    getComments: createBoundDouyinApiMethod("", cookie2),
    /**
     * 
     * @param options  aweme_id, comment_id,  number, cursor  typeMode
     * @returns API
     */
    getCommentReplies: createBoundDouyinApiMethod("", cookie2),
    /**
     * 
     * @param options  sec_uid  typeMode
     * @returns API
     */
    getUserProfile: createBoundDouyinApiMethod("", cookie2),
    /**
     *  Emoji 
     * @param options  ( typeMode)
     * @returns APIEmoji
     */
    getEmojiList: createBoundDouyinApiMethod("Emoji", cookie2),
    /**
     * 
     * @param options  ( typeMode)
     * @returns API
     */
    getEmojiProList: createBoundDouyinApiMethod("", cookie2),
    /**
     * 
     * @param options  sec_uid,  number, max_cursor  typeMode
     * @returns API
     */
    getUserVideos: createBoundDouyinApiMethod("", cookie2),
    /**
     * 
     * @param options  music_id  typeMode
     * @returns API
     */
    getMusicInfo: createBoundDouyinApiMethod("", cookie2),
    /**
     * 
     * @param options  query,  number  typeMode
     * @returns API
     */
    getSuggestWords: createBoundDouyinApiMethod("", cookie2),
    /**
     * 
     * @param options  query,  number, search_id, cursor  typeMode
     * @returns API
     */
    search: createBoundDouyinApiMethod("", cookie2),
    /**
     * 
     * @param options  sec_uid  typeMode
     * @returns API
     */
    getLiveRoomInfo: createBoundDouyinApiMethod("", cookie2)
  };
};
var createDouyinRouteHandler = (dataFetcher, methodType, cookie2) => {
  return async (req, res) => {
    try {
      const result = await dataFetcher(methodType, req.validatedParams, cookie2);
      res.json({
        ...result,
        requestPath: req.originalUrl
      });
    } catch (error) {
      const errorResponse = handleError(error);
      res.status(errorResponse.code || 500).json({
        ...errorResponse,
        requestPath: req.originalUrl
      });
    }
  };
};
var createDouyinRoutes = (cookie2) => {
  const router2 = Router();
  router2.get(
    "/fetch_one_work",
    createDouyinValidationMiddleware(""),
    createDouyinRouteHandler(getDouyinData, "", cookie2)
  );
  router2.get(
    "/fetch_one_work",
    createDouyinValidationMiddleware(""),
    createDouyinRouteHandler(getDouyinData, "", cookie2)
  );
  router2.get(
    "/fetch_one_work",
    createDouyinValidationMiddleware(""),
    createDouyinRouteHandler(getDouyinData, "", cookie2)
  );
  router2.get(
    "/fetch_one_work",
    createDouyinValidationMiddleware(""),
    createDouyinRouteHandler(getDouyinData, "", cookie2)
  );
  router2.get(
    "/fetch_work_comments",
    createDouyinValidationMiddleware(""),
    createDouyinRouteHandler(getDouyinData, "", cookie2)
  );
  router2.get(
    "/fetch_user_info",
    createDouyinValidationMiddleware(""),
    createDouyinRouteHandler(getDouyinData, "", cookie2)
  );
  router2.get(
    "/fetch_user_post_videos",
    createDouyinValidationMiddleware(""),
    createDouyinRouteHandler(getDouyinData, "", cookie2)
  );
  router2.get(
    "/fetch_search_info",
    createDouyinValidationMiddleware(""),
    createDouyinRouteHandler(getDouyinData, "", cookie2)
  );
  router2.get(
    "/fetch_suggest_words",
    createDouyinValidationMiddleware(""),
    createDouyinRouteHandler(getDouyinData, "", cookie2)
  );
  router2.get(
    "/fetch_music_work",
    createDouyinValidationMiddleware(""),
    createDouyinRouteHandler(getDouyinData, "", cookie2)
  );
  router2.get(
    "/fetch_emoji_list",
    createDouyinValidationMiddleware("Emoji"),
    createDouyinRouteHandler(getDouyinData, "Emoji", cookie2)
  );
  router2.get(
    "/fetch_emoji_pro_list",
    createDouyinValidationMiddleware(""),
    createDouyinRouteHandler(getDouyinData, "", cookie2)
  );
  router2.get(
    "/fetch_user_live_videos",
    createDouyinValidationMiddleware(""),
    createDouyinRouteHandler(getDouyinData, "", cookie2)
  );
  router2.get(
    "/fetch_video_comment_replies",
    createDouyinValidationMiddleware(""),
    createDouyinRouteHandler(getDouyinData, "", cookie2)
  );
  return router2;
};
var douyinUtils = {
  sign: douyinSign,
  douyinApiUrls,
  api: douyin
};
var createKuaishouRouteHandler = (dataFetcher, methodType, cookie2) => {
  return async (req, res) => {
    try {
      const result = await dataFetcher(methodType, req.validatedParams, cookie2);
      res.json({
        ...result,
        requestPath: req.originalUrl
      });
    } catch (error) {
      const errorResponse = handleError(error);
      res.status(errorResponse.code || 500).json({
        ...errorResponse,
        requestPath: req.originalUrl
      });
    }
  };
};
var createKuaishouRoutes = (cookie2) => {
  const router2 = Router();
  router2.get(
    "/fetch_one_work",
    createKuaishouValidationMiddleware(""),
    createKuaishouRouteHandler(getKuaishouData, "", cookie2)
  );
  router2.get(
    "/fetch_work_comments",
    createKuaishouValidationMiddleware(""),
    createKuaishouRouteHandler(getKuaishouData, "", cookie2)
  );
  router2.get(
    "/fetch_emoji_list",
    createKuaishouValidationMiddleware("Emoji"),
    createKuaishouRouteHandler(getKuaishouData, "Emoji", cookie2)
  );
  return router2;
};
var createKuaishouApiMethod = (methodType) => {
  return async (options, cookie2) => {
    return await getKuaishouData(methodType, options, cookie2);
  };
};
var createBoundKuaishouApiMethod = (methodType, cookie2) => {
  return async (options) => {
    return await getKuaishouData(methodType, options, cookie2);
  };
};
var kuaishou = {
  /**
   * 
   * @param options  photoId  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getWorkInfo: createKuaishouApiMethod(""),
  /**
   * 
   * @param options  photoId  typeMode
   * @param cookie  Cookie
   * @returns API
   */
  getComments: createKuaishouApiMethod(""),
  /**
   *  Emoji 
   * @param options  ( typeMode)
   * @param cookie  Cookie
   * @returns API
   */
  getEmojiList: createKuaishouApiMethod("Emoji")
};
var createBoundKuaishouApi = (cookie2) => {
  return {
    /**
     * 
     * @param options  photoId  typeMode
     * @returns API
     */
    getWorkInfo: createBoundKuaishouApiMethod("", cookie2),
    /**
     * 
     * @param options  photoId  typeMode
     * @returns API
     */
    getComments: createBoundKuaishouApiMethod("", cookie2),
    /**
     *  Emoji 
     * @param options  ( typeMode)
     * @returns API
     */
    getEmojiList: createBoundKuaishouApiMethod("Emoji", cookie2)
  };
};
var kuaishouUtils = {
  kuaishouApiUrls,
  api: kuaishou
};
var createAmagiClient = (options) => {
  const douyinCookie = (options == null ? void 0 : options.douyin) ?? "";
  const bilibiliCookie = (options == null ? void 0 : options.bilibili) ?? "";
  const kuaishouCookie = (options == null ? void 0 : options.kuaishou) ?? "";
  const startServer = (port = 4567) => {
    const app$12 = app();
    app$12.use(app.json());
    app$12.use(app.urlencoded({ extended: true }));
    app$12.get("/", (_req, res) => {
      res.redirect(301, "https://amagi.apifox.cn");
    });
    app$12.get("/docs", (_req, res) => {
      res.redirect(301, "https://amagi.apifox.cn");
    });
    app$12.use("/api/douyin", createDouyinRoutes(douyinCookie));
    app$12.use("/api/bilibili", createBilibiliRoutes(bilibiliCookie));
    app$12.use("/api/kuaishou", createKuaishouRoutes(kuaishouCookie));
    app$12.listen(port, "::", () => {
      logger$1.mark(`Amagi server listening on ${logger$1.green(`http://localhost:${port}`)} ${logger$1.yellow("API docs: https://amagi.apifox.cn ")}`);
    });
    return app$12;
  };
  const startClient = (port = 4567) => {
    return startServer(port);
  };
  const getDouyinDataWithCookie = async (methodType, options2) => {
    return await getDouyinData(methodType, options2, douyinCookie);
  };
  const getBilibiliDataWithCookie = async (methodType, options2) => {
    return await getBilibiliData(methodType, options2, bilibiliCookie);
  };
  const getKuaishouDataWithCookie = async (methodType, options2) => {
    return await getKuaishouData(methodType, options2, kuaishouCookie);
  };
  return {
    /** HTTP */
    startServer,
    /** @deprecated  startServer  */
    startClient,
    getDouyinData: getDouyinDataWithCookie,
    getBilibiliData: getBilibiliDataWithCookie,
    getKuaishouData: getKuaishouDataWithCookie,
    douyin: {
      ...douyinUtils,
      /** cookieAPIcookie */
      api: createBoundDouyinApi(douyinCookie)
    },
    bilibili: {
      ...bilibiliUtils,
      /** cookieBAPIcookie */
      api: createBoundBilibiliApi(bilibiliCookie)
    },
    kuaishou: {
      ...kuaishouUtils,
      /** cookieAPIcookie */
      api: createBoundKuaishouApi(kuaishouCookie)
    }
  };
};
function CreateAmagiApp(options = {}) {
  if (!(this instanceof CreateAmagiApp)) {
    return createAmagiClient(options);
  }
  return createAmagiClient(options);
}
CreateAmagiApp.douyin = douyinUtils;
CreateAmagiApp.bilibili = bilibiliUtils;
CreateAmagiApp.kuaishou = kuaishouUtils;
CreateAmagiApp.getDouyinData = getDouyinData;
CreateAmagiApp.getBilibiliData = getBilibiliData;
CreateAmagiApp.getKuaishouData = getKuaishouData;
var CreateApp = CreateAmagiApp;
var amagi = CreateApp;
var v5_default = amagi;
var lib$2 = { exports: {} };
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var objectAssign;
var hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign) return objectAssign;
  hasRequiredObjectAssign = 1;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === void 0) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i = 0; i < 10; i++) {
        test2["_" + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
        return test2[n];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for (var s = 1; s < arguments.length; s++) {
      from = Object(arguments[s]);
      for (var key in from) {
        if (hasOwnProperty2.call(from, key)) {
          to[key] = from[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from);
        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from, symbols[i])) {
            to[symbols[i]] = from[symbols[i]];
          }
        }
      }
    }
    return to;
  };
  return objectAssign;
}
var vary = { exports: {} };
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredVary;
function requireVary() {
  if (hasRequiredVary) return vary.exports;
  hasRequiredVary = 1;
  vary.exports = vary$12;
  vary.exports.append = append2;
  var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
  function append2(header, field) {
    if (typeof header !== "string") {
      throw new TypeError("header argument is required");
    }
    if (!field) {
      throw new TypeError("field argument is required");
    }
    var fields = !Array.isArray(field) ? parse2(String(field)) : field;
    for (var j = 0; j < fields.length; j++) {
      if (!FIELD_NAME_REGEXP.test(fields[j])) {
        throw new TypeError("field argument contains an invalid header name");
      }
    }
    if (header === "*") {
      return header;
    }
    var val = header;
    var vals = parse2(header.toLowerCase());
    if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
      return "*";
    }
    for (var i = 0; i < fields.length; i++) {
      var fld = fields[i].toLowerCase();
      if (vals.indexOf(fld) === -1) {
        vals.push(fld);
        val = val ? val + ", " + fields[i] : fields[i];
      }
    }
    return val;
  }
  function parse2(header) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = header.length; i < len; i++) {
      switch (header.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          list.push(header.substring(start, end));
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    list.push(header.substring(start, end));
    return list;
  }
  function vary$12(res, field) {
    if (!res || !res.getHeader || !res.setHeader) {
      throw new TypeError("res argument is required");
    }
    var val = res.getHeader("Vary") || "";
    var header = Array.isArray(val) ? val.join(", ") : String(val);
    if (val = append2(header, field)) {
      res.setHeader("Vary", val);
    }
  }
  return vary.exports;
}
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$2.exports;
  hasRequiredLib$2 = 1;
  (function() {
    var assign = requireObjectAssign();
    var vary2 = requireVary();
    var defaults2 = {
      origin: "*",
      methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
      preflightContinue: false,
      optionsSuccessStatus: 204
    };
    function isString2(s) {
      return typeof s === "string" || s instanceof String;
    }
    function isOriginAllowed(origin2, allowedOrigin) {
      if (Array.isArray(allowedOrigin)) {
        for (var i = 0; i < allowedOrigin.length; ++i) {
          if (isOriginAllowed(origin2, allowedOrigin[i])) {
            return true;
          }
        }
        return false;
      } else if (isString2(allowedOrigin)) {
        return origin2 === allowedOrigin;
      } else if (allowedOrigin instanceof RegExp) {
        return allowedOrigin.test(origin2);
      } else {
        return !!allowedOrigin;
      }
    }
    function configureOrigin(options, req) {
      var requestOrigin = req.headers.origin, headers2 = [], isAllowed;
      if (!options.origin || options.origin === "*") {
        headers2.push([{
          key: "Access-Control-Allow-Origin",
          value: "*"
        }]);
      } else if (isString2(options.origin)) {
        headers2.push([{
          key: "Access-Control-Allow-Origin",
          value: options.origin
        }]);
        headers2.push([{
          key: "Vary",
          value: "Origin"
        }]);
      } else {
        isAllowed = isOriginAllowed(requestOrigin, options.origin);
        headers2.push([{
          key: "Access-Control-Allow-Origin",
          value: isAllowed ? requestOrigin : false
        }]);
        headers2.push([{
          key: "Vary",
          value: "Origin"
        }]);
      }
      return headers2;
    }
    function configureMethods(options) {
      var methods = options.methods;
      if (methods.join) {
        methods = options.methods.join(",");
      }
      return {
        key: "Access-Control-Allow-Methods",
        value: methods
      };
    }
    function configureCredentials(options) {
      if (options.credentials === true) {
        return {
          key: "Access-Control-Allow-Credentials",
          value: "true"
        };
      }
      return null;
    }
    function configureAllowedHeaders(options, req) {
      var allowedHeaders = options.allowedHeaders || options.headers;
      var headers2 = [];
      if (!allowedHeaders) {
        allowedHeaders = req.headers["access-control-request-headers"];
        headers2.push([{
          key: "Vary",
          value: "Access-Control-Request-Headers"
        }]);
      } else if (allowedHeaders.join) {
        allowedHeaders = allowedHeaders.join(",");
      }
      if (allowedHeaders && allowedHeaders.length) {
        headers2.push([{
          key: "Access-Control-Allow-Headers",
          value: allowedHeaders
        }]);
      }
      return headers2;
    }
    function configureExposedHeaders(options) {
      var headers2 = options.exposedHeaders;
      if (!headers2) {
        return null;
      } else if (headers2.join) {
        headers2 = headers2.join(",");
      }
      if (headers2 && headers2.length) {
        return {
          key: "Access-Control-Expose-Headers",
          value: headers2
        };
      }
      return null;
    }
    function configureMaxAge(options) {
      var maxAge = (typeof options.maxAge === "number" || options.maxAge) && options.maxAge.toString();
      if (maxAge && maxAge.length) {
        return {
          key: "Access-Control-Max-Age",
          value: maxAge
        };
      }
      return null;
    }
    function applyHeaders(headers2, res) {
      for (var i = 0, n = headers2.length; i < n; i++) {
        var header = headers2[i];
        if (header) {
          if (Array.isArray(header)) {
            applyHeaders(header, res);
          } else if (header.key === "Vary" && header.value) {
            vary2(res, header.value);
          } else if (header.value) {
            res.setHeader(header.key, header.value);
          }
        }
      }
    }
    function cors(options, req, res, next) {
      var headers2 = [], method = req.method && req.method.toUpperCase && req.method.toUpperCase();
      if (method === "OPTIONS") {
        headers2.push(configureOrigin(options, req));
        headers2.push(configureCredentials(options));
        headers2.push(configureMethods(options));
        headers2.push(configureAllowedHeaders(options, req));
        headers2.push(configureMaxAge(options));
        headers2.push(configureExposedHeaders(options));
        applyHeaders(headers2, res);
        if (options.preflightContinue) {
          next();
        } else {
          res.statusCode = options.optionsSuccessStatus;
          res.setHeader("Content-Length", "0");
          res.end();
        }
      } else {
        headers2.push(configureOrigin(options, req));
        headers2.push(configureCredentials(options));
        headers2.push(configureExposedHeaders(options));
        applyHeaders(headers2, res);
        next();
      }
    }
    function middlewareWrapper(o) {
      var optionsCallback = null;
      if (typeof o === "function") {
        optionsCallback = o;
      } else {
        optionsCallback = function(req, cb) {
          cb(null, o);
        };
      }
      return function corsMiddleware(req, res, next) {
        optionsCallback(req, function(err, options) {
          if (err) {
            next(err);
          } else {
            var corsOptions = assign({}, defaults2, options);
            var originCallback = null;
            if (corsOptions.origin && typeof corsOptions.origin === "function") {
              originCallback = corsOptions.origin;
            } else if (corsOptions.origin) {
              originCallback = function(origin2, cb) {
                cb(null, corsOptions.origin);
              };
            }
            if (originCallback) {
              originCallback(req.headers.origin, function(err2, origin2) {
                if (err2 || !origin2) {
                  next(err2);
                } else {
                  corsOptions.origin = origin2;
                  cors(corsOptions, req, res, next);
                }
              });
            } else {
              next();
            }
          }
        });
      };
    }
    lib$2.exports = middlewareWrapper;
  })();
  return lib$2.exports;
}
var libExports = requireLib$2();
var dist = {};
var factory = {};
var httpProxyMiddleware = {};
var httpProxy$2 = { exports: {} };
var eventemitter3 = { exports: {} };
var hasRequiredEventemitter3;
function requireEventemitter3() {
  if (hasRequiredEventemitter3) return eventemitter3.exports;
  hasRequiredEventemitter3 = 1;
  (function(module) {
    var has = Object.prototype.hasOwnProperty, prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once2) {
      this.fn = fn;
      this.context = context;
      this.once = once2 || false;
    }
    function addListener(emitter, event, fn, context, once2) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once2), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers2 = this._events[evt];
      if (!handlers2) return [];
      if (handlers2.fn) return [handlers2.fn];
      for (var i = 0, l = handlers2.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers2[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once2(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once2) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once2 || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once2 && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    {
      module.exports = EventEmitter2;
    }
  })(eventemitter3);
  return eventemitter3.exports;
}
var common$1 = {};
var requiresPort;
var hasRequiredRequiresPort;
function requireRequiresPort() {
  if (hasRequiredRequiresPort) return requiresPort;
  hasRequiredRequiresPort = 1;
  requiresPort = function required(port, protocol) {
    protocol = protocol.split(":")[0];
    port = +port;
    if (!port) return false;
    switch (protocol) {
      case "http":
      case "ws":
        return port !== 80;
      case "https":
      case "wss":
        return port !== 443;
      case "ftp":
        return port !== 21;
      case "gopher":
        return port !== 70;
      case "file":
        return false;
    }
    return port !== 0;
  };
  return requiresPort;
}
var hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  (function(exports) {
    var common2 = exports, url = require$$0$6, extend2 = require$$0$5._extend, required = requireRequiresPort();
    var upgradeHeader = /(^|,)\s*upgrade\s*($|,)/i, isSSL = /^https|wss/;
    common2.isSSL = isSSL;
    common2.setupOutgoing = function(outgoing, options, req, forward) {
      outgoing.port = options[forward || "target"].port || (isSSL.test(options[forward || "target"].protocol) ? 443 : 80);
      [
        "host",
        "hostname",
        "socketPath",
        "pfx",
        "key",
        "passphrase",
        "cert",
        "ca",
        "ciphers",
        "secureProtocol"
      ].forEach(
        function(e) {
          outgoing[e] = options[forward || "target"][e];
        }
      );
      outgoing.method = options.method || req.method;
      outgoing.headers = extend2({}, req.headers);
      if (options.headers) {
        extend2(outgoing.headers, options.headers);
      }
      if (options.auth) {
        outgoing.auth = options.auth;
      }
      if (options.ca) {
        outgoing.ca = options.ca;
      }
      if (isSSL.test(options[forward || "target"].protocol)) {
        outgoing.rejectUnauthorized = typeof options.secure === "undefined" ? true : options.secure;
      }
      outgoing.agent = options.agent || false;
      outgoing.localAddress = options.localAddress;
      if (!outgoing.agent) {
        outgoing.headers = outgoing.headers || {};
        if (typeof outgoing.headers.connection !== "string" || !upgradeHeader.test(outgoing.headers.connection)) {
          outgoing.headers.connection = "close";
        }
      }
      var target = options[forward || "target"];
      var targetPath = target && options.prependPath !== false ? target.path || "" : "";
      var outgoingPath = !options.toProxy ? url.parse(req.url).path || "" : req.url;
      outgoingPath = !options.ignorePath ? outgoingPath : "";
      outgoing.path = common2.urlJoin(targetPath, outgoingPath);
      if (options.changeOrigin) {
        outgoing.headers.host = required(outgoing.port, options[forward || "target"].protocol) && !hasPort(outgoing.host) ? outgoing.host + ":" + outgoing.port : outgoing.host;
      }
      return outgoing;
    };
    common2.setupSocket = function(socket) {
      socket.setTimeout(0);
      socket.setNoDelay(true);
      socket.setKeepAlive(true, 0);
      return socket;
    };
    common2.getPort = function(req) {
      var res = req.headers.host ? req.headers.host.match(/:(\d+)/) : "";
      return res ? res[1] : common2.hasEncryptedConnection(req) ? "443" : "80";
    };
    common2.hasEncryptedConnection = function(req) {
      return Boolean(req.connection.encrypted || req.connection.pair);
    };
    common2.urlJoin = function() {
      var args = Array.prototype.slice.call(arguments), lastIndex = args.length - 1, last = args[lastIndex], lastSegs = last.split("?"), retSegs;
      args[lastIndex] = lastSegs.shift();
      retSegs = [
        args.filter(Boolean).join("/").replace(/\/+/g, "/").replace("http:/", "http://").replace("https:/", "https://")
      ];
      retSegs.push.apply(retSegs, lastSegs);
      return retSegs.join("?");
    };
    common2.rewriteCookieProperty = function rewriteCookieProperty(header, config, property) {
      if (Array.isArray(header)) {
        return header.map(function(headerElement) {
          return rewriteCookieProperty(headerElement, config, property);
        });
      }
      return header.replace(new RegExp("(;\\s*" + property + "=)([^;]+)", "i"), function(match, prefix, previousValue) {
        var newValue;
        if (previousValue in config) {
          newValue = config[previousValue];
        } else if ("*" in config) {
          newValue = config["*"];
        } else {
          return match;
        }
        if (newValue) {
          return prefix + newValue;
        } else {
          return "";
        }
      });
    };
    function hasPort(host) {
      return !!~host.indexOf(":");
    }
  })(common$1);
  return common$1;
}
var webOutgoing;
var hasRequiredWebOutgoing;
function requireWebOutgoing() {
  if (hasRequiredWebOutgoing) return webOutgoing;
  hasRequiredWebOutgoing = 1;
  var url = require$$0$6, common2 = requireCommon$1();
  var redirectRegex = /^201|30(1|2|7|8)$/;
  /*!
   * Array of passes.
   *
   * A `pass` is just a function that is executed on `req, res, options`
   * so that you can easily add new checks while still keeping the base
   * flexible.
   */
  webOutgoing = {
    // <--
    /**
     * If is a HTTP 1.0 request, remove chunk headers
     *
     * @param {ClientRequest} Req Request object
     *@param {IncomingMessage} Res Response object
     * @param {proxyResponse} Res Response object from the proxy request
     *
     * @api private
     */
    removeChunked: function removeChunked(req, res, proxyRes) {
      if (req.httpVersion === "1.0") {
        delete proxyRes.headers["transfer-encoding"];
      }
    },
    /**
     * If is a HTTP 1.0 request, set the correct connection header
     * or if connection header not present, then use `keep-alive`
     *
     * @param {ClientRequest} Req Request object
     *@param {IncomingMessage} Res Response object
     * @param {proxyResponse} Res Response object from the proxy request
     *
     * @api private
     */
    setConnection: function setConnection(req, res, proxyRes) {
      if (req.httpVersion === "1.0") {
        proxyRes.headers.connection = req.headers.connection || "close";
      } else if (req.httpVersion !== "2.0" && !proxyRes.headers.connection) {
        proxyRes.headers.connection = req.headers.connection || "keep-alive";
      }
    },
    setRedirectHostRewrite: function setRedirectHostRewrite(req, res, proxyRes, options) {
      if ((options.hostRewrite || options.autoRewrite || options.protocolRewrite) && proxyRes.headers["location"] && redirectRegex.test(proxyRes.statusCode)) {
        var target = url.parse(options.target);
        var u = url.parse(proxyRes.headers["location"]);
        if (target.host != u.host) {
          return;
        }
        if (options.hostRewrite) {
          u.host = options.hostRewrite;
        } else if (options.autoRewrite) {
          u.host = req.headers["host"];
        }
        if (options.protocolRewrite) {
          u.protocol = options.protocolRewrite;
        }
        proxyRes.headers["location"] = u.format();
      }
    },
    /**
     * Copy headers from proxyResponse to response
     * set each header in response object.
     *
     * @param {ClientRequest} Req Request object
     *@param {IncomingMessage} Res Response object
     * @param {proxyResponse} Res Response object from the proxy request
     * @param {Object} Options options.cookieDomainRewrite: Config to rewrite cookie domain
     *
     * @api private
     */
    writeHeaders: function writeHeaders(req, res, proxyRes, options) {
      var rewriteCookieDomainConfig = options.cookieDomainRewrite, rewriteCookiePathConfig = options.cookiePathRewrite, preserveHeaderKeyCase = options.preserveHeaderKeyCase, rawHeaderKeyMap, setHeader = function(key2, header) {
        if (header == void 0) return;
        if (rewriteCookieDomainConfig && key2.toLowerCase() === "set-cookie") {
          header = common2.rewriteCookieProperty(header, rewriteCookieDomainConfig, "domain");
        }
        if (rewriteCookiePathConfig && key2.toLowerCase() === "set-cookie") {
          header = common2.rewriteCookieProperty(header, rewriteCookiePathConfig, "path");
        }
        res.setHeader(String(key2).trim(), header);
      };
      if (typeof rewriteCookieDomainConfig === "string") {
        rewriteCookieDomainConfig = { "*": rewriteCookieDomainConfig };
      }
      if (typeof rewriteCookiePathConfig === "string") {
        rewriteCookiePathConfig = { "*": rewriteCookiePathConfig };
      }
      if (preserveHeaderKeyCase && proxyRes.rawHeaders != void 0) {
        rawHeaderKeyMap = {};
        for (var i = 0; i < proxyRes.rawHeaders.length; i += 2) {
          var key = proxyRes.rawHeaders[i];
          rawHeaderKeyMap[key.toLowerCase()] = key;
        }
      }
      Object.keys(proxyRes.headers).forEach(function(key2) {
        var header = proxyRes.headers[key2];
        if (preserveHeaderKeyCase && rawHeaderKeyMap) {
          key2 = rawHeaderKeyMap[key2] || key2;
        }
        setHeader(key2, header);
      });
    },
    /**
     * Set the statusCode from the proxyResponse
     *
     * @param {ClientRequest} Req Request object
     *@param {IncomingMessage} Res Response object
     * @param {proxyResponse} Res Response object from the proxy request
     *
     * @api private
     */
    writeStatusCode: function writeStatusCode(req, res, proxyRes) {
      if (proxyRes.statusMessage) {
        res.statusCode = proxyRes.statusCode;
        res.statusMessage = proxyRes.statusMessage;
      } else {
        res.statusCode = proxyRes.statusCode;
      }
    }
  };
  return webOutgoing;
}
var followRedirects = { exports: {} };
var browser$1 = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index2++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index2];
            match = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend2;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup;
  return common;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$1.exports;
  hasRequiredBrowser$1 = 1;
  (function(module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser$1, browser$1.exports);
  return browser$1.exports;
}
var debug_1;
var hasRequiredDebug$1;
function requireDebug$1() {
  if (hasRequiredDebug$1) return debug_1;
  hasRequiredDebug$1 = 1;
  var debug2;
  debug_1 = function() {
    if (!debug2) {
      try {
        debug2 = requireBrowser$1()("follow-redirects");
      } catch (error) {
      }
      if (typeof debug2 !== "function") {
        debug2 = function() {
        };
      }
    }
    debug2.apply(null, arguments);
  };
  return debug_1;
}
var hasRequiredFollowRedirects;
function requireFollowRedirects() {
  if (hasRequiredFollowRedirects) return followRedirects.exports;
  hasRequiredFollowRedirects = 1;
  var url = require$$0$6;
  var URL2 = url.URL;
  var http = require$$1$4;
  var https = require$$2$1;
  var Writable = stream.Writable;
  var assert = require$$5$1;
  var debug2 = requireDebug$1();
  (function detectUnsupportedEnvironment() {
    var looksLikeNode = typeof process !== "undefined";
    var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
    var looksLikeV8 = isFunction2(Error.captureStackTrace);
    if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
      console.warn("The follow-redirects package should be excluded from browser builds.");
    }
  })();
  var useNativeURL = false;
  try {
    assert(new URL2(""));
  } catch (error) {
    useNativeURL = error.code === "ERR_INVALID_URL";
  }
  var preservedUrlFields = [
    "auth",
    "host",
    "hostname",
    "href",
    "path",
    "pathname",
    "port",
    "protocol",
    "query",
    "search",
    "hash"
  ];
  var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
  var eventHandlers = /* @__PURE__ */ Object.create(null);
  events.forEach(function(event) {
    eventHandlers[event] = function(arg1, arg2, arg3) {
      this._redirectable.emit(event, arg1, arg2, arg3);
    };
  });
  var InvalidUrlError = createErrorType(
    "ERR_INVALID_URL",
    "Invalid URL",
    TypeError
  );
  var RedirectionError = createErrorType(
    "ERR_FR_REDIRECTION_FAILURE",
    "Redirected request failed"
  );
  var TooManyRedirectsError = createErrorType(
    "ERR_FR_TOO_MANY_REDIRECTS",
    "Maximum number of redirects exceeded",
    RedirectionError
  );
  var MaxBodyLengthExceededError = createErrorType(
    "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
    "Request body larger than maxBodyLength limit"
  );
  var WriteAfterEndError = createErrorType(
    "ERR_STREAM_WRITE_AFTER_END",
    "write after end"
  );
  var destroy = Writable.prototype.destroy || noop2;
  function RedirectableRequest(options, responseCallback) {
    Writable.call(this);
    this._sanitizeOptions(options);
    this._options = options;
    this._ended = false;
    this._ending = false;
    this._redirectCount = 0;
    this._redirects = [];
    this._requestBodyLength = 0;
    this._requestBodyBuffers = [];
    if (responseCallback) {
      this.on("response", responseCallback);
    }
    var self2 = this;
    this._onNativeResponse = function(response2) {
      try {
        self2._processResponse(response2);
      } catch (cause) {
        self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
      }
    };
    this._performRequest();
  }
  RedirectableRequest.prototype = Object.create(Writable.prototype);
  RedirectableRequest.prototype.abort = function() {
    destroyRequest(this._currentRequest);
    this._currentRequest.abort();
    this.emit("abort");
  };
  RedirectableRequest.prototype.destroy = function(error) {
    destroyRequest(this._currentRequest, error);
    destroy.call(this, error);
    return this;
  };
  RedirectableRequest.prototype.write = function(data2, encoding2, callback) {
    if (this._ending) {
      throw new WriteAfterEndError();
    }
    if (!isString2(data2) && !isBuffer2(data2)) {
      throw new TypeError("data should be a string, Buffer or Uint8Array");
    }
    if (isFunction2(encoding2)) {
      callback = encoding2;
      encoding2 = null;
    }
    if (data2.length === 0) {
      if (callback) {
        callback();
      }
      return;
    }
    if (this._requestBodyLength + data2.length <= this._options.maxBodyLength) {
      this._requestBodyLength += data2.length;
      this._requestBodyBuffers.push({ data: data2, encoding: encoding2 });
      this._currentRequest.write(data2, encoding2, callback);
    } else {
      this.emit("error", new MaxBodyLengthExceededError());
      this.abort();
    }
  };
  RedirectableRequest.prototype.end = function(data2, encoding2, callback) {
    if (isFunction2(data2)) {
      callback = data2;
      data2 = encoding2 = null;
    } else if (isFunction2(encoding2)) {
      callback = encoding2;
      encoding2 = null;
    }
    if (!data2) {
      this._ended = this._ending = true;
      this._currentRequest.end(null, null, callback);
    } else {
      var self2 = this;
      var currentRequest = this._currentRequest;
      this.write(data2, encoding2, function() {
        self2._ended = true;
        currentRequest.end(null, null, callback);
      });
      this._ending = true;
    }
  };
  RedirectableRequest.prototype.setHeader = function(name, value) {
    this._options.headers[name] = value;
    this._currentRequest.setHeader(name, value);
  };
  RedirectableRequest.prototype.removeHeader = function(name) {
    delete this._options.headers[name];
    this._currentRequest.removeHeader(name);
  };
  RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
    var self2 = this;
    function destroyOnTimeout(socket) {
      socket.setTimeout(msecs);
      socket.removeListener("timeout", socket.destroy);
      socket.addListener("timeout", socket.destroy);
    }
    function startTimer(socket) {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
      }
      self2._timeout = setTimeout(function() {
        self2.emit("timeout");
        clearTimer();
      }, msecs);
      destroyOnTimeout(socket);
    }
    function clearTimer() {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
        self2._timeout = null;
      }
      self2.removeListener("abort", clearTimer);
      self2.removeListener("error", clearTimer);
      self2.removeListener("response", clearTimer);
      self2.removeListener("close", clearTimer);
      if (callback) {
        self2.removeListener("timeout", callback);
      }
      if (!self2.socket) {
        self2._currentRequest.removeListener("socket", startTimer);
      }
    }
    if (callback) {
      this.on("timeout", callback);
    }
    if (this.socket) {
      startTimer(this.socket);
    } else {
      this._currentRequest.once("socket", startTimer);
    }
    this.on("socket", destroyOnTimeout);
    this.on("abort", clearTimer);
    this.on("error", clearTimer);
    this.on("response", clearTimer);
    this.on("close", clearTimer);
    return this;
  };
  [
    "flushHeaders",
    "getHeader",
    "setNoDelay",
    "setSocketKeepAlive"
  ].forEach(function(method) {
    RedirectableRequest.prototype[method] = function(a, b) {
      return this._currentRequest[method](a, b);
    };
  });
  ["aborted", "connection", "socket"].forEach(function(property) {
    Object.defineProperty(RedirectableRequest.prototype, property, {
      get: function() {
        return this._currentRequest[property];
      }
    });
  });
  RedirectableRequest.prototype._sanitizeOptions = function(options) {
    if (!options.headers) {
      options.headers = {};
    }
    if (options.host) {
      if (!options.hostname) {
        options.hostname = options.host;
      }
      delete options.host;
    }
    if (!options.pathname && options.path) {
      var searchPos = options.path.indexOf("?");
      if (searchPos < 0) {
        options.pathname = options.path;
      } else {
        options.pathname = options.path.substring(0, searchPos);
        options.search = options.path.substring(searchPos);
      }
    }
  };
  RedirectableRequest.prototype._performRequest = function() {
    var protocol = this._options.protocol;
    var nativeProtocol = this._options.nativeProtocols[protocol];
    if (!nativeProtocol) {
      throw new TypeError("Unsupported protocol " + protocol);
    }
    if (this._options.agents) {
      var scheme = protocol.slice(0, -1);
      this._options.agent = this._options.agents[scheme];
    }
    var request2 = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
    request2._redirectable = this;
    for (var event of events) {
      request2.on(event, eventHandlers[event]);
    }
    this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
      // When making a request to a proxy, []
      // a client MUST send the target URI in absolute-form [].
      this._options.path
    );
    if (this._isRedirect) {
      var i = 0;
      var self2 = this;
      var buffers = this._requestBodyBuffers;
      (function writeNext(error) {
        if (request2 === self2._currentRequest) {
          if (error) {
            self2.emit("error", error);
          } else if (i < buffers.length) {
            var buffer2 = buffers[i++];
            if (!request2.finished) {
              request2.write(buffer2.data, buffer2.encoding, writeNext);
            }
          } else if (self2._ended) {
            request2.end();
          }
        }
      })();
    }
  };
  RedirectableRequest.prototype._processResponse = function(response2) {
    var statusCode2 = response2.statusCode;
    if (this._options.trackRedirects) {
      this._redirects.push({
        url: this._currentUrl,
        headers: response2.headers,
        statusCode: statusCode2
      });
    }
    var location = response2.headers.location;
    if (!location || this._options.followRedirects === false || statusCode2 < 300 || statusCode2 >= 400) {
      response2.responseUrl = this._currentUrl;
      response2.redirects = this._redirects;
      this.emit("response", response2);
      this._requestBodyBuffers = [];
      return;
    }
    destroyRequest(this._currentRequest);
    response2.destroy();
    if (++this._redirectCount > this._options.maxRedirects) {
      throw new TooManyRedirectsError();
    }
    var requestHeaders;
    var beforeRedirect = this._options.beforeRedirect;
    if (beforeRedirect) {
      requestHeaders = Object.assign({
        // The Host header was set by nativeProtocol.request
        Host: response2.req.getHeader("host")
      }, this._options.headers);
    }
    var method = this._options.method;
    if ((statusCode2 === 301 || statusCode2 === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
    // the server is redirecting the user agent to a different resource []
    // A user agent can perform a retrieval request targeting that URI
    // (a GET or HEAD request if using HTTP) []
    statusCode2 === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
      this._options.method = "GET";
      this._requestBodyBuffers = [];
      removeMatchingHeaders(/^content-/i, this._options.headers);
    }
    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
    var currentUrlParts = parseUrl(this._currentUrl);
    var currentHost = currentHostHeader || currentUrlParts.host;
    var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
    var redirectUrl = resolveUrl(location, currentUrl);
    debug2("redirecting to", redirectUrl.href);
    this._isRedirect = true;
    spreadUrlObject(redirectUrl, this._options);
    if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
      removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
    }
    if (isFunction2(beforeRedirect)) {
      var responseDetails = {
        headers: response2.headers,
        statusCode: statusCode2
      };
      var requestDetails = {
        url: currentUrl,
        method,
        headers: requestHeaders
      };
      beforeRedirect(this._options, responseDetails, requestDetails);
      this._sanitizeOptions(this._options);
    }
    this._performRequest();
  };
  function wrap(protocols) {
    var exports = {
      maxRedirects: 21,
      maxBodyLength: 10 * 1024 * 1024
    };
    var nativeProtocols = {};
    Object.keys(protocols).forEach(function(scheme) {
      var protocol = scheme + ":";
      var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
      var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);
      function request2(input, options, callback) {
        if (isURL(input)) {
          input = spreadUrlObject(input);
        } else if (isString2(input)) {
          input = spreadUrlObject(parseUrl(input));
        } else {
          callback = options;
          options = validateUrl(input);
          input = { protocol };
        }
        if (isFunction2(options)) {
          callback = options;
          options = null;
        }
        options = Object.assign({
          maxRedirects: exports.maxRedirects,
          maxBodyLength: exports.maxBodyLength
        }, input, options);
        options.nativeProtocols = nativeProtocols;
        if (!isString2(options.host) && !isString2(options.hostname)) {
          options.hostname = "::1";
        }
        assert.equal(options.protocol, protocol, "protocol mismatch");
        debug2("options", options);
        return new RedirectableRequest(options, callback);
      }
      function get2(input, options, callback) {
        var wrappedRequest = wrappedProtocol.request(input, options, callback);
        wrappedRequest.end();
        return wrappedRequest;
      }
      Object.defineProperties(wrappedProtocol, {
        request: { value: request2, configurable: true, enumerable: true, writable: true },
        get: { value: get2, configurable: true, enumerable: true, writable: true }
      });
    });
    return exports;
  }
  function noop2() {
  }
  function parseUrl(input) {
    var parsed;
    if (useNativeURL) {
      parsed = new URL2(input);
    } else {
      parsed = validateUrl(url.parse(input));
      if (!isString2(parsed.protocol)) {
        throw new InvalidUrlError({ input });
      }
    }
    return parsed;
  }
  function resolveUrl(relative, base) {
    return useNativeURL ? new URL2(relative, base) : parseUrl(url.resolve(base, relative));
  }
  function validateUrl(input) {
    if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    return input;
  }
  function spreadUrlObject(urlObject, target) {
    var spread2 = target || {};
    for (var key of preservedUrlFields) {
      spread2[key] = urlObject[key];
    }
    if (spread2.hostname.startsWith("[")) {
      spread2.hostname = spread2.hostname.slice(1, -1);
    }
    if (spread2.port !== "") {
      spread2.port = Number(spread2.port);
    }
    spread2.path = spread2.search ? spread2.pathname + spread2.search : spread2.pathname;
    return spread2;
  }
  function removeMatchingHeaders(regex2, headers2) {
    var lastValue;
    for (var header in headers2) {
      if (regex2.test(header)) {
        lastValue = headers2[header];
        delete headers2[header];
      }
    }
    return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
  }
  function createErrorType(code, message, baseClass) {
    function CustomError(properties) {
      if (isFunction2(Error.captureStackTrace)) {
        Error.captureStackTrace(this, this.constructor);
      }
      Object.assign(this, properties || {});
      this.code = code;
      this.message = this.cause ? message + ": " + this.cause.message : message;
    }
    CustomError.prototype = new (baseClass || Error)();
    Object.defineProperties(CustomError.prototype, {
      constructor: {
        value: CustomError,
        enumerable: false
      },
      name: {
        value: "Error [" + code + "]",
        enumerable: false
      }
    });
    return CustomError;
  }
  function destroyRequest(request2, error) {
    for (var event of events) {
      request2.removeListener(event, eventHandlers[event]);
    }
    request2.on("error", noop2);
    request2.destroy(error);
  }
  function isSubdomain(subdomain, domain) {
    assert(isString2(subdomain) && isString2(domain));
    var dot = subdomain.length - domain.length - 1;
    return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
  }
  function isString2(value) {
    return typeof value === "string" || value instanceof String;
  }
  function isFunction2(value) {
    return typeof value === "function";
  }
  function isBuffer2(value) {
    return typeof value === "object" && "length" in value;
  }
  function isURL(value) {
    return URL2 && value instanceof URL2;
  }
  followRedirects.exports = wrap({ http, https });
  followRedirects.exports.wrap = wrap;
  return followRedirects.exports;
}
var webIncoming;
var hasRequiredWebIncoming;
function requireWebIncoming() {
  if (hasRequiredWebIncoming) return webIncoming;
  hasRequiredWebIncoming = 1;
  var httpNative = require$$1$4, httpsNative = require$$2$1, web_o = requireWebOutgoing(), common2 = requireCommon$1(), followRedirects2 = requireFollowRedirects();
  web_o = Object.keys(web_o).map(function(pass) {
    return web_o[pass];
  });
  var nativeAgents = { http: httpNative, https: httpsNative };
  /*!
   * Array of passes.
   *
   * A `pass` is just a function that is executed on `req, res, options`
   * so that you can easily add new checks while still keeping the base
   * flexible.
   */
  webIncoming = {
    /**
     * Sets `content-length` to '0' if request is of DELETE type.
     *
     * @param {ClientRequest} Req Request object
     *@param {IncomingMessage} Res Response object
     * @param {Object} Options Config object passed to the proxy
     *
     * @api private
     */
    deleteLength: function deleteLength(req, res, options) {
      if ((req.method === "DELETE" || req.method === "OPTIONS") && !req.headers["content-length"]) {
        req.headers["content-length"] = "0";
        delete req.headers["transfer-encoding"];
      }
    },
    /**
     * Sets timeout in request socket if it was specified in options.
     *
     * @param {ClientRequest} Req Request object
     *@param {IncomingMessage} Res Response object
     * @param {Object} Options Config object passed to the proxy
     *
     * @api private
     */
    timeout: function timeout(req, res, options) {
      if (options.timeout) {
        req.socket.setTimeout(options.timeout);
      }
    },
    /**
     * Sets `x-forwarded-*` headers if specified in config.
     *
     * @param {ClientRequest} Req Request object
     *@param {IncomingMessage} Res Response object
     * @param {Object} Options Config object passed to the proxy
     *
     * @api private
     */
    XHeaders: function XHeaders(req, res, options) {
      if (!options.xfwd) return;
      var encrypted = req.isSpdy || common2.hasEncryptedConnection(req);
      var values = {
        for: req.connection.remoteAddress || req.socket.remoteAddress,
        port: common2.getPort(req),
        proto: encrypted ? "https" : "http"
      };
      ["for", "port", "proto"].forEach(function(header) {
        req.headers["x-forwarded-" + header] = (req.headers["x-forwarded-" + header] || "") + (req.headers["x-forwarded-" + header] ? "," : "") + values[header];
      });
      req.headers["x-forwarded-host"] = req.headers["x-forwarded-host"] || req.headers["host"] || "";
    },
    /**
     * Does the actual proxying. If `forward` is enabled fires up
     * a ForwardStream, same happens for ProxyStream. The request
     * just dies otherwise.
     *
     * @param {ClientRequest} Req Request object
     *@param {IncomingMessage} Res Response object
     * @param {Object} Options Config object passed to the proxy
     *
     * @api private
     */
    stream: function stream2(req, res, options, _, server, clb) {
      server.emit("start", req, res, options.target || options.forward);
      var agents = options.followRedirects ? followRedirects2 : nativeAgents;
      var http = agents.http;
      var https = agents.https;
      if (options.forward) {
        var forwardReq = (options.forward.protocol === "https:" ? https : http).request(
          common2.setupOutgoing(options.ssl || {}, options, req, "forward")
        );
        var forwardError = createErrorHandler(forwardReq, options.forward);
        req.on("error", forwardError);
        forwardReq.on("error", forwardError);
        (options.buffer || req).pipe(forwardReq);
        if (!options.target) {
          return res.end();
        }
      }
      var proxyReq = (options.target.protocol === "https:" ? https : http).request(
        common2.setupOutgoing(options.ssl || {}, options, req)
      );
      proxyReq.on("socket", function(socket) {
        if (server && !proxyReq.getHeader("expect")) {
          server.emit("proxyReq", proxyReq, req, res, options);
        }
      });
      if (options.proxyTimeout) {
        proxyReq.setTimeout(options.proxyTimeout, function() {
          proxyReq.abort();
        });
      }
      req.on("aborted", function() {
        proxyReq.abort();
      });
      var proxyError = createErrorHandler(proxyReq, options.target);
      req.on("error", proxyError);
      proxyReq.on("error", proxyError);
      function createErrorHandler(proxyReq2, url) {
        return function proxyError2(err) {
          if (req.socket.destroyed && err.code === "ECONNRESET") {
            server.emit("econnreset", err, req, res, url);
            return proxyReq2.abort();
          }
          if (clb) {
            clb(err, req, res, url);
          } else {
            server.emit("error", err, req, res, url);
          }
        };
      }
      (options.buffer || req).pipe(proxyReq);
      proxyReq.on("response", function(proxyRes) {
        if (server) {
          server.emit("proxyRes", proxyRes, req, res);
        }
        if (!res.headersSent && !options.selfHandleResponse) {
          for (var i = 0; i < web_o.length; i++) {
            if (web_o[i](req, res, proxyRes, options)) {
              break;
            }
          }
        }
        if (!res.finished) {
          proxyRes.on("end", function() {
            if (server) server.emit("end", req, res, proxyRes);
          });
          if (!options.selfHandleResponse) proxyRes.pipe(res);
        } else {
          if (server) server.emit("end", req, res, proxyRes);
        }
      });
    }
  };
  return webIncoming;
}
var wsIncoming;
var hasRequiredWsIncoming;
function requireWsIncoming() {
  if (hasRequiredWsIncoming) return wsIncoming;
  hasRequiredWsIncoming = 1;
  var http = require$$1$4, https = require$$2$1, common2 = requireCommon$1();
  /*!
   * Array of passes.
   *
   * A `pass` is just a function that is executed on `req, socket, options`
   * so that you can easily add new checks while still keeping the base
   * flexible.
   */
  wsIncoming = {
    /**
     * WebSocket requests must have the `GET` method and
     * the `upgrade:websocket` header
     *
     * @param {ClientRequest} Req Request object
     *@param {Socket} Websocket
     *
     * @api private
     */
    checkMethodAndHeader: function checkMethodAndHeader(req, socket) {
      if (req.method !== "GET" || !req.headers.upgrade) {
        socket.destroy();
        return true;
      }
      if (req.headers.upgrade.toLowerCase() !== "websocket") {
        socket.destroy();
        return true;
      }
    },
    /**
     * Sets `x-forwarded-*` headers if specified in config.
     *
     * @param {ClientRequest} Req Request object
     *@param {Socket} Websocket
     * @param {Object} Options Config object passed to the proxy
     *
     * @api private
     */
    XHeaders: function XHeaders(req, socket, options) {
      if (!options.xfwd) return;
      var values = {
        for: req.connection.remoteAddress || req.socket.remoteAddress,
        port: common2.getPort(req),
        proto: common2.hasEncryptedConnection(req) ? "wss" : "ws"
      };
      ["for", "port", "proto"].forEach(function(header) {
        req.headers["x-forwarded-" + header] = (req.headers["x-forwarded-" + header] || "") + (req.headers["x-forwarded-" + header] ? "," : "") + values[header];
      });
    },
    /**
     * Does the actual proxying. Make the request and upgrade it
     * send the Switching Protocols request and pipe the sockets.
     *
     * @param {ClientRequest} Req Request object
     *@param {Socket} Websocket
     * @param {Object} Options Config object passed to the proxy
     *
     * @api private
     */
    stream: function stream2(req, socket, options, head, server, clb) {
      var createHttpHeader = function(line, headers2) {
        return Object.keys(headers2).reduce(function(head2, key) {
          var value = headers2[key];
          if (!Array.isArray(value)) {
            head2.push(key + ": " + value);
            return head2;
          }
          for (var i = 0; i < value.length; i++) {
            head2.push(key + ": " + value[i]);
          }
          return head2;
        }, [line]).join("\r\n") + "\r\n\r\n";
      };
      common2.setupSocket(socket);
      if (head && head.length) socket.unshift(head);
      var proxyReq = (common2.isSSL.test(options.target.protocol) ? https : http).request(
        common2.setupOutgoing(options.ssl || {}, options, req)
      );
      if (server) {
        server.emit("proxyReqWs", proxyReq, req, socket, options, head);
      }
      proxyReq.on("error", onOutgoingError);
      proxyReq.on("response", function(res) {
        if (!res.upgrade) {
          socket.write(createHttpHeader("HTTP/" + res.httpVersion + " " + res.statusCode + " " + res.statusMessage, res.headers));
          res.pipe(socket);
        }
      });
      proxyReq.on("upgrade", function(proxyRes, proxySocket, proxyHead) {
        proxySocket.on("error", onOutgoingError);
        proxySocket.on("end", function() {
          server.emit("close", proxyRes, proxySocket, proxyHead);
        });
        socket.on("error", function() {
          proxySocket.end();
        });
        common2.setupSocket(proxySocket);
        if (proxyHead && proxyHead.length) proxySocket.unshift(proxyHead);
        socket.write(createHttpHeader("HTTP/1.1 101 Switching Protocols", proxyRes.headers));
        proxySocket.pipe(socket).pipe(proxySocket);
        server.emit("open", proxySocket);
        server.emit("proxySocket", proxySocket);
      });
      return proxyReq.end();
      function onOutgoingError(err) {
        if (clb) {
          clb(err, req, socket);
        } else {
          server.emit("error", err, req, socket);
        }
        socket.end();
      }
    }
  };
  return wsIncoming;
}
var hasRequiredHttpProxy$2;
function requireHttpProxy$2() {
  if (hasRequiredHttpProxy$2) return httpProxy$2.exports;
  hasRequiredHttpProxy$2 = 1;
  (function(module) {
    var httpProxy2 = module.exports, extend2 = require$$0$5._extend, parse_url = require$$0$6.parse, EE3 = requireEventemitter3(), http = require$$1$4, https = require$$2$1, web = requireWebIncoming(), ws = requireWsIncoming();
    httpProxy2.Server = ProxyServer;
    function createRightProxy(type2) {
      return function(options) {
        return function(req, res) {
          var passes = type2 === "ws" ? this.wsPasses : this.webPasses, args = [].slice.call(arguments), cntr = args.length - 1, head, cbl;
          if (typeof args[cntr] === "function") {
            cbl = args[cntr];
            cntr--;
          }
          var requestOptions = options;
          if (!(args[cntr] instanceof Buffer) && args[cntr] !== res) {
            requestOptions = extend2({}, options);
            extend2(requestOptions, args[cntr]);
            cntr--;
          }
          if (args[cntr] instanceof Buffer) {
            head = args[cntr];
          }
          ["target", "forward"].forEach(function(e) {
            if (typeof requestOptions[e] === "string")
              requestOptions[e] = parse_url(requestOptions[e]);
          });
          if (!requestOptions.target && !requestOptions.forward) {
            return this.emit("error", new Error("Must provide a proper URL as target"));
          }
          for (var i = 0; i < passes.length; i++) {
            if (passes[i](req, res, requestOptions, head, this, cbl)) {
              break;
            }
          }
        };
      };
    }
    httpProxy2.createRightProxy = createRightProxy;
    function ProxyServer(options) {
      EE3.call(this);
      options = options || {};
      options.prependPath = options.prependPath === false ? false : true;
      this.web = this.proxyRequest = createRightProxy("web")(options);
      this.ws = this.proxyWebsocketRequest = createRightProxy("ws")(options);
      this.options = options;
      this.webPasses = Object.keys(web).map(function(pass) {
        return web[pass];
      });
      this.wsPasses = Object.keys(ws).map(function(pass) {
        return ws[pass];
      });
      this.on("error", this.onError, this);
    }
    require$$0$5.inherits(ProxyServer, EE3);
    ProxyServer.prototype.onError = function(err) {
      if (this.listeners("error").length === 1) {
        throw err;
      }
    };
    ProxyServer.prototype.listen = function(port, hostname) {
      var self2 = this, closure = function(req, res) {
        self2.web(req, res);
      };
      this._server = this.options.ssl ? https.createServer(this.options.ssl, closure) : http.createServer(closure);
      if (this.options.ws) {
        this._server.on("upgrade", function(req, socket, head) {
          self2.ws(req, socket, head);
        });
      }
      this._server.listen(port, hostname);
      return this;
    };
    ProxyServer.prototype.close = function(callback) {
      var self2 = this;
      if (this._server) {
        this._server.close(done);
      }
      function done() {
        self2._server = null;
        if (callback) {
          callback.apply(null, arguments);
        }
      }
    };
    ProxyServer.prototype.before = function(type2, passName, callback) {
      if (type2 !== "ws" && type2 !== "web") {
        throw new Error("type must be `web` or `ws`");
      }
      var passes = type2 === "ws" ? this.wsPasses : this.webPasses, i = false;
      passes.forEach(function(v, idx) {
        if (v.name === passName) i = idx;
      });
      if (i === false) throw new Error("No such pass");
      passes.splice(i, 0, callback);
    };
    ProxyServer.prototype.after = function(type2, passName, callback) {
      if (type2 !== "ws" && type2 !== "web") {
        throw new Error("type must be `web` or `ws`");
      }
      var passes = type2 === "ws" ? this.wsPasses : this.webPasses, i = false;
      passes.forEach(function(v, idx) {
        if (v.name === passName) i = idx;
      });
      if (i === false) throw new Error("No such pass");
      passes.splice(i++, 0, callback);
    };
  })(httpProxy$2);
  return httpProxy$2.exports;
}
var httpProxy$1;
var hasRequiredHttpProxy$1;
function requireHttpProxy$1() {
  if (hasRequiredHttpProxy$1) return httpProxy$1;
  hasRequiredHttpProxy$1 = 1;
  var ProxyServer = requireHttpProxy$2().Server;
  function createProxyServer(options) {
    return new ProxyServer(options);
  }
  ProxyServer.createProxyServer = createProxyServer;
  ProxyServer.createServer = createProxyServer;
  ProxyServer.createProxy = createProxyServer;
  httpProxy$1 = ProxyServer;
  return httpProxy$1;
}
/*!
 * Caron dimonio, con occhi di bragia
 * loro accennando, tutte le raccoglie;
 * batte col remo qualunque sadagia 
 *
 * Charon the demon, with the eyes of glede,
 * Beckoning to them, collects them all together,
 * Beats with his oar whoever lags behind
 *          
 *          Dante - The Divine Comedy (Canto III)
 */
var httpProxy;
var hasRequiredHttpProxy;
function requireHttpProxy() {
  if (hasRequiredHttpProxy) return httpProxy;
  hasRequiredHttpProxy = 1;
  httpProxy = requireHttpProxy$1();
  return httpProxy;
}
var configuration = {};
var errors = {};
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  Object.defineProperty(errors, "__esModule", { value: true });
  errors.ERRORS = void 0;
  var ERRORS;
  (function(ERRORS2) {
    ERRORS2["ERR_CONFIG_FACTORY_TARGET_MISSING"] = '[HPM] Missing "target" option. Example: {target: "http://www.example.org"}';
    ERRORS2["ERR_CONTEXT_MATCHER_GENERIC"] = '[HPM] Invalid pathFilter. Expecting something like: "/api" or ["/api", "/ajax"]';
    ERRORS2["ERR_CONTEXT_MATCHER_INVALID_ARRAY"] = '[HPM] Invalid pathFilter. Plain paths (e.g. "/api") can not be mixed with globs (e.g. "/api/**"). Expecting something like: ["/api", "/ajax"] or ["/api/**", "!**.html"].';
    ERRORS2["ERR_PATH_REWRITER_CONFIG"] = "[HPM] Invalid pathRewrite config. Expecting object with pathRewrite config or a rewrite function";
  })(ERRORS || (errors.ERRORS = ERRORS = {}));
  return errors;
}
var hasRequiredConfiguration;
function requireConfiguration() {
  if (hasRequiredConfiguration) return configuration;
  hasRequiredConfiguration = 1;
  Object.defineProperty(configuration, "__esModule", { value: true });
  configuration.verifyConfig = verifyConfig;
  const errors_1 = requireErrors();
  function verifyConfig(options) {
    if (!options.target && !options.router) {
      throw new Error(errors_1.ERRORS.ERR_CONFIG_FACTORY_TARGET_MISSING);
    }
  }
  return configuration;
}
var getPlugins = {};
var _default = {};
var debugProxyErrorsPlugin = {};
var debug = {};
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug) return debug;
  hasRequiredDebug = 1;
  Object.defineProperty(debug, "__esModule", { value: true });
  debug.Debug = void 0;
  const createDebug = requireBrowser$1();
  debug.Debug = createDebug("http-proxy-middleware");
  return debug;
}
var hasRequiredDebugProxyErrorsPlugin;
function requireDebugProxyErrorsPlugin() {
  if (hasRequiredDebugProxyErrorsPlugin) return debugProxyErrorsPlugin;
  hasRequiredDebugProxyErrorsPlugin = 1;
  Object.defineProperty(debugProxyErrorsPlugin, "__esModule", { value: true });
  debugProxyErrorsPlugin.debugProxyErrorsPlugin = void 0;
  const debug_12 = requireDebug();
  const debug2 = debug_12.Debug.extend("debug-proxy-errors-plugin");
  const debugProxyErrorsPlugin$1 = (proxyServer) => {
    proxyServer.on("error", (error, req, res, target) => {
      debug2(`http-proxy error event: 
%O`, error);
    });
    proxyServer.on("proxyReq", (proxyReq, req, socket) => {
      socket.on("error", (error) => {
        debug2("Socket error in proxyReq event: \n%O", error);
      });
    });
    proxyServer.on("proxyRes", (proxyRes, req, res) => {
      res.on("close", () => {
        if (!res.writableEnded) {
          debug2("Destroying proxyRes in proxyRes close event");
          proxyRes.destroy();
        }
      });
    });
    proxyServer.on("proxyReqWs", (proxyReq, req, socket) => {
      socket.on("error", (error) => {
        debug2("Socket error in proxyReqWs event: \n%O", error);
      });
    });
    proxyServer.on("open", (proxySocket) => {
      proxySocket.on("error", (error) => {
        debug2("Socket error in open event: \n%O", error);
      });
    });
    proxyServer.on("close", (req, socket, head) => {
      socket.on("error", (error) => {
        debug2("Socket error in close event: \n%O", error);
      });
    });
    proxyServer.on("econnreset", (error, req, res, target) => {
      debug2(`http-proxy econnreset event: 
%O`, error);
    });
  };
  debugProxyErrorsPlugin.debugProxyErrorsPlugin = debugProxyErrorsPlugin$1;
  return debugProxyErrorsPlugin;
}
var errorResponsePlugin = {};
var statusCode = {};
var hasRequiredStatusCode;
function requireStatusCode() {
  if (hasRequiredStatusCode) return statusCode;
  hasRequiredStatusCode = 1;
  Object.defineProperty(statusCode, "__esModule", { value: true });
  statusCode.getStatusCode = getStatusCode;
  function getStatusCode(errorCode) {
    let statusCode2;
    if (/HPE_INVALID/.test(errorCode)) {
      statusCode2 = 502;
    } else {
      switch (errorCode) {
        case "ECONNRESET":
        case "ENOTFOUND":
        case "ECONNREFUSED":
        case "ETIMEDOUT":
          statusCode2 = 504;
          break;
        default:
          statusCode2 = 500;
          break;
      }
    }
    return statusCode2;
  }
  return statusCode;
}
var hasRequiredErrorResponsePlugin;
function requireErrorResponsePlugin() {
  if (hasRequiredErrorResponsePlugin) return errorResponsePlugin;
  hasRequiredErrorResponsePlugin = 1;
  Object.defineProperty(errorResponsePlugin, "__esModule", { value: true });
  errorResponsePlugin.errorResponsePlugin = void 0;
  const status_code_1 = requireStatusCode();
  function isResponseLike(obj) {
    return obj && typeof obj.writeHead === "function";
  }
  function isSocketLike(obj) {
    return obj && typeof obj.write === "function" && !("writeHead" in obj);
  }
  const errorResponsePlugin$1 = (proxyServer, options) => {
    proxyServer.on("error", (err, req, res, target) => {
      if (!req && !res) {
        throw err;
      }
      if (isResponseLike(res)) {
        if (!res.headersSent) {
          const statusCode2 = (0, status_code_1.getStatusCode)(err.code);
          res.writeHead(statusCode2);
        }
        const host = req.headers && req.headers.host;
        res.end(`Error occurred while trying to proxy: ${host}${req.url}`);
      } else if (isSocketLike(res)) {
        res.destroy();
      }
    });
  };
  errorResponsePlugin.errorResponsePlugin = errorResponsePlugin$1;
  return errorResponsePlugin;
}
var loggerPlugin$1 = {};
var logger = {};
var hasRequiredLogger;
function requireLogger() {
  if (hasRequiredLogger) return logger;
  hasRequiredLogger = 1;
  Object.defineProperty(logger, "__esModule", { value: true });
  logger.getLogger = getLogger;
  const noopLogger = {
    info: () => {
    },
    warn: () => {
    },
    error: () => {
    }
  };
  function getLogger(options) {
    return options.logger || noopLogger;
  }
  return logger;
}
var loggerPlugin = {};
var hasRequiredLoggerPlugin$1;
function requireLoggerPlugin$1() {
  if (hasRequiredLoggerPlugin$1) return loggerPlugin;
  hasRequiredLoggerPlugin$1 = 1;
  Object.defineProperty(loggerPlugin, "__esModule", { value: true });
  loggerPlugin.getPort = getPort;
  function getPort(sockets) {
    return Object.keys(sockets || {})?.[0]?.split(":")[1];
  }
  return loggerPlugin;
}
var hasRequiredLoggerPlugin;
function requireLoggerPlugin() {
  if (hasRequiredLoggerPlugin) return loggerPlugin$1;
  hasRequiredLoggerPlugin = 1;
  Object.defineProperty(loggerPlugin$1, "__esModule", { value: true });
  loggerPlugin$1.loggerPlugin = void 0;
  const url_1 = require$$0$6;
  const logger_1 = requireLogger();
  const logger_plugin_1 = requireLoggerPlugin$1();
  const loggerPlugin2 = (proxyServer, options) => {
    const logger2 = (0, logger_1.getLogger)(options);
    proxyServer.on("error", (err, req, res, target) => {
      const hostname = req?.headers?.host;
      const requestHref = `${hostname}${req?.url}`;
      const targetHref = `${target?.href}`;
      const errorMessage = "[HPM] Error occurred while proxying request %s to %s [%s] (%s)";
      const errReference = "https://nodejs.org/api/errors.html#errors_common_system_errors";
      logger2.error(errorMessage, requestHref, targetHref, err.code || err, errReference);
    });
    proxyServer.on("proxyRes", (proxyRes, req, res) => {
      const originalUrl = req.originalUrl ?? `${req.baseUrl || ""}${req.url}`;
      let target;
      try {
        const port = (0, logger_plugin_1.getPort)(proxyRes.req?.agent?.sockets);
        const obj = {
          protocol: proxyRes.req.protocol,
          host: proxyRes.req.host,
          pathname: proxyRes.req.path
        };
        target = new url_1.URL(`${obj.protocol}//${obj.host}${obj.pathname}`);
        if (port) {
          target.port = port;
        }
      } catch (err) {
        target = new url_1.URL(options.target);
        target.pathname = proxyRes.req.path;
      }
      const targetUrl = target.toString();
      const exchange = `[HPM] ${req.method} ${originalUrl} -> ${targetUrl} [${proxyRes.statusCode}]`;
      logger2.info(exchange);
    });
    proxyServer.on("open", (socket) => {
      logger2.info("[HPM] Client connected: %o", socket.address());
    });
    proxyServer.on("close", (req, proxySocket, proxyHead) => {
      logger2.info("[HPM] Client disconnected: %o", proxySocket.address());
    });
  };
  loggerPlugin$1.loggerPlugin = loggerPlugin2;
  return loggerPlugin$1;
}
var proxyEvents = {};
var _function = {};
var hasRequired_function;
function require_function() {
  if (hasRequired_function) return _function;
  hasRequired_function = 1;
  Object.defineProperty(_function, "__esModule", { value: true });
  _function.getFunctionName = getFunctionName;
  function getFunctionName(fn) {
    return fn.name || "[anonymous Function]";
  }
  return _function;
}
var hasRequiredProxyEvents;
function requireProxyEvents() {
  if (hasRequiredProxyEvents) return proxyEvents;
  hasRequiredProxyEvents = 1;
  Object.defineProperty(proxyEvents, "__esModule", { value: true });
  proxyEvents.proxyEventsPlugin = void 0;
  const debug_12 = requireDebug();
  const function_1 = require_function();
  const debug2 = debug_12.Debug.extend("proxy-events-plugin");
  const proxyEventsPlugin = (proxyServer, options) => {
    Object.entries(options.on || {}).forEach(([eventName, handler]) => {
      debug2(`register event handler: "${eventName}" -> "${(0, function_1.getFunctionName)(handler)}"`);
      proxyServer.on(eventName, handler);
    });
  };
  proxyEvents.proxyEventsPlugin = proxyEventsPlugin;
  return proxyEvents;
}
var hasRequired_default;
function require_default() {
  if (hasRequired_default) return _default;
  hasRequired_default = 1;
  (function(exports) {
    var __createBinding = _default && _default.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = _default && _default.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(requireDebugProxyErrorsPlugin(), exports);
    __exportStar(requireErrorResponsePlugin(), exports);
    __exportStar(requireLoggerPlugin(), exports);
    __exportStar(requireProxyEvents(), exports);
  })(_default);
  return _default;
}
var hasRequiredGetPlugins;
function requireGetPlugins() {
  if (hasRequiredGetPlugins) return getPlugins;
  hasRequiredGetPlugins = 1;
  Object.defineProperty(getPlugins, "__esModule", { value: true });
  getPlugins.getPlugins = getPlugins$1;
  const default_1 = require_default();
  function getPlugins$1(options) {
    const maybeErrorResponsePlugin = options.on?.error ? [] : [default_1.errorResponsePlugin];
    const defaultPlugins = options.ejectPlugins ? [] : [default_1.debugProxyErrorsPlugin, default_1.proxyEventsPlugin, default_1.loggerPlugin, ...maybeErrorResponsePlugin];
    const userPlugins = options.plugins ?? [];
    return [...defaultPlugins, ...userPlugins];
  }
  return getPlugins;
}
var pathFilter = {};
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var isExtglob;
var hasRequiredIsExtglob;
function requireIsExtglob() {
  if (hasRequiredIsExtglob) return isExtglob;
  hasRequiredIsExtglob = 1;
  isExtglob = function isExtglob2(str) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    var match;
    while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
      if (match[2]) return true;
      str = str.slice(match.index + match[0].length);
    }
    return false;
  };
  return isExtglob;
}
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isGlob;
var hasRequiredIsGlob;
function requireIsGlob() {
  if (hasRequiredIsGlob) return isGlob;
  hasRequiredIsGlob = 1;
  var isExtglob2 = requireIsExtglob();
  var chars = { "{": "}", "(": ")", "[": "]" };
  var strictCheck = function(str) {
    if (str[0] === "!") {
      return true;
    }
    var index2 = 0;
    var pipeIndex = -2;
    var closeSquareIndex = -2;
    var closeCurlyIndex = -2;
    var closeParenIndex = -2;
    var backSlashIndex = -2;
    while (index2 < str.length) {
      if (str[index2] === "*") {
        return true;
      }
      if (str[index2 + 1] === "?" && /[\].+)]/.test(str[index2])) {
        return true;
      }
      if (closeSquareIndex !== -1 && str[index2] === "[" && str[index2 + 1] !== "]") {
        if (closeSquareIndex < index2) {
          closeSquareIndex = str.indexOf("]", index2);
        }
        if (closeSquareIndex > index2) {
          if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
            return true;
          }
          backSlashIndex = str.indexOf("\\", index2);
          if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
            return true;
          }
        }
      }
      if (closeCurlyIndex !== -1 && str[index2] === "{" && str[index2 + 1] !== "}") {
        closeCurlyIndex = str.indexOf("}", index2);
        if (closeCurlyIndex > index2) {
          backSlashIndex = str.indexOf("\\", index2);
          if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
            return true;
          }
        }
      }
      if (closeParenIndex !== -1 && str[index2] === "(" && str[index2 + 1] === "?" && /[:!=]/.test(str[index2 + 2]) && str[index2 + 3] !== ")") {
        closeParenIndex = str.indexOf(")", index2);
        if (closeParenIndex > index2) {
          backSlashIndex = str.indexOf("\\", index2);
          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
            return true;
          }
        }
      }
      if (pipeIndex !== -1 && str[index2] === "(" && str[index2 + 1] !== "|") {
        if (pipeIndex < index2) {
          pipeIndex = str.indexOf("|", index2);
        }
        if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
          closeParenIndex = str.indexOf(")", pipeIndex);
          if (closeParenIndex > pipeIndex) {
            backSlashIndex = str.indexOf("\\", pipeIndex);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
      }
      if (str[index2] === "\\") {
        var open = str[index2 + 1];
        index2 += 2;
        var close = chars[open];
        if (close) {
          var n = str.indexOf(close, index2);
          if (n !== -1) {
            index2 = n + 1;
          }
        }
        if (str[index2] === "!") {
          return true;
        }
      } else {
        index2++;
      }
    }
    return false;
  };
  var relaxedCheck = function(str) {
    if (str[0] === "!") {
      return true;
    }
    var index2 = 0;
    while (index2 < str.length) {
      if (/[*?{}()[\]]/.test(str[index2])) {
        return true;
      }
      if (str[index2] === "\\") {
        var open = str[index2 + 1];
        index2 += 2;
        var close = chars[open];
        if (close) {
          var n = str.indexOf(close, index2);
          if (n !== -1) {
            index2 = n + 1;
          }
        }
        if (str[index2] === "!") {
          return true;
        }
      } else {
        index2++;
      }
    }
    return false;
  };
  isGlob = function isGlob2(str, options) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    if (isExtglob2(str)) {
      return true;
    }
    var check = strictCheck;
    if (options && options.strict === false) {
      check = relaxedCheck;
    }
    return check(str);
  };
  return isGlob;
}
var utils$3 = {};
var hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$3;
  hasRequiredUtils$3 = 1;
  (function(exports) {
    exports.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports.find = (node, type2) => node.nodes.find((node2) => node2.type === type2);
    exports.exceedsLimit = (min2, max2, step = 1, limit) => {
      if (limit === false) return false;
      if (!exports.isInteger(min2) || !exports.isInteger(max2)) return false;
      return (Number(max2) - Number(min2)) / Number(step) >= limit;
    };
    exports.escapeNode = (block, n = 0, type2) => {
      const node = block.nodes[n];
      if (!node) return;
      if (type2 && node.type === type2 || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports.encloseBrace = (node) => {
      if (node.type !== "brace") return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports.isInvalidBrace = (block) => {
      if (block.type !== "brace") return false;
      if (block.invalid === true || block.dollar) return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text") acc.push(node.value);
      if (node.type === "range") node.type = "text";
      return acc;
    }, []);
    exports.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          const ele = arr[i];
          if (Array.isArray(ele)) {
            flat(ele);
            continue;
          }
          if (ele !== void 0) {
            result.push(ele);
          }
        }
        return result;
      };
      flat(args);
      return result;
    };
  })(utils$3);
  return utils$3;
}
var stringify;
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify;
  hasRequiredStringify = 1;
  const utils2 = requireUtils$3();
  stringify = (ast, options = {}) => {
    const stringify2 = (node, parent = {}) => {
      const invalidBlock = options.escapeInvalid && utils2.isInvalidBrace(parent);
      const invalidNode = node.invalid === true && options.escapeInvalid === true;
      let output2 = "";
      if (node.value) {
        if ((invalidBlock || invalidNode) && utils2.isOpenOrClose(node)) {
          return "\\" + node.value;
        }
        return node.value;
      }
      if (node.value) {
        return node.value;
      }
      if (node.nodes) {
        for (const child of node.nodes) {
          output2 += stringify2(child);
        }
      }
      return output2;
    };
    return stringify2(ast);
  };
  return stringify;
}
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
var isNumber;
var hasRequiredIsNumber;
function requireIsNumber() {
  if (hasRequiredIsNumber) return isNumber;
  hasRequiredIsNumber = 1;
  isNumber = function(num) {
    if (typeof num === "number") {
      return num - num === 0;
    }
    if (typeof num === "string" && num.trim() !== "") {
      return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
    }
    return false;
  };
  return isNumber;
}
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
var toRegexRange_1;
var hasRequiredToRegexRange;
function requireToRegexRange() {
  if (hasRequiredToRegexRange) return toRegexRange_1;
  hasRequiredToRegexRange = 1;
  const isNumber2 = requireIsNumber();
  const toRegexRange = (min2, max2, options) => {
    if (isNumber2(min2) === false) {
      throw new TypeError("toRegexRange: expected the first argument to be a number");
    }
    if (max2 === void 0 || min2 === max2) {
      return String(min2);
    }
    if (isNumber2(max2) === false) {
      throw new TypeError("toRegexRange: expected the second argument to be a number.");
    }
    let opts = { relaxZeros: true, ...options };
    if (typeof opts.strictZeros === "boolean") {
      opts.relaxZeros = opts.strictZeros === false;
    }
    let relax = String(opts.relaxZeros);
    let shorthand = String(opts.shorthand);
    let capture = String(opts.capture);
    let wrap = String(opts.wrap);
    let cacheKey = min2 + ":" + max2 + "=" + relax + shorthand + capture + wrap;
    if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
      return toRegexRange.cache[cacheKey].result;
    }
    let a = Math.min(min2, max2);
    let b = Math.max(min2, max2);
    if (Math.abs(a - b) === 1) {
      let result = min2 + "|" + max2;
      if (opts.capture) {
        return `(${result})`;
      }
      if (opts.wrap === false) {
        return result;
      }
      return `(?:${result})`;
    }
    let isPadded = hasPadding(min2) || hasPadding(max2);
    let state = { min: min2, max: max2, a, b };
    let positives = [];
    let negatives = [];
    if (isPadded) {
      state.isPadded = isPadded;
      state.maxLen = String(state.max).length;
    }
    if (a < 0) {
      let newMin = b < 0 ? Math.abs(b) : 1;
      negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
      a = state.a = 0;
    }
    if (b >= 0) {
      positives = splitToPatterns(a, b, state, opts);
    }
    state.negatives = negatives;
    state.positives = positives;
    state.result = collatePatterns(negatives, positives);
    if (opts.capture === true) {
      state.result = `(${state.result})`;
    } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
      state.result = `(?:${state.result})`;
    }
    toRegexRange.cache[cacheKey] = state;
    return state.result;
  };
  function collatePatterns(neg, pos, options) {
    let onlyNegative = filterPatterns(neg, pos, "-", false) || [];
    let onlyPositive = filterPatterns(pos, neg, "", false) || [];
    let intersected = filterPatterns(neg, pos, "-?", true) || [];
    let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
    return subpatterns.join("|");
  }
  function splitToRanges(min2, max2) {
    let nines = 1;
    let zeros = 1;
    let stop = countNines(min2, nines);
    let stops = /* @__PURE__ */ new Set([max2]);
    while (min2 <= stop && stop <= max2) {
      stops.add(stop);
      nines += 1;
      stop = countNines(min2, nines);
    }
    stop = countZeros(max2 + 1, zeros) - 1;
    while (min2 < stop && stop <= max2) {
      stops.add(stop);
      zeros += 1;
      stop = countZeros(max2 + 1, zeros) - 1;
    }
    stops = [...stops];
    stops.sort(compare);
    return stops;
  }
  function rangeToPattern(start, stop, options) {
    if (start === stop) {
      return { pattern: start, count: [], digits: 0 };
    }
    let zipped = zip(start, stop);
    let digits = zipped.length;
    let pattern = "";
    let count = 0;
    for (let i = 0; i < digits; i++) {
      let [startDigit, stopDigit] = zipped[i];
      if (startDigit === stopDigit) {
        pattern += startDigit;
      } else if (startDigit !== "0" || stopDigit !== "9") {
        pattern += toCharacterClass(startDigit, stopDigit);
      } else {
        count++;
      }
    }
    if (count) {
      pattern += options.shorthand === true ? "\\d" : "[0-9]";
    }
    return { pattern, count: [count], digits };
  }
  function splitToPatterns(min2, max2, tok, options) {
    let ranges = splitToRanges(min2, max2);
    let tokens = [];
    let start = min2;
    let prev;
    for (let i = 0; i < ranges.length; i++) {
      let max3 = ranges[i];
      let obj = rangeToPattern(String(start), String(max3), options);
      let zeros = "";
      if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
        if (prev.count.length > 1) {
          prev.count.pop();
        }
        prev.count.push(obj.count[0]);
        prev.string = prev.pattern + toQuantifier(prev.count);
        start = max3 + 1;
        continue;
      }
      if (tok.isPadded) {
        zeros = padZeros(max3, tok, options);
      }
      obj.string = zeros + obj.pattern + toQuantifier(obj.count);
      tokens.push(obj);
      start = max3 + 1;
      prev = obj;
    }
    return tokens;
  }
  function filterPatterns(arr, comparison, prefix, intersection, options) {
    let result = [];
    for (let ele of arr) {
      let { string } = ele;
      if (!intersection && !contains(comparison, "string", string)) {
        result.push(prefix + string);
      }
      if (intersection && contains(comparison, "string", string)) {
        result.push(prefix + string);
      }
    }
    return result;
  }
  function zip(a, b) {
    let arr = [];
    for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
    return arr;
  }
  function compare(a, b) {
    return a > b ? 1 : b > a ? -1 : 0;
  }
  function contains(arr, key, val) {
    return arr.some((ele) => ele[key] === val);
  }
  function countNines(min2, len) {
    return Number(String(min2).slice(0, -len) + "9".repeat(len));
  }
  function countZeros(integer, zeros) {
    return integer - integer % Math.pow(10, zeros);
  }
  function toQuantifier(digits) {
    let [start = 0, stop = ""] = digits;
    if (stop || start > 1) {
      return `{${start + (stop ? "," + stop : "")}}`;
    }
    return "";
  }
  function toCharacterClass(a, b, options) {
    return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
  }
  function hasPadding(str) {
    return /^-?(0+)\d/.test(str);
  }
  function padZeros(value, tok, options) {
    if (!tok.isPadded) {
      return value;
    }
    let diff = Math.abs(tok.maxLen - String(value).length);
    let relax = options.relaxZeros !== false;
    switch (diff) {
      case 0:
        return "";
      case 1:
        return relax ? "0?" : "0";
      case 2:
        return relax ? "0{0,2}" : "00";
      default: {
        return relax ? `0{0,${diff}}` : `0{${diff}}`;
      }
    }
  }
  toRegexRange.cache = {};
  toRegexRange.clearCache = () => toRegexRange.cache = {};
  toRegexRange_1 = toRegexRange;
  return toRegexRange_1;
}
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var fillRange;
var hasRequiredFillRange;
function requireFillRange() {
  if (hasRequiredFillRange) return fillRange;
  hasRequiredFillRange = 1;
  const util2 = require$$0$5;
  const toRegexRange = requireToRegexRange();
  const isObject2 = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  const transform = (toNumber) => {
    return (value) => toNumber === true ? Number(value) : String(value);
  };
  const isValidValue = (value) => {
    return typeof value === "number" || typeof value === "string" && value !== "";
  };
  const isNumber2 = (num) => Number.isInteger(+num);
  const zeros = (input) => {
    let value = `${input}`;
    let index2 = -1;
    if (value[0] === "-") value = value.slice(1);
    if (value === "0") return false;
    while (value[++index2] === "0") ;
    return index2 > 0;
  };
  const stringify2 = (start, end, options) => {
    if (typeof start === "string" || typeof end === "string") {
      return true;
    }
    return options.stringify === true;
  };
  const pad = (input, maxLength, toNumber) => {
    if (maxLength > 0) {
      let dash = input[0] === "-" ? "-" : "";
      if (dash) input = input.slice(1);
      input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
    }
    if (toNumber === false) {
      return String(input);
    }
    return input;
  };
  const toMaxLen = (input, maxLength) => {
    let negative = input[0] === "-" ? "-" : "";
    if (negative) {
      input = input.slice(1);
      maxLength--;
    }
    while (input.length < maxLength) input = "0" + input;
    return negative ? "-" + input : input;
  };
  const toSequence = (parts, options, maxLen) => {
    parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    let prefix = options.capture ? "" : "?:";
    let positives = "";
    let negatives = "";
    let result;
    if (parts.positives.length) {
      positives = parts.positives.map((v) => toMaxLen(String(v), maxLen)).join("|");
    }
    if (parts.negatives.length) {
      negatives = `-(${prefix}${parts.negatives.map((v) => toMaxLen(String(v), maxLen)).join("|")})`;
    }
    if (positives && negatives) {
      result = `${positives}|${negatives}`;
    } else {
      result = positives || negatives;
    }
    if (options.wrap) {
      return `(${prefix}${result})`;
    }
    return result;
  };
  const toRange = (a, b, isNumbers, options) => {
    if (isNumbers) {
      return toRegexRange(a, b, { wrap: false, ...options });
    }
    let start = String.fromCharCode(a);
    if (a === b) return start;
    let stop = String.fromCharCode(b);
    return `[${start}-${stop}]`;
  };
  const toRegex = (start, end, options) => {
    if (Array.isArray(start)) {
      let wrap = options.wrap === true;
      let prefix = options.capture ? "" : "?:";
      return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
    }
    return toRegexRange(start, end, options);
  };
  const rangeError = (...args) => {
    return new RangeError("Invalid range arguments: " + util2.inspect(...args));
  };
  const invalidRange = (start, end, options) => {
    if (options.strictRanges === true) throw rangeError([start, end]);
    return [];
  };
  const invalidStep = (step, options) => {
    if (options.strictRanges === true) {
      throw new TypeError(`Expected step "${step}" to be a number`);
    }
    return [];
  };
  const fillNumbers = (start, end, step = 1, options = {}) => {
    let a = Number(start);
    let b = Number(end);
    if (!Number.isInteger(a) || !Number.isInteger(b)) {
      if (options.strictRanges === true) throw rangeError([start, end]);
      return [];
    }
    if (a === 0) a = 0;
    if (b === 0) b = 0;
    let descending = a > b;
    let startString = String(start);
    let endString = String(end);
    let stepString = String(step);
    step = Math.max(Math.abs(step), 1);
    let padded = zeros(startString) || zeros(endString) || zeros(stepString);
    let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
    let toNumber = padded === false && stringify2(start, end, options) === false;
    let format = options.transform || transform(toNumber);
    if (options.toRegex && step === 1) {
      return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
    }
    let parts = { negatives: [], positives: [] };
    let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
    let range2 = [];
    let index2 = 0;
    while (descending ? a >= b : a <= b) {
      if (options.toRegex === true && step > 1) {
        push(a);
      } else {
        range2.push(pad(format(a, index2), maxLen, toNumber));
      }
      a = descending ? a - step : a + step;
      index2++;
    }
    if (options.toRegex === true) {
      return step > 1 ? toSequence(parts, options, maxLen) : toRegex(range2, null, { wrap: false, ...options });
    }
    return range2;
  };
  const fillLetters = (start, end, step = 1, options = {}) => {
    if (!isNumber2(start) && start.length > 1 || !isNumber2(end) && end.length > 1) {
      return invalidRange(start, end, options);
    }
    let format = options.transform || ((val) => String.fromCharCode(val));
    let a = `${start}`.charCodeAt(0);
    let b = `${end}`.charCodeAt(0);
    let descending = a > b;
    let min2 = Math.min(a, b);
    let max2 = Math.max(a, b);
    if (options.toRegex && step === 1) {
      return toRange(min2, max2, false, options);
    }
    let range2 = [];
    let index2 = 0;
    while (descending ? a >= b : a <= b) {
      range2.push(format(a, index2));
      a = descending ? a - step : a + step;
      index2++;
    }
    if (options.toRegex === true) {
      return toRegex(range2, null, { wrap: false, options });
    }
    return range2;
  };
  const fill = (start, end, step, options = {}) => {
    if (end == null && isValidValue(start)) {
      return [start];
    }
    if (!isValidValue(start) || !isValidValue(end)) {
      return invalidRange(start, end, options);
    }
    if (typeof step === "function") {
      return fill(start, end, 1, { transform: step });
    }
    if (isObject2(step)) {
      return fill(start, end, 0, step);
    }
    let opts = { ...options };
    if (opts.capture === true) opts.wrap = true;
    step = step || opts.step || 1;
    if (!isNumber2(step)) {
      if (step != null && !isObject2(step)) return invalidStep(step, opts);
      return fill(start, end, 1, step);
    }
    if (isNumber2(start) && isNumber2(end)) {
      return fillNumbers(start, end, step, opts);
    }
    return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
  };
  fillRange = fill;
  return fillRange;
}
var compile_1;
var hasRequiredCompile;
function requireCompile() {
  if (hasRequiredCompile) return compile_1;
  hasRequiredCompile = 1;
  const fill = requireFillRange();
  const utils2 = requireUtils$3();
  const compile = (ast, options = {}) => {
    const walk = (node, parent = {}) => {
      const invalidBlock = utils2.isInvalidBrace(parent);
      const invalidNode = node.invalid === true && options.escapeInvalid === true;
      const invalid = invalidBlock === true || invalidNode === true;
      const prefix = options.escapeInvalid === true ? "\\" : "";
      let output2 = "";
      if (node.isOpen === true) {
        return prefix + node.value;
      }
      if (node.isClose === true) {
        console.log("node.isClose", prefix, node.value);
        return prefix + node.value;
      }
      if (node.type === "open") {
        return invalid ? prefix + node.value : "(";
      }
      if (node.type === "close") {
        return invalid ? prefix + node.value : ")";
      }
      if (node.type === "comma") {
        return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
      }
      if (node.value) {
        return node.value;
      }
      if (node.nodes && node.ranges > 0) {
        const args = utils2.reduce(node.nodes);
        const range2 = fill(...args, { ...options, wrap: false, toRegex: true, strictZeros: true });
        if (range2.length !== 0) {
          return args.length > 1 && range2.length > 1 ? `(${range2})` : range2;
        }
      }
      if (node.nodes) {
        for (const child of node.nodes) {
          output2 += walk(child, node);
        }
      }
      return output2;
    };
    return walk(ast);
  };
  compile_1 = compile;
  return compile_1;
}
var expand_1;
var hasRequiredExpand;
function requireExpand() {
  if (hasRequiredExpand) return expand_1;
  hasRequiredExpand = 1;
  const fill = requireFillRange();
  const stringify2 = requireStringify();
  const utils2 = requireUtils$3();
  const append2 = (queue = "", stash = "", enclose = false) => {
    const result = [];
    queue = [].concat(queue);
    stash = [].concat(stash);
    if (!stash.length) return queue;
    if (!queue.length) {
      return enclose ? utils2.flatten(stash).map((ele) => `{${ele}}`) : stash;
    }
    for (const item of queue) {
      if (Array.isArray(item)) {
        for (const value of item) {
          result.push(append2(value, stash, enclose));
        }
      } else {
        for (let ele of stash) {
          if (enclose === true && typeof ele === "string") ele = `{${ele}}`;
          result.push(Array.isArray(ele) ? append2(item, ele, enclose) : item + ele);
        }
      }
    }
    return utils2.flatten(result);
  };
  const expand = (ast, options = {}) => {
    const rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
    const walk = (node, parent = {}) => {
      node.queue = [];
      let p = parent;
      let q = parent.queue;
      while (p.type !== "brace" && p.type !== "root" && p.parent) {
        p = p.parent;
        q = p.queue;
      }
      if (node.invalid || node.dollar) {
        q.push(append2(q.pop(), stringify2(node, options)));
        return;
      }
      if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
        q.push(append2(q.pop(), ["{}"]));
        return;
      }
      if (node.nodes && node.ranges > 0) {
        const args = utils2.reduce(node.nodes);
        if (utils2.exceedsLimit(...args, options.step, rangeLimit)) {
          throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
        }
        let range2 = fill(...args, options);
        if (range2.length === 0) {
          range2 = stringify2(node, options);
        }
        q.push(append2(q.pop(), range2));
        node.nodes = [];
        return;
      }
      const enclose = utils2.encloseBrace(node);
      let queue = node.queue;
      let block = node;
      while (block.type !== "brace" && block.type !== "root" && block.parent) {
        block = block.parent;
        queue = block.queue;
      }
      for (let i = 0; i < node.nodes.length; i++) {
        const child = node.nodes[i];
        if (child.type === "comma" && node.type === "brace") {
          if (i === 1) queue.push("");
          queue.push("");
          continue;
        }
        if (child.type === "close") {
          q.push(append2(q.pop(), queue, enclose));
          continue;
        }
        if (child.value && child.type !== "open") {
          queue.push(append2(queue.pop(), child.value));
          continue;
        }
        if (child.nodes) {
          walk(child, node);
        }
      }
      return queue;
    };
    return utils2.flatten(walk(ast));
  };
  expand_1 = expand;
  return expand_1;
}
var constants$2;
var hasRequiredConstants$2;
function requireConstants$2() {
  if (hasRequiredConstants$2) return constants$2;
  hasRequiredConstants$2 = 1;
  constants$2 = {
    MAX_LENGTH: 1e4,
    // Digits
    CHAR_0: "0",
    /* 0 */
    CHAR_9: "9",
    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: "A",
    /* A */
    CHAR_LOWERCASE_A: "a",
    /* a */
    CHAR_UPPERCASE_Z: "Z",
    /* Z */
    CHAR_LOWERCASE_Z: "z",
    /* z */
    CHAR_LEFT_PARENTHESES: "(",
    /* ( */
    CHAR_RIGHT_PARENTHESES: ")",
    /* ) */
    CHAR_ASTERISK: "*",
    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: "&",
    /* & */
    CHAR_AT: "@",
    /* @ */
    CHAR_BACKSLASH: "\\",
    /* \ */
    CHAR_BACKTICK: "`",
    /* ` */
    CHAR_CARRIAGE_RETURN: "\r",
    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: "^",
    /* ^ */
    CHAR_COLON: ":",
    /* : */
    CHAR_COMMA: ",",
    /* , */
    CHAR_DOLLAR: "$",
    /* . */
    CHAR_DOT: ".",
    /* . */
    CHAR_DOUBLE_QUOTE: '"',
    /* " */
    CHAR_EQUAL: "=",
    /* = */
    CHAR_EXCLAMATION_MARK: "!",
    /* ! */
    CHAR_FORM_FEED: "\f",
    /* \f */
    CHAR_FORWARD_SLASH: "/",
    /* / */
    CHAR_HASH: "#",
    /* # */
    CHAR_HYPHEN_MINUS: "-",
    /* - */
    CHAR_LEFT_ANGLE_BRACKET: "<",
    /* < */
    CHAR_LEFT_CURLY_BRACE: "{",
    /* { */
    CHAR_LEFT_SQUARE_BRACKET: "[",
    /* [ */
    CHAR_LINE_FEED: "\n",
    /* \n */
    CHAR_NO_BREAK_SPACE: "",
    /* \u00A0 */
    CHAR_PERCENT: "%",
    /* % */
    CHAR_PLUS: "+",
    /* + */
    CHAR_QUESTION_MARK: "?",
    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: ">",
    /* > */
    CHAR_RIGHT_CURLY_BRACE: "}",
    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: "]",
    /* ] */
    CHAR_SEMICOLON: ";",
    /* ; */
    CHAR_SINGLE_QUOTE: "'",
    /* ' */
    CHAR_SPACE: " ",
    /*   */
    CHAR_TAB: "	",
    /* \t */
    CHAR_UNDERSCORE: "_",
    /* _ */
    CHAR_VERTICAL_LINE: "|",
    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    /* \uFEFF */
  };
  return constants$2;
}
var parse_1$1;
var hasRequiredParse$1;
function requireParse$1() {
  if (hasRequiredParse$1) return parse_1$1;
  hasRequiredParse$1 = 1;
  const stringify2 = requireStringify();
  const {
    MAX_LENGTH,
    CHAR_BACKSLASH,
    /* \ */
    CHAR_BACKTICK,
    /* ` */
    CHAR_COMMA,
    /* , */
    CHAR_DOT,
    /* . */
    CHAR_LEFT_PARENTHESES,
    /* ( */
    CHAR_RIGHT_PARENTHESES,
    /* ) */
    CHAR_LEFT_CURLY_BRACE,
    /* { */
    CHAR_RIGHT_CURLY_BRACE,
    /* } */
    CHAR_LEFT_SQUARE_BRACKET,
    /* [ */
    CHAR_RIGHT_SQUARE_BRACKET,
    /* ] */
    CHAR_DOUBLE_QUOTE,
    /* " */
    CHAR_SINGLE_QUOTE,
    /* ' */
    CHAR_NO_BREAK_SPACE,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE
  } = requireConstants$2();
  const parse2 = (input, options = {}) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected a string");
    }
    const opts = options || {};
    const max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    if (input.length > max2) {
      throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max2})`);
    }
    const ast = { type: "root", input, nodes: [] };
    const stack = [ast];
    let block = ast;
    let prev = ast;
    let brackets = 0;
    const length = input.length;
    let index2 = 0;
    let depth = 0;
    let value;
    const advance = () => input[index2++];
    const push = (node) => {
      if (node.type === "text" && prev.type === "dot") {
        prev.type = "text";
      }
      if (prev && prev.type === "text" && node.type === "text") {
        prev.value += node.value;
        return;
      }
      block.nodes.push(node);
      node.parent = block;
      node.prev = prev;
      prev = node;
      return node;
    };
    push({ type: "bos" });
    while (index2 < length) {
      block = stack[stack.length - 1];
      value = advance();
      if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
        continue;
      }
      if (value === CHAR_BACKSLASH) {
        push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
        continue;
      }
      if (value === CHAR_RIGHT_SQUARE_BRACKET) {
        push({ type: "text", value: "\\" + value });
        continue;
      }
      if (value === CHAR_LEFT_SQUARE_BRACKET) {
        brackets++;
        let next;
        while (index2 < length && (next = advance())) {
          value += next;
          if (next === CHAR_LEFT_SQUARE_BRACKET) {
            brackets++;
            continue;
          }
          if (next === CHAR_BACKSLASH) {
            value += advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            brackets--;
            if (brackets === 0) {
              break;
            }
          }
        }
        push({ type: "text", value });
        continue;
      }
      if (value === CHAR_LEFT_PARENTHESES) {
        block = push({ type: "paren", nodes: [] });
        stack.push(block);
        push({ type: "text", value });
        continue;
      }
      if (value === CHAR_RIGHT_PARENTHESES) {
        if (block.type !== "paren") {
          push({ type: "text", value });
          continue;
        }
        block = stack.pop();
        push({ type: "text", value });
        block = stack[stack.length - 1];
        continue;
      }
      if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
        const open = value;
        let next;
        if (options.keepQuotes !== true) {
          value = "";
        }
        while (index2 < length && (next = advance())) {
          if (next === CHAR_BACKSLASH) {
            value += next + advance();
            continue;
          }
          if (next === open) {
            if (options.keepQuotes === true) value += next;
            break;
          }
          value += next;
        }
        push({ type: "text", value });
        continue;
      }
      if (value === CHAR_LEFT_CURLY_BRACE) {
        depth++;
        const dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
        const brace = {
          type: "brace",
          open: true,
          close: false,
          dollar,
          depth,
          commas: 0,
          ranges: 0,
          nodes: []
        };
        block = push(brace);
        stack.push(block);
        push({ type: "open", value });
        continue;
      }
      if (value === CHAR_RIGHT_CURLY_BRACE) {
        if (block.type !== "brace") {
          push({ type: "text", value });
          continue;
        }
        const type2 = "close";
        block = stack.pop();
        block.close = true;
        push({ type: type2, value });
        depth--;
        block = stack[stack.length - 1];
        continue;
      }
      if (value === CHAR_COMMA && depth > 0) {
        if (block.ranges > 0) {
          block.ranges = 0;
          const open = block.nodes.shift();
          block.nodes = [open, { type: "text", value: stringify2(block) }];
        }
        push({ type: "comma", value });
        block.commas++;
        continue;
      }
      if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
        const siblings = block.nodes;
        if (depth === 0 || siblings.length === 0) {
          push({ type: "text", value });
          continue;
        }
        if (prev.type === "dot") {
          block.range = [];
          prev.value += value;
          prev.type = "range";
          if (block.nodes.length !== 3 && block.nodes.length !== 5) {
            block.invalid = true;
            block.ranges = 0;
            prev.type = "text";
            continue;
          }
          block.ranges++;
          block.args = [];
          continue;
        }
        if (prev.type === "range") {
          siblings.pop();
          const before = siblings[siblings.length - 1];
          before.value += prev.value + value;
          prev = before;
          block.ranges--;
          continue;
        }
        push({ type: "dot", value });
        continue;
      }
      push({ type: "text", value });
    }
    do {
      block = stack.pop();
      if (block.type !== "root") {
        block.nodes.forEach((node) => {
          if (!node.nodes) {
            if (node.type === "open") node.isOpen = true;
            if (node.type === "close") node.isClose = true;
            if (!node.nodes) node.type = "text";
            node.invalid = true;
          }
        });
        const parent = stack[stack.length - 1];
        const index3 = parent.nodes.indexOf(block);
        parent.nodes.splice(index3, 1, ...block.nodes);
      }
    } while (stack.length > 0);
    push({ type: "eos" });
    return ast;
  };
  parse_1$1 = parse2;
  return parse_1$1;
}
var braces_1;
var hasRequiredBraces;
function requireBraces() {
  if (hasRequiredBraces) return braces_1;
  hasRequiredBraces = 1;
  const stringify2 = requireStringify();
  const compile = requireCompile();
  const expand = requireExpand();
  const parse2 = requireParse$1();
  const braces = (input, options = {}) => {
    let output2 = [];
    if (Array.isArray(input)) {
      for (const pattern of input) {
        const result = braces.create(pattern, options);
        if (Array.isArray(result)) {
          output2.push(...result);
        } else {
          output2.push(result);
        }
      }
    } else {
      output2 = [].concat(braces.create(input, options));
    }
    if (options && options.expand === true && options.nodupes === true) {
      output2 = [...new Set(output2)];
    }
    return output2;
  };
  braces.parse = (input, options = {}) => parse2(input, options);
  braces.stringify = (input, options = {}) => {
    if (typeof input === "string") {
      return stringify2(braces.parse(input, options), options);
    }
    return stringify2(input, options);
  };
  braces.compile = (input, options = {}) => {
    if (typeof input === "string") {
      input = braces.parse(input, options);
    }
    return compile(input, options);
  };
  braces.expand = (input, options = {}) => {
    if (typeof input === "string") {
      input = braces.parse(input, options);
    }
    let result = expand(input, options);
    if (options.noempty === true) {
      result = result.filter(Boolean);
    }
    if (options.nodupes === true) {
      result = [...new Set(result)];
    }
    return result;
  };
  braces.create = (input, options = {}) => {
    if (input === "" || input.length < 3) {
      return [input];
    }
    return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
  };
  braces_1 = braces;
  return braces_1;
}
var utils$2 = {};
var constants$1;
var hasRequiredConstants$1;
function requireConstants$1() {
  if (hasRequiredConstants$1) return constants$1;
  hasRequiredConstants$1 = 1;
  const path2 = require$$1$3;
  const WIN_SLASH = "\\\\/";
  const WIN_NO_SLASH = `[^${WIN_SLASH}]`;
  const DOT_LITERAL = "\\.";
  const PLUS_LITERAL = "\\+";
  const QMARK_LITERAL = "\\?";
  const SLASH_LITERAL = "\\/";
  const ONE_CHAR = "(?=.)";
  const QMARK = "[^/]";
  const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
  const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
  const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
  const NO_DOT = `(?!${DOT_LITERAL})`;
  const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
  const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
  const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
  const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
  const STAR = `${QMARK}*?`;
  const POSIX_CHARS = {
    DOT_LITERAL,
    PLUS_LITERAL,
    QMARK_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    QMARK,
    END_ANCHOR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  };
  const WINDOWS_CHARS = {
    ...POSIX_CHARS,
    SLASH_LITERAL: `[${WIN_SLASH}]`,
    QMARK: WIN_NO_SLASH,
    STAR: `${WIN_NO_SLASH}*?`,
    DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
    NO_DOT: `(?!${DOT_LITERAL})`,
    NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
    NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
    START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
    END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
  };
  const POSIX_REGEX_SOURCE = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
  };
  constants$1 = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE,
    // regular expressions
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    // Replace globs with equivalent patterns to reduce parsing time.
    REPLACEMENTS: {
      "***": "*",
      "**/**": "**",
      "**/**/**": "**"
    },
    // Digits
    CHAR_0: 48,
    /* 0 */
    CHAR_9: 57,
    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: 65,
    /* A */
    CHAR_LOWERCASE_A: 97,
    /* a */
    CHAR_UPPERCASE_Z: 90,
    /* Z */
    CHAR_LOWERCASE_Z: 122,
    /* z */
    CHAR_LEFT_PARENTHESES: 40,
    /* ( */
    CHAR_RIGHT_PARENTHESES: 41,
    /* ) */
    CHAR_ASTERISK: 42,
    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: 38,
    /* & */
    CHAR_AT: 64,
    /* @ */
    CHAR_BACKWARD_SLASH: 92,
    /* \ */
    CHAR_CARRIAGE_RETURN: 13,
    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: 94,
    /* ^ */
    CHAR_COLON: 58,
    /* : */
    CHAR_COMMA: 44,
    /* , */
    CHAR_DOT: 46,
    /* . */
    CHAR_DOUBLE_QUOTE: 34,
    /* " */
    CHAR_EQUAL: 61,
    /* = */
    CHAR_EXCLAMATION_MARK: 33,
    /* ! */
    CHAR_FORM_FEED: 12,
    /* \f */
    CHAR_FORWARD_SLASH: 47,
    /* / */
    CHAR_GRAVE_ACCENT: 96,
    /* ` */
    CHAR_HASH: 35,
    /* # */
    CHAR_HYPHEN_MINUS: 45,
    /* - */
    CHAR_LEFT_ANGLE_BRACKET: 60,
    /* < */
    CHAR_LEFT_CURLY_BRACE: 123,
    /* { */
    CHAR_LEFT_SQUARE_BRACKET: 91,
    /* [ */
    CHAR_LINE_FEED: 10,
    /* \n */
    CHAR_NO_BREAK_SPACE: 160,
    /* \u00A0 */
    CHAR_PERCENT: 37,
    /* % */
    CHAR_PLUS: 43,
    /* + */
    CHAR_QUESTION_MARK: 63,
    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: 62,
    /* > */
    CHAR_RIGHT_CURLY_BRACE: 125,
    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: 93,
    /* ] */
    CHAR_SEMICOLON: 59,
    /* ; */
    CHAR_SINGLE_QUOTE: 39,
    /* ' */
    CHAR_SPACE: 32,
    /*   */
    CHAR_TAB: 9,
    /* \t */
    CHAR_UNDERSCORE: 95,
    /* _ */
    CHAR_VERTICAL_LINE: 124,
    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    /* \uFEFF */
    SEP: path2.sep,
    /**
     * Create EXTGLOB_CHARS
     */
    extglobChars(chars) {
      return {
        "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
        "?": { type: "qmark", open: "(?:", close: ")?" },
        "+": { type: "plus", open: "(?:", close: ")+" },
        "*": { type: "star", open: "(?:", close: ")*" },
        "@": { type: "at", open: "(?:", close: ")" }
      };
    },
    /**
     * Create GLOB_CHARS
     */
    globChars(win322) {
      return win322 === true ? WINDOWS_CHARS : POSIX_CHARS;
    }
  };
  return constants$1;
}
var hasRequiredUtils$2;
function requireUtils$2() {
  if (hasRequiredUtils$2) return utils$2;
  hasRequiredUtils$2 = 1;
  (function(exports) {
    const path2 = require$$1$3;
    const win322 = process.platform === "win32";
    const {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = requireConstants$1();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win322 === true || path2.sep === "\\";
    };
    exports.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1) return input;
      if (input[idx - 1] === "\\") return exports.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state = {}) => {
      let output2 = input;
      if (output2.startsWith("./")) {
        output2 = output2.slice(2);
        state.prefix = "./";
      }
      return output2;
    };
    exports.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append2 = options.contains ? "" : "$";
      let output2 = `${prepend}(?:${input})${append2}`;
      if (state.negated === true) {
        output2 = `(?:^(?!${output2}).*$)`;
      }
      return output2;
    };
  })(utils$2);
  return utils$2;
}
var scan_1;
var hasRequiredScan;
function requireScan() {
  if (hasRequiredScan) return scan_1;
  hasRequiredScan = 1;
  const utils2 = requireUtils$2();
  const {
    CHAR_ASTERISK,
    /* * */
    CHAR_AT,
    /* @ */
    CHAR_BACKWARD_SLASH,
    /* \ */
    CHAR_COMMA,
    /* , */
    CHAR_DOT,
    /* . */
    CHAR_EXCLAMATION_MARK,
    /* ! */
    CHAR_FORWARD_SLASH,
    /* / */
    CHAR_LEFT_CURLY_BRACE,
    /* { */
    CHAR_LEFT_PARENTHESES,
    /* ( */
    CHAR_LEFT_SQUARE_BRACKET,
    /* [ */
    CHAR_PLUS,
    /* + */
    CHAR_QUESTION_MARK,
    /* ? */
    CHAR_RIGHT_CURLY_BRACE,
    /* } */
    CHAR_RIGHT_PARENTHESES,
    /* ) */
    CHAR_RIGHT_SQUARE_BRACKET
    /* ] */
  } = requireConstants$1();
  const isPathSeparator = (code) => {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  };
  const depth = (token) => {
    if (token.isPrefix !== true) {
      token.depth = token.isGlobstar ? Infinity : 1;
    }
  };
  const scan = (input, options) => {
    const opts = options || {};
    const length = input.length - 1;
    const scanToEnd = opts.parts === true || opts.scanToEnd === true;
    const slashes = [];
    const tokens = [];
    const parts = [];
    let str = input;
    let index2 = -1;
    let start = 0;
    let lastIndex = 0;
    let isBrace = false;
    let isBracket = false;
    let isGlob2 = false;
    let isExtglob2 = false;
    let isGlobstar = false;
    let braceEscaped = false;
    let backslashes = false;
    let negated = false;
    let negatedExtglob = false;
    let finished = false;
    let braces = 0;
    let prev;
    let code;
    let token = { value: "", depth: 0, isGlob: false };
    const eos = () => index2 >= length;
    const peek = () => str.charCodeAt(index2 + 1);
    const advance = () => {
      prev = code;
      return str.charCodeAt(++index2);
    };
    while (index2 < length) {
      code = advance();
      let next;
      if (code === CHAR_BACKWARD_SLASH) {
        backslashes = token.backslashes = true;
        code = advance();
        if (code === CHAR_LEFT_CURLY_BRACE) {
          braceEscaped = true;
        }
        continue;
      }
      if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
        braces++;
        while (eos() !== true && (code = advance())) {
          if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            continue;
          }
          if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
            isBrace = token.isBrace = true;
            isGlob2 = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (braceEscaped !== true && code === CHAR_COMMA) {
            isBrace = token.isBrace = true;
            isGlob2 = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_RIGHT_CURLY_BRACE) {
            braces--;
            if (braces === 0) {
              braceEscaped = false;
              isBrace = token.isBrace = true;
              finished = true;
              break;
            }
          }
        }
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_FORWARD_SLASH) {
        slashes.push(index2);
        tokens.push(token);
        token = { value: "", depth: 0, isGlob: false };
        if (finished === true) continue;
        if (prev === CHAR_DOT && index2 === start + 1) {
          start += 2;
          continue;
        }
        lastIndex = index2 + 1;
        continue;
      }
      if (opts.noext !== true) {
        const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
        if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
          isGlob2 = token.isGlob = true;
          isExtglob2 = token.isExtglob = true;
          finished = true;
          if (code === CHAR_EXCLAMATION_MARK && index2 === start) {
            negatedExtglob = true;
          }
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                isGlob2 = token.isGlob = true;
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
      }
      if (code === CHAR_ASTERISK) {
        if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
        isGlob2 = token.isGlob = true;
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_QUESTION_MARK) {
        isGlob2 = token.isGlob = true;
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_LEFT_SQUARE_BRACKET) {
        while (eos() !== true && (next = advance())) {
          if (next === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            isBracket = token.isBracket = true;
            isGlob2 = token.isGlob = true;
            finished = true;
            break;
          }
        }
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index2 === start) {
        negated = token.negated = true;
        start++;
        continue;
      }
      if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
        isGlob2 = token.isGlob = true;
        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_LEFT_PARENTHESES) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }
            if (code === CHAR_RIGHT_PARENTHESES) {
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (isGlob2 === true) {
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
    }
    if (opts.noext === true) {
      isExtglob2 = false;
      isGlob2 = false;
    }
    let base = str;
    let prefix = "";
    let glob = "";
    if (start > 0) {
      prefix = str.slice(0, start);
      str = str.slice(start);
      lastIndex -= start;
    }
    if (base && isGlob2 === true && lastIndex > 0) {
      base = str.slice(0, lastIndex);
      glob = str.slice(lastIndex);
    } else if (isGlob2 === true) {
      base = "";
      glob = str;
    } else {
      base = str;
    }
    if (base && base !== "" && base !== "/" && base !== str) {
      if (isPathSeparator(base.charCodeAt(base.length - 1))) {
        base = base.slice(0, -1);
      }
    }
    if (opts.unescape === true) {
      if (glob) glob = utils2.removeBackslashes(glob);
      if (base && backslashes === true) {
        base = utils2.removeBackslashes(base);
      }
    }
    const state = {
      prefix,
      input,
      start,
      base,
      glob,
      isBrace,
      isBracket,
      isGlob: isGlob2,
      isExtglob: isExtglob2,
      isGlobstar,
      negated,
      negatedExtglob
    };
    if (opts.tokens === true) {
      state.maxDepth = 0;
      if (!isPathSeparator(code)) {
        tokens.push(token);
      }
      state.tokens = tokens;
    }
    if (opts.parts === true || opts.tokens === true) {
      let prevIndex;
      for (let idx = 0; idx < slashes.length; idx++) {
        const n = prevIndex ? prevIndex + 1 : start;
        const i = slashes[idx];
        const value = input.slice(n, i);
        if (opts.tokens) {
          if (idx === 0 && start !== 0) {
            tokens[idx].isPrefix = true;
            tokens[idx].value = prefix;
          } else {
            tokens[idx].value = value;
          }
          depth(tokens[idx]);
          state.maxDepth += tokens[idx].depth;
        }
        if (idx !== 0 || value !== "") {
          parts.push(value);
        }
        prevIndex = i;
      }
      if (prevIndex && prevIndex + 1 < input.length) {
        const value = input.slice(prevIndex + 1);
        parts.push(value);
        if (opts.tokens) {
          tokens[tokens.length - 1].value = value;
          depth(tokens[tokens.length - 1]);
          state.maxDepth += tokens[tokens.length - 1].depth;
        }
      }
      state.slashes = slashes;
      state.parts = parts;
    }
    return state;
  };
  scan_1 = scan;
  return scan_1;
}
var parse_1;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse_1;
  hasRequiredParse = 1;
  const constants2 = requireConstants$1();
  const utils2 = requireUtils$2();
  const {
    MAX_LENGTH,
    POSIX_REGEX_SOURCE,
    REGEX_NON_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_BACKREF,
    REPLACEMENTS
  } = constants2;
  const expandRange = (args, options) => {
    if (typeof options.expandRange === "function") {
      return options.expandRange(...args, options);
    }
    args.sort();
    const value = `[${args.join("-")}]`;
    try {
      new RegExp(value);
    } catch (ex) {
      return args.map((v) => utils2.escapeRegex(v)).join("..");
    }
    return value;
  };
  const syntaxError = (type2, char) => {
    return `Missing ${type2}: "${char}" - use "\\\\${char}" to match literal characters`;
  };
  const parse2 = (input, options) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected a string");
    }
    input = REPLACEMENTS[input] || input;
    const opts = { ...options };
    const max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    let len = input.length;
    if (len > max2) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
    }
    const bos = { type: "bos", value: "", output: opts.prepend || "" };
    const tokens = [bos];
    const capture = opts.capture ? "" : "?:";
    const win322 = utils2.isWindows(options);
    const PLATFORM_CHARS = constants2.globChars(win322);
    const EXTGLOB_CHARS = constants2.extglobChars(PLATFORM_CHARS);
    const {
      DOT_LITERAL,
      PLUS_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    } = PLATFORM_CHARS;
    const globstar = (opts2) => {
      return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const nodot = opts.dot ? "" : NO_DOT;
    const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    let star = opts.bash === true ? globstar(opts) : STAR;
    if (opts.capture) {
      star = `(${star})`;
    }
    if (typeof opts.noext === "boolean") {
      opts.noextglob = opts.noext;
    }
    const state = {
      input,
      index: -1,
      start: 0,
      dot: opts.dot === true,
      consumed: "",
      output: "",
      prefix: "",
      backtrack: false,
      negated: false,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: false,
      tokens
    };
    input = utils2.removePrefix(input, state);
    len = input.length;
    const extglobs = [];
    const braces = [];
    const stack = [];
    let prev = bos;
    let value;
    const eos = () => state.index === len - 1;
    const peek = state.peek = (n = 1) => input[state.index + n];
    const advance = state.advance = () => input[++state.index] || "";
    const remaining = () => input.slice(state.index + 1);
    const consume = (value2 = "", num = 0) => {
      state.consumed += value2;
      state.index += num;
    };
    const append2 = (token) => {
      state.output += token.output != null ? token.output : token.value;
      consume(token.value);
    };
    const negate = () => {
      let count = 1;
      while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
        advance();
        state.start++;
        count++;
      }
      if (count % 2 === 0) {
        return false;
      }
      state.negated = true;
      state.start++;
      return true;
    };
    const increment = (type2) => {
      state[type2]++;
      stack.push(type2);
    };
    const decrement = (type2) => {
      state[type2]--;
      stack.pop();
    };
    const push = (tok) => {
      if (prev.type === "globstar") {
        const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
        const isExtglob2 = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
        if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob2) {
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "star";
          prev.value = "*";
          prev.output = star;
          state.output += prev.output;
        }
      }
      if (extglobs.length && tok.type !== "paren") {
        extglobs[extglobs.length - 1].inner += tok.value;
      }
      if (tok.value || tok.output) append2(tok);
      if (prev && prev.type === "text" && tok.type === "text") {
        prev.value += tok.value;
        prev.output = (prev.output || "") + tok.value;
        return;
      }
      tok.prev = prev;
      tokens.push(tok);
      prev = tok;
    };
    const extglobOpen = (type2, value2) => {
      const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
      token.prev = prev;
      token.parens = state.parens;
      token.output = state.output;
      const output2 = (opts.capture ? "(" : "") + token.open;
      increment("parens");
      push({ type: type2, value: value2, output: state.output ? "" : ONE_CHAR });
      push({ type: "paren", extglob: true, value: advance(), output: output2 });
      extglobs.push(token);
    };
    const extglobClose = (token) => {
      let output2 = token.close + (opts.capture ? ")" : "");
      let rest;
      if (token.type === "negate") {
        let extglobStar = star;
        if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
          extglobStar = globstar(opts);
        }
        if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
          output2 = token.close = `)$))${extglobStar}`;
        }
        if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
          const expression = parse2(rest, { ...options, fastpaths: false }).output;
          output2 = token.close = `)${expression})${extglobStar})`;
        }
        if (token.prev.type === "bos") {
          state.negatedExtglob = true;
        }
      }
      push({ type: "paren", extglob: true, value, output: output2 });
      decrement("parens");
    };
    if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
      let backslashes = false;
      let output2 = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index2) => {
        if (first === "\\") {
          backslashes = true;
          return m;
        }
        if (first === "?") {
          if (esc) {
            return esc + first + (rest ? QMARK.repeat(rest.length) : "");
          }
          if (index2 === 0) {
            return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
          }
          return QMARK.repeat(chars.length);
        }
        if (first === ".") {
          return DOT_LITERAL.repeat(chars.length);
        }
        if (first === "*") {
          if (esc) {
            return esc + first + (rest ? star : "");
          }
          return star;
        }
        return esc ? m : `\\${m}`;
      });
      if (backslashes === true) {
        if (opts.unescape === true) {
          output2 = output2.replace(/\\/g, "");
        } else {
          output2 = output2.replace(/\\+/g, (m) => {
            return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
          });
        }
      }
      if (output2 === input && opts.contains === true) {
        state.output = input;
        return state;
      }
      state.output = utils2.wrapOutput(output2, state, options);
      return state;
    }
    while (!eos()) {
      value = advance();
      if (value === "\0") {
        continue;
      }
      if (value === "\\") {
        const next = peek();
        if (next === "/" && opts.bash !== true) {
          continue;
        }
        if (next === "." || next === ";") {
          continue;
        }
        if (!next) {
          value += "\\";
          push({ type: "text", value });
          continue;
        }
        const match = /^\\+/.exec(remaining());
        let slashes = 0;
        if (match && match[0].length > 2) {
          slashes = match[0].length;
          state.index += slashes;
          if (slashes % 2 !== 0) {
            value += "\\";
          }
        }
        if (opts.unescape === true) {
          value = advance();
        } else {
          value += advance();
        }
        if (state.brackets === 0) {
          push({ type: "text", value });
          continue;
        }
      }
      if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
        if (opts.posix !== false && value === ":") {
          const inner = prev.value.slice(1);
          if (inner.includes("[")) {
            prev.posix = true;
            if (inner.includes(":")) {
              const idx = prev.value.lastIndexOf("[");
              const pre = prev.value.slice(0, idx);
              const rest2 = prev.value.slice(idx + 2);
              const posix = POSIX_REGEX_SOURCE[rest2];
              if (posix) {
                prev.value = pre + posix;
                state.backtrack = true;
                advance();
                if (!bos.output && tokens.indexOf(prev) === 1) {
                  bos.output = ONE_CHAR;
                }
                continue;
              }
            }
          }
        }
        if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
          value = `\\${value}`;
        }
        if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
          value = `\\${value}`;
        }
        if (opts.posix === true && value === "!" && prev.value === "[") {
          value = "^";
        }
        prev.value += value;
        append2({ value });
        continue;
      }
      if (state.quotes === 1 && value !== '"') {
        value = utils2.escapeRegex(value);
        prev.value += value;
        append2({ value });
        continue;
      }
      if (value === '"') {
        state.quotes = state.quotes === 1 ? 0 : 1;
        if (opts.keepQuotes === true) {
          push({ type: "text", value });
        }
        continue;
      }
      if (value === "(") {
        increment("parens");
        push({ type: "paren", value });
        continue;
      }
      if (value === ")") {
        if (state.parens === 0 && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError("opening", "("));
        }
        const extglob = extglobs[extglobs.length - 1];
        if (extglob && state.parens === extglob.parens + 1) {
          extglobClose(extglobs.pop());
          continue;
        }
        push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
        decrement("parens");
        continue;
      }
      if (value === "[") {
        if (opts.nobracket === true || !remaining().includes("]")) {
          if (opts.nobracket !== true && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("closing", "]"));
          }
          value = `\\${value}`;
        } else {
          increment("brackets");
        }
        push({ type: "bracket", value });
        continue;
      }
      if (value === "]") {
        if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
          push({ type: "text", value, output: `\\${value}` });
          continue;
        }
        if (state.brackets === 0) {
          if (opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "["));
          }
          push({ type: "text", value, output: `\\${value}` });
          continue;
        }
        decrement("brackets");
        const prevValue = prev.value.slice(1);
        if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
          value = `/${value}`;
        }
        prev.value += value;
        append2({ value });
        if (opts.literalBrackets === false || utils2.hasRegexChars(prevValue)) {
          continue;
        }
        const escaped = utils2.escapeRegex(prev.value);
        state.output = state.output.slice(0, -prev.value.length);
        if (opts.literalBrackets === true) {
          state.output += escaped;
          prev.value = escaped;
          continue;
        }
        prev.value = `(${capture}${escaped}|${prev.value})`;
        state.output += prev.value;
        continue;
      }
      if (value === "{" && opts.nobrace !== true) {
        increment("braces");
        const open = {
          type: "brace",
          value,
          output: "(",
          outputIndex: state.output.length,
          tokensIndex: state.tokens.length
        };
        braces.push(open);
        push(open);
        continue;
      }
      if (value === "}") {
        const brace = braces[braces.length - 1];
        if (opts.nobrace === true || !brace) {
          push({ type: "text", value, output: value });
          continue;
        }
        let output2 = ")";
        if (brace.dots === true) {
          const arr = tokens.slice();
          const range2 = [];
          for (let i = arr.length - 1; i >= 0; i--) {
            tokens.pop();
            if (arr[i].type === "brace") {
              break;
            }
            if (arr[i].type !== "dots") {
              range2.unshift(arr[i].value);
            }
          }
          output2 = expandRange(range2, opts);
          state.backtrack = true;
        }
        if (brace.comma !== true && brace.dots !== true) {
          const out = state.output.slice(0, brace.outputIndex);
          const toks = state.tokens.slice(brace.tokensIndex);
          brace.value = brace.output = "\\{";
          value = output2 = "\\}";
          state.output = out;
          for (const t of toks) {
            state.output += t.output || t.value;
          }
        }
        push({ type: "brace", value, output: output2 });
        decrement("braces");
        braces.pop();
        continue;
      }
      if (value === "|") {
        if (extglobs.length > 0) {
          extglobs[extglobs.length - 1].conditions++;
        }
        push({ type: "text", value });
        continue;
      }
      if (value === ",") {
        let output2 = value;
        const brace = braces[braces.length - 1];
        if (brace && stack[stack.length - 1] === "braces") {
          brace.comma = true;
          output2 = "|";
        }
        push({ type: "comma", value, output: output2 });
        continue;
      }
      if (value === "/") {
        if (prev.type === "dot" && state.index === state.start + 1) {
          state.start = state.index + 1;
          state.consumed = "";
          state.output = "";
          tokens.pop();
          prev = bos;
          continue;
        }
        push({ type: "slash", value, output: SLASH_LITERAL });
        continue;
      }
      if (value === ".") {
        if (state.braces > 0 && prev.type === "dot") {
          if (prev.value === ".") prev.output = DOT_LITERAL;
          const brace = braces[braces.length - 1];
          prev.type = "dots";
          prev.output += value;
          prev.value += value;
          brace.dots = true;
          continue;
        }
        if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
          push({ type: "text", value, output: DOT_LITERAL });
          continue;
        }
        push({ type: "dot", value, output: DOT_LITERAL });
        continue;
      }
      if (value === "?") {
        const isGroup = prev && prev.value === "(";
        if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          extglobOpen("qmark", value);
          continue;
        }
        if (prev && prev.type === "paren") {
          const next = peek();
          let output2 = value;
          if (next === "<" && !utils2.supportsLookbehinds()) {
            throw new Error("Node.js v10 or higher is required for regex lookbehinds");
          }
          if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
            output2 = `\\${value}`;
          }
          push({ type: "text", value, output: output2 });
          continue;
        }
        if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
          push({ type: "qmark", value, output: QMARK_NO_DOT });
          continue;
        }
        push({ type: "qmark", value, output: QMARK });
        continue;
      }
      if (value === "!") {
        if (opts.noextglob !== true && peek() === "(") {
          if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
            extglobOpen("negate", value);
            continue;
          }
        }
        if (opts.nonegate !== true && state.index === 0) {
          negate();
          continue;
        }
      }
      if (value === "+") {
        if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          extglobOpen("plus", value);
          continue;
        }
        if (prev && prev.value === "(" || opts.regex === false) {
          push({ type: "plus", value, output: PLUS_LITERAL });
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
          push({ type: "plus", value });
          continue;
        }
        push({ type: "plus", value: PLUS_LITERAL });
        continue;
      }
      if (value === "@") {
        if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          push({ type: "at", extglob: true, value, output: "" });
          continue;
        }
        push({ type: "text", value });
        continue;
      }
      if (value !== "*") {
        if (value === "$" || value === "^") {
          value = `\\${value}`;
        }
        const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
        if (match) {
          value += match[0];
          state.index += match[0].length;
        }
        push({ type: "text", value });
        continue;
      }
      if (prev && (prev.type === "globstar" || prev.star === true)) {
        prev.type = "star";
        prev.star = true;
        prev.value += value;
        prev.output = star;
        state.backtrack = true;
        state.globstar = true;
        consume(value);
        continue;
      }
      let rest = remaining();
      if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
        extglobOpen("star", value);
        continue;
      }
      if (prev.type === "star") {
        if (opts.noglobstar === true) {
          consume(value);
          continue;
        }
        const prior = prev.prev;
        const before = prior.prev;
        const isStart = prior.type === "slash" || prior.type === "bos";
        const afterStar = before && (before.type === "star" || before.type === "globstar");
        if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
          push({ type: "star", value, output: "" });
          continue;
        }
        const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
        const isExtglob2 = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
        if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob2) {
          push({ type: "star", value, output: "" });
          continue;
        }
        while (rest.slice(0, 3) === "/**") {
          const after = input[state.index + 4];
          if (after && after !== "/") {
            break;
          }
          rest = rest.slice(3);
          consume("/**", 3);
        }
        if (prior.type === "bos" && eos()) {
          prev.type = "globstar";
          prev.value += value;
          prev.output = globstar(opts);
          state.output = prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = "globstar";
          prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
          prev.value += value;
          state.globstar = true;
          state.output += prior.output + prev.output;
          consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
          const end = rest[1] !== void 0 ? "|$" : "";
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = "globstar";
          prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
          prev.value += value;
          state.output += prior.output + prev.output;
          state.globstar = true;
          consume(value + advance());
          push({ type: "slash", value: "/", output: "" });
          continue;
        }
        if (prior.type === "bos" && rest[0] === "/") {
          prev.type = "globstar";
          prev.value += value;
          prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
          state.output = prev.output;
          state.globstar = true;
          consume(value + advance());
          push({ type: "slash", value: "/", output: "" });
          continue;
        }
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = "globstar";
        prev.output = globstar(opts);
        prev.value += value;
        state.output += prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }
      const token = { type: "star", value, output: star };
      if (opts.bash === true) {
        token.output = ".*?";
        if (prev.type === "bos" || prev.type === "slash") {
          token.output = nodot + token.output;
        }
        push(token);
        continue;
      }
      if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
        token.output = value;
        push(token);
        continue;
      }
      if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
        if (prev.type === "dot") {
          state.output += NO_DOT_SLASH;
          prev.output += NO_DOT_SLASH;
        } else if (opts.dot === true) {
          state.output += NO_DOTS_SLASH;
          prev.output += NO_DOTS_SLASH;
        } else {
          state.output += nodot;
          prev.output += nodot;
        }
        if (peek() !== "*") {
          state.output += ONE_CHAR;
          prev.output += ONE_CHAR;
        }
      }
      push(token);
    }
    while (state.brackets > 0) {
      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
      state.output = utils2.escapeLast(state.output, "[");
      decrement("brackets");
    }
    while (state.parens > 0) {
      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
      state.output = utils2.escapeLast(state.output, "(");
      decrement("parens");
    }
    while (state.braces > 0) {
      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
      state.output = utils2.escapeLast(state.output, "{");
      decrement("braces");
    }
    if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
      push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
    }
    if (state.backtrack === true) {
      state.output = "";
      for (const token of state.tokens) {
        state.output += token.output != null ? token.output : token.value;
        if (token.suffix) {
          state.output += token.suffix;
        }
      }
    }
    return state;
  };
  parse2.fastpaths = (input, options) => {
    const opts = { ...options };
    const max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    const len = input.length;
    if (len > max2) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
    }
    input = REPLACEMENTS[input] || input;
    const win322 = utils2.isWindows(options);
    const {
      DOT_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOTS_SLASH,
      STAR,
      START_ANCHOR
    } = constants2.globChars(win322);
    const nodot = opts.dot ? NO_DOTS : NO_DOT;
    const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
    const capture = opts.capture ? "" : "?:";
    const state = { negated: false, prefix: "" };
    let star = opts.bash === true ? ".*?" : STAR;
    if (opts.capture) {
      star = `(${star})`;
    }
    const globstar = (opts2) => {
      if (opts2.noglobstar === true) return star;
      return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const create = (str) => {
      switch (str) {
        case "*":
          return `${nodot}${ONE_CHAR}${star}`;
        case ".*":
          return `${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "*.*":
          return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "*/*":
          return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
        case "**":
          return nodot + globstar(opts);
        case "**/*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
        case "**/*.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "**/.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
        default: {
          const match = /^(.*?)\.(\w+)$/.exec(str);
          if (!match) return;
          const source2 = create(match[1]);
          if (!source2) return;
          return source2 + DOT_LITERAL + match[2];
        }
      }
    };
    const output2 = utils2.removePrefix(input, state);
    let source = create(output2);
    if (source && opts.strictSlashes !== true) {
      source += `${SLASH_LITERAL}?`;
    }
    return source;
  };
  parse_1 = parse2;
  return parse_1;
}
var picomatch_1;
var hasRequiredPicomatch$1;
function requirePicomatch$1() {
  if (hasRequiredPicomatch$1) return picomatch_1;
  hasRequiredPicomatch$1 = 1;
  const path2 = require$$1$3;
  const scan = requireScan();
  const parse2 = requireParse();
  const utils2 = requireUtils$2();
  const constants2 = requireConstants$1();
  const isObject2 = (val) => val && typeof val === "object" && !Array.isArray(val);
  const picomatch2 = (glob, options, returnState = false) => {
    if (Array.isArray(glob)) {
      const fns = glob.map((input) => picomatch2(input, options, returnState));
      const arrayMatcher = (str) => {
        for (const isMatch of fns) {
          const state2 = isMatch(str);
          if (state2) return state2;
        }
        return false;
      };
      return arrayMatcher;
    }
    const isState = isObject2(glob) && glob.tokens && glob.input;
    if (glob === "" || typeof glob !== "string" && !isState) {
      throw new TypeError("Expected pattern to be a non-empty string");
    }
    const opts = options || {};
    const posix = utils2.isWindows(options);
    const regex2 = isState ? picomatch2.compileRe(glob, options) : picomatch2.makeRe(glob, options, false, true);
    const state = regex2.state;
    delete regex2.state;
    let isIgnored = () => false;
    if (opts.ignore) {
      const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
      isIgnored = picomatch2(opts.ignore, ignoreOpts, returnState);
    }
    const matcher = (input, returnObject = false) => {
      const { isMatch, match, output: output2 } = picomatch2.test(input, regex2, options, { glob, posix });
      const result = { glob, state, regex: regex2, posix, input, output: output2, match, isMatch };
      if (typeof opts.onResult === "function") {
        opts.onResult(result);
      }
      if (isMatch === false) {
        result.isMatch = false;
        return returnObject ? result : false;
      }
      if (isIgnored(input)) {
        if (typeof opts.onIgnore === "function") {
          opts.onIgnore(result);
        }
        result.isMatch = false;
        return returnObject ? result : false;
      }
      if (typeof opts.onMatch === "function") {
        opts.onMatch(result);
      }
      return returnObject ? result : true;
    };
    if (returnState) {
      matcher.state = state;
    }
    return matcher;
  };
  picomatch2.test = (input, regex2, options, { glob, posix } = {}) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected input to be a string");
    }
    if (input === "") {
      return { isMatch: false, output: "" };
    }
    const opts = options || {};
    const format = opts.format || (posix ? utils2.toPosixSlashes : null);
    let match = input === glob;
    let output2 = match && format ? format(input) : input;
    if (match === false) {
      output2 = format ? format(input) : input;
      match = output2 === glob;
    }
    if (match === false || opts.capture === true) {
      if (opts.matchBase === true || opts.basename === true) {
        match = picomatch2.matchBase(input, regex2, options, posix);
      } else {
        match = regex2.exec(output2);
      }
    }
    return { isMatch: Boolean(match), match, output: output2 };
  };
  picomatch2.matchBase = (input, glob, options, posix = utils2.isWindows(options)) => {
    const regex2 = glob instanceof RegExp ? glob : picomatch2.makeRe(glob, options);
    return regex2.test(path2.basename(input));
  };
  picomatch2.isMatch = (str, patterns, options) => picomatch2(patterns, options)(str);
  picomatch2.parse = (pattern, options) => {
    if (Array.isArray(pattern)) return pattern.map((p) => picomatch2.parse(p, options));
    return parse2(pattern, { ...options, fastpaths: false });
  };
  picomatch2.scan = (input, options) => scan(input, options);
  picomatch2.compileRe = (state, options, returnOutput = false, returnState = false) => {
    if (returnOutput === true) {
      return state.output;
    }
    const opts = options || {};
    const prepend = opts.contains ? "" : "^";
    const append2 = opts.contains ? "" : "$";
    let source = `${prepend}(?:${state.output})${append2}`;
    if (state && state.negated === true) {
      source = `^(?!${source}).*$`;
    }
    const regex2 = picomatch2.toRegex(source, options);
    if (returnState === true) {
      regex2.state = state;
    }
    return regex2;
  };
  picomatch2.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
    if (!input || typeof input !== "string") {
      throw new TypeError("Expected a non-empty string");
    }
    let parsed = { negated: false, fastpaths: true };
    if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
      parsed.output = parse2.fastpaths(input, options);
    }
    if (!parsed.output) {
      parsed = parse2(input, options);
    }
    return picomatch2.compileRe(parsed, options, returnOutput, returnState);
  };
  picomatch2.toRegex = (source, options) => {
    try {
      const opts = options || {};
      return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
    } catch (err) {
      if (options && options.debug === true) throw err;
      return /$^/;
    }
  };
  picomatch2.constants = constants2;
  picomatch_1 = picomatch2;
  return picomatch_1;
}
var picomatch;
var hasRequiredPicomatch;
function requirePicomatch() {
  if (hasRequiredPicomatch) return picomatch;
  hasRequiredPicomatch = 1;
  picomatch = requirePicomatch$1();
  return picomatch;
}
var micromatch_1;
var hasRequiredMicromatch;
function requireMicromatch() {
  if (hasRequiredMicromatch) return micromatch_1;
  hasRequiredMicromatch = 1;
  const util2 = require$$0$5;
  const braces = requireBraces();
  const picomatch2 = requirePicomatch();
  const utils2 = requireUtils$2();
  const isEmptyString = (v) => v === "" || v === "./";
  const hasBraces = (v) => {
    const index2 = v.indexOf("{");
    return index2 > -1 && v.indexOf("}", index2) > -1;
  };
  const micromatch = (list, patterns, options) => {
    patterns = [].concat(patterns);
    list = [].concat(list);
    let omit = /* @__PURE__ */ new Set();
    let keep = /* @__PURE__ */ new Set();
    let items = /* @__PURE__ */ new Set();
    let negatives = 0;
    let onResult = (state) => {
      items.add(state.output);
      if (options && options.onResult) {
        options.onResult(state);
      }
    };
    for (let i = 0; i < patterns.length; i++) {
      let isMatch = picomatch2(String(patterns[i]), { ...options, onResult }, true);
      let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
      if (negated) negatives++;
      for (let item of list) {
        let matched = isMatch(item, true);
        let match = negated ? !matched.isMatch : matched.isMatch;
        if (!match) continue;
        if (negated) {
          omit.add(matched.output);
        } else {
          omit.delete(matched.output);
          keep.add(matched.output);
        }
      }
    }
    let result = negatives === patterns.length ? [...items] : [...keep];
    let matches = result.filter((item) => !omit.has(item));
    if (options && matches.length === 0) {
      if (options.failglob === true) {
        throw new Error(`No matches found for "${patterns.join(", ")}"`);
      }
      if (options.nonull === true || options.nullglob === true) {
        return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
      }
    }
    return matches;
  };
  micromatch.match = micromatch;
  micromatch.matcher = (pattern, options) => picomatch2(pattern, options);
  micromatch.isMatch = (str, patterns, options) => picomatch2(patterns, options)(str);
  micromatch.any = micromatch.isMatch;
  micromatch.not = (list, patterns, options = {}) => {
    patterns = [].concat(patterns).map(String);
    let result = /* @__PURE__ */ new Set();
    let items = [];
    let onResult = (state) => {
      if (options.onResult) options.onResult(state);
      items.push(state.output);
    };
    let matches = new Set(micromatch(list, patterns, { ...options, onResult }));
    for (let item of items) {
      if (!matches.has(item)) {
        result.add(item);
      }
    }
    return [...result];
  };
  micromatch.contains = (str, pattern, options) => {
    if (typeof str !== "string") {
      throw new TypeError(`Expected a string: "${util2.inspect(str)}"`);
    }
    if (Array.isArray(pattern)) {
      return pattern.some((p) => micromatch.contains(str, p, options));
    }
    if (typeof pattern === "string") {
      if (isEmptyString(str) || isEmptyString(pattern)) {
        return false;
      }
      if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
        return true;
      }
    }
    return micromatch.isMatch(str, pattern, { ...options, contains: true });
  };
  micromatch.matchKeys = (obj, patterns, options) => {
    if (!utils2.isObject(obj)) {
      throw new TypeError("Expected the first argument to be an object");
    }
    let keys = micromatch(Object.keys(obj), patterns, options);
    let res = {};
    for (let key of keys) res[key] = obj[key];
    return res;
  };
  micromatch.some = (list, patterns, options) => {
    let items = [].concat(list);
    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch2(String(pattern), options);
      if (items.some((item) => isMatch(item))) {
        return true;
      }
    }
    return false;
  };
  micromatch.every = (list, patterns, options) => {
    let items = [].concat(list);
    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch2(String(pattern), options);
      if (!items.every((item) => isMatch(item))) {
        return false;
      }
    }
    return true;
  };
  micromatch.all = (str, patterns, options) => {
    if (typeof str !== "string") {
      throw new TypeError(`Expected a string: "${util2.inspect(str)}"`);
    }
    return [].concat(patterns).every((p) => picomatch2(p, options)(str));
  };
  micromatch.capture = (glob, input, options) => {
    let posix = utils2.isWindows(options);
    let regex2 = picomatch2.makeRe(String(glob), { ...options, capture: true });
    let match = regex2.exec(posix ? utils2.toPosixSlashes(input) : input);
    if (match) {
      return match.slice(1).map((v) => v === void 0 ? "" : v);
    }
  };
  micromatch.makeRe = (...args) => picomatch2.makeRe(...args);
  micromatch.scan = (...args) => picomatch2.scan(...args);
  micromatch.parse = (patterns, options) => {
    let res = [];
    for (let pattern of [].concat(patterns || [])) {
      for (let str of braces(String(pattern), options)) {
        res.push(picomatch2.parse(str, options));
      }
    }
    return res;
  };
  micromatch.braces = (pattern, options) => {
    if (typeof pattern !== "string") throw new TypeError("Expected a string");
    if (options && options.nobrace === true || !hasBraces(pattern)) {
      return [pattern];
    }
    return braces(pattern, options);
  };
  micromatch.braceExpand = (pattern, options) => {
    if (typeof pattern !== "string") throw new TypeError("Expected a string");
    return micromatch.braces(pattern, { ...options, expand: true });
  };
  micromatch.hasBraces = hasBraces;
  micromatch_1 = micromatch;
  return micromatch_1;
}
var hasRequiredPathFilter;
function requirePathFilter() {
  if (hasRequiredPathFilter) return pathFilter;
  hasRequiredPathFilter = 1;
  Object.defineProperty(pathFilter, "__esModule", { value: true });
  pathFilter.matchPathFilter = matchPathFilter;
  const isGlob2 = requireIsGlob();
  const micromatch = requireMicromatch();
  const url = require$$0$6;
  const errors_1 = requireErrors();
  function matchPathFilter(pathFilter2 = "/", uri2, req) {
    if (isStringPath(pathFilter2)) {
      return matchSingleStringPath(pathFilter2, uri2);
    }
    if (isGlobPath(pathFilter2)) {
      return matchSingleGlobPath(pathFilter2, uri2);
    }
    if (Array.isArray(pathFilter2)) {
      if (pathFilter2.every(isStringPath)) {
        return matchMultiPath(pathFilter2, uri2);
      }
      if (pathFilter2.every(isGlobPath)) {
        return matchMultiGlobPath(pathFilter2, uri2);
      }
      throw new Error(errors_1.ERRORS.ERR_CONTEXT_MATCHER_INVALID_ARRAY);
    }
    if (typeof pathFilter2 === "function") {
      const pathname = getUrlPathName(uri2);
      return pathFilter2(pathname, req);
    }
    throw new Error(errors_1.ERRORS.ERR_CONTEXT_MATCHER_GENERIC);
  }
  function matchSingleStringPath(pathFilter2, uri2) {
    const pathname = getUrlPathName(uri2);
    return pathname?.indexOf(pathFilter2) === 0;
  }
  function matchSingleGlobPath(pattern, uri2) {
    const pathname = getUrlPathName(uri2);
    const matches = micromatch([pathname], pattern);
    return matches && matches.length > 0;
  }
  function matchMultiGlobPath(patternList, uri2) {
    return matchSingleGlobPath(patternList, uri2);
  }
  function matchMultiPath(pathFilterList, uri2) {
    let isMultiPath = false;
    for (const context of pathFilterList) {
      if (matchSingleStringPath(context, uri2)) {
        isMultiPath = true;
        break;
      }
    }
    return isMultiPath;
  }
  function getUrlPathName(uri2) {
    return uri2 && url.parse(uri2).pathname;
  }
  function isStringPath(pathFilter2) {
    return typeof pathFilter2 === "string" && !isGlob2(pathFilter2);
  }
  function isGlobPath(pathFilter2) {
    return isGlob2(pathFilter2);
  }
  return pathFilter;
}
var pathRewriter = {};
var isPlainObject = {};
var hasRequiredIsPlainObject;
function requireIsPlainObject() {
  if (hasRequiredIsPlainObject) return isPlainObject;
  hasRequiredIsPlainObject = 1;
  Object.defineProperty(isPlainObject, "__esModule", { value: true });
  /*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  function isObject2(o) {
    return Object.prototype.toString.call(o) === "[object Object]";
  }
  function isPlainObject$12(o) {
    var ctor, prot;
    if (isObject2(o) === false) return false;
    ctor = o.constructor;
    if (ctor === void 0) return true;
    prot = ctor.prototype;
    if (isObject2(prot) === false) return false;
    if (prot.hasOwnProperty("isPrototypeOf") === false) {
      return false;
    }
    return true;
  }
  isPlainObject.isPlainObject = isPlainObject$12;
  return isPlainObject;
}
var hasRequiredPathRewriter;
function requirePathRewriter() {
  if (hasRequiredPathRewriter) return pathRewriter;
  hasRequiredPathRewriter = 1;
  Object.defineProperty(pathRewriter, "__esModule", { value: true });
  pathRewriter.createPathRewriter = createPathRewriter;
  const is_plain_object_1 = requireIsPlainObject();
  const errors_1 = requireErrors();
  const debug_12 = requireDebug();
  const debug2 = debug_12.Debug.extend("path-rewriter");
  function createPathRewriter(rewriteConfig) {
    let rulesCache;
    if (!isValidRewriteConfig(rewriteConfig)) {
      return;
    }
    if (typeof rewriteConfig === "function") {
      const customRewriteFn = rewriteConfig;
      return customRewriteFn;
    } else {
      rulesCache = parsePathRewriteRules(rewriteConfig);
      return rewritePath;
    }
    function rewritePath(path2) {
      let result = path2;
      for (const rule of rulesCache) {
        if (rule.regex.test(path2)) {
          result = result.replace(rule.regex, rule.value);
          debug2('rewriting path from "%s" to "%s"', path2, result);
          break;
        }
      }
      return result;
    }
  }
  function isValidRewriteConfig(rewriteConfig) {
    if (typeof rewriteConfig === "function") {
      return true;
    } else if ((0, is_plain_object_1.isPlainObject)(rewriteConfig)) {
      return Object.keys(rewriteConfig).length !== 0;
    } else if (rewriteConfig === void 0 || rewriteConfig === null) {
      return false;
    } else {
      throw new Error(errors_1.ERRORS.ERR_PATH_REWRITER_CONFIG);
    }
  }
  function parsePathRewriteRules(rewriteConfig) {
    const rules = [];
    if ((0, is_plain_object_1.isPlainObject)(rewriteConfig)) {
      for (const [key, value] of Object.entries(rewriteConfig)) {
        rules.push({
          regex: new RegExp(key),
          value
        });
        debug2('rewrite rule created: "%s" ~> "%s"', key, value);
      }
    }
    return rules;
  }
  return pathRewriter;
}
var router = {};
var hasRequiredRouter;
function requireRouter() {
  if (hasRequiredRouter) return router;
  hasRequiredRouter = 1;
  Object.defineProperty(router, "__esModule", { value: true });
  router.getTarget = getTarget;
  const is_plain_object_1 = requireIsPlainObject();
  const debug_12 = requireDebug();
  const debug2 = debug_12.Debug.extend("router");
  async function getTarget(req, config) {
    let newTarget;
    const router2 = config.router;
    if ((0, is_plain_object_1.isPlainObject)(router2)) {
      newTarget = getTargetFromProxyTable(req, router2);
    } else if (typeof router2 === "function") {
      newTarget = await router2(req);
    }
    return newTarget;
  }
  function getTargetFromProxyTable(req, table) {
    let result;
    const host = req.headers.host;
    const path2 = req.url;
    const hostAndPath = host + path2;
    for (const [key, value] of Object.entries(table)) {
      if (containsPath(key)) {
        if (hostAndPath.indexOf(key) > -1) {
          result = value;
          debug2('match: "%s" -> "%s"', key, result);
          break;
        }
      } else {
        if (key === host) {
          result = value;
          debug2('match: "%s" -> "%s"', host, result);
          break;
        }
      }
    }
    return result;
  }
  function containsPath(v) {
    return v.indexOf("/") > -1;
  }
  return router;
}
var hasRequiredHttpProxyMiddleware;
function requireHttpProxyMiddleware() {
  if (hasRequiredHttpProxyMiddleware) return httpProxyMiddleware;
  hasRequiredHttpProxyMiddleware = 1;
  Object.defineProperty(httpProxyMiddleware, "__esModule", { value: true });
  httpProxyMiddleware.HttpProxyMiddleware = void 0;
  const httpProxy2 = requireHttpProxy();
  const configuration_1 = requireConfiguration();
  const get_plugins_1 = requireGetPlugins();
  const path_filter_1 = requirePathFilter();
  const PathRewriter = requirePathRewriter();
  const Router2 = requireRouter();
  const debug_12 = requireDebug();
  const function_1 = require_function();
  const logger_1 = requireLogger();
  class HttpProxyMiddleware {
    constructor(options) {
      this.wsInternalSubscribed = false;
      this.serverOnCloseSubscribed = false;
      this.middleware = async (req, res, next) => {
        if (this.shouldProxy(this.proxyOptions.pathFilter, req)) {
          try {
            const activeProxyOptions = await this.prepareProxyRequest(req);
            (0, debug_12.Debug)(`proxy request to target: %O`, activeProxyOptions.target);
            this.proxy.web(req, res, activeProxyOptions);
          } catch (err) {
            next?.(err);
          }
        } else {
          next?.();
        }
        const server = (req.socket ?? req.connection)?.server;
        if (server && !this.serverOnCloseSubscribed) {
          server.on("close", () => {
            (0, debug_12.Debug)("server close signal received: closing proxy server");
            this.proxy.close();
          });
          this.serverOnCloseSubscribed = true;
        }
        if (this.proxyOptions.ws === true) {
          this.catchUpgradeRequest(server);
        }
      };
      this.catchUpgradeRequest = (server) => {
        if (!this.wsInternalSubscribed) {
          (0, debug_12.Debug)("subscribing to server upgrade event");
          server.on("upgrade", this.handleUpgrade);
          this.wsInternalSubscribed = true;
        }
      };
      this.handleUpgrade = async (req, socket, head) => {
        try {
          if (this.shouldProxy(this.proxyOptions.pathFilter, req)) {
            const activeProxyOptions = await this.prepareProxyRequest(req);
            this.proxy.ws(req, socket, head, activeProxyOptions);
            (0, debug_12.Debug)("server upgrade event received. Proxying WebSocket");
          }
        } catch (err) {
          this.proxy.emit("error", err, req, socket);
        }
      };
      this.shouldProxy = (pathFilter2, req) => {
        try {
          return (0, path_filter_1.matchPathFilter)(pathFilter2, req.url, req);
        } catch (err) {
          (0, debug_12.Debug)("Error: matchPathFilter() called with request url: ", `"${req.url}"`);
          this.logger.error(err);
          return false;
        }
      };
      this.prepareProxyRequest = async (req) => {
        if (this.middleware.__LEGACY_HTTP_PROXY_MIDDLEWARE__) {
          req.url = req.originalUrl || req.url;
        }
        const newProxyOptions = Object.assign({}, this.proxyOptions);
        await this.applyRouter(req, newProxyOptions);
        await this.applyPathRewrite(req, this.pathRewriter);
        return newProxyOptions;
      };
      this.applyRouter = async (req, options2) => {
        let newTarget;
        if (options2.router) {
          newTarget = await Router2.getTarget(req, options2);
          if (newTarget) {
            (0, debug_12.Debug)('router new target: "%s"', newTarget);
            options2.target = newTarget;
          }
        }
      };
      this.applyPathRewrite = async (req, pathRewriter2) => {
        if (pathRewriter2) {
          const path2 = await pathRewriter2(req.url, req);
          if (typeof path2 === "string") {
            (0, debug_12.Debug)("pathRewrite new path: %s", req.url);
            req.url = path2;
          } else {
            (0, debug_12.Debug)("pathRewrite: no rewritten path found: %s", req.url);
          }
        }
      };
      (0, configuration_1.verifyConfig)(options);
      this.proxyOptions = options;
      this.logger = (0, logger_1.getLogger)(options);
      (0, debug_12.Debug)(`create proxy server`);
      this.proxy = httpProxy2.createProxyServer({});
      this.registerPlugins(this.proxy, this.proxyOptions);
      this.pathRewriter = PathRewriter.createPathRewriter(this.proxyOptions.pathRewrite);
      this.middleware.upgrade = (req, socket, head) => {
        if (!this.wsInternalSubscribed) {
          this.handleUpgrade(req, socket, head);
        }
      };
    }
    registerPlugins(proxy, options) {
      const plugins = (0, get_plugins_1.getPlugins)(options);
      plugins.forEach((plugin) => {
        (0, debug_12.Debug)(`register plugin: "${(0, function_1.getFunctionName)(plugin)}"`);
        plugin(proxy, options);
      });
    }
  }
  httpProxyMiddleware.HttpProxyMiddleware = HttpProxyMiddleware;
  return httpProxyMiddleware;
}
var hasRequiredFactory;
function requireFactory() {
  if (hasRequiredFactory) return factory;
  hasRequiredFactory = 1;
  Object.defineProperty(factory, "__esModule", { value: true });
  factory.createProxyMiddleware = createProxyMiddleware2;
  const http_proxy_middleware_1 = requireHttpProxyMiddleware();
  function createProxyMiddleware2(options) {
    const { middleware } = new http_proxy_middleware_1.HttpProxyMiddleware(options);
    return middleware;
  }
  return factory;
}
var handlers = {};
var _public$1 = {};
var responseInterceptor = {};
var hasRequiredResponseInterceptor;
function requireResponseInterceptor() {
  if (hasRequiredResponseInterceptor) return responseInterceptor;
  hasRequiredResponseInterceptor = 1;
  Object.defineProperty(responseInterceptor, "__esModule", { value: true });
  responseInterceptor.responseInterceptor = responseInterceptor$1;
  const zlib$1 = zlib;
  const debug_12 = requireDebug();
  const function_1 = require_function();
  const debug2 = debug_12.Debug.extend("response-interceptor");
  function responseInterceptor$1(interceptor) {
    return async function proxyResResponseInterceptor(proxyRes, req, res) {
      debug2("intercept proxy response");
      const originalProxyRes = proxyRes;
      let buffer2 = Buffer.from("", "utf8");
      const _proxyRes = decompress(proxyRes, proxyRes.headers["content-encoding"]);
      _proxyRes.on("data", (chunk) => buffer2 = Buffer.concat([buffer2, chunk]));
      _proxyRes.on("end", async () => {
        copyHeaders(proxyRes, res);
        debug2("call interceptor function: %s", (0, function_1.getFunctionName)(interceptor));
        const interceptedBuffer = Buffer.from(await interceptor(buffer2, originalProxyRes, req, res));
        debug2("set content-length: %s", Buffer.byteLength(interceptedBuffer, "utf8"));
        res.setHeader("content-length", Buffer.byteLength(interceptedBuffer, "utf8"));
        debug2("write intercepted response");
        res.write(interceptedBuffer);
        res.end();
      });
      _proxyRes.on("error", (error) => {
        res.end(`Error fetching proxied request: ${error.message}`);
      });
    };
  }
  function decompress(proxyRes, contentEncoding) {
    let _proxyRes = proxyRes;
    let decompress2;
    switch (contentEncoding) {
      case "gzip":
        decompress2 = zlib$1.createGunzip();
        break;
      case "br":
        decompress2 = zlib$1.createBrotliDecompress();
        break;
      case "deflate":
        decompress2 = zlib$1.createInflate();
        break;
    }
    if (decompress2) {
      debug2(`decompress proxy response with 'content-encoding': %s`, contentEncoding);
      _proxyRes.pipe(decompress2);
      _proxyRes = decompress2;
    }
    return _proxyRes;
  }
  function copyHeaders(originalResponse, response2) {
    debug2("copy original response headers");
    response2.statusCode = originalResponse.statusCode;
    response2.statusMessage = originalResponse.statusMessage;
    if (response2.setHeader) {
      let keys = Object.keys(originalResponse.headers);
      keys = keys.filter((key) => !["content-encoding", "transfer-encoding"].includes(key));
      keys.forEach((key) => {
        let value = originalResponse.headers[key];
        if (key === "set-cookie") {
          value = Array.isArray(value) ? value : [value];
          value = value.map((x) => x.replace(/Domain=[^;]+?/i, ""));
        }
        response2.setHeader(key, value);
      });
    } else {
      response2.headers = originalResponse.headers;
    }
  }
  return responseInterceptor;
}
var fixRequestBody = {};
var hasRequiredFixRequestBody;
function requireFixRequestBody() {
  if (hasRequiredFixRequestBody) return fixRequestBody;
  hasRequiredFixRequestBody = 1;
  Object.defineProperty(fixRequestBody, "__esModule", { value: true });
  fixRequestBody.fixRequestBody = fixRequestBody$1;
  const querystring = require$$6$1;
  function fixRequestBody$1(proxyReq, req) {
    if (req.readableLength !== 0) {
      return;
    }
    const requestBody = req.body;
    if (!requestBody) {
      return;
    }
    const contentType2 = proxyReq.getHeader("Content-Type");
    if (!contentType2) {
      return;
    }
    const writeBody = (bodyData) => {
      proxyReq.setHeader("Content-Length", Buffer.byteLength(bodyData));
      proxyReq.write(bodyData);
    };
    if (contentType2.includes("application/json") || contentType2.includes("+json")) {
      writeBody(JSON.stringify(requestBody));
    } else if (contentType2.includes("application/x-www-form-urlencoded")) {
      writeBody(querystring.stringify(requestBody));
    } else if (contentType2.includes("multipart/form-data")) {
      writeBody(handlerFormDataBodyData(contentType2, requestBody));
    }
  }
  function handlerFormDataBodyData(contentType2, data2) {
    const boundary = contentType2.replace(/^.*boundary=(.*)$/, "$1");
    let str = "";
    for (const [key, value] of Object.entries(data2)) {
      str += `--${boundary}\r
Content-Disposition: form-data; name="${key}"\r
\r
${value}\r
`;
    }
    return str;
  }
  return fixRequestBody;
}
var hasRequired_public$1;
function require_public$1() {
  if (hasRequired_public$1) return _public$1;
  hasRequired_public$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fixRequestBody = exports.responseInterceptor = void 0;
    var response_interceptor_1 = requireResponseInterceptor();
    Object.defineProperty(exports, "responseInterceptor", { enumerable: true, get: function() {
      return response_interceptor_1.responseInterceptor;
    } });
    var fix_request_body_1 = requireFixRequestBody();
    Object.defineProperty(exports, "fixRequestBody", { enumerable: true, get: function() {
      return fix_request_body_1.fixRequestBody;
    } });
  })(_public$1);
  return _public$1;
}
var hasRequiredHandlers;
function requireHandlers() {
  if (hasRequiredHandlers) return handlers;
  hasRequiredHandlers = 1;
  (function(exports) {
    var __createBinding = handlers && handlers.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = handlers && handlers.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_public$1(), exports);
  })(handlers);
  return handlers;
}
var legacy = {};
var _public = {};
var createProxyMiddleware = {};
var optionsAdapter = {};
var hasRequiredOptionsAdapter;
function requireOptionsAdapter() {
  if (hasRequiredOptionsAdapter) return optionsAdapter;
  hasRequiredOptionsAdapter = 1;
  Object.defineProperty(optionsAdapter, "__esModule", { value: true });
  optionsAdapter.legacyOptionsAdapter = legacyOptionsAdapter;
  const url = require$$0$6;
  const debug_12 = requireDebug();
  const logger_1 = requireLogger();
  const debug2 = debug_12.Debug.extend("legacy-options-adapter");
  const proxyEventMap = {
    onError: "error",
    onProxyReq: "proxyReq",
    onProxyRes: "proxyRes",
    onProxyReqWs: "proxyReqWs",
    onOpen: "open",
    onClose: "close"
  };
  function legacyOptionsAdapter(legacyContext, legacyOptions) {
    let options = {};
    let logger2;
    if (typeof legacyContext === "string" && !!url.parse(legacyContext).host) {
      throw new Error(`Shorthand syntax is removed from legacyCreateProxyMiddleware().
      Please use "legacyCreateProxyMiddleware({ target: 'http://www.example.org' })" instead.

      More details: https://github.com/chimurai/http-proxy-middleware/blob/master/MIGRATION.md#removed-shorthand-usage
      `);
    }
    if (legacyContext && legacyOptions) {
      debug2("map legacy context/filter to options.pathFilter");
      options = { ...legacyOptions, pathFilter: legacyContext };
      logger2 = getLegacyLogger(options);
      logger2.warn(`[http-proxy-middleware] Legacy "context" argument is deprecated. Migrate your "context" to "options.pathFilter":

      const options = {
        pathFilter: '${legacyContext}',
      }

      More details: https://github.com/chimurai/http-proxy-middleware/blob/master/MIGRATION.md#removed-context-argument
      `);
    } else if (legacyContext && !legacyOptions) {
      options = { ...legacyContext };
      logger2 = getLegacyLogger(options);
    } else {
      logger2 = getLegacyLogger({});
    }
    Object.entries(proxyEventMap).forEach(([legacyEventName, proxyEventName]) => {
      if (options[legacyEventName]) {
        options.on = { ...options.on };
        options.on[proxyEventName] = options[legacyEventName];
        debug2('map legacy event "%s" to "on.%s"', legacyEventName, proxyEventName);
        logger2.warn(`[http-proxy-middleware] Legacy "${legacyEventName}" is deprecated. Migrate to "options.on.${proxyEventName}":

        const options = {
          on: {
            ${proxyEventName}: () => {},
          },
        }

        More details: https://github.com/chimurai/http-proxy-middleware/blob/master/MIGRATION.md#refactored-proxy-events
        `);
      }
    });
    const logProvider = options.logProvider && options.logProvider();
    const logLevel = options.logLevel;
    debug2("legacy logLevel", logLevel);
    debug2("legacy logProvider: %O", logProvider);
    if (typeof logLevel === "string" && logLevel !== "silent") {
      debug2('map "logProvider" to "logger"');
      logger2.warn(`[http-proxy-middleware] Legacy "logLevel" and "logProvider" are deprecated. Migrate to "options.logger":

      const options = {
        logger: console,
      }

      More details: https://github.com/chimurai/http-proxy-middleware/blob/master/MIGRATION.md#removed-logprovider-and-loglevel-options
      `);
    }
    return options;
  }
  function getLegacyLogger(options) {
    const legacyLogger = options.logProvider && options.logProvider();
    if (legacyLogger) {
      options.logger = legacyLogger;
    }
    return (0, logger_1.getLogger)(options);
  }
  return optionsAdapter;
}
var hasRequiredCreateProxyMiddleware;
function requireCreateProxyMiddleware() {
  if (hasRequiredCreateProxyMiddleware) return createProxyMiddleware;
  hasRequiredCreateProxyMiddleware = 1;
  Object.defineProperty(createProxyMiddleware, "__esModule", { value: true });
  createProxyMiddleware.legacyCreateProxyMiddleware = legacyCreateProxyMiddleware;
  const factory_1 = requireFactory();
  const debug_12 = requireDebug();
  const options_adapter_1 = requireOptionsAdapter();
  const debug2 = debug_12.Debug.extend("legacy-create-proxy-middleware");
  function legacyCreateProxyMiddleware(legacyContext, legacyOptions) {
    debug2("init");
    const options = (0, options_adapter_1.legacyOptionsAdapter)(legacyContext, legacyOptions);
    const proxyMiddleware = (0, factory_1.createProxyMiddleware)(options);
    debug2("add marker for patching req.url (old behavior)");
    proxyMiddleware.__LEGACY_HTTP_PROXY_MIDDLEWARE__ = true;
    return proxyMiddleware;
  }
  return createProxyMiddleware;
}
var hasRequired_public;
function require_public() {
  if (hasRequired_public) return _public;
  hasRequired_public = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.legacyCreateProxyMiddleware = void 0;
    var create_proxy_middleware_1 = requireCreateProxyMiddleware();
    Object.defineProperty(exports, "legacyCreateProxyMiddleware", { enumerable: true, get: function() {
      return create_proxy_middleware_1.legacyCreateProxyMiddleware;
    } });
  })(_public);
  return _public;
}
var hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy) return legacy;
  hasRequiredLegacy = 1;
  (function(exports) {
    var __createBinding = legacy && legacy.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = legacy && legacy.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_public(), exports);
  })(legacy);
  return legacy;
}
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  (function(exports) {
    var __createBinding = dist && dist.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = dist && dist.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(requireFactory(), exports);
    __exportStar(requireHandlers(), exports);
    __exportStar(require_default(), exports);
    __exportStar(requireLegacy(), exports);
  })(dist);
  return dist;
}
var distExports = requireDist();
var browser = {};
var canPromise;
var hasRequiredCanPromise;
function requireCanPromise() {
  if (hasRequiredCanPromise) return canPromise;
  hasRequiredCanPromise = 1;
  canPromise = function() {
    return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
  };
  return canPromise;
}
var qrcode = {};
var utils$1 = {};
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  let toSJISFunction;
  const CODEWORDS_COUNT = [
    0,
    // Not used
    26,
    44,
    70,
    100,
    134,
    172,
    196,
    242,
    292,
    346,
    404,
    466,
    532,
    581,
    655,
    733,
    815,
    901,
    991,
    1085,
    1156,
    1258,
    1364,
    1474,
    1588,
    1706,
    1828,
    1921,
    2051,
    2185,
    2323,
    2465,
    2611,
    2761,
    2876,
    3034,
    3196,
    3362,
    3532,
    3706
  ];
  utils$1.getSymbolSize = function getSymbolSize(version2) {
    if (!version2) throw new Error('"version" cannot be null or undefined');
    if (version2 < 1 || version2 > 40) throw new Error('"version" should be in range from 1 to 40');
    return version2 * 4 + 17;
  };
  utils$1.getSymbolTotalCodewords = function getSymbolTotalCodewords(version2) {
    return CODEWORDS_COUNT[version2];
  };
  utils$1.getBCHDigit = function(data2) {
    let digit = 0;
    while (data2 !== 0) {
      digit++;
      data2 >>>= 1;
    }
    return digit;
  };
  utils$1.setToSJISFunction = function setToSJISFunction(f) {
    if (typeof f !== "function") {
      throw new Error('"toSJISFunc" is not a valid function.');
    }
    toSJISFunction = f;
  };
  utils$1.isKanjiModeEnabled = function() {
    return typeof toSJISFunction !== "undefined";
  };
  utils$1.toSJIS = function toSJIS(kanji) {
    return toSJISFunction(kanji);
  };
  return utils$1;
}
var errorCorrectionLevel = {};
var hasRequiredErrorCorrectionLevel;
function requireErrorCorrectionLevel() {
  if (hasRequiredErrorCorrectionLevel) return errorCorrectionLevel;
  hasRequiredErrorCorrectionLevel = 1;
  (function(exports) {
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string);
      }
    }
    exports.isValid = function isValid2(level2) {
      return level2 && typeof level2.bit !== "undefined" && level2.bit >= 0 && level2.bit < 4;
    };
    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e) {
        return defaultValue;
      }
    };
  })(errorCorrectionLevel);
  return errorCorrectionLevel;
}
var bitBuffer;
var hasRequiredBitBuffer;
function requireBitBuffer() {
  if (hasRequiredBitBuffer) return bitBuffer;
  hasRequiredBitBuffer = 1;
  function BitBuffer() {
    this.buffer = [];
    this.length = 0;
  }
  BitBuffer.prototype = {
    get: function(index2) {
      const bufIndex = Math.floor(index2 / 8);
      return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) === 1;
    },
    put: function(num, length) {
      for (let i = 0; i < length; i++) {
        this.putBit((num >>> length - i - 1 & 1) === 1);
      }
    },
    getLengthInBits: function() {
      return this.length;
    },
    putBit: function(bit) {
      const bufIndex = Math.floor(this.length / 8);
      if (this.buffer.length <= bufIndex) {
        this.buffer.push(0);
      }
      if (bit) {
        this.buffer[bufIndex] |= 128 >>> this.length % 8;
      }
      this.length++;
    }
  };
  bitBuffer = BitBuffer;
  return bitBuffer;
}
var bitMatrix;
var hasRequiredBitMatrix;
function requireBitMatrix() {
  if (hasRequiredBitMatrix) return bitMatrix;
  hasRequiredBitMatrix = 1;
  function BitMatrix(size) {
    if (!size || size < 1) {
      throw new Error("BitMatrix size must be defined and greater than 0");
    }
    this.size = size;
    this.data = new Uint8Array(size * size);
    this.reservedBit = new Uint8Array(size * size);
  }
  BitMatrix.prototype.set = function(row, col, value, reserved) {
    const index2 = row * this.size + col;
    this.data[index2] = value;
    if (reserved) this.reservedBit[index2] = true;
  };
  BitMatrix.prototype.get = function(row, col) {
    return this.data[row * this.size + col];
  };
  BitMatrix.prototype.xor = function(row, col, value) {
    this.data[row * this.size + col] ^= value;
  };
  BitMatrix.prototype.isReserved = function(row, col) {
    return this.reservedBit[row * this.size + col];
  };
  bitMatrix = BitMatrix;
  return bitMatrix;
}
var alignmentPattern = {};
var hasRequiredAlignmentPattern;
function requireAlignmentPattern() {
  if (hasRequiredAlignmentPattern) return alignmentPattern;
  hasRequiredAlignmentPattern = 1;
  (function(exports) {
    const getSymbolSize = requireUtils$1().getSymbolSize;
    exports.getRowColCoords = function getRowColCoords(version2) {
      if (version2 === 1) return [];
      const posCount = Math.floor(version2 / 7) + 2;
      const size = getSymbolSize(version2);
      const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      const positions = [size - 7];
      for (let i = 1; i < posCount - 1; i++) {
        positions[i] = positions[i - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports.getPositions = function getPositions(version2) {
      const coords = [];
      const pos = exports.getRowColCoords(version2);
      const posLength = pos.length;
      for (let i = 0; i < posLength; i++) {
        for (let j = 0; j < posLength; j++) {
          if (i === 0 && j === 0 || // top-left
          i === 0 && j === posLength - 1 || // bottom-left
          i === posLength - 1 && j === 0) {
            continue;
          }
          coords.push([pos[i], pos[j]]);
        }
      }
      return coords;
    };
  })(alignmentPattern);
  return alignmentPattern;
}
var finderPattern = {};
var hasRequiredFinderPattern;
function requireFinderPattern() {
  if (hasRequiredFinderPattern) return finderPattern;
  hasRequiredFinderPattern = 1;
  const getSymbolSize = requireUtils$1().getSymbolSize;
  const FINDER_PATTERN_SIZE = 7;
  finderPattern.getPositions = function getPositions(version2) {
    const size = getSymbolSize(version2);
    return [
      // top-left
      [0, 0],
      // top-right
      [size - FINDER_PATTERN_SIZE, 0],
      // bottom-left
      [0, size - FINDER_PATTERN_SIZE]
    ];
  };
  return finderPattern;
}
var maskPattern = {};
var hasRequiredMaskPattern;
function requireMaskPattern() {
  if (hasRequiredMaskPattern) return maskPattern;
  hasRequiredMaskPattern = 1;
  (function(exports) {
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    const PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports.isValid = function isValid2(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports.from = function from(value) {
      return exports.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports.getPenaltyN1 = function getPenaltyN1(data2) {
      const size = data2.size;
      let points = 0;
      let sameCountCol = 0;
      let sameCountRow = 0;
      let lastCol = null;
      let lastRow = null;
      for (let row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (let col = 0; col < size; col++) {
          let module = data2.get(row, col);
          if (module === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module;
            sameCountCol = 1;
          }
          module = data2.get(col, row);
          if (module === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports.getPenaltyN2 = function getPenaltyN2(data2) {
      const size = data2.size;
      let points = 0;
      for (let row = 0; row < size - 1; row++) {
        for (let col = 0; col < size - 1; col++) {
          const last = data2.get(row, col) + data2.get(row, col + 1) + data2.get(row + 1, col) + data2.get(row + 1, col + 1);
          if (last === 4 || last === 0) points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports.getPenaltyN3 = function getPenaltyN3(data2) {
      const size = data2.size;
      let points = 0;
      let bitsCol = 0;
      let bitsRow = 0;
      for (let row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (let col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data2.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;
          bitsRow = bitsRow << 1 & 2047 | data2.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports.getPenaltyN4 = function getPenaltyN4(data2) {
      let darkCount = 0;
      const modulesCount = data2.data.length;
      for (let i = 0; i < modulesCount; i++) darkCount += data2.data[i];
      const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern2, i, j) {
      switch (maskPattern2) {
        case exports.Patterns.PATTERN000:
          return (i + j) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i + j) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return i * j % 2 + i * j % 3 === 0;
        case exports.Patterns.PATTERN110:
          return (i * j % 2 + i * j % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (i * j % 3 + (i + j) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern2);
      }
    }
    exports.applyMask = function applyMask(pattern, data2) {
      const size = data2.size;
      for (let col = 0; col < size; col++) {
        for (let row = 0; row < size; row++) {
          if (data2.isReserved(row, col)) continue;
          data2.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports.getBestMask = function getBestMask(data2, setupFormatFunc) {
      const numPatterns = Object.keys(exports.Patterns).length;
      let bestPattern = 0;
      let lowerPenalty = Infinity;
      for (let p = 0; p < numPatterns; p++) {
        setupFormatFunc(p);
        exports.applyMask(p, data2);
        const penalty = exports.getPenaltyN1(data2) + exports.getPenaltyN2(data2) + exports.getPenaltyN3(data2) + exports.getPenaltyN4(data2);
        exports.applyMask(p, data2);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p;
        }
      }
      return bestPattern;
    };
  })(maskPattern);
  return maskPattern;
}
var errorCorrectionCode = {};
var hasRequiredErrorCorrectionCode;
function requireErrorCorrectionCode() {
  if (hasRequiredErrorCorrectionCode) return errorCorrectionCode;
  hasRequiredErrorCorrectionCode = 1;
  const ECLevel = requireErrorCorrectionLevel();
  const EC_BLOCKS_TABLE = [
    // L  M  Q  H
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    1,
    2,
    2,
    4,
    1,
    2,
    4,
    4,
    2,
    4,
    4,
    4,
    2,
    4,
    6,
    5,
    2,
    4,
    6,
    6,
    2,
    5,
    8,
    8,
    4,
    5,
    8,
    8,
    4,
    5,
    8,
    11,
    4,
    8,
    10,
    11,
    4,
    9,
    12,
    16,
    4,
    9,
    16,
    16,
    6,
    10,
    12,
    18,
    6,
    10,
    17,
    16,
    6,
    11,
    16,
    19,
    6,
    13,
    18,
    21,
    7,
    14,
    21,
    25,
    8,
    16,
    20,
    25,
    8,
    17,
    23,
    25,
    9,
    17,
    23,
    34,
    9,
    18,
    25,
    30,
    10,
    20,
    27,
    32,
    12,
    21,
    29,
    35,
    12,
    23,
    34,
    37,
    12,
    25,
    34,
    40,
    13,
    26,
    35,
    42,
    14,
    28,
    38,
    45,
    15,
    29,
    40,
    48,
    16,
    31,
    43,
    51,
    17,
    33,
    45,
    54,
    18,
    35,
    48,
    57,
    19,
    37,
    51,
    60,
    19,
    38,
    53,
    63,
    20,
    40,
    56,
    66,
    21,
    43,
    59,
    70,
    22,
    45,
    62,
    74,
    24,
    47,
    65,
    77,
    25,
    49,
    68,
    81
  ];
  const EC_CODEWORDS_TABLE = [
    // L  M  Q  H
    7,
    10,
    13,
    17,
    10,
    16,
    22,
    28,
    15,
    26,
    36,
    44,
    20,
    36,
    52,
    64,
    26,
    48,
    72,
    88,
    36,
    64,
    96,
    112,
    40,
    72,
    108,
    130,
    48,
    88,
    132,
    156,
    60,
    110,
    160,
    192,
    72,
    130,
    192,
    224,
    80,
    150,
    224,
    264,
    96,
    176,
    260,
    308,
    104,
    198,
    288,
    352,
    120,
    216,
    320,
    384,
    132,
    240,
    360,
    432,
    144,
    280,
    408,
    480,
    168,
    308,
    448,
    532,
    180,
    338,
    504,
    588,
    196,
    364,
    546,
    650,
    224,
    416,
    600,
    700,
    224,
    442,
    644,
    750,
    252,
    476,
    690,
    816,
    270,
    504,
    750,
    900,
    300,
    560,
    810,
    960,
    312,
    588,
    870,
    1050,
    336,
    644,
    952,
    1110,
    360,
    700,
    1020,
    1200,
    390,
    728,
    1050,
    1260,
    420,
    784,
    1140,
    1350,
    450,
    812,
    1200,
    1440,
    480,
    868,
    1290,
    1530,
    510,
    924,
    1350,
    1620,
    540,
    980,
    1440,
    1710,
    570,
    1036,
    1530,
    1800,
    570,
    1064,
    1590,
    1890,
    600,
    1120,
    1680,
    1980,
    630,
    1204,
    1770,
    2100,
    660,
    1260,
    1860,
    2220,
    720,
    1316,
    1950,
    2310,
    750,
    1372,
    2040,
    2430
  ];
  errorCorrectionCode.getBlocksCount = function getBlocksCount(version2, errorCorrectionLevel2) {
    switch (errorCorrectionLevel2) {
      case ECLevel.L:
        return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 0];
      case ECLevel.M:
        return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 1];
      case ECLevel.Q:
        return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 2];
      case ECLevel.H:
        return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 3];
      default:
        return void 0;
    }
  };
  errorCorrectionCode.getTotalCodewordsCount = function getTotalCodewordsCount(version2, errorCorrectionLevel2) {
    switch (errorCorrectionLevel2) {
      case ECLevel.L:
        return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 0];
      case ECLevel.M:
        return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 1];
      case ECLevel.Q:
        return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 2];
      case ECLevel.H:
        return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 3];
      default:
        return void 0;
    }
  };
  return errorCorrectionCode;
}
var polynomial = {};
var galoisField = {};
var hasRequiredGaloisField;
function requireGaloisField() {
  if (hasRequiredGaloisField) return galoisField;
  hasRequiredGaloisField = 1;
  const EXP_TABLE = new Uint8Array(512);
  const LOG_TABLE = new Uint8Array(256);
  (function initTables() {
    let x = 1;
    for (let i = 0; i < 255; i++) {
      EXP_TABLE[i] = x;
      LOG_TABLE[x] = i;
      x <<= 1;
      if (x & 256) {
        x ^= 285;
      }
    }
    for (let i = 255; i < 512; i++) {
      EXP_TABLE[i] = EXP_TABLE[i - 255];
    }
  })();
  galoisField.log = function log(n) {
    if (n < 1) throw new Error("log(" + n + ")");
    return LOG_TABLE[n];
  };
  galoisField.exp = function exp(n) {
    return EXP_TABLE[n];
  };
  galoisField.mul = function mul(x, y) {
    if (x === 0 || y === 0) return 0;
    return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];
  };
  return galoisField;
}
var hasRequiredPolynomial;
function requirePolynomial() {
  if (hasRequiredPolynomial) return polynomial;
  hasRequiredPolynomial = 1;
  (function(exports) {
    const GF = requireGaloisField();
    exports.mul = function mul(p1, p2) {
      const coeff = new Uint8Array(p1.length + p2.length - 1);
      for (let i = 0; i < p1.length; i++) {
        for (let j = 0; j < p2.length; j++) {
          coeff[i + j] ^= GF.mul(p1[i], p2[j]);
        }
      }
      return coeff;
    };
    exports.mod = function mod(divident, divisor) {
      let result = new Uint8Array(divident);
      while (result.length - divisor.length >= 0) {
        const coeff = result[0];
        for (let i = 0; i < divisor.length; i++) {
          result[i] ^= GF.mul(divisor[i], coeff);
        }
        let offset = 0;
        while (offset < result.length && result[offset] === 0) offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports.generateECPolynomial = function generateECPolynomial(degree) {
      let poly = new Uint8Array([1]);
      for (let i = 0; i < degree; i++) {
        poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]));
      }
      return poly;
    };
  })(polynomial);
  return polynomial;
}
var reedSolomonEncoder;
var hasRequiredReedSolomonEncoder;
function requireReedSolomonEncoder() {
  if (hasRequiredReedSolomonEncoder) return reedSolomonEncoder;
  hasRequiredReedSolomonEncoder = 1;
  const Polynomial = requirePolynomial();
  function ReedSolomonEncoder(degree) {
    this.genPoly = void 0;
    this.degree = degree;
    if (this.degree) this.initialize(this.degree);
  }
  ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
    this.degree = degree;
    this.genPoly = Polynomial.generateECPolynomial(this.degree);
  };
  ReedSolomonEncoder.prototype.encode = function encode2(data2) {
    if (!this.genPoly) {
      throw new Error("Encoder not initialized");
    }
    const paddedData = new Uint8Array(data2.length + this.degree);
    paddedData.set(data2);
    const remainder = Polynomial.mod(paddedData, this.genPoly);
    const start = this.degree - remainder.length;
    if (start > 0) {
      const buff = new Uint8Array(this.degree);
      buff.set(remainder, start);
      return buff;
    }
    return remainder;
  };
  reedSolomonEncoder = ReedSolomonEncoder;
  return reedSolomonEncoder;
}
var version = {};
var mode = {};
var versionCheck = {};
var hasRequiredVersionCheck;
function requireVersionCheck() {
  if (hasRequiredVersionCheck) return versionCheck;
  hasRequiredVersionCheck = 1;
  versionCheck.isValid = function isValid2(version2) {
    return !isNaN(version2) && version2 >= 1 && version2 <= 40;
  };
  return versionCheck;
}
var regex = {};
var hasRequiredRegex;
function requireRegex() {
  if (hasRequiredRegex) return regex;
  hasRequiredRegex = 1;
  const numeric = "[0-9]+";
  const alphanumeric = "[A-Z $%*+\\-./:]+";
  let kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
  kanji = kanji.replace(/u/g, "\\u");
  const byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
  regex.KANJI = new RegExp(kanji, "g");
  regex.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
  regex.BYTE = new RegExp(byte, "g");
  regex.NUMERIC = new RegExp(numeric, "g");
  regex.ALPHANUMERIC = new RegExp(alphanumeric, "g");
  const TEST_KANJI = new RegExp("^" + kanji + "$");
  const TEST_NUMERIC = new RegExp("^" + numeric + "$");
  const TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
  regex.testKanji = function testKanji(str) {
    return TEST_KANJI.test(str);
  };
  regex.testNumeric = function testNumeric(str) {
    return TEST_NUMERIC.test(str);
  };
  regex.testAlphanumeric = function testAlphanumeric(str) {
    return TEST_ALPHANUMERIC.test(str);
  };
  return regex;
}
var hasRequiredMode;
function requireMode() {
  if (hasRequiredMode) return mode;
  hasRequiredMode = 1;
  (function(exports) {
    const VersionCheck = requireVersionCheck();
    const Regex = requireRegex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports.MIXED = {
      bit: -1
    };
    exports.getCharCountIndicator = function getCharCountIndicator(mode2, version2) {
      if (!mode2.ccBits) throw new Error("Invalid mode: " + mode2);
      if (!VersionCheck.isValid(version2)) {
        throw new Error("Invalid version: " + version2);
      }
      if (version2 >= 1 && version2 < 10) return mode2.ccBits[0];
      else if (version2 < 27) return mode2.ccBits[1];
      return mode2.ccBits[2];
    };
    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr)) return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr)) return exports.KANJI;
      else return exports.BYTE;
    };
    exports.toString = function toString3(mode2) {
      if (mode2 && mode2.id) return mode2.id;
      throw new Error("Invalid mode");
    };
    exports.isValid = function isValid2(mode2) {
      return mode2 && mode2.bit && mode2.ccBits;
    };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string);
      }
    }
    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e) {
        return defaultValue;
      }
    };
  })(mode);
  return mode;
}
var hasRequiredVersion;
function requireVersion() {
  if (hasRequiredVersion) return version;
  hasRequiredVersion = 1;
  (function(exports) {
    const Utils = requireUtils$1();
    const ECCode = requireErrorCorrectionCode();
    const ECLevel = requireErrorCorrectionLevel();
    const Mode = requireMode();
    const VersionCheck = requireVersionCheck();
    const G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    const G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode2, length, errorCorrectionLevel2) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel2, mode2)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode2, version2) {
      return Mode.getCharCountIndicator(mode2, version2) + 4;
    }
    function getTotalBitsFromDataArray(segments2, version2) {
      let totalBits = 0;
      segments2.forEach(function(data2) {
        const reservedBits = getReservedBitsCount(data2.mode, version2);
        totalBits += reservedBits + data2.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments2, errorCorrectionLevel2) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        const length = getTotalBitsFromDataArray(segments2, currentVersion);
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel2, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports.from = function from(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports.getCapacity = function getCapacity(version2, errorCorrectionLevel2, mode2) {
      if (!VersionCheck.isValid(version2)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode2 === "undefined") mode2 = Mode.BYTE;
      const totalCodewords = Utils.getSymbolTotalCodewords(version2);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode2 === Mode.MIXED) return dataTotalCodewordsBits;
      const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode2, version2);
      switch (mode2) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports.getBestVersionForData = function getBestVersionForData(data2, errorCorrectionLevel2) {
      let seg;
      const ecl = ECLevel.from(errorCorrectionLevel2, ECLevel.M);
      if (Array.isArray(data2)) {
        if (data2.length > 1) {
          return getBestVersionForMixedData(data2, ecl);
        }
        if (data2.length === 0) {
          return 1;
        }
        seg = data2[0];
      } else {
        seg = data2;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports.getEncodedBits = function getEncodedBits(version2) {
      if (!VersionCheck.isValid(version2) || version2 < 7) {
        throw new Error("Invalid QR Code version");
      }
      let d = version2 << 12;
      while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
        d ^= G18 << Utils.getBCHDigit(d) - G18_BCH;
      }
      return version2 << 12 | d;
    };
  })(version);
  return version;
}
var formatInfo = {};
var hasRequiredFormatInfo;
function requireFormatInfo() {
  if (hasRequiredFormatInfo) return formatInfo;
  hasRequiredFormatInfo = 1;
  const Utils = requireUtils$1();
  const G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
  const G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
  const G15_BCH = Utils.getBCHDigit(G15);
  formatInfo.getEncodedBits = function getEncodedBits(errorCorrectionLevel2, mask) {
    const data2 = errorCorrectionLevel2.bit << 3 | mask;
    let d = data2 << 10;
    while (Utils.getBCHDigit(d) - G15_BCH >= 0) {
      d ^= G15 << Utils.getBCHDigit(d) - G15_BCH;
    }
    return (data2 << 10 | d) ^ G15_MASK;
  };
  return formatInfo;
}
var segments = {};
var numericData;
var hasRequiredNumericData;
function requireNumericData() {
  if (hasRequiredNumericData) return numericData;
  hasRequiredNumericData = 1;
  const Mode = requireMode();
  function NumericData(data2) {
    this.mode = Mode.NUMERIC;
    this.data = data2.toString();
  }
  NumericData.getBitsLength = function getBitsLength(length) {
    return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
  };
  NumericData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  NumericData.prototype.getBitsLength = function getBitsLength() {
    return NumericData.getBitsLength(this.data.length);
  };
  NumericData.prototype.write = function write(bitBuffer2) {
    let i, group, value;
    for (i = 0; i + 3 <= this.data.length; i += 3) {
      group = this.data.substr(i, 3);
      value = parseInt(group, 10);
      bitBuffer2.put(value, 10);
    }
    const remainingNum = this.data.length - i;
    if (remainingNum > 0) {
      group = this.data.substr(i);
      value = parseInt(group, 10);
      bitBuffer2.put(value, remainingNum * 3 + 1);
    }
  };
  numericData = NumericData;
  return numericData;
}
var alphanumericData;
var hasRequiredAlphanumericData;
function requireAlphanumericData() {
  if (hasRequiredAlphanumericData) return alphanumericData;
  hasRequiredAlphanumericData = 1;
  const Mode = requireMode();
  const ALPHA_NUM_CHARS = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    " ",
    "$",
    "%",
    "*",
    "+",
    "-",
    ".",
    "/",
    ":"
  ];
  function AlphanumericData(data2) {
    this.mode = Mode.ALPHANUMERIC;
    this.data = data2;
  }
  AlphanumericData.getBitsLength = function getBitsLength(length) {
    return 11 * Math.floor(length / 2) + 6 * (length % 2);
  };
  AlphanumericData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  AlphanumericData.prototype.getBitsLength = function getBitsLength() {
    return AlphanumericData.getBitsLength(this.data.length);
  };
  AlphanumericData.prototype.write = function write(bitBuffer2) {
    let i;
    for (i = 0; i + 2 <= this.data.length; i += 2) {
      let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;
      value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);
      bitBuffer2.put(value, 11);
    }
    if (this.data.length % 2) {
      bitBuffer2.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
    }
  };
  alphanumericData = AlphanumericData;
  return alphanumericData;
}
var byteData;
var hasRequiredByteData;
function requireByteData() {
  if (hasRequiredByteData) return byteData;
  hasRequiredByteData = 1;
  const Mode = requireMode();
  function ByteData(data2) {
    this.mode = Mode.BYTE;
    if (typeof data2 === "string") {
      this.data = new TextEncoder().encode(data2);
    } else {
      this.data = new Uint8Array(data2);
    }
  }
  ByteData.getBitsLength = function getBitsLength(length) {
    return length * 8;
  };
  ByteData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  ByteData.prototype.getBitsLength = function getBitsLength() {
    return ByteData.getBitsLength(this.data.length);
  };
  ByteData.prototype.write = function(bitBuffer2) {
    for (let i = 0, l = this.data.length; i < l; i++) {
      bitBuffer2.put(this.data[i], 8);
    }
  };
  byteData = ByteData;
  return byteData;
}
var kanjiData;
var hasRequiredKanjiData;
function requireKanjiData() {
  if (hasRequiredKanjiData) return kanjiData;
  hasRequiredKanjiData = 1;
  const Mode = requireMode();
  const Utils = requireUtils$1();
  function KanjiData(data2) {
    this.mode = Mode.KANJI;
    this.data = data2;
  }
  KanjiData.getBitsLength = function getBitsLength(length) {
    return length * 13;
  };
  KanjiData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  KanjiData.prototype.getBitsLength = function getBitsLength() {
    return KanjiData.getBitsLength(this.data.length);
  };
  KanjiData.prototype.write = function(bitBuffer2) {
    let i;
    for (i = 0; i < this.data.length; i++) {
      let value = Utils.toSJIS(this.data[i]);
      if (value >= 33088 && value <= 40956) {
        value -= 33088;
      } else if (value >= 57408 && value <= 60351) {
        value -= 49472;
      } else {
        throw new Error(
          "Invalid SJIS character: " + this.data[i] + "\nMake sure your charset is UTF-8"
        );
      }
      value = (value >>> 8 & 255) * 192 + (value & 255);
      bitBuffer2.put(value, 13);
    }
  };
  kanjiData = KanjiData;
  return kanjiData;
}
var dijkstra = { exports: {} };
var hasRequiredDijkstra;
function requireDijkstra() {
  if (hasRequiredDijkstra) return dijkstra.exports;
  hasRequiredDijkstra = 1;
  (function(module) {
    var dijkstra2 = {
      single_source_shortest_paths: function(graph, s, d) {
        var predecessors = {};
        var costs = {};
        costs[s] = 0;
        var open = dijkstra2.PriorityQueue.make();
        open.push(s, 0);
        var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open.empty()) {
          closest = open.pop();
          u = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u] || {};
          for (v in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v)) {
              cost_of_e = adjacent_nodes[v];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v];
              first_visit = typeof costs[v] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v] = u;
              }
            }
          }
        }
        if (typeof d !== "undefined" && typeof costs[d] === "undefined") {
          var msg = ["Could not find a path from ", s, " to ", d, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d) {
        var nodes = [];
        var u = d;
        while (u) {
          nodes.push(u);
          predecessors[u];
          u = predecessors[u];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s, d) {
        var predecessors = dijkstra2.single_source_shortest_paths(graph, s, d);
        return dijkstra2.extract_shortest_path_from_predecessor_list(
          predecessors,
          d
        );
      },
      /**
       * A very naive priority queue implementation.
       */
      PriorityQueue: {
        make: function(opts) {
          var T = dijkstra2.PriorityQueue, t = {}, key;
          opts = opts || {};
          for (key in T) {
            if (T.hasOwnProperty(key)) {
              t[key] = T[key];
            }
          }
          t.queue = [];
          t.sorter = opts.sorter || T.default_sorter;
          return t;
        },
        default_sorter: function(a, b) {
          return a.cost - b.cost;
        },
        /**
         * Add a new item to the queue and ensure the highest priority element
         * is at the front of the queue.
         */
        push: function(value, cost) {
          var item = { value, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        /**
         * Return the highest priority element in the queue.
         */
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    {
      module.exports = dijkstra2;
    }
  })(dijkstra);
  return dijkstra.exports;
}
var hasRequiredSegments;
function requireSegments() {
  if (hasRequiredSegments) return segments;
  hasRequiredSegments = 1;
  (function(exports) {
    const Mode = requireMode();
    const NumericData = requireNumericData();
    const AlphanumericData = requireAlphanumericData();
    const ByteData = requireByteData();
    const KanjiData = requireKanjiData();
    const Regex = requireRegex();
    const Utils = requireUtils$1();
    const dijkstra2 = requireDijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex2, mode2, str) {
      const segments2 = [];
      let result;
      while ((result = regex2.exec(str)) !== null) {
        segments2.push({
          data: result[0],
          index: result.index,
          mode: mode2,
          length: result[0].length
        });
      }
      return segments2;
    }
    function getSegmentsFromString(dataStr) {
      const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      let byteSegs;
      let kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s2) {
        return s1.index - s2.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length, mode2) {
      switch (mode2) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length);
        case Mode.BYTE:
          return ByteData.getBitsLength(length);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      const nodes = [];
      for (let i = 0; i < segs.length; i++) {
        const seg = segs[i];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version2) {
      const table = {};
      const graph = { start: {} };
      let prevNodeIds = ["start"];
      for (let i = 0; i < nodes.length; i++) {
        const nodeGroup = nodes[i];
        const currentNodeIds = [];
        for (let j = 0; j < nodeGroup.length; j++) {
          const node = nodeGroup[j];
          const key = "" + i + j;
          currentNodeIds.push(key);
          table[key] = { node, lastCount: 0 };
          graph[key] = {};
          for (let n = 0; n < prevNodeIds.length; n++) {
            const prevNodeId = prevNodeIds[n];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version2);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (let n = 0; n < prevNodeIds.length; n++) {
        graph[prevNodeIds[n]].end = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data2, modesHint) {
      let mode2;
      const bestMode = Mode.getBestModeForData(data2);
      mode2 = Mode.from(modesHint, bestMode);
      if (mode2 !== Mode.BYTE && mode2.bit < bestMode.bit) {
        throw new Error('"' + data2 + '" cannot be encoded with mode ' + Mode.toString(mode2) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode2 === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode2 = Mode.BYTE;
      }
      switch (mode2) {
        case Mode.NUMERIC:
          return new NumericData(data2);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data2);
        case Mode.KANJI:
          return new KanjiData(data2);
        case Mode.BYTE:
          return new ByteData(data2);
      }
    }
    exports.fromArray = function fromArray(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports.fromString = function fromString(data2, version2) {
      const segs = getSegmentsFromString(data2, Utils.isKanjiModeEnabled());
      const nodes = buildNodes(segs);
      const graph = buildGraph(nodes, version2);
      const path2 = dijkstra2.find_path(graph.map, "start", "end");
      const optimizedSegs = [];
      for (let i = 1; i < path2.length - 1; i++) {
        optimizedSegs.push(graph.table[path2[i]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    exports.rawSplit = function rawSplit(data2) {
      return exports.fromArray(
        getSegmentsFromString(data2, Utils.isKanjiModeEnabled())
      );
    };
  })(segments);
  return segments;
}
var hasRequiredQrcode;
function requireQrcode() {
  if (hasRequiredQrcode) return qrcode;
  hasRequiredQrcode = 1;
  const Utils = requireUtils$1();
  const ECLevel = requireErrorCorrectionLevel();
  const BitBuffer = requireBitBuffer();
  const BitMatrix = requireBitMatrix();
  const AlignmentPattern = requireAlignmentPattern();
  const FinderPattern = requireFinderPattern();
  const MaskPattern = requireMaskPattern();
  const ECCode = requireErrorCorrectionCode();
  const ReedSolomonEncoder = requireReedSolomonEncoder();
  const Version = requireVersion();
  const FormatInfo = requireFormatInfo();
  const Mode = requireMode();
  const Segments = requireSegments();
  function setupFinderPattern(matrix, version2) {
    const size = matrix.size;
    const pos = FinderPattern.getPositions(version2);
    for (let i = 0; i < pos.length; i++) {
      const row = pos[i][0];
      const col = pos[i][1];
      for (let r = -1; r <= 7; r++) {
        if (row + r <= -1 || size <= row + r) continue;
        for (let c = -1; c <= 7; c++) {
          if (col + c <= -1 || size <= col + c) continue;
          if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {
            matrix.set(row + r, col + c, true, true);
          } else {
            matrix.set(row + r, col + c, false, true);
          }
        }
      }
    }
  }
  function setupTimingPattern(matrix) {
    const size = matrix.size;
    for (let r = 8; r < size - 8; r++) {
      const value = r % 2 === 0;
      matrix.set(r, 6, value, true);
      matrix.set(6, r, value, true);
    }
  }
  function setupAlignmentPattern(matrix, version2) {
    const pos = AlignmentPattern.getPositions(version2);
    for (let i = 0; i < pos.length; i++) {
      const row = pos[i][0];
      const col = pos[i][1];
      for (let r = -2; r <= 2; r++) {
        for (let c = -2; c <= 2; c++) {
          if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {
            matrix.set(row + r, col + c, true, true);
          } else {
            matrix.set(row + r, col + c, false, true);
          }
        }
      }
    }
  }
  function setupVersionInfo(matrix, version2) {
    const size = matrix.size;
    const bits = Version.getEncodedBits(version2);
    let row, col, mod;
    for (let i = 0; i < 18; i++) {
      row = Math.floor(i / 3);
      col = i % 3 + size - 8 - 3;
      mod = (bits >> i & 1) === 1;
      matrix.set(row, col, mod, true);
      matrix.set(col, row, mod, true);
    }
  }
  function setupFormatInfo(matrix, errorCorrectionLevel2, maskPattern2) {
    const size = matrix.size;
    const bits = FormatInfo.getEncodedBits(errorCorrectionLevel2, maskPattern2);
    let i, mod;
    for (i = 0; i < 15; i++) {
      mod = (bits >> i & 1) === 1;
      if (i < 6) {
        matrix.set(i, 8, mod, true);
      } else if (i < 8) {
        matrix.set(i + 1, 8, mod, true);
      } else {
        matrix.set(size - 15 + i, 8, mod, true);
      }
      if (i < 8) {
        matrix.set(8, size - i - 1, mod, true);
      } else if (i < 9) {
        matrix.set(8, 15 - i - 1 + 1, mod, true);
      } else {
        matrix.set(8, 15 - i - 1, mod, true);
      }
    }
    matrix.set(size - 8, 8, 1, true);
  }
  function setupData(matrix, data2) {
    const size = matrix.size;
    let inc = -1;
    let row = size - 1;
    let bitIndex = 7;
    let byteIndex = 0;
    for (let col = size - 1; col > 0; col -= 2) {
      if (col === 6) col--;
      while (true) {
        for (let c = 0; c < 2; c++) {
          if (!matrix.isReserved(row, col - c)) {
            let dark = false;
            if (byteIndex < data2.length) {
              dark = (data2[byteIndex] >>> bitIndex & 1) === 1;
            }
            matrix.set(row, col - c, dark);
            bitIndex--;
            if (bitIndex === -1) {
              byteIndex++;
              bitIndex = 7;
            }
          }
        }
        row += inc;
        if (row < 0 || size <= row) {
          row -= inc;
          inc = -inc;
          break;
        }
      }
    }
  }
  function createData(version2, errorCorrectionLevel2, segments2) {
    const buffer2 = new BitBuffer();
    segments2.forEach(function(data2) {
      buffer2.put(data2.mode.bit, 4);
      buffer2.put(data2.getLength(), Mode.getCharCountIndicator(data2.mode, version2));
      data2.write(buffer2);
    });
    const totalCodewords = Utils.getSymbolTotalCodewords(version2);
    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
    if (buffer2.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
      buffer2.put(0, 4);
    }
    while (buffer2.getLengthInBits() % 8 !== 0) {
      buffer2.putBit(0);
    }
    const remainingByte = (dataTotalCodewordsBits - buffer2.getLengthInBits()) / 8;
    for (let i = 0; i < remainingByte; i++) {
      buffer2.put(i % 2 ? 17 : 236, 8);
    }
    return createCodewords(buffer2, version2, errorCorrectionLevel2);
  }
  function createCodewords(bitBuffer2, version2, errorCorrectionLevel2) {
    const totalCodewords = Utils.getSymbolTotalCodewords(version2);
    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
    const dataTotalCodewords = totalCodewords - ecTotalCodewords;
    const ecTotalBlocks = ECCode.getBlocksCount(version2, errorCorrectionLevel2);
    const blocksInGroup2 = totalCodewords % ecTotalBlocks;
    const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
    const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
    const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
    const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
    const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
    const rs = new ReedSolomonEncoder(ecCount);
    let offset = 0;
    const dcData = new Array(ecTotalBlocks);
    const ecData = new Array(ecTotalBlocks);
    let maxDataSize = 0;
    const buffer2 = new Uint8Array(bitBuffer2.buffer);
    for (let b = 0; b < ecTotalBlocks; b++) {
      const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
      dcData[b] = buffer2.slice(offset, offset + dataSize);
      ecData[b] = rs.encode(dcData[b]);
      offset += dataSize;
      maxDataSize = Math.max(maxDataSize, dataSize);
    }
    const data2 = new Uint8Array(totalCodewords);
    let index2 = 0;
    let i, r;
    for (i = 0; i < maxDataSize; i++) {
      for (r = 0; r < ecTotalBlocks; r++) {
        if (i < dcData[r].length) {
          data2[index2++] = dcData[r][i];
        }
      }
    }
    for (i = 0; i < ecCount; i++) {
      for (r = 0; r < ecTotalBlocks; r++) {
        data2[index2++] = ecData[r][i];
      }
    }
    return data2;
  }
  function createSymbol(data2, version2, errorCorrectionLevel2, maskPattern2) {
    let segments2;
    if (Array.isArray(data2)) {
      segments2 = Segments.fromArray(data2);
    } else if (typeof data2 === "string") {
      let estimatedVersion = version2;
      if (!estimatedVersion) {
        const rawSegments = Segments.rawSplit(data2);
        estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel2);
      }
      segments2 = Segments.fromString(data2, estimatedVersion || 40);
    } else {
      throw new Error("Invalid data");
    }
    const bestVersion = Version.getBestVersionForData(segments2, errorCorrectionLevel2);
    if (!bestVersion) {
      throw new Error("The amount of data is too big to be stored in a QR Code");
    }
    if (!version2) {
      version2 = bestVersion;
    } else if (version2 < bestVersion) {
      throw new Error(
        "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
      );
    }
    const dataBits = createData(version2, errorCorrectionLevel2, segments2);
    const moduleCount = Utils.getSymbolSize(version2);
    const modules = new BitMatrix(moduleCount);
    setupFinderPattern(modules, version2);
    setupTimingPattern(modules);
    setupAlignmentPattern(modules, version2);
    setupFormatInfo(modules, errorCorrectionLevel2, 0);
    if (version2 >= 7) {
      setupVersionInfo(modules, version2);
    }
    setupData(modules, dataBits);
    if (isNaN(maskPattern2)) {
      maskPattern2 = MaskPattern.getBestMask(
        modules,
        setupFormatInfo.bind(null, modules, errorCorrectionLevel2)
      );
    }
    MaskPattern.applyMask(maskPattern2, modules);
    setupFormatInfo(modules, errorCorrectionLevel2, maskPattern2);
    return {
      modules,
      version: version2,
      errorCorrectionLevel: errorCorrectionLevel2,
      maskPattern: maskPattern2,
      segments: segments2
    };
  }
  qrcode.create = function create(data2, options) {
    if (typeof data2 === "undefined" || data2 === "") {
      throw new Error("No input text");
    }
    let errorCorrectionLevel2 = ECLevel.M;
    let version2;
    let mask;
    if (typeof options !== "undefined") {
      errorCorrectionLevel2 = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
      version2 = Version.from(options.version);
      mask = MaskPattern.from(options.maskPattern);
      if (options.toSJISFunc) {
        Utils.setToSJISFunction(options.toSJISFunc);
      }
    }
    return createSymbol(data2, version2, errorCorrectionLevel2, mask);
  };
  return qrcode;
}
var canvas = {};
var utils = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  (function(exports) {
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      let hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c) {
          return [c, c];
        }));
      }
      if (hexCode.length === 6) hexCode.push("F", "F");
      const hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports.getOptions = function getOptions(options) {
      if (!options) options = {};
      if (!options.color) options.color = {};
      const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      const width = options.width && options.width >= 21 ? options.width : void 0;
      const scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      const scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
      const size = qr.modules.size;
      const data2 = qr.modules.data;
      const scale = exports.getScale(size, opts);
      const symbolSize = Math.floor((size + opts.margin * 2) * scale);
      const scaledMargin = opts.margin * scale;
      const palette = [opts.color.light, opts.color.dark];
      for (let i = 0; i < symbolSize; i++) {
        for (let j = 0; j < symbolSize; j++) {
          let posDst = (i * symbolSize + j) * 4;
          let pxColor = opts.color.light;
          if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
            const iSrc = Math.floor((i - scaledMargin) / scale);
            const jSrc = Math.floor((j - scaledMargin) / scale);
            pxColor = palette[data2[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  })(utils);
  return utils;
}
var hasRequiredCanvas;
function requireCanvas() {
  if (hasRequiredCanvas) return canvas;
  hasRequiredCanvas = 1;
  (function(exports) {
    const Utils = requireUtils();
    function clearCanvas(ctx, canvas2, size) {
      ctx.clearRect(0, 0, canvas2.width, canvas2.height);
      if (!canvas2.style) canvas2.style = {};
      canvas2.height = size;
      canvas2.width = size;
      canvas2.style.height = size + "px";
      canvas2.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports.render = function render(qrData, canvas2, options) {
      let opts = options;
      let canvasEl = canvas2;
      if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
        opts = canvas2;
        canvas2 = void 0;
      }
      if (!canvas2) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      const size = Utils.getImageWidth(qrData.modules.size, opts);
      const ctx = canvasEl.getContext("2d");
      const image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, canvas2, options) {
      let opts = options;
      if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
        opts = canvas2;
        canvas2 = void 0;
      }
      if (!opts) opts = {};
      const canvasEl = exports.render(qrData, canvas2, opts);
      const type2 = opts.type || "image/png";
      const rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type2, rendererOpts.quality);
    };
  })(canvas);
  return canvas;
}
var svgTag = {};
var hasRequiredSvgTag;
function requireSvgTag() {
  if (hasRequiredSvgTag) return svgTag;
  hasRequiredSvgTag = 1;
  const Utils = requireUtils();
  function getColorAttrib(color, attrib) {
    const alpha = color.a / 255;
    const str = attrib + '="' + color.hex + '"';
    return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
  }
  function svgCmd(cmd, x, y) {
    let str = cmd + x;
    if (typeof y !== "undefined") str += " " + y;
    return str;
  }
  function qrToPath(data2, size, margin) {
    let path2 = "";
    let moveBy = 0;
    let newRow = false;
    let lineLength = 0;
    for (let i = 0; i < data2.length; i++) {
      const col = Math.floor(i % size);
      const row = Math.floor(i / size);
      if (!col && !newRow) newRow = true;
      if (data2[i]) {
        lineLength++;
        if (!(i > 0 && col > 0 && data2[i - 1])) {
          path2 += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
          moveBy = 0;
          newRow = false;
        }
        if (!(col + 1 < size && data2[i + 1])) {
          path2 += svgCmd("h", lineLength);
          lineLength = 0;
        }
      } else {
        moveBy++;
      }
    }
    return path2;
  }
  svgTag.render = function render(qrData, options, cb) {
    const opts = Utils.getOptions(options);
    const size = qrData.modules.size;
    const data2 = qrData.modules.data;
    const qrcodesize = size + opts.margin * 2;
    const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
    const path2 = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data2, size, opts.margin) + '"/>';
    const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
    const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
    const svgTag2 = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path2 + "</svg>\n";
    if (typeof cb === "function") {
      cb(null, svgTag2);
    }
    return svgTag2;
  };
  return svgTag;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  const canPromise2 = requireCanPromise();
  const QRCode = requireQrcode();
  const CanvasRenderer = requireCanvas();
  const SvgRenderer = requireSvgTag();
  function renderCanvas(renderFunc, canvas2, text, opts, cb) {
    const args = [].slice.call(arguments, 1);
    const argsNum = args.length;
    const isLastArgCb = typeof args[argsNum - 1] === "function";
    if (!isLastArgCb && !canPromise2()) {
      throw new Error("Callback required as last argument");
    }
    if (isLastArgCb) {
      if (argsNum < 2) {
        throw new Error("Too few arguments provided");
      }
      if (argsNum === 2) {
        cb = text;
        text = canvas2;
        canvas2 = opts = void 0;
      } else if (argsNum === 3) {
        if (canvas2.getContext && typeof cb === "undefined") {
          cb = opts;
          opts = void 0;
        } else {
          cb = opts;
          opts = text;
          text = canvas2;
          canvas2 = void 0;
        }
      }
    } else {
      if (argsNum < 1) {
        throw new Error("Too few arguments provided");
      }
      if (argsNum === 1) {
        text = canvas2;
        canvas2 = opts = void 0;
      } else if (argsNum === 2 && !canvas2.getContext) {
        opts = text;
        text = canvas2;
        canvas2 = void 0;
      }
      return new Promise(function(resolve, reject) {
        try {
          const data2 = QRCode.create(text, opts);
          resolve(renderFunc(data2, canvas2, opts));
        } catch (e) {
          reject(e);
        }
      });
    }
    try {
      const data2 = QRCode.create(text, opts);
      cb(null, renderFunc(data2, canvas2, opts));
    } catch (e) {
      cb(e);
    }
  }
  browser.create = QRCode.create;
  browser.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
  browser.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
  browser.toString = renderCanvas.bind(null, function(data2, _, opts) {
    return SvgRenderer.render(data2, opts);
  });
  return browser;
}
var browserExports = requireBrowser();
var heicConvert = { exports: {} };
var heicDecode = { exports: {} };
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var libheifBundle = { exports: {} };
var hasRequiredLibheifBundle;
function requireLibheifBundle() {
  if (hasRequiredLibheifBundle) return libheifBundle.exports;
  hasRequiredLibheifBundle = 1;
  (function(module, exports) {
    var libheif = (() => {
      var xe = Object.create;
      var wA = Object.defineProperty;
      var Le = Object.getOwnPropertyDescriptor;
      var ye = Object.getOwnPropertyNames;
      var Oe = Object.getPrototypeOf, Je = Object.prototype.hasOwnProperty;
      var be = ((f) => typeof commonjsRequire != "undefined" ? commonjsRequire : typeof Proxy != "undefined" ? new Proxy(f, { get: (N, y) => (typeof commonjsRequire != "undefined" ? commonjsRequire : N)[y] }) : f)(function(f) {
        if (typeof commonjsRequire != "undefined") return commonjsRequire.apply(this, arguments);
        throw Error('Dynamic require of "' + f + '" is not supported');
      });
      var Ej = (f, N) => () => (N || f((N = { exports: {} }).exports, N), N.exports), De = (f, N) => {
        for (var y in N) wA(f, y, { get: N[y], enumerable: true });
      }, Zj = (f, N, y, K) => {
        if (N && typeof N == "object" || typeof N == "function") for (let r of ye(N)) !Je.call(f, r) && r !== y && wA(f, r, { get: () => N[r], enumerable: !(K = Le(N, r)) || K.enumerable });
        return f;
      };
      var we = (f, N, y) => (y = f != null ? xe(Oe(f)) : {}, Zj(!f || !f.__esModule ? wA(y, "default", { value: f, enumerable: true }) : y, f)), Ce = (f) => Zj(wA({}, "__esModule", { value: true }), f);
      var Qj = (() => {
        for (var f = new Uint8Array(128), N = 0; N < 64; N++) f[N < 26 ? N + 65 : N < 52 ? N + 71 : N < 62 ? N - 4 : N * 4 - 205] = N;
        return (y) => {
          for (var K = y.length, r = new Uint8Array((K - (y[K - 1] == "=") - (y[K - 2] == "=")) * 3 / 4 | 0), z = 0, AA = 0; z < K; ) {
            var sj = f[y.charCodeAt(z++)], qA = f[y.charCodeAt(z++)], jA = f[y.charCodeAt(z++)], _A = f[y.charCodeAt(z++)];
            r[AA++] = sj << 2 | qA >> 4, r[AA++] = qA << 4 | jA >> 2, r[AA++] = jA << 6 | _A;
          }
          return r;
        };
      })();
      var j6 = Ej((v_, A6) => {
        A6.exports = {};
      });
      var e6 = Ej((F_, t6) => {
        t6.exports = {};
      });
      var l6 = Ej((k6, nj) => {
        var r6 = (() => {
          var f, N = typeof document != "undefined" ? (f = document.currentScript) == null ? void 0 : f.src : void 0;
          return typeof __filename != "undefined" && (N || (N = __filename)), function(y = {}) {
            var K, r = y, z, AA;
            new Promise((A, j) => {
              z = A, AA = j;
            });
            var qA = typeof window == "object", jA = typeof importScripts == "function", _A = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", Gj = Object.assign({}, r), CA = "./this.program", M = "";
            function a6(A) {
              return r.locateFile ? r.locateFile(A, M) : M + A;
            }
            var aA, SA, hA;
            if (_A) {
              var PA = j6(), uj = e6();
              M = __dirname + "/", aA = (A, j) => (A = RA(A) ? new URL(A) : uj.normalize(A), PA.readFileSync(A, j ? void 0 : "utf8")), hA = (A) => {
                var j = aA(A, true);
                return j.buffer || (j = new Uint8Array(j)), j;
              }, SA = (A, j, t, e = true) => {
                A = RA(A) ? new URL(A) : uj.normalize(A), PA.readFile(A, e ? void 0 : "utf8", (l, _) => {
                  l ? t(l) : j(e ? _.buffer : _);
                });
              }, !r.thisProgram && process.argv.length > 1 && (CA = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2);
            } else (qA || jA) && (jA ? M = self.location.href : typeof document != "undefined" && document.currentScript && (M = document.currentScript.src), N && (M = N), M.startsWith("blob:") ? M = "" : M = M.substr(0, M.replace(/[?#].*/, "").lastIndexOf("/") + 1), aA = (A) => {
              var j = new XMLHttpRequest();
              return j.open("GET", A, false), j.send(null), j.responseText;
            }, jA && (hA = (A) => {
              var j = new XMLHttpRequest();
              return j.open("GET", A, false), j.responseType = "arraybuffer", j.send(null), new Uint8Array(j.response);
            }), SA = (A, j, t) => {
              if (RA(A)) {
                var e = new XMLHttpRequest();
                e.open("GET", A, true), e.responseType = "arraybuffer", e.onload = () => {
                  if (e.status == 200 || e.status == 0 && e.response) {
                    j(e.response);
                    return;
                  }
                  t();
                }, e.onerror = t, e.send(null);
                return;
              }
              fetch(A, { credentials: "same-origin" }).then((l) => l.ok ? l.arrayBuffer() : Promise.reject(new Error(l.status + " : " + l.url))).then(j, t);
            });
            var MA = r.print || console.log.bind(console), oA = r.printErr || console.error.bind(console);
            Object.assign(r, Gj), Gj = null, r.arguments && r.arguments, r.thisProgram && (CA = r.thisProgram), r.quit && r.quit;
            var KA;
            r.wasmBinary && (KA = r.wasmBinary);
            var mA, pj = false, J, D, R, iA, H, m, Hj, cj;
            function qj() {
              var A = mA.buffer;
              r.HEAP8 = J = new Int8Array(A), r.HEAP16 = R = new Int16Array(A), r.HEAPU8 = D = new Uint8Array(A), r.HEAPU16 = iA = new Uint16Array(A), r.HEAP32 = H = new Int32Array(A), r.HEAPU32 = m = new Uint32Array(A), r.HEAPF32 = Hj = new Float32Array(A), r.HEAPF64 = cj = new Float64Array(A);
            }
            var hj = [], mj = [], Nj = [];
            function E6() {
              if (r.preRun) for (typeof r.preRun == "function" && (r.preRun = [r.preRun]); r.preRun.length; ) G6(r.preRun.shift());
              VA(hj);
            }
            function n6() {
              !r.noFSInit && !k.init.initialized && k.init(), k.ignorePermissions = false, VA(mj);
            }
            function s6() {
              if (r.postRun) for (typeof r.postRun == "function" && (r.postRun = [r.postRun]); r.postRun.length; ) $6(r.postRun.shift());
              VA(Nj);
            }
            function G6(A) {
              hj.unshift(A);
            }
            function d6(A) {
              mj.unshift(A);
            }
            function $6(A) {
              Nj.unshift(A);
            }
            var tA = 0, EA = null;
            function XA(A) {
              var j;
              tA++, (j = r.monitorRunDependencies) == null || j.call(r, tA);
            }
            function NA(A) {
              var j;
              if (tA--, (j = r.monitorRunDependencies) == null || j.call(r, tA), tA == 0 && EA) {
                var t = EA;
                EA = null, t();
              }
            }
            function nA(A) {
              var j;
              (j = r.onAbort) == null || j.call(r, A), A = "Aborted(" + A + ")", oA(A), pj = true, A += ". Build with -sASSERTIONS for more info.";
              var t = new WebAssembly.RuntimeError(A);
              throw AA(t), t;
            }
            var u6 = "data:application/octet-stream;base64,", p6 = (A) => A.startsWith(u6), RA = (A) => A.startsWith("file://");
            function H6() {
              var A = "libheif.wasm";
              return p6(A) ? A : a6(A);
            }
            var fA;
            function c6(A) {
              if (A == fA && KA) return new Uint8Array(KA);
              if (hA) return hA(A);
              throw 'sync fetching of the wasm failed: you can preload it to Module["wasmBinary"] manually, or emcc.py will do that for you when generating HTML (but not JS)';
            }
            function q6(A, j) {
              var t, e = c6(A);
              t = new WebAssembly.Module(e);
              var l = new WebAssembly.Instance(t, j);
              return [l, t];
            }
            function h6() {
              return { a: fe };
            }
            function m6() {
              var A = h6();
              function j(e, l) {
                return B = e.exports, mA = B.Q, qj(), Dj = B.T, d6(B.R), NA(), B;
              }
              if (XA(), r.instantiateWasm) try {
                return r.instantiateWasm(A, j);
              } catch (e) {
                oA(`Module.instantiateWasm callback failed with error: ${e}`), AA(e);
              }
              fA || (fA = H6());
              var t = q6(fA, A);
              return j(t[0]);
            }
            var h, b, VA = (A) => {
              for (; A.length > 0; ) A.shift()(r);
            };
            r.noExitRuntime || true;
            var fj = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0, kA = (A, j, t) => {
              for (var e = j + t, l = j; A[l] && !(l >= e); ) ++l;
              if (l - j > 16 && A.buffer && fj) return fj.decode(A.subarray(j, l));
              for (var _ = ""; j < l; ) {
                var a = A[j++];
                if (!(a & 128)) {
                  _ += String.fromCharCode(a);
                  continue;
                }
                var o = A[j++] & 63;
                if ((a & 224) == 192) {
                  _ += String.fromCharCode((a & 31) << 6 | o);
                  continue;
                }
                var i = A[j++] & 63;
                if ((a & 240) == 224 ? a = (a & 15) << 12 | o << 6 | i : a = (a & 7) << 18 | o << 12 | i << 6 | A[j++] & 63, a < 65536) _ += String.fromCharCode(a);
                else {
                  var n = a - 65536;
                  _ += String.fromCharCode(55296 | n >> 10, 56320 | n & 1023);
                }
              }
              return _;
            }, eA = (A, j) => A ? kA(D, A, j) : "", N6 = (A, j, t, e) => {
              nA(`Assertion failed: ${eA(A)}, at: ` + [j ? eA(j) : "unknown filename", t, e ? eA(e) : "unknown function"]);
            };
            class f6 {
              constructor(j) {
                this.excPtr = j, this.ptr = j - 24;
              }
              set_type(j) {
                m[this.ptr + 4 >> 2] = j;
              }
              get_type() {
                return m[this.ptr + 4 >> 2];
              }
              set_destructor(j) {
                m[this.ptr + 8 >> 2] = j;
              }
              get_destructor() {
                return m[this.ptr + 8 >> 2];
              }
              set_caught(j) {
                j = j ? 1 : 0, J[this.ptr + 12] = j;
              }
              get_caught() {
                return J[this.ptr + 12] != 0;
              }
              set_rethrown(j) {
                j = j ? 1 : 0, J[this.ptr + 13] = j;
              }
              get_rethrown() {
                return J[this.ptr + 13] != 0;
              }
              init(j, t) {
                this.set_adjusted_ptr(0), this.set_type(j), this.set_destructor(t);
              }
              set_adjusted_ptr(j) {
                m[this.ptr + 16 >> 2] = j;
              }
              get_adjusted_ptr() {
                return m[this.ptr + 16 >> 2];
              }
              get_exception_ptr() {
                var j = Fe(this.get_type());
                if (j) return m[this.excPtr >> 2];
                var t = this.get_adjusted_ptr();
                return t !== 0 ? t : this.excPtr;
              }
            }
            var vj = 0, F6 = (A, j, t) => {
              var e = new f6(A);
              throw e.init(j, t), vj = A, vj;
            };
            function vA() {
              var A = H[+w.varargs >> 2];
              return w.varargs += 4, A;
            }
            var lA = vA, I = { isAbs: (A) => A.charAt(0) === "/", splitPath: (A) => {
              var j = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
              return j.exec(A).slice(1);
            }, normalizeArray: (A, j) => {
              for (var t = 0, e = A.length - 1; e >= 0; e--) {
                var l = A[e];
                l === "." ? A.splice(e, 1) : l === ".." ? (A.splice(e, 1), t++) : t && (A.splice(e, 1), t--);
              }
              if (j) for (; t; t--) A.unshift("..");
              return A;
            }, normalize: (A) => {
              var j = I.isAbs(A), t = A.substr(-1) === "/";
              return A = I.normalizeArray(A.split("/").filter((e) => !!e), !j).join("/"), !A && !j && (A = "."), A && t && (A += "/"), (j ? "/" : "") + A;
            }, dirname: (A) => {
              var j = I.splitPath(A), t = j[0], e = j[1];
              return !t && !e ? "." : (e && (e = e.substr(0, e.length - 1)), t + e);
            }, basename: (A) => {
              if (A === "/") return "/";
              A = I.normalize(A), A = A.replace(/\/$/, "");
              var j = A.lastIndexOf("/");
              return j === -1 ? A : A.substr(j + 1);
            }, join: (...A) => I.normalize(A.join("/")), join2: (A, j) => I.normalize(A + "/" + j) }, I6 = () => {
              if (typeof crypto == "object" && typeof crypto.getRandomValues == "function") return (e) => crypto.getRandomValues(e);
              if (_A) try {
                var A = be("crypto"), j = A.randomFillSync;
                if (j) return (e) => A.randomFillSync(e);
                var t = A.randomBytes;
                return (e) => (e.set(t(e.byteLength)), e);
              } catch {
              }
              nA("initRandomDevice");
            }, Fj = (A) => (Fj = I6())(A), V = { resolve: (...A) => {
              for (var j = "", t = false, e = A.length - 1; e >= -1 && !t; e--) {
                var l = e >= 0 ? A[e] : k.cwd();
                if (typeof l != "string") throw new TypeError("Arguments to path.resolve must be strings");
                if (!l) return "";
                j = l + "/" + j, t = I.isAbs(l);
              }
              return j = I.normalizeArray(j.split("/").filter((_) => !!_), !t).join("/"), (t ? "/" : "") + j || ".";
            }, relative: (A, j) => {
              A = V.resolve(A).substr(1), j = V.resolve(j).substr(1);
              function t(n) {
                for (var s = 0; s < n.length && n[s] === ""; s++) ;
                for (var u = n.length - 1; u >= 0 && n[u] === ""; u--) ;
                return s > u ? [] : n.slice(s, u - s + 1);
              }
              for (var e = t(A.split("/")), l = t(j.split("/")), _ = Math.min(e.length, l.length), a = _, o = 0; o < _; o++) if (e[o] !== l[o]) {
                a = o;
                break;
              }
              for (var i = [], o = a; o < e.length; o++) i.push("..");
              return i = i.concat(l.slice(a)), i.join("/");
            } }, UA = [], YA = (A) => {
              for (var j = 0, t = 0; t < A.length; ++t) {
                var e = A.charCodeAt(t);
                e <= 127 ? j++ : e <= 2047 ? j += 2 : e >= 55296 && e <= 57343 ? (j += 4, ++t) : j += 3;
              }
              return j;
            }, zA = (A, j, t, e) => {
              if (!(e > 0)) return 0;
              for (var l = t, _ = t + e - 1, a = 0; a < A.length; ++a) {
                var o = A.charCodeAt(a);
                if (o >= 55296 && o <= 57343) {
                  var i = A.charCodeAt(++a);
                  o = 65536 + ((o & 1023) << 10) | i & 1023;
                }
                if (o <= 127) {
                  if (t >= _) break;
                  j[t++] = o;
                } else if (o <= 2047) {
                  if (t + 1 >= _) break;
                  j[t++] = 192 | o >> 6, j[t++] = 128 | o & 63;
                } else if (o <= 65535) {
                  if (t + 2 >= _) break;
                  j[t++] = 224 | o >> 12, j[t++] = 128 | o >> 6 & 63, j[t++] = 128 | o & 63;
                } else {
                  if (t + 3 >= _) break;
                  j[t++] = 240 | o >> 18, j[t++] = 128 | o >> 12 & 63, j[t++] = 128 | o >> 6 & 63, j[t++] = 128 | o & 63;
                }
              }
              return j[t] = 0, t - l;
            };
            function FA(A, j, t) {
              var e = YA(A) + 1, l = new Array(e), _ = zA(A, l, 0, l.length);
              return j && (l.length = _), l;
            }
            var g6 = () => {
              if (!UA.length) {
                var A = null;
                if (_A) {
                  var j = 256, t = Buffer.alloc(j), e = 0, l = process.stdin.fd;
                  try {
                    e = PA.readSync(l, t, 0, j);
                  } catch (_) {
                    if (_.toString().includes("EOF")) e = 0;
                    else throw _;
                  }
                  e > 0 && (A = t.slice(0, e).toString("utf-8"));
                } else typeof window != "undefined" && typeof window.prompt == "function" && (A = window.prompt("Input: "), A !== null && (A += `
`));
                if (!A) return null;
                UA = FA(A, true);
              }
              return UA.shift();
            }, W = { ttys: [], init() {
            }, shutdown() {
            }, register(A, j) {
              W.ttys[A] = { input: [], output: [], ops: j }, k.registerDevice(A, W.stream_ops);
            }, stream_ops: { open(A) {
              var j = W.ttys[A.node.rdev];
              if (!j) throw new k.ErrnoError(43);
              A.tty = j, A.seekable = false;
            }, close(A) {
              A.tty.ops.fsync(A.tty);
            }, fsync(A) {
              A.tty.ops.fsync(A.tty);
            }, read(A, j, t, e, l) {
              if (!A.tty || !A.tty.ops.get_char) throw new k.ErrnoError(60);
              for (var _ = 0, a = 0; a < e; a++) {
                var o;
                try {
                  o = A.tty.ops.get_char(A.tty);
                } catch {
                  throw new k.ErrnoError(29);
                }
                if (o === void 0 && _ === 0) throw new k.ErrnoError(6);
                if (o == null) break;
                _++, j[t + a] = o;
              }
              return _ && (A.node.timestamp = Date.now()), _;
            }, write(A, j, t, e, l) {
              if (!A.tty || !A.tty.ops.put_char) throw new k.ErrnoError(60);
              try {
                for (var _ = 0; _ < e; _++) A.tty.ops.put_char(A.tty, j[t + _]);
              } catch {
                throw new k.ErrnoError(29);
              }
              return e && (A.node.timestamp = Date.now()), _;
            } }, default_tty_ops: { get_char(A) {
              return g6();
            }, put_char(A, j) {
              j === null || j === 10 ? (MA(kA(A.output, 0)), A.output = []) : j != 0 && A.output.push(j);
            }, fsync(A) {
              A.output && A.output.length > 0 && (MA(kA(A.output, 0)), A.output = []);
            }, ioctl_tcgets(A) {
              return { c_iflag: 25856, c_oflag: 5, c_cflag: 191, c_lflag: 35387, c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
            }, ioctl_tcsets(A, j, t) {
              return 0;
            }, ioctl_tiocgwinsz(A) {
              return [24, 80];
            } }, default_tty1_ops: { put_char(A, j) {
              j === null || j === 10 ? (oA(kA(A.output, 0)), A.output = []) : j != 0 && A.output.push(j);
            }, fsync(A) {
              A.output && A.output.length > 0 && (oA(kA(A.output, 0)), A.output = []);
            } } }, Ij = (A) => {
              nA();
            }, q = { ops_table: null, mount(A) {
              return q.createNode(null, "/", 16895, 0);
            }, createNode(A, j, t, e) {
              if (k.isBlkdev(t) || k.isFIFO(t)) throw new k.ErrnoError(63);
              q.ops_table || (q.ops_table = { dir: { node: { getattr: q.node_ops.getattr, setattr: q.node_ops.setattr, lookup: q.node_ops.lookup, mknod: q.node_ops.mknod, rename: q.node_ops.rename, unlink: q.node_ops.unlink, rmdir: q.node_ops.rmdir, readdir: q.node_ops.readdir, symlink: q.node_ops.symlink }, stream: { llseek: q.stream_ops.llseek } }, file: { node: { getattr: q.node_ops.getattr, setattr: q.node_ops.setattr }, stream: { llseek: q.stream_ops.llseek, read: q.stream_ops.read, write: q.stream_ops.write, allocate: q.stream_ops.allocate, mmap: q.stream_ops.mmap, msync: q.stream_ops.msync } }, link: { node: { getattr: q.node_ops.getattr, setattr: q.node_ops.setattr, readlink: q.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: q.node_ops.getattr, setattr: q.node_ops.setattr }, stream: k.chrdev_stream_ops } });
              var l = k.createNode(A, j, t, e);
              return k.isDir(l.mode) ? (l.node_ops = q.ops_table.dir.node, l.stream_ops = q.ops_table.dir.stream, l.contents = {}) : k.isFile(l.mode) ? (l.node_ops = q.ops_table.file.node, l.stream_ops = q.ops_table.file.stream, l.usedBytes = 0, l.contents = null) : k.isLink(l.mode) ? (l.node_ops = q.ops_table.link.node, l.stream_ops = q.ops_table.link.stream) : k.isChrdev(l.mode) && (l.node_ops = q.ops_table.chrdev.node, l.stream_ops = q.ops_table.chrdev.stream), l.timestamp = Date.now(), A && (A.contents[j] = l, A.timestamp = l.timestamp), l;
            }, getFileDataAsTypedArray(A) {
              return A.contents ? A.contents.subarray ? A.contents.subarray(0, A.usedBytes) : new Uint8Array(A.contents) : new Uint8Array(0);
            }, expandFileStorage(A, j) {
              var t = A.contents ? A.contents.length : 0;
              if (!(t >= j)) {
                var e = 1048576;
                j = Math.max(j, t * (t < e ? 2 : 1.125) >>> 0), t != 0 && (j = Math.max(j, 256));
                var l = A.contents;
                A.contents = new Uint8Array(j), A.usedBytes > 0 && A.contents.set(l.subarray(0, A.usedBytes), 0);
              }
            }, resizeFileStorage(A, j) {
              if (A.usedBytes != j) if (j == 0) A.contents = null, A.usedBytes = 0;
              else {
                var t = A.contents;
                A.contents = new Uint8Array(j), t && A.contents.set(t.subarray(0, Math.min(j, A.usedBytes))), A.usedBytes = j;
              }
            }, node_ops: { getattr(A) {
              var j = {};
              return j.dev = k.isChrdev(A.mode) ? A.id : 1, j.ino = A.id, j.mode = A.mode, j.nlink = 1, j.uid = 0, j.gid = 0, j.rdev = A.rdev, k.isDir(A.mode) ? j.size = 4096 : k.isFile(A.mode) ? j.size = A.usedBytes : k.isLink(A.mode) ? j.size = A.link.length : j.size = 0, j.atime = new Date(A.timestamp), j.mtime = new Date(A.timestamp), j.ctime = new Date(A.timestamp), j.blksize = 4096, j.blocks = Math.ceil(j.size / j.blksize), j;
            }, setattr(A, j) {
              j.mode !== void 0 && (A.mode = j.mode), j.timestamp !== void 0 && (A.timestamp = j.timestamp), j.size !== void 0 && q.resizeFileStorage(A, j.size);
            }, lookup(A, j) {
              throw k.genericErrors[44];
            }, mknod(A, j, t, e) {
              return q.createNode(A, j, t, e);
            }, rename(A, j, t) {
              if (k.isDir(A.mode)) {
                var e;
                try {
                  e = k.lookupNode(j, t);
                } catch {
                }
                if (e) for (var l in e.contents) throw new k.ErrnoError(55);
              }
              delete A.parent.contents[A.name], A.parent.timestamp = Date.now(), A.name = t, j.contents[t] = A, j.timestamp = A.parent.timestamp;
            }, unlink(A, j) {
              delete A.contents[j], A.timestamp = Date.now();
            }, rmdir(A, j) {
              var t = k.lookupNode(A, j);
              for (var e in t.contents) throw new k.ErrnoError(55);
              delete A.contents[j], A.timestamp = Date.now();
            }, readdir(A) {
              var j = [".", ".."];
              for (var t of Object.keys(A.contents)) j.push(t);
              return j;
            }, symlink(A, j, t) {
              var e = q.createNode(A, j, 41471, 0);
              return e.link = t, e;
            }, readlink(A) {
              if (!k.isLink(A.mode)) throw new k.ErrnoError(28);
              return A.link;
            } }, stream_ops: { read(A, j, t, e, l) {
              var _ = A.node.contents;
              if (l >= A.node.usedBytes) return 0;
              var a = Math.min(A.node.usedBytes - l, e);
              if (a > 8 && _.subarray) j.set(_.subarray(l, l + a), t);
              else for (var o = 0; o < a; o++) j[t + o] = _[l + o];
              return a;
            }, write(A, j, t, e, l, _) {
              if (j.buffer === J.buffer && (_ = false), !e) return 0;
              var a = A.node;
              if (a.timestamp = Date.now(), j.subarray && (!a.contents || a.contents.subarray)) {
                if (_) return a.contents = j.subarray(t, t + e), a.usedBytes = e, e;
                if (a.usedBytes === 0 && l === 0) return a.contents = j.slice(t, t + e), a.usedBytes = e, e;
                if (l + e <= a.usedBytes) return a.contents.set(j.subarray(t, t + e), l), e;
              }
              if (q.expandFileStorage(a, l + e), a.contents.subarray && j.subarray) a.contents.set(j.subarray(t, t + e), l);
              else for (var o = 0; o < e; o++) a.contents[l + o] = j[t + o];
              return a.usedBytes = Math.max(a.usedBytes, l + e), e;
            }, llseek(A, j, t) {
              var e = j;
              if (t === 1 ? e += A.position : t === 2 && k.isFile(A.node.mode) && (e += A.node.usedBytes), e < 0) throw new k.ErrnoError(28);
              return e;
            }, allocate(A, j, t) {
              q.expandFileStorage(A.node, j + t), A.node.usedBytes = Math.max(A.node.usedBytes, j + t);
            }, mmap(A, j, t, e, l) {
              if (!k.isFile(A.node.mode)) throw new k.ErrnoError(43);
              var _, a, o = A.node.contents;
              if (!(l & 2) && o.buffer === J.buffer) a = false, _ = o.byteOffset;
              else {
                if ((t > 0 || t + j < o.length) && (o.subarray ? o = o.subarray(t, t + j) : o = Array.prototype.slice.call(o, t, t + j)), a = true, _ = Ij(), !_) throw new k.ErrnoError(48);
                J.set(o, _);
              }
              return { ptr: _, allocated: a };
            }, msync(A, j, t, e, l) {
              return q.stream_ops.write(A, j, 0, e, t, false), 0;
            } } }, x6 = (A, j, t, e) => {
              var l = `al ${A}`;
              SA(A, (_) => {
                j(new Uint8Array(_)), l && NA();
              }, (_) => {
                if (t) t();
                else throw `Loading data file "${A}" failed.`;
              }), l && XA();
            }, L6 = (A, j, t, e, l, _) => {
              k.createDataFile(A, j, t, e, l, _);
            }, y6 = r.preloadPlugins || [], O6 = (A, j, t, e) => {
              typeof Browser != "undefined" && Browser.init();
              var l = false;
              return y6.forEach((_) => {
                l || _.canHandle(j) && (_.handle(A, j, t, e), l = true);
              }), l;
            }, J6 = (A, j, t, e, l, _, a, o, i, n) => {
              var s = j ? V.resolve(I.join2(A, j)) : A;
              function d(G) {
                function p(g) {
                  n == null || n(), o || L6(A, j, g, e, l, i), _ == null || _(), NA();
                }
                O6(G, s, p, () => {
                  a == null || a(), NA();
                }) || p(G);
              }
              XA(), typeof t == "string" ? x6(t, d, a) : d(t);
            }, b6 = (A) => {
              var j = { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 }, t = j[A];
              if (typeof t == "undefined") throw new Error(`Unknown file open mode: ${A}`);
              return t;
            }, WA = (A, j) => {
              var t = 0;
              return A && (t |= 365), j && (t |= 146), t;
            }, k = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, ErrnoError: class {
              constructor(A) {
                this.name = "ErrnoError", this.errno = A;
              }
            }, genericErrors: {}, filesystems: null, syncFSRequests: 0, FSStream: class {
              constructor() {
                this.shared = {};
              }
              get object() {
                return this.node;
              }
              set object(A) {
                this.node = A;
              }
              get isRead() {
                return (this.flags & 2097155) !== 1;
              }
              get isWrite() {
                return (this.flags & 2097155) !== 0;
              }
              get isAppend() {
                return this.flags & 1024;
              }
              get flags() {
                return this.shared.flags;
              }
              set flags(A) {
                this.shared.flags = A;
              }
              get position() {
                return this.shared.position;
              }
              set position(A) {
                this.shared.position = A;
              }
            }, FSNode: class {
              constructor(A, j, t, e) {
                A || (A = this), this.parent = A, this.mount = A.mount, this.mounted = null, this.id = k.nextInode++, this.name = j, this.mode = t, this.node_ops = {}, this.stream_ops = {}, this.rdev = e, this.readMode = 365, this.writeMode = 146;
              }
              get read() {
                return (this.mode & this.readMode) === this.readMode;
              }
              set read(A) {
                A ? this.mode |= this.readMode : this.mode &= ~this.readMode;
              }
              get write() {
                return (this.mode & this.writeMode) === this.writeMode;
              }
              set write(A) {
                A ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
              }
              get isFolder() {
                return k.isDir(this.mode);
              }
              get isDevice() {
                return k.isChrdev(this.mode);
              }
            }, lookupPath(A, j = {}) {
              if (A = V.resolve(A), !A) return { path: "", node: null };
              var t = { follow_mount: true, recurse_count: 0 };
              if (j = Object.assign(t, j), j.recurse_count > 8) throw new k.ErrnoError(32);
              for (var e = A.split("/").filter((u) => !!u), l = k.root, _ = "/", a = 0; a < e.length; a++) {
                var o = a === e.length - 1;
                if (o && j.parent) break;
                if (l = k.lookupNode(l, e[a]), _ = I.join2(_, e[a]), k.isMountpoint(l) && (!o || o && j.follow_mount) && (l = l.mounted.root), !o || j.follow) for (var i = 0; k.isLink(l.mode); ) {
                  var n = k.readlink(_);
                  _ = V.resolve(I.dirname(_), n);
                  var s = k.lookupPath(_, { recurse_count: j.recurse_count + 1 });
                  if (l = s.node, i++ > 40) throw new k.ErrnoError(32);
                }
              }
              return { path: _, node: l };
            }, getPath(A) {
              for (var j; ; ) {
                if (k.isRoot(A)) {
                  var t = A.mount.mountpoint;
                  return j ? t[t.length - 1] !== "/" ? `${t}/${j}` : t + j : t;
                }
                j = j ? `${A.name}/${j}` : A.name, A = A.parent;
              }
            }, hashName(A, j) {
              for (var t = 0, e = 0; e < j.length; e++) t = (t << 5) - t + j.charCodeAt(e) | 0;
              return (A + t >>> 0) % k.nameTable.length;
            }, hashAddNode(A) {
              var j = k.hashName(A.parent.id, A.name);
              A.name_next = k.nameTable[j], k.nameTable[j] = A;
            }, hashRemoveNode(A) {
              var j = k.hashName(A.parent.id, A.name);
              if (k.nameTable[j] === A) k.nameTable[j] = A.name_next;
              else for (var t = k.nameTable[j]; t; ) {
                if (t.name_next === A) {
                  t.name_next = A.name_next;
                  break;
                }
                t = t.name_next;
              }
            }, lookupNode(A, j) {
              var t = k.mayLookup(A);
              if (t) throw new k.ErrnoError(t);
              for (var e = k.hashName(A.id, j), l = k.nameTable[e]; l; l = l.name_next) {
                var _ = l.name;
                if (l.parent.id === A.id && _ === j) return l;
              }
              return k.lookup(A, j);
            }, createNode(A, j, t, e) {
              var l = new k.FSNode(A, j, t, e);
              return k.hashAddNode(l), l;
            }, destroyNode(A) {
              k.hashRemoveNode(A);
            }, isRoot(A) {
              return A === A.parent;
            }, isMountpoint(A) {
              return !!A.mounted;
            }, isFile(A) {
              return (A & 61440) === 32768;
            }, isDir(A) {
              return (A & 61440) === 16384;
            }, isLink(A) {
              return (A & 61440) === 40960;
            }, isChrdev(A) {
              return (A & 61440) === 8192;
            }, isBlkdev(A) {
              return (A & 61440) === 24576;
            }, isFIFO(A) {
              return (A & 61440) === 4096;
            }, isSocket(A) {
              return (A & 49152) === 49152;
            }, flagsToPermissionString(A) {
              var j = ["r", "w", "rw"][A & 3];
              return A & 512 && (j += "w"), j;
            }, nodePermissions(A, j) {
              return k.ignorePermissions ? 0 : j.includes("r") && !(A.mode & 292) || j.includes("w") && !(A.mode & 146) || j.includes("x") && !(A.mode & 73) ? 2 : 0;
            }, mayLookup(A) {
              if (!k.isDir(A.mode)) return 54;
              var j = k.nodePermissions(A, "x");
              return j || (A.node_ops.lookup ? 0 : 2);
            }, mayCreate(A, j) {
              try {
                var t = k.lookupNode(A, j);
                return 20;
              } catch {
              }
              return k.nodePermissions(A, "wx");
            }, mayDelete(A, j, t) {
              var e;
              try {
                e = k.lookupNode(A, j);
              } catch (_) {
                return _.errno;
              }
              var l = k.nodePermissions(A, "wx");
              if (l) return l;
              if (t) {
                if (!k.isDir(e.mode)) return 54;
                if (k.isRoot(e) || k.getPath(e) === k.cwd()) return 10;
              } else if (k.isDir(e.mode)) return 31;
              return 0;
            }, mayOpen(A, j) {
              return A ? k.isLink(A.mode) ? 32 : k.isDir(A.mode) && (k.flagsToPermissionString(j) !== "r" || j & 512) ? 31 : k.nodePermissions(A, k.flagsToPermissionString(j)) : 44;
            }, MAX_OPEN_FDS: 4096, nextfd() {
              for (var A = 0; A <= k.MAX_OPEN_FDS; A++) if (!k.streams[A]) return A;
              throw new k.ErrnoError(33);
            }, getStreamChecked(A) {
              var j = k.getStream(A);
              if (!j) throw new k.ErrnoError(8);
              return j;
            }, getStream: (A) => k.streams[A], createStream(A, j = -1) {
              return A = Object.assign(new k.FSStream(), A), j == -1 && (j = k.nextfd()), A.fd = j, k.streams[j] = A, A;
            }, closeStream(A) {
              k.streams[A] = null;
            }, dupStream(A, j = -1) {
              var t, e, l = k.createStream(A, j);
              return (e = (t = l.stream_ops) == null ? void 0 : t.dup) == null || e.call(t, l), l;
            }, chrdev_stream_ops: { open(A) {
              var j, t, e = k.getDevice(A.node.rdev);
              A.stream_ops = e.stream_ops, (t = (j = A.stream_ops).open) == null || t.call(j, A);
            }, llseek() {
              throw new k.ErrnoError(70);
            } }, major: (A) => A >> 8, minor: (A) => A & 255, makedev: (A, j) => A << 8 | j, registerDevice(A, j) {
              k.devices[A] = { stream_ops: j };
            }, getDevice: (A) => k.devices[A], getMounts(A) {
              for (var j = [], t = [A]; t.length; ) {
                var e = t.pop();
                j.push(e), t.push(...e.mounts);
              }
              return j;
            }, syncfs(A, j) {
              typeof A == "function" && (j = A, A = false), k.syncFSRequests++, k.syncFSRequests > 1 && oA(`warning: ${k.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
              var t = k.getMounts(k.root.mount), e = 0;
              function l(a) {
                return k.syncFSRequests--, j(a);
              }
              function _(a) {
                if (a) return _.errored ? void 0 : (_.errored = true, l(a));
                ++e >= t.length && l(null);
              }
              t.forEach((a) => {
                if (!a.type.syncfs) return _(null);
                a.type.syncfs(a, A, _);
              });
            }, mount(A, j, t) {
              var e = t === "/", l = !t, _;
              if (e && k.root) throw new k.ErrnoError(10);
              if (!e && !l) {
                var a = k.lookupPath(t, { follow_mount: false });
                if (t = a.path, _ = a.node, k.isMountpoint(_)) throw new k.ErrnoError(10);
                if (!k.isDir(_.mode)) throw new k.ErrnoError(54);
              }
              var o = { type: A, opts: j, mountpoint: t, mounts: [] }, i = A.mount(o);
              return i.mount = o, o.root = i, e ? k.root = i : _ && (_.mounted = o, _.mount && _.mount.mounts.push(o)), i;
            }, unmount(A) {
              var j = k.lookupPath(A, { follow_mount: false });
              if (!k.isMountpoint(j.node)) throw new k.ErrnoError(28);
              var t = j.node, e = t.mounted, l = k.getMounts(e);
              Object.keys(k.nameTable).forEach((a) => {
                for (var o = k.nameTable[a]; o; ) {
                  var i = o.name_next;
                  l.includes(o.mount) && k.destroyNode(o), o = i;
                }
              }), t.mounted = null;
              var _ = t.mount.mounts.indexOf(e);
              t.mount.mounts.splice(_, 1);
            }, lookup(A, j) {
              return A.node_ops.lookup(A, j);
            }, mknod(A, j, t) {
              var e = k.lookupPath(A, { parent: true }), l = e.node, _ = I.basename(A);
              if (!_ || _ === "." || _ === "..") throw new k.ErrnoError(28);
              var a = k.mayCreate(l, _);
              if (a) throw new k.ErrnoError(a);
              if (!l.node_ops.mknod) throw new k.ErrnoError(63);
              return l.node_ops.mknod(l, _, j, t);
            }, create(A, j) {
              return j = j !== void 0 ? j : 438, j &= 4095, j |= 32768, k.mknod(A, j, 0);
            }, mkdir(A, j) {
              return j = j !== void 0 ? j : 511, j &= 1023, j |= 16384, k.mknod(A, j, 0);
            }, mkdirTree(A, j) {
              for (var t = A.split("/"), e = "", l = 0; l < t.length; ++l) if (t[l]) {
                e += "/" + t[l];
                try {
                  k.mkdir(e, j);
                } catch (_) {
                  if (_.errno != 20) throw _;
                }
              }
            }, mkdev(A, j, t) {
              return typeof t == "undefined" && (t = j, j = 438), j |= 8192, k.mknod(A, j, t);
            }, symlink(A, j) {
              if (!V.resolve(A)) throw new k.ErrnoError(44);
              var t = k.lookupPath(j, { parent: true }), e = t.node;
              if (!e) throw new k.ErrnoError(44);
              var l = I.basename(j), _ = k.mayCreate(e, l);
              if (_) throw new k.ErrnoError(_);
              if (!e.node_ops.symlink) throw new k.ErrnoError(63);
              return e.node_ops.symlink(e, l, A);
            }, rename(A, j) {
              var t = I.dirname(A), e = I.dirname(j), l = I.basename(A), _ = I.basename(j), a, o, i;
              if (a = k.lookupPath(A, { parent: true }), o = a.node, a = k.lookupPath(j, { parent: true }), i = a.node, !o || !i) throw new k.ErrnoError(44);
              if (o.mount !== i.mount) throw new k.ErrnoError(75);
              var n = k.lookupNode(o, l), s = V.relative(A, e);
              if (s.charAt(0) !== ".") throw new k.ErrnoError(28);
              if (s = V.relative(j, t), s.charAt(0) !== ".") throw new k.ErrnoError(55);
              var u;
              try {
                u = k.lookupNode(i, _);
              } catch {
              }
              if (n !== u) {
                var d = k.isDir(n.mode), G = k.mayDelete(o, l, d);
                if (G) throw new k.ErrnoError(G);
                if (G = u ? k.mayDelete(i, _, d) : k.mayCreate(i, _), G) throw new k.ErrnoError(G);
                if (!o.node_ops.rename) throw new k.ErrnoError(63);
                if (k.isMountpoint(n) || u && k.isMountpoint(u)) throw new k.ErrnoError(10);
                if (i !== o && (G = k.nodePermissions(o, "w"), G)) throw new k.ErrnoError(G);
                k.hashRemoveNode(n);
                try {
                  o.node_ops.rename(n, i, _), n.parent = i;
                } catch (p) {
                  throw p;
                } finally {
                  k.hashAddNode(n);
                }
              }
            }, rmdir(A) {
              var j = k.lookupPath(A, { parent: true }), t = j.node, e = I.basename(A), l = k.lookupNode(t, e), _ = k.mayDelete(t, e, true);
              if (_) throw new k.ErrnoError(_);
              if (!t.node_ops.rmdir) throw new k.ErrnoError(63);
              if (k.isMountpoint(l)) throw new k.ErrnoError(10);
              t.node_ops.rmdir(t, e), k.destroyNode(l);
            }, readdir(A) {
              var j = k.lookupPath(A, { follow: true }), t = j.node;
              if (!t.node_ops.readdir) throw new k.ErrnoError(54);
              return t.node_ops.readdir(t);
            }, unlink(A) {
              var j = k.lookupPath(A, { parent: true }), t = j.node;
              if (!t) throw new k.ErrnoError(44);
              var e = I.basename(A), l = k.lookupNode(t, e), _ = k.mayDelete(t, e, false);
              if (_) throw new k.ErrnoError(_);
              if (!t.node_ops.unlink) throw new k.ErrnoError(63);
              if (k.isMountpoint(l)) throw new k.ErrnoError(10);
              t.node_ops.unlink(t, e), k.destroyNode(l);
            }, readlink(A) {
              var j = k.lookupPath(A), t = j.node;
              if (!t) throw new k.ErrnoError(44);
              if (!t.node_ops.readlink) throw new k.ErrnoError(28);
              return V.resolve(k.getPath(t.parent), t.node_ops.readlink(t));
            }, stat(A, j) {
              var t = k.lookupPath(A, { follow: !j }), e = t.node;
              if (!e) throw new k.ErrnoError(44);
              if (!e.node_ops.getattr) throw new k.ErrnoError(63);
              return e.node_ops.getattr(e);
            }, lstat(A) {
              return k.stat(A, true);
            }, chmod(A, j, t) {
              var e;
              if (typeof A == "string") {
                var l = k.lookupPath(A, { follow: !t });
                e = l.node;
              } else e = A;
              if (!e.node_ops.setattr) throw new k.ErrnoError(63);
              e.node_ops.setattr(e, { mode: j & 4095 | e.mode & -4096, timestamp: Date.now() });
            }, lchmod(A, j) {
              k.chmod(A, j, true);
            }, fchmod(A, j) {
              var t = k.getStreamChecked(A);
              k.chmod(t.node, j);
            }, chown(A, j, t, e) {
              var l;
              if (typeof A == "string") {
                var _ = k.lookupPath(A, { follow: !e });
                l = _.node;
              } else l = A;
              if (!l.node_ops.setattr) throw new k.ErrnoError(63);
              l.node_ops.setattr(l, { timestamp: Date.now() });
            }, lchown(A, j, t) {
              k.chown(A, j, t, true);
            }, fchown(A, j, t) {
              var e = k.getStreamChecked(A);
              k.chown(e.node, j, t);
            }, truncate(A, j) {
              if (j < 0) throw new k.ErrnoError(28);
              var t;
              if (typeof A == "string") {
                var e = k.lookupPath(A, { follow: true });
                t = e.node;
              } else t = A;
              if (!t.node_ops.setattr) throw new k.ErrnoError(63);
              if (k.isDir(t.mode)) throw new k.ErrnoError(31);
              if (!k.isFile(t.mode)) throw new k.ErrnoError(28);
              var l = k.nodePermissions(t, "w");
              if (l) throw new k.ErrnoError(l);
              t.node_ops.setattr(t, { size: j, timestamp: Date.now() });
            }, ftruncate(A, j) {
              var t = k.getStreamChecked(A);
              if (!(t.flags & 2097155)) throw new k.ErrnoError(28);
              k.truncate(t.node, j);
            }, utime(A, j, t) {
              var e = k.lookupPath(A, { follow: true }), l = e.node;
              l.node_ops.setattr(l, { timestamp: Math.max(j, t) });
            }, open(A, j, t) {
              if (A === "") throw new k.ErrnoError(44);
              j = typeof j == "string" ? b6(j) : j, j & 64 ? (t = typeof t == "undefined" ? 438 : t, t = t & 4095 | 32768) : t = 0;
              var e;
              if (typeof A == "object") e = A;
              else {
                A = I.normalize(A);
                try {
                  var l = k.lookupPath(A, { follow: !(j & 131072) });
                  e = l.node;
                } catch {
                }
              }
              var _ = false;
              if (j & 64) if (e) {
                if (j & 128) throw new k.ErrnoError(20);
              } else e = k.mknod(A, t, 0), _ = true;
              if (!e) throw new k.ErrnoError(44);
              if (k.isChrdev(e.mode) && (j &= -513), j & 65536 && !k.isDir(e.mode)) throw new k.ErrnoError(54);
              if (!_) {
                var a = k.mayOpen(e, j);
                if (a) throw new k.ErrnoError(a);
              }
              j & 512 && !_ && k.truncate(e, 0), j &= -131713;
              var o = k.createStream({ node: e, path: k.getPath(e), flags: j, seekable: true, position: 0, stream_ops: e.stream_ops, ungotten: [], error: false });
              return o.stream_ops.open && o.stream_ops.open(o), r.logReadFiles && !(j & 1) && (k.readFiles || (k.readFiles = {}), A in k.readFiles || (k.readFiles[A] = 1)), o;
            }, close(A) {
              if (k.isClosed(A)) throw new k.ErrnoError(8);
              A.getdents && (A.getdents = null);
              try {
                A.stream_ops.close && A.stream_ops.close(A);
              } catch (j) {
                throw j;
              } finally {
                k.closeStream(A.fd);
              }
              A.fd = null;
            }, isClosed(A) {
              return A.fd === null;
            }, llseek(A, j, t) {
              if (k.isClosed(A)) throw new k.ErrnoError(8);
              if (!A.seekable || !A.stream_ops.llseek) throw new k.ErrnoError(70);
              if (t != 0 && t != 1 && t != 2) throw new k.ErrnoError(28);
              return A.position = A.stream_ops.llseek(A, j, t), A.ungotten = [], A.position;
            }, read(A, j, t, e, l) {
              if (e < 0 || l < 0) throw new k.ErrnoError(28);
              if (k.isClosed(A)) throw new k.ErrnoError(8);
              if ((A.flags & 2097155) === 1) throw new k.ErrnoError(8);
              if (k.isDir(A.node.mode)) throw new k.ErrnoError(31);
              if (!A.stream_ops.read) throw new k.ErrnoError(28);
              var _ = typeof l != "undefined";
              if (!_) l = A.position;
              else if (!A.seekable) throw new k.ErrnoError(70);
              var a = A.stream_ops.read(A, j, t, e, l);
              return _ || (A.position += a), a;
            }, write(A, j, t, e, l, _) {
              if (e < 0 || l < 0) throw new k.ErrnoError(28);
              if (k.isClosed(A)) throw new k.ErrnoError(8);
              if (!(A.flags & 2097155)) throw new k.ErrnoError(8);
              if (k.isDir(A.node.mode)) throw new k.ErrnoError(31);
              if (!A.stream_ops.write) throw new k.ErrnoError(28);
              A.seekable && A.flags & 1024 && k.llseek(A, 0, 2);
              var a = typeof l != "undefined";
              if (!a) l = A.position;
              else if (!A.seekable) throw new k.ErrnoError(70);
              var o = A.stream_ops.write(A, j, t, e, l, _);
              return a || (A.position += o), o;
            }, allocate(A, j, t) {
              if (k.isClosed(A)) throw new k.ErrnoError(8);
              if (j < 0 || t <= 0) throw new k.ErrnoError(28);
              if (!(A.flags & 2097155)) throw new k.ErrnoError(8);
              if (!k.isFile(A.node.mode) && !k.isDir(A.node.mode)) throw new k.ErrnoError(43);
              if (!A.stream_ops.allocate) throw new k.ErrnoError(138);
              A.stream_ops.allocate(A, j, t);
            }, mmap(A, j, t, e, l) {
              if (e & 2 && !(l & 2) && (A.flags & 2097155) !== 2) throw new k.ErrnoError(2);
              if ((A.flags & 2097155) === 1) throw new k.ErrnoError(2);
              if (!A.stream_ops.mmap) throw new k.ErrnoError(43);
              return A.stream_ops.mmap(A, j, t, e, l);
            }, msync(A, j, t, e, l) {
              return A.stream_ops.msync ? A.stream_ops.msync(A, j, t, e, l) : 0;
            }, ioctl(A, j, t) {
              if (!A.stream_ops.ioctl) throw new k.ErrnoError(59);
              return A.stream_ops.ioctl(A, j, t);
            }, readFile(A, j = {}) {
              if (j.flags = j.flags || 0, j.encoding = j.encoding || "binary", j.encoding !== "utf8" && j.encoding !== "binary") throw new Error(`Invalid encoding type "${j.encoding}"`);
              var t, e = k.open(A, j.flags), l = k.stat(A), _ = l.size, a = new Uint8Array(_);
              return k.read(e, a, 0, _, 0), j.encoding === "utf8" ? t = kA(a, 0) : j.encoding === "binary" && (t = a), k.close(e), t;
            }, writeFile(A, j, t = {}) {
              t.flags = t.flags || 577;
              var e = k.open(A, t.flags, t.mode);
              if (typeof j == "string") {
                var l = new Uint8Array(YA(j) + 1), _ = zA(j, l, 0, l.length);
                k.write(e, l, 0, _, void 0, t.canOwn);
              } else if (ArrayBuffer.isView(j)) k.write(e, j, 0, j.byteLength, void 0, t.canOwn);
              else throw new Error("Unsupported data type");
              k.close(e);
            }, cwd: () => k.currentPath, chdir(A) {
              var j = k.lookupPath(A, { follow: true });
              if (j.node === null) throw new k.ErrnoError(44);
              if (!k.isDir(j.node.mode)) throw new k.ErrnoError(54);
              var t = k.nodePermissions(j.node, "x");
              if (t) throw new k.ErrnoError(t);
              k.currentPath = j.path;
            }, createDefaultDirectories() {
              k.mkdir("/tmp"), k.mkdir("/home"), k.mkdir("/home/web_user");
            }, createDefaultDevices() {
              k.mkdir("/dev"), k.registerDevice(k.makedev(1, 3), { read: () => 0, write: (e, l, _, a, o) => a }), k.mkdev("/dev/null", k.makedev(1, 3)), W.register(k.makedev(5, 0), W.default_tty_ops), W.register(k.makedev(6, 0), W.default_tty1_ops), k.mkdev("/dev/tty", k.makedev(5, 0)), k.mkdev("/dev/tty1", k.makedev(6, 0));
              var A = new Uint8Array(1024), j = 0, t = () => (j === 0 && (j = Fj(A).byteLength), A[--j]);
              k.createDevice("/dev", "random", t), k.createDevice("/dev", "urandom", t), k.mkdir("/dev/shm"), k.mkdir("/dev/shm/tmp");
            }, createSpecialDirectories() {
              k.mkdir("/proc");
              var A = k.mkdir("/proc/self");
              k.mkdir("/proc/self/fd"), k.mount({ mount() {
                var j = k.createNode(A, "fd", 16895, 73);
                return j.node_ops = { lookup(t, e) {
                  var l = +e, _ = k.getStreamChecked(l), a = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: () => _.path } };
                  return a.parent = a, a;
                } }, j;
              } }, {}, "/proc/self/fd");
            }, createStandardStreams() {
              r.stdin ? k.createDevice("/dev", "stdin", r.stdin) : k.symlink("/dev/tty", "/dev/stdin"), r.stdout ? k.createDevice("/dev", "stdout", null, r.stdout) : k.symlink("/dev/tty", "/dev/stdout"), r.stderr ? k.createDevice("/dev", "stderr", null, r.stderr) : k.symlink("/dev/tty1", "/dev/stderr");
              k.open("/dev/stdin", 0);
              k.open("/dev/stdout", 1);
              k.open("/dev/stderr", 1);
            }, staticInit() {
              [44].forEach((A) => {
                k.genericErrors[A] = new k.ErrnoError(A), k.genericErrors[A].stack = "<generic error, no stack>";
              }), k.nameTable = new Array(4096), k.mount(q, {}, "/"), k.createDefaultDirectories(), k.createDefaultDevices(), k.createSpecialDirectories(), k.filesystems = { MEMFS: q };
            }, init(A, j, t) {
              k.init.initialized = true, r.stdin = A || r.stdin, r.stdout = j || r.stdout, r.stderr = t || r.stderr, k.createStandardStreams();
            }, quit() {
              k.init.initialized = false;
              for (var A = 0; A < k.streams.length; A++) {
                var j = k.streams[A];
                j && k.close(j);
              }
            }, findObject(A, j) {
              var t = k.analyzePath(A, j);
              return t.exists ? t.object : null;
            }, analyzePath(A, j) {
              try {
                var t = k.lookupPath(A, { follow: !j });
                A = t.path;
              } catch {
              }
              var e = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
              try {
                var t = k.lookupPath(A, { parent: true });
                e.parentExists = true, e.parentPath = t.path, e.parentObject = t.node, e.name = I.basename(A), t = k.lookupPath(A, { follow: !j }), e.exists = true, e.path = t.path, e.object = t.node, e.name = t.node.name, e.isRoot = t.path === "/";
              } catch (l) {
                e.error = l.errno;
              }
              return e;
            }, createPath(A, j, t, e) {
              A = typeof A == "string" ? A : k.getPath(A);
              for (var l = j.split("/").reverse(); l.length; ) {
                var _ = l.pop();
                if (_) {
                  var a = I.join2(A, _);
                  try {
                    k.mkdir(a);
                  } catch {
                  }
                  A = a;
                }
              }
              return a;
            }, createFile(A, j, t, e, l) {
              var _ = I.join2(typeof A == "string" ? A : k.getPath(A), j), a = WA(e, l);
              return k.create(_, a);
            }, createDataFile(A, j, t, e, l, _) {
              var a = j;
              A && (A = typeof A == "string" ? A : k.getPath(A), a = j ? I.join2(A, j) : A);
              var o = WA(e, l), i = k.create(a, o);
              if (t) {
                if (typeof t == "string") {
                  for (var n = new Array(t.length), s = 0, u = t.length; s < u; ++s) n[s] = t.charCodeAt(s);
                  t = n;
                }
                k.chmod(i, o | 146);
                var d = k.open(i, 577);
                k.write(d, t, 0, t.length, 0, _), k.close(d), k.chmod(i, o);
              }
            }, createDevice(A, j, t, e) {
              var l = I.join2(typeof A == "string" ? A : k.getPath(A), j), _ = WA(!!t, !!e);
              k.createDevice.major || (k.createDevice.major = 64);
              var a = k.makedev(k.createDevice.major++, 0);
              return k.registerDevice(a, { open(o) {
                o.seekable = false;
              }, close(o) {
                var i;
                (i = e == null ? void 0 : e.buffer) != null && i.length && e(10);
              }, read(o, i, n, s, u) {
                for (var d = 0, G = 0; G < s; G++) {
                  var p;
                  try {
                    p = t();
                  } catch {
                    throw new k.ErrnoError(29);
                  }
                  if (p === void 0 && d === 0) throw new k.ErrnoError(6);
                  if (p == null) break;
                  d++, i[n + G] = p;
                }
                return d && (o.node.timestamp = Date.now()), d;
              }, write(o, i, n, s, u) {
                for (var d = 0; d < s; d++) try {
                  e(i[n + d]);
                } catch {
                  throw new k.ErrnoError(29);
                }
                return s && (o.node.timestamp = Date.now()), d;
              } }), k.mkdev(l, _, a);
            }, forceLoadFile(A) {
              if (A.isDevice || A.isFolder || A.link || A.contents) return true;
              if (typeof XMLHttpRequest != "undefined") throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
              if (aA) try {
                A.contents = FA(aA(A.url), true), A.usedBytes = A.contents.length;
              } catch {
                throw new k.ErrnoError(29);
              }
              else throw new Error("Cannot load without read() or XMLHttpRequest.");
            }, createLazyFile(A, j, t, e, l) {
              class _ {
                constructor() {
                  this.lengthKnown = false, this.chunks = [];
                }
                get(G) {
                  if (!(G > this.length - 1 || G < 0)) {
                    var p = G % this.chunkSize, g = G / this.chunkSize | 0;
                    return this.getter(g)[p];
                  }
                }
                setDataGetter(G) {
                  this.getter = G;
                }
                cacheLength() {
                  var G = new XMLHttpRequest();
                  if (G.open("HEAD", t, false), G.send(null), !(G.status >= 200 && G.status < 300 || G.status === 304)) throw new Error("Couldn't load " + t + ". Status: " + G.status);
                  var p = Number(G.getResponseHeader("Content-length")), g, O = (g = G.getResponseHeader("Accept-Ranges")) && g === "bytes", F = (g = G.getResponseHeader("Content-Encoding")) && g === "gzip", E = 1024 * 1024;
                  O || (E = p);
                  var $ = (c, S) => {
                    if (c > S) throw new Error("invalid range (" + c + ", " + S + ") or no bytes requested!");
                    if (S > p - 1) throw new Error("only " + p + " bytes available! programmer error!");
                    var L = new XMLHttpRequest();
                    if (L.open("GET", t, false), p !== E && L.setRequestHeader("Range", "bytes=" + c + "-" + S), L.responseType = "arraybuffer", L.overrideMimeType && L.overrideMimeType("text/plain; charset=x-user-defined"), L.send(null), !(L.status >= 200 && L.status < 300 || L.status === 304)) throw new Error("Couldn't load " + t + ". Status: " + L.status);
                    return L.response !== void 0 ? new Uint8Array(L.response || []) : FA(L.responseText || "", true);
                  }, x = this;
                  x.setDataGetter((c) => {
                    var S = c * E, L = (c + 1) * E - 1;
                    if (L = Math.min(L, p - 1), typeof x.chunks[c] == "undefined" && (x.chunks[c] = $(S, L)), typeof x.chunks[c] == "undefined") throw new Error("doXHR failed!");
                    return x.chunks[c];
                  }), (F || !p) && (E = p = 1, p = this.getter(0).length, E = p, MA("LazyFiles on gzip forces download of the whole file when length is accessed")), this._length = p, this._chunkSize = E, this.lengthKnown = true;
                }
                get length() {
                  return this.lengthKnown || this.cacheLength(), this._length;
                }
                get chunkSize() {
                  return this.lengthKnown || this.cacheLength(), this._chunkSize;
                }
              }
              if (typeof XMLHttpRequest != "undefined") {
                if (!jA) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
                var a = new _(), o = { isDevice: false, contents: a };
              } else var o = { isDevice: false, url: t };
              var i = k.createFile(A, j, o, e, l);
              o.contents ? i.contents = o.contents : o.url && (i.contents = null, i.url = o.url), Object.defineProperties(i, { usedBytes: { get: function() {
                return this.contents.length;
              } } });
              var n = {}, s = Object.keys(i.stream_ops);
              s.forEach((d) => {
                var G = i.stream_ops[d];
                n[d] = (...p) => (k.forceLoadFile(i), G(...p));
              });
              function u(d, G, p, g, O) {
                var F = d.node.contents;
                if (O >= F.length) return 0;
                var E = Math.min(F.length - O, g);
                if (F.slice) for (var $ = 0; $ < E; $++) G[p + $] = F[O + $];
                else for (var $ = 0; $ < E; $++) G[p + $] = F.get(O + $);
                return E;
              }
              return n.read = (d, G, p, g, O) => (k.forceLoadFile(i), u(d, G, p, g, O)), n.mmap = (d, G, p, g, O) => {
                k.forceLoadFile(i);
                var F = Ij();
                if (!F) throw new k.ErrnoError(48);
                return u(d, J, F, G, p), { ptr: F, allocated: true };
              }, i.stream_ops = n, i;
            } }, w = { DEFAULT_POLLMASK: 5, calculateAt(A, j, t) {
              if (I.isAbs(j)) return j;
              var e;
              if (A === -100) e = k.cwd();
              else {
                var l = w.getStreamFromFD(A);
                e = l.path;
              }
              if (j.length == 0) {
                if (!t) throw new k.ErrnoError(44);
                return e;
              }
              return I.join2(e, j);
            }, doStat(A, j, t) {
              var e = A(j);
              H[t >> 2] = e.dev, H[t + 4 >> 2] = e.mode, m[t + 8 >> 2] = e.nlink, H[t + 12 >> 2] = e.uid, H[t + 16 >> 2] = e.gid, H[t + 20 >> 2] = e.rdev, b = [e.size >>> 0, (h = e.size, +Math.abs(h) >= 1 ? h > 0 ? +Math.floor(h / 4294967296) >>> 0 : ~~+Math.ceil((h - +(~~h >>> 0)) / 4294967296) >>> 0 : 0)], H[t + 24 >> 2] = b[0], H[t + 28 >> 2] = b[1], H[t + 32 >> 2] = 4096, H[t + 36 >> 2] = e.blocks;
              var l = e.atime.getTime(), _ = e.mtime.getTime(), a = e.ctime.getTime();
              return b = [Math.floor(l / 1e3) >>> 0, (h = Math.floor(l / 1e3), +Math.abs(h) >= 1 ? h > 0 ? +Math.floor(h / 4294967296) >>> 0 : ~~+Math.ceil((h - +(~~h >>> 0)) / 4294967296) >>> 0 : 0)], H[t + 40 >> 2] = b[0], H[t + 44 >> 2] = b[1], m[t + 48 >> 2] = l % 1e3 * 1e3, b = [Math.floor(_ / 1e3) >>> 0, (h = Math.floor(_ / 1e3), +Math.abs(h) >= 1 ? h > 0 ? +Math.floor(h / 4294967296) >>> 0 : ~~+Math.ceil((h - +(~~h >>> 0)) / 4294967296) >>> 0 : 0)], H[t + 56 >> 2] = b[0], H[t + 60 >> 2] = b[1], m[t + 64 >> 2] = _ % 1e3 * 1e3, b = [Math.floor(a / 1e3) >>> 0, (h = Math.floor(a / 1e3), +Math.abs(h) >= 1 ? h > 0 ? +Math.floor(h / 4294967296) >>> 0 : ~~+Math.ceil((h - +(~~h >>> 0)) / 4294967296) >>> 0 : 0)], H[t + 72 >> 2] = b[0], H[t + 76 >> 2] = b[1], m[t + 80 >> 2] = a % 1e3 * 1e3, b = [e.ino >>> 0, (h = e.ino, +Math.abs(h) >= 1 ? h > 0 ? +Math.floor(h / 4294967296) >>> 0 : ~~+Math.ceil((h - +(~~h >>> 0)) / 4294967296) >>> 0 : 0)], H[t + 88 >> 2] = b[0], H[t + 92 >> 2] = b[1], 0;
            }, doMsync(A, j, t, e, l) {
              if (!k.isFile(j.node.mode)) throw new k.ErrnoError(43);
              if (e & 2) return 0;
              var _ = D.slice(A, A + t);
              k.msync(j, _, l, t, e);
            }, getStreamFromFD(A) {
              var j = k.getStreamChecked(A);
              return j;
            }, varargs: void 0, getStr(A) {
              var j = eA(A);
              return j;
            } };
            function D6(A, j, t) {
              w.varargs = t;
              try {
                var e = w.getStreamFromFD(A);
                switch (j) {
                  case 0: {
                    var l = vA();
                    if (l < 0) return -28;
                    for (; k.streams[l]; ) l++;
                    var _;
                    return _ = k.dupStream(e, l), _.fd;
                  }
                  case 1:
                  case 2:
                    return 0;
                  case 3:
                    return e.flags;
                  case 4: {
                    var l = vA();
                    return e.flags |= l, 0;
                  }
                  case 12: {
                    var l = lA(), a = 0;
                    return R[l + a >> 1] = 2, 0;
                  }
                  case 13:
                  case 14:
                    return 0;
                }
                return -28;
              } catch (o) {
                if (typeof k == "undefined" || o.name !== "ErrnoError") throw o;
                return -o.errno;
              }
            }
            function w6(A, j, t) {
              w.varargs = t;
              try {
                var e = w.getStreamFromFD(A);
                switch (j) {
                  case 21509:
                    return e.tty ? 0 : -59;
                  case 21505: {
                    if (!e.tty) return -59;
                    if (e.tty.ops.ioctl_tcgets) {
                      var l = e.tty.ops.ioctl_tcgets(e), _ = lA();
                      H[_ >> 2] = l.c_iflag || 0, H[_ + 4 >> 2] = l.c_oflag || 0, H[_ + 8 >> 2] = l.c_cflag || 0, H[_ + 12 >> 2] = l.c_lflag || 0;
                      for (var a = 0; a < 32; a++) J[_ + a + 17] = l.c_cc[a] || 0;
                      return 0;
                    }
                    return 0;
                  }
                  case 21510:
                  case 21511:
                  case 21512:
                    return e.tty ? 0 : -59;
                  case 21506:
                  case 21507:
                  case 21508: {
                    if (!e.tty) return -59;
                    if (e.tty.ops.ioctl_tcsets) {
                      for (var _ = lA(), o = H[_ >> 2], i = H[_ + 4 >> 2], n = H[_ + 8 >> 2], s = H[_ + 12 >> 2], u = [], a = 0; a < 32; a++) u.push(J[_ + a + 17]);
                      return e.tty.ops.ioctl_tcsets(e.tty, j, { c_iflag: o, c_oflag: i, c_cflag: n, c_lflag: s, c_cc: u });
                    }
                    return 0;
                  }
                  case 21519: {
                    if (!e.tty) return -59;
                    var _ = lA();
                    return H[_ >> 2] = 0, 0;
                  }
                  case 21520:
                    return e.tty ? -28 : -59;
                  case 21531: {
                    var _ = lA();
                    return k.ioctl(e, j, _);
                  }
                  case 21523: {
                    if (!e.tty) return -59;
                    if (e.tty.ops.ioctl_tiocgwinsz) {
                      var d = e.tty.ops.ioctl_tiocgwinsz(e.tty), _ = lA();
                      R[_ >> 1] = d[0], R[_ + 2 >> 1] = d[1];
                    }
                    return 0;
                  }
                  case 21524:
                    return e.tty ? 0 : -59;
                  case 21515:
                    return e.tty ? 0 : -59;
                  default:
                    return -28;
                }
              } catch (G) {
                if (typeof k == "undefined" || G.name !== "ErrnoError") throw G;
                return -G.errno;
              }
            }
            function C6(A, j, t, e) {
              w.varargs = e;
              try {
                j = w.getStr(j), j = w.calculateAt(A, j);
                var l = e ? vA() : 0;
                return k.open(j, t, l).fd;
              } catch (_) {
                if (typeof k == "undefined" || _.name !== "ErrnoError") throw _;
                return -_.errno;
              }
            }
            function S6(A, j, t) {
              try {
                return j = w.getStr(j), j = w.calculateAt(A, j), t === 0 ? k.unlink(j) : t === 512 ? k.rmdir(j) : nA("Invalid flags passed to unlinkat"), 0;
              } catch (e) {
                if (typeof k == "undefined" || e.name !== "ErrnoError") throw e;
                return -e.errno;
              }
            }
            var P6 = () => {
              nA("");
            }, IA = {}, ZA = (A) => {
              for (; A.length; ) {
                var j = A.pop(), t = A.pop();
                t(j);
              }
            };
            function sA(A) {
              return this.fromWireType(m[A >> 2]);
            }
            var BA = {}, rA = {}, gA = {}, gj, xA = (A) => {
              throw new gj(A);
            }, QA = (A, j, t) => {
              A.forEach(function(o) {
                gA[o] = j;
              });
              function e(o) {
                var i = t(o);
                i.length !== A.length && xA("Mismatched type converter count");
                for (var n = 0; n < A.length; ++n) T(A[n], i[n]);
              }
              var l = new Array(j.length), _ = [], a = 0;
              j.forEach((o, i) => {
                rA.hasOwnProperty(o) ? l[i] = rA[o] : (_.push(o), BA.hasOwnProperty(o) || (BA[o] = []), BA[o].push(() => {
                  l[i] = rA[o], ++a, a === _.length && e(l);
                }));
              }), _.length === 0 && e(l);
            }, M6 = (A) => {
              var j = IA[A];
              delete IA[A];
              var t = j.rawConstructor, e = j.rawDestructor, l = j.fields, _ = l.map((a) => a.getterReturnType).concat(l.map((a) => a.setterArgumentType));
              QA([A], _, (a) => {
                var o = {};
                return l.forEach((i, n) => {
                  var s = i.fieldName, u = a[n], d = i.getter, G = i.getterContext, p = a[n + l.length], g = i.setter, O = i.setterContext;
                  o[s] = { read: (F) => u.fromWireType(d(G, F)), write: (F, E) => {
                    var $ = [];
                    g(O, F, p.toWireType($, E)), ZA($);
                  } };
                }), [{ name: j.name, fromWireType: (i) => {
                  var n = {};
                  for (var s in o) n[s] = o[s].read(i);
                  return e(i), n;
                }, toWireType: (i, n) => {
                  for (var s in o) if (!(s in n)) throw new TypeError(`Missing field: "${s}"`);
                  var u = t();
                  for (s in o) o[s].write(u, n[s]);
                  return i !== null && i.push(e, u), u;
                }, argPackAdvance: X, readValueFromPointer: sA, destructorFunction: e }];
              });
            }, K6 = (A, j, t, e, l) => {
            }, T6 = () => {
              for (var A = new Array(256), j = 0; j < 256; ++j) A[j] = String.fromCharCode(j);
              xj = A;
            }, xj, C = (A) => {
              for (var j = "", t = A; D[t]; ) j += xj[D[t++]];
              return j;
            }, GA, v = (A) => {
              throw new GA(A);
            };
            function X6(A, j, t = {}) {
              var e = j.name;
              if (A || v(`type "${e}" must have a positive integer typeid pointer`), rA.hasOwnProperty(A)) {
                if (t.ignoreDuplicateRegistrations) return;
                v(`Cannot register type '${e}' twice`);
              }
              if (rA[A] = j, delete gA[A], BA.hasOwnProperty(A)) {
                var l = BA[A];
                delete BA[A], l.forEach((_) => _());
              }
            }
            function T(A, j, t = {}) {
              if (!("argPackAdvance" in j)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
              return X6(A, j, t);
            }
            var X = 8, R6 = (A, j, t, e) => {
              j = C(j), T(A, { name: j, fromWireType: function(l) {
                return !!l;
              }, toWireType: function(l, _) {
                return _ ? t : e;
              }, argPackAdvance: X, readValueFromPointer: function(l) {
                return this.fromWireType(D[l]);
              }, destructorFunction: null });
            }, V6 = (A) => ({ count: A.count, deleteScheduled: A.deleteScheduled, preservePointerOnDelete: A.preservePointerOnDelete, ptr: A.ptr, ptrType: A.ptrType, smartPtr: A.smartPtr, smartPtrType: A.smartPtrType }), Aj = (A) => {
              function j(t) {
                return t.$$.ptrType.registeredClass.name;
              }
              v(j(A) + " instance already deleted");
            }, jj = false, Lj = (A) => {
            }, U6 = (A) => {
              A.smartPtr ? A.smartPtrType.rawDestructor(A.smartPtr) : A.ptrType.registeredClass.rawDestructor(A.ptr);
            }, yj = (A) => {
              A.count.value -= 1;
              var j = A.count.value === 0;
              j && U6(A);
            }, Oj = (A, j, t) => {
              if (j === t) return A;
              if (t.baseClass === void 0) return null;
              var e = Oj(A, j, t.baseClass);
              return e === null ? null : t.downcast(e);
            }, Jj = {}, Y6 = () => Object.keys(uA).length, z6 = () => {
              var A = [];
              for (var j in uA) uA.hasOwnProperty(j) && A.push(uA[j]);
              return A;
            }, dA = [], tj = () => {
              for (; dA.length; ) {
                var A = dA.pop();
                A.$$.deleteScheduled = false, A.delete();
              }
            }, $A, W6 = (A) => {
              $A = A, dA.length && $A && $A(tj);
            }, Z6 = () => {
              r.getInheritedInstanceCount = Y6, r.getLiveInheritedInstances = z6, r.flushPendingDeletes = tj, r.setDelayFunction = W6;
            }, uA = {}, Q6 = (A, j) => {
              for (j === void 0 && v("ptr should not be undefined"); A.baseClass; ) j = A.upcast(j), A = A.baseClass;
              return j;
            }, At = (A, j) => (j = Q6(A, j), uA[j]), LA = (A, j) => {
              (!j.ptrType || !j.ptr) && xA("makeClassHandle requires ptr and ptrType");
              var t = !!j.smartPtrType, e = !!j.smartPtr;
              return t !== e && xA("Both smartPtrType and smartPtr must be specified"), j.count = { value: 1 }, pA(Object.create(A, { $$: { value: j, writable: true } }));
            };
            function jt(A) {
              var j = this.getPointee(A);
              if (!j) return this.destructor(A), null;
              var t = At(this.registeredClass, j);
              if (t !== void 0) {
                if (t.$$.count.value === 0) return t.$$.ptr = j, t.$$.smartPtr = A, t.clone();
                var e = t.clone();
                return this.destructor(A), e;
              }
              function l() {
                return this.isSmartPointer ? LA(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: j, smartPtrType: this, smartPtr: A }) : LA(this.registeredClass.instancePrototype, { ptrType: this, ptr: A });
              }
              var _ = this.registeredClass.getActualType(j), a = Jj[_];
              if (!a) return l.call(this);
              var o;
              this.isConst ? o = a.constPointerType : o = a.pointerType;
              var i = Oj(j, this.registeredClass, o.registeredClass);
              return i === null ? l.call(this) : this.isSmartPointer ? LA(o.registeredClass.instancePrototype, { ptrType: o, ptr: i, smartPtrType: this, smartPtr: A }) : LA(o.registeredClass.instancePrototype, { ptrType: o, ptr: i });
            }
            var pA = (A) => typeof FinalizationRegistry == "undefined" ? (pA = (j) => j, A) : (jj = new FinalizationRegistry((j) => {
              yj(j.$$);
            }), pA = (j) => {
              var t = j.$$, e = !!t.smartPtr;
              if (e) {
                var l = { $$: t };
                jj.register(j, l, j);
              }
              return j;
            }, Lj = (j) => jj.unregister(j), pA(A)), tt = () => {
              Object.assign(yA.prototype, { isAliasOf(A) {
                if (!(this instanceof yA) || !(A instanceof yA)) return false;
                var j = this.$$.ptrType.registeredClass, t = this.$$.ptr;
                A.$$ = A.$$;
                for (var e = A.$$.ptrType.registeredClass, l = A.$$.ptr; j.baseClass; ) t = j.upcast(t), j = j.baseClass;
                for (; e.baseClass; ) l = e.upcast(l), e = e.baseClass;
                return j === e && t === l;
              }, clone() {
                if (this.$$.ptr || Aj(this), this.$$.preservePointerOnDelete) return this.$$.count.value += 1, this;
                var A = pA(Object.create(Object.getPrototypeOf(this), { $$: { value: V6(this.$$) } }));
                return A.$$.count.value += 1, A.$$.deleteScheduled = false, A;
              }, delete() {
                this.$$.ptr || Aj(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && v("Object already scheduled for deletion"), Lj(this), yj(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0);
              }, isDeleted() {
                return !this.$$.ptr;
              }, deleteLater() {
                return this.$$.ptr || Aj(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && v("Object already scheduled for deletion"), dA.push(this), dA.length === 1 && $A && $A(tj), this.$$.deleteScheduled = true, this;
              } });
            };
            function yA() {
            }
            var HA = (A, j) => Object.defineProperty(j, "name", { value: A }), et = (A, j, t) => {
              if (A[j].overloadTable === void 0) {
                var e = A[j];
                A[j] = function(...l) {
                  return A[j].overloadTable.hasOwnProperty(l.length) || v(`Function '${t}' called with an invalid number of arguments (${l.length}) - expects one of (${A[j].overloadTable})!`), A[j].overloadTable[l.length].apply(this, l);
                }, A[j].overloadTable = [], A[j].overloadTable[e.argCount] = e;
              }
            }, ej = (A, j, t) => {
              r.hasOwnProperty(A) ? ((t === void 0 || r[A].overloadTable !== void 0 && r[A].overloadTable[t] !== void 0) && v(`Cannot register public name '${A}' twice`), et(r, A, A), r.hasOwnProperty(t) && v(`Cannot register multiple overloads of a function with the same number of arguments (${t})!`), r[A].overloadTable[t] = j) : (r[A] = j, t !== void 0 && (r[A].numArguments = t));
            }, rt = 48, kt = 57, lt = (A) => {
              if (A === void 0) return "_unknown";
              A = A.replace(/[^a-zA-Z0-9_]/g, "$");
              var j = A.charCodeAt(0);
              return j >= rt && j <= kt ? `_${A}` : A;
            };
            function Bt(A, j, t, e, l, _, a, o) {
              this.name = A, this.constructor = j, this.instancePrototype = t, this.rawDestructor = e, this.baseClass = l, this.getActualType = _, this.upcast = a, this.downcast = o, this.pureVirtualFunctions = [];
            }
            var rj = (A, j, t) => {
              for (; j !== t; ) j.upcast || v(`Expected null or instance of ${t.name}, got an instance of ${j.name}`), A = j.upcast(A), j = j.baseClass;
              return A;
            };
            function _t(A, j) {
              if (j === null) return this.isReference && v(`null is not a valid ${this.name}`), 0;
              j.$$ || v(`Cannot pass "${_j(j)}" as a ${this.name}`), j.$$.ptr || v(`Cannot pass deleted object as a pointer of type ${this.name}`);
              var t = j.$$.ptrType.registeredClass, e = rj(j.$$.ptr, t, this.registeredClass);
              return e;
            }
            function at(A, j) {
              var t;
              if (j === null) return this.isReference && v(`null is not a valid ${this.name}`), this.isSmartPointer ? (t = this.rawConstructor(), A !== null && A.push(this.rawDestructor, t), t) : 0;
              (!j || !j.$$) && v(`Cannot pass "${_j(j)}" as a ${this.name}`), j.$$.ptr || v(`Cannot pass deleted object as a pointer of type ${this.name}`), !this.isConst && j.$$.ptrType.isConst && v(`Cannot convert argument of type ${j.$$.smartPtrType ? j.$$.smartPtrType.name : j.$$.ptrType.name} to parameter type ${this.name}`);
              var e = j.$$.ptrType.registeredClass;
              if (t = rj(j.$$.ptr, e, this.registeredClass), this.isSmartPointer) switch (j.$$.smartPtr === void 0 && v("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy) {
                case 0:
                  j.$$.smartPtrType === this ? t = j.$$.smartPtr : v(`Cannot convert argument of type ${j.$$.smartPtrType ? j.$$.smartPtrType.name : j.$$.ptrType.name} to parameter type ${this.name}`);
                  break;
                case 1:
                  t = j.$$.smartPtr;
                  break;
                case 2:
                  if (j.$$.smartPtrType === this) t = j.$$.smartPtr;
                  else {
                    var l = j.clone();
                    t = this.rawShare(t, P.toHandle(() => l.delete())), A !== null && A.push(this.rawDestructor, t);
                  }
                  break;
                default:
                  v("Unsupporting sharing policy");
              }
              return t;
            }
            function ot(A, j) {
              if (j === null) return this.isReference && v(`null is not a valid ${this.name}`), 0;
              j.$$ || v(`Cannot pass "${_j(j)}" as a ${this.name}`), j.$$.ptr || v(`Cannot pass deleted object as a pointer of type ${this.name}`), j.$$.ptrType.isConst && v(`Cannot convert argument of type ${j.$$.ptrType.name} to parameter type ${this.name}`);
              var t = j.$$.ptrType.registeredClass, e = rj(j.$$.ptr, t, this.registeredClass);
              return e;
            }
            var it = () => {
              Object.assign(OA.prototype, { getPointee(A) {
                return this.rawGetPointee && (A = this.rawGetPointee(A)), A;
              }, destructor(A) {
                var j;
                (j = this.rawDestructor) == null || j.call(this, A);
              }, argPackAdvance: X, readValueFromPointer: sA, fromWireType: jt });
            };
            function OA(A, j, t, e, l, _, a, o, i, n, s) {
              this.name = A, this.registeredClass = j, this.isReference = t, this.isConst = e, this.isSmartPointer = l, this.pointeeType = _, this.sharingPolicy = a, this.rawGetPointee = o, this.rawConstructor = i, this.rawShare = n, this.rawDestructor = s, !l && j.baseClass === void 0 ? e ? (this.toWireType = _t, this.destructorFunction = null) : (this.toWireType = ot, this.destructorFunction = null) : this.toWireType = at;
            }
            var bj = (A, j, t) => {
              r.hasOwnProperty(A) || xA("Replacing nonexistent public symbol"), r[A].overloadTable !== void 0 && t !== void 0 ? r[A].overloadTable[t] = j : (r[A] = j, r[A].argCount = t);
            }, Et = (A, j, t) => {
              A = A.replace(/p/g, "i");
              var e = r["dynCall_" + A];
              return e(j, ...t);
            }, JA = [], Dj, wj = (A) => {
              var j = JA[A];
              return j || (A >= JA.length && (JA.length = A + 1), JA[A] = j = Dj.get(A)), j;
            }, nt = (A, j, t = []) => {
              if (A.includes("j")) return Et(A, j, t);
              var e = wj(j)(...t);
              return e;
            }, st = (A, j) => (...t) => nt(A, j, t), U = (A, j) => {
              A = C(A);
              function t() {
                return A.includes("j") ? st(A, j) : wj(j);
              }
              var e = t();
              return typeof e != "function" && v(`unknown function pointer with signature ${A}: ${j}`), e;
            }, Gt = (A, j) => {
              var t = HA(j, function(e) {
                this.name = j, this.message = e;
                var l = new Error(e).stack;
                l !== void 0 && (this.stack = this.toString() + `
` + l.replace(/^Error(:[^\n]*)?\n/, ""));
              });
              return t.prototype = Object.create(A.prototype), t.prototype.constructor = t, t.prototype.toString = function() {
                return this.message === void 0 ? this.name : `${this.name}: ${this.message}`;
              }, t;
            }, Cj, Sj = (A) => {
              var j = ve(A), t = C(j);
              return Z(j), t;
            }, Pj = (A, j) => {
              var t = [], e = {};
              function l(_) {
                if (!e[_] && !rA[_]) {
                  if (gA[_]) {
                    gA[_].forEach(l);
                    return;
                  }
                  t.push(_), e[_] = true;
                }
              }
              throw j.forEach(l), new Cj(`${A}: ` + t.map(Sj).join([", "]));
            }, dt = (A, j, t, e, l, _, a, o, i, n, s, u, d) => {
              s = C(s), _ = U(l, _), o && (o = U(a, o)), n && (n = U(i, n)), d = U(u, d);
              var G = lt(s);
              ej(G, function() {
                Pj(`Cannot construct ${s} due to unbound types`, [e]);
              }), QA([A, j, t], e ? [e] : [], (p) => {
                var g;
                p = p[0];
                var F, E;
                e ? (F = p.registeredClass, E = F.instancePrototype) : E = yA.prototype;
                var $ = HA(s, function(...ij) {
                  if (Object.getPrototypeOf(this) !== x) throw new GA("Use 'new' to construct " + s);
                  if (c.constructor_body === void 0) throw new GA(s + " has no accessible constructor");
                  var Wj = c.constructor_body[ij.length];
                  if (Wj === void 0) throw new GA(`Tried to invoke ctor of ${s} with invalid number of parameters (${ij.length}) - expected (${Object.keys(c.constructor_body).toString()}) parameters instead!`);
                  return Wj.apply(this, ij);
                }), x = Object.create(E, { constructor: { value: $ } });
                $.prototype = x;
                var c = new Bt(s, $, x, d, F, _, o, n);
                c.baseClass && ((g = c.baseClass).__derivedClasses != null || (g.__derivedClasses = []), c.baseClass.__derivedClasses.push(c));
                var S = new OA(s, c, true, false, false), L = new OA(s + "*", c, false, false, false), zj = new OA(s + " const*", c, false, true, false);
                return Jj[A] = { pointerType: L, constPointerType: zj }, bj(G, $), [S, L, zj];
              });
            }, kj = [], Y = [], lj = (A) => {
              A > 9 && --Y[A + 1] === 0 && (Y[A] = void 0, kj.push(A));
            }, $t = () => Y.length / 2 - 5 - kj.length, ut = () => {
              Y.push(0, 1, void 0, 1, null, 1, true, 1, false, 1), r.count_emval_handles = $t;
            }, P = { toValue: (A) => (A || v("Cannot use deleted val. handle = " + A), Y[A]), toHandle: (A) => {
              switch (A) {
                case void 0:
                  return 2;
                case null:
                  return 4;
                case true:
                  return 6;
                case false:
                  return 8;
                default: {
                  let j = kj.pop() || Y.length;
                  return Y[j] = A, Y[j + 1] = 1, j;
                }
              }
            } }, pt = { name: "emscripten::val", fromWireType: (A) => {
              var j = P.toValue(A);
              return lj(A), j;
            }, toWireType: (A, j) => P.toHandle(j), argPackAdvance: X, readValueFromPointer: sA, destructorFunction: null }, Ht = (A) => T(A, pt), ct = (A, j, t) => {
              switch (j) {
                case 1:
                  return t ? function(e) {
                    return this.fromWireType(J[e]);
                  } : function(e) {
                    return this.fromWireType(D[e]);
                  };
                case 2:
                  return t ? function(e) {
                    return this.fromWireType(R[e >> 1]);
                  } : function(e) {
                    return this.fromWireType(iA[e >> 1]);
                  };
                case 4:
                  return t ? function(e) {
                    return this.fromWireType(H[e >> 2]);
                  } : function(e) {
                    return this.fromWireType(m[e >> 2]);
                  };
                default:
                  throw new TypeError(`invalid integer width (${j}): ${A}`);
              }
            }, qt = (A, j, t, e) => {
              j = C(j);
              function l() {
              }
              l.values = {}, T(A, { name: j, constructor: l, fromWireType: function(_) {
                return this.constructor.values[_];
              }, toWireType: (_, a) => a.value, argPackAdvance: X, readValueFromPointer: ct(j, t, e), destructorFunction: null }), ej(j, l);
            }, Bj = (A, j) => {
              var t = rA[A];
              return t === void 0 && v(`${j} has unknown type ${Sj(A)}`), t;
            }, ht = (A, j, t) => {
              var e = Bj(A, "enum");
              j = C(j);
              var l = e.constructor, _ = Object.create(e.constructor.prototype, { value: { value: t }, constructor: { value: HA(`${e.name}_${j}`, function() {
              }) } });
              l.values[t] = _, l[j] = _;
            }, _j = (A) => {
              if (A === null) return "null";
              var j = typeof A;
              return j === "object" || j === "array" || j === "function" ? A.toString() : "" + A;
            }, mt = (A, j) => {
              switch (j) {
                case 4:
                  return function(t) {
                    return this.fromWireType(Hj[t >> 2]);
                  };
                case 8:
                  return function(t) {
                    return this.fromWireType(cj[t >> 3]);
                  };
                default:
                  throw new TypeError(`invalid float width (${j}): ${A}`);
              }
            }, Nt = (A, j, t) => {
              j = C(j), T(A, { name: j, fromWireType: (e) => e, toWireType: (e, l) => l, argPackAdvance: X, readValueFromPointer: mt(j, t), destructorFunction: null });
            };
            function ft(A) {
              for (var j = 1; j < A.length; ++j) if (A[j] !== null && A[j].destructorFunction === void 0) return true;
              return false;
            }
            function vt(A, j, t, e, l, _) {
              var a = j.length;
              a < 2 && v("argTypes array size mismatch! Must at least get return value and 'this' types!");
              j[1] !== null && t !== null;
              var i = ft(j), n = j[0].name !== "void", s = a - 2, u = new Array(s), d = [], G = [], p = function(...g) {
                g.length !== s && v(`function ${A} called with ${g.length} arguments, expected ${s}`), G.length = 0;
                var O;
                d.length = 1, d[0] = l;
                for (var F = 0; F < s; ++F) u[F] = j[F + 2].toWireType(G, g[F]), d.push(u[F]);
                var E = e(...d);
                function $(x) {
                  if (i) ZA(G);
                  else for (var c = 2; c < j.length; c++) {
                    var S = c === 1 ? O : u[c - 2];
                    j[c].destructorFunction !== null && j[c].destructorFunction(S);
                  }
                  if (n) return j[0].fromWireType(x);
                }
                return $(E);
              };
              return HA(A, p);
            }
            var Ft = (A, j) => {
              for (var t = [], e = 0; e < A; e++) t.push(m[j + e * 4 >> 2]);
              return t;
            }, It = (A) => {
              A = A.trim();
              let j = A.indexOf("(");
              return j !== -1 ? A.substr(0, j) : A;
            }, gt = (A, j, t, e, l, _, a) => {
              var o = Ft(j, t);
              A = C(A), A = It(A), l = U(e, l), ej(A, function() {
                Pj(`Cannot call ${A} due to unbound types`, o);
              }, j - 1), QA([], o, (i) => {
                var n = [i[0], null].concat(i.slice(1));
                return bj(A, vt(A, n, null, l, _), j - 1), [];
              });
            }, xt = (A, j, t) => {
              switch (j) {
                case 1:
                  return t ? (e) => J[e] : (e) => D[e];
                case 2:
                  return t ? (e) => R[e >> 1] : (e) => iA[e >> 1];
                case 4:
                  return t ? (e) => H[e >> 2] : (e) => m[e >> 2];
                default:
                  throw new TypeError(`invalid integer width (${j}): ${A}`);
              }
            }, Lt = (A, j, t, e, l) => {
              j = C(j);
              var _ = (s) => s;
              if (e === 0) {
                var a = 32 - 8 * t;
                _ = (s) => s << a >>> a;
              }
              var o = j.includes("unsigned"), i = (s, u) => {
              }, n;
              o ? n = function(s, u) {
                return i(u, this.name), u >>> 0;
              } : n = function(s, u) {
                return i(u, this.name), u;
              }, T(A, { name: j, fromWireType: _, toWireType: n, argPackAdvance: X, readValueFromPointer: xt(j, t, e !== 0), destructorFunction: null });
            }, yt = (A, j, t) => {
              var e = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], l = e[j];
              function _(a) {
                var o = m[a >> 2], i = m[a + 4 >> 2];
                return new l(J.buffer, i, o);
              }
              t = C(t), T(A, { name: t, fromWireType: _, argPackAdvance: X, readValueFromPointer: _ }, { ignoreDuplicateRegistrations: true });
            }, Ot = (A, j, t) => zA(A, D, j, t), Jt = (A, j) => {
              j = C(j);
              var t = j === "std::string";
              T(A, { name: j, fromWireType(e) {
                var l = m[e >> 2], _ = e + 4, a;
                if (t) for (var o = _, i = 0; i <= l; ++i) {
                  var n = _ + i;
                  if (i == l || D[n] == 0) {
                    var s = n - o, u = eA(o, s);
                    a === void 0 ? a = u : (a += "\0", a += u), o = n + 1;
                  }
                }
                else {
                  for (var d = new Array(l), i = 0; i < l; ++i) d[i] = String.fromCharCode(D[_ + i]);
                  a = d.join("");
                }
                return Z(e), a;
              }, toWireType(e, l) {
                l instanceof ArrayBuffer && (l = new Uint8Array(l));
                var _, a = typeof l == "string";
                a || l instanceof Uint8Array || l instanceof Uint8ClampedArray || l instanceof Int8Array || v("Cannot pass non-string to std::string"), t && a ? _ = YA(l) : _ = l.length;
                var o = Rj(4 + _ + 1), i = o + 4;
                if (m[o >> 2] = _, t && a) Ot(l, i, _ + 1);
                else if (a) for (var n = 0; n < _; ++n) {
                  var s = l.charCodeAt(n);
                  s > 255 && (Z(i), v("String has UTF-16 code units that do not fit in 8 bits")), D[i + n] = s;
                }
                else for (var n = 0; n < _; ++n) D[i + n] = l[n];
                return e !== null && e.push(Z, o), o;
              }, argPackAdvance: X, readValueFromPointer: sA, destructorFunction(e) {
                Z(e);
              } });
            }, Mj = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0, bt = (A, j) => {
              for (var t = A, e = t >> 1, l = e + j / 2; !(e >= l) && iA[e]; ) ++e;
              if (t = e << 1, t - A > 32 && Mj) return Mj.decode(D.subarray(A, t));
              for (var _ = "", a = 0; !(a >= j / 2); ++a) {
                var o = R[A + a * 2 >> 1];
                if (o == 0) break;
                _ += String.fromCharCode(o);
              }
              return _;
            }, Dt = (A, j, t) => {
              if (t != null || (t = 2147483647), t < 2) return 0;
              t -= 2;
              for (var e = j, l = t < A.length * 2 ? t / 2 : A.length, _ = 0; _ < l; ++_) {
                var a = A.charCodeAt(_);
                R[j >> 1] = a, j += 2;
              }
              return R[j >> 1] = 0, j - e;
            }, wt = (A) => A.length * 2, Ct = (A, j) => {
              for (var t = 0, e = ""; !(t >= j / 4); ) {
                var l = H[A + t * 4 >> 2];
                if (l == 0) break;
                if (++t, l >= 65536) {
                  var _ = l - 65536;
                  e += String.fromCharCode(55296 | _ >> 10, 56320 | _ & 1023);
                } else e += String.fromCharCode(l);
              }
              return e;
            }, St = (A, j, t) => {
              if (t != null || (t = 2147483647), t < 4) return 0;
              for (var e = j, l = e + t - 4, _ = 0; _ < A.length; ++_) {
                var a = A.charCodeAt(_);
                if (a >= 55296 && a <= 57343) {
                  var o = A.charCodeAt(++_);
                  a = 65536 + ((a & 1023) << 10) | o & 1023;
                }
                if (H[j >> 2] = a, j += 4, j + 4 > l) break;
              }
              return H[j >> 2] = 0, j - e;
            }, Pt = (A) => {
              for (var j = 0, t = 0; t < A.length; ++t) {
                var e = A.charCodeAt(t);
                e >= 55296 && e <= 57343 && ++t, j += 4;
              }
              return j;
            }, Mt = (A, j, t) => {
              t = C(t);
              var e, l, _, a;
              j === 2 ? (e = bt, l = Dt, a = wt, _ = (o) => iA[o >> 1]) : j === 4 && (e = Ct, l = St, a = Pt, _ = (o) => m[o >> 2]), T(A, { name: t, fromWireType: (o) => {
                for (var i = m[o >> 2], n, s = o + 4, u = 0; u <= i; ++u) {
                  var d = o + 4 + u * j;
                  if (u == i || _(d) == 0) {
                    var G = d - s, p = e(s, G);
                    n === void 0 ? n = p : (n += "\0", n += p), s = d + j;
                  }
                }
                return Z(o), n;
              }, toWireType: (o, i) => {
                typeof i != "string" && v(`Cannot pass non-string to C++ string type ${t}`);
                var n = a(i), s = Rj(4 + n + j);
                return m[s >> 2] = n / j, l(i, s + 4, n + j), o !== null && o.push(Z, s), s;
              }, argPackAdvance: X, readValueFromPointer: sA, destructorFunction(o) {
                Z(o);
              } });
            }, Kt = (A, j, t, e, l, _) => {
              IA[A] = { name: C(j), rawConstructor: U(t, e), rawDestructor: U(l, _), fields: [] };
            }, Tt = (A, j, t, e, l, _, a, o, i, n) => {
              IA[A].fields.push({ fieldName: C(j), getterReturnType: t, getter: U(e, l), getterContext: _, setterArgumentType: a, setter: U(o, i), setterContext: n });
            }, Xt = (A, j) => {
              j = C(j), T(A, { isVoid: true, name: j, argPackAdvance: 0, fromWireType: () => {
              }, toWireType: (t, e) => {
              } });
            }, Rt = (A, j, t) => D.copyWithin(A, j, j + t), Vt = {}, Kj = (A) => {
              var j = Vt[A];
              return j === void 0 ? C(A) : j;
            }, aj = [], Ut = (A, j, t, e, l) => (A = aj[A], j = P.toValue(j), t = Kj(t), A(j, j[t], e, l)), Yt = (A) => {
              var j = aj.length;
              return aj.push(A), j;
            }, zt = (A, j) => {
              for (var t = new Array(A), e = 0; e < A; ++e) t[e] = Bj(m[j + e * 4 >> 2], "parameter " + e);
              return t;
            }, Wt = Reflect.construct, Zt = (A, j, t) => {
              var e = [], l = A.toWireType(e, t);
              return e.length && (m[j >> 2] = P.toHandle(e)), l;
            }, Qt = (A, j, t) => {
              var e = zt(A, j), l = e.shift();
              A--;
              var _ = new Array(A), a = (i, n, s, u) => {
                for (var d = 0, G = 0; G < A; ++G) _[G] = e[G].readValueFromPointer(u + d), d += e[G].argPackAdvance;
                var p = t === 1 ? Wt(n, _) : n.apply(i, _);
                return Zt(l, s, p);
              }, o = `methodCaller<(${e.map((i) => i.name).join(", ")}) => ${l.name}>`;
              return Yt(HA(o, a));
            }, Ae = (A) => {
              A > 9 && (Y[A + 1] += 1);
            }, je = () => P.toHandle([]), te = (A) => P.toHandle(Kj(A)), ee = () => P.toHandle({}), re = (A) => {
              var j = P.toValue(A);
              ZA(j), lj(A);
            }, ke = (A, j, t) => {
              A = P.toValue(A), j = P.toValue(j), t = P.toValue(t), A[j] = t;
            }, le = (A, j) => {
              A = Bj(A, "_emval_take_value");
              var t = A.readValueFromPointer(j);
              return P.toHandle(t);
            }, Be = () => 2147483648, _e = (A) => {
              var j = mA.buffer, t = (A - j.byteLength + 65535) / 65536;
              try {
                return mA.grow(t), qj(), 1;
              } catch {
              }
            }, ae = (A) => {
              var j = D.length;
              A >>>= 0;
              var t = Be();
              if (A > t) return false;
              for (var e = (i, n) => i + (n - i % n) % n, l = 1; l <= 4; l *= 2) {
                var _ = j * (1 + 0.2 / l);
                _ = Math.min(_, A + 100663296);
                var a = Math.min(t, e(Math.max(A, _), 65536)), o = _e(a);
                if (o) return true;
              }
              return false;
            }, oj = {}, oe = () => CA || "./this.program", cA = () => {
              if (!cA.strings) {
                var A = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", j = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: A, _: oe() };
                for (var t in oj) oj[t] === void 0 ? delete j[t] : j[t] = oj[t];
                var e = [];
                for (var t in j) e.push(`${t}=${j[t]}`);
                cA.strings = e;
              }
              return cA.strings;
            }, ie = (A, j) => {
              for (var t = 0; t < A.length; ++t) J[j++] = A.charCodeAt(t);
              J[j] = 0;
            }, Ee = (A, j) => {
              var t = 0;
              return cA().forEach((e, l) => {
                var _ = j + t;
                m[A + l * 4 >> 2] = _, ie(e, _), t += e.length + 1;
              }), 0;
            }, ne = (A, j) => {
              var t = cA();
              m[A >> 2] = t.length;
              var e = 0;
              return t.forEach((l) => e += l.length + 1), m[j >> 2] = e, 0;
            };
            function se(A) {
              try {
                var j = w.getStreamFromFD(A);
                return k.close(j), 0;
              } catch (t) {
                if (typeof k == "undefined" || t.name !== "ErrnoError") throw t;
                return t.errno;
              }
            }
            var Ge = (A, j, t, e) => {
              for (var l = 0, _ = 0; _ < t; _++) {
                var a = m[j >> 2], o = m[j + 4 >> 2];
                j += 8;
                var i = k.read(A, J, a, o, e);
                if (i < 0) return -1;
                if (l += i, i < o) break;
              }
              return l;
            };
            function de(A, j, t, e) {
              try {
                var l = w.getStreamFromFD(A), _ = Ge(l, j, t);
                return m[e >> 2] = _, 0;
              } catch (a) {
                if (typeof k == "undefined" || a.name !== "ErrnoError") throw a;
                return a.errno;
              }
            }
            var $e = (A, j) => j + 2097152 >>> 0 < 4194305 - !!A ? (A >>> 0) + j * 4294967296 : NaN;
            function ue(A, j, t, e, l) {
              var _ = $e(j, t);
              try {
                if (isNaN(_)) return 61;
                var a = w.getStreamFromFD(A);
                return k.llseek(a, _, e), b = [a.position >>> 0, (h = a.position, +Math.abs(h) >= 1 ? h > 0 ? +Math.floor(h / 4294967296) >>> 0 : ~~+Math.ceil((h - +(~~h >>> 0)) / 4294967296) >>> 0 : 0)], H[l >> 2] = b[0], H[l + 4 >> 2] = b[1], a.getdents && _ === 0 && e === 0 && (a.getdents = null), 0;
              } catch (o) {
                if (typeof k == "undefined" || o.name !== "ErrnoError") throw o;
                return o.errno;
              }
            }
            var pe = (A, j, t, e) => {
              for (var l = 0, _ = 0; _ < t; _++) {
                var a = m[j >> 2], o = m[j + 4 >> 2];
                j += 8;
                var i = k.write(A, J, a, o, e);
                if (i < 0) return -1;
                l += i;
              }
              return l;
            };
            function He(A, j, t, e) {
              try {
                var l = w.getStreamFromFD(A), _ = pe(l, j, t);
                return m[e >> 2] = _, 0;
              } catch (a) {
                if (typeof k == "undefined" || a.name !== "ErrnoError") throw a;
                return a.errno;
              }
            }
            var bA = (A) => A % 4 === 0 && (A % 100 !== 0 || A % 400 === 0), ce = (A, j) => {
              for (var t = 0, e = 0; e <= j; t += A[e++]) ;
              return t;
            }, Tj = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Xj = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], qe = (A, j) => {
              for (var t = new Date(A.getTime()); j > 0; ) {
                var e = bA(t.getFullYear()), l = t.getMonth(), _ = (e ? Tj : Xj)[l];
                if (j > _ - t.getDate()) j -= _ - t.getDate() + 1, t.setDate(1), l < 11 ? t.setMonth(l + 1) : (t.setMonth(0), t.setFullYear(t.getFullYear() + 1));
                else return t.setDate(t.getDate() + j), t;
              }
              return t;
            }, he = (A, j) => {
              J.set(A, j);
            }, me = (A, j, t, e) => {
              var l = m[e + 40 >> 2], _ = { tm_sec: H[e >> 2], tm_min: H[e + 4 >> 2], tm_hour: H[e + 8 >> 2], tm_mday: H[e + 12 >> 2], tm_mon: H[e + 16 >> 2], tm_year: H[e + 20 >> 2], tm_wday: H[e + 24 >> 2], tm_yday: H[e + 28 >> 2], tm_isdst: H[e + 32 >> 2], tm_gmtoff: H[e + 36 >> 2], tm_zone: l ? eA(l) : "" }, a = eA(t), o = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
              for (var i in o) a = a.replace(new RegExp(i, "g"), o[i]);
              var n = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], s = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
              function u(E, $, x) {
                for (var c = typeof E == "number" ? E.toString() : E || ""; c.length < $; ) c = x[0] + c;
                return c;
              }
              function d(E, $) {
                return u(E, $, "0");
              }
              function G(E, $) {
                function x(S) {
                  return S < 0 ? -1 : S > 0 ? 1 : 0;
                }
                var c;
                return (c = x(E.getFullYear() - $.getFullYear())) === 0 && (c = x(E.getMonth() - $.getMonth())) === 0 && (c = x(E.getDate() - $.getDate())), c;
              }
              function p(E) {
                switch (E.getDay()) {
                  case 0:
                    return new Date(E.getFullYear() - 1, 11, 29);
                  case 1:
                    return E;
                  case 2:
                    return new Date(E.getFullYear(), 0, 3);
                  case 3:
                    return new Date(E.getFullYear(), 0, 2);
                  case 4:
                    return new Date(E.getFullYear(), 0, 1);
                  case 5:
                    return new Date(E.getFullYear() - 1, 11, 31);
                  case 6:
                    return new Date(E.getFullYear() - 1, 11, 30);
                }
              }
              function g(E) {
                var $ = qe(new Date(E.tm_year + 1900, 0, 1), E.tm_yday), x = new Date($.getFullYear(), 0, 4), c = new Date($.getFullYear() + 1, 0, 4), S = p(x), L = p(c);
                return G(S, $) <= 0 ? G(L, $) <= 0 ? $.getFullYear() + 1 : $.getFullYear() : $.getFullYear() - 1;
              }
              var O = { "%a": (E) => n[E.tm_wday].substring(0, 3), "%A": (E) => n[E.tm_wday], "%b": (E) => s[E.tm_mon].substring(0, 3), "%B": (E) => s[E.tm_mon], "%C": (E) => {
                var $ = E.tm_year + 1900;
                return d($ / 100 | 0, 2);
              }, "%d": (E) => d(E.tm_mday, 2), "%e": (E) => u(E.tm_mday, 2, " "), "%g": (E) => g(E).toString().substring(2), "%G": g, "%H": (E) => d(E.tm_hour, 2), "%I": (E) => {
                var $ = E.tm_hour;
                return $ == 0 ? $ = 12 : $ > 12 && ($ -= 12), d($, 2);
              }, "%j": (E) => d(E.tm_mday + ce(bA(E.tm_year + 1900) ? Tj : Xj, E.tm_mon - 1), 3), "%m": (E) => d(E.tm_mon + 1, 2), "%M": (E) => d(E.tm_min, 2), "%n": () => `
`, "%p": (E) => E.tm_hour >= 0 && E.tm_hour < 12 ? "AM" : "PM", "%S": (E) => d(E.tm_sec, 2), "%t": () => "	", "%u": (E) => E.tm_wday || 7, "%U": (E) => {
                var $ = E.tm_yday + 7 - E.tm_wday;
                return d(Math.floor($ / 7), 2);
              }, "%V": (E) => {
                var $ = Math.floor((E.tm_yday + 7 - (E.tm_wday + 6) % 7) / 7);
                if ((E.tm_wday + 371 - E.tm_yday - 2) % 7 <= 2 && $++, $) {
                  if ($ == 53) {
                    var x = (E.tm_wday + 371 - E.tm_yday) % 7;
                    x != 4 && (x != 3 || !bA(E.tm_year)) && ($ = 1);
                  }
                } else {
                  $ = 52;
                  var c = (E.tm_wday + 7 - E.tm_yday - 1) % 7;
                  (c == 4 || c == 5 && bA(E.tm_year % 400 - 1)) && $++;
                }
                return d($, 2);
              }, "%w": (E) => E.tm_wday, "%W": (E) => {
                var $ = E.tm_yday + 7 - (E.tm_wday + 6) % 7;
                return d(Math.floor($ / 7), 2);
              }, "%y": (E) => (E.tm_year + 1900).toString().substring(2), "%Y": (E) => E.tm_year + 1900, "%z": (E) => {
                var $ = E.tm_gmtoff, x = $ >= 0;
                return $ = Math.abs($) / 60, $ = $ / 60 * 100 + $ % 60, (x ? "+" : "-") + ("0000" + $).slice(-4);
              }, "%Z": (E) => E.tm_zone, "%%": () => "%" };
              a = a.replace(/%%/g, "\0\0");
              for (var i in O) a.includes(i) && (a = a.replace(new RegExp(i, "g"), O[i](_)));
              a = a.replace(/\0\0/g, "%");
              var F = FA(a, false);
              return F.length > j ? 0 : (he(F, A), F.length - 1);
            }, Ne = (A, j, t, e, l) => me(A, j, t, e);
            k.createPreloadedFile = J6, k.staticInit(), gj = r.InternalError = class extends Error {
              constructor(A) {
                super(A), this.name = "InternalError";
              }
            }, T6(), GA = r.BindingError = class extends Error {
              constructor(A) {
                super(A), this.name = "BindingError";
              }
            }, tt(), Z6(), it(), Cj = r.UnboundTypeError = Gt(Error, "UnboundTypeError"), ut();
            var fe = { b: N6, p: F6, r: D6, B: w6, F: C6, E: S6, C: P6, w: M6, z: K6, K: R6, m: dt, J: Ht, j: qt, a: ht, v: Nt, f: gt, i: Lt, e: yt, u: Jt, o: Mt, x: Kt, l: Tt, L: Xt, I: Rt, N: Ut, c: lj, O: Qt, P: Ae, q: je, h: te, k: ee, M: re, g: ke, d: le, D: ae, G: Ee, H: ne, s: se, t: de, y: ue, n: He, A: Ne }, B = m6();
            B.R;
            r._memcpy = B.S;
            r._heif_color_conversion_options_set_defaults = B.U;
            var Rj = r._malloc = B.V;
            r._heif_nclx_color_profile_set_color_primaries = B.W;
            var Z = r._free = B.X;
            r._heif_nclx_color_profile_set_transfer_characteristics = B.Y;
            r._heif_nclx_color_profile_set_matrix_coefficients = B.Z;
            r._heif_init = B._;
            r._heif_deinit = B.$;
            r._heif_load_plugin = B.aa;
            r._heif_unload_plugin = B.ba;
            r._heif_load_plugins = B.ca;
            r._heif_get_plugin_directories = B.da;
            r._heif_free_plugin_directories = B.ea;
            r._heif_get_version = B.fa;
            r._heif_get_version_number = B.ga;
            r._heif_get_version_number_major = B.ha;
            r._heif_get_version_number_minor = B.ia;
            r._heif_get_version_number_maintenance = B.ja;
            r._heif_check_filetype = B.ka;
            r._heif_read_main_brand = B.la;
            r._heif_has_compatible_filetype = B.ma;
            r._heif_list_compatible_brands = B.na;
            r._heif_free_list_of_compatible_brands = B.oa;
            r._heif_check_jpeg_filetype = B.pa;
            r._heif_main_brand = B.qa;
            r._heif_fourcc_to_brand = B.ra;
            r._heif_read_minor_version_brand = B.sa;
            r._heif_brand_to_fourcc = B.ta;
            r._heif_has_compatible_brand = B.ua;
            r._heif_get_global_security_limits = B.va;
            r._heif_get_file_mime_type = B.wa;
            r._heif_get_disabled_security_limits = B.xa;
            r._heif_context_get_security_limits = B.ya;
            r._heif_context_set_security_limits = B.za;
            r._heif_context_alloc = B.Aa;
            r._heif_context_free = B.Ba;
            r._heif_context_read_from_file = B.Ca;
            r._heif_context_read_from_memory = B.Da;
            r._heif_context_read_from_memory_without_copy = B.Ea;
            r._heif_context_read_from_reader = B.Fa;
            r._heif_context_debug_dump_boxes_to_file = B.Ga;
            r._heif_context_get_primary_image_handle = B.Ha;
            r._heif_context_get_primary_image_ID = B.Ia;
            r._heif_context_is_top_level_image_ID = B.Ja;
            r._heif_context_get_number_of_top_level_images = B.Ka;
            r._heif_context_get_list_of_top_level_image_IDs = B.La;
            r._heif_context_get_image_handle = B.Ma;
            r._heif_image_handle_is_primary_image = B.Na;
            r._heif_image_handle_get_item_id = B.Oa;
            r._heif_image_handle_get_number_of_thumbnails = B.Pa;
            r._heif_image_handle_get_list_of_thumbnail_IDs = B.Qa;
            r._heif_image_handle_get_thumbnail = B.Ra;
            r._heif_image_handle_get_number_of_auxiliary_images = B.Sa;
            r._heif_image_handle_get_list_of_auxiliary_image_IDs = B.Ta;
            r._heif_image_handle_get_auxiliary_type = B.Ua;
            r._heif_image_handle_release_auxiliary_type = B.Va;
            r._heif_image_handle_free_auxiliary_types = B.Wa;
            r._heif_image_handle_get_auxiliary_image_handle = B.Xa;
            r._heif_image_handle_get_width = B.Ya;
            r._heif_image_handle_get_height = B.Za;
            r._heif_image_handle_get_ispe_width = B._a;
            r._heif_image_handle_get_ispe_height = B.$a;
            r._heif_image_handle_get_context = B.ab;
            r._heif_image_handle_get_image_tiling = B.bb;
            r._heif_image_handle_get_grid_image_tile_id = B.cb;
            r._heif_context_get_entity_groups = B.db;
            r._heif_entity_groups_release = B.eb;
            r._heif_image_handle_get_preferred_decoding_colorspace = B.fb;
            r._heif_image_handle_has_alpha_channel = B.gb;
            r._heif_image_handle_is_premultiplied_alpha = B.hb;
            r._heif_image_handle_get_luma_bits_per_pixel = B.ib;
            r._heif_image_handle_get_chroma_bits_per_pixel = B.jb;
            r._heif_image_handle_has_depth_image = B.kb;
            r._heif_depth_representation_info_free = B.lb;
            r._heif_image_handle_get_depth_image_representation_info = B.mb;
            r._heif_image_handle_get_number_of_depth_images = B.nb;
            r._heif_image_handle_get_list_of_depth_image_IDs = B.ob;
            r._heif_image_handle_get_depth_image_handle = B.pb;
            r._heif_decoding_options_alloc = B.qb;
            r._heif_decoding_options_free = B.rb;
            r._heif_decode_image = B.sb;
            r._heif_image_handle_decode_image_tile = B.tb;
            r._heif_image_create = B.ub;
            r._heif_image_get_decoding_warnings = B.vb;
            r._heif_image_add_decoding_warning = B.wb;
            r._heif_image_has_content_light_level = B.xb;
            r._heif_image_get_content_light_level = B.yb;
            r._heif_image_handle_get_content_light_level = B.zb;
            r._heif_image_set_content_light_level = B.Ab;
            r._heif_image_has_mastering_display_colour_volume = B.Bb;
            r._heif_image_get_mastering_display_colour_volume = B.Cb;
            r._heif_image_handle_get_mastering_display_colour_volume = B.Db;
            r._heif_image_set_mastering_display_colour_volume = B.Eb;
            r._heif_mastering_display_colour_volume_decode = B.Fb;
            r._heif_image_get_pixel_aspect_ratio = B.Gb;
            r._heif_image_handle_get_pixel_aspect_ratio = B.Hb;
            r._heif_image_set_pixel_aspect_ratio = B.Ib;
            r._heif_image_release = B.Jb;
            r._heif_image_handle_release = B.Kb;
            r._heif_image_get_colorspace = B.Lb;
            r._heif_image_get_chroma_format = B.Mb;
            r._heif_image_get_width = B.Nb;
            r._heif_image_get_height = B.Ob;
            r._heif_image_get_primary_width = B.Pb;
            r._heif_image_get_primary_height = B.Qb;
            r._heif_image_crop = B.Rb;
            r._heif_image_get_bits_per_pixel = B.Sb;
            r._heif_image_get_bits_per_pixel_range = B.Tb;
            r._heif_image_has_channel = B.Ub;
            r._heif_image_add_plane = B.Vb;
            r._heif_image_get_plane_readonly = B.Wb;
            r._heif_image_get_plane = B.Xb;
            r._heif_image_set_premultiplied_alpha = B.Yb;
            r._heif_image_is_premultiplied_alpha = B.Zb;
            r._heif_image_extend_padding_to_size = B._b;
            r._heif_image_scale_image = B.$b;
            r._heif_image_extend_to_size_fill_with_zero = B.ac;
            r._heif_image_set_raw_color_profile = B.bc;
            r._heif_image_set_nclx_color_profile = B.cc;
            r._heif_image_handle_get_number_of_metadata_blocks = B.dc;
            r._heif_image_handle_get_list_of_metadata_block_IDs = B.ec;
            r._heif_image_handle_get_metadata_type = B.fc;
            r._heif_image_handle_get_metadata_content_type = B.gc;
            r._heif_image_handle_get_metadata_item_uri_type = B.hc;
            r._heif_image_handle_get_metadata_size = B.ic;
            r._heif_image_handle_get_metadata = B.jc;
            r._heif_image_handle_get_color_profile_type = B.kc;
            r._heif_image_handle_get_raw_color_profile_size = B.lc;
            r._heif_image_handle_get_nclx_color_profile = B.mc;
            r._heif_image_handle_get_raw_color_profile = B.nc;
            r._heif_image_get_color_profile_type = B.oc;
            r._heif_image_get_raw_color_profile_size = B.pc;
            r._heif_image_get_raw_color_profile = B.qc;
            r._heif_image_get_nclx_color_profile = B.rc;
            r._heif_nclx_color_profile_alloc = B.sc;
            r._heif_nclx_color_profile_free = B.tc;
            r._heif_image_handle_has_camera_intrinsic_matrix = B.uc;
            r._heif_image_handle_get_camera_intrinsic_matrix = B.vc;
            r._heif_image_handle_has_camera_extrinsic_matrix = B.wc;
            r._heif_image_handle_get_camera_extrinsic_matrix = B.xc;
            r._heif_camera_extrinsic_matrix_release = B.yc;
            r._heif_camera_extrinsic_matrix_get_rotation_matrix = B.zc;
            r._heif_register_decoder = B.Ac;
            r._heif_register_decoder_plugin = B.Bc;
            r._heif_register_encoder_plugin = B.Cc;
            r._heif_context_write_to_file = B.Dc;
            r._heif_context_write = B.Ec;
            r._heif_context_add_compatible_brand = B.Fc;
            r._heif_context_get_encoder_descriptors = B.Gc;
            r._heif_get_encoder_descriptors = B.Hc;
            r._heif_encoder_descriptor_get_name = B.Ic;
            r._heif_encoder_descriptor_get_id_name = B.Jc;
            r._heif_get_decoder_descriptors = B.Kc;
            r._heif_decoder_descriptor_get_name = B.Lc;
            r._heif_decoder_descriptor_get_id_name = B.Mc;
            r._heif_encoder_descriptor_get_compression_format = B.Nc;
            r._heif_encoder_descriptor_supports_lossy_compression = B.Oc;
            r._heif_encoder_descriptor_supports_lossless_compression = B.Pc;
            r._heif_encoder_descriptor_supportes_lossy_compression = B.Qc;
            r._heif_encoder_descriptor_supportes_lossless_compression = B.Rc;
            r._heif_encoder_get_name = B.Sc;
            r._heif_context_get_encoder = B.Tc;
            r._heif_have_decoder_for_format = B.Uc;
            r._heif_have_encoder_for_format = B.Vc;
            r._heif_context_get_encoder_for_format = B.Wc;
            r._heif_encoder_release = B.Xc;
            r._heif_encoder_set_lossy_quality = B.Yc;
            r._heif_encoder_set_lossless = B.Zc;
            r._heif_encoder_set_logging_level = B._c;
            r._heif_encoder_list_parameters = B.$c;
            r._heif_encoder_parameter_get_name = B.ad;
            r._heif_encoder_parameter_get_type = B.bd;
            r._heif_encoder_set_parameter_integer = B.cd;
            r._heif_encoder_parameter_get_valid_integer_values = B.dd;
            r._heif_encoder_get_parameter_integer = B.ed;
            r._heif_encoder_parameter_get_valid_integer_range = B.fd;
            r._heif_encoder_parameter_get_valid_string_values = B.gd;
            r._heif_encoder_parameter_integer_valid_range = B.hd;
            r._heif_encoder_set_parameter_boolean = B.id;
            r._heif_encoder_get_parameter_boolean = B.jd;
            r._heif_encoder_set_parameter_string = B.kd;
            r._heif_encoder_get_parameter_string = B.ld;
            r._heif_encoder_parameter_string_valid_values = B.md;
            r._heif_encoder_parameter_integer_valid_values = B.nd;
            r._heif_encoder_set_parameter = B.od;
            r._heif_encoder_get_parameter = B.pd;
            r._heif_encoder_has_default = B.qd;
            r._heif_encoding_options_alloc = B.rd;
            r._heif_encoding_options_free = B.sd;
            r._heif_context_encode_image = B.td;
            r._heif_context_encode_grid = B.ud;
            r._heif_context_add_grid_image = B.vd;
            r._heif_context_add_overlay_image = B.wd;
            r._heif_context_add_image_tile = B.xd;
            r._heif_context_assign_thumbnail = B.yd;
            r._heif_context_encode_thumbnail = B.zd;
            r._heif_context_set_primary_image = B.Ad;
            r._heif_context_add_exif_metadata = B.Bd;
            r._heif_context_add_XMP_metadata = B.Cd;
            r._heif_context_add_XMP_metadata2 = B.Dd;
            r._heif_context_add_generic_metadata = B.Ed;
            r._heif_context_add_generic_uri_metadata = B.Fd;
            r._heif_context_set_maximum_image_size_limit = B.Gd;
            r._heif_context_set_max_decoding_threads = B.Hd;
            r._heif_image_handle_get_number_of_region_items = B.Id;
            r._heif_image_handle_get_list_of_region_item_ids = B.Jd;
            r._heif_context_get_region_item = B.Kd;
            r._heif_region_item_get_id = B.Ld;
            r._heif_region_item_release = B.Md;
            r._heif_region_item_get_reference_size = B.Nd;
            r._heif_region_item_get_number_of_regions = B.Od;
            r._heif_region_item_get_list_of_regions = B.Pd;
            r._heif_image_handle_add_region_item = B.Qd;
            r._heif_region_item_add_region_point = B.Rd;
            r._heif_region_item_add_region_rectangle = B.Sd;
            r._heif_region_item_add_region_ellipse = B.Td;
            r._heif_region_item_add_region_polygon = B.Ud;
            r._heif_region_item_add_region_polyline = B.Vd;
            r._heif_region_item_add_region_referenced_mask = B.Wd;
            r._heif_region_item_add_region_inline_mask_data = B.Xd;
            r._heif_region_item_add_region_inline_mask = B.Yd;
            r._heif_region_release = B.Zd;
            r._heif_region_release_many = B._d;
            r._heif_region_get_type = B.$d;
            r._heif_region_get_point = B.ae;
            r._heif_region_get_point_transformed = B.be;
            r._heif_region_get_rectangle = B.ce;
            r._heif_region_get_rectangle_transformed = B.de;
            r._heif_region_get_ellipse = B.ee;
            r._heif_region_get_ellipse_transformed = B.fe;
            r._heif_region_get_polygon_num_points = B.ge;
            r._heif_region_get_polyline_num_points = B.he;
            r._heif_region_get_polygon_points = B.ie;
            r._heif_region_get_polyline_points = B.je;
            r._heif_region_get_polygon_points_transformed = B.ke;
            r._heif_region_get_polyline_points_transformed = B.le;
            r._heif_region_get_referenced_mask_ID = B.me;
            r._heif_region_get_inline_mask_data_len = B.ne;
            r._heif_region_get_inline_mask_data = B.oe;
            r._heif_region_get_mask_image = B.pe;
            r._heif_item_get_properties_of_type = B.qe;
            r._heif_item_get_transformation_properties = B.re;
            r._heif_item_get_property_type = B.se;
            r._heif_item_get_property_user_description = B.te;
            r._heif_item_add_property_user_description = B.ue;
            r._heif_item_get_property_transform_mirror = B.ve;
            r._heif_item_get_property_transform_rotation_ccw = B.we;
            r._heif_item_get_property_transform_crop_borders = B.xe;
            r._heif_property_user_description_release = B.ye;
            r._heif_item_add_raw_property = B.ze;
            r._heif_item_get_property_raw_size = B.Ae;
            r._heif_item_get_property_raw_data = B.Be;
            r._heif_item_get_property_uuid_type = B.Ce;
            r._heif_context_get_number_of_items = B.De;
            r._heif_context_get_list_of_item_IDs = B.Ee;
            r._heif_item_get_item_type = B.Fe;
            r._heif_item_is_item_hidden = B.Ge;
            r._heif_item_get_mime_item_content_type = B.He;
            r._heif_item_get_mime_item_content_encoding = B.Ie;
            r._heif_item_get_uri_item_uri_type = B.Je;
            r._heif_item_get_item_name = B.Ke;
            r._heif_item_get_item_data = B.Le;
            r._heif_release_item_data = B.Me;
            r._heif_context_get_item_references = B.Ne;
            r._heif_release_item_references = B.Oe;
            r._heif_context_add_item = B.Pe;
            r._heif_context_add_mime_item = B.Qe;
            r._heif_context_add_precompressed_mime_item = B.Re;
            r._heif_context_add_uri_item = B.Se;
            r._heif_context_add_item_reference = B.Te;
            r._heif_context_add_item_references = B.Ue;
            r._heif_item_set_item_name = B.Ve;
            r._de265_get_version = B.We;
            r._de265_init = B.Xe;
            r._de265_free = B.Ye;
            r._de265_new_decoder = B.Ze;
            r._de265_set_parameter_bool = B._e;
            r._de265_free_decoder = B.$e;
            r._de265_push_NAL = B.af;
            r._de265_flush_data = B.bf;
            r._de265_decode = B.cf;
            r._de265_get_next_picture = B.df;
            r._de265_get_chroma_format = B.ef;
            r._de265_get_image_width = B.ff;
            r._de265_get_image_height = B.gf;
            r._de265_get_bits_per_pixel = B.hf;
            r._de265_get_image_plane = B.jf;
            r._de265_get_image_colour_primaries = B.kf;
            r._de265_get_image_transfer_characteristics = B.lf;
            r._de265_get_image_matrix_coefficients = B.mf;
            r._de265_get_image_full_range_flag = B.nf;
            r._de265_release_next_picture = B.of;
            var ve = B.pf, Fe = B.qf;
            r.dynCall_ji = B.rf;
            r.dynCall_iij = B.sf;
            r.dynCall_jijj = B.tf;
            r.dynCall_vijj = B.uf;
            r.dynCall_jiji = B.vf;
            r.dynCall_viijii = B.wf;
            r.dynCall_iiiiij = B.xf;
            r.dynCall_iiiiijj = B.yf;
            r.dynCall_iiiiiijj = B.zf;
            r._heif_error_ok = 80028;
            r._heif_error_success = 79460;
            r._heif_error_invalid_parameter_value = 80052;
            r._heif_error_unsupported_parameter = 80040;
            var DA;
            EA = function A() {
              DA || Vj(), DA || (EA = A);
            };
            function Vj() {
              if (tA > 0 || (E6(), tA > 0)) return;
              function A() {
                DA || (DA = true, r.calledRun = true, !pj && (n6(), z(r), r.onRuntimeInitialized && r.onRuntimeInitialized(), s6()));
              }
              r.setStatus ? (r.setStatus("Running..."), setTimeout(function() {
                setTimeout(function() {
                  r.setStatus("");
                }, 1), A();
              }, 1)) : A();
            }
            if (r.preInit) for (typeof r.preInit == "function" && (r.preInit = [r.preInit]); r.preInit.length > 0; ) r.preInit.pop()();
            Vj();
            function Uj(A) {
              for (var j = new ArrayBuffer(A.length), t = new Uint8Array(j), e = 0, l = A.length; e < l; e++) t[e] = A.charCodeAt(e);
              return j;
            }
            var Q = function(A) {
              this.handle = A, this.img = null;
            };
            Q.prototype.free = function() {
              this.handle && (r.heif_image_handle_release(this.handle), this.handle = null);
            }, Q.prototype._ensureImage = function() {
              if (!this.img) {
                var A = r.heif_js_decode_image(this.handle, r.heif_colorspace.heif_colorspace_YCbCr, r.heif_chroma.heif_chroma_420);
                if (!A || A.code) {
                  console.log("Decoding image failed", this.handle, A);
                  return;
                }
                this.data = new Uint8Array(Uj(A.data)), delete A.data, this.img = A, A.alpha !== void 0 && (this.alpha = new Uint8Array(Uj(A.alpha)), delete A.alpha);
              }
            }, Q.prototype.get_width = function() {
              return r.heif_image_handle_get_width(this.handle);
            }, Q.prototype.get_height = function() {
              return r.heif_image_handle_get_height(this.handle);
            }, Q.prototype.is_primary = function() {
              return !!heif_image_handle_is_primary_image(this.handle);
            }, Q.prototype.display = function(A, j) {
              this.get_width();
              this.get_height();
              setTimeout(function() {
                if (!this.img) {
                  var l = r.heif_js_decode_image2(this.handle, r.heif_colorspace.heif_colorspace_RGB, r.heif_chroma.heif_chroma_interleaved_RGBA);
                  if (!l || l.code) {
                    console.log("Decoding image failed", this.handle, l), j(null);
                    return;
                  }
                  for (let _ of l.channels) if (_.id == r.heif_channel.heif_channel_interleaved) if (_.stride == _.width * 4) A.data.set(_.data);
                  else for (let a = 0; a < _.height; a++) {
                    let o = _.data.slice(a * _.stride, a * _.stride + _.width * 4), i = a * _.width * 4;
                    A.data.set(o, i);
                  }
                  r.heif_image_release(l.image);
                }
                j(A);
              }.bind(this), 0);
            };
            var Yj = function() {
              this.decoder = null;
            };
            Yj.prototype.decode = function(A) {
              if (this.decoder && r.heif_context_free(this.decoder), this.decoder = r.heif_context_alloc(), !this.decoder) return console.log("Could not create HEIF context"), [];
              var j = r.heif_context_read_from_memory(this.decoder, A);
              if (j.code !== r.heif_error_code.heif_error_Ok) return console.log("Could not parse HEIF file", j.message), [];
              var t = r.heif_js_context_get_list_of_top_level_image_IDs(this.decoder);
              if (!t || t.code) return console.log("Error loading image ids", t), [];
              if (!t.length) return console.log("No images found"), [];
              for (var e = [], l = 0; l < t.length; l++) {
                var _ = r.heif_js_context_get_image_handle(this.decoder, t[l]);
                if (!_ || _.code) {
                  console.log("Could not get image data for id", t[l], _);
                  continue;
                }
                e.push(new Q(_));
              }
              return e;
            };
            var Ie = function(A) {
              return A.charCodeAt(0) << 24 | A.charCodeAt(1) << 16 | A.charCodeAt(2) << 8 | A.charCodeAt(3);
            };
            r.HeifImage = Q, r.HeifDecoder = Yj, r.fourcc = Ie;
            let ge = ["heif_error_code", "heif_suberror_code", "heif_compression_format", "heif_chroma", "heif_colorspace", "heif_channel"];
            for (let A of ge) for (let j in r[A]) !r[A].hasOwnProperty(j) || j === "values" || (r[j] = r[A][j]);
            for (let A in r) A.indexOf("_heif_") !== 0 || r[A.slice(1)] !== void 0 || (r[A.slice(1)] = r[A]);
            return K = r, K;
          };
        })();
        typeof k6 == "object" && typeof nj == "object" ? nj.exports = r6 : false;
      });
      var Me = {};
      De(Me, { default: () => Pe });
      var _6 = we(l6());
      var B6 = Qj("AGFzbQEAAAAB8ARJYAF/AGABfwF/YAJ/fwBgA39/fwBgA39/fwF/YAJ/fwF/YAR/f39/AGAFf39/f38AYAd/f39/f39/AGAGf39/f39/AGAEf39/fwF/YAZ/f39/f38Bf2AFf39/f38Bf2AIf39/f39/f38AYAAAYAABf2ACf34Bf2AKf39/f39/f39/fwBgAX8BfmAIf39/f39/f38Bf2AJf39/f39/f39/AGAHf39/f39/fwF/YAN/fn4BfmADf35/AX5gBX9/fn9/AGAFf35+fn4AYAV/f39/fgF/YA1/f39/f39/f39/f39/AGAEf35+fwBgA39+fgBgBX9/f398AX9gC39/f39/f39/f39/AX9gCn9/f39/f39/f38Bf2ACfn8Bf2APf39/f39/f39/f39/f39/AGAMf39/f39/f39/f39/AGAHf39/f39+fgF/YAZ/f39/fn4Bf2ADf39+AGACfH8BfGAGf39/f35+AGADf35/AX9gDH9/f39/f39/f39/fwF/YAF8AXxgDn9/f39/f39/f39/f39/AGACf38BfmAEf39/fwF+YAZ/fH9/f38Bf2ADfn5/AGAFf39/f38BfGACf3wBf2ACf34AYAJ/fABgAX0Bf2AEfn5+fgF/YAR/f39+AX5gA3x8fwF8YAJ8fAF8YAl/f39/f39+fn8AYAt/f39/f39/f39/fwBgA39+fwBgAn5+AXxgBH9/fn4AYAN/f38BfGADf39/AX1gAn5+AX1gBH9+fn4AYAN+fn4Bf2ACfH8Bf2AKf39/f39/f35/fwF/YAZ/f39+f38Bf2AFf39/fn8Bf2AJf39/f39/f39/AX8C/QEqAWEBYQADAWEBYgAGAWEBYwAAAWEBZAAFAWEBZQADAWEBZgAIAWEBZwADAWEBaAABAWEBaQAHAWEBagAGAWEBawAPAWEBbAARAWEBbQAbAWEBbgAKAWEBbwADAWEBcAADAWEBcQAPAWEBcgAEAWEBcwABAWEBdAAKAWEBdQACAWEBdgADAWEBdwAAAWEBeAAJAWEBeQAMAWEBegAIAWEBQQAMAWEBQgAEAWEBQwAOAWEBRAABAWEBRQAEAWEBRgAKAWEBRwAFAWEBSAAFAWEBSQADAWEBSgAAAWEBSwAGAWEBTAACAWEBTQAAAWEBTgAxAWEBTwAEAWEBUAAAA+0P6w8AAAEE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QCABIAggAyABKAIAKAIwEQQAIANHDQELIAZBADYCDCABIQILIAVBEGokACACDAELEDgACw0AIAAgACgCAEEMaygCAGoiASABKAIQQQVyEHoLIAsQciAHQRBqJAAgAAvaAQECfyMAQRBrIgQkAAJAAkAgAkELSQRAIAAiAyAALQALQYABcSACQf8AcXI6AAsgACAALQALQf8AcToACwwBCyACQff///8HSw0BIARBCGogAkELTwR/IAJBCGpBeHEiAyADQQFrIgMgA0ELRhsFQQoLQQFqEPIBIAQoAgwaIAAgBCgCCCIDNgIAIAAgACgCCEGAgICAeHEgBCgCDEH/////B3FyNgIIIAAgACgCCEGAgICAeHI2AgggACACNgIECyABIAJBAWogAxCxASAEQRBqJAAPCxCKAQALSQAgACACNgIEIAAgATYCACAAQQhqIQEgAywAC0EATgRAIAEgAykCADcCACABIAMoAgg2AgggAA8LIAEgAygCACADKAIEEC4gAAtYAQN/IwBBEGsiAyQAQZSvAygCACEEIAEtAABBKkYiBUUEQEGEwwFBBkEBIAQQeBoLIAMgAjYCDCAAIAEgBWogAkGPCkGQChDbAhogBBDPARogA0EQaiQAC7YBAgN/An4CQCAAKAIQIgIgAU4NACACQThKDQBBwAAgAmutIQUgACgCBCECA0ACQCAFpyEEIAJFBEAgBCEDDAELIAAgACgCACIDQQFqNgIAIAMxAAAhBiAAIAJBAWsiAjYCBCAAIAApAwggBiAEQQhrIgOthoQ3AwggBUIIfSEFIARBD0oNAQsLQcAAIANrIQILIAAgAiABazYCECAAIAApAwgiBSABrYY3AwggBUHAACABa62IpwuABAEDfyACQYAETwRAIAAgASACECIgAA8LIAAgAmohAwJAIAAgAXNBA3FFBEACQCAAQQNxRQRAIAAhAgwBCyACRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAkEDcUUNASACIANJDQALCwJAIANBfHEiBEHAAEkNACACIARBQGoiBUsNAANAIAIgASgCADYCACACIAEoAgQ2AgQgAiABKAIINgIIIAIgASgCDDYCDCACIAEoAhA2AhAgAiABKAIUNgIUIAIgASgCGDYCGCACIAEoAhw2AhwgAiABKAIgNgIg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AiwgA0IANwIUIANBADYCECADIAI2AgwgAyAFNgIEIANBADYCPCADQoGAgICAgICAATcCNCADIAA2AgggBSADQQRqIAYgBkEBQQAgBSgCACgCFBEJACAAQQAgAygCHBshBwsgA0FAayQAIAciAw0AIwBBQGoiAyQAIANBADYCECADIAE2AgwgAyAANgIIIAMgAjYCBEEAIQAgA0EUakEAQScQNBogA0EANgI8IANBAToAOyAFIANBBGogBkEBQQAgBSgCACgCGBEHAAJAAkACQCADKAIoDgIAAQILIAMoAhhBACADKAIkQQFGG0EAIAMoAiBBAUYbQQAgAygCLEEBRhshAAwBCyADKAIcQQFHBEAgAygCLA0BIAMoAiBBAUcNASADKAIkQQFHDQELIAMoAhQhAAsgA0FAayQAIAAhAwsgBEEQaiQAIAML9wQBAX8jAEFAaiIHJAAgB0IANwMoIAdCADcDMCAHQQA2AjggB0IANwMgIAdBgAI7ARwgB0EBNgIYIAcgB0EYaiADIARBAUEIQQggBSABKAIkIgNBCkYbIAUgBUEYRhsiBCAEQSBGGyAEIANBC0YbAn9BASEEAkACQAJAAkAgAw5kAwMDAwICAgICAgABAAEAAQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwILQQMMAwtBBAwCC0EAIQQLIAQLIAYQuQICQCAHKAIABEAgACAHKQMANwIAIAAgBygCEDYCECAAIAcpAwg3AgggB0EANgIQIAdCADcDCAwBCwJAAkAgASgCQCIDRQRAIAFBQGsiBiEFDAELA0AgAiADIgUoAhAiA0gEQCAFIgYoAgAiAw0BDAILIAIgA0wNAiAFKAIEIgMNAAsgBUEEaiEGC0E4ECwiAyACNgIQIAMgBykDGDcCFCADIAcpAyA3AhwgAyAHKQMoNwIkIAMgBykDMDcCLCADIAcoAjg2AjQgAyAFNgIIIANCADcCACAGIAM2AgAgASgCPCgCACICBEAgASACNgI8IAYoAgAhAwsgASgCQCADEI4BIAEgASgCREEBajYCRAsgAEGQpQUpAgA3AgAgAEEIaiEAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABB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dDYCDCAAIAQgAmsgA3Q2AhAgASABLQAAIgJBAXZB8PwCai0AAEEBdCACQQFxIgRFIgEgBCACQQJJG3I6AAAgACADIAAvARRqIgI7ARQgAsEiAkEASA0AIAAoAgQiAyAAKAIISQRAIAAgA0EBajYCBCAAIAAoAhAgAy0AACACdHI2AhALIAAgAkEIazsBFAsgAQttAQR/IAAoAgwiAkECaiIEIAAoAgQgACgCACIDayIFSwRAIAAgBCAFaxBlIAAoAgAhAyAAKAIMIQILIAAgAkEBajYCDCACIANqIAFBCHY6AAAgACAAKAIMIgJBAWo2AgwgAiAAKAIAaiABOgAAC6UBAQN/IwBBEGsiAyQAAkAgAEECEIsBRQ0AIAAoAgAhAiAAKAIEIgEEQCABIAEoAgRBAWo2AgQLAn8gAiADQQ5qQQIgAigCACgCEBEEAEUEQCAAEKIBQQAMAQsgAy8ADiIAQQh0IABBCHZyCyECIAFFDQAgASABKAIEIgBBAWs2AgQgAA0AIAEgASgCACgCCBEAACABECsLIANBEGokACACQf//A3ELLwEBf0EEEKADIgBBgLoENgIAIABB2LkENgIAIABB7LkENgIAIABB3LoEQSAQDwALgwIBA38CQAJ/IAAtAAtBB3YEQCAAKAIEDAELIAAtAAtB/wBxCyICIAFJBEAjAEEQayIEJAAgASACayICBEAgAiAALQALQQd2BH8gACgCCEH/////B3FBAWsFQQoLIgMCfyAALQALQQd2BEAgACgCBAwBCyAALQALQf8AcQsiAWtLBEAgACADIAIgA2sgAWogASABEKkDCyABAn8gAC0AC0EHdgRAIAAoAgAMAQsgAAsiA2ogAkEAENYEIAAgASACaiIAENgBIARBADoADyAAIANqIAQtAA86AAALIARBEGokAAwBCyAAAn8gAC0AC0EHdgRAIAAoAgAMAQsgAAsgARDgBAsLlAEBAn8CQAJAIAJFDQAgACgCpAEiA0EASgRAIABB1ABqIQRBACECA0AgBCACQQJ0aigCACABRg0DIAJBAWoiAiADRw0ACyADQRNKDQELIAAgA0EBajYCpAEgACADQQJ0aiABNgJUCyAAKAJQIgJBFEYEQCAAQekHNgJMDwsgACACQQFqNgJQIAAgAkECdGogATYCAAsLlQEBA38jAEEQayIDJAACQCAAQQEQiwFFDQAgACgCACECIAAoAgQiAQRAIAEgASgCBEEBajYCBAsCfyACIANBD2pBASACKAIAKAIQEQQARQRAIAAQogFBAAwBCyADLQAPCyECIAFFDQAgASABKAIEIgBBAWs2AgQgAA0AIAEgASgCACgCCBEAACABECsLIANBEGokACACC/ECAQZ/AkAgACgCBCIEIAAoAgAiB2tBA3UiBkEBaiICQYCAgIACSQRAQf////8BIAAoAgggB2siA0ECdSIFIAIgAiAFSRsgA0H4////B08bIgMEfyADQYCAgIACTw0CIANBA3QQLAVBAAsiBSAGQQN0aiICIAEoAgA2AgAgAiABKAIENgIEIAFCADcCACAFIANBA3RqIQUgAkEIaiEGAkAgBCAHRgRAIAIhAQwBCwNAIAJBCGsiASAEQQhrIgMoAgA2AgAgAkEEayAEQQRrKAIANgIAIANCADcCACABIQIgAyIEIAdHDQALCyAAKAIAIQIgACABNgIAIAAoAgQhASAAIAY2AgQgACgCCBogACAFNgIIIAEgAkcEQANAAkAgAUEEaygCACIARQ0AIAAgACgCBCIEQQFrNgIEIAQNACAAIAAoAgAoAggRAAAgABArCyABQQhrIgEgAkcNAAsLIAIEQCACECoLIAYPCxA2AAsQTwALtwECBX8DfgJAIAAoAhgiAiABTg0AIAJBOEoNAEHAACACa60hByAAKQMQIQggACgCCCECIAAoAgAhAwNAAkAgB6chBCACRQRAIAQhBQwBCyAAIANBAWoiBjYCACADMQAAIQkgACACQQFrIgI2AgggACAJIARBCGsiBa2GIAiEIgg3AxAgB0IIfSEHIAYhAyAEQQ9KDQELC0HAACAFayECCyAAIAIgAWs2AhggACAAKQMQIAGthjcDEAvUKAEMfyMAQRBrIgokAAJAAkACQAJAAkACQAJAAkACQAJAIABB9AFNBEBBqLgGKAIAIgRBECAAQQtqQfgDcSAAQQtJGyIGQQN2IgB2IgFBA3EEQAJAIAFBf3NBAXEgAGoiAkEDdCIBQdC4BmoiACABQdi4BmooAgAiASgCCCIFRgRAQai4BiAEQX4gAndxNgIADAELIAUgADYCDCAAIAU2AggLIAFBCGohACABIAJBA3QiAkEDcjYCBCABIAJqIgEgASgCBEEBcjYCBAwLCyAGQbC4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B2ohCCABIAYgB2oiAkEAIAEQNCIDaiEJAkAgBCAFRgRAIAMhBwwBCwJAIAZBA3EiBkUEQCAEIQEMAQtBACEDIAQhAQNAIAJBAWsiAiABQQFrIgEtAAA6AAAgA0EBaiIDIAZHDQALCyAFIARrQXxNBEADQCACQQFrIAFBAWstAAA6AAAgAkECayABQQJrLQAAOgAAIAJBA2sgAUEDay0AADoAACACQQRrIgIgAUEEayIBLQAAOgAAIAEgBUcNAAsLIAAoAggaIAAoAgAhBQsgACAINgIIIAAgCTYCBCAAIAc2AgAgBQRAIAUQKgsPCxA2AAvJCgIFfxF+IwBB4ABrIgUkACAEQv///////z+DIQwgAiAEhUKAgICAgICAgIB/gyEKIAJC////////P4MiDUIgiCEOIARCMIinQf//AXEhBwJAAkAgAkIwiKdB//8BcSIJQf//AWtBgoB+TwRAIAdB//8Ba0GBgH5LDQELIAFQIAJC////////////AIMiC0KAgICAgIDA//8AVCALQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQoMAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhCiADIQEMAgsgASALQoCAgICAgMD//wCFhFAEQCACIAOEUARAQoCAgICAgOD//wAhCkIAIQEMAwsgCkKAgICAgIDA//8AhCEKQgAhAQwCCyADIAJCgICAgICAwP//AIWEUARAIAEgC4QhGUIAIQEgGVAEQEKAgICAgIDg//8AIQoMAwsgCkKAgICAgIDA//8AhCEKDAILIAEgC4RQBEBCACEBDAILIAIgA4RQBEBCACEBDAILIAtC////////P1gEQCAFQdAAaiABIA0gASANIA1QIgYbeSAGQQZ0rXynIgZBD2sQhgFBECAGayEGIAUpA1giDUIgiCEOIAUpA1AhAQsgAkL///////8/Vg0AIAVBQGsgAyAMIAMgDCAMUCIIG3kgCEEGdK18pyIIQQ9rEIYBIAYgCGtBEGohBiAFKQNIIQwgBSkDQCEDCyADQg+GIgtCgID+/w+DIgIgAUIgiCIEfiIQIAtCIIgiEyABQv////8PgyIBfnwiD0IghiIRIAEgAn58IgsgEVStIAIgDUL/////D4Mi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DQAgASABKAIEIgRBAWs2AgQgBA0AIAEgASgCACgCCBEAACABECsLIANBCGsiAyACRw0ACyAAKAK0ASEBCyAAIAI2ArgBIAAoArwBGiABECoLIAAoAqgBIgIEQCAAKAKsASIDIAIiAUcEQANAAkAgA0EEaygCACIBRQ0AIAEgASgCBCIEQQFrNgIEIAQNACABIAEoAgAoAggRAAAgARArCyADQQhrIgMgAkcNAAsgACgCqAEhAQsgACACNgKsASAAKAKwARogARAqCyAALACnAUEASARAIAAoAqQBGiAAKAKcARAqCwJAIAAoAlQiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsCQCAAKAJIIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEAACABECsLIAAoAjQiAgRAIAAoAjgiAyACIgFHBEADQAJAIANBBGsoAgAiAUUNACABIAEoAgQiBEEBazYCBCAEDQAgASABKAIAKAIIEQAAIAEQKwsgA0EIayIDIAJHDQALIAAoAjQhAQsgACACNgI4IAAoAjwaIAEQKgsgACgCGCICBEAgACgCHCIDIAIiAUcEQANAAkAgA0EEaygCACIBRQ0AIAEgASgCBCIEQQFrNgIEIAQNACABIAEoAgAoAggRAAAgARArCyADQQhrIgMgAkcNAAsgACgCGCEBCyAAIAI2AhwgACgCIBogARAqCyAALAAPQQBIBEAgACgCDBogACgCBBAqCyAACy0AIAJFBEAgACgCBCABKAIERg8LIAAgAUYEQEEBDwsgACgCBCABKAIEEIgBRQsNACAAKAIAEMYFGiAACw0AIAAoAgAQzQUaIAALQgEBfyABIAJsIQQgBAJ/IAMoAkxBAEgEQCAAIAQgAxDfAgwBCyAAIAQgAxDfAgsiAEYEQCACQQAgARsPCyAAIAFuC70DAgd/BH4gACkDECEJIAAoAgAhBiAAKAIYIQIgACgCCCIHIQMCQANAIAACfyACQQBKBEAgCSEKIAIMAQtBwAAgAmshAgJ+IANFBEBBACEDIAIhBCAJDAELIAKtIQsCQANAIAAgBkEBaiIINgIAIAYxAAAhCiAAIANBAWsiAzYCCCAAIAogAkEIayIErYYgCYQiCTcDECACQQ9MDQEgC0IIfSILpyECIAghBiADDQALIAMhB0EAIQMgAiEEIAkMAQsgAyEHIAghBiAJCyEKQcAAIARrCyIEQQFrIgI2AhggACAKQgGGIgk3AxAgCkIAWQRAIAVBAWoiBUEVRw0BDAILCyABIAUEfwJAIAQgBUoNACAEQTlKDQBBwQAgBGutIQsDQAJAIAunIQIgB0UEQCACIQQMAQsgACAGQQFqIgM2AgAgBjEAACEMIAAgB0EBayIHNgIIIAAgDCACQQhrIgSthiAJhCIJNwMQIAtCCH0hCyADIQYgAkEPSg0BCwtBwAAgBGshAgsgACACIAVrNgIYIAAgCSAFrYY3AxAgCUHAACAFa62Ip0F/IAV0QX9zagVBAAs2AgALIApCP4inCyAAIAAgACgCGEUgAXIiATYCECAAKAIUIAFxBEAQbAALC8wBAQJ/IwBBEGsiAyQAIAEgAhBJIgRB////B3E2AmQgASAEQRh2OgBhIAEgASgCIEEEajYCIAJAIAItABRBAUYEQCADQQA6AAQgA0EAOgAPIABBAkHkACADQQRqEC8aIAMsAA9BAE4NASADKAIMGiADKAIEECoMAQsgAEGQpQUpAgA3AgAgAEEIaiEAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyADQRBqJAALdQEBfiAAIAEgBH4gAiADfnwgA0IgiCICIAFCIIgiBH58IANC/////w+DIgMgAUL/////D4MiAX4iBUIgiCADIAR+fCIDQiCIfCABIAJ+IANC/////w+DfCIBQiCIfDcDCCAAIAVC/////w+DIAFCIIaENwMACxgAIAAtAABBIHFFBEAgASACIAAQ3wIaCwuoAQACQCABQYAITgRAIABEAAAAAAAA4H+iIQAgAUH/D0kEQCABQf8HayEBDAILIABEAAAAAAAA4H+iIQBB/RcgASABQf0XTxtB/g9rIQEMAQsgAUGBeEoNACAARAAAAAAAAGADoiEAIAFBuHBLBEAgAUHJB2ohAQwBCyAARAAAAAAAAGADoiEAQfBoIAEgAUHwaE0bQZIPaiEBCyAAIAFB/wdqrUI0hr+iC30BA38gACAAKAIQQQF0IgI2AhAgACAALwEUQQFqIgE7ARQCQCABwUEASA0AIABB+P8DOwEUIAAoAgQiASAAKAIITw0AIAAgAUEBajYCBCAAIAIgAS0AAHIiAjYCEAsgACgCDEEHdCIBIAJNBH8gACACIAFrNgIQQQEFQQALC3cBA38gARBYIgJB+P///wdJBEACQAJAIAJBC08EQCACQQdyQQFqIgQQLCEDIAAgBEGAgICAeHI2AgggACADNgIAIAAgAjYCBAwBCyAAIAI6AAsgACEDIAJFDQELIAMgASACEDcaCyACIANqQQA6AAAgAA8LEDgAC4MBAQN/AkACQCABKAKAASIDRQ0AIAFBgAFqIgQhAQNAIAEgAyADKAIQIAJJIgUbIQEgAyAFQQJ0aigCACIDDQALIAEgBEYNACABKAIQIAJNDQELIABCADcCAA8LIAAgASgCFDYCACAAIAEoAhgiADYCBCAABEAgACAAKAIEQQFqNgIECwttAQJ/IwBBEGsiBSQAIAUgAjYCDCAFIAQ2AgggBUEEaiAFQQxqEKcBIQYgACABIAMgBSgCCBDaAiEBIAYoAgAiAARAQeivBigCABogAARAQeivBkHwrgYgACAAQX9GGzYCAAsLIAVBEGokACABC+0BAQJ/An8gAC0AC0EHdgRAIAAoAgQMAQsgAC0AC0H/AHELIQQCQCACIAFrQQVIDQAgBEUNACABIAIQxQIgAkEEayEEAn8gAC0AC0EHdgRAIAAoAgQMAQsgAC0AC0H/AHELAn8gAC0AC0EHdgRAIAAoAgAMAQsgAAsiAmohBQJAA0ACQCACLAAAIQAgASAETw0AAkAgAEEATA0AIABB/wBODQAgACABKAIARw0DCyABQQRqIQEgAiAFIAJrQQFKaiECDAELCyAAQQBMDQEgAEH/AE4NASACLAAAIAQoAgBBAWtLDQELIANBBDYCAAsLugEBAn8jAEEQayICJAAgAC0AC0EHdgRAIAAoAggaIAAoAgBBARC/AQsCfyABLQALQQd2BEAgASgCBAwBCyABLQALCxogAS0AC0EHdiEDIAAgASgCCDYCCCAAIAEpAgA3AgAgASABLQALQYABcToACyABIAEtAAtB/wBxOgALIAJBADoADyABIAItAA86AAACQCAAIAFGIgENACADDQALIAAtAAtBB3YhAAJAIAENACAADQALIAJBEGokAAvWAQEFfyMAQRBrIgIkACACQQhqIAAQcxoCQCACLQAIRQ0AIAJBBGoiBCAAIAAoAgBBDGsoAgBqKAIc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IAMgAigCCCIANgIIIAAgACgCACACR0ECdGogAzYCACADIAI2AgQgAiADNgIIDwsCQCADRQ0AIAMtAAxBAUYNACADQQxqIQMMAQsCQCABIAQoAgAiA0cEQCAEIQMMAQsgBCADKAIEIgA2AgAgAARAIAAgBDYCCCAEKAIIIQILIAMgAjYCCCACIAIoAgAgBEdBAnRqIAM2AgAgAyAENgIEIAQgAzYCCCADKAIIIQILIANBAToADCACQQA6AAwgAiACKAIEIgEoAgAiADYCBCAABEAgACACNgIICyABIAIoAggiADYCCCAAIAAoAgAgAkdBAnRqIAE2AgAgASACNgIAIAIgATYCCAwCCyAEQQE6AAwgAiAAIAJGOgAMIANBAToAACACIgEgAEcNAAsLC9MJAgR/BX4jAEHwAGsiBiQAIARC////////////AIMhCQJAAkAgAVAiBSACQv///////////wCDIgpCgICAgICAwP//AH1CgICAgICAwICAf1QgClAbRQRAIANCAFIgCUKAgICAgIDA//8AfSILQoCAgICAgMCAgH9WIAtCgICAgICAwICAf1EbDQELIAUgCkKAgICAgIDA//8AVCAKQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQQgASEDDAILIANQIAlCgICAgICAwP//AFQgCUKAgICAgIDA//8AURtFBEAgBEKAgICAgIAghCEEDAILIAEgCkKAgICAgIDA//8AhYRQBEBCgICAgICA4P//ACACIAEgA4UgAiAEhUKAgICAgICAgIB/hYRQIgUbIQRCACABIAUbIQMMAgsgAyAJQoCAgICAgMD//wCFhFANASABIAqEUARAIAMgCYRCAFINAiABIAODIQMgAiAEgyEEDAILIAMgCYRCAFINACABIQMgAiEEDAELIAMgASABIANUIAkgClYgCSAKURsiCBshCiAEIAIgCBsiDEL///////8/gyEJIAIgBCAIGyILQjCIp0H//wFxIQcgDEIwiKdB//8BcSIFRQRAIAZB4ABqIAogCSAKIAkgCVAiBRt5IAVBBnStfKciBUEPaxCGASAGKQNoIQkgBikDYCEKQRAgBWshBQsgASADIAgbIQMgC0L///////8/gyEBIAcEfiABBSAGQdAAaiADIAEgAyABIAFQIgcbeSAHQQZ0rXynIgdBD2sQhgFBECAHayEHIAYpA1AhAyAGKQNYC0IDhiADQj2IhEKAgICAgICABIQhASAJQgOGIApCPYiEIQ0gAiAEhSEEAn4gA0IDhiICIAUgB0YNABogBSAHayIHQf8ASwRAQgAhAUIBDAELIAZBQGsgAiABQYABIAdrEIYBIAZBMGogAiABIAcQ3QEgBikDOCEBIAYpAzAgBikDQCAGKQNIhEIAUq2ECyEJIA1CgICAgICAgASEIQsgCkIDhiEKAkAgBEIAUwRAQgAhA0IAIQQgCSAKhSABIAuFhFANAiAKIAl9IQIgCyABfSAJIApWrX0iBEL/////////A1YNASAGQSBqIAIgBCACIAQgBFAiBxt5IAdBBnStfKdBDGsiBxCGASAFIAdrIQUgBikDKCEEIAYpAyAhAgwBCyAJIAp8IgIgCVStIAEgC3x8IgRCgICAgICAgAiDUA0AIAlCAYMgBEI/hiACQgGIhIQhAiAFQQFqIQUgBEIBiCEECyAMQoCAgICAgICAgH+DIQMgBUH//wFOBEAgA0KAgICAgIDA//8AhCEEQgAhAwwBC0EAIQcCQCAFQQBKBEAgBSEHDAELIAZBEGogAiAEIAVB/wBqEIYBIAYgAiAEQQEgBWsQ3QEgBikDACAGKQMQIAYpAxiEQgBSrYQhAiAGKQMIIQQLIARCPYYgAkIDiIQhASAEQgOIQv///////z+DIAetQjCGhCADhCEEAkACQCACp0EHcSIFQQRHBEAgBCABIAEgBUEES618IgNWrXwhBAwBCyAEIAEgASABQgGDfCIDVq18IQQMAQsgBUUNAQsLIAAgAzcDACAAIAQ3AwggBkHwAGokAAuQAgEGfwJAIAEEQCAAKAIsIgIgACgCKCIFayIEQQJ1IgNBD00EQCAAKAIwIgYgAksEQCACIAE2AgAgACACQQRqNgIsDwtB/////wMgBiAFayIGQQF1IgcgA0EBaiIDIAMgB0kbIAZB/P///wdPGyIDQYCAgIAETw0CIANBAnQiAxAsIgYgBGoiBCABNgIAIARBBGohASACIAVHBEADQCAEQQRrIgQgAkEEayICKAIANgIAIAIgBUcNAAsLIAAgAyAGajYCMCAAIAE2AiwgACAENgIoIAUEQCAFECoLIAAgATYCLA8LIAEoAhQQKiABKAIgIgAEQCABIAA2AiQgASgCKBogABAqCyABECoLDwsQTwALiQUBBX8jAEGgAWsiAyQAIANBoNMDNgIYIANBtNMDNgJQIANBxNMDKAIAIgQ2AhAgA0EQaiIFIARBDGsoAgBqQcjTAygCADYCACADQQA2AhQgBSADKAIQQQxrKAIAaiIEIANBHGoiBhA+IARCgICAgHA3AkggA0HM0wMoAgAiBDYCGCADQRhqIgcgBEEMaygCAGpB0NMDKAIANgIAIANBwNMDKAIAIgQ2AhAgBSAEQQxrKAIAakHU0wMoAgA2AgAgA0G00wM2AlAgA0GM0wM2AhAgA0Gg0wM2AhggBhA/IgRB8MsDNgIAIANCADcCRCADQgA3AjwgA0EYNgJMIAcgAiACEFgQLUGeqgFBEhAtIAEtAGEQQkHfHEEXEC0aAkACfyADKAJMIgFBEHEEQCADKAJIIgEgAygCNCICSQRAIAMgAjYCSCACIQELIANBMGoMAQsgAUEIcUUEQEEAIQEgA0EAOgAPIANBBGohAgwCCyADKAIsIQEgA0EkagshAgJAIAEgAigCACIFayIBQfj///8HSQRAIAFBC08EQCABQQdyQQFqIgYQLCECIAMgBkGAgICAeHI2AgwgAyACNgIEIAMgATYCCAwCCyADIAE6AA8gA0EEaiECIAENAUEAIQEMAgsQOAALIAIgBSABEDcaCyABIAJqQQA6AAAgAEEEQboXIANBBGoQLxogAywAD0EASARAIAMoAgwaIAMoAgQQKgsgA0G80wMoAgAiADYCECAAQQxrKAIAIANBEGpqQdzTAygCADYCACADQeDTAygCADYCGCAEQfDLAzYCACADLABHQQBIBEAgAygCRBogAygCPBAqCyAEED0aIANB0ABqEDsaIANBoAFqJAALoAIBB38CQAJAIAAoAmwiAiABIAAoAnAiAyACa0ECdRDLAyICIAMgAhsiBiAAKAJwIgJGBEACQCAAKAJ0IgQgBksEQCACIAE2AgAgAkEEaiEBDAELIAYgACgCbCIDa0ECdSIIQQFqIgVBgICAgARPDQJB/////wMgBCADayIEQQF1IgcgBSAFIAdJGyAEQfz///8HTxsiBAR/IARBgICAgARPDQQgBEECdBAsBUEACyIHIAhBAnRqIgUgATYCACAFQQRqIQEgAyAGRwRAA0AgBUEEayIFIAJBBGsiAigCADYCACACIANHDQALCyAA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AAAiBDoAACAFIAItAABBAnRqIAItAAFBB3RqIAQ6AAAgACACLQAAQQJ0aiACLQABQQd0aiADLQAAIgQ6ACAgByACLQAAQQJ0aiACLQABQQd0aiAEOgAgIAYgAi0AAEECdGogAi0AAUEHdGogAy0AACIEOgAgIAUgAi0AAEECdGogAi0AAUEHdGogBDoAICAAIAItAABBAnRqIAItAAFBB3RqIAMtAAAiBDoAQCAHIAItAABBAnRqIAItAAFBB3RqIAQ6AEAgBiACLQAAQQJ0aiACLQABQQd0aiADLQAAIgQ6AEAgBSACLQAAQQJ0aiACLQABQQd0aiAEOgBAIAAgAi0AAEECdGogAi0AAUEHdGogAy0AACIEOgBgIAcgAi0AAEECdGogAi0AAUEHdGogBDoAYCAGIAItAABBAnRqIAItAAFBB3RqIAMtAAAiAzoAYCAFIAItAABBAnRqIAItAAFBB3RqIAM6AGAgCEEBaiIIQcAARw0ACwwCC0GdkAFB3fQAQeEGQacpEAEACyAAQdiLAygCACgCCCICLQABQQJ0aiACLQAAaiABLQAAOgAAIAItAAIgACACLQADQQJ0amogAS0AAToAACACLQAEIAAgAi0ABUECdGpqIAEtAAI6AAAgAi0ABiAAIAItAAdBAnRqaiABLQADOgAAIAItAAggACACLQAJQQJ0amogAS0ABDoAACACLQAKIAAgAi0AC0ECdGpqIAEtAAU6AAAgAi0ADCAAIAItAA1BAnRqaiABLQAGOgAAIAItAA4gACACLQAPQQJ0amogAS0ABzoAACACLQAQIAAgAi0AEUECdGpqIAEtAAg6AAAgAi0AEiAAIAItABNBAnRqaiABLQAJOgAAIAItABQgACACLQAVQQJ0amogAS0ACjoAACACLQAWIAAgAi0AF0ECdGpqIAEtAAs6AAAgAi0AGCAAIAItABlBAnRqaiABLQAMOgAAIAItABogACACLQAbQQJ0amogAS0ADToAACACLQAcIAAgAi0AHUECdGpqIAEtAA46AAAgAi0AHiAAIAItAB9BAnRqaiABLQAPOgAACwvqAwEBfwJAAkACQAJAAkACQCABIAlKDQAgASADaiAJTA0AIAIgCkoNACACIANqIApKDQELQQAhAyAJIApyQQBIDQIgACgCfCIBKALkAyAJTA0CIAEoAugDIApM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DC8BQEEBdGsiByAHQR91IgdzIAdrSg0BCyAJQYABaiEHDAELIAlBgAFqIQcgDyAMQYABay8BACINIAtqIAxBQGovAQBBAXRrIg4gDkEfdSIOcyAOa00NACAJIAo7AYACIAkgDTsBACAJIAs7AYABIAogC2shDyANIAtrIQ5BASEKA0AgByAKQQF0Ig1rIAsgCiAObEEgakEGdmo7AQAgByANaiALIAogD2xBIGpBBnZqOwEAIApBAWoiDUHAAEcEQCAHIApBf3NBAXRqIAsgDSAObEEgakEGdmo7AQAgByANQQF0aiALIA0gD2xBIGpBBnZqOwEAIApBAmohCgwBCwtBACADQQF0ayEODAELIAlBgAFqIgsgA0ECdCIKayAMIAprLwEAOwEAIAogC2ogCiAMai8BADsBAEEAIANBAXQiDWshDkEBIA1rIgogDU4NACALIApBAXQiEGogDEECayISIBBqLwEAIAxBAiANayIKQQF0ai8BACIPIAwgEGovAQBBAXRqakECakECdjsBAANAIAsgCkEBdCIQaiAQIBJqLwEAIAwgEEECaiIYai8BACIVIA9BAXRqakECakECdjsBACALIBhqIAwgEGovAQAgDCAKQQJqIgpBAXRqLwEAIg8gFUEBdGpqQQJqQQJ2OwEAIAogDUcNAAsLIAwgDkEBdCIKaiAHIApqIANBA3RBAnIQMhoLIAlBkAJqJAALAkACQAJAAkAgEQ4CAAECC0EBIQsgA0ECTgRAQQAhByADIQgDQCAHIgpBAWohByAIQQNLISIgCEEBdiEIICINAAsgCkECaiELCyADQQBMDQIgA0H+////B3EhGCADQQFxIRUgA0EBayEKIAwgA0F/c0EBdGovAQAhFiAMIANBAXRqLwECIQlBACEIA0AgCiAIayERIAhBAWoiByAWbCENIBMgCCAUbEEBdGohDyAMIAhBf3NBAXRqLwEAIQ5BACEIQQAhECADQQFHBEADQCAPIAhBAXRqIAogCGsgDmwgA2ogCEEBciISIAlsaiARIAwgEkEBdCIXai8BAGxqIA1qIAt1OwEAIA8gF2ogCiASayAObCADaiAIQQJqIgggCWxqIBEgDCAIQQF0ai8BAGxqIA1qIAt1OwEAIBBBAmoiECAYRw0ACwsgFQRAIA8gCEEBdGogCiAIayAObCADaiAIQQFqIggg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QQAhAiAFQQNLBEADQCAJIAovAQA7AQAgCSABQQF0IgdqIgkgCi8BAjsBACAHIAlqIgkgCi8BBDsBACAHIAlqIgkgCi8BBjsBACAHIAlqIQkgCkEIaiEKIAJBBGoiAiALRw0ACwtBACECIAhFDQADQCAJIAovAQA7AQAgCkECaiEKIAkgAUEBdGohCSACQQFqIgIgCEcNAAsLIANBAWoiAyAERw0ACwsLsgwBC38gCEECdCIJQaCJA2ooAgAgBWoiDCAJQZCJA2ooAgAiCWohDiAHQQJ0QZCJA2ooAgAhCgJAAkACQAJAAkAgBw4EAAECAwQLIAxBACAJayINTA0DIARBAEwNAyAGIAlBAXRqIRAgAiAKayERIARB/P///wdxIRIgBEEDcSEPIARBBEkhEwNAIBAgDUEBdGohCiARIAMgDWxqIQlBACELIBNFBEADQCAKIAktAAA7AQAgCiAOQQF0IgJqIgogCS0AATsBACACIApqIgogCS0AAjsBACACIApqIgogCS0AAzsBACACIApqIQogCUEEaiEJIAtBBGoiCyASRw0ACwtBACECIA8EQANAIAogCS0AADsBACAJQQFqIQkgCiAOQQF0aiEKIAJBAWoiAiAPRw0ACwsgDUEBaiINIAxHDQALDAMLIAxBACAJayILTA0CIARBAEwNAiAGIAlBAXRqIQ0gAiAKayEPA0AgDSALQQF0aiEKIA8gAyALbGohCUEAIQIDQCAKIAktAAYgCS0AAUECdCAJLQAAayAJLQACQXZsaiAJLQADQTpsaiAJLQAEQRFsaiAJLQAFQXtsamo7AQAgCUEBaiEJIAogDkEBdGohCiACQQFqIgIgBEcNAAsgC0EBaiILIAxHDQALDAILIAxBACAJayILTA0BIARBAEwNASAGIAlBAXRqIQ0gAiAKayEPA0AgDSALQQF0aiEKIA8gAyALbGohCUEAIQIDQCAKIAktAAFBAnQgCS0AAGsgCS0ABCAJLQADakEobGogCS0ABkECdGogCS0AB2sgCS0ABSAJLQACakF1bGo7AQAgCUEBaiEJIAogDkEBdGohCiACQQFqIgIgBEcNAAsgC0EBaiILIAxHDQALDAELIAxBACAJayILTA0AIARBAEwNACAGIAlBAXRqIQ0gAiAKayEPA0AgDSALQQF0aiEKIA8gAyALbGohCUEAIQID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BiAJbGogAxAyGgsgAEGQpQUpAgA3AgAgAEEIaiEAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyAKLAAbQQBIBEAgCigCGBogCigCEBAqCyAKQSBqJAALPwEBfyMAQSBrIgQkACAEQQxqIAAoAkQgASACIAMQ4AMgBCwAH0EASARAIAQoAhwaIAQoAhQQKgsgBEEgaiQACwwAIABBgoaAIDYAAAsfACABBEAgACABKAIAEMoBIAAgASgCBBDKASABECoLC18BAn8CfyAALQALQQd2BEAgACgCAAwBCyAACwJ/IAAtAAtBB3YEQCAAKAIEDAELIAAtAAtB/wBxC0ECdGohASMAQRBrIgAkACAAIAE2AgwgACgCDCECIABBEGokACACC6wBAQF/AkAgA0GAEHFFDQAgA0HKAHEiBEEIRg0AIARBwABGDQAgAkUNACAAQSs6AAAgAEEBaiEACyADQYAEcQRAIABBIzoAACAAQQFqIQALA0AgAS0AACIEBEAgACAEOgAAIABBAWohACABQQFqIQEMAQsLIAACf0HvACADQcoAcSIBQcAARg0AGkHYAEH4ACADQYCAAXEbIAFBCEYNABpB5ABB9QAgAhsLOgAAC1wBAn8CfyAALQALQQd2BEAgACgCAAwBCyAACwJ/IAAtAAtBB3YEQCAAKAIEDAELIAAtAAtB/wBxC2ohASMAQRBrIgAkACAAIAE2AgwgACgCDCECIABBEGokACACC5oBAgF9An8gALwiAkEXdkH/AXEiA0GVAU0EQCADQf0ATQR9IABDAAAAAJQFAn0gAIsiAEMAAABLkkMAAADLkiAAkyIBQwAAAD9eBEAgACABkkMAAIC/kgwBCyAAIAGSIgAgAUMAAAC/X0UNABogAEMAAIA/kgsiAIwgACACQQBIGwshAAsgAItDAAAAT10EQCAAqA8LQYCAgIB4C+kBAQN/IABFBEBB2KMFKAIAIgAEQCAAEM8BIQELQcCiBSgCACIABEAgABDPASABciEBC0HMrgYoAgAiAARAA0AgACgCTBogACgCFCAAKAIcRwRAIAAQzwEgAXIhAQsgACgCOCIADQALCyABDwsgACgCTEEASCECAkACQCAAKAIUIAAoAhxGDQAgAEEAQQAgACgCJBEEABogACgCFA0AQX8hAQwBCyAAKAIEIgEgACgCCCIDRwRAIAAgASADa6xBASAAKAIoERcAGgtBACEBIABBADYCHCAAQgA3AxAgAEIANwIEIAINAAsgAQujAwAgAEIANwIEIABBADoAmAEgACABNgIUIABCADcDGCAAQgA3AjQgAEIANwJEIABCADcDUCAAQgA3ApwBIABBADYCDCAAQa4gNgIQIABCADcDICAAQgA3AyggAEEAOwEwIABCADcBOiAAQQA6AEwgAEEAOgBYIABBADYCzAEgAEIANwLEASAAQgA3ArwBIABCADcCtAEgAEIANwKsASAAQgA3AqQBIABBlIQFNgIAIABBADYCoAIgAEIANwOYAiAAQQE6ANABIABCADcC1AEgAEIANwDZASAAQgA3A+gBIABCADcD8AEgAEIANwP4ASAAQgA3A4ACIABCADcDiAIgAEEAOgCQAiAAQQE7AaQCIABCADcDqAIgAEIANwOwAiAAQgA3A7gCIABBADYC8AIgAEIANwPoAiAAQoCAgICAgID4PzcDwAIgAEIANwOQASAAQgA3A4gBIABCADcDgAEgAEIANwN4IABCADcDcCAAQgA3A2ggAEIANwNgIABBADYC4AIgAEIANwPYAiAAQgA3A9ACIABCADcDyAIgACACNgIkIAALKgEBfyAAKAJsIgIgASAAKAJwIgEgAmtBAnUQywMiAiABIAIbIAAoAnBHC40BAgJ/AX4gASkCACEFIAFCADcCACAAKAIEIQMgACAFNwIAAkAgA0UNACADIAMoAgQiBEEBazYCBCAEDQAgAyADKAIAKAIIEQAAIAMQKwsgAEEBOgAIIAAgAjYCGAJAIAEoAgQiAEUNACAAIAAoAgQiAUEBazYCBCABDQAgACAAKAIAKAIIEQAAIAAQKwsLTAEBfiABKQIAIQIgAUIANwIAIAAoAgQhASAAIAI3AgACQCABRQ0AIAEgASgCBCIAQQFrNgIEIAANACABIAEoAgAoAggRAAAgARArCwsEAEEEC8YKAQR/IwBBoAFrIgQkAAJAAkACQCABKAIwIAIQ5wEiBUHk0sm7BkYNACAFQezsvcsGRg0AIAVB7sqRywZHDQELIAEoAjAiBSgCVCEGIAUoAlgiBQRAIAUgBSgCBEEBajYCBAsCQCAGRQRAIARBOBAsIgE2AgQgBEK2gICAgIeAgIB/NwIIIAFB5iEpAAA3AAAgAUEAOgA2IAFBlCIpAAA3AC4gAUGOIikAADcAKCABQYYiKQAANwAgIAFB/iEpAAA3ABggAUH2ISkAADcAECABQe4hKQAANwAIIABBAkH1ACAEQQRqEC8aIAQsAA9BAE4NASAEKAIMGiAEKAIEECoMAQsgBEEEaiAGIAJB59qlowYQugECQAJAIAQoAgQiBiAEKAIIRwRAIAIgBigCACIGRw0BCyAEQTgQLCIBNgKUASAEQraAgICAh4CAgH83ApgBIAFB5iEpAAA3AAAgAUEAOgA2IAFBlCIpAAA3AC4gAUGOIikAADcAKCABQYYiKQAANwAgIAFB/iEpAAA3ABggAUH2ISkAADcAECABQe4hKQAANwAIIABBAkH1ACAEQZQBahAvGiAELACfAUEATg0BIAQoApwBGiAEKAKUARAqDAELIAAgASAGIAMQ1QELIAQoAgQiAEUNACAEIAA2AgggBCgCDBogABAqCyAFRQ0BIAUgBSgCBCIAQQFrNgIEIAANASAFIAUoAgAoAggRAAAgBRArDAELAkACQAJAAkACQCABKAIUIgVFDQAgAUEUaiIGIQEDQCABIAUgBSgCECACSSIHGyEBIAUgB0ECdGooAgAiBQ0ACyABIAZGDQAgASgCECACSw0AIAMgAjYCACAAQZClBSkCADcCACAAQQhqIQBBo6UFLAAAQQBIDQEgAEGYpQUpAgA3AgAgAEGgpQUoAgA2AggMBQsgBEGg0wM2AgwgBEG00wM2AkQgBEHE0wMoAgAiATYCBCAEQQRqIgMgAUEMaygCAGpByNMDKAIANgIAIARBADYCCCADIAQoAgRBDGsoAgBqIgEgBEEQaiIFED4gAUKAgICAcDcCSCAEQczTAygCACIBNgIMIARBDGoiBiABQQxrKAIAakHQ0wMoAgA2AgAgBEHA0wMoAgAiATYCBCADIAFBDGsoAgBqQdTTAygCADYCACAEQbTTAzYCRCAEQYzTAzYCBCAEQaDTAzYCDCAFED8iA0HwywM2AgAgBEIANwI4IARCADcCMCAEQRg2AkAgBkHRqwFBCxAtIAIQPEH0xAFBIxAtGgJ/IAQoAkAiAUEQcQRAIAQoAjwiBSAEKAIoIgFJBEAgBCABNgI8IAEhBQsgBEEkagwBCyABQQhxRQRAQQAhBSAEQQA6AJ8BIARBlAFqIQEMBQsgBCgCICEFIARBGGoLIQEgBSABKAIAIgJrIgVB+P///wdPDQEgBUELTwRAIAVBB3JBAWoiBhAsIQEgBCAGQYCAgIB4cjYCnAEgBCABNgKUASAEIAU2ApgBDAMLIAQgBToAnwEgBEGUAWohASAFDQJBACEFDAMLIABBmKUFKAIAQZylBSgCABAuDAMLEDgACyABIAIgBRA3GgsgASAFakEAOgAAIABBAkHQDyAEQZQBahAvGiAELACfAUEASARAIAQoApwBGiAEKAKUARAqCyAEQbzTAygCACIANgIEIABBDGsoAgAgBEEEampB3NMDKAIANgIAIARB4NMDKAIANgIMIANB8MsDNgIAIAQsADtBAEgEQCAEKAI4GiAEKAIwECoLIAMQPRogBEHEAGoQOxoLIARBoAFqJAALQgEDfyMAQRBrIgEkACABIAA2AgwgASgCDCECIwBBEGsiACQAIAAgAjYCDCAAKAIMIQMgAEEQaiQAIAFBEGokACADC7UCAQN/IAMgACgCCCIEIAAoAgAiBWtBAnVNBEAgAyAAKAIEIgQgBWsiBkECdUsEQCAEIAVHBEAgBSABIAYQNxogACgCBCEECyACIAEgBmoiAWshAyABIAJHBEAgBCABIAMQNxoLIAAgAyAEajYCBA8LIAIgAWshAyABIAJHBEAgBSABIAMQNxoLIAAgAyAFajYCBA8LIAUEQCAAIAU2AgQgBRAqIABBADYCCCAAQgA3AgBBACEECwJAIANBgICAgARPDQBB/////wMgBEEBdSIFIAMgAyAFSRsgBEH8////B08bIgNBgICAgARPDQAgACADQQJ0IgQQLCIDNgIEIAAgAzYCACAAIAMgBGo2AgggAiABayEEIAEgAkcEQCADIAEgBBAyGgsgACADIARqNgIEDwsQNgALOAAgAC0AC0EHdgRAIAAgATYCBA8LIAAgAC0AC0GAAXEgAUH/AHFyOgALIAAgAC0AC0H/AHE6AAsLdgEBfyMAQRBrIgIkACACIAA2AgwCQCAAIAFGDQADQCACIAFBAWsiATYCCCAAIAFPDQEgAigCDCIALQAAIQEgACACKAIIIgAtAAA6AAAgACABOgAAIAIgAigCDEEBaiIANgIMIAIoAgghAQwACwALIAJBEGokAAsoACAAQRh0IABBgP4DcUEIdHIgAEEI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BEAgAygCSCICIAMoAjQiAUkEQCADIAE2AkggASECCyADQTBqDAELIAFBCHFFBEBBACECIABBADoACwwCCyADKAIsIQIgA0EkagshAQJAIAIgASgCACIEayICQfj///8HSQRAIAJBC08EQCACQQdyQQFqIgUQLCEBIAAgBUGAgICAeHI2AgggACABNgIAIAAgAjYCBCABIQAMAgsgACACOgALIAINAUEAIQIMAgsQOAALIAAgBCACEDcaCyAAIAJqQQA6AAAgA0Hs1QMoAgAiADYCGCAAQQxrKAIAIANBGGpqQfjVAygCADYCACAGQfDLAzYCACADLABHQQBIBEAgAygCRBogAygCPBAqCyAGED0aIANB0ABqEDsaIANBoAFqJAALwgMBCH8CQAJAIAAoAgQiAiAAKAIAIgRrQQxtIgdBAWoiA0HWqtWqAUkEQEHVqtWqASAAKAIIIARrQQxtIgVBAXQiBiADIAMgBkkbIAVBqtWq1QBPGyIFBEAgBUHWqtWqAU8NAiAFQQxsECwhCAsgCCAHQQxsaiIDQQA2AgggA0IANwIAIAEoAgQiBiABKAIAIgdHBEAgBiAHayIBQQBIDQMgAyABECwiBjYCACADIAEgBmoiCTYCCCAGIAcgARAyGiADIAk2AgQLIAggBUEMbGohByADQQxqIQgCQCACIARGBEAgAyEBDAELA0AgA0EEayIGQQA2AgAgA0EMayIBIAJBDGsiBSgCADYCACADQQhrIAJBCGsoAgA2AgAgBiACQQRrIgIoAgA2AgAgAkEANgIAIAVCADcCACABIQMgBSICIARHDQALIAAoAggaIAAoAgQhAiAAKAIAIQQLIAAgBzYCCCAAIAg2AgQgACABNgIAIAIgBEcEQANAIAJBDGsiACgCACIBBEAgAkEIayABNgIAIAJBBGsoAgAaIAEQKgsgACICIARHDQALCyAEBEAgBBAqCyAIDwsQNgALEE8ACxA2AAvOAQEBfyABKAL0AiECAkAgASgC+AIiAUUEQCAAQQA2AgQgACACNgIADAELIAEgASgCBEEBajYCBCAAIAE2AgQgACACNgIAIAEgASgCBEEBajYCBAsgAEGQpQUpAgA3AgggAEEQaiEAAkBBo6UFLAAAQQBOBEAgAEGYpQUpAgA3AgAgAEGgpQUoAgA2AggMAQsgAEGYpQUoAgBBnKUF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ARogBigCoAEQKgsgBigCsAEiAEUNACAAIAAoAgQiAUEBazYCBCABDQAgACAAKAIAKAIIEQAAIAAQKwsgBiwAzwFBAEgEQCAGKALMARogBigCxAEQKgsCQCAGKAK4ASIARQ0AIAAgACgCBCIBQQFrNgIEIAENACAAIAAoAgAoAggRAAAgABArCwJAIAYoAvwBIgBFDQAgACAAKAIEIgFBAWs2AgQgAQ0AIAAgACgCACgCCBEAACAAECsLIAZBgAJqJAAPCxA2AAtSAQF/IAEEQCAAIAEoAgAQhAIgACABKAIEEIQCAkAgASgCGCIARQ0AIAAgACgCBCICQQFrNgIEIAINACAAIAAoAgAoAggRAAAgABArCyABECoLC8wDAgJ+An8gAEEANgIYIABCADcDECAAIAI2AgggACACNgIEIAAgATYCAEFAIQYCQCACRQ0AIAAgAUEBajYCACABMQAAIQMgACACQQFrIgU2AgggACADQjiGIgM3AxAgBUUNACAAIAFBAmo2AgAgATEAASEEIAAgAkECayIFNgIIIAAgBEIwhiADhCIDNwMQIAVFDQAgACABQQNqNgIAIAExAAIhBCAAIAJBA2siBTYCCCAAIARCKIYgA4QiAzcDECAFRQ0AIAAgAUEEajYCACABMQADIQQgACACQQRrIgU2AgggACAEQiCGIAOEIgM3AxAgBUUNACAAIAFBBWo2AgAgATEABCEEIAAgAkEFayIFNgIIIAAgBEIYhiADhCIDNwMQIAVFDQAgACABQQZqNgIAIAExAAUhBCAAIAJBBmsiBTYCCCAAIARCEIYgA4QiAzcDECAFRQ0AIAAgAUEHajYCACABMQAGIQQgACACQQdrIgU2AgggACAEQgiGIAOEIgM3AxAgBUUNACAAIAFBCGo2AgAgATEAByEEIAAgAkEIazYCCCAAIAMgBIQ3AxBBSCEGCyAAIAZBByACIAJBB08bQQN0akFAazYCGCAAC/wBAQN/IwBBEGsiAiQAIAIgAToADwJAAkACfyAALQALIgNBB3YiBEUEQEEKIQEgA0H/AHEMAQsgACgCCEH/////B3FBAWshASAAKAIECyIDIAFGBEAgACABQQEgASABEKkDAn8gAC0AC0EHdgRAIAAoAgAMAQtBAAsaDAELAn8gAC0AC0EHdgRAIAAoAgAMAQtBAAsaIAQNACAA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IgogCSgCRCIBSQRAIAkgATYCWCABIQoLIAlBQGsMAQsgAUEIcUUEQEEAIQogCUEAOgAfIAlBFGohAgwMCyAJKAI8IQogCUE0agshASAKIAEoAgAiAWsiCkH4////B08NECAKQQtPBEAgCkEHckEBaiIEECwhAiAJIARBgICAgHhyNgIcIAkgAjYCFCAJIAo2AhgMCgsgCSAKOgAfIAlBFGohAiAKDQlBACEKDAoLIAMoAgAiASAKKQMIIAIpAwggEnx8IgYgBiARfCABKAIAKAIYERYAIRcgAygCACEBIBdQBEAgACABKQIENwIAIABBCGohACABLAAXQQBOBEAgACABKQIMNwIAIAAgASgCFDYCCAwQCyAAIAEoAgwgASgCEBAuDA8LIAEgBiABKAIAKAIUERAARQRAIABBAkEAIAlBIGpB1jMQgAEiABAvGiAALAALQQBODQ8gACgCCBogACgCABAqDA8LAkAgCyARpyINaiIBIAUoAgQgBSgCACIOayIMSwRAIAUgASAMaxBlDAELIAEgDEkEQCAFIAEgDmo2AgQLCyADKAIAIgEgBSgCACALaiANIAEoAgAoAhARBAANAiAAQQJBACAJQSBqQYzUABCAASIAEC8aIAAsAAtBAE4NDiAAKAIIGiAAKAIAECoMDgsgBCgCACIBRQRAIAlBOBAsIgE2AiAgCUK2gICAgIeAgIB/NwIkIAFBpdQAKQAANwAAIAFBADoANiABQdPUACkAADcALiABQc3UACkAADcAKCABQcXUACkAADcAICABQb3UACkAADcAGCABQbXUACkAADcAECABQa3UACkAADcACCAAQQJB5wAgCUEgahAvGiAJLAArQQBODQ4gCSgCKBogCSgCIBAqDA4LIAopAwggAikDCHwhEiACKQMQIREjAEGgAWsiCyQAIAUoAgQgBSgCAGshDAJAAkACQAJAAkAgCCkDKCITUA0AIBMgDK0iFX0gEVoNACALQaDTAzYCGCALQbTTAzYCUCALQcTTAygCACIMNgIQIAtBEGoiASAMQQxrKAIAakHI0wMoAgA2AgAgC0EANgIUIAEgCygCEEEMaygCAGoiDCALQRxqIg0QPiAMQoCAgIBwNwJIIAtBzNMDKAIAIgw2AhggC0EYaiIOIAxBDGsoAgBqQdDTAygCADYCACALQcDTAygCACIMNgIQ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EC4LIAMsABtBAEgEQCADKAIYGiADKAIQECoLIAYNAQsgBCAFNgIAIARBkKUFKQIANwIEIARBDGohAUGjpQUsAABBAE4EQCABQZilBSkCADcCACABQaClBSgCADYCCAwBCyABQZilBSgCAEGcpQUoAgAQLgsgA0EgaiQAAkAgAigCEARAIABBADYCCCAAQgA3AgAgACACKQIQNwIMIABBFGohACACLAAjQQBOBEAgACACKQIYNwIAIAAgAigCIDYCCAwCCyAAIAIoAhggAigCHBAuDAELIAJBJGogAigCKCACKAIMIgEoAgAiAyABKAIEIgEgASADaxDFASAAQQA2AgggAEIANwIAIAIoAigiASACKAIkIgRHBEAgASAEayIBQQBIDQQgACABECwiAzYCBCAAIAM2AgAgACABIANqIgU2AgggAyAEIAEQMhogACAFNgIECyAAQZClBSkCADcCDCAAQRRqIQBBo6UFLAAAQQBOBEAgAEGYpQUpAgA3AgAgAEGgpQUoAgA2AggMAQsgAEGYpQUoAgBBnKUFKAIAEC4LIAIsACNBAEgEQCACKAIgGiACKAIYECoLIAIoAiQiAEUNACACIAA2AiggAigCLBogABAqCyACLABPQQBIBEAgAigCTBogAigCRBAqCyACKAIwIgAEQCACIAA2AjQgAigCOBogABAqCyACQdAAaiQADwsQNgALEDYAC8kCAgF+An8gAigCBCEFAkAgASgCBCIGIAAoAgRMBEAgBSAGTA0BIAEpAgAhBCABIAIpAgA3AgAgAiAENwIAIAEoAgQgACgCBEwEQCAEQiCIpyEFDAILIAApAgAhBCAAIAEpAgA3AgAgASAENwIAIAIoAgQhBQwBCyAAKQIAIQQgBSAGSgRAIAAgAikCADcCACACIAQ3AgAgBEIgiKchBQwBCyAAIAEpAgA3AgAgASAENwIAIAIoAgQiBSAEQiCIpyIGTA0AIAEgAikCADcCACACIAQ3AgAgBiEFCwJAIAMoAgQgBUwNACACKQIAIQQgAiADKQIANwIAIAMgBDcCACACKAIEIAEoAgRMDQAgASkCACEEIAEgAikCADcCACACIAQ3AgAgASgCBCAAKAIETA0AIAApAgAhBCAAIAEpAgA3AgAgASAENwIACwv2BQEFfyMAQaABayIDJAAgA0Hk1QM2AkQgA0Hw1QMoAgAiBjYCDCADQQxqIgQgBkEMaygCAGpB9NUDKAIANgIAIAQgAygCDEEMaygCAGoiBiADQRBqIgUQPiAGQoCAgIBwNwJIIANB5NUDNgJEIANB0NUDNgIMIAUQPyIGQfDLAzYCACADQgA3AjggA0IANwIwIANBEDYCQCADQZQBaiIFIAIQNSAEIAMoApQBIAUgAywAnwEiBEEASCIFGyADKAKYASAEIAUbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBDGpBvLEBQQUQLSEHIANBlAFqIgUgARD+ASAHIAMoApQBIAUgAywAnwEiBEEASCIFGyADKAKYASAEIAUbEC1Byo4CQQcQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgA0GUAWoiBCACEDUgA0EMaiADKAKUASAEIAMsAJ8BIgJBAEgiBBsgAygCmAEgAiAEGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyADQQxqQfW8AUEGEC0gASkDCBCFAUG9vAFBERAtIAEoAiAQPEHOkAJBAhAtGgJAAn8gAygCQCIBQRBxBEAgAygCPCIBIAMoAigiAkkEQCADIAI2AjwgAiEBCyADQSRqDAELIAFBCHFFBEBBACEBIABBADoACwwCCyADKAIgIQEgA0EYagshAgJAIAEgAigCACIEayIBQfj///8HSQRAIAFBC08EQCABQQdyQQFqIgUQLCECIAAgBUGAgICAeHI2AgggACACNgIAIAAgATYCBCACIQAMAgsgACABOgALIAENAUEAIQEMAgsQOAALIAAgBCABEDcaCyAAIAFqQQA6AAAgA0Hs1QMoAgAiADYCDCAAQQxrKAIAIANBDGpqQfjVAygCADYCACAGQfDLAzYCACADLAA7QQBIBEAgAygCOBogAygCMBAqCyAGED0aIANBxABqEDsaIANBoAFqJAAL1wsCBX8BfiMAQaABayIDJAAgAigCACIEIAQoAgAoAggREgAhCAJAIAIoAgAiBCAIQgh8IAQoAgAoAgwREAAEQCADQQA6ABAgA0EAOgAbIABBAkHkACADQRBqEC8aIAMsABtBAE4NASADKAIYGiADKAIQECoMAQsgASACEEmtNwMIIAIQSSEEIAFBCDYCICABIAQ2AhACQAJAAkAgASkDCEIBUQR/IAIoAgAiBCAEKAIAKAIIERIAIQggAigCACIEIAhCCHwgBCgCACgCDBEQAARAIANBADoAECADQQA6ABsgAEECQeQAIANBEGoQLxogAywAG0EATg0FIAMoAhgaIAMoAhAQKgwFCyABIAIQSa1CIIYgAhBJrYQ3AwggASABKAIgQQhqNgIgIANBoNMDNgIYIANBtNMDNgJQIANBxNMDKAIAIgQ2AhAgA0EQaiIFIARBDGsoAgBqQcjTAygCADYCACADQQA2AhQgBSADKAIQQQxrKAIAaiIEIANBHGoiBhA+IARCgICAgHA3AkggA0HM0wMoAgAiBDYCGCADQRhqIgcgBEEMaygCAGpB0NMDKAIANgIAIANBwNMDKAIAIgQ2AhAgBSAEQQxrKAIAakHU0wMoAgA2AgAgA0G00wM2AlAgA0GM0wM2AhAgA0Gg0wM2AhggBhA/IgRB8MsDNgIAIANCADcCRCADQgA3AjwgA0EYNgJMIAdBxq0BQQkQLSABKQMIEIUBQdOUAUEYEC0aIANB0ABqIQUgASkDCEKAgICAgICAgBBaBEACfyADKAJMIgFBEHEEQCADKAJIIgIgAygCNCIBSQRAIAMgATYCSCABIQILIANBMGoMAQsgAUEIcUUEQEEAIQIgA0EAOgAPIANBBGohAQwGCyADKAIsIQIgA0EkagshASACIAEoAgAiBmsiAkH4////B08NAiACQQtPBEAgAkEHckEBaiIHECwhASADIAdBgICAgHhyNgIMIAMgATYCBCADIAI2AggMBAsgAyACOgAPIANBBGohASACDQNBACECDAQLIANBvNMDKAIAIgY2AhAgBkEMaygCACADQRBqakHc0wMoAgA2AgAgA0Hg0wMoAgA2AhggBEHwywM2AgAgAywAR0EASARAIAMoAkQaIAMoAjwQKgsgBBA9GiAFEDsaIAEoAhAFIAQLQeTS1asHRgRAIAIoAgAiBCAEKAIAKAIIERIAIQggAigCACIEIAhCEHwgBCgCACgCDBEQAARAIANBADoAECADQQA6ABsgAEECQeQAIANBEGoQLxogAywAG0EATg0FIAMoAhgaIAMoAhAQKgwFCwJAIAJBEBCLAUUNACABQRRqIQYCQCABKAIYIAEoAhQiBWsiBEEPTQRAIAZBECAEaxBlDAELIARBEEYNACABIAVBEGo2AhgLIAIoAgAhBSAC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IGsiBSQAIABBADYCCCAAQgA3AgACQCABKAIgIgQgASgCHCIBRwRAIAQgAWsiA0EASA0BIAAgAxAsIgI2AgQgACACNgIAIAAgAiADajYCCANAIAIgASgCADYCACACIAEoAgQiAzYCBCADBEAgAyADKAIEQQFqNgIECyACQQhqIQIgAUEIaiIBIARHDQALIAAgAjYCBAsgBUEgaiQADwsQNgALSQECfyAAKAIEIgVBCHUhBiAAKAIAIgAgASAFQQFxBH8gBiACKAIAaigCAAUgBgsgAmogA0ECIAVBAnEbIAQgACgCACgCGBEHAAuDAwEFfyMAQRBrIggkACACIAFBf3NB9////wdqTQRAAn8gAC0AC0EHdgRAIAAoAgAMAQsgAAshCiAIQQRqIgkgAUHz////A0kEfyAIIAFBAXQ2AgwgCCABIAJqNgIEIwBBEGsiAiQAIAkoAgAgCEEMaiILKAIASSEMIAJBEGokACALIAkgDBsoAgAiAkELTwR/IAJBCGpBeHEiAiACQQFrIgIgAkELRhsFQQoLQQFqBUH3////BwsQ8gEgCCgCBCECIAgoAggaIAQEQCAKIAQgAhCxAQsgBgRAIAcgBiACIARqELEBCyADIAQgBWoiCWshByADIAlHBEAgBCAKaiAFaiAHIAIgBGogBmoQsQELIAFBCkcEQCAKQQEQvwELIAAgAjYCACAAIAAoAghBgICAgHhxIAgoAghB/////wdxcjYCCCAAIAAoAghBgICAgHhyNgIIIAAgBCAGaiAHaiIANgIEIAhBADoADCAAIAJqIAgtAAw6AAAgCEEQaiQADwsQigEACwgAQf////8HCwUAQf8AC3YBAX8jAEEQayICJAAgAiAANgIMAkAgACABRg0AA0AgAiABQQRrIgE2AgggACABTw0BIAIoAgwiACgCACEBIAAgAigCCCIAKAIANgIAIAAgATYCACACIAIoAgxBBGoiADYCDCACKAIIIQEMAAsACyACQRBqJAAL/QQBCH8jAEEQayILJAAgBkGc0AYQQyEJIAtBBGoiByAGQeTQBhBDIgggCCgCACgCFBECAAJAAn8gBy0AC0EHdgRAIAcoAgQMAQsgBy0AC0H/AHELRQRAIAkgACACIAMgCSgCACgCMBEKABogBSADIAIgAGtBAnRqIgY2AgAMAQsgBSADNgIAAkACQCAAIgotAAAiBkEraw4DAAEAAQsgCSAGwCAJKAIAKAIsEQUAIQcgBSAFKAIAIgZBBGo2AgAgBiAHNgIAIABBAWohCgsCQCACIAprQQJIDQAgCi0AAEEwRw0AIAotAAFBIHJB+ABHDQAgCUEwIAkoAgAoAiwRBQAhByAFIAUoAgAiBkEEajYCACAGIAc2AgAgCSAKLAABIAkoAgAoAiwRBQAhByAFIAUoAgAiBkEEajYCACAGIAc2AgAgCkECaiEKCyAKIAIQ2QEgCCAIKAIAKAIQEQEAIQ5BACEHIAohBgN/IAIgBk0EfyADIAogAGtBAnRqIAUoAgAQxQIgBSgCAAUCQAJ/IAtBBGoiCC0AC0EHdgRAIAgoAgAMAQsgCAsgB2otAABFDQAgDAJ/IAgtAAtBB3YEQCAIKAIADAELIAgLIAdqLAAARw0AIAUgBSgCACINQQRqNgIAIA0gDjYCACAHIAcCfyAILQALQQd2BEAgCCgCBAwBCyAILQALQf8AcQtBAWtJaiEHQQAhDAsgCSAGLAAAIAkoAgAoAiwRBQAhDSAFIAUoAgAiCEEEajYCACAIIA02AgAgBkEBaiEGIAxBAWohDAwBCwshBgsgBCAGIAMgASAAa0ECdGogASACRhs2AgAgC0EEahBGGiALQRBqJAAL0AEBAn8gAkGAEHEEQCAAQSs6AAAgAEEBaiEACyACQYAIcQRAIABBIzoAACAAQQFqIQALIAJBhAJxIgNBhAJHBEAgAEGu1AA7AAAgAEECaiEACyACQYCAAXEhAgNAIAEtAAAiBARAIAAgBDoAACAAQQFqIQAgAUEBaiEBDAELCyAAAn8CQCADQYACRwRAIANBBEcNAUHGAEHmACACGwwCC0HFAEHlACACGwwBC0HBAEHhACACGyADQYQCRg0AGkHHAEHnACACGws6AAAgA0GEAkcL9AQBCH8jAEEQayILJAAgBkGk0AYQQyEJIAtBBGoiByAGQdzQBhBDIgggCCgCACgCFBECAAJAAn8gBy0AC0EHdgRAIAcoAgQMAQsgBy0AC0H/AHELRQRAIAkgACACIAMgCSgCACgCIBEKABogBSADIAIgAGtqIgY2AgAMAQsgBSADNgIAAkACQCAAIgotAAAiBkEraw4DAAEAAQsgCSAGwCAJKAIAKAIcEQUAIQcgBSAFKAIAIgZBAWo2AgAgBiAHOgAAIABBAWohCgsCQCACIAprQQJIDQAgCi0AAEEwRw0AIAotAAFBIHJB+ABHDQAgCUEwIAkoAgAoAhwRBQAhByAFIAUoAgAiBkEBajYCACAGIAc6AAAgCSAKLAABIAkoAgAoAhwRBQAhByAFIAUoAgAiBkEBajYCACAGIAc6AAAgCkECaiEKCyAKIAIQ2QEgCCAIKAIAKAIQEQEAIQ5BACEHIAohBgN/IAIgBk0EfyADIAogAGtqIAUoAgAQ2QEgBSgCAAUCQAJ/IAtBBGoiCC0AC0EHdgRAIAgoAgAMAQsgCAsgB2otAABFDQAgDAJ/IAgtAAtBB3YEQCAIKAIADAELIAgLIAdqLAAARw0AIAUgBSgCACINQQFqNgIAIA0gDjoAACAHIAcCfyAILQALQQd2BEAgCCgCBAwBCyAILQALQf8AcQtBAWtJaiEHQQAhDAsgCSAGLAAAIAkoAgAoAhwRBQAhDSAFIAUoAgAiCEEBajYCACAIIA06AAAgBkEBaiEGIAxBAWohDAwBCwshBgsgBCAGIAMgASAAa2ogASACRhs2AgAgC0EEahBGGiALQRBqJAAL4AUBC38jAEGAAWsiCiQAIAogATYCfCAKQYULNgIQIApBCGpBACAKQRBqIggQayELAkACQAJAIAMgAmtBDG0iCUHlAE8EQCAJEFUiCEUNASALKAIAIQEgCyAINgIAIAEEQCABIAsoAgQRAAALCyAIIQcgAiEBA0AgASADRgRAA0AgACAKQfwAaiIBEF1BASAJGwRAIAAgARBdBEAgBSAFKAIAQQJyNgIACwNAIAIgA0YNBiAILQAAQQJGDQcgCEEBaiEIIAJBDGohAgwACwALAn8gACgCACIHKAIMIgEgBygCEEYEQCAHIAcoAgAoAiQRAQAMAQsgASgCAAshDiAGRQRAIAQgDiAEKAIAKAIcEQUAIQ4LIA9BAWohDUEAIRAgCCEHIAIhAQNAIAEgA0YEQCANIQ8gEEUNAiAAEHYaIAghByACIQEgCSAMakECSQ0CA0AgASADRgRADAQFAkAgBy0AAEECRw0AAn8gAS0AC0EHdgRAIAEoAgQMAQsgAS0AC0H/AHELIA9GDQAgB0EAOgAAIAxBAWshDAsgB0EBaiEHIAFBDGohAQwBCwALAAUCQCAHLQAAQQFHDQACfyABLQALQQd2BEAgASgCAAwBCyABCyAPQQJ0aigCACERAkAgBgR/IBEFIAQgESAEKAIAKAIcEQUACyAORgRAQQEhEAJ/IAEtAAtBB3YEQCABKAIEDAELIAEtAAtB/wBxCyANRw0CIAdBAjoAACAMQQFqIQwMAQsgB0EAOgAACyAJQQFrIQkLIAdBAWohByABQQxqIQEMAQsACwALAAUgB0ECQQECfyABLQALQQd2BEAgASgCBAwBCyABLQALQf8AcQtFIg0bOgAAIAdBAWohByABQQxqIQEgDCANaiEMIAkgDWshCQwBCwALAAsQbAALIAUgBSgCAEEEcjYCAAsgCygCACEAIAtBADYCACAABEAgACALKAIEEQAACyAKQYABaiQAIAIL3gUBC38jAEGAAWsiCiQAIAogATYCfCAKQYULNgIQIApBCGpBACAKQRBqIggQayELAkACQAJAIAMgAmtBDG0iCUHlAE8EQCAJEFUiCEUNASALKAIAIQEgCyAINgIAIAEEQCABIAsoAgQRAAALCyAIIQcgAiEBA0AgASADRgRAA0AgACAKQfwAaiIBEF5BASAJGwRAIAAgARBeBEAgBSAFKAIAQQJyNgIACwNAIAIgA0YNBiAILQAAQQJGDQcgCEEBaiEIIAJBDGohAgwACwALAn8gACgCACIHKAIMIgEgBygCEEYEQCAHIAcoAgAoAiQRAQAMAQsgAS0AAAvAIQ4gBkUEQCAEIA4gBCgCACgCDBEFACEOCyAPQQFqIQ1BACEQIAghByACIQEDQCABIANGBEAgDSEPIBBFDQIgABB3GiAIIQcgAiEBIAkgDGpBAkkNAgNAIAEgA0YEQAwEBQJAIActAABBAkcNAAJ/IAEtAAtBB3YEQCABKAIEDAELIAEtAAtB/wBxCyAPRg0AIAdBADoAACAMQQFrIQwLIAdBAWohByABQQxqIQEMAQsACwAFAkAgBy0AAEEBRw0AAn8gAS0AC0EHdgRAIAEoAgAMAQsgAQsgD2osAAAhEQJAIAYEfyARBSAEIBEgBCgCACgCDBEFAAsgDkYEQEEBIRACfyABLQALQQd2BEAgASgCBAwBCyABLQALQf8AcQsgDUcNAiAHQQI6AAAgDEEBaiEMDAELIAdBADoAAAsgCUEBayEJCyAHQQFqIQcgAUEMaiEBDAELAAsACwAFIAdBAkEBAn8gAS0AC0EHdgRAIAEoAgQMAQsgAS0AC0H/AHELRSINGzoAACAHQQFqIQcgAUEMaiEBIAwgDWohDCAJIA1rIQkMAQsACwALEGwACyAFIAUoAgBBBHI2AgALIAsoAgAhACALQQA2AgAgAARAIAAgCygCBBEAAAsgCkGAAWokACACCxYAIAAgARA+IABBADYCSCAAQX82AkwLQQECfyMAQRBrIgEkAEF/IQICQCAAEJYCDQAgACABQQ9qQQEgACgCIBEEAEEBRw0AIAEtAA8hAgsgAUEQaiQAIAILNgEBfyMAQRBrIgMkACADIAE2AgwgAyACNgIIIAAgAygCDDYCACAAIAMoAgg2AgQgA0EQaiQACwsAIAEgAiAAENwBCwwAIABBDGoQOxogAAvWAQEFfyMAQRBrIgIkACACQQhqIAAQcxoCQCACLQAIRQ0AIAJBBGoiBCAAIAAoAgBBDGsoAgBqKAIcIgM2AgAgA0HszgZHBEAgAyADKAIEQQFqNgIECyAEQeTNBhBDIQMgBBBHIAIgACAAKAIAQQxrKAIAaigCGDYCACAAIAAoAgBBDGsoAgBqIgUQlAIhBiACIAMgAigCACAFIAYgASADKAIAKAIMEQwANgIEIAQoAgANACAAIAAoAgBBDGsoAgBqQQUQowELIAJBCGoQciACQRBqJAAgAAsMACAAQQRqEDsaIAALDAAgAEEIahA7GiAACwQAQX8LIAAgACgCTEEASARAIAAgASACENcFDwsgACABIAIQ1wULnAsBBn8gACABaiEFAkACQCAAKAIEIgJBAXENACACQQJxRQ0BIAAoAgAiAiABaiEBAkACQAJAIAAgAmsiAEG8uAYoAgBHBEAgACgCDCEDIAJB/wFNBEAgAyAAKAIIIgRHDQJBqLgGQai4BigCAEF+IAJBA3Z3cTYCAAwFCyAAKAIYIQYgACADRwRAIAAoAggiAiADNgIMIAMgAjYCCAwECyAAKAIUIgQEfyAAQRRqBSAAKAIQIgRFDQMgAEEQagshAgNAIAIhByAEIgNBFGohAiADKAIUIgQNACADQRBqIQIgAygCECIEDQALIAdBADYCAAwDCyAFKAIEIgJBA3FBA0cNA0GwuAYgATYCACAFIAJBfnE2AgQgACABQQFyNgIEIAUgATYCAA8LIAQgAzYCDCADIAQ2AggMAgtBACEDCyAGRQ0AAkAgACgCHCICQQJ0Qdi6BmoiBCgCACAARgRAIAQgAzYCACADDQFBrLgGQay4BigCAEF+IAJ3cTYCAAwCCyAGQRBBFCAGKAIQIABGG2ogAzYCACADRQ0BCyADIAY2AhggACgCECICBEAgAyACNgIQIAIgAzYCGAsgACgCFCICRQ0AIAMgAjYCFCACIAM2AhgLAkACQAJAAkAgBSgCBCICQQJxRQRAQcC4BigCACAFRgRAQcC4BiAANgIAQbS4BkG0uAYoAgAgAWoiATYCACAAIAFBAXI2AgQgAEG8uAYoAgBHDQZBsLgGQQA2AgBBvLgGQQA2AgAPC0G8uAYoAgAgBUYEQEG8uAYgADYCAEGwuAZBsLgGKAIAIAFqIgE2AgAgACABQQFyNgIEIAAgAWogATYCAA8LIAJBeHEgAWohASAFKAIMIQMgAkH/AU0EQCAFKAIIIgQgA0YEQEGouAZBqLgGKAIAQX4gAkEDdndxNgIADAULIAQgAzYCDCADIAQ2AggMBAsgBSgCGCEGIAMgBUcEQCAFKAIIIgIgAzYCDCADIAI2AggMAwsgBSgCFCIEBH8gBUEUagUgBSgCECIERQ0CIAVBEGoLIQIDQCACIQcgBCIDQRRqIQIgAygCFCIEDQAgA0EQaiECIAMoAhAiBA0ACyAHQQA2AgAMAgsgBSACQX5xNgIEIAAgAUEBcjYCBCAAIAFqIAE2AgAMAwtBACEDCyAGRQ0AAkAgBSgCHCICQQJ0Qdi6BmoiBCgCACAFRgRAIAQgAzYCACADDQFBrLgGQay4BigCAEF+IAJ3cTYCAAwCCyAGQRBBFCAGKAIQIAVGG2ogAzYCACADRQ0BCyADIAY2AhggBSgCECICBEAgAyACNgIQIAIgAzYCGAsgBSgCFCICRQ0AIAMgAjYCFCACIAM2AhgLIAAgAUEBcjYCBCAAIAFqIAE2AgAgAEG8uAYoAgBHDQBBsLgGIAE2AgAPCyABQf8BTQRAIAFBeHFB0LgGaiECAn9BqLgGKAIAIgNBASABQQN2dCIBcUUEQEGouAYgASADcjYCACACDAELIAIoAggLIQEgAiAANgIIIAEgADYCDCAAIAI2AgwgACABNgIIDwtBHyEDIAFB////B00EQCABQSYgAUEIdmciAmt2QQFxIAJBAXRrQT5qIQMLIAAgAzYCHCAAQgA3AhAgA0ECdEHYugZqIQICQAJAQay4BigCACIEQQEgA3QiB3FFBEBBrLgGIAQgB3I2AgAgAiAANgIAIAAgAjYCGAwBCyABQRkgA0EBdmtBACADQR9HG3QhAyACKAIAIQIDQCACIgQoAgRBeHEgAUYNAiADQR12IQIgA0EBdCEDIAQgAkEEcWoiB0EQaigCACICDQALIAcgADYCECAAIAQ2AhgLIAAgADYCDCAAIAA2AggPCyAEKAIIIgEgADYCDCAEIAA2AgggAEEANgIYIAAgBDYCDCAAIAE2AggLC4UEAQV/AkACfyABQQhGBEAgAhBVDAELQRwhBCABQQRJDQEgAUEDcQ0BIAFBAnYiAyADQQFrcQ0BQTAhBEFAIAFrIAJJDQECf0EQIQMCQEEQQRAgASABQRBNGyIBIAFBEE0bIgQgBEEBa3FFBEAgBCEBDAELA0AgAyIBQQF0IQMgASAESQ0ACwsgAkFAIAFrTwRAQcCuBkEwNgIAQQAMAQtBAEEQIAJBC2pBeHEgAkELSRsiBCABakEMahBVIgNFDQAaIANBCGshAgJAIAFBAWsgA3FFBEAgAiEBDAELIANBBGsiBigCACIHQXhxIAEgA2pBAWtBACABa3FBCGsiAyABQQAgAyACa0EPTRtqIgEgAmsiA2shBSAHQQNxRQRAIAIoAgAhAiABIAU2AgQgASACIANqNgIADAELIAEgBSABKAIEQQFxckECcjYCBCABIAVqIgUgBSgCBEEBcjYCBCAGIAMgBigCAEEBcXJBAnI2AgAgAiADaiIFIAUoAgRBAXI2AgQgAiADENUCCwJAIAEoAgQiAkEDcUUNACACQXhxIgMgBEEQak0NACABIAQgAkEBcXJBAnI2AgQgASAEaiICIAMgBGsiBEEDcjYCBCABIANqIgMgAygCBEEBcjYCBCACIAQQ1QILIAFBCGoLCyIBRQRAQTAPCyAAIAE2AgBBACEECyAEC4IIAQt/IABFBEAgARBVDwsgAUFATwRAQcCuBkEwNgIAQQAPCwJ/QRAgAUELakF4cSABQQtJGyEFIABBCGsiBCgCBCIJQXhxIQgCQCAJQQNxRQRAIAVBgAJJDQEgBUEEaiAITQRAIAQhAiAIIAVrQYi8BigCAEEBdE0NAgtBAAwCCyAEIAhqIQYCQCAFIAhNBEAgCCAFayIDQRBJDQEgBCAJQQFxIAVyQQJyNgIEIAQgBWoiAiADQQNyNgIEIAYgBigCBEEBcjYCBCACIAMQ1QIMAQtBwLgGKAIAIAZGBEBBtLgGKAIAIAhqIgggBU0NAiAEIAlBAXEgBXJBAnI2AgQgBCAFaiIDIAggBWsiAkEBcjYCBEG0uAYgAjYCAEHAuAYgAzYCAAwBC0G8uAYoAgAgBkYEQEGwuAYoAgAgCGoiAyAFSQ0CAkAgAyAFayICQRBPBEAgBCAJQQFxIAVyQQJyNgIEIAQgBWoiCCACQQFyNgIEIAMgBGoiAyACNgIAIAMgAygCBEF+cTYCBAwBCyAEIAlBAXEgA3JBAnI2AgQgAyAEaiICIAIoAgRBAXI2AgRBACECQQAhCAtBvLgGIAg2AgBBsLgGIAI2AgAMAQsgBigCBCIDQQJxDQEgA0F4cSAIaiIKIAVJDQEgCiAFayEMIAYoAgwhBwJAIANB/wFNBEAgBigCCCICIAdGBEBBqLgGQai4BigCAEF+IANBA3Z3cTYCAAwCCyACIAc2AgwgByACNgIIDAELIAYoAhghCwJAIAYgB0cEQCAGKAIIIgIgBzYCDCAHIAI2AggMAQsCQCAGKAIUIgIEfyAGQRRqBSAGKAIQIgJFDQEgBkEQagshCANAIAghAyACIgdBFGohCCACKAIUIgINACAHQRBqIQggBygCECICDQALIANBADYCAAwBC0EAIQcLIAtFDQACQCAGKAIcIgNBAnRB2LoGaiICKAIAIAZGBEAgAiAHNgIAIAcNAUGsuAZBrLgGKAIAQX4gA3dxNgIADAILIAtBEEEUIAsoAhAgBkYbaiAHNgIAIAdFDQELIAcgCzYCGCAGKAIQIgIEQCAHIAI2AhAgAiAHNgIYCyAGKAIUIgJFDQAgByACNgIUIAIgBzYCGAsgDEEPTQRAIAQgCUEBcSAKckECcjYCBCAEIApqIgIgAigCBEEBcjYCBAwBCyAEIAlBAXEgBXJBAnI2AgQgBCAFaiIDIAxBA3I2AgQgBCAKaiICIAIoAgRBAXI2AgQgAyAMENUCCyAEIQILIAILIgIEQCACQQhqDwsgARBVIgRFBEBBAA8LIAQgAEF8QXggAEEEaygCACICQQNxGyACQXhxaiICIAEgASACSxsQMhogABAqIAQLEgAgAEUEQEEADwsgACABENkCC4kCAAJAIAAEfyABQf8ATQ0BAkBB6K8GKAIAKAIARQRAIAFBgH9xQYC/A0YNAwwBCyABQf8PTQRAIAAgAUE/cUGAAXI6AAEgACABQQZ2QcABcjoAAEECDwsgAUGAQHFBgMADRyABQYCwA09xRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMPCyABQYCABGtB//8/TQRAIAAgAUE/cUGAAXI6AAMgACABQRJ2QfABcjoAACAAIAFBBnZBP3FBgAFyOgACIAAgAUEMdkE/cUGAAXI6AAFBBA8LC0HArgZBGTYCAEF/BUEBCw8LIAAgAToAAEEBC40BAQN/IwBBoAFrIgQkACAEIAAgBEGeAWogARsiBTYClAEgBCABQQFrIgBBACAAIAFNGzYCmAEgBEEAQZABEDQiAEF/NgJMIABBkQo2AiQgAEF/NgJQIAAgAEGfAWo2AiwgACAAQZQBajYCVCAFQQA6AAAgACACIANBjwpBkAoQ2wIhBiAAQaABaiQAIAYLxgIBBX8jAEHQAWsiBSQAIAUgAjYCzAEgBUGgAWoiAkEAQSgQNBogBSAFKALMATYCyAECQEEAIAEgBUHIAWogBUHQAGogAiADIAQQ4QVBAEgEQEF/IQQMAQsgACgCTEEASCEJIAAgACgCACIIQV9xNgIAAn8CQAJAIAAoAjBFBEAgAEHQADYCMCAAQQA2AhwgAEIANwMQIAAoAiwhBiAAIAU2AiwMAQsgACgCEA0BC0F/IAAQzgMNARoLIAAgASAFQcgBaiAFQdAAaiAFQaABaiADIAQQ4QULIQIgBgRAIABBAEEAIAAoAiQRBAAaIABBADYCMCAAIAY2AiwgAEEANgIcIAAoAhQhASAAQgA3AxAgAkF/IAEbIQILIAAgACgCACIAIAhBIHFyNgIAQX8gAiAAQSBxGyEEIAkNAAsgBUHQAWokACAEC6MBAQR/IwBBEGsiBSQAIAUgAjYCDCMAQaABayIDJAAgA0EIaiIGQcDEA0GQARAyGiADIAA2AjQgAyAANgIcIANB/////wdBfiAAayIEIARB/////wdLGyIENgI4IAMgACAEaiIENgIkIAMgBDYCGCAGIAEgAhDeBSAAQX5HBEAgAygCHCIAIAAgAygCGEZrQQA6AAALIANBoAFqJAAgBUEQaiQACyoBAn8jAEEQayIEJAAgBCADNgIMIAAgASACIAMQ2gIhBSAEQRBqJAAgBQvbAQEIfyAAIABBPRDjBSIBRgRAQQAPCwJAIAAgASAAayIFai0AAA0AQcSuBigCACICRQ0AIAIoAgAiAUUNAANAAkACfyAAIQRBACAFIgZFDQAaIAAtAAAiAwR/AkADQCADIAEtAAAiB0cNASAHRQ0BIAZBAWsiBkUNASABQQFqIQEgBC0AASEDIARBAWohBCADDQALQQAhAwsgAwVBAAsgAS0AAGsLRQRAIAIoAgAgBWoiAS0AAEE9Rg0BCyACKAIEIQEgAkEEaiECIAENAQwCCwsgAUEBaiEICyAIC8MBAQN/AkAgASACKAIQIgMEfyADBSACEM4DDQEgAigCEAsgAigCFCIEa0sEQCACIAAgASACKAIkEQQADwsCQAJAIAIoAlBBAEgNACABRQ0AIAEhAwNAIAAgA2oiBUEBay0AAEEKRwRAIANBAWsiAw0BDAILCyACIAAgAyACKAIkEQQAIgQgA0kNAiABIANrIQEgAigCFCEEDAELIAAhBUEAIQMLIAQgBSABEDIaIAIgAigCFCABajYCFCABIANqIQQLIAQLzwsBA38jAEGQBWsiAyQAQYHBAEHgLSABGyEBIAAtAAAEQCADIAAsAAE2AoQFIAMgATYCgAUgAkGg7gEgA0GABWoQMCADIAAsAAI2AvQEIAMgATYC8AQgAkHy9wEgA0HwBGoQMEGvngEhBCADIAAoAgRBAWsiBUEDTQR/IAVBAnRB6JEDaigCAAVBr54BCzYC5AQgAyABNgLgBCACQcvGASADQeAEahAwIAMgATYC0AQgAkGetQEgA0HQBGoQMCADIAAsAAg2AsAEIAJBzfIAIANBwARqEDAgAkGdnQFBABAwIAMgACwACTYCsAQgAkHN8gAgA0GwBGoQMCACQZ2dAUEAEDAgAyAALAAKNgKgBCACQc3yACADQaAEahAwIAJBnZ0BQQAQMCADIAAsAAs2ApAEIAJBzfIAIANBkARqEDAgAkGdnQFBABAwIAMgACwADDYCgAQgAkHN8gAgA0GABGoQMCACQZ2dAUEAEDAgAyAALAANNgLwAyACQc3yACADQfADahAwIAJBnZ0BQQAQMCADIAAsAA42AuADIAJBzfIAIANB4ANqEDAgAkGdnQFBABAwIAMgACwADzYC0AMgAkHN8gAgA0HQA2oQMCACQZ2dAUEAEDAgAyAALAAQNgLAAyACQc3yACADQcADahAwIAJBnZ0BQQAQMCADIAAsABE2ArADIAJBzfIAIANBsANqEDAgAkGdnQFBABAwIAMgACwAEjYCoAMgAkHN8gAgA0GgA2oQMCACQZ2dAUEAEDAgAyAALAATNgKQAyACQc3yACADQZADahAwIAJBnZ0BQQAQMCADIAAsABQ2AoADIAJBzfIAIANBgANqEDAgAkGdnQFBABAwIAMgACwAFTYC8AIgAkHN8gAgA0HwAmoQMCACQZ2dAUEAEDAgAyAALAAWNgLgAiACQc3yACADQeACahAwIAJBnZ0BQQAQMCADIAAsABc2AtACIAJBzfIAIANB0AJqEDAgAkGdnQFBABAwIAMgACwAGDYCwAIgAkHN8gAgA0HAAmoQMCACQZ2dAUEAEDAgAyAALAAZNgKwAiACQc3yACADQbACahAwIAJBnZ0BQQAQMCADIAAsABo2AqACIAJBzfIAIANBoAJqEDAgAkGdnQFBABAwIAMgACwAGzYCkAIgAkHN8gAgA0GQAmoQMCACQZ2dAUEAEDAgAyAALAAcNgKAAiACQc3yACADQYACahAwIAJBnZ0BQQAQMCADIAAsAB02AvABIAJBzfIAIANB8AFqEDAgAkGdnQFBABAwIAMgACwAHjYC4AEgAkHN8gAgA0HgAWoQMCACQZ2dAUEAEDAgAyAALAAfNgLQASACQc3yACADQdABahAwIAJBnZ0BQQAQMCADIAAsACA2AsABIAJBzfIAIANBwAFqEDAgAkGdnQFBABAwIAMgACwAITYCsAEgAkHN8gAgA0GwAWoQMCACQZ2dAUEAEDAgAyAALAAiNgKgASACQc3yACADQaABahAwIAJBnZ0BQQAQMCADIAAsACM2ApABIAJBzfIAIANBkAFqEDAgAkGdnQFBABAwIAMgACwAJDYCgAEgAkHN8gAgA0GAAWoQMCACQZ2dAUEAEDAgAyAALAAlNgJwIAJBzfIAIANB8ABqEDAgAkGdnQFBABAwIAMgACwAJjYCYCACQc3yACADQeAAahAwIAJBnZ0BQQAQMCADIAAsACc2AlAgAkHN8gAgA0HQAGoQMCACQeSOAkEAEDAgAyAALAAoNgJEIAMgATYCQCACQcPbASADQUBrEDAgAyAALAApNgI0IAMgATYCMCACQejbASADQTBqEDAgAyAALAAqNgIkIAMgATYCICACQf/UASADQSBqEDAgAyAALAArNgIUIAMgATYCECACQdfUASADQRBqEDALIAAtACwEQCADIAAoAjAiADYCBCADIAE2AgAgAyAAskMAAPBBlbs5AwggAkHLjwIgAxAwCyADQZAFaiQAC7sTASd/IAAoApyRASIDKAKEASENIAMoAnwiFigC/IMBIRcCQAJAAkACQCACDQAgDS0ALUUNACAAKAIMIgJBAEwNACAAKAIIDQBBAiETIBdBAk4EQCACQQFrIgIgACgCpJEBIgQoAtgDIAQoAtQDa0EDdU8NAiADIAAoAqyRAUEBIAJBARC1ASAAQYyRAWogACgCpJEBKALUAyAAKAIMQQN0akEIaxD4ASAAKAKkkQEoAtQDIAAoAgxBA3RqQQhrEJUGDAELIAMgACgCrJEBQQAgAkEBa0EBELUBIAAoAqCRASICKAKkBiIDQQNPDQIgAEGMkQFqIAMgAigCoAYQowIgAEEANgCUkQELIABB9JABaiEYIABBjJEBaiEeIBdBAWshIyAAKAIMIQsgACgCCCECQQIhEwNAIAsgF2wgAmoiJCANKAKEQiANKAKAQmtBAnVPDQEgAiAWKAL8gwFODQEgCyAWKAKEhAFODQECQCALQQBMDQAgAUUNACACICNODQAgACgCnJEBIAAoAqyRASACQQFqIAtBAWtBARC1AQsgACgCkJEBRQ0BQQAhGUEAIR8gACgCACIDIAMgACgCnJEBIgMoAnwiICgC/IMBIgRtIgkgBGxrIg4gICgC7IMBIgd0ISEgACgCoJEBIQQCQCADKAKYASIIIA5MDQAgAygCnAEgCUwNACADKAKMASAIIAlsQRhsaiAOQRhsaiAEKAKoBjsBAAsCQAJAAkAgISADKAKUASIGdSIFQQBIDQAgBSAITg0AIAkgB3QiJSAGdSIGQQBIDQEgBiADKAKcAU4NASADKAKMASAFQRhsaiAGIAhsQRhsaiAEKAIAOwECAkAgBC0AzQJFBEAgBC0AzgJFDQELQQAhBCMAQSBrIgckACAAKAKgkQEhFCAAKAKckQEiCCgChAEhGiAIKAJ8IQUgB0EAOgAYIAdCADcDECAHQgA3AwgCf0EAIA5BAEwNABpBACAAKAIAIBQoAqgGTA0AGkEAIA5BAnQiAyAaKAKkQiIGIAUoAvyDASAJbEECdCIPamooAgAgAyAGaiAPakEEaygCAEcNABogAEH0kAFqIAAoAoyRARBMCyEbAkAgCUEATA0AIBtB/wFxDQAgFCgCqAYgACgCACAFKAL8gwEiA2tKDQAgDkECdCIGIBooAqRCIg8gAyAJbEECdGpqKAIAIA8gAyAJQQFrbEECdGogBmooAgBHDQAgAEH0kAFqIAAoAoyRARBMIRkLIBkgG3JB/wFxRQRAIABB9JABaiEDIAdBCGoiBkECciEmIAZBBXIhJyAFKALQgwEhKCAHLQAJISIgBy0ACCEcQQAhDwNAAkACQAJAAn8CQAJAIARFBEAgFC0AzQINAQsgBEUNBSAULQDOAkUNBSAEQQFHDQMgAyAAKAKMkQFBAWoQTA0BQQAMAgsgAyAAKAKMkQFBAWoQTAR/QQJBASADEH8bBUEACyIcIg8hBQwDC0ECQQEgAxB/GwshBSAFQQJ0IAVBBHRyIA9yIhwhDwwBCyAPQf8BcSAEQQF0dkEDcSEFCyAFRQ0AICcgBEECdGoiBiADQX9BCkHIgwFBwIMBIAQbIgogCCgCfGooAgAiDCAMQQpOG0EFa3RBf3MQnwIiDDoAACAGIANBf0EKIAgoAnwgCmooAgAiESARQQpOG0EFa3RBf3MQnwIiEToAASAGIANBf0EKIAgoAnwgCmooAgAiEiASQQpOG0EFa3RBf3MQnwIiEjoAAiAGIANBf0EKIAgoAnwgCmooAgAiCiAKQQpOG0EFa3RBf3MQnwIiHToAAwJAIAVBAUYEQEEAIQVBACEQIAxB/wFxBEBBf0EBIAMQfxshEAsgEUH/AXEEQEF/QQEgAxB/GyEFC0EAIQpBACEVIBJB/wFxBEBBf0EBIAMQfxshFQsgHUH/AXEEQEF/QQEgAxB/GyEKCyAEICZqIANBBRC2AToAACAGLQADIR0gBi0AAiESIAYtAAEhESAGLQAAIQwMAQsCQAJ/IARFBEBBASEFQX8hCiADQQIQtgEMAQtBASEFQX8hCiAEQQFHDQEgA0ECELYBIhBBAnQgEEEEdHIgH3ILIiIhHwtBfyEVQQEhEAsgBiAMIBpByMAAQcfAACAEG2otAAAiDHQgEGw6AAAgBiARIAx0IAVsOgABIAYgEiAMdCAVbDoAAiAGIB0gDHQgCmw6AAMLICgEQCAEQQJJISkgBEEBaiEEICkNAQsLIAcgIjoACSAHIBw6AAggCCgCjAEgCCgCmAEgCWxBGGxqIA5BGGxqIgMgBy0AGDoAFCADIAcpAxA3AAwgAyAHKQMINwAECyAbQf8BcQRAIAgoAowBIAgoApgBIAlsQRhsaiAOQRhsaiIDIANBGGsiBC0AFDoAFCADIAQpAAw3AAwgAyAEKQAENwAECyAZQf8BcQRAIA5BGGwiBCAIKAKMASIFIAgoApgBIgggCWxBGGxqaiIDIAUgCCAJQQFrbEEYbGogBGoiBC0AFDoAFCADIAQpAAw3AAwgAyAEKQAENwAECyAHQSBqJAAgICgC7IMBIQcLIAAgISAlIAdBABDiAgwCC0GJIEG0xgBBgAFBkx0QAQALQeMfQbTGAEGBAUGTHRABAAsCQCACQQFHDQAgDS0ALUUNACALIBYoAoSEAUEBa04NACAAKAKkkQEiAigC2AMgAigC1AMiAmtBA3UgC00NAiACIAtBA3QiA2ogHhD4ASAAKAKkkQEoAtQDIANqEJQGCwJAIBgQ2AMiA0UNACANLQAORQ0AIAAoAqCRAUG8CmogHhD4ASAAKAKgkQFBvApqEJQGIAAoAqCRAUEBOgDECgsgACgCnJEBKALAAiAkQcwAbGoiAigCAEEATARAIAJBATYCAAsgACAAKAIEIglBAWoiBDYCBCAAKAKckQEiCCgCfCIHKAKMhAEiAiAETARAIAcoAvyDASEBIAAgAjYCACAAIAIgAW0iBDYCDCAAIAIgASAEbGs2AghBACETIAMNAiAAKAKYkQFBBGpB7AdBABBRDAQLIAAoAgwhBSAHKAL8gwEhAiAAIARBAnQiByAIKAKEASgCjEJqKAIAIgQ2AgAgACAEIAJtIgs2AgwgACAEIAIgC2xrIgI2AgggAwRAQQAPCyANLQAuBH8gByANKAKYQiIDaigCACADIAlBAnRqKAIARwVBAAtFBEAgDS0ALUEARyAFIAtHcUUNAQsLIBgQ2ANFBEAgACgCmJEBQQRqQfkHQQAQUQwDCyAYEKACQQEhEwsgEw8LQfSMAUHK9QBB8AtBpiIQAQALIAAoApyRAUEDOgC4AkECC8I3ARt/IABB9JABaiEMAkACQAJAAkACQANAIAAoApyRASIJKAKEASEFAn8CQCAJKAJ8IgsoAuQDIgZBASADdCIIIAFqSARAIAsoAuiDASEHDAELIAsoAuiDASEHIAsoAugDIgogAiAIakgNACADIAdMDQBBASEHAn9BASABQQFrIgggAnJBAEgNABpBASABIAZKDQAaQQEgAiAKTg0AGkEBIAkoAowBIg4gC0H8gwFqKAIAIAIgC0HsgwFqKAIAIg11bCIQIAEgDXVqIg9BGGxqLwEAIA4gECAIIA11aiINQRhsai8BAEcNABogBSgCpEIiDiAPQQJ0aigCACAOIA1BAnRqKAIARwshHQJAIAJBAWsiDSABckEASA0AIAEgBk4NACACIApKDQAgCSgCjAEiCiALQfyDAWooAgAiECACIAtB7IMBaigCACIGdWwgASAGdSIPaiISQRhsai8BACAKIA0gBnUgEGwgD2oiBkEYbGovAQBHDQAgBSgCpEIiByASQQJ0aigCACAHIAZBAnRqKAIARyEHC0EAIQYgHUUEQCAIIAkoAqgBIgp1IgZBAEgNByAGIAkoAqwBIghODQcgAiAKdSIKQQBIDQggCiAJKAKwAU4NCCAEIAkoAqABIAZBA2xqIAggCmxBA2xqLwAAQQZ2QQNxSCEGCwJAIAwgBwR/QQAFIAEgCSgCqAEiCnUiB0EASA0IIAcgCSgCrAEiCE4NCCANIAp1IgpBAEgNASAKIAkoArABTg0BIAQgCSgCoAEgB0EDbGogCCAKbEEDbGovAABBBnZBA3FICyAAKAKMkQEgBmpqQQJqEExFDAILDAcLIAMgB0wLIR4CQCAFLQAaRQ0AIAUoAsxAIANKDQAgAEIANwLEkAELAkAgACgCoJEBLQD4BUUNACAFKALQQCADSg0AIABBADYCzJABCyAeRQRAIAAgASACIANBAWsiAyAEQQFqIgQQ4gJBASADdCIGIAJqIQUgASAGaiIGIAsoAuQDSARAIAAgBiACIAMgBBDiAgsgCygC6AMiByAFSgRAIAAgASAFIAMgBBDiAiALKALoAyEHCyAGIAsoAuQDTg0CIAYhASAFIgIgB0gNAQwCCwsgAyAJKAKoASIFayIGQR9HBEBBASAGdCILIAIgBXUiB2ohCiALIAEgBXUiBmohCyAEQQZ0QcABcSEIA0AgBiEFA0AgCSgCoAEgBUEDbGogCSgCrAEgB2xBA2xqIg0gDS8AAEG//gNxIAhyOwAAIAVBAWoiBSALSA0ACyAHQQFqIgcgCkgNAAsLIwBB0ABrIg0kACAAIgcoAqCRASEOIAAoApyRASIFKAKEASEKIAUoAnwhECABIQYgAiEJIAMiCyAFKAKoASIAayIBQR9HBEBBASABdCIIIAIgAHUiAmohDCAIIAYgAHUiAWohCANAIAEhAANAIAUoAqABIABBA2xqIAUoAqwBIAJsQQNsaiIPIA8vAABB+P8DcTsAACAAQQFqIgAgCEgNAAsgAkEBaiICIAxIDQALCwJAIAYgBSgCqAEiAXUiAEEASA0CIAAgBSgCrAEiAk4NAiAJIAF1IgFBAEgNAyABIAUoArABTg0DIAUoAqABIABBA2xqIAEgAmxBA2xqIgAgAC8AAEH4/wNxIANBB3FyOwAADAALIAsgBSgC+AEiAWsiAEEfRwRAQQEgAHQiAyAJIAF1IgBqIQggAyAGIAF1IgJqIQMDQCACIQEDQCAFKALwASABaiAFKAL8ASAAbGpBADoAACABQQFqIgEgA0gNAAsgAEEBaiIAIAhIDQALCyAHIAYgCRDpBQJAIAotACwEQCAHIAdB9JABaiAHKAKMkQFBoQFqEEwiADoAICAARQ0BIAsgBSgCqAEiAGsiAUEfRwRAQQEgAXQiAyAJIAB1IgJqIQogAyAGIAB1IgFqIQMDQCABIQADQCAFKAKgASAAQQNsaiAFKAKsASACbEEDbGoiCCAILwAAQf/vA3FBgBByOwAAIABBAWoiACADSA0ACyACQQFqIgIgCkgNAAsLAkAgBiAFKAKUASIBdSIAQQBIDQQgACAFKAKYASICTg0EIAkgAXUiAUEASA0FIAEgBSgCnAFODQUgBSgCjAEgAEEYbGogASACbEEYbGpBAToAFgwACwwBCyAHQQA6ACALQQEgC3QhCAJAAkACf0EAIA4oAhxBAkYNABogBygCnJEBIQBBASEKAn9BASAGQQFrIgMgCXJBAEgNABpBASAAKAJ8IgEoAuQDIAZIDQAaQQEgASgC6AMgCUwNABpBASAAKAKMASICIAFB/IMBaigCACAJIAFB7IMBaigCACIBdWwiDCAGIAF1aiIPQRhsai8BACACIAwgAyABdWoiAUEYbGovAQBHDQAaIAAoAoQBKAKkQiICIA9BAnRqKAIAIAIgAUECdGooAgBHCyEfAkAgCUEBayIPIAZyQQBIDQAgACgCfCIBKALkAyAGTA0AIAEoAugDIAlIDQAgACgCjAEiAiABQfyDAWooAgAiDCAJIAFB7IMBaigCACIBdWwgBiABdSITaiIVQRhsai8BACACIA8gAXUgDGwgE2oiAUEYbGovAQBHDQAgACgChAEoAqRCIgIgFUECdGooAgAgAiABQQJ0aigCAEchCgtBACEMQQAhAiAfRQRAIAMgACgCqAEiAnUiAUEASA0HIAEgACgCrAEiA04NByAJIAJ1IgJBAEgNCCACIAAoArABTg0IIAAoAqABIAFBA2xqIAIgA2xBA2xqLwAAQYAGcUGABEYhAgsgCkUEQCAGIAAoAqgBIgN1IgFBAEgNByABIAAoAqwBIgpODQcgDyADdSIDQQBIDQggAyAAKAKwAU4NCCAAKAKgASABQQNsaiADIApsQQNsai8AAEGABnFBgARGIQwLIAdB9JABaiIAIAcoAoyRASACaiAMakEFahBMQf8BcQRAQRAhAQJAIAcoAqCRASgCrAZBAkgNACAAIAcoAoyRAUGUAWoQTEUNAEEwIQEgBygCoJEBKAKsBkEDSA0AQQEhAQNAIAAQfwRAIAFBAWoiASAHKAKgkQEoAqwGQQFrSA0BCwsgAUEFdEEQciEBCyAHIAEgBy0AGkEPcXI6ABogBiAFKAKoASIBdSIAQQBIDQUgACAFKAKsASICTg0FIAkgAXUiAUEASA0GIAEgBSgCsAFODQYgBSgCoAEgAEEDbGogASACbEEDbGoiACAALwAAQcf/A3E7AAAgCyAFKAKoASIAayIBQR9HBEBBASABdCIBIAkgAHUiAmohAyABIAYgAHUiAGohBANAIAAhAQNAIAUoAqABIAFBA2xqIAUoAqwBIAJsQQNsaiILIAsvAABB//kDcUGABHI7AAAgAUEBaiIBIARIDQALIAJBAWoiAiADSA0ACwsgBygCmJEBIAcoAqCRASAHKAKckQEgB0EQaiAGIAlBAEEAIAggCCAIQQAQ8AUMAgtBACAOKAIcQQJGDQAaIAAgBygCjJEBQZUBahBMRQshAyALIAUoAqgBIgBrIgFBH0cEQEEBIAF0IgEgCSAAdSICaiEKIANBCHQhDCABIAYgAHUiAGohDgNAIAAhAQNAIAUoAqABIAFBA2xqIAUoAqwBIAJsQQNsaiIPIA8vAABB//kDcSAMcjsAACABQQFqIgEgDkgNAAsgAkEBaiICIApIDQALCwJ/IANFAn8gAwRAAn9BACEAIAcoApyRASgCfCEKAkAgB0H0kAFqIgIgBygCjJEBQQhqEEwNACACIAcoAoyRAUEJahBMIQECQCALIAooAuiDAUoEQEEBQQIgARsiACAKLQDeREUNAxogACACIAcoAoyRAUELahBMDQMaIAIQfyECIAEEQEEFIQAgAg0DCyABBEBBBCEAIAJFDQMLIAEgAnINAUEGDAMLQQEhACABDQFBAiEAIAtBA0YNAUEDIAIgBygCjJEBQQpqEExrIQAMAQsgAUUEQEEHIQAgAg0BC0HczgBByvUAQe4NQe7fABABAAsgAAsMAQtBACEBQQAgECgC6IMBIAtHDQEaQQBBAyAHQfSQAWogBygCjJEBQQhqEEwbCyIBQQNGcQshFSAGIAUoAqgBIgJ1IgBBAEgNAyAAIAUoAqwBIgpODQMgCSACdSICQQBIDQQgAiAFKAKwAU4NBCAFKAKgASAAQQNsaiACIApsQQNsaiIAIAAvAABBx/8DcSABQQN0QThxcjsAAAJAIANFBEACQCABDQAgEC0A4ERFDQAgECgCvIQBIAtKDQAgECgCwIQBIAtIDQAgB0H0kAFqIg8Q2ANFDQAgCyAFKAKoASIAayIBQR9HBEBBASABdCIDIAkgAHUiAmohBCADIAYgAHUiAWohAwNAIAEhAANAIAUoAqABIABBA2xqIAUoAqwBIAJsQQNsaiIKIAovAABB//cDcUGACHI7AAAgAEEBaiIAIANIDQALIAJBAWoiAiAESA0ACwsCQCAGIAUoApQBIgF1IgBBAEgNByAAIAUoApgBIgJODQcgCSABdSIBQQBIDQggASAFKAKcAU4NCCAFKAKMASAAQRhsaiABIAJsQRhsakEBOgAWDAALIA0gBygC+JABIgA2AjAgBygC/JABIQFBACEMIA1BADYCQCANQgA3AzggDSABIABrNgI0IAcoApyRASIAKAIoIgEgCWwhAiAAKAIEIQMgACgCfCIELADhRCEAAkAgBCgCwIMBIgRBCU4EQCALQR9GDQEgBCAAayIEQQAgBEEAShshBSADIAIgBmpBAXRqIQIDQCACIAEgDGxBAXRqIQNBACEEA0AgAyAEQQF0aiANQTBqIAAQMSAFdDsBACAEQQFqIgQgCEcNAAsgDEEBaiIMIAhHDQALDAELIAtBH0YNACAEIABrIgRBACAEQQBKGyEFIAIgA2ogBmohAgNAIAIgASAMbGohA0EAIQQDQCADIARqIA1BMGogABAxIAV0OgAAIARBAWoiBCAIRw0ACyAMQQFqIgwgCEcNAAsLAkAgBygCnJEBIgwoAnwiACgC0IMBRQ0AIAYgACgC1IMBIgFtIQsgCCAAKALYgwEiAm0hCiAIIAFtIQQgDCgCLCIDIAkgAm1sIQ4gDCgCCCEQIAAsAOJEIQEgACgCyIMBIgBBCU4EQEEAIQUgACABayIAQQAgAEEAShshAiALIA5qQQF0IQACQCAEQQBMDQAgCkEATA0AIAAgEGohCwNAIAsgAyAFbEEBdGohDEEAIQADQCAMIABBAXRqIA1BMGogARAxIAJ0OwEAIABBAWoiACAERw0ACyAFQQFqIgUgCkcNAAsgBygCnJEBIgwoAnwiACgCyIMBIAAsAOJEIgFrIgJBACACQQBKGyECIAwoAiwiAyAJIAAoAtiDASIEbWwgBiAAKALUgwEiBW1qQQF0IQAgCCAEbSEKIAggBW0hBAsgCkEATA0BIARBAEwNASAMKAIMIABqIQZBACEFA0AgBiADIAVsQQF0aiEJQQAhAANAIAkgAEEBdGogDUEwaiABEDEgAnQ7AQAgAEEBaiIAIARHDQALIAVBAWoiBSAKRw0ACwwBC0EAIQUgACABayIAQQAgAEEAShshAgJAIARBAEwNACAKQQBMDQAgDiAQaiALaiELA0AgCyADIAVsaiEMQQAhAANAIAAgDGogDUEwaiABEDEgAnQ6AAAgAEEBaiIAIARHDQALIAVBAWoiBSAKRw0ACyAHKAKckQEiDCgCfCIAKALIgwEgACwA4kQiAWsiAkEAIAJBAEobIQIgBiAAKALUgwEiA20hCyAIIAAoAtiDASIAbSEKIAggA20hBCAMKAIsIgMgCSAAbWwhDgsgCkEATA0AIARBAEwNACAMKAIMIA5qIAtqIQZBACEFA0AgBiADIAVsaiEJQQAhAANAIAAgCWogDUEwaiABEDEgAnQ6AAAgAEEBaiIAIARHDQALIAVBAWoiBSAKRw0ACwsgDUEwahCTBiAHIA0oAjA2AviQASAPEKACDAMLIAhBAm0gCCABQQNGIgIbIQ8gC0EfRwRAIAdB9JABaiEDQQAhAUEAIQwDQEEAIQADQCANQTBqIAFBAnRqIAMgBygCjJEBQQxqEEw2AgAgAUEBaiEBIAAgD2oiACAISA0ACyAMIA9qIgwgCEgNAAsLAn9BACAGQQFrIgEgCXJBAEgNABpBACAFKAJ8IgAoAuQDIAZIDQAaQQAgACgC6AMgCUwNABpBACAFKAKMASIDIABB/IMBaigCACAJIABB7IMBaigCACIAdWwiBCAGIAB1aiIKQRhsai8BACADIAQgASAAdWoiAEEYbGovAQBHDQAaIAUoAoQBKAKkQiIBIApBAnRqKAIAIAEgAEECdGooAgBGCyEaAkAgCUEBayIBIAZyQQBIDQAgBSgCfCIAKALkAyAGTA0AIAAoAugDIAlIDQAgBSgCjAEiAyAAQfyDAWooAgAiBCAJIABB7IMBaigCACIAdWwgBiAAdSIKaiIMQRhsai8BACADIAEgAHUgBGwgCmoiAEEYbGovAQBHDQAgBSgChAEoAqRCIgEgDEECdGooAgAgASAAQQJ0aigCAEYhGwsgCyACayESIAtBH0cEQCAHQfSQAWohGUEAIRMDQCAJIBNqIQQgGyATQQBKciEKQQAhDgNAAn8gF0ECdCIUIA1BMGpqKAIAIhwEQCAZQQIQnwIhDCANQSBqDAELIBlBBRC2ASEMIA1BEGoLIBRqIAw2AgAgBiAOaiIAIQIgECgCtIQBIAQgECgCsIQBIgF1bCAAIAF1aiIMIQMgBSgCfCEWQQEhAQJAAn9BASAaIA5BAEpyRQ0AGiACQQFrIAUoAqgBIhF1IgBBAEgNDCAAIAUoAqwBIhhODQwgBCARdSIRQQBIDQ0gESAFKAKwAU4NDUEBIAUoAqABIABBA2xqIBEgGGxBA2xqLQABQQdxDQAaIAUoAsgBIANqQQFrLQAACyEAAkAgCkUNACACIAUoAqgBIhF1IgJBAEgNDCACIAUoAqwBIhhODQwgBEEBayARdSIRQQBIDQ0gESAFKAKwAU4NDSAFKAKgASACQQNsaiARIBhsQQNsai0AAUEHcQ0AQX8gFigC7IMBdCAEcSAETg0AIAUoAsgBIAMgFigCtIQBa2otAAAhAQsgACABRgRAIABBAU0EQCANQRo2AgwgDUKAgICAEDcCBAwCCyANIAA2AgQgDSAAQQFrQR9xQQJqNgIMIA0gAEEdakEfcUECajYCCAwBCyANIAE2AgggDSAANgIEAkAgAEUNACABRQ0AIA1BADYCDAwBCwJAIABBAUYNACABQQFGDQAgDUEBNgIMDAELIA1BGjYCDAwACwJ/IBxBAUcEQCANKAIEIgAgDSgCCCICIAAgAkobIQECQCAAIAIgACACSBsiACANKAIMIgJMBEAgACEDIAIhAAwBCyANIAA2AgwgDSACNgIEIAIhAwsCQCAAIAFOBEAgACECIAEhAAwBCyANIAA2AgggASECCyANQRBqIBRqKAIAIgEgASADTmoiASAAIAFMaiIAIAAgAk5qDAELIA1BBGogDUEgaiAUaigCAEECdGooAgALIQMgEiAFKALQASIUayIAQR9HBEBBASAAdCIWQf7///8HcSERQQAhAANAQQAhAUEAIQIgEiAURwRAA0AgBSgCyAEgAWogDGogBSgC1AEgAGxqIAM6AAAgBSgCyAEgAWogDGogBSgC1AEgAGxqIAM6AAEgAUECaiEBIAJBAmoiAiARRw0ACwsgEiAURgRAIAUoAsgBIAFqIAxqIAUoAtQBIABsaiADOgAACyAAQQFqIgAgFkcNAAsLIBdBAWohFyAOIA9qIg4gCEgNAAsgDyATaiITIAhIDQALCwJAAkAgECgC0IMBDgQDAQEAAQsgC0EfRg0CIAdB9JABaiEAQQAhDgJAA0AgCSAOaiECQQAhAQJAA0AgACAHKAKMkQFBDWoQTAR/IABBAhC2AQVBBAshAyABIAZqIgwgBSgC0AEiCnUiBEEASA0BIAQgBSgC1AEiE04NASACIAp1IgpBAEgNAyAKIAUoAtgBTg0DIAUoAsgBIARqIAogE2xqLQAAIgRBACAEQSJNGyEEIAUgDCACIBIgA0EERiIKBH8gBAVBIiADQQJ0QbCPA2ooAgAiAyADIARGGwsgChDsBSABIA9qIgEgCEgNAAsgDiAPaiIOIAhIDQEMBQsLDAkLDAkLIAdB9JABaiIAIAcoAoyRAUENahBMBH8gAEECELYBBUEECyEAIAYgBSgC0AEiAnUiAUEASA0HIAEgBSgC1AEiA04NByAJIAJ1IgJBAEgNCCACIAUoAtgBTg0IIAUoAsgBIAFqIAIgA2xqLQAAIgFBACABQSJNGyEBIABBBEcEQEEiIABBAnRBsI8DaigCACICIAEgAkYbIQELIAUgBiAJIAsgECgC0IMBQQJGBH8gAUHAjwNqLQAABSABCyAAQQRGEOwFDAELAkACQAJAAkACQAJAAkACQAJAAkACQCABDggIAAEGAgMEBQcLIAcgBiAJQQBBACAIIAhBAm0iACAEIAhBABCJASAHIAYgCUEAIAAgCCAAIAQgCEEBEIkBDAgLIAcgBiAJQQBBACAIQQJtIgAgCCAEIAhBABCJASAHIAYgCSAAQQAgACAIIAQgCEEBEIkBDAcLIAcgBiAJQQBBACAIIAhBBG0iACAEIAhBABCJASAHIAYgCUEAIAAgCEEDIAt0QQRtIAQgCEEBEIkBDAYLIAcgBiAJQQBBACAIQQMgC3RBBG0iACAEIAhBABCJASAHIAYgCUEAIAAgCCAIQQRtIAQgCEEBEIkBDAULIAcgBiAJQQBBACAIQQRtIgAgCCAEIAhBABCJASAHIAYgCSAAQQBBAyALdEEEbSAIIAQgCEEBEIkBDAQLIAcgBiAJQQBBAEEDIAt0QQRtIgAgCCAEIAhBABCJASAHIAYgCSAAQQAgCEEEbSAIIAQgCEEBEIkBDAMLIAcgBiAJQQBBACAIQQJtIgAgACAEIAhBABCJASAHIAYgCSAAQQAgACAAIAQgCEEBEIkBIAcgBiAJQQAgACAAIAAgBCAIQQIQiQEgByAGIAkgACAAIAAgACAEIAhBAxCJAQwCC0GdkAFByvUAQcAjQYMbEAEACyAHIAYgCUEAQQAgCCAIIAQgCEEAEIkBIActABpBEHENAQsgB0H0kAFqIAcoAoyRAUGZAWoQTEUNAgsgByAGIAkgBiAJIAYgCSALQQBBACAQKAL0BCAVQQEgECgC0IMBQQBHIgAgABCaAgwBCyAHIAYgCSAGIAkgBiAJIAtBAEEAIBAoAvgEIBVqIBVBACAQKALQgwFBAEciACAAEJoCCyANQdAAaiQADAALCw8LQYkgQbTGAEGAAUGTHRABAAtB4x9BtMYAQYEBQZMdEAEAC0GJIEG0xgBB9gBBkx0QAQALQeMfQbTGAEH3AEGTHRABAAufAgEEfyACLQDMAkUEQCAJQQA2AQAgCkEAOgAADwsgASgCfCgC7IMBIQsgAAJ/AkAgAigCHA0AIAItAPwCDQBB3AcMAQtBnAcLIAJqIAIoAoADQQJ0aigCACIMIAAoAgAoAgwRBQBFBEAgCUEANgEAIApBADoAACAAQQRqQfQHQQAQUQ8LAkACQAJAAkAgBCALdSAEIAZqIg0gC3VHDQAgAyAFaiILIAEoAnwiDigC5ANODQAgDSAOKALoA0gNAQsgCUEANgEAIApBADoAAAwBCyAAIAEgAiAMIAtBcHEgDUFwcSAHIAggCSAKEPIFIAotAAANAQsgACABIAIgDCAFQQF1IANqQXBxIAZBAXUgBGpBcHEgByAIIAkgChDyBQsLDAAgAEEAQeQAEDQaC/MQARh/IAAoAhQhCCAAKAIQIQcgACgCDCEDIAAoAgghCQNAIAAgASgAACIKNgJYIAAgASgABCILNgJcIAAgASgACCIMNgJgIAAgASgADCINNgJkIAAgASgAECIONgJoIAAgASgAFCIPNgJsIAAgASgAGCIQNgJwIAAgASgAHCIRNgJ0IAAgASgAICISNgJ4IAAgASgAJCITNgJ8IAAgASgAKCIUNgKAASAAIAEoACwiFTYChAEgACABKAAwIhY2AogBIAAgASgANCIXNgKMASAAIAEoADgiGDYCkAEgACABKAA8Ihk2ApQBIAMgDCAQIBQgGCAZIA0gESAVIBEgDSAZIBUgGCAUIBAgByAMaiAIIAtqIAogCSADIAcgCHNxIAhzampBiLfVxAJrQQd3IANqIgQgAyAHc3EgB3NqQaqR4bkBa0EMdyAEaiIFIAMgBHNxIANzakHb4YGhAmpBEXcgBWoiBmogBSAPaiAEIA5qIAMgDWogBiAEIAVzcSAEc2pBkuKI8gNrQRZ3IAZqIgMgBSAGc3EgBXNqQdHgj9QAa0EHdyADaiIEIAMgBnNxIAZzakGqjJ+8BGpBDHcgBGoiBSADIARzcSADc2pB7fO+vgVrQRF3IAVqIgZqIAUgE2ogBCASaiADIBFqIAYgBCAFc3EgBHNqQf/V5RVrQRZ3IAZqIgMgBSAGc3EgBXNqQdixgswGakEHdyADaiIEIAMgBnNxIAZzakHRkOylB2tBDHcgBGoiBSADIARzcSADc2pBz8gCa0ERdyAFaiIGaiAFIBdqIAQgFmogAyAVaiAGIAQgBXNxIARzakHC0Iy1B2tBFncgBmoiAyAFIAZzcSAFc2pBoqLA3AZqQQd3IANqIgQgAyAGc3EgBnNqQe2cnhNrQQx3IARqIgYgAyAEc3EgA3NqQfL4mswFa0ERdyAGaiIFaiAGIBBqIAQgC2ogAyAZaiAFIAQgBnNxIARzakGhkNDNBGpBFncgBWoiAyAFcyAGcSAFc2pBnrWHzwBrQQV3IANqIgQgA3MgBXEgA3NqQcCZ/f0Da0EJdyAEaiIFIARzIANxIARzakHRtPmyAmpBDncgBWoiBmogBSAUaiAEIA9qIAMgCmogBSAGcyAEcSAFc2pB1vCksgFrQRR3IAZqIgMgBnMgBXEgBnNqQaPfw84Ca0EFdyADaiIEIANzIAZxIANzakHTqJASakEJdyAEaiIFIARzIANxIARzakH/svi6AmtBDncgBWoiBmogBSAYaiAEIBNqIAMgDmogBSAGcyAEcSAFc2pBuIiwwQFrQRR3IAZqIgMgBnMgBXEgBnNqQeabh48CakEFdyADaiIEIANzIAZxIANzakGq8KPmA2tBCXcgBGoiBSAEcyADcSAEc2pB+eSr2QBrQQ53IAVqIgZqIAUgDGogBCAXaiADIBJqIAUgBnMgBHEgBXNqQe2p6KoEakEUdyAGaiIDIAZzIAVxIAZzakH7rfCwBWtBBXcgA2oiBCADcyAGcSADc2pBiLjBGGtBCXcgBGoiBSAEcyADcSAEc2pB2YW8uwZqQQ53IAVqIgZqIAQgD2ogBSAGcyIaIAMgFmogBCAacSAFc2pB9ubWlgdrQRR3IAZqIgNzakG+jRdrQQR3IANqIgQgA3MgBSASaiADIAZzIARzakH/krjEB2tBC3cgBGoiBXNqQaLC9ewGakEQdyAFaiIGaiAEIAtqIAMgGGogBCAFcyAGc2pB9I/rEGtBF3cgBmoiAyAFIAZzc2pBvKuE2gVrQQR3IANqIgQgA3MgBSAOaiADIAZzIARzakGpn/veBGpBC3cgBGoiBXNqQaDpksoAa0EQdyAFaiIGaiAEIBdqIAMgFGogBCAFcyAGc2pBkIeBigRrQRd3IAZqIgMgBSAGc3NqQcb97cQCakEEdyADaiIEIANzIAUgCmogAyAGcyAEc2pBhrD7qgFrQQt3IARqIgVzakH7nsPYAmtBEHcgBWoiBmogBCATaiADIBBqIAQgBXMgBnNqQYW6oCRqQRd3IAZqIgMgBSAGc3NqQcffrLECa0EEdyADaiIEIANzIAUgFmogAyAGcyAEc2pBm8yRyQFrQQt3IARqIgVzakH4+Yn9AWpBEHcgBWoiBmogBSARaiAEIApqIAMgDGogBCAFcyAGc2pBm9PO2gNrQRd3IAZqIgMgBUF/c3IgBnNqQby7294Aa0EGdyADaiIEIAZBf3NyIANzakGX/6uZBGpBCncgBGoiBSADQX9zciAEc2pB2bivowVrQQ93IAVqIgZqIAUgDWogBCAWaiADIA9qIAYgBEF/c3IgBXNqQce/sRtrQRV3IAZqIgMgBUF/c3IgBnNqQcOz7aoGakEGdyADaiIEIAZBf3NyIANzakHu5syHB2tBCncgBGoiBSADQX9zciAEc2pBg5fAAGtBD3cgBWoiBmogBSAZaiAEIBJqIAMgC2ogBiAEQX9zciAFc2pBr8Tu0wdrQRV3IAZqIgMgBUF/c3IgBnNqQc/8of0GakEGdyADaiIEIAZBf3NyIANzakGgsswOa0EKdyAEaiIFIANBf3NyIARzakHs+frnBWtBD3cgBWoiBmogBSAVaiAEIA5qIAMgF2ogBiAEQX9zciAFc2pBoaOg8ARqQRV3IAZqIgMgBUF/c3IgBnNqQf6CssUAa0EGdyADaiIEIAZBf3NyIANzakHLm5SWBGtBCncgBGoiBSADQX9zciAEc2pBu6Xf1gJqQQ93IAVqIgZqIAMgE2ogBiAEQX9zciAFc2pB79jkowFrQRV3aiEDIAYgB2ohByAFIAhqIQggBCAJaiEJIAFBQGshASACQUBqIgINAAsgACAINgIUIAAgBzYCECAAIAM2AgwgACAJNgIIIAELJAAgACgC0AIgACgC1AJHBEADQCAAKALQAiAAKALUAkcNAAsLC0UBAX8gACAAKALIAiIBQQFrNgLIAiAAIAAoAtACQQFqNgLQAiABQQBKBEAgACgC1AIaDwtBz48BQcH1AEGlBUGSJRABAAunCwEJfyMAQSBrIgYkAAJAAkAgACgCECICQYAITwRAIAAgAkGACGs2AhAgACgCBCICKAIAIQggACACQQRqIgE2AgQCQCAAKAIIIgMgACgCDEcNACAAKAIAIgIgAUkEQCADIAFrIQQgASABIAJrQQJ1QQFqQX5tQQJ0IgVqIQIgASADRwRAIAIgASAEEDcaIAAoAgQhAQsgACACIARqIgM2AgggACABIAVqNgIEDAELQQEgAyACa0EBdSACIANGGyIEQYCAgIAETw0DIARBAnQiBRAsIgcgBWohCSAHIARBfHFqIgQhBSABIANHBEAgBCADIAFraiEDA0AgBSABKAIANgIAIAFBBGohASAFQQRqIgUgA0cNAAsLIAAgCTYCDCAAIAU2AgggACAENgIEIAAgBzYCACACECogACgCCCEDCyADIAg2AgAgACAAKAIIQQRqNgIIDAELIAAoAggiASAAKAIEIgVrIgQgACgCDCICIAAoAgAiA2siB0kEQCABIAJHBEAgBkGAIBAsNgIMAkACQAJAIAAoAggiBCAAKAIMRwRAIAQhAgwBCyAAKAIEIgEgACgCACIDSwRAIAQgAWshAiABIAEgA2tBAnVBAWpBfm1BAnQiBWohAyABIARHBEAgAyABIAIQNxogACgCBCEBCyAAIAIgA2oiAjYCCCAAIAEgBWo2AgQMAQtBASAEIANrQQF1IAMgBEYbIgJBgICAgARPDQEgAkECdCIHECwiBSAHaiEIIAUgAkF8cWoiByECIAEgBEcEQCAHIAQgAWtqIQQDQCACIAEoAgA2AgAgAUEEaiEBIAJBBGoiAiAERw0ACwsgACAINgIMIAAgAjYCCCAAIAc2AgQgACAFNgIAIANFDQAgAxAqIAAoAgghAgsgAiAGKAIMNgIAIAAgACgCCEEEajYCCAwBCxBPAAsMAgsgBkGAIBAsNgIMIAAgBkEMahCBBiAAKAIEIgIoAgAhCCAAIAJBBGoiATYCBAJAIAAoAggiAyAAKAIMRw0AIAAoAgAiAiABSQRAIAMgAWshBCABIAEgAmtBAnVBAWpBfm1BAnQiBWohAiABIANHBEAgAiABIAQQNxogACgCBCEBCyAAIAIgBGoiAzYCCCAAIAEgBWo2AgQMAQtBASADIAJrQQF1IAIgA0YbIgRBgICAgARPDQMgBEECdCIFECwiByAFaiEJIAcgBEF8cWoiBCEFIAEgA0cEQCAEIAMgAWtqIQMDQCAFIAEoAgA2AgAgAUEEaiEBIAVBBGoiBSADRw0ACwsgACAJNgIMIAAgBTYCCCAAIAQ2AgQgACAHNgIAIAIQKiAAKAIIIQMLIAMgCDYCACAAIAAoAghBBGo2AggMAQsgBiAAQQxqNgIcQQEgB0EBdSACIANGGyICQYCAgIAETw0BIAYgAkECdCIIECwiAjYCDCAGIAIgCGoiBzYCGCAGIAIgBGoiAzYCEEGAIBAsIQkCQCAEIAhHDQAgBEEASgRAIAYgAyAEQQF2QQJqQXxxayIDNgIQDAELQQEgBEEBdSABIAVGGyIBQYCAgIAETw0CIAYgAUECdCIDECwiBDYCDCAGIAMgBGoiBzYCGCAGIAQgAUF8cWoiAzYCECACECogACgCBCEFIAAoAgghASAEIQILIAMgCTYCACAGIANBBGoiCDYCFCABIAVHBEADQCAGQQxqIAFBBGsiARCBBiABIAAoAgQiBUcNAAsgACgCCCEBIAYoAhghByAGKAIUIQggBigCECEDIAYoAgwhAgsgACgCACEEIAAgAjYCACAGIAQ2AgwgACADNgIEIAYgBTYCECAAIAg2AgggBiABNgIUIAAoAgwhAiAAIAc2AgwgBiACNgIYIAEgBUcEQCAGIAEgBSABa0EDakF8cWo2AhQLIARFDQAgBBAqCyAGQSBqJAAPCxBPAAvGBQEUfyMAQYAQayIKJAACfyABQQJIBEBBfyEJQQYhEEF+IQhBICERQQUMAQsgASEEA0AgBSIJQQFqIQUgBEEDSyEVIARBAXYhBCAVDQALQQAhBSABIQQDQCAFIgdBAWohBSAEQQNLIRYgBEEBdiEEIBYNAAsgCUEBayEIQQAhBSABIQQDQCAFIgZBAWohBSAEQQNLIRcgBEEBdiEEIBcNAAtBwAAgB3QhESAHQQdqIRBBBCAGawshDQJAIAFBAEwNAEEBIAh0IQsgAUH+////B3EhEyABQQFxIRQgAUEBayESQQAhBgNAIAIgBkEBdGohDEEAIQgDQCAIIA10IQ5BACEEQQAhBUEAIQcgEgRAA0AgDCAEQQFyIg8gA2xBAXRqLgEAIA8gDkEFdEGQgQNqIg9qLAAAbCAMIAMgBGxBAXRqLgEAIAQgD2osAABsIAVqaiEFIARBAmohBCAHQQJqIgcgE0cNAAsLIAogASAIbCAGakEBdGogFAR/IAwgAyAEbEEBdGouAQAgDkEFdCAEakGQgQNqLAAAbCAFagUgBQsgC2ogCXU7AQAgCEEBaiIIIAFHDQALIAZBAWoiBiABRw0ACyABQQBMDQAgAUH+////B3EhCCABQQFxIQxBACEJA0AgACABIAlsIgNBAXRqIQ5BACECA0AgAiANdCEGQQAhBEEAIQVBACEHIBIEQANAIAogBEEBciILIANqQQF0ai4BACALIAZBBXRBkIEDaiILaiwAAGwgCiADIARqQQF0ai4BACAEIAtqLAAAbCAFamohBSAEQQJqIQQgB0ECaiIHIAhHDQALCyAOIAJBAXRqIAwEfyAKIAMgBGpBAXRqLgEAIAZBBXQgBGpBkIEDaiwAAGwgBWoFIAULIBFqIBB1OwEAIAJBAWoiAiABRw0ACyAJQQFqIgkgAUcNAAsLIApBgBBqJAALpAkBE38jAEGAEGsiCiQAQQUhCyACQQJOBEBBACELIAIhBQNAIAsiBkEBaiELIAVBA0shFyAFQQF2IQUgFw0AC0EEIAZrIQsLAkAgAkEATA0AIAJB/P///wdxIREgAkEDcSEPIAJBAWshEANAIAMgCEEBdGohDUEAIQUgAiEGAkADQCAFIQwgBiIJQQBMBEBBACEGQQAhBUEAIQcgEEEDTwRAA0AgCiACIAVsIAhqQQF0akEAOwEAIAogBUEBciACbCAIakEBdGpBADsBACAKIAVBAnIgAmwgCGpBAXRqQQA7AQAgCiAFQQNyIAJsIAhqQQF0akEAOwEAIAVBBGohBSAHQQRqIgcgEUcNAAsLIA9FDQIDQCAKIAIgBWwgCGpBAXRqQQA7AQAgBUEBaiEFIAZBAWoiBiAPRw0ACwwCCyAMQQFqIQUgDSAJQQFrIgYgAmxBAXRqLwEARQ0ACyAJQf7///8HcSESIAlBAXEhCUEAIQYDQEEAIQVBACEHQQAhDiAMIBBHBEADQCANIAIgBWxBAXRqLgEAIAUgC3RBBXQgBmpBkIEDaiwAAGwgB2ogDSAFQQFyIgcgAmxBAXRqLgEAIAcgC3RBBXQgBmpBkIEDaiwAAGxqIQcgBUECaiEFIA5BAmoiDiASRw0ACwsgCiACIAZsIAhqQQF0akGAgH5B//8BIAkEfyANIAIgBWxBAXRqLgEAIAUgC3RBBXQgBmpBkIEDaiwAAGwgB2oFIAcLQUBrQQd1IgUgBUH//wFOGyIFIAVBgIB+TBs7AQAgBkEBaiIGIAJHDQALCyAIQQFqIgggAkcNAAsgAkEATA0AIAJB/v///wdxIQ8gAkEBcSERQQFBEyAEa3QiEkEUIARrIhN1IQ1BfyAEdEF/cyEMQQAhBANAIAIgBGwhCEEAIQUgAiEGAkACQANAIAUhCSAGIgNBAEwNASAFQQFqIQUgCiAGQQFrIgYgCGpBAXRqLwEARQ0ACyADQf7///8HcSEUIANBAXEhFSAAIAEgBGxBAXRqIRZBACEGA0BBACEFQQAhB0EAIQ4gCSAQRwRAA0AgCiAFIAhqQQF0ai4BACAFIAt0QQV0IAZqQZCBA2osAABsIAdqIAogBUEBciIDIAhqQQF0ai4BACADIAt0QQV0IAZqQZCBA2osAABsaiEHIAVBAmohBSAOQQJqIg4gFEcNAAsLIBYgBkEBdGoiAyADLwEAIBUEfyAKIAUgCGpBAXRqLgEAIAUgC3RBBXQgBmpBkIEDaiwAAGwgB2oFIAcLIBJqIBN1aiIDIAwgAyAMSBtBACADQQBOGzsBACAGQQFqIgYgAkcNAAsMAQsgACABIARsQQF0aiEGQQAhBUEAIQkgEARAA0AgBiAFQQF0aiIDIA0gAy8BAGoiByAMIAcgDEgbQQAgB0EAThs7AQAgAyANIAMvAQJqIgMgDCADIAxIG0EAIANBAE4bOwECIAVBAmohBSAJQQJqIgkgD0cNAAsLIBFFDQAgBiAFQQF0aiIDIA0gAy8BAGoiAyAMIAMgDEgbQQAgA0EAThs7AQALIARBAWoiBCACRw0ACwsgCkGAEGokAAvfCAEQfyMAQYAQayIJJABBBSEKIAJBAk4EQEEAIQogAiEEA0AgCiIFQQFqIQogBEEDSyETIARBAXYhBCATDQALQQQgBWshCgsCQCACQQBMDQAgAkH8////B3EhECACQQNxIQ4gAkEBayEPA0AgAyAHQQF0aiEMQQAhBCACIQUCQANAIAQhCyAFIghBAEwEQEEAIQVBACEEQQAhBiAPQQNPBEADQCAJIAIgBGwgB2pBAXRqQQA7AQAgCSAEQQFyIAJsIAdqQQF0akEAOwEAIAkgBEECciACbCAHakEBdGpBADsBACAJIARBA3IgAmwgB2pBAXRqQQA7AQAgBEEEaiEEIAZBBGoiBiAQRw0ACwsgDkUNAgNAIAkgAiAEbCAHakEBdGpBADsBACAEQQFqIQQgBUEBaiIFIA5HDQALDAILIAtBAWohBCAMIAhBAWsiBSACbEEBdGovAQBFDQALIAhB/v///wdxIREgCEEBcSEIQQAhBQNAQQAhBEEAIQZBACENIAsgD0cEQANAIAwgAiAEbEEBdGouAQAgBCAKdEEFdCAFakGQgQNqLAAAbCAGaiAMIARBAXIiBiACbEEBdGouAQAgBiAKdEEFdCAFakGQgQNqLAAAbGohBiAEQQJqIQQgDUECaiINIBFHDQALCyAJIAIgBWwgB2pBAXRqQYCAfkH//wEgCAR/IAwgAiAEbEEBdGouAQAgBCAKdEEFdCAFakGQgQNqLAAAbCAGagUgBgtBQGtBB3UiBCAEQf//AU4bIgQgBEGAgH5MGzsBACAFQQFqIgUgAkcNAAsLIAdBAWoiByACRw0ACyACQQBMDQAgAkH+////B3EhDCACQQFxIQ5BACELA0AgAiALbCEHQQAhBCACIQUCQAJAA0AgBCEIIAUiA0EATA0BIARBAWohBCAJIAVBAWsiBSAHakEBdGovAQBFDQALIANB/v///wdxIRAgA0EBcSERIAAgASALbGohEkEAIQUDQEEAIQRBACEGQQAhDSAIIA9HBEADQCAJIAQgB2pBAXRqLgEAIAQgCnRBBXQgBWpBkIEDaiwAAGwgBmogCSAEQQFyIgMgB2pBAXRqLgEAIAMgCnRBBXQgBWpBkIEDaiwAAGxqIQYgBEECaiEEIA1BAmoiDSAQRw0ACwsgBSASaiIDQf8BIAMtAAAgEQR/IAkgBCAHakEBdGouAQAgBCAKdEEFdCAFakGQgQNqLAAAbCAGagUgBgtBgBBqQQx1aiIDIANB/wFOG0EAIANBAE4bOgAAIAVBAWoiBSACRw0ACwwBCyAAIAEgC2xqIQVBACEEQQAhCCAPBEADQCAEIAVqIgNB/wEgAy0AACIGIAZB/wFPGzoAACADQf8BIAMtAAEiAyADQf8BTxs6AAEgBEECaiEEIAhBAmoiCCAMRw0ACwsgDkUNACAEIAVqIgNB/wEgAy0AACIDIANB/wFPGzoAAAsgC0EBaiILIAJHDQALCyAJQYAQaiQAC/0IARF/IwBBgBBrIgkkAEEFIQogAUECTgRAQQAhCiABIQUDQCAKIgtBAWohCiAFQQNLIRUgBUEBdiEFIBUNAAtBBCALayEKCwJAIAFBAEwNAEEAQQEgBHQiDmshDyAOQf//A2ohEiABQfz///8HcSETIAFBA3EhECABQQFrIREDQCACIAdBAXRqIQxBACEFIAEhBAJAA0AgBSEIIAQiC0EATARAQQAhBEEAIQVBACEGIBFBA08EQANAIAkgASAFbCAHakEBdGpBADsBACAJIAVBAXIgAWwgB2pBAXRqQQA7AQAgCSAFQQJyIAFsIAdqQQF0akEAOwEAIAkgBUEDciABbCAHakEBdGpBADsBACAFQQRqIQUgBkEEaiIGIBNHDQALCyAQRQ0CA0AgCSABIAVsIAdqQQF0akEAOwEAIAVBAWohBSAEQQFqIgQgEEcNAAsMAgsgCEEBaiEFIAwgC0EBayIEIAFsQQF0ai8BAEUNAAsgC0H+////B3EhFCALQQFxIQtBACEEA0BBACEFQQAhBkEAIQ0gCCARRwRAA0AgDCABIAVsQQF0ai4BACAFIAp0QQV0IARqQZCBA2osAABsIAZqIAwgBUEBciIGIAFsQQF0ai4BACAGIAp0QQV0IARqQZCBA2osAABsaiEGIAVBAmohBSANQQJqIg0gFEcNAAsLIAkgASAEbCAHakEBdGogDyALBH8gDCABIAVsQQF0ai4BACAFIAp0QQV0IARqQZCBA2osAABsIAZqBSAGC0FAa0EHdSIFIBIgBSAOSBsgBSAPSBs7AQAgBEEBaiIEIAFHDQALCyAHQQFqIgcgAUcNAAsgAUEATA0AIAFB+P///wdxIQ8gAUEHcSEOQQEgA0EBa3QiECADdSEIQQAhDANAIAEgDGwhB0EAIQUgASEEAkACQANAIAUhCyAEIgJBAEwNASAFQQFqIQUgCSAEQQFrIgQgB2pBAXRqLwEARQ0ACyACQf7///8HcSESIAJBAXEhAiAAIAdBAnRqIRNBACEEA0BBACEFQQAhBkEAIQ0gCyARRwRAA0AgCSAFIAdqQQF0ai4BACAFIAp0QQV0IARqQZCBA2osAABsIAZqIAkgBUEBciIGIAdqQQF0ai4BACAGIAp0QQV0IARqQZCBA2osAABsaiEGIAVBAmohBSANQQJqIg0gEkcNAAsLIBMgBEECdGogAgR/IAkgBSAHakEBdGouAQAgBSAKdEEFdCAEakGQgQNqLAAAbCAGagUgBgsgEGogA3U2AgAgBEEBaiIEIAFHDQALDAELIAAgB0ECdGohBUEAIQZBACEEQQAhDSARQQdPBEADQCAFIARBAnRqIgIgCDYCACACIAg2AgQgAiAINgIIIAIgCDYCDCACIAg2AhAgAiAINgIUIAIgCDYCGCACIAg2AhwgBEEIaiEEIA1BCGoiDSAPRw0ACwsgDkUNAANAIAUgBEECdGogCDYCACAEQQFqIQQgBkEBaiIGIA5HDQALCyAMQQFqIgwgAUcNAAsLIAlBgBBqJAAL5wIBBn8gASAAKAIIIgUgACgCBCIGa00EQCAAIAEEfyAGIAItAAAgARA0IAFqBSAGCzYCBA8LIAYgACgCACIEayIHIAFqIgNBAE4EQEH/////ByAFIARrIgVBAXQiCCADIAMgCEkbIAVB/////wNPGyIDBH8gAxAsBUEACyIFIANqIQggBSAHaiIDIAItAAAgARA0IAFqIQUgBCAGRwRAAkAgB0EDcSIHRQRAIAYhAQwBC0EAIQIgBiEBA0AgA0EBayIDIAFBAWsiAS0AADoAACACQQFqIgIgB0cNAAsLIAQgBmtBfE0EQANAIANBAWsgAUEBay0AADoAACADQQJrIAFBAmstAAA6AAAgA0EDayABQQNrLQAAOgAAIANBBGsiAyABQQRrIgEtAAA6AAAgASAERw0ACwsgACgCCBogACgCACEECyAAIAg2AgggACAFNgIEIAAgAzYCACAEBEAgBBAqCw8LEDYAC+8DAQV/IwBBEGsiBiQAIABB3BBqIgdBARCIBgRAIAAgACgC6AosAA1BA3RqIggoAtgFIQQCQCAIKALcBSIFRQRAIAZBADYCDAwBCyAFIAUoAgRBAWo2AgQgBiAFNgIMIAUgBSgCBEEBajYCBAsgBiAENgIIIAYgBikCCDcDAEEAIQQgByAGIABCAEEAQQAQgwYiB0EATgRAIAcgACgC6BAgACgC5BAiAGtBAnVJBEAgACAHQQJ0aigCACEEC0EBIAEoAsiDAUEBa3QhAEEBIAEoAsCDAUEBa3QiCEEATgRAIAQoAgQgCCAEKAIcIAQoAihsEDQaCyAAQQBOBEAgBCgCCCAAIAQoAiQgBCgCLGwQNBoLIABBAE4EQCAEKAIMIAAgBCgCJCAEKAIsbBA0GgsgBCgCpAFBAEoEQEEAIQADQCAEKAKgASAAQQNsaiIIIAgvAABB//kDcTsAACAAQQFqIgAgBCgCpAFIDQALCyAEIAI2AmAgASgC5IMBIQAgBEEAOgBoIARBAToAuAIgBEECQQEgAxs2AmQgBCAAQQFrIAJxNgJcCwJAIAVFDQAgBSAFKAIEIgBBAWs2AgQgAA0AIAUgBSgCACgCCBEAACAFECsLIAZBEGokACAHDwtBwJ4BQbz0AEGRC0G0zwAQAQALSgAgACABKAIANgIAIAEoAgQhASAAQQA6ABQgACACNgIQIABBADYCDCAAIAM2AgggACABNgIEIAMEQCAAIAMoAgxBAWo2AgwLIAALBABBfwu5BgEFfyMAQTBrIgMkACADQQA2AiwgA0IANwIkIAEoAhQiAigCMCEFIAIoAjQiAgRAIAIgAigCBEEBajYCBAsgBSgCNCEGIAUoAjgiBQRAIAUgBSgCBEEBajYCBAsCQCACRQ0AIAIgAigCBCIEQQFrNgIEIAQNACACIAIoAgAoAggRAAAgAhArCyABKAIUIgIoAjAhBCACKAI0IgIEQCACIAIoAgRBAWo2AgQLIAMgBCgCPDYCHCADIAQoAkAiBDYCICAEBEAgBCAEKAIEQQFqNgIECwJAIAJFDQAgAiACKAIEIgRBAWs2AgQgBA0AIAIgAigCACgCCBEAACACECsLIANBCGogBiABKAIkIANBHGogA0EkahDdBSADKAIIIQEgAEEANgIIIABCADcCAAJAAkAgAQRAIAAgAykDCDcCDCAAQRRqIQAgAywAG0EATgRAIAAgAykCEDcCACAAIAMoAhg2AggMAgsgACADKAIQIAMoAhQQLgwBCyADKAIoIgYgAygCJCIBRwRAIAYgAWsiBEEASA0CIAAgBBAsIgI2AgQgACACNgIAIAAgAiAEajYCCANAIAIgASgCADYCACACIAEoAgQiBDYCBCAEBEAgBCAEKAIEQQFqNgIECyACQQhqIQIgAUEIaiIBIAZHDQALIAAgAjYCBAsgAEGQpQUpAgA3AgwgAEEUaiEAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyADLAAbQQBIBEAgAygCGBogAygCEBAqCwJAIAMoAiAiAEUNACAAIAAoAgQiAUEBazYCBCABDQAgACAAKAIAKAIIEQAAIAAQKwsCQCAFRQ0AIAUgBSgCBCIAQQFrNgIEIAANACAFIAUoAgAoAggRAAAgBRArCyADKAIkIgAEQCADKAIoIgIgACIBRwRAA0ACQCACQQRrKAIAIgFFDQAgASABKAIEIgVBAWs2AgQgBQ0AIAEgASgCACgCCBEAACABECsLIAJBCGsiAiAARw0ACyADKAIkIQELIAMgADYCKCADKAIsGiABECoLIANBMGokAA8LEDYACxgAIABBDGogACgCECABIAEgAmogAhDFAQvoAgEIfyAAKAJsIgQgACgCcCIFSQRAIAQgAToAACAAIARBAWo2AmwPCyAEIAAoAmgiBmsiAkEBaiIDQQBOBEAgAkH/////ByAFIAZrIgVBAXQiByADIAMgB0kbIAVB/////wNPGyIHBH8gBxAsBUEACyIFaiIDIAE6AAAgBSAHaiEIIANBAWohBwJAIAQgBkYEQCADIQUMAQsCQCACQQNxIglFBEAgBCECDAELQQAhASAEIQIDQCADQQFrIgMgAkEBayICLQAAOgAAIAFBAWoiASAJRw0ACwsgBiAEa0F8TQRAA0AgA0EBayACQQFrLQAAOgAAIANBAmsgAkECay0AADoAACADQQNrIAJBA2stAAA6AAAgA0EEayIDIAJBBGsiAi0AADoAACACIAZHDQALCyAAKAJwGiAAKAJoIQYLIAAgCDYCcCAAIAc2AmwgACAFNgJoIAYEQCAGECoLIAAgBzYCbA8LEDYAC8EVAQJ/AkACQAJAAkACQAJAAkAgAkEBaw4KAQYAAgMGBAYFBAYLQZADECwiA0IANwIUIANCADcCBCADQQA6AKgBIAMgATYCJCADQa4gNgIgIANCADcDKCADQgA3AkQgA0IANwJUIANCADcDYCADQgA3AqwBIANBkIUFNgIAIANBADYCHCADQgA3AzAgA0IANwM4IANBQGtBADsBACADQgA3AUogA0EAOgBcIANBADoAaCADQgA3ArQBIANCADcCvAEgA0IANwLEASADQgA3AswBIANCADcC1AEgA0EANgLcASADQQA2ArACIANCADcDqAIgA0EBOgDgASADQgA3AuQBIANCADcA6QEgA0IANwP4ASADQgA3A4ACIANCADcDiAIgA0IANwOQAiADQgA3A5gCIANBADoAoAIgA0EBOwG0AiADQgA3A7gCIANCADcDwAIgA0IANwPIAiADQQA2AoADIANCADcC+AIgA0KAgICAgICA+D83A9ACIANCADcDoAEgA0IANwOYASADQgA3A5ABIANCADcDiAEgA0IANwOAASADQgA3A3ggA0IANwNwIANBADYC8AIgA0IANwPoAiADQgA3A+ACIANCADcD2AIgA0IANwKEAyADQfj4BDYCECADQRBqIQQMBQtBkAMQLCIDQgA3AhQgA0IANwIEIANBADoAqAEgAyABNgIkIANBriA2AiAgA0IANwMoIANCADcCRCADQgA3AlQgA0IANwNgIANCADcCrAEgA0G4hQU2AgAgA0EANgIcIANCADcDMCADQgA3AzggA0FAa0EAOwEAIANCADcBSiADQQA6AFwgA0EAOgBoIANCADcCtAEgA0IANwK8ASADQgA3AsQBIANCADcCzAEgA0IANwLUASADQQA2AtwBIANBADYCsAIgA0IANwOoAiADQQE6AOABIANCADcC5AEgA0IANwDpASADQgA3A/gBIANCADcDgAIgA0IANwOIAiADQgA3A5ACIANCADcDmAIgA0EAOgCgAiADQQE7AbQCIANCADcDuAIgA0IANwPAAiADQgA3A8gCIANBADYCgAMgA0IANwL4AiADQoCAgICAgID4PzcD0AIgA0IANwOgASADQgA3A5gBIANCADcDkAEgA0IANwOIASADQgA3A4ABIANCADcDeCADQgA3A3AgA0EANgLwAiADQgA3A+gCIANCADcD4AIgA0IANwPYAiADQgA3AoQDIANB6PMENgIQIANBEGohBAwEC0GQAxAsIgNCADcCFCADQgA3AgQgA0EAOgCoASADIAE2AiQgA0GuIDYCICADQgA3AyggA0IANwJEIANCADcCVCADQgA3A2AgA0IANwKsASADQeCFBTYCACADQQA2AhwgA0IANwMwIANCADcDOCADQUBrQQA7AQAgA0IANwFKIANBADoAXCADQQA6AGggA0IANwK0ASADQgA3ArwBIANCADcCxAEgA0IANwLMASADQgA3AtQBIANBADYC3AEgA0EANgKwAiADQgA3A6gCIANBAToA4AEgA0IANwLkASADQgA3AOkBIANCADcD+AEgA0IANwOAAiADQgA3A4gCIANCADcDkAIgA0IANwOYAiADQQA6AKACIANBATsBtAIgA0IANwO4AiADQgA3A8ACIANCADcDyAIgA0EANgKAAyADQgA3AvgCIANCgICAgICAgPg/NwPQAiADQgA3A6ABIANCADcDmAEgA0IANwOQASADQgA3A4gBIANCADcDgAEgA0IANwN4IANCADcDcCADQQA2AvACIANCADcD6AIgA0IANwPgAiADQgA3A9gCIANCADcChAMgA0GE9gQ2AhAgA0EQaiEEDAMLQZADECwiA0IANwIUIANCADcCBCADQQA6AKgBIAMgATYCJCADQa4gNgIgIANCADcDKCADQgA3AkQgA0IANwJUIANCADcDYCADQgA3AqwBIANBiIYFNgIAIANBADYCHCADQgA3AzAgA0IANwM4IANBQGtBADsBACADQgA3AUogA0EAOgBcIANBADoAaCADQgA3ArQBIANCADcCvAEgA0IANwLEASADQgA3AswBIANCADcC1AEgA0EANgLcASADQQA2ArACIANCADcDqAIgA0EBOgDgASADQgA3AuQBIANCADcA6QEgA0IANwP4ASADQgA3A4ACIANCADcDiAIgA0IANwOQAiADQgA3A5gCIANBADoAoAIgA0EBOwG0AiADQgA3A7gCIANCADcDwAIgA0IANwPIAiADQQA2AoADIANCADcC+AIgA0KAgICAgICA+D83A9ACIANCADcDoAEgA0IANwOYASADQgA3A5ABIANCADcDiAEgA0IANwOAASADQgA3A3ggA0IANwNwIANBADYC8AIgA0IANwPoAiADQgA3A+ACIANCADcD2AIgA0IANwKEAyADQeD+BDYCECADQRBqIQQMAgtBkAMQLCIDQgA3AhQgA0IANwIEIANBADoAqAEgAyABNgIkIANBriA2AiAgA0IANwMoIANCADcCRCADQgA3AlQgA0IANwNgIANCADcCrAEgA0HchwU2AgAgA0EANgIcIANCADcDMCADQgA3AzggA0FAa0EAOwEAIANCADcBSiADQQA6AFwgA0EAOgBoIANCADcCtAEgA0IANwK8ASADQgA3AsQBIANCADcCzAEgA0IANwLUASADQQA2AtwBIANBADYCsAIgA0IANwOoAiADQQE6AOABIANCADcC5AEgA0IANwDpASADQgA3A/gBIANCADcDgAIgA0IANwOIAiADQgA3A5ACIANCADcDmAIgA0EAOgCgAiADQQE7AbQCIANCADcDuAIgA0IANwPAAiADQgA3A8gCIANBADYCgAMgA0IANwL4AiADQoCAgICAgID4PzcD0AIgA0IANwOgASADQgA3A5gBIANCADcDkAEgA0IANwOIASADQgA3A4ABIANCADcDeCADQgA3A3AgA0EANgLwAiADQgA3A+gCIANCADcD4AIgA0IANwPYAiADQgA3AoQDIANB3PoENgIQIANBEGohBAwBC0GIAxAsIgNCADcCFCADQgA3AgQgA0EAOgCoASADIAE2AiQgA0GuIDYCICADQgA3AyggA0IANwJEIANCADcCVCADQgA3A2AgA0IANwKsASADQYSIBTYCACADQQA2AhwgA0IANwMwIANCADcDOCADQUBrQQA7AQAgA0IANwFKIANBADoAXCADQQA6AGggA0IANwK0ASADQgA3ArwBIANCADcCxAEgA0IANwLMASADQgA3AtQBIANBADYC3AEgA0EANgKwAiADQgA3A6gCIANBAToA4AEgA0IANwLkASADQgA3AOkBIANCADcD+AEgA0IANwOAAiADQgA3A4gCIANCADcDkAIgA0IANwOYAiADQQA6AKACIANBATsBtAIgA0IANwO4AiADQgA3A8ACIANCADcDyAIgA0EANgKAAyADQgA3AvgCIANCgICAgICAgPg/NwPQAiADQgA3A6ABIANCADcDmAEgA0IANwOQASADQgA3A4gBIANCADcDgAEgA0IANwN4IANCADcDcCADQQA2AvACIANCADcD6AIgA0IANwPgAiADQgA3A9gCIANBrIMFNgIQIANBEGohBAsgACADNgIEIAAgBDYCAAsIACAAEHQQKgsPACAAIAAoAgAoAgwRAQALwQEBBH8CQAJAIAMEQCADQdaq1aoBTw0BIAAgA0EMbCIEECwiAzYCBCAAIAM2AgAgACADIARqNgIIIAEgAkcEQANAIANBADYCCCADQgA3AgAgASgCBCIEIAEoAgAiBkcEQCAEIAZrIgRBAEgNBSADIAQQLCIFNgIEIAMgBTYCACADIAQgBWoiBzYCCCAFIAYgBBAyGiADIAc2AgQLIANBDGohAyABQQxqIgEgAkcNAAsLIAAgAzYCBAsPCxA2AAsQNgALnQMBB38CQCAAKAIEIAAoAgAiAmtBDG0iBUEBaiIGQdaq1aoBSQRAQdWq1aoBIAAoAgggAmtBDG0iA0EBdCICIAYgAiAGSxsgA0Gq1arVAE8bIgIEQCACQdaq1aoBTw0CIAJBDGwQLCEHCyAHIAVBDGxqIgMgASgCADYCACADIAEoAgQ2AgQgAyABKAIINgIIIAFBADYCCCABQgA3AgAgByACQQxsaiEGIANBDGohCAJAIAAoAgQiASAAKAIAIgRGBEAgAyECDAELA0AgA0EEayIHQQA2AgAgA0EMayICIAFBDGsiBSgCADYCACADQQhrIAFBCGsoAgA2AgAgByABQQRrIgEoAgA2AgAgAUEANgIAIAVCADcCACACIQMgBSIBIARHDQALIAAoAgQhASAAKAIAIQQLIAAgCDYCBCAAIAI2AgAgACgCCBogACAGNgIIIAEgBEcEQANAIAFBDGsiACgCACIC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IBJCIHwiEyAHKQMwIhFWBEAgByACKAIAIgUgEiATIAUoAgAoAhgRFgAiETcDMAsgESATVARAIANBGBAsIgI2AmAgA0KXgICAgIOAgIB/NwJkIAJBiPkAKQAANwAAIAJBADoAFyACQZf5ACkAADcADyACQZD5ACkAADcACCAJQQJBACADQeAAahAvGiADLABrQQBODQIgAygCaBogAygCYBAqDAILIAMgBygCODYCiAEgAyAHKAI8IgU2AowBIAUEQCAFIAUoAgRBAWo2AgQgBykDMCERCyADIAMpAogBNwMIIANBkAFqIANBCGogEqciCCARpxDVAyEGIANB4ABqIgVCADcDCCAFQgA3AxAgBUIANwMYIAVBADYCICAFQdS9BDYCACADQcgAaiAFIAYQrQIgAyADKQNIIhE3A9ABIAMsAOMBQQBOBH8gEacFIAMoAuABGiADKALYARAqIAMoAtABCyEGIAMgAykDUDcD2AEgAyADKAJYNgLgAQJAIAYEQCAJIAMpA9ABNwIAIAkgAygC4AE2AhAgCSADKQLYATcCCCADQgA3A9gBIANBADYC4AFBASEGDAELIAMpA2ghESADKAJwQeHolesGRgRAIBFQBEAgA0EwECwiBjYCSCADQqqAgICAhoCAgH83AkwgBkHWywApAAA3AAAgBkEAOgAqIAZB/ssALwAAOwAoIAZB9ssAKQAANwAgIAZB7ssAKQAANwAYIAZB5ssAKQAANwAQIAZB3ssAKQAANwAIIAlBAkHoACADQcgAahAvGiADLABTQQBIBEAgAygCUBogAygCSBAqC0EBIQYMAgsgBykDMCITIBEgEnwiEVQEQCAHIAcoAjgiBiASIBEgBigCACgCGBEWACITNwMwCyARIBNWBEAgA0EgECwiBjYCSCADQpmAgICAhICAgH83AkwgBkHSESkAADcAACAGQQA6ABkgBkHqES0AADoAGCAGQeIRKQAANwAQIAZB2hEpAAA3AAggCUECQegAIANByABqEC8aIAMsAFNBAEgEQCADKAJQGiADKAJIECoLQQEhBgwCCyADIAcoAjg2AkAgAyAHKAI8IgY2AkQgBgRAIAYgBigCBEEBajYCBAsgAyADKQJANwMAIANByABqIAMgCCARpxDVAyEGIANCADcCOCADQSBqIAYgA0E4aiAKEPsBIAMgAykDICIR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ADcCtAEgAkIANwKsASACQQA2ArACIAJCADcDqAIgAkEBOgDgASACQgA3AuQBIAJCADcA6QEgAkIANwP4ASACQgA3A4ACIAJCADcDiAIgAkIANwOQAiACQgA3A5gCIAJBADoAoAIgAkEBOwG0AiACQgA3A7gCIAJCADcDwAIgAkIANwPIAiACQQA2AoADIAJCADcC+AIgAkKAgICAgICA+D83A9ACIAJCADcDoAEgAkIANwOYASACQgA3A5ABIAJCADcDiAEgAkIANwOAASACQgA3A3ggAkIANwNwIAJBADYC8AIgAkIANwPoAiACQgA3A+ACIAJCADcD2AIgAkIANwKEAyACIAU2AjQgAkHc+gQ2AhAgA0EkaiIFIAI2AgQgBSACQRBqNgIAIAQgAygCJDYChAIgBCADKAIoNgKIAiADQgA3AiQgBRBtDAkLIAJB6NbN6wZMBEAgAkHnysHTBkcEQCACQbHsoeMGRg0GIAJB5dql6wZHDQkgBSgChAEgBSwAiwEiAiACQQBIIgIbQQpHDQkgBSgCgAEgBUGAAWogAhtBr8gAQQoQXw0JC0GQAxAsIgJCADcCFCACQgA3AgQgAkEAOgCoASACIAE2AiQgAkGuIDYCICACQgA3AyggAkIANwJEIAJCADcCVCACQgA3A2AgAkIANwKsASACQZCFBTYCACACQQA2AhwgAkIANwMwIAJCADcDOCACQUBrQQA7AQAgAkIANwFKIAJBADoAXCACQQA6AGggAkIANwK0ASACQgA3ArwBIAJCADcCxAEgAkIANwLMASACQgA3AtQBIAJBADYC3AEgAkEANgKwAiACQgA3A6gCIAJBAToA4AEgAkIANwLkASACQgA3AOkBIAJCADcD+AEgAkIANwOAAiACQgA3A4gCIAJCADcDkAIgAkIANwOYAiACQQA6AKACIAJBATsBtAIgAkIANwO4AiACQgA3A8ACIAJCADcDyAIgAkEANgKAAyACQgA3AvgCIAJCgICAgICAgPg/NwPQAiACQgA3A6ABIAJCADcDmAEgAkIANwOQASACQgA3A4gBIAJCADcDgAEgAkIANwN4IAJCADcDcCACQQA2AvACIAJCADcD6AIgAkIANwPgAiACQgA3A9gCIAJCADcChAMgAiAGNgI0IAJB+PgENgIQIAQgAjYCiAIgBCACQRBqNgKEAgwJCyACQejGuasHTARAIAJB6dbN6wZGDQYgAkHp2KWjB0cNCEH4AxAsIgVCADcCBCAFQaSJBTYCACAFQRBqIAMoArwBIAMoArQBENABIgJCADcCtAMgAkIANwPYAyACQQA6ANQDIAJBgIAENgLQAyACQgA3A8gDIAJBhIwFNgIAIAJCADcCvAMgAkIANwPgAyADQSRqIgYgBTYCBCAGIAI2AgAgBCADKAIkNgKEAiAEIAMoAig2AogCIANCADcCJCAGEG0MCQsgAkHpxrmrB0YNAyACQbHG2bMHRw0HQZADECwiAkIANwIUIAJCADcCBCACQQA6AKgBIAIgATYCJCACQa4gNgIgIAJCADcDKCACQgA3AkQgAkIANwJUIAJCADcDYCACQgA3AqwBIAJBiIYFNgIAIAJBADYCHCACQgA3AzAgAkIANwM4IAJBQGtBADsBACACQgA3AUogAkEAOgBcIAJBADoAaCACQgA3ArQBIAJCADcCvAEgAkIANwLEASACQgA3AswBIAJCADcC1AEgAkEANgLcASACQQA2ArACIAJCADcDqAIgAkEBOgDgASACQgA3AuQBIAJCADcA6QEgAkIANwP4ASACQgA3A4ACIAJCADcDiAIgAkIANwOQAiACQgA3A5gCIAJBADoAoAIgAkEBOwG0AiACQgA3A7gCIAJCADcDwAIgAkIANwPIAiACQQA2AoADIAJCADcC+AIgAkKAgICAgICA+D83A9ACIAJCADcDoAEgAkIANwOYASACQgA3A5ABIAJCADcDiAEgAkIANwOAASACQgA3A3ggAkIANwNwIAJBADYC8AIgAkIANwPoAiACQgA3A+ACIAJCADcD2AIgAkIANwKEAyACIAY2AjQgAkHg/gQ2AhAgBCACNgKIAiAEIAJBEGo2AoQCDAgLQZADECwiAkIANwIUIAJCADcCBCACQQA6AKgBIAIgATYCJCACQa4gNgIgIAJCADcDKCACQgA3AkQgAkIANwJUIAJCADcDYCACQgA3AqwBIAJBuIUFNgIAIAJBADYCHCACQgA3AzAgAkIANwM4IAJBQGtBADsBACACQgA3AUogAkEAOgBcIAJBADoAaCACQgA3ArQBIAJCADcCvAEgAkIANwLEASACQgA3AswBIAJCADcC1AEgAkEANgLcASACQQA2ArACIAJCADcDqAIgAkEBOgDgASACQgA3AuQBIAJCADcA6QEgAkIANwP4ASACQgA3A4ACIAJCADcDiAIgAkIANwOQAiACQgA3A5gCIAJBADoAoAIgAkEBOwG0AiACQgA3A7gCIAJCADcDwAIgAkIANwPIAiACQQA2AoADIAJCADcC+AIgAkKAgICAgICA+D83A9ACIAJCADcDoAEgAkIANwOYASACQgA3A5ABIAJCADcDiAEgAkIANwOAASACQgA3A3ggAkIANwNwIAJBADYC8AIgAkIANwPoAiACQgA3A+ACIAJCADcD2AIgAkIANwKEAyACIAY2AjQgAkHo8wQ2AhAgBCACNgKIAiAEIAJBEGo2AoQCDAcLQZADECwiAkIANwIUIAJCADcCBCACQQA6AKgBIAIgATYCJCACQa4gNgIgIAJCADcDKCACQgA3AkQgAkIANwJUIAJCADcDYCACQgA3AqwBIAJB4IUFNgIAIAJBADYCHCACQgA3AzAgAkIANwM4IAJBQGtBADsBACACQgA3AUogAkEAOgBcIAJBADoAaCACQgA3ArQBIAJCADcCvAEgAkIANwLEASACQgA3AswBIAJCADcC1AEgAkEANgLcASACQQA2ArACIAJCADcDqAIgAkEBOgDgASACQgA3AuQBIAJCADcA6QEgAkIANwP4ASACQgA3A4ACIAJCADcDiAIgAkIANwOQAiACQgA3A5gCIAJBADoAoAIgAkEBOwG0AiACQgA3A7gCIAJCADcDwAIgAkIANwPIAiACQQA2AoADIAJCADcC+AIgAkKAgICAgICA+D83A9ACIAJCADcDoAEgAkIANwOYASACQgA3A5ABIAJCADcDiAEgAkIANwOAASACQgA3A3ggAkIANwNwIAJBADYC8AIgAkIANwPoAiACQgA3A+ACIAJCADcD2AIgAkIANwKEAyACIAY2AjQgAkGE9gQ2AhAgBCACNgKIAiAEIAJBEGo2AoQCDAYLQZADECwiAkIANwIUIAJCADcCBCACQQA6AKgBIAIgATYCJCACQa4gNgIgIAJCADcDKCACQgA3AkQgAkIANwJUIAJCADcDYCACQgA3AqwBIAJBsIYFNgIAIAJBADYCHCACQgA3AzAgAkIANwM4IAJBQGtBADsBACACQgA3AUogAkEAOgBcIAJBADoAaCACQgA3ArQBIAJCADcCvAEgAkIANwLEASACQgA3AswBIAJCADcC1AEgAkEANgLcASACQQA2ArACIAJCADcDqAIgAkEBOgDgASACQgA3AuQBIAJCADcA6QEgAkIANwP4ASACQgA3A4ACIAJCADcDiAIgAkIANwOQAiACQgA3A5gCIAJBADoAoAIgAkEBOwG0AiACQgA3A7gCIAJCADcDwAIgAkIANwPIAiACQQA2AoADIAJCADcC+AIgAkKAgICAgICA+D83A9ACIAJCADcDoAEgAkIANwOYASACQgA3A5ABIAJCADcDiAEgAkIANwOAASACQgA3A3ggAkIANwNwIAJBADYC8AIgAkIANwPoAiACQgA3A+ACIAJCADcD2AIgAkIANwKEAyACIAY2AjQgAkGAgQU2AhAgBCACNgKIAiAEIAJBEGo2AoQCDAULIANBJGoQvwQiC0EIakHKpQFBFBAtISsgA0EQaiIFIAMoArgBEKQBICsgAygCECAFIAMsABsiAkEASCIFGyADKAIUIAIgBRsQLUHCmwFBExAtGiADLAAbQQBIBEAgAygCGBogAygCEBAqCyADQQRqIgIgCxC+BCADQRBqQQRBuRcgAhAvIQYgAywAD0EASARAIAMoAgwaIAMoAgQQKgsgA0EEaiEKQaADECwiEUIANwIEIBFB2IYFNgIAIBFBEGohAiMAQSBrIgUkACADKAK0ASEQIAMoArgBIQ8gBSAGKQIAIjs3AwggBUEQaiEIAkAgBiwAE0EATgRAIAggBikCCDcCACAIIAYoAhA2AggMAQsgCCAGKAIIIAYoAgwQLiAFKQMIITsLIAJCADcCBCACQQA6AJgBIAJCADcCNCACQgA3AkQgAkIANwNQIAJCADcCnAEgAkEANgIMIAJBriA2AhAgAkIANwE6IAJBADoATCACQQA6AFggAkIANwKkASACQgA3AqwBIAJCADcCtAEgAkIANwK8ASACQgA3AsQBIAJBADYCzAEgAkIANwEqIAJCADcCJCACQgA3AhwgAkIANwIUIAJBADYCoAIgAkIANwOYAiACQQE6ANABIAJCADcC1AEgAkIANwDZASACQgA3A+gBIAJCADcD8AEgAkIANwP4ASACQgA3A4ACIAJCADcDiAIgAkEAOgCQAiACQQE7AaQCIAJCADcDqAIgAkIANwOwAiACQgA3A7gCIAJBADYC8AIgAkIANwLoAiACQoCAgICAgID4PzcDwAIgAkIANwOQASACQgA3A4gBIAJCADcDgAEgAkIANwN4IAJCADcDcCACQgA3A2ggAkIANwNgIAJBADYC4AIgAkIANwPYAiACQgA3A9ACIAJCADcDyAIgAiA7NwL4AiACIBA2AiQgAiAPNgL0AiACQYCHBTYCACACQYADaiEQAkAgBSwAG0EATgRAIBAgCCkDADcDACAQIAgoAgg2AggMAQsgECAFKAIQIAUoAhQQLiAFLAAbQQBODQAgBSgCGBogBSgCEBAqCyAFQSBqJAAgCiARNgIEIAogAjYCACAEIAMoAgQ2AoQCIAQgAygCCDYCiAIgA0IANwIEIAoQbSAGLAATQQBIBEAgBigCEBogBigCCBAqCyALEOkBGgwECyADQSRqQQRBuRcgA0EQakGuHBCAASIGEC8hBSAEAn9BoAMQLCICQgA3AgQgAkHYhgU2AgAgBSgCDCEKIAUoAgghCCADKAK4ASEQIAMoArQBIQsgBUIANwIIIAUoAhAhESAFQQA2AhAgBSkCACE7IAJBADYCHCACQgA3AhQgAkEAOgCoASACQa4gNgIgIAJCADcCRCACQgA3AUogAkIANwJUIAJBADoAXCACQgA3A2AgAkEAOgBoIAJCADcCrAEgAkIANwK0ASACQgA3ArwBIAJCADcCxAEgAkIANwLMASACQgA3AtQBIAJBADYC3AEgAkIANwE6IAJCADcCNCACQgA3AiwgAkIANwIkIAJBADYCsAIgAkIANwOoAiACQQE6AOABIAJCADcC5AEgAkIANwDpASACQgA3A/gBIAJCADcDgAIgAkIANwOIAiACQgA3A5ACIAJCADcDmAIgAkEAOgCgAiACQQE7AbQCIAJCADcDuAIgAkIANwPAAiACQgA3A8gCIAJBADYCgAMgAkIANwP4AiACQoCAgICAgID4PzcD0AIgAkIANwOgASACQgA3A5gBIAJCADcDkAEgAkIANwOIASACQgA3A4ABIAJCADcDeCACQgA3A3AgAkEANgLwAiACQgA3A+gCIAJCADcD4AIgAkIANwPYAiACIDs3A4gDIAIgCzYCNCACIBA2AoQDIAJBgIcFNgIQIBFBAE4EQCACIBE2ApgDIAIgCjYClAMgAiAINgKQAyACDAELIAJBkANqIAggChAuIAgQKiACCyICNgKIAiAEIAJBEGo2AoQCIANCADcCBCADQQRqEG0gBSwAE0EASARAIAUoAhAaIAUoAggQKgsgBiwAC0EATg0DIAYoAggaIAYoAgAQKgwDC0GIAxAsIgJCADcCBCACQYSIBTYCACADKAK0ASEFIAMoArwBIQYgAkEANgIcIAJCADcCFCACQQA6AKgBIAIgBjYCJCACQa4gNgIgIAJCADcDKCACQgA3AzAgAkIANwM4IAJBQGtBADsBACACQgA3AkQgAkIANwFKIAJCADcCVCACQQA6AFwgAkIANwNgIAJBADoAaCACQQA2AtwBIAJCADcC1AEgAkIANwLMASACQgA3AsQBIAJCADcCvAEgAkIANwK0ASACQgA3AqwBIAJBADYCsAIgAkIANwOoAiACQQE6AOABIAJCADcC5AEgAkIANwDpASACQgA3A/gBIAJCADcDgAIgAkIANwOIAiACQgA3A5ACIAJCADcDmAIgAkEAOgCgAiACQQE7AbQCIAJCADcDuAIgAkIANwPAAiACQgA3A8gCIAJBADYCgAMgAkIANwL4AiACQoCAgICAgID4PzcD0AIgAkIANwOgASACQgA3A5gBIAJCADcDkAEgAkIANwOIASACQgA3A4ABIAJCADcDeCACQgA3A3AgAkEANgLwAiACQgA3A+gCIAJCADcD4AIgAkIANwPYAiACIAU2AjQgAkGsgwU2AhAgA0EkaiIFIAI2AgQgBSACQRBqNgIAIAQgAygCJDYChAIgBCADKAIoNgKIAiADQgA3AiQgBRBtDAILQbADECwiBUIANwIEIAVB1IgFNgIAIAVBEGogAygCvAEgAygCtAEQ0AEiAkIANwL0AiACQgA3A4ADIAJBtIoFNgIAIAJBADsB/AIgAkIANwOIAyACQgA3A5ADIAJCADcDmAMgA0EkaiIGIAU2AgQgBiACNgIAIAQgAygCJDYChAIgBCADKAIoNgKIAiADQgA3AiQgBhBtDAELIARCADcChAILIANBwAFqJAACQCAEKAKEAiIIRQRAQQMhCgwBCyAEKAKIAiIFBEAgBSAFKAIEQQFqNgIECwJAAkACQCANIgYiAygCACICRQ0AA0AgAiIDKAIQIgIgCUsEQCADIQYgAygCACICDQEMAgsgAiAJTw0CIAMoAgQiAg0ACyADQQRqIQYLQRwQLCICIAU2AhggAiAINgIUIAIgCTYCECACIAM2Aggg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IRgDQCAEQagCaiAUIAIoAhQoAiQQpgMCQCAEKAKoAiIKIAQoAqwCIidGBEBBEiEHDAELIAJBFGohDwJ/AkACQANAAkAgCigCECIDQezw1YsGRwRAIANB4tqhowdHDQEgBEEANgJoIARCADcCYAJ/AkAgCigCMCIDIAooAiwiBUYiBw0AIAMgBWsiA0EASA0PIAQgAxAsIgg2AmAgBCADIAhqIgY2AmggCCAFIAMQMhogBCAGNgJkIAcNAANAIAgoAgAhByAPKAIAIglBAToAMQJAAkAgDSIFKAIAIgNFDQADQCAFIAMgAygCECAHSSILGyEFIAMgC0ECdGooAgAiAw0ACyAFIA1GDQAgByAFKAIQTw0BCyAEQTAQLCIDNgLwASAEQqmAgICAhoCAgH83AvQBIANBq9wAKQAANwAAIANBADoAKSADQdPcAC0AADoAKCADQcvcACkAADcAICADQcPcACkAADcAGCADQbvcACkAADcAECADQbPcACkAADcACCAAQQJB0A8gBEHwAWoQLxogBCwA+wFBAEgEQCAEKAL4ARogBCgC8AEQKgtBAAwDCyAFKAIUIgMtADFBAUYEQCAEQSgQLCIDNgLwASAEQqaAgICAhYCAgH83AvQBIANB9z4pAAA3AAAgA0EAOgAmIANBlT8pAAA3AB4gA0GPPykAADcAGCADQYc/KQAANwAQIANB/z4pAAA3AAggAEECQdAPIARB8AFqEC8aIAQsAPsBQQBIBEAgBCgC+AEaIAQoAvABECoLQQAMAwsgAyAJRgRAIARBKBAsIgM2AvABIARCooCAgICFgICAfzcC9AEgA0GL6QApAAA3AAAgA0EAOgAiIANBq+kALwAAOwAgIANBo+kAKQAANwAYIANBm+kAKQAANwAQIANBk+kAKQAANwAIIABBAkHQDyAEQfABahAvGiAELAD7AUEASARAIAQoAvgBGiAEKALwARAqC0EADAMLIAMCfyADKAI4IgUgAygCPEkEQCAFIAk2AgAgBSACKAIYIgM2AgQgAwRAIAMgAygCBEEBajYCBAsgBUEIagwBCyADQTRqIA8QYQs2AjggCEEEaiIIIAZHDQALCyABIA8QmANBAQshMiAEKAJgIgMEQCAEIAM2AmQgBCgCaBogAxAqCyAyDQFBAQwFCwJAAkACQAJAAkACQAJAAkACQCAPKAIAIgUoAhgiAyAFKAIcIgVHBEADQAJAIAMoAgAiBkUNACAGQaC/BEHYxwQQOSIMRQ0AIAMoAgQiEgRAIBIgEigCBEEBajYCBAtBACELIARBADYCaCAEQgA3AmBBACEJIAooAjAiAyAKKAIsIgVHBEAgAyAFayIDQQBIDRkgBCADECwiCTYCYCAEIAMgCWoiCzYCaCAJIAUgAxAyGiAEIAs2AmQLIAxB6ABqIQ4gDCgCbCIFIAwsAHMiAyADQQBIIgYbIgdBGWsOEwMEBwcHBwcHBwcHBwcHBwcHBwUHCyADQQhqIgMgBUcNAAsLIAQgITYCYCAEQaDTAzYCaCAEQbTTAzYCoAEgBEHgAGoiAyAiKAIAaiAWNgIAIARBADYCZCADIAQoAmBBDGsoAgBqIgUgGRA+IAVCgICAgHA3AkggBCAfNgJoIBogICgCAGogJjYCACAEIB02AmAgAyAeKAIAaiAlNgIAIARBtNMDNgKgASAEQYzTAzYCYCAEQaDTAzYCaCAZED8iB0HwywM2AgAgBEIANwKUASAEQgA3AowBIARBGDYCnAEgGkGxrgFBGxAtIA8oAgAoAiQQPBoCQCAEKAKcASIDQRBxBEAgECEDIAQoApgBIgYgBCgChAEiBU8NASAEIAU2ApgBIAUhBgwBCyADQQhxRQRAQQAhAyAEQQA6APsBIARB8AFqIQYMDgsgBCgCfCEGIBEhAwsgBiADKAIAIgVrIgNB+P///wdPDQUgA0ELTwRAIANBB3JBAWoiCRAsIQYgBCAJQYCAgIB4cjYC+AEgBCAGNgLwASAEIAM2AvQBDAwLIAQgAzoA+wEgBEHwAWohBiADDQtBACEDDAwLIA4oAgAgDiAGG0H0jQFBGRBfDQMgCSALRw0CDAMLIA4oAgAgDiAGG0HZjQEgBxBfDQIgCSALRw0BDAILIA4oAgAgDiAGG0Gp+gAgBxBfDQEgCSALRg0BCwNAIAkoAgAhBgJAAkACQCANIgUoAgAiA0UNAANAIAUgAyADKAIQIAZJIgcbIQUgAyAHQQJ0aigCACIDDQALIAUgDUYNACAGIAUoAhBPDQELIAEoAjAgBhC7Ag0BIARBKBAsIgM2AvABIARCo4CAgICFgICAfzcC9AEgA0G48QApAAA3AAAgA0EAOgAjIANB1/EAKAAANgAfIANB0PEAKQAANwAYIANByPEAKQAANwAQIANBwPEAKQAANwAIIABBAkHQDyAEQfABahAvGiAELAD7AUEASARAIAQoAvgBGiAEKALwARAqC0EBIQMMBgsgBSgCFCEHIAUoAhgiBQRAIAUgBSgCBEEBajYCBAsCQCAHIA8oAgAiCEYEQCAEQSAQLCIDNgLwASAEQp6AgICAhICAgH83AvQBIANBzekAKQAANwAAIANBADoAHiADQePpACkAADcAFiADQd3pACkAADcAECADQdXpACkAADcACCAAQQJB0A8gBEHwAWoQLxogBCwA+wFBAEgEQCAEKAL4ARogBCgC8AEQKgtBASEDDAELIAhBAToAQCACKAIYIgMEQCADIAMoAgRBAWo2AgQLIAcgCDYCRCAHKAJIIQYgByADNgJIQQAhAyAGRQ0AIAYgBigCBCITQQFrNgIEIBMNACAGIAYoAgAoAggRAAAgBhArCwJAIAVFDQAgBSAFKAIEIgZBAWs2AgQgBg0AIAUgBSgCACgCCBEAACAFECsLIAcgCEYNBQsgCUEEaiIJIAtHDQALIAwtAHMhAyAMKAJsIQULAkACQAJAIAUgAyADwEEASCIDG0Eaaw4SAAQEBAQEBAQEBAQEBAQEBAQBBAsgDigCACAOIAMbQeqLAUEaEF9FDQEMAwsgDigCACAOIAMbQfbEAEErEF8NAgsgDygCAEEBOgBMIAQoAmAiCSAEKAJkIihGDQEDQAJAIAkoAgAhBgJAAkACQCANIgUoAgAiA0UNAANAIAUgAyADKAIQIAZJIgcbIQUgAyAHQQJ0aigCACIDDQALIAUgDUYNACAGIAUoAhBPDQELIAEoAjAgBhC7Ag0BIARBKBAsIgM2AvABIARCo4CAgICFgICAfzcC9AEgA0Hy8AApAAA3AAAgA0EAOgAjIANBkfEAKAAANgAfIANBivEAKQAANwAYIANBgvEAKQAANwAQIANB+vAAKQAANwAIIABBAkHQDyAEQfABahAvGiAELAD7AUEASARAIAQoAvgBGiAEKALwARAqC0EBIQMMBgsgDygCACIDIAUoAhQiBUYEQCAEQSAQLCIDNgLwASAEQp6AgICAhICAgH83AvQBIANBrukAKQAANwAAIANBADoAHiADQcTpACkAADcAFiADQb7pACkAADcAECADQbbpACkAADcACCAAQQJB0A8gBEHwAWoQLxogBCwA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BEAgBCgCsAIaIAQoAqgCECoLIAJBI0dBACACGw0CIAdBBGoiByARRw0ACwJAIAQoApwCIhEgBCgCoAIiEEYNACAURQ0AA0AgBEHgAGogFCARKAIAIgZB7crJgwcQugECQCAEKAJgIgggBCgCZCIJRgRAQQEhAwwBCyAIIQcCQCANKAIAIgVFDQADQCANIQIgBSEDA0AgAiADIAMoAhAgBkkiChshAiADIApBAnRqKAIAIgMNAAsgAiANRg0BIAYgAigCEEkNAUEBIQMgAigCFEEBOgBBIAdBBGoiByAJRw0ACwwBCyAEQTAQLCIDNgKoAiAEQqqAgICAhoCAgH83AqwCIANB2NsAKQAANwAAIANBADoAKiADQYDcAC8AADsAKCADQfjbACkAADcAICADQfDbACkAADcAGCADQejbACkAADcAECADQeDbACkAADcACCAAQQJB0A8gBEGoAmoQLxogBCwAswJBAEgEQCAEKAKwAhogBCgCqAIQKgtBACEDIAQoAmAhCAsgCARAIAQgCDYCZCAEKAJoGiAIECoLIANFDQMgEUEEaiIRIBBHDQALIAQoAqACIRAgBCgCnAIhEQsgECARRg0AIAFBgAFqIQ4DQAJAIAEoAjAgESgCACILEOcBQe7CnZMHRw0AQSQQLCIDQgA3AhAgA0IANwIEIANBpOQENgIAIANCADcCGCADQQA2AiAgBCADNgIcIAQgA0EMajYCGCADIAs2AgwgBEEANgL4ASAEQgA3AvABIARBqAJqIAEoAjAgCyAEQfABahCBAgJAIAQoAqgCBEAgACAEKQOoAjcCACAAIAQoArgCNgIQIAAgBCkCsAI3AgggBEIANwOwAiAEQQA2ArgCQQEhBgwBCyAEQQRqIQkgBCgCGCEIIwBBEGsiAyQAAkAgBEHwAWoiCigCBCAKKAIAIgJrIgVBB00EQCADQSAQLCICNgIEIANCmYCAgICEgICAfzcCCCACQcr5ACkAADcAACACQQA6ABkgAkHi+QAtAAA6ABggAkHa+QApAAA3ABAgAkHS+QApAAA3AAggCUECQYgBIANBBGoQLxogAywAD0EATg0BIAMoAgwaIAMoAgQQKgwBCwJ/IAItAAFBAXEiDARAIAVBC00EQCADQRgQLCICNgIEIANCloCAgICDgICAfzcCCCACQYTOACkAADcAACACQQA6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BEGg0wM2AiAgBRA/IgVB8MsDNgIAIARCADcCTCAEQgA3AkQgBEEYNgJUIAdB8KYBQRoQLSAGEDxBhqkBQSwQLSADKAI4EDxB3pYBQQoQLRoCfyAEKAJUIgFBEHEEQCAEKAJQIgEgBCgCPCICSQRAIAQgAjYCUCACIQELIARBOGoMAQsgAUEIcUUEQEEAIQEgBEEAOgAXIARBDGohAgwGCyAEKAI0IQEgBEEsagshAiABIAIoAgAiA2siAUH4////B08NAiABQQtPBEAgAUEHckEBaiIGECwhAiAEIAZBgICAgHhyNgIUIAQgAjYCDCAEIAE2AhAMBAsgBCABOgAXIARBDGohAiABDQNBACEBDAQLIAFB7ABqIQMCQAJAIAEoAnAgASgCbCIHa0ECdSIFIAZJBEAgAyAGIAVrEKoBDAELIAUgBksEQCABIAcgBkECdGo2AnALIAZFDQELQQAhAQNAIAIQSSEFIAMoAgAgAUECdGogBTYCACABQQFqIgEgBkcNAAsLIABBkKUFKQIANwIAIABBCGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwHCyAAQZilBSgCAEGcpQUoAgAQLgwGCxA4AAsQOAALIAIgAyABEDcaCyABIAJqQQA6AAAgAEECQegHIARBDGoQLxogBCwAF0EASARAIAQoAhQaIAQoAgwQKgsgBEG80wMoAgAiADYCGCAAQQxrKAIAIARBGGpqQdzTAygCADYCACAEQeDTAygCADYCICAFQfDLAzYCACAELABPQQBIBEAgBCgCTBogBCgCRBAqCyAFED0aIARB2ABqEDsaDAILIAIgBiABEDcaCyABIAJqQQA6AAAgAEECQeQAIARBDGoQLxogBCwAF0EASARAIAQoAhQaIAQoAgwQKgsgBEG80wMoAgAiADYCGCAAQQxrKAIAIARBGGpqQdzTAygCADYCACAEQeDTAygCADYCICADQfDLAzYCACAELABPQQBIBEAgBCgCTBogBCgCRBAqCyADED0aIARB2ABqEDsaCyAELAC7AUEASARAIAQoArgBGiAEKAKwARAqCyAEQcABaiQAC18BAn8jAEEQayIDJAAgAyACNgIMIANBCGogA0EMahCnASEEIAAgARDZAiEBIAQoAgAiAARAQeivBigCABogAARAQeivBkHw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IAAoAgBBDGsoAgBqKAIQRQRAIAAgACgCAEEMaygCAGooAkgiAgRAIAIQvwMLIAFBAToACAsCQCABLQAIRQ0AIAAgACgCAEEMaygCAGooAhgiAiACKAIAKAIYEQEAQX9HDQAgACAAKAIAQQxrKAIAakEBEKMBCyABQQhqEHILIAFBEGokAAsUACAAQdDKAzYCACAAQQRqEEcgAAsJACAAEM8CECoLJAEBfwJAIAAoAgAiAkUNACACIAEQzAVBf0cNACAAQQA2AgALCwkAIAAQ0QIQKgukAQEEfyMAQTBrIgMkACAAIAAoAgBBDGsoAgBqIgQgBCgCEEF9cSIEEHogA0EvaiAAEMYDIAMtAC8EQCADQRhqIgUgACAAKAIAQQxrKAIAaigCGCIGIAEgAkEIIAYoAgAoAhARGAAgA0EIaiICQn83AwggAkIANwMAIAAgACgCAEEMaygCAGogBEEEciAEIAUpAwggAikDCFEbEKMBCyADQTBqJAALCQAgACABEKMBC2cBAn8jAEEQayIDJAAgAEEAOgAAIAEgASgCAEEMaygCAGohAgJAIAIoAhBFBEAgAigCSARAIAIoAkgQlQILIAAgASABKAIAQQxrKAIAaigCEEU6AAAMAQsgAkEEEKMBCyADQRBqJAALCQAgABDSAhAqCwsAIAEgAiAAELEBC3MBBn8gACgCTBogABDPASEGIAAgACgCDBEBACEFIAAtAABBAXFFBEAgACgCOCEBIAAoAjQiAgRAIAIgATYCOAsgAQRAIAEgAjYCNAsgAEHMrgYoAgBGBEBBzK4GIAE2AgALIAAoAmAQKiAAECoLIAYgBXIL6wMCA34FfyMAQSBrIgYkACABQv///////z+DIQICfiABQjCIQv//AYMiA6ciBUGB+ABrQf0PTQRAIAJCBIYgAEI8iIQhAiAFQYD4AGutIQMCQCAAQv//////////D4MiAEKBgICAgICAgAhaBEAgAkIBfCECDAELIABCgICAgICAgIAIUg0AIAJCAYMgAnwhAgtCACACIAJC/////////wdWIgUbIQQgBa0gA3wMAQsCQCAAIAKEUA0AIANC//8BUg0AIAJCBIYgAEI8iIRCgICAgICAgASEIQRC/w8MAQsgBUH+hwFLBEBC/w8MAQtCAEGA+ABBgfgAIANQIggbIgkgBWsiB0HwAEoNABog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LQAAOgAAIAlBAWoiCSACRw0ACwsgCCAAa0F8TQRAA0AgA0EBayAFQQFrLQAAOgAAIANBAmsgBUECay0AADoAACADQQNrIAVBA2stAAA6AAAgA0EEayIDIAVBBGsiBS0AADoAACAFIAhHDQALCyAGKAKAARogBigCeCEICyAGIA02AoABIAYgBDYCfCAGIAE2AnggCEUNACAIECoLIAYgBDYCfCAPKAIAQQEQQCEEAkAgBigCfCIAIAYoAoABIgFJBEAgACAEOgAAIABBAWohBAwBCyAAIAYoAngiCGsiBUEBaiIDQQBIDQQgBUH/////ByABIAhrIgJBAXQiASADIAEgA0sbIAJB/////wNPGyICBH8gAhAsBUEACyIBaiIDIAQ6AAAgASACaiENIANBAWohBAJAIAAgCEYEQCADIQEMAQsCQCAFQQNxIgJFBEAgACEFDAELQQAhCSAAIQUDQCADQQFrIgMgBUEBayIFLQAAOgAAIAlBAWoiCSACRw0ACwsgCCAAa0F8TQRAA0AgA0EBayAFQQFrLQAAOgAAIANBAmsgBUECay0AADoAACADQQNrIAVBA2stAAA6AAAgA0EEayIDIAVBBGsiBS0AADoAACAFIAhHDQALCyAGKAKAARogBigCeCEICyAGIA02AoABIAYgBDYCfCAGIAE2AnggCEUNACAIECoLIAYgBDYCfCAPKAIAQQIQQCEEIAYoAnwiACAGKAKAASIBSQRAIAAgBDoAACAGIABBAWo2AnwMAgsgACAGKAJ4IghrIgVBAWoiA0EASA0DIAVB/////wcgASAIayICQQF0IgEgAyABIANLGyACQf////8DTxsiAgR/IAIQLAVBAAsiAWoiAyAEOgAAIAEgAmohBCADQQFqIQ0CQCAAIAhGBEAgAyEBDAELAkAgBUEDcSICRQRAIAAhBQwBC0EAIQkgACEFA0AgA0EBayIDIAVBAWsiBS0AADoAACAJQQFqIgkgAkcNAAsLIAggAGtBfE0EQANAIANBAWsgBUEBay0AADoAACADQQJrIAVBAmstAAA6AAAgA0EDayAFQQNrLQAAOgAAIANBBGsiAyAFQQRrIgUtAAA6AAAgBSAIRw0ACwsgBigCgAEaIAYoAnghCAsgBiAENgKAASAGIA02AnwgBiABNgJ4IAgEQCAIECoLIAYgDTYCfAwBCyAB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AlA2AXIgCyACNgIEIAsgADYCACACIAIoAgRBAWo2AgQCQCAKKAIEIgEgCigCCEkEQCABIAI2AgQgASAANgIAIAogAUEIajYCBAwBCyAKIAsQUyEAIAsoAgQhASAKIAA2AgQgAUUNACABIAEoAgQiAEEBazYCBCAADQAgASABKAIAKAIIEQAAIAEQKwsgAiACKAIEIgBBAWs2AgQgAA0AIAIgAigCACgCCBEAACACECsLAkAgDygCAC0AbEEBRw0AQZABECwiAkIANwIEIAJB4N0ENgIAIAJBEGoiAUIANwMQIAFCADcDCCABQn83AzggAUIANwNIIAFCADcCZCABQQA2AjAgAUIANwMoIAFCADcDICABQgA3AxggAUFAa0J/NwMAIAFCADcDUCABQgA3A1ggAUEAOgBgIAFCADcCbCABQgA3AnQgAUH2xpHrBjYCECABQai+BDYCACAPKAIAIgApAlwhECAAKQJUIREgAiAAKQJkNwKEASACIBA3AnwgAiARNwJ0IAsgAjYCBCALIAE2AgAgAiACKAIEQQFqNgIEAkAgCigCBCIAIAooAghJBEAgACACNgIEIAAgATYCACAKIABBCGo2AgQMAQsgCiALEFMhACALKAIEIQEgCiAANgIEIAFFDQAgASABKAIEIgBBAWs2AgQgAA0AIAEgASgCACgCCBEAACABECsLIAIgAigCBCIAQQFrNgIEIAANACACIAIoAgAoAggRAAAgAhArCyAGIAYoAgQiAEEBazYCBCAARQRAIAYgBigCACgCCBEAACAGECsLIAwgDCgCBCIAQQFrNgIEIAANACAMIAwoAgAoAggRAAAgDBArCyALQRBqJAAPCxA2AAuNAQACfwJAAkACQAJAIABB5srB0wZMBEAgAEGx4NiLBkYNAiAAQbHG2cMGRg0BIABBsdbJ0QZHDQRBBw8LIABB6Ma5qwdMBEBBAyAAQefKwdMGRg0FGiAAQenWzesGRw0EQQkPCyAAQenGuasHRg0CIABBscbZswdHDQNBBQ8LQQEPC0EEDwtBCA8LQQALC3oBA38CfwJAAkAgACgCQCIDRQ0AIABBQGsiBCEAA0AgACADIAMoAhAgAUgiBRshACADIAVBAnRqKAIAIgMNAAsgACAERg0AIAAoAhAgAUwNAQtBACACRQ0BGiACQQA2AgBBAA8LIAIEQCACIAAoAjQ2AgALIAAoAiwLC8QCAQR/IABB6IEFNgIAIAAoAowBIgMEQCAAKAKQASICIAMiAUcEQANAIAJBDGsiASgCACIEBEAgAkEIayAENgIAIAJBBGsoAgAaIAQQKgsgASICIANHDQALIAAoAowBIQELIAAgAzYCkAEgACgClAEaIAEQKgsgACgCgAEiAwRAIAAoAoQBIgIgAyIBRwRAA0AgAkEMayIBKAIAIgQEQCACQQhrIAQ2AgAgAkEEaygCABogBBAqCyABIgIgA0cNAAsgACgCgAEhAQsgACADNgKEASAAKAKIARogARAqCyAAKAJ0IgMEQCAAKAJ4IgIgAyIBRwRAA0AgAkEMayIBKAIAIgQEQCACQQhrIAQ2AgAgAkEEaygCABogBBAqCyABIgIgA0cNAAsgACgCdCEBCyAAIAM2AnggACgCfBogARAqCyAAEFYLTQAgAEIANwIAIABBADYCMCAAQgA3AiggAEEgaiIBQgA3AgAgAEIANwIYIABCADcCECAAQgA3AgggAUIANwIAIAFBADYCECABQgA3AggLtAIBCH8gAEGYgAU2AgAgACgCsAEiBARAIAAoArQBIgIgBCIBRwRAA0AgAkEMayIHKAIAIgUEQCACQQhrIggoAgAiASAFIgNHBEADQCABQQxrIgMoAgAiBgRAIAFBCGsgBjYCACABQQRrKAIAGiAGECoLIAMiASAFRw0ACyAHKAIAIQMLIAggBTYCACACQQRrKAIAGiADECoLIAJBEGsiAiAERw0ACyAAKAKwASEBCyAAIAQ2ArQBIAAoArgBGiABECoLIAAoApwBIgEEQCAAIAE2AqABIAAoAqQBGiABECoLIAAoApABIgEEQCAAIAE2ApQBIAAoApgBGiABECoLIAAoAoQBIgEEQCAAKAKMARogARAqCyAAKAJ4IgEEQCAAIAE2AnwgACgCgAEaIAEQKgsgABBWC84OAQ9/IAAoArABIg0gACgCtAEiDkcEQANAAkAgDSgCBCILIA0oAggiD0YNAANAAkAgCygCACEMIAsoAgQhEAJAIAEoAgQiBCABKAIIIgBJBEAgBEEAOgAAIARBAWohBQwBCyAEIAEoAgAiA2siB0EBaiICQQBIDQEgB0H/////ByAAIANrIgZBAXQiACACIAAgAksbIAZB/////wNPGyIABH8gABAsBUEACyIGaiICQQA6AAAgACAGaiEJIAJBAWohBQJAIAMgBEYEQCACIQYMAQtBACEIIAQhACAHQQNxIgcEQANAIAJBAWsiAiAAQQFrIgAtAAA6AAAgCEEBaiIIIAdHDQALCyADIARrQXxNBEADQCACQQFrIABBAWstAAA6AAAgAkECayAAQQJrLQAAOgAAIAJBA2sgAEEDay0AADoAACACQQRrIgIgAEEEayIALQAAOgAAIAAgA0cNAAsLIAEoAggaIAEoAgAhAwsgASAJNgIIIAEgBTYCBCABIAY2AgAgA0UNACADECoLIAEgBTYCBAJAIAEoAggiACAFSwRAIAVBADoAACAFQQFqIQQMAQsgBSABKAIAIgNrIgdBAWoiAkEASA0BIAdB/////wcgACADayIGQQF0IgAgAiAAIAJLGyAGQf////8DTxsiAAR/IAAQLAVBAAsiBmoiAkEAOgAAIAAgBmohCSACQQFqIQQCQCADIAVGBEAgAiEGDAELQQAhCCAFIQAgB0EDcSIHBEADQCACQQFrIgIgAEEBayIALQAAOgAAIAhBAWoiCCAHRw0ACwsgAyAFa0F8TQRAA0AgAkEBayAAQQFrLQAAOgAAIAJBAmsgAEECay0AADoAACACQQNrIABBA2stAAA6AAAgAkEEayICIABBBGsiAC0AADoAACAAIANHDQALCyABKAIIGiABKAIAIQMLIAEgCTYCCCABIAQ2AgQgASAGNgIAIANFDQAgAxAqCyABIAQ2AgQgECAMayIKQQh2IQUCQCABKAIIIgAgBEsEQCAEIAU6AAAgBEEBaiEFDAELIAQgASgCACIDayIHQQFqIgJBAEgNASAHQf////8HIAAgA2siBkEBdCIAIAIgACACSxsgBkH/////A08bIgAEfyAAECwFQQALIgZqIgIgBToAACAAIAZqIQkgAkEBaiEFAkAgAyAERgRAIAIhBgwBC0EAIQggBCEAIAdBA3EiBwRAA0AgAkEBayICIABBAWsiAC0AADoAACAIQQFqIgggB0cNAAsLIAMgBGtBfE0EQANAIAJBAWsgAEEBay0AADoAACACQQJrIABBAmstAAA6AAAgAkEDayAAQQNrLQAAOgAAIAJBBGsiAiAAQQRrIgAtAAA6AAAgACADRw0ACwsgASgCCBogASgCACEDCyABIAk2AgggASAFNgIEIAEgBjYCACADRQ0AIAMQKgsgASAFNgIEAkAgASgCCCIAIAVLBEAgBSAKOgAAIAVBAWohBAwBCyAFIAEoAgAiA2siB0EBaiICQQBIDQEgB0H/////ByAAIANrIgZBAXQiACACIAAgAksbIAZB/////wNPGyIABH8gABAsBUEACyIGaiICIAo6AAAgACAGaiEJIAJBAWohBAJAIAMgBUYEQCACIQYMAQtBACEIIAUhACAHQQNxIgcEQANAIAJBAWsiAiAAQQFrIgAtAAA6AAAgCEEBaiIIIAdHDQALCyADIAVrQXxNBEADQCACQQFrIABBAWstAAA6AAAgAkECayAAQQJrLQAAOgAAIAJBA2sgAEEDay0AADoAACACQQRrIgIgAEEEayIALQAAOgAAIAAgA0cNAAsLIAEoAggaIAEoAgAhAwsgASAJNgIIIAEgBDYCBCABIAY2AgAgA0UNACADECoLIAEgBDYCBAJAIAsoAgQiBiALKAIAIglrIghBAEwNACAIIAEoAggiACAEa0wEQCAGIAlHBEAgBCAJIAgQNxoLIAEgBCAIajYCBAwBCyAEIAEoAgAiA2siCiAIaiICQQBIDQFBACEMQQAhBUH/////ByAAIANrIgZBAXQiACACIAAgAksbIAZB/////wNPGyIABEAgABAsIQULIAAgBWohByAFIApqIgIgCSAIEDIiACAIaiEJAkAgAyAERgRAIAAhBQwBC0EAIQggBCEAIApBA3EiBgRAA0AgAkEBayICIABBAWsiAC0AADoAACAIQQFqIgggBkcNAAsLIAMgBGtBfE0EQANAIAJBAWsgAEEBay0AADoAACACQQJrIABBAmstAAA6AAAgAkEDayAAQQNrLQAAOgAAIAJBBGsiAiAAQQRrIgAtAAA6AAAgACADRw0ACwsgASgCBCIAIARrIQwgACAERg0AIAkgBCAMEDcaCyABIAkgDGo2AgQgASgCACEAIAEgBTYCACABKAIIGiABIAc2AgggAEUNACAAECoLIA8gC0EMaiILRw0BDAILCxA2AAsgDUEQaiINIA5HDQALC0EBC6IGAQt/IwBBEGsiBCQAAkACQCAAKAIEIgIgAUkEQAJAAkAgACgCCCIFQQV0IgMgASACayIGSQ0AIAIgAyAGa0sNACAAIAE2AgQgAkEfcSEDIAAoAgAgAkEDdkH8////AXFqIQEMAQsgBEEANgIMIARCADcCBCABQQBIDQMCQCADQf7///8DTQR/IAVBBnQiAiABQR9qQWBxIgEgASACSRsFQf////8HCyIBIAQoAgxBBXRNDQAgAUEATgRAIAFBAWtBBXZBAWoiCkECdBAsIQUgBCgCBCEDIAUgBCgCCCIBQQFrQQV2QQAgAUEhTxtBAnRqQQA2AgAgAQRAIAFBH3EhCyADIAFBA3ZB/P///wFxaiEMIAUhASADIQIDQEEBIAh0IQcgAQJ/IAIoAgAgCXZBAXEEQCABKAIAIAdyDAELIAEoAgAgB0F/c3ELNgIAQQAgCEEBaiAIQR9GIgcbIQggASAHQQJ0aiEBIAIgCUEfRiIHQQJ0aiECQQAgCUEBaiAHGyIJIAtHDQAgAiAMRw0ACwsgBCAKNgIMIAQgBTYCBCADRQ0BIAMQKgwBCxA2AAsgBCAAKAIEIgMgBmo2AgggACgCACECIAQoAgQhAQJAIANBAEwEQEEAIQMMAQsgA0EFdiEFIANBIE8EQCABIAIgBUECdBA3GgsgASAFQQJ0IgVqIQEgA0EfcSIDBEAgASABKAIAQX9BICADa3YiCEF/c3EgAiAFaigCACAIcXI2AgALIAAoAgAhAgsgACAEKAIENgIAIAQgAjYCBCAAKAIEIQUgACAEKAIINgIEIAQgBTYCCCAAKAIIIQUgACAEKAIMNgIIIAQgBTYCDCACRQ0AIAIQKgsgBkUNASADBEAgASABKAIAQX8gA3RBf0EgIANrIgAgACAGIAAgBkkbIgBrdnFBf3NxNgIAIAYgAGshBiABQQRqIQELIAZBBXYhACAGQSBPBEAgAUEAIABBAnQQNBoLIAZBH3EiAkUNASABIABBAnRqIgAgACgCAEF/QSAgAmt2QX9zcTYCAAwBCyAAIAE2AgQLIARBEGokAA8LEDYAC80BAQN/AkAgACABRwRAAkAgASgCBCICRQRAQQAhAgwBCyAAKAIIQQV0IAJJBEAgACgCACIDBEAgAxAqIABBADYCCCAAQgA3AgAgASgCBCECCyACQQBIDQMgAkEBa0EFdkEBaiICQQJ0ECwhAyAAIAI2AgggAEEANgIEIAAgAzYCACABKAIEIQILIAEoAgAiAyACQQFrQQN2Qfz///8BcWpBBGoiBCADRg0AIAAoAgAgAyAEIANrEDcaIAEoAgQhAgsgACACNgIECw8LEDYAC6IbAg5/AX4gAiABQTxqIgVHBEAgBSACKAIAIgUgAigCBCICIAIgBWsQqQELIwBBMGsiAiQAIAFBADYCSCACQRhqIQYjAEEQayIFJAACQAJAIAEoAkAgASgCPCIEayIIQQJPBEAgASgCSCIDIAhBAmtNDQELIAVBADoABCAFQQA6AA8gBkECQYwBIAVBBGoQLxogBSwAD0EATg0BIAUoAgwaIAUoAgQQKgwBCyADIARqLwAAIQQgASADQQJqNgJIIARBCHQgBEEIdnJB//8DcUHP/gNGBEAgBkGQpQUpAgA3AgAgBkEIaiEDQaOlBSwAAEEATgRAIANBmKUFKQIANwIAIANBoKUFKAIANgIIDAILIANBmKUFKAIAQZylBSgCABAuDAELIAVBIBAsIgM2AgQgBUKbgICAgISAgIB/NwIIIANBri8pAAA3AAAgA0EAOgAbIANBxS8oAAA2ABcgA0G+LykAADcAECADQbYvKQAANwAIIAZBAkGMASAFQQRqEC8aIAUsAA9BAE4NACAFKAIMGiAFKAIEECoLIAVBEGokAAJAIAIoAhgEQCAAIAIpAxg3AgAgACACKAIoNgIQIAAgAikDIDcCCCACQQA2AiggAkIANwMgDAELIwBBEGsiBSQAAkACQCABKAJAIAEoAjwiBmsiCEErTwRAIAEoAkgiAyAIQStrTQ0BCyAFQQA6AAQgBUEAOgAPIAJBAkGMASAFQQRqEC8aIAUsAA9BAE4NASAFKAIMGiAFKAIEECoMAQsgAyAGai8AACEEIAEgA0ECaiIHNgJIIARBCHQgBEEIdnJB//8DcUHR/gNHBEAgBUEgECwiAzYCBCAFQpuAgICAhICAgH83AgggA0GSLykAADcAACADQQA6ABsgA0GpLygAADYAFyADQaIvKQAANwAQIANBmi8pAAA3AAggAkECQYwBIAVBBGoQLxogBSwAD0EATg0BIAUoAgwaIAUoAgQQKgwBCyAGIAdqLwAAIQQgASADQQRqIgc2AkggBEEIdCAEQQh2ckHZ/wBqQf//A3FBgYABTQRAIAVBGBAsIgM2AgQgBUKXgICAgIOAgIB/NwIIIANB1MwAKQAANwAAIANBADoAFyADQePMACkAADcADyADQdzMACkAADcACCACQQJBjAEgBUEEahAvGiAFLAAPQQBODQEgBSgCDBogBSgCBBAqDAELIAYgB2ovAAAhBCABIANBBmoiBzYCSCABIARBCHQgBEEIdnI7AQAgBiAHaigAACEEIAEgA0EKaiIHNgJIIAEgBEEYdCAEQYD+A3FBCHRyIARBCHZBgP4DcSAEQRh2cnI2AgQgBiAHaigAACEEIAEgA0EOaiIHNgJIIAEgBEEYdCAEQYD+A3FBCHRyIARBCHZBgP4DcSAEQRh2cnI2AgggBiAHaigAACEEIAEgA0ESaiIHNgJIIAEgBEEYdCAEQYD+A3FBCHRyIARBCHZBgP4DcSAEQRh2cnI2AgwgBiAHaigAACEEIAEgA0EWaiIHNgJIIAEgBEEYdCAEQYD+A3FBCHRyIARBCHZBgP4DcSAEQRh2cnI2AhAgBiAHaigAACEEIAEgA0EaaiIHNgJIIAEgBEEYdCAEQYD+A3FBCHRyIARBCHZBgP4DcSAEQRh2cnI2AhQgBiAHaigAACEEIAEgA0EeaiIHNgJIIAEgBEEYdCAEQYD+A3FBCHRyIARBCHZBgP4DcSAEQRh2cnI2AhggBiAHaigAACEEIAEgA0EiaiIHNgJIIAEgBEEYdCAEQYD+A3FBCHRyIARBCHZBgP4DcSAEQRh2cnI2AhwgBiAHaigAACEEIAEgA0EmaiIHNgJIIAEgBEEYdCAEQYD+A3FBCHRyIARBCHZBgP4DcSAEQRh2cnI2AiAgBiAHai8AACEGIAEgA0EoaiIDNgJIIAZBCHQgBkEIdnIiB0GBgAFrQf//A3FB//8CTQRAIAVBGBAsIgM2AgQgBUKXgICAgIOAgIB/NwIIIANB7MwAKQAANwAAIANBADoAFyADQfvMACkAADcADyADQfTMACkAADcACCACQQJBjAEgBUEEahAvGiAFLAAPQQBODQEgBSgCDBogBSgCBBAqDAELIAdB//8DcUF9bCAIaiADTwRAIAEoAighAwJAAkADQCABKAI8IgQgASgCSCIGai0AACEIIAEgBkEBaiIJNgJIIAQgCWotAAAhCSABIAZBAmoiCjYCSCAEIApqLQAAIQogASAGQQNqNgJIIAhBB3YhCyAIQf8AcUEBaiENIAECfyABKAIsIgggA0sEQCADIA1BEHQgC0EYdHIgCkEIdHIgCXI2AAAgA0EEagwBCyADIAEoAiQiBmtBAnUiDkEBaiIEQYCAgIAETw0CQf////8DIAggBmsiCEEBdSIMIAQgBCAMSRsgCEH8////B08bIggEfyAIQYCAgIAETw0EIAhBAnQQLAVBAAsiDCAOQQJ0aiIEIA1BEHQgC0EYdHIgCkEIdHIgCXI2AAAgBEEEaiEJIAMgBkcEQANAIARBBGsiBCADQQRrIgMoAAA2AAAgAyAGRw0ACyABKAIsGiABKAIkIQYLIAEgDCAIQQJ0ajYCLCABIAk2AiggASAENgIkIAYEQCAGECoLIAkLIgM2AiggD0EBaiIPQf//A3EgB0H//wNxSQ0ACyACEOgBDAMLEDYACxBPAAsgAkECQYwBIAVBBGpB0JACEIABIgMQLxogAywAC0EATg0AIAMoAggaIAMoAgAQKgsgBUEQaiQAIAIgAikDACIRNwMYIAIsACtBAE4EfyARpwUgAigCKBogAigCIBAqIAIoAhgLIRAgAiACKQMINwMgIAIgAigCEDYCKCAQBEAgACACKQMYNwIAIAAgAigCKDYCECAAIAIpAiA3AgggAkIANwMgIAJBADYCKAwBCyABKAJIIgUgASgCQCABKAI8IgNrQQJrSQRAIAMgBWovAAAhAyABIAVBAmo2AkggA0EIdCADQQh2ckH//wNxQdD+A0YEQCMAQRBrIgUkAAJAIAEoAkgiBiABKAJAIAEoAjwiA2tBCGtLBEAgBUEAOgAEIAVBADoADyAAQQJBjAEgBUEEahAvGiAFLAAPQQBODQEgBSgCDBogBSgCBBAqDAELIAMgBmovAAAhBCABIAZBAmoiCDYCSCAEQQh0IARBCHZyQccAa0H//wNxQcD/A00EQCAFQRgQLCIBNgIEIAVCl4CAgICDgICAfzcCCCABQZzNACkAADcAACABQQA6ABcgAUGrzQApAAA3AA8gAUGkzQApAAA3AAggAEECQYwBIAVBBGoQLxogBSwAD0EATg0BIAUoAgwaIAUoAgQQKgwBCyADIAhqKAAAIQMgASAGQQZqNgJIIANBGHQgA0GA/gNxQQh0ciADQQh2QYD+A3EgA0EYdnJyIQpBAiEEA0ACQCAKQSAgBGt2QQFxRQ0AIARBD0YEQCABKAJIIgMgASgCPGoiBi0AASEIIAYtAAAhBiABIANBAmo2AkggBSAGQRh0IAhBEHRyQQ9yIgM2AgAgBSADNgIEAkAgASgCNCIDIAEoAjgiB0kEQCADIAUoAQA2AQAgASADQQRqNgI0DAELAkAgAyABKAIwIgZrQQJ1IglBAWoiCEGAgICABEkEQEH/////AyAHIAZrIgdBAXUiCyAIIAggC0kbIAdB/P///wdPGyIHBH8gB0GAgICABE8NAiAHQQJ0ECwFQQALIgsgCUECdGoiCCAFKAEANgEAIAhBBGohCSADIAZHBEADQCAIQQRrIgggA0EEayIDKAEANgEAIAMgBkcNAAsgASgCOBogASgCMCEGCyABIAsgB0ECdGo2AjggASAJNgI0IAEgCDYCMCAGBEAgBhAqCyABIAk2AjQMAgsQNgALEE8ACwwBCyAFQQRqIghB3MUGQfy8AUEnEC0gBBBCIgMgAygCAEEMaygCAGooAhwiBjYCACAGQezOBkcEQCAGIAYoAgRBAWo2AgQLIAhBpNAGEEMiBkEKIAYoAgAoAhwRBQAhByAIEEcjAEEQayIGJAAgBkEIaiADEHMaAkAgBi0ACEUNACAGQQRqIgggAyADKAIAQQxrKAIAaigCGDYCACAIIAcQwgMgCCgCAA0AIAMgAygCAEEMaygCAGpBARDFAwsgBkEIahByIAZBEGokACADEJUCIAEgASgCSEECajYCSAsgBEEBaiIEQSFHDQALIABBkKUFKQIANwIAIABBCGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgBUEQaiQADAILIABBkKUFKQIANwIAIABBCGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwCCyAAQZilBSgCAEGcpQUoAgAQLgwBCyACQSgQLCIBNgIAIAJCoYCAgICFgICAfzcCBCABQY2eASkAADcAACABQQA6ACEgAUGtngEtAAA6ACAgAUGlngEpAAA3ABggAUGdngEpAAA3ABAgAUGVngEpAAA3AAggAEECQYwBIAIQLxogAiwAC0EATg0AIAIoAggaIAIoAgAQKgsgAiwAK0EASARAIAIoAigaIAIoAiAQKgsgAkEwaiQAC7kCAQd/IAEgACgCCCIDIAAoAgQiAmtBBm1NBEAgACABBH8gAkEAIAFBBmxBBmsiACAAQQZwa0EGaiIAEDQgAGoFIAILNgIEDwsCQCACIAAoAgAiBGtBBm0iByABaiIFQavVqtUCSQRAQarVqtUCIAMgBGtBBm0iA0EBdCIIIAUgBSAISRsgA0HVqtWqAU8bIgMEQCADQavVqtUCTw0CIANBBmwQLCEGCyAHQQZsIAZqIgVBACABQQZsQQZrIgEgAUEGcGtBBmoiARA0IAFqIQEgAiAERwRAA0AgBUEGayIFIAJBBmsiAigBADYBACAFIAIvAQQ7AQQgAiAERw0ACyAAKAIIGiAAKAIAIQQLIAAgBiADQQZsajYCCCAAIAE2AgQgACAFNgIAIAQEQCAEECoLDwsQNgALEE8AC1sAIABBADYCCCAAQgA3AgAgAEGQpQUpAgA3AgwgAEEUaiEAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDwsgAEGYpQUoAgBBnKUFKAIAEC4LBABBBwulCgEMfyMAQdAAayIDJAACQCABLQA4QQFGBEAgAEGQpQUpAgA3AgAgAEEIaiEAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAILIABBmKUFKAIAQZylBSgCABAuDAELIANBMGogARCqAgJAIAMoAjwEQCAAIAMpAjw3AgAgAEEIaiEAIAMsAE9BAE4EQCAAIAMpAkQ3AgAgACADKAJMNgIIDAILIAAgAygCRCADKAJIEC4MAQsgA0EYECwiBDYCDCADQpeAgICAg4CAgH83AhAgBEHZMCkAADcADyAEQdIwKQAANwAIIARByjApAAA3AAAgBEEAOgAXIANBGGpBAkEAIANBDGoQLyECIAMsABdBAEgEQCADKAIUGiADKAIMECoLAkACQAJAAkACQCADKAI0IAMoAjAiB2siBUECTwRAQQEhBANAIAYhCCAEIQYCQCAHIAhqIgotAABB/wFHDQAgBCAHai0AACIEQfABcUHAAUcNACAEQQ9xQeDJAmotAABBAUcNACAFIAhBCWoiBk0EQCAAIAIpAwA3AgAgAEEIaiEAIAIsABNBAE4EQCAAIAIpAgg3AgAgACACKAIQNgIIDAkLIAAgAigCCCACKAIMEC4MCAsCQCAFIAhBC2oiBCAGIAdqLQAAIghBA2xqSwRAIAhFDQYgBCAHaiIFLQAAIQlBACEHQQAhBEEAIQYgCEEBRw0BDAULIAAgAikDADcCACAAQQhqIQAgAiwAE0EATgRAIAAgAikCCDcCACAAIAIoAhA2AggMCQsgACACKAIIIAIoAgwQLgwICyAFLQADIgZBD3EhBCAGQQR2IQYgCEECRg0DIAUtAAYiBUEPcSELIAVBBHYhDAwDCyAGQQFqIgQgBUcNAAsLIAAgAikDADcCACAAQQhqIQAgAiwAE0EATgRAIAAgAikCCDcCACAAIAIoAhA2AggMBQsgACACKAIIIAIoAgwQLgwECyAKLQAEIQogCUEPcSEFIAlBBHYhCSAIQQFrDgMCAAEACyAAIAIpAwA3AgAgAEEIaiEAIAIsABNBAE4EQCAAIAIpAgg3AgAgACACKAIQNgIIDAMLIAAgAigCCCACKAIMEC4MAgsgBiAMRiAEIAtGcUUEQCAAIAIpAwA3AgAgAEEIaiEAIAIsABNBAE4EQCAAIAIpAgg3AgAgACACKAIQNgIIDAMLIAAgAigCCCACKAIMEC4MAgtBASEHAkAgBEEBRw0AIAZBAUcNACAJQQJHDQAgBUECRg0BCwJAIARBAUciDQ0AIAZBAUcNACAJQQJHDQBBAiEHIAVBAUYNAQsCQCANDQAgBkEBRw0AIAlBAUcNAEEDIQcgBUEBRg0BCyAAIAIpAwA3AgAgAEEIaiEAIAIsABNBAE4EQCAAIAIpAgg3AgAgACACKAIQNgIIDAILIAAgAigCCCACKAIMEC4MAQsCQCABLQA4QQFGBEAgASAKOgAoIAEgAy8ADDsAKSABIAMtAA46ACsMAQsgASAKOgAoIAEgAy8ADDsAKSABIAMtAA46ACsgAUEBOgA4CyABIAs6ADYgASAEOgA1IAEgBToANCABIAw6ADMgASAGOgAyIAEgCToAMSABIAg6ADAgASAHNgIsIAAQ6AELIAIsABNBAE4NACACKAIQGiACKAIIECoLIAMsAE9BAEgEQCADKAJMGiADKAJEECoLIAMoAjAiAEUNACADIAA2AjQgAygCOBogABAqCyADQdAAaiQACwQAQQMLTQEBfyAALAAbQQBIBEAgACgCGBogACgCEBAqCwJAIAAoAgQiAEUNACAAIAAoAgQiAUEBazYCBCABDQAgACAAKAIAKAIIEQAAIAAQKwsLOgEBfyAAIAAoAgAoAhQRAAAgACgCJCIBIAAoAigiAEcEQANAIAEoAgAQ9wMgAUEIaiIBIABHDQALCwuUBAEJfwJAIAAoAgQgACgCACICa0EEdSIEQQFqIgNBgICAgAFJBEBB/////wAgACgCCCACayICQQN1IgYgAyADIAZJGyACQfD///8HTxsiAgRAIAJBgICAgAFPDQIgAkEEdBAsIQULIAEvAQAhBiAFIARBBHRqIgNBADYCDCADQgA3AgQgAyAGOwEAIANBBGogASgCBCIEIAEoAggiASABIARrQQxtEPcCIAUgAkEEdGohCCADQRBqIQYCQCAAKAIEIgIgACgCACIERgRAIAMhBQwBCwNAIAJBEGsiAS8BACEHIANBBGsiCUEANgIAIANBDGsiCkIANwIAIANBEGsiBSAHOwEAIAogAkEMayIHKAIANgIAIANBCGsgAkEIaygCADYCACAJIAJBBGsiAygCADYCACADQQA2AgAgB0IANwIAIAUhAyABIgIgBEcNAAsgACgCBCECIAAoAgAhBAsgACAGNgIEIAAgBTYCACAAKAIIGiAAIAg2AgggAiAERwRAA0AgAkEMayIIKAIAIgAEQCACQQhrIgcoAgAiAyAAIgFHBEADQCADQQxrIgEoAgAiBQRAIANBCGsgBTYCACADQQRrKAIAGiAFECoLIAEiAyAARw0ACyAIKAIAIQELIAcgADYCACACQQRrKAIAGiABECoLIAJBEGsiAiAERw0ACwsgBARAIAQQKgsgBg8LEDYACxBPAAuHBAEIfwJAIAAoAgQgACgCACICa0EEdSIFQQFqIgNBgICAgAFJBEBB/////wAgACgCCCACayICQQN1IgcgAyADIAdJGyACQfD///8HTxsiAgRAIAJBgICAgAFPDQIgAkEEdBAsIQQLIAQgBUEEdGoiAyABLwEAOwEAIAMgASgCBDYCBCADIAEoAgg2AgggAyABKAIMNgIMIAFBADYCDCABQgA3AgQgBCACQQR0aiEIIANBEGohBwJAIAAoAgQiAiAAKAIAIgVGBEAgAyEEDAELA0AgAkEQayIBLwEAIQYgA0EEayIJQQA2AgAgA0EQayIEIAY7AQAgA0EMayACQQxrIgYoAgA2AgAgA0EIayACQQhrKAIANgIAIAkgAkEEayIDKAIANgIAIANBADYCACAGQgA3AgAgBCEDIAEiAiAFRw0ACyAAKAIEIQIgACgCACEFCyAAIAc2AgQgACAENgIAIAAoAggaIAAgCDYCCCACIAVHBEADQCACQQxrIggoAgAiAARA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ACADECsLCwsAIAAoAgAgARBkCx8BAX8CQCAARQ0AIAAoAgAiAEUNACAAKAIsIQELIAELHwEBfwJAIABFDQAgACgCACIARQ0AIAAoAighAQsgAQsfAAJAIAFFDQAgASgCACIARQ0AIAAQKiABQQA2AgALC/0EAQN/AkACQCACRQRAIABBADYCCCAAQgA3AgAgASgCrAEiBCABKAKoASIBRg0BIAQgAWsiAkEASA0CIAAgAhAsIgM2AgQgACADNgIAIAAgAiADajYCCANAIAMgASgCADYCACADIAEoAgQiAjYCBCACBEAgAiACKAIEQQFqNgIECyADQQhqIQMgAUEIaiIBIARHDQALIAAgAzYCBA8LIABBADYCCCAAQgA3AgAgASgCqAEiAyABKAKsASIERg0AIAJBBHEhBSACQQJxRQRAQQAhASAFRQRAA0AgAAJ/IAAoAgggAU0EQCAAIAMQYQwBCyABIAMoAgA2AgAgASADKAIEIgI2AgQgAgRAIAIgAigCBEEBajYCBAsgAUEIagsiATYCBCADQQhqIgMgBEcNAAwDCwALA0AgAygCACICLQBMRQRAIAACfyAAKAIIIAFNBEAgACADEGEMAQsgASACNgIAIAEgAygCBCICNgIEIAIEQCACIAIoAgRBAWo2AgQLIAFBCGoLIgE2AgQLIANBCGoiAyAERw0ACwwBC0EAIQEgBUUEQANAIAMoAgAiAi0AQEUEQCAAAn8gACgCCCABTQRAIAAgAxBhDAELIAEgAjYCACABIAMoAgQiAjYCBCACBEAgAiACKAIEQQFqNgIECyABQQhqCyIBNgIECyADQQhqIgMgBEcNAAwCCwALA0ACQCADKAIAIgItAEANACACLQBMDQAgAAJ/IAAoAgggAUsEQCABIAI2AgAgASADKAIEIgI2AgQgAgRAIAIgAigCBEEBajYCBAsgAUEIagwBCyAAIAMQYQsiATYCBAsgA0EIaiIDIARHDQALCw8LEDYACwoAIAAoAgAoAiQLCgAgACgCAC0AMAt1AQJ/IAJBgYAEa0H//3dJBEADQCABQQJtIQEgAkECbSICQYGABGtB//93SQ0ACwsCQCACQQFMDQADQCABQYGABGtB/v93Sw0BIAFBAm0hASACQQNLIQQgAkEBdiECIAQNAAsLIAAgAa0gAq1CIIaENwIAIAALogMBCH8jAEEQayIDJAACQCAARQ0AIAFFDQAgAkUNACADQQRqIAAoAgAQwAICQCADKAIIIgYgAygCBCIAa0EDdSIEIAIgAiAEShsiBEEASgRAQQAhAiAEQQRPBEAgBEH8////B3EhBwNAIAEgAkECdGogACACQQN0aigCACgCJDYCACABIAJBAXIiBUECdGogACAFQQN0aigCACgCJDYCACABIAJBAnIiBUECdGogACAFQQN0aigCACgCJDYCACABIAJBA3IiBUECdGogACAFQQN0aigCACgCJDYCACACQQRqIQIgCEEEaiIIIAdHDQALCyAEQQNxIgdFDQEDQCABIAJBAnRqIAAgAkEDdGooAgAoAiQ2AgAgAkEBaiECIAlBAWoiCSAHRw0ACwwBCyAARQ0BCyAAIAZGBH8gAAUDQAJAIAZBBGsoAgAiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsgBkEIayIGIABHDQALIAMoAgQLIQogAyAANgIIIAMoAgwaIAoQKgsgA0EQaiQAIAQLowEBBX8jAEEQayIBJAAgAUEEaiAAKAIAEMACIAEoAgghBCABKAIEIgMEQCADIgAgBEcEQCAEIQADQAJAIABBBGsoAgAiAkUNACACIAIoAgQiBUEBazYCBCAFDQAgAiACKAIAKAIIEQAAIAIQKwsgAEEIayIAIANHDQALIAEoAgQhAAsgASADNgIIIAEoAgwaIAAQKgsgAUEQaiQAIAQgA2tBA3UL1QQBA38jAEEwayIDJAACQCACRQRAIANBADoAECADQQA6ABsgA0EcakEFQdEPIANBEGoQLyECIAMsABtBAEgEQCADKAIYGiADKAIQECoLIAAgAiABKAIAEEEgAiwAE0EATg0BIAIoAhAaIAIoAggQKgwBCyADQQhqIAEoAgAQxgQCQCADKAIIIgVFBEAgA0EAOgAQIANBADoAGyADQRxqQQJB/AAgA0EQahAvIQIgAywAG0EASARAIAMoAhgaIAMoAhAQKgsgACACIAEoAgAQQSACLAATQQBODQEgAigCEBogAigCCBAqDAELIAVB8IQFQdDwBBA5IgQEQCADKAIMIgIEQCACIAIoAgRBAWo2AgQLIANBHGoiBSAEIAQoAgAoAhQRAgAgACAFIAEoAgAQQSADLAAvQQBIBEAgAygCLBog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Qn83A0ggAUJ/NwNQIAFCADcDWCABQgA3A2AgAUIANwNoIAFBADoAcCACQdjFBDYCACABQe/GwcsGNgIgIAMgAjYCNCADKAI4IQIgAyABNgI4AkAgAkUNACACIAIoAgQiAUEBazYCBCABDQAgAiACKAIAKAIIEQAAIAIQKwtBiAEQLCIBQgA3AgQgAUH41QQ2AgAgAUEQaiICQgA3AwggAkIANwMQIAJCADcDGCACQQA2AiAgAkHUvQQ2AgAgAUIANwI8IAFCADcCNCABQn83A0ggAUJ/NwNQIAFBADYCdCABQgA3A1ggAUIANwNgIAFCADcDaCABQQA7AXAgAkHcxgQ2AgAgAUEANgKAASABQgA3AnggAUHh2sHLBjYCICADIAI2AjwgAygCQCECIAMgATYCQAJAIAJFDQAgAiACKAIEIgFBAWs2AgQgAQ0AIAIgAigCACgCCBEAACACECsLQbABECwiAkIANwIEIAJBsNQENgIAIAJBEGoiAUIANwMIIAFCfzcDOCABQgA3A0ggAUEANgJkIAFBADYCiAEgAUEANgKAASABQgA3A2ggAUEANgIwIAFCADcDKCABQgA3AyAgAUIANwMYIAFCADcDECABQUBrQn83AwAgAUIANwNQIAFCADcDWCABQQA7AWAgAUIANwNwIAFCADcAdSABQey9BDYCACABQQA6AIQBIAFB496xywY2AhAgAyABNgJEIAMoAkghASADIAI2AkgCQCABRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArC0H4ABAsIgFCADcCBCABQdjUBDYCACABQRBqIgJCADcDCCACQgA3AxAgAkIANwMYIAJBADYCICACQdS9BDYCACABQgA3AjwgAUIANwI0IAFCfzcDSCABQn83A1AgAUEANgJ0IAFCADcDWCABQgA3A2AgAUIANwNoIAFBADsBcCACQcjEBDYCACABQebcpcsGNgIgIAMgAjYCZCADKAJoIQIgAyABNgJoAkAgAkUNACACIAIoAgQiAUEBazYCBCABDQAgAiACKAIAKAIIEQAAIAIQKwtB+AAQLCIBQgA3AgQgAUGo1QQ2AgAgAUEQaiICQgA3AwggAkIANwMQIAJCADcDGCACQQA2AiAgAkHUvQQ2AgAgAUIANwI8IAFCADcCNCABQn83A0ggAUJ/NwNQIAFCADcDWCABQgA3A2AgAUIANwNoIAFBADoAcCACQZDFBDYCACABQfDkwcsGNgIgIAMgAjYCdCADKAJ4IQIgAyABNgJ4AkAgAkUNACACIAIoAgQiAUEBazYCBCABDQAgAiACKAIAKAIIEQAAIAIQKwtBgAEQLCIBQgA3AgQgAUGI1AQ2AgAgAUEQaiICQgA3AwggAkIANwMQIAJCADcDGCACQQA2AiAgAkHUvQQ2AgAgAUIANwI8IAFCADcCNCABQn83A0ggAUJ/NwNQIAFBADYCdCABQgA3A1ggAUIANwNgIAFCADcDaCABQQA7AXAgAkG4wwQ2AgAgAUHt6KWDBzYCICABQQA2AnggAyACNgJcIAMoAmAhAiADIAE2AmACQCACRQ0AIAIgAigCBCIBQQFrNgIEIAENACACIAIoAgAoAggRAAAgAhArCyADKAIsIQEgBCADKAIkIgU2AgggBCADKAIoIgI2AgwgAgRAIAIgAigCBEEBajYCBAsgAQJ/IAEoAigiAiABKAIsSQRAIAIgBTYCACACIAQoAgwiATYCBCABBEAgASABKAIEQQFqNgIECyACQQhqDAELIAFBJGogBEEIahBhCzYCKAJAIAQoAgwiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsgAygCLCEBIAQgAygCXCIFNgIIIAQgAygCYCICNgIMIAIEQCACIAIoAgRBAWo2AgQLIAECfyABKAIoIgIgASgCLEkEQCACIAU2AgAgAiAEKAIMIgE2AgQgAQRAIAEgASgCBEEBajYCBAsgAkEIagwBCyABQSRqIARBCGoQYQs2AigCQCAEKAIMIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEAACABECsLIAMoAiwhASAEIAMoAkQiBTYCCCAEIAMoAkgiAjYCDCACBEAgAiACKAIEQQFqNgIECyABAn8gASgCKCICIAEoAixJBEAgAiAFNgIAIAIgBCgCDCIBNgIEIAEEQCABIAEoAgRBAWo2AgQLIAJBCGoMAQsgAUEkaiAEQQhqEGELNgIoAkAgBCgCDCIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCyADKAIsIQEgBCADKAJkIgU2AgggBCADKAJoIgI2AgwgAgRAIAIgAigCBEEBajYCBAsgAQJ/IAEoAigiAiABKAIsSQRAIAIgBTYCACACIAQoAgwiATYCBCABBEAgASABKAIEQQFqNgIECyACQQhqDAELIAFBJGogBEEIahBhCzYCKAJAIAQoAgwiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsgAygCLCEBIAQgAygCdCIFNgIIIAQgAygCeCICNgIMIAIEQCACIAIoAgRBAWo2AgQLIAECfyABKAIoIgIgASgCLEkEQCACIAU2AgAgAiAEKAIMIgE2AgQgAQRAIAEgASgCBEEBajYCBAsgAkEIagwBCyABQSRqIARBCGoQYQs2AigCQCAEKAIMIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEAACABECsLIAMoAnQhBiAEIAMoAjQiBzYCCCAEIAMoAjgiATYCDAJAAkACQCABRQRAIAZBKGohBSAGKAIoIgIgBigCLE8NAiACIAE2AgQgAiAHNgIADAELIAEgASgCBEEBajYCBCAGQShqIQUgBigCKCICIAYoAixPDQEgAiABNgIEIAIgBzYCACABIAEoAgRBAWo2AgQLIAJBCGohAgwBCyAGQSRqIARBCGoQYSECIAQoAgwhAQsgBSACNgIAAkAgAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsgAygCdCEGIAQgAygCPCIHNgIIIAQgAygCQCIBNgIMAkACQAJAIAFFBEAgBkEoaiEFIAYoAigiAiAGKAIsTw0CIAIgATYCBCACIAc2AgAMAQsgASABKAIEQQFqNgIEIAZBKGohBSAGKAIoIgIgBigCLE8NASACIAE2AgQgAiAHNgIAIAEgASgCBEEBajYCBAsgAkEIaiECDAELIAZBJGogBEEIahBhIQIgBCgCDCEBCyAFIAI2AgACQCABRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCyADQfwAaiADKAKAARC8AiADIANBgAFqNgJ8IANCADcCgAEgBCADKAIcIgY2AgggBCADKAIgIgE2AgwgAQRAIAEgASgCBEEBajYCBAsgA0EQaiEFAkAgAygCFCICIAMoAhhJBEAgAiABNgIEIAIgBjYCACADIAJBCGo2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AyACEN4ENgIIIAAgAygCDDYCACAAIAMoAgg2AgQgA0EQaiQACwcAIAAQ1gELTwEBfyMAQRBrIgMkACADIAE2AgggAyAANgIMIAMgAjYCBEEAIQEgA0EEaiIAKAIAIAMoAgxPBEAgACgCACADKAIISSEBCyADQRBqJAAgAQtKAQF/IwBBEGsiAyQAAn8gAC0AC0EHdgRAIAAoAgQMAQsgAC0ACwsaIAAgAhDYASADQQA6AA8gASACaiADLQAPOgAAIANBEGokAAsbACAAQf////8DSwRAEGwACyAAQQJ0QQQQugULzgYBBH8jAEGgAWsiAyQAIANB5NUDNgJEIANB8NUDKAIAIgY2AgwgA0EMaiIEIAZBDGsoAgBqQfTVAygCADYCACAEIAMoAgxBDGsoAgBqIgYgA0EQaiIFED4gBkKAgICAcDcCSCADQeTVAzYCRCADQdDVAzYCDCAFED8iBkHwywM2AgAgA0IANwI4IANCADcCMCADQRA2AkAgA0GUAWoiBSABIAIQWSAEIAMoApQBIAUgAywAnwEiBEEASCIFGyADKAKYASAEIAUbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBlAFqIgQgAhA1IANBDGogAygClAEgBCADLACfASIEQQBIIgUbIAMoApgBIAQgBRsQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgA0EMakHwwAFBChAtIAEoAmgQPEHPkAJBARAtIQQgA0GUAWoiBSACEDUgBCADKAKUASAFIAMsAJ8BIgJBAEgiBRsgAygCmAEgAiAFGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyAEQbm3AUEMEC0aAkAgASgCbCICIAEoAnAiBEYNACADQQxqIAIoAgAQPBogAkEEaiIBIARGDQADQCABKAIAIQIgA0EgOgCUASADQQxqIgUgA0GUAWpBARAtGiAFIAIQPBogAUEEaiIBIARHDQALCyADQQxqQc+QAkEBEC0aAkACfyADKAJAIgFBEHEEQCADKAI8IgEgAygCKCICSQRAIAMgAjYCPCACIQELIANBJGoMAQsgAUEIcUUEQEEAIQEgAEEAOgALDAILIAMoAiAhASADQRhqCyECAkAgASACKAIAIgRrIgFB+P///wdJBEAgAUELTwRAIAFBB3JBAWoi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BCAHRwRAAkAgDyARRwRAIA8hEAwBCyACIAIoAgAiEEEEajYCACAQIAo2AgBBACEQAn8gCy0AC0EHdgRAIAsoAgQMAQsgCy0AC0H/AHELIBJBAWoiEk0EQCAPIREMAQsCfyALLQALQQd2BEAgCygCAAwBCyALCyASai0AAEH/AEYEQEF/IREMAQsCfyALLQALQQd2BEAgCygCAAwBCyALCyASaiwAACERCyAHQQRrIgcoAgAhDyACIAIoAgAiGEEEajYCACAYIA82AgAgEEEBaiEPDAELCyACKAIAIQcLIBogBxDFAgsgFEEBaiEUDAELCwvvAwEBfyMAQRBrIgokACAJAn8gAARAIAJBrM4GEEMhAAJAIAEEQCAKQQRqIgEgACAAKAIAKAIsEQIAIAMgCigCBDYAACABIAAgACgCACgCIBECAAwBCyAKQQRqIgEgACAAKAIAKAIoEQIAIAMgCigCBDYAACABIAAgACgCACgCHBECAAsgCCABEKsBIAEQahogBCAAIAAoAgAoAgwRAQA2AgAgBSAAIAAoAgAoAhARAQA2AgAgCkEEaiIBIAAgACgCACgCFBECACAGIAEQhAEgARBGGiABIAAgACgCACgCGBECACAHIAEQqwEgARBqGiAAIAAoAgAoAiQRAQAMAQsgAkGkzgYQQyEAAkAgAQRAIApBBGoiASAAIAAoAgAoAiwRAgAgAyAKKAIENgAAIAEgACAAKAIAKAIgEQIADAELIApBBGoiASAAIAAoAgAoAigRAgAgAyAKKAIENgAAIAEgACAAKAIAKAIcEQIACyAIIAEQqwEgARBqGiAEIAAgACgCACgCDBEBADYCACAFIAAgACgCACgCEBEBADYCACAKQQRqIgEgACAAKAIAKAIUEQIAIAYgARCEASABEEYaIAEgACAAKAIAKAIYEQIAIAcgARCrASABEGoaIAAgACgCACgCJBEBAAs2AgAgCkEQaiQAC9gBAQh/IwBBEGsiBSQAIwBBIGsiAyQAIANBGGogACABEN0EIANBEGogAygCGCADKAIcIAIQvgUgAygCECEEIwBBEGsiASQAIAEgADYCDCABQQxqIgAhCiAEIQcgACgCACEEIwBBEGsiACQAIAAgBDYCDCAKIAchCSAAKAIMIQYgAEEQaiQAIAkgBmsQqAMhACABQRBqJAAgAyAANgIMIAMgAiADKAIUIAJrajYCCCAFIAMoAgw2AgggBSADKAIINgIMIANBIGokACAFKAIMIQggBUEQaiQAIAgL3AcBDH8jAEEQayITJAAgAiAANgIAIANBgARxIRYDQCAUQQRGBEACfyANLQALQQd2BEAgDSgCBAwBCyANLQALQf8AcQtBAUsEQCATIA0QmQE2AgwgAiATQQxqQQEQqAMgDRDNASACKAIAEPoENgIACyADQbABcSIDQRBHBEAgASADQSBGBH8gAigCAAUgAAs2AgALIBNBEGokAAUCQAJAAkACQAJAAkAgCCAUai0AAA4FAAEDAgQFCyABIAIoAgA2AgAMBAsgASACKAIANgIAIAZBICAGKAIAKAIcEQUAIQ8gAiACKAIAIhBBAWo2AgAgECAPOgAADAMLAn8gDS0AC0EHdgRAIA0oAgQMAQsgDS0AC0H/AHELRQ0CAn8gDS0AC0EHdgRAIA0oAgAMAQsgDQstAAAhDyACIAIoAgAiEEEBajYCACAQIA86AAAMAgsCfyAMLQALQQd2BEAgDCgCBAwBCyAMLQALQf8AcQtFIRkgFkUNASAZDQEgAiAMEJkBIAwQzQEgAigCABD6BDYCAAwBCyACKAIAIRogBCAHaiIEIREDQAJAIAUgEU0NACARLAAAIg9BAE4EfyAGKAIIIA9BAnRqKAIAQcAAcUEARwVBAAtFDQAgEUEBaiERDAELCyAOIg9BAEoEQANAAkAgBCARTw0AIA9FDQAgD0EBayEPIBFBAWsiES0AACEQIAIgAigCACISQQFqNgIAIBIgEDoAAAwBCwsgDwR/IAZBMCAGKAIAKAIcEQUABUEACyESA0AgAiACKAIAIhBBAWo2AgAgD0EASgRAIBAgEjoAACAPQQFrIQ8MAQsLIBAgCToAAAsCQCAEIBFGBEAgBkEwIAYoAgAoAhwRBQAhDyACIAIoAgAiEEEBajYCACAQIA86AAAMAQsCfyALLQALQQd2BEAgCygCBAwBCyALLQALQf8AcQsEfwJ/IAstAAtBB3YEQCALKAIADAELIAsLLAAABUF/CyESQQAhD0EAIRADQCAEIBFGDQECQCAPIBJHBEAgDyEVDAELIAIgAigCACISQQFqNgIAIBIgCjoAAEEAIRUCfyALLQALQQd2BEAgCygCBAwBCyALLQALQf8AcQsgEEEBaiIQTQRAIA8hEgwBCwJ/IAstAAtBB3YEQCALKAIADAELIAsLIBBqLQAAQf8ARgRAQX8hEgwBCwJ/IAstAAtBB3YEQCALKAIADAELIAsLIBBqLAAAIRILIBFBAWsiES0AACEPIAIgAigCACIYQQFqNgIAIBggDzoAACAVQQFqIQ8MAAsACyAaIAIoAgAQ2QELIBRBAWohFAwBCwsL7wMBAX8jAEEQayIKJAAgCQJ/IAAEQCACQZzOBhBDIQACQCABBEAgCkEEaiIBIAAgACgCACgCLBECACADIAooAgQ2AAAgASAAIAAoAgAoAiARAgAMAQsgCkEEaiIBIAAgACgCACgCKBECACADIAooAgQ2AAAgASAAIAAoAgAoAhwRAgALIAggARCEASABEEYaIAQgACAAKAIAKAIMEQEAOgAAIAUgACAAKAIAKAIQEQEAOgAAIApBBGoiASAAIAAoAgAoAhQRAgAgBiABEIQBIAEQRhogASAAIAAoAgAoAhgRAgAgByABEIQBIAEQRhogACAAKAIAKAIkEQEADAELIAJBlM4GEEMhAAJAIAEEQCAKQQRqIgEgACAAKAIAKAIsEQIAIAMgCigCBDYAACABIAAgACgCACgCIBECAAwBCyAKQQRqIgEgACAAKAIAKAIoEQIAIAMgCigCBDYAACABIAAgACgCACgCHBECAAsgCCABEIQBIAEQRhogBCAAIAAoAgAoAgwRAQA6AAAgBSAAIAAoAgAoAhARAQA6AAAgCkEEaiIBIAAgACgCACgCFBECACAGIAEQhAEgARBGGiABIAAgACgCACgCGBECACAHIAEQhAEgARBGGiAAIAAoAgAoAiQRAQALNgIAIApBEGokAAvNAgEFfyMAQRBrIgUkAAJAIAJB9////wMgAWtNBEACfyAALQALQQd2BEAgACgCAAwBCyAACyEHIAVBBGoiBiABQfP///8BSQR/IAUgAUEBdDYCDCAFIAEgAmo2AgQjAEEQayICJAAgBigCACAFQQxqIggoAgBJIQkgAkEQaiQAIAggBiAJGygCACICQQJPBH8gAkECakF+cSICIAJBAWsiAiACQQJGGwVBAQtBAWoFQff///8DCxDrASAFKAIEIQIgBSgCCBogBARAIAIgByAEEM4CCyADIARHBEAgBEECdCIGIAJqIAYgB2ogAyAEaxDOAgsgAUEBRwRAIAdBBBC/AQsgACACNgIAIAAgACgCCEGAgICAeHEgBSgCCEH/////B3FyNgIIIAAgACgCCEGAgICAeHI2AgggBUEQaiQADAELEIoBAAsgACADNgIECx8BAX8gASgCABDGBSECIAAgASgCADYCBCAAIAI2AgALmBgBC38jAEGQBGsiCyQAIAsgCjYCiAQgCyABNgKMBAJAIAAgC0GMBGoQXQRAIAUgBSgCAEEEcjYCAEEAIQAMAQsgC0GGCzYCSCALIAtB6ABqIAtB8ABqIAtByABqIg8QayIRKAIAIgE2AmQgCyABQZADajYCYCMAQRBrIgEkACAPQgA3AgAgD0EANgIIIAFBEGokACMAQRBrIgEkACALQTxqIg5CADcCACAOQQA2AgggAUEQaiQAIwBBEGsiASQAIAtBMGoiDUIANwIAIA1BADYCCCABQRBqJAAjAEEQayIBJAAgC0EkaiIMQgA3AgAgDEEANgIIIAFBEGokACMAQRBrIgEkACALQRhqIhBCADcCACAQQQA2AgggAUEQaiQAIwBBEGsiCiQAIAsCfyACBEAgCkEEaiICIANBrM4GEEMiASABKAIAKAIsEQIAIAsgCigCBDYAXCACIAEgASgCACgCIBECACAMIAIQqwEgAhBqGiACIAEgASgCACgCHBECACANIAIQqwEgAhBqGiALIAEgASgCACgCDBEBADYCWCALIAEgASgCACgCEBEBADYCVCACIAEgASgCACgCFBECACAPIAIQhAEgAhBGGiACIAEgASgCACgCGBECACAOIAIQqwEgAhBqGiABIAEoAgAoAiQRAQAMAQsgCkEEaiICIANBpM4GEEMiASABKAIAKAIsEQIAIAsgCigCBDYAXCACIAEgASgCACgCIBECACAMIAIQqwEgAhBqGiACIAEgASgCACgCHBECACANIAIQqwEgAhBqGiALIAEgASgCACgCDBEBADYCWCALIAEgASgCACgCEBEBADYCVCACIAEgASgCACgCFBECACAPIAIQhAEgAhBGGiACIAEgASgCACgCGBECACAOIAIQqwEgAhBqGiABIAEoAgAoAiQRAQALNgIUIApBEGokACAJIAgoAgA2AgAgBEGABHEhEkEAIQNBACEBA0AgASECAkACQAJAAkAgA0EERg0AIAAgC0GMBGoQXQ0AQQAhCgJAAkACQAJAAkACQCALQdwAaiADai0AAA4FAQAEAwUJCyADQQNGDQcgB0EBAn8gACgCACIBKAIMIgQgASgCEEYEQCABIAEoAgAoAiQRAQAMAQsgBCgCAAsgBygCACgCDBEEAARAIAtBDGogABD+BCAQIAsoAgwQoQMMAgsgBSAFKAIAQQRyNgIAQQAhAAwGCyADQQNGDQYLA0AgACALQYwEahBdDQYgB0EBAn8gACgCACIBKAIMIgQgASgCEEYEQCABIAEoAgAoAiQRAQAMAQsgBCgCAAsgBygCACgCDBEEAEUNBiALQQxqIAAQ/gQgECALKAIMEKEDDAALAAsCQAJ/IA0tAAtBB3YEQCANKAIEDAELIA0tAAtB/wBxC0UNAAJ/IAAoAgAiASgCDCIEIAEoAhBGBEAgASABKAIAKAIkEQEADAELIAQoAgALAn8gDS0AC0EHdgRAIA0oAgAMAQsgDQsoAgBHDQAgABB2GiAGQQA6AAAgDSACAn8gDS0AC0EHdgRAIA0oAgQMAQsgDS0AC0H/AHELQQFLGyEBDAYLAkACfyAMLQALQQd2BEAgDCgCBAwBCyAMLQALQf8AcQtFDQACfyAAKAIAIgEoAgwiBCABKAIQRgRAIAEgASgCACgCJBEBAAwBCyAEKAIACwJ/IAwtAAtBB3YEQCAMKAIADAELIAwLKAIARw0AIAAQdhogBkEBOgAAIAwgAgJ/IAwtAAtBB3YEQCAMKAIEDAELIAwtAAtB/wBxC0EBSxshAQwGCwJAAn8gDS0AC0EHdgRAIA0oAgQMAQsgDS0AC0H/AHELRQ0AAn8gDC0AC0EHdgRAIAwoAgQMAQsgDC0AC0H/AHELRQ0AIAUgBSgCAEEEcjYCAEEAIQAMBAsCfyANLQALQQd2BEAgDSgCBAwBCyANLQALQf8AcQtFBEACfyAMLQALQQd2BEAgDCgCBAwBCyAMLQALQf8AcQtFDQULIAYCfyAMLQALQQd2BEAgDCgCBAwBCyAMLQALQf8AcQtFOgAADAQLAkAgA0ECSQ0AIAINACASDQBBACEBIANBAkYgCy0AX0EAR3FFDQULIAsgDhCZATYCCCALIAsoAgg2AgwCQCADRQ0AIAMgC2otAFtBAUsNAANAAkAgCyAOEMsBNgIIIAsoAgwiASALKAIIRg0AIAdBASABKAIAIAcoAgAoAgwRBABFDQAgCyALKAIMQQRqNgIMDAELCyALIA4QmQE2AggCfyAQLQALQQd2BEAgECgCBAwBCyAQLQALQf8AcQsgCygCDCALQQhqIgEoAgBrQQJ1IgRPBEAgCyAQEMsBNgIIIAFBACAEaxCnAyEUIBAQywEhBCAOEJkBIQojAEEQayITJAAgFBDWASEBIAQQ1gEhBCABIAoQ1gEgBCABa0F8cRBfRSEVIBNBEGokACAVDQELIAsgDhCZATYCBCALIAsoAgQ2AgggCyALKAIINgIMCyALIAsoAgw2AggDQAJAIAsgDhDLATYCBCALKAIIIAsoAgRGDQAgACALQYwEahBdDQACfyAAKAIAIgEoAgwiBCABKAIQRgRAIAEgASgCACgCJBEBAAwBCyAEKAIACyALKAIIKAIARw0AIAAQdhogCyALKAIIQQRqNgIIDAELCyASRQ0DIAsgDhDLATYCBCALKAIIIAsoAgRGDQMgBSAFKAIAQQRyNgIAQQAhAAwCCwNAAkAgACALQYwEahBdDQACfyAHQcAAAn8gACgCACIBKAIMIgQgASgCEEYEQCABIAEoAgAoAiQRAQAMAQsgBCgCAAsiASAHKAIAKAIMEQQABEAgCSgCACIEIAsoAogERgRAIAggCSALQYgEahDtASAJKAIAIQQLIAkgBEEEajYCACAEIAE2AgAgCkEBagwBCwJ/IA8tAAtBB3YEQCAPKAIEDAELIA8tAAtB/wBxC0UNASAKRQ0BIAEgCygCVEcNASALKAJkIgEgCygCYEYEQCARIAtB5ABqIAtB4ABqEO0BIAsoAmQhAQsgCyABQQRqNgJkIAEgCjYCAEEACyEKIAAQdhoMAQsLAkAgCygCZCIBIBEoAgBGDQAgCkUNACALKAJgIAFGBEAgESALQeQAaiALQeAAahDtASALKAJkIQELIAsgAUEEajYCZCABIAo2AgALAkAgCygCFEEATA0AAkAgACALQYwEahBdRQRAAn8gACgCACIBKAIMIgQgASgCEEYEQCABIAEoAgAoAiQRAQAMAQsgBCgCAAsgCygCWEYNAQsgBSAFKAIAQQRyNgIAQQAhAAwDCwNAIAAQdhogCygCFEEATA0BAkAgACALQYwEahBdRQRAIAdBwAACfyAAKAIAIgEoAgwiBCABKAIQRgRAIAEgASgCACgCJBEBAAwBCyAEKAIACyAHKAIAKAIMEQQADQELIAUgBSgCAEEEcjYCAEEAIQAMBAsgCSgCACALKAKIBEYEQCAIIAkgC0GIBGoQ7QELAn8gACgCACIBKAIMIgQgASgCEEYEQCABIAEoAgAoAiQRAQAMAQsgBCgCAAshASAJIAkoAgAiBEEEajYCACAEIAE2AgAgCyALKAIUQQFrNgIUDAALAAsgAiEBIAgoAgAgCSgCAEcNAyAFIAUoAgBBBHI2AgBBACEADAELAkAgAkUNAEEBIQoDQAJ/IAItAAtBB3YEQCACKAIEDAELIAItAAtB/wBxCyAKTQ0BAkAgACALQYwEahBdRQRAAn8gACgCACIBKAIMIgMgASgCEEYEQCABIAEoAgAoAiQRAQAMAQsgAygCAAsCfyACLQALQQd2BEAgAigCAAwBCyACCyAKQQJ0aigCAEYNAQsgBSAFKAIAQQRyNgIAQQAhAAwDCyAAEHYaIApBAWohCgwACwALQQEhACARKAIAIAsoAmRGDQBBACEAIAtBADYCDCAPIBEoAgAgCygCZCALQQxqEIMBIAsoAgwEQCAFIAUoAgBBBHI2AgAMAQtBASEACyAQEGoaIAwQahogDRBqGiAOEGoaIA8QRhogESgCACEBIBFBADYCACABBEAgASARKAIEEQAACwwDCyACIQELIANBAWohAwwACwALIAtBkARqJAAgAAs5AQJ/IAEoAgAhAyABQQA2AgAgACgCACECIAAgAzYCACACBEAgAiAAKAIEEQAACyAAIAEoAgQ2AgQL5AEBBn8jAEEQayIFJAAgACgCBCEDQQECfyACKAIAIAAoAgBrIgRB/////wdJBEAgBEEBdAwBC0F/CyIEIARBAU0bIQQgASgCACEHIAAoAgAhCCADQYYLRgR/QQAFIAAoAgALIAQQ1wIiBgRAIANBhgtHBEAgACgCABogAEEANgIACyAFQYULNgIEIAAgBUEIaiAGIAVBBGoQayIDEIAFIAMoAgAhBiADQQA2AgAgBgRAIAYgAygCBBEAAAsgASAAKAIAIAcgCGtqNgIAIAIgBCAAKAIAajYCACAFQRBqJAAPCxBsAAsgAQF/IAEoAgAQzQXAIQIgACABKAIANgIEIAAgAjoAAAvwGAELfyMAQZAEayILJAAgCyAKNgKIBCALIAE2AowEAkAgACALQYwEahBeBEAgBSAFKAIAQQRyNgIAQQAhAAwBCyALQYYLNgJMIAsgC0HoAGogC0HwAGogC0HMAGoiDxBrIhEoAgAiATYCZCALIAFBkANqNgJgIwBBEGsiASQAIA9CADcCACAPQQA2AgggAUEQaiQAIwBBEGsiASQAIAtBQGsiDkIANwIAIA5BADYCCCABQRBqJAAjAEEQayIBJAAgC0E0aiINQgA3AgAgDUEANgIIIAFBEGokACMAQRBrIgEkACALQShqIgxCADcCACAMQQA2AgggAUEQaiQAIwBBEGsiASQAIAtBHGoiEEIANwIAIBBBADYCCCABQRBqJAAjAEEQayIKJAAgCwJ/IAIEQCAKQQRqIgIgA0GczgYQQyIBIAEoAgAoAiwRAgAgCyAKKAIENgBcIAIgASABKAIAKAIgEQIAIAwgAhCEASACEEYaIAIgASABKAIAKAIcEQIAIA0gAhCEASACEEYaIAsgASABKAIAKAIMEQEAOgBbIAsgASABKAIAKAIQEQEAOgBaIAIgASABKAIAKAIUEQIAIA8gAhCEASACEEYaIAIgASABKAIAKAIYEQIAIA4gAhCEASACEEYaIAEgASgCACgCJBEBAAwBCyAKQQRqIgIgA0GUzgYQQyIBIAEoAgAoAiwRAgAgCyAKKAIENgBcIAIgASABKAIAKAIgEQIAIAwgAhCEASACEEYaIAIgASABKAIAKAIcEQIAIA0gAhCEASACEEYaIAsgASABKAIAKAIMEQEAOgBbIAsgASABKAIAKAIQEQEAOgBaIAIgASABKAIAKAIUEQIAIA8gAhCEASACEEYaIAIgASABKAIAKAIYEQIAIA4gAhCEASACEEYaIAEgASgCACgCJBEBAAs2AhggCkEQaiQAIAkgCCgCADYCACAEQYAEcSESQQAhA0EAIQEDQCABIQICQAJAAkACQCADQQRGDQAgACALQYwEahBeDQBBACEKAkACQAJAAkACQAJAIAtB3ABqIANqLQAADgUBAAQDBQkLIANBA0YNBwJ/IAAoAgAiASgCDCIEIAEoAhBGBEAgASABKAIAKAIkEQEADAELIAQtAAALwCIBQQBOBH8gBygCCCABQQJ0aigCAEEBcQVBAAsEQCALQRBqIAAQggUgECALLAAQEIYCDAILIAUgBSgCAEEEcjYCAEEAIQAMBgsgA0EDRg0GCwNAIAAgC0GMBGoQXg0GAn8gACgCACIBKAIMIgQgASgCEEYEQCABIAEoAgAoAiQRAQAMAQsgBC0AAAvAIgFBAE4EfyAHKAIIIAFBAnRqKAIAQQFxBUEAC0UNBiALQRBqIAAQggUgECALLAAQEIYCDAALAAsCQAJ/IA0tAAtBB3YEQCANKAIEDAELIA0tAAtB/wBxC0UNAAJ/IAAoAgAiASgCDCIEIAEoAhBGBEAgASABKAIAKAIkEQEADAELIAQtAAALwEH/AXECfyANLQALQQd2BEAgDSgCAAwBCyANCy0AAEcNACAAEHcaIAZBADoAACANIAICfyANLQALQQd2BEAgDSgCBAwBCyANLQALQf8AcQtBAUsbIQEMBgsCQAJ/IAwtAAtBB3YEQCAMKAIEDAELIAwtAAtB/wBxC0UNAAJ/IAAoAgAiASgCDCIEIAEoAhBGBEAgASABKAIAKAIkEQEADAELIAQtAAALwEH/AXECfyAMLQALQQd2BEAgDCgCAAwBCyAMCy0AAEcNACAAEHcaIAZBAToAACAMIAICfyAMLQALQQd2BEAgDCgCBAwBCyAMLQALQf8AcQtBAUsbIQEMBgsCQAJ/IA0tAAtBB3YEQCANKAIEDAELIA0tAAtB/wBxC0UNAAJ/IAwtAAtBB3YEQCAMKAIEDAELIAwtAAtB/wBxC0UNACAFIAUoAgBBBHI2AgBBACEADAQLAn8gDS0AC0EHdgRAIA0oAgQMAQsgDS0AC0H/AHELRQRAAn8gDC0AC0EHdgRAIAwoAgQMAQsgDC0AC0H/AHELRQ0FCyAGAn8gDC0AC0EHdgRAIAwoAgQMAQsgDC0AC0H/AHELRToAAAwECwJAIANBAkkNACACDQAgEg0AQQAhASADQQJGIAstAF9BAEdxRQ0FCyALIA4QmQE2AgwgCyALKAIMNgIQAkAgA0UNACADIAtqLQBbQQFLDQADQAJAIAsgDhDNATYCDCALKAIQIgEgCygCDEYNACABLAAAIgFBAE4EfyAHKAIIIAFBAnRqKAIAQQFxBUEAC0UNACALIAsoAhBBAWo2AhAMAQsLIAsgDhCZATYCDAJ/IBAtAAtBB3YEQCAQKAIEDAELIBAtAAtB/wBxCyALKAIQIAtBDGoiASgCAGsiBE8EQCALIBAQzQE2AgwgAUEAIARrEKgDIRQgEBDNASEEIA4QmQEhCiMAQRBrIhMkACAUENYBIQEgBBDWASEEIAEgChDWASAEIAFrEF9FIRUgE0EQaiQAIBUNAQsgCyAOEJkBNgIIIAsgCygCCDYCDCALIAsoAgw2AhALIAsgCygCEDYCDANAAkAgCyAOEM0BNgIIIAsoAgwgCygCCEYNACAAIAtBjARqEF4NAAJ/IAAoAgAiASgCDCIEIAEoAhBGBEAgASABKAIAKAIkEQEADAELIAQtAAALwEH/AXEgCygCDC0AAEcNACAAEHcaIAsgCygCDEEBajYCDAwBCwsgEkUNAyALIA4QzQE2AgggCygCDCALKAIIRg0DIAUgBSgCAEEEcjYCAEEAIQAMAgsDQAJAIAAgC0GMBGoQXg0AAn8CfyAAKAIAIgEoAgwiBCABKAIQRgRAIAEgASgCACgCJBEBAAwBCyAELQAAC8AiAUEATgR/IAcoAgggAUECdGooAgBBwABxBUEACwRAIAkoAgAiBCALKAKIBEYEQCAIIAkgC0GIBGoQgQUgCSgCACEECyAJIARBAWo2AgAgBCABOgAAIApBAWoMAQsCfyAPLQALQQd2BEAgDygCBAwBCyAPLQALQf8AcQtFDQEgCkUNASALLQBaIAFB/wFxRw0BIAsoAmQiASALKAJgRgRAIBEgC0HkAGogC0HgAGoQ7QEgCygCZCEBCyALIAFBBGo2AmQgASAKNgIAQQALIQogABB3GgwBCwsCQCALKAJkIgEgESgCAEYNACAKRQ0AIAsoAmAgAUYEQCARIAtB5ABqIAtB4ABqEO0BIAsoAmQhAQsgCyABQQRqNgJkIAEgCjYCAAsCQCALKAIYQQBMDQACQCAAIAtBjARqEF5FBEACfyAAKAIAIgEoAgwiBCABKAIQRgRAIAEgASgCACgCJBEBAAwBCyAELQAAC8BB/wFxIAstAFtGDQELIAUgBSgCAEEEcjYCAEEAIQAMAwsDQCAAEHcaIAsoAhhBAEwNAQJAIAAgC0GMBGoQXkUEQAJ/IAAoAgAiASgCDCIEIAEoAhBGBEAgASABKAIAKAIkEQEADAELIAQtAAALwCIBQQBOBH8gBygCCCABQQJ0aigCAEHAAHEFQQALDQELIAUgBSgCAEEEcjYCAEEAIQAMBAsgCSgCACALKAKIBEYEQCAIIAkgC0GIBGoQgQULAn8gACgCACIBKAIMIgQgASgCEEYEQCABIAEoAgAoAiQRAQAMAQsgBC0AAAvAIQEgCSAJKAIAIgRBAWo2AgAgBCABOgAAIAsgCygCGEEBazYCGAwACwALIAIhASAIKAIAIAkoAgBHDQMgBSAFKAIAQQRyNgIAQQAhAAwBCwJAIAJFDQBBASEKA0ACfyACLQALQQd2BEAgAigCBAwBCyACLQALQf8AcQsgCk0NAQJAIAAgC0GMBGoQXkUEQAJ/IAAoAgAiASgCDCIDIAEoAhBGBEAgASABKAIAKAIkEQEADAELIAMtAAALwEH/AXECfyACLQALQQd2BEAgAigCAAwBCyACCyAKai0AAEYNAQsgBSAFKAIAQQRyNgIAQQAhAAwDCyAAEHcaIApBAWohCgwACwALQQEhACARKAIAIAsoAmRGDQBBACEAIAtBADYCECAPIBEoAgAgCygCZCALQRBqEIMBIAsoAhAEQCAFIAUoAgBBBHI2AgAMAQtBASEACyAQEEYaIAwQRhogDRBGGiAOEEYaIA8QRhogESgCACEBIBFBADYCACABBEAgASARKAIEEQAACwwDCyACIQELIANBAWohAwwACwALIAtBkARqJAAgAAsMACAAQQFBLRCOBRoLDAAgAEEBQS0QkAUaC20BAX8jAEEQayIGJAAgBkEAOgAPIAYgBToADiAGIAQ6AA0gBkElOgAMIAUEQCAGLQANIQQgBiAGLQAOOgANIAYgBDoADgsgAiABIAIoAgAgAWsgBkEMaiADIAAoAgAQGiABajYCACAGQRBqJAALQgAgASACIAMgBEEEEKwBIQEgAy0AAEEEcUUEQCAAIAFB0A9qIAFB7A5qIAEgAUHkAEkbIAFBxQBIG0HsDms2AgALC0AAIAIgAyAAQQhqIAAoAggoAgQRAQAiACAAQaACaiAFIARBABDJAiAAayIAQZ8CTARAIAEgAEEMbUEMbzYCAAsLQAAgAiADIABBCGogACgCCCgCABEBACIAIABBqAFqIAUgBEEAEMkCIABrIgBBpwFMBEAgASAAQQxtQQdvNgIACwvgCAENfyMAQSBrIgUkAAJAAkAgASgCaCIIIAEoAmwiDUcEQCAFQRhqIQoDQCAFIAo2AhQgBUEANgIYQQAhCSAIKAIsIgsgCCgCMCIORgR/QQAFA0AgCygCACEHIAUoAhgiAyEEIAoiAiEGIAIhAQJAAkAgA0UNAANAIAIiASAEIgYgBCgCECAHSSIMGyECIAQgDEECdGooAgAiBA0ACyACIApHBEAgByABIAYgDBsoAhBPDQcLA0AgAyIBKAIQIgIgB0sEQCABIQYgASgCACIDDQEMAgsgAiAHTw0CIAEoAgQiAw0ACyABQQRqIQYLQRQQLCICIAE2AgggAkIANwIAIAIgBzYCECAGIAI2AgAgBSgCFCgCACIBBEAgBSABNgIUIAYoAgAhAgsgAiACIAUoAhgiBkYiAToADAJAIAENAANAIAIoAggiAy0ADA0BAkAgAyADKAIIIgEoAgAiBEYEQAJAIAEoAgQiB0UNACAHLQAMQQFGDQAgB0EMaiECDAILAkAgAiADKAIARgRAIAMhAgwBCyADIAMoAgQiAigCACIENgIEIAMhBiAEBEAgBCADNgIIIAMoAggiASgCACEGCyACIAE2AgggASADIAZHQQJ0aiACNgIAIAIgAzYCACADIAI2AgggAigCCCIBKAIAIQQLIAJBAToADCABQQA6AAwgASAEKAIEIgI2AgAgAgRAIAIgATYCCAsgBCABKAIIIgI2AgggAiACKAIAIAFHQQJ0aiAENgIAIAQgATYCBCABIAQ2AggMAwsCQCAERQ0AIAQtAAxBAUYNACAEQQxqIQIMAQsCQCACIAMoAgAiBEcEQCADIQQMAQsgAyAEKAIEIgI2AgAgAgRAIAIgAzYCCCADKAIIIQELIAQgATYCCCABIAEoAgAgA0dBAnRqIAQ2AgAgBCADNgIEIAMgBDYCCCAEKAIIIQELIARBAToADCABQQA6AAwgASABKAIEIgIoAgAiAzYCBCADBEAgAyABNgIICyACIAEoAggiAzYCCCADIAMoAgAgAUdBAnRqIAI2AgAgAiABNgIAIAEgAjYCCAwCCyADQQE6AAwgASABIAZGOgAMIAJBAToAACAGIAEiAkcNAAsLIAlBAWohCQsgC0EEaiILIA5HDQALIAUoAhgLIQEgBSAJNgIcIAVBFGogARDKASAIQThqIgggDUcNAAsLIABBkKUFKQIANwIAIABBCGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwCCyAAQZilBSgCAEGcpQUoAgAQLgwBCyAFIAk2AhwgBUEgECwiATYCCCAFQpyAgICAhICAgH83AgwgAUHbJigAADYAGCABQdMmKQAANwAQIAFByyYpAAA3AAggAUHDJikAADcAACABQQA6ABwgAEECQQAgBUEIahAvGiAFLAATQQBIBEAgBSgCEBogBSgCCBAqCyAFQRRqIAUoAhgQygELIAVBIGokAAtCACABIAIgAyAEQQQQrQEhASADLQAAQQRxRQRAIAAgAUHQD2ogAUHsDmogASABQeQASRsgAUHFAEgbQewOazYCAAsLQAAgAiADIABBCGogACgCCCgCBBEBACIAIABBoAJqIAUgBEEAEMoCIABrIgBBnwJMBEAgASAAQQxtQQxvNgIACwtAACACIAMgAEEIaiAAKAIIKAIAEQEAIgAgAEGoAWogBSAEQQAQygIgAGsiAEGnAUwEQCABIABBDG1BB282AgALC7wCAQV/IwBBEGsiByQAIwBBEGsiBCQAIAAhAwJAIAFB9////wNNBEACQCABQQJJBEAgAyADLQALQYABcSABQf8AcXI6AAsgAyADLQALQf8AcToACwwBCyAEQQhqIAFBAk8EfyABQQJqQX5xIgAgAEEBayIAIABBAkYbBUEBC0EBahDrASAEKAIMGiADIAQoAggiADYCACADIAMoAghBgICAgHhxIAQoAgxB/////wdxcjYCCCADIAMoAghBgICAgHhyNgIIIAMgATYCBAsjAEEQayIFJAAgBSACNgIMIAAhAiABIQYDQCAGBEAgAiAFKAIMNgIAIAZBAWshBiACQQRqIQIMAQsLIAVBEGokACAEQQA2AgQgACABQQJ0aiAEKAIENgIAIARBEGokAAwBCxCKAQALIAdBEGokACADC4sHAQt/IwBBEGsiDCQAIAZBnNAGEEMhCSAMQQRqIAZB5NAGEEMiDSIGIAYoAgAoAhQRAgAgBSADNgIAAkACQCAAIggtAAAiBkEraw4DAAEAAQsgCSAGwCAJKAIAKAIsEQUAIQYgBSAFKAIAIgdBBGo2AgAgByAGNgIAIABBAWohCAsCQAJAIAIgCCIGa0EBTA0AIAYtAABBMEcNACAGLQABQSByQfgARw0AIAlBMCAJKAIAKAIsEQUAIQcgBSAFKAIAIghBBGo2AgAgCCAHNgIAIAkgBiwAASAJKAIAKAIsEQUAIQcgBSAFKAIAIghBBGo2AgAgCCAHNgIAIAZBAmoiCCEGA0AgAiAGTQ0CIAYsAAAhBxBgGiAHQTBrQQpJIAdBIHJB4QBrQQZJckUNAiAGQQFqIQYMAAsACwNAIAIgBk0NASAGLAAAIREQYBogEUEwa0EKTw0BIAZBAWohBgwACwALAkACfyAMLQAPQQd2BEAgDCgCCAwBCyAMLQAPQf8AcQtFBEAgCSAIIAYgBSgCACAJKAIAKAIwEQoAGiAFIAUoAgAgBiAIa0ECdGo2AgAMAQsgCCAGENkBIA0gDSgCACgCEBEBACEPIAghBwNAIAYgB00EQCADIAggAGtBAnRqIAUoAgAQxQIFAkACfyAMQQRqIgotAAtBB3YEQCAKKAIADAELIAoLIA5qLAAAQQBMDQAgCwJ/IAotAAtBB3YEQCAKKAIADAELIAoLIA5qLAAARw0AIAUgBSgCACILQQRqNgIAIAsgDzYCACAOIA4CfyAKLQALQQd2BEAgCigCBAwBCyAKLQALQf8AcQtBAWtJaiEOQQAhCwsgCSAHLAAAIAkoAgAoAiwRBQAhCiAFIAUoAgAiEEEEajYCACAQIAo2AgAgB0EBaiEHIAtBAWohCwwBCwsLAkACQANAIAIgBk0NASAGQQFqIQcgBiwAACIGQS5HBEAgCSAGIAkoAgAoAiwRBQAhBiAFIAUoAgAiCEEEajYCACAIIAY2AgAgByEGDAELCyANIA0oAgAoAgwRAQAhBiAFIAUoAgAiCEEEaiILNgIAIAggBjYCAAwBCyAFKAIAIQsgBiEHCyAJIAcgAiALIAkoAgAoAjARCgAaIAUgBSgCACACIAdrQQJ0aiIFNgIAIAQgBSADIAEgAGtBAnRqIAEgAkYbNgIAIAxBBGoQRhogDEEQaiQAC4ECAQN/IwBBEGsiBSQAIwBBEGsiAyQAAkAgAUH3////B00EQAJAIAFBC0kEQCAAIAAtAAtBgAFxIAFB/wBxcjoACyAAIAAtAAtB/wBxOgALIAAhBAwBCyADQQhqIAFBC08EfyABQQhqQXhxIgQgBEEBayIEIARBC0YbBUEKC0EBahDyASADKAIMGiAAIAMoAggiBDYCACAAIAAoAghBgICAgHhxIAMoAgxB/////wdxcjYCCCAAIAAoAghBgICAgHhyNgIIIAAgATYCBAsgBCABIAIQ1gQgA0EAOgAHIAEgBGogAy0ABzoAACADQRBqJAAMAQsQigEACyAFQRBqJAAgAAv7BgELfyMAQRBrIgskACAGQaTQBhBDIQkgC0EEaiAGQdzQBhBDIg0iBiAGKAIAKAIUEQIAIAUgAzYCAAJAAkAgACIILQAAIgZBK2sOAwABAAELIAkgBsAgCSgCACgCHBEFACEGIAUgBSgCACIHQQFqNgIAIAcgBjoAACAAQQFqIQgLAkACQCACIAgiBmtBAUwNACAGLQAAQTBHDQAgBi0AAUEgckH4AEcNACAJQTAgCSgCACgCHBEFACEHIAUgBSgCACIIQQFqNgIAIAggBzoAACAJIAYsAAEgCSgCACgCHBEFACEHIAUgBSgCACIIQQFqNgIAIAggBzoAACAGQQJqIgghBgNAIAIgBk0NAiAGLAAAIQcQYBogB0Ewa0EKSSAHQSByQeEAa0EGSXJFDQIgBkEBaiEGDAALAAsDQCACIAZNDQEgBiwAACEREGAaIBFBMGtBCk8NASAGQQFqIQYMAAsACwJAAn8gCy0AD0EHdgRAIAsoAggMAQsgCy0AD0H/AHELRQRAIAkgCCAGIAUoAgAgCSgCACgCIBEKABogBSAFKAIAIAYgCGtqNgIADAELIAggBhDZASANIA0oAgAoAhARAQAhDyAIIQcDQCAGIAdNBEAgAyAIIABraiAFKAIAENkBBQJAAn8gC0EEaiIKLQALQQd2BEAgCigCAAwBCyAKCyAOaiwAAEEATA0AIAwCfyAKLQALQQd2BEAgCigCAAwBCyAKCyAOaiwAAEcNACAFIAUoAgAiDEEBajYCACAMIA86AAAgDiAOAn8gCi0AC0EHdgRAIAooAgQMAQsgCi0AC0H/AHELQQFrSWohDkEAIQwLIAkgBywAACAJKAIAKAIcEQUAIQogBSAFKAIAIhBBAWo2AgAgECAKOgAAIAdBAWohByAMQQFqIQwMAQsLCwNAAkACQCACIAZNBEAgBiEHDAELIAZBAWohByAGLAAAIgZBLkcNASANIA0oAgAoAgwRAQAhBiAFIAUoAgAiCEEBajYCACAIIAY6AAALIAkgByACIAUoAgAgCSgCACgCIBEKABogBSAFKAIAIAIgB2tqIgU2AgAgBCAFIAMgASAAa2ogASACRhs2AgAgC0EEahBGGiALQRBqJAAPCyAJIAYgCSgCACgCHBEFACEGIAUgBSgCACIIQQFqNgIAIAggBjoAACAHIQYMAAsAC5sFAQV/IwBB0AJrIgAkACAAIAI2AsgCIAAgATYCzAIgAxCvASEGIAMgAEHQAWoQjAIhByAAQcQBaiADIABBxAJqEIsCIwBBEGsiAiQAIABBuAFqIgFCADcCACABQQA2AgggAkEQaiQAIAEgAS0AC0EHdgR/IAEoAghB/////wdxQQFrBUEKCxBQIAACfyABLQALQQd2BEAgASgCAAwBCyABCyICNgK0ASAAIABBEGo2AgwgAEEANgIIA0ACQCAAQcwCaiAAQcgCahBdDQAgACgCtAECfyABLQALQQd2BEAgASgCBAwBCyABLQALQf8AcQsgAmpGBEACfyABLQALQQd2BEAgASgCBAwBCyABLQALQf8AcQshAyABAn8gAS0AC0EHdgRAIAEoAgQMAQsgAS0AC0H/AHELQQF0EFAgASABLQALQQd2BH8gASgCCEH/////B3FBAWsFQQoLEFAgACADAn8gAS0AC0EHdgRAIAEoAgAMAQsgAQsiAmo2ArQBCwJ/IABBzAJqIggoAgAiAygCDCIJIAMoAhBGBEAgAyADKAIAKAIkEQEADAELIAkoAgALIAYgAiAAQbQBaiAAQQhqIAAoAsQCIABBxAFqIABBEGogAEEMaiAHEO4BDQAgCBB2GgwBCwsCQAJ/IAAtAM8BQQd2BEAgACgCyAEMAQsgAC0AzwFB/wBxC0UNACAAKAIMIgMgAEEQamtBnwFKDQAgACADQQRqNgIMIAMgACgCCDYCAAsgBSACIAAoArQBIAQgBhCYBTYCACAAQcQBaiAAQRBqIAAoAgwgBBCDASAAQcwCaiAAQcgCahBdBEAgBCAEKAIAQQJyNgIACyAAKALMAiEKIAEQRhogAEHEAWoQRhogAEHQAmokACAKC2wBAn8jAEEQayIDJAAgAyABNgIMIAMgAjYCCCADQQRqIANBDGoQpwEhBCAAQZYzIAMoAggQogUhAiAEKAIAIgAEQEHorwYoAgAaIAAEQEHorwZB8K4GIAAgAEF/Rhs2AgALCyADQRBqJAAgAguxAgIEfgV/IwBBIGsiCCQAAkACQAJAIAEgAkcEQEHArgYoAgAhDEHArgZBADYCACMAQRBrIgkkABBgGiMAQRBrIgokACMAQRBrIgskACALIAEgCEEcakECELUDIAspAwAhBCAKIAspAwg3AwggCiAENwMAIAtBEGokACAKKQMAIQQgCSAKKQMINwMIIAkgBDcDACAKQRBqJAAgCSkDACEEIAggCSkDCDcDECAIIAQ3AwggCUEQaiQAIAgpAxAhBCAIKQMIIQVBwK4GKAIAIgFFDQEgCCgCHCACRw0CIAUhBiAEIQcgAUHEAEcNAwwCCyADQQQ2AgAMAgtBwK4GIAw2AgAgCCgCHCACRg0BCyADQQQ2AgAgBiEFIAchBAsgACAFNwMAIAAgBDcDCCAIQSBqJAALtgECA38CfCMAQRBrIgMkAAJAAkACQCAAIAFHBEBBwK4GKAIAIQVBwK4GQQA2AgAQYBojAEEQayIEJAAgBCAAIANBDGpBARC1AyAEKQMAIAQpAwgQygMhBiAEQRBqJABBwK4GKAIAIgBFDQEgAygCDCABRw0CIAYhByAAQcQARw0DDAILIAJBBDYCAAwCC0HArgYgBTYCACADKAIMIAFGDQELIAJBBDYCACAHIQYLIANBEGokACAGC7YBAgN/An0jAEEQayIDJAACQAJAAkAgACABRwRAQcCuBigCACEFQcCuBkEANgIAEGAaIwBBEGsiBCQAIAQgACADQQxqQQAQtQMgBCkDACAEKQMIEKQFIQYgBEEQaiQAQcCuBigCACIARQ0BIAMoAgwgAUcNAiAGIQcgAEHEAEcNAwwCCyACQQQ2AgAMAgtBwK4GIAU2AgAgAygCDCABRg0BCyACQQQ2AgAgByEGCyADQRBqJAAgBgvJAQIDfwJ+IwBBEGsiBCQAAn4CQAJAIAAgAUcEQAJAAkAgAC0AACIFQS1HDQAgAEEBaiIAIAFHDQAMAQtBwK4GKAIAIQZBwK4GQQA2AgAQYBogACAEQQxqIANCfxCPAiEHAkBBwK4GKAIAIgAEQCAEKAIMIAFHDQEgAEHEAEYNBAwFC0HArgYgBjYCACAEKAIMIAFGDQQLCwsgAkEENgIAQgAMAgsgAkEENgIAQn8MAQtCACAHfSAHIAVBLUYbCyEIIARBEGokACAIC9oBAgR/AX4jAEEQayIEJAACfwJAAkACQCAAIAFHBEACQAJAIAAtAAAiBUEtRw0AIABBAWoiACABRw0ADAELQcCuBigCACEGQcCuBkEANgIAEGAaIAAgBEEMaiADQn8QjwIhCAJAQcCuBigCACIABEAgBCgCDCABRw0BIABBxABGDQUMBAtBwK4GIAY2AgAgBCgCDCABRg0DCwsLIAJBBDYCAEEADAMLIAhC/////w9YDQELIAJBBDYCAEF/DAELQQAgCKciAGsgACAFQS1GGwshByAEQRBqJAAgBwuRBQEEfyMAQYACayIAJAAgACACNgL4ASAAIAE2AvwBIAMQrwEhBiAAQcQBaiADIABB9wFqEI4CIwBBEGsiAiQAIABBuAFqIgFCADcCACABQQA2AgggAkEQaiQAIAEgAS0AC0EHdgR/IAEoAghB/////wdxQQFrBUEKCxBQIAACfyABLQALQQd2BEAgASgCAAwBCyABCyICNgK0ASAAIABBEGo2AgwgAEEANgIIA0ACQCAAQfwBaiAAQfgBahBeDQAgACgCtAECfyABLQALQQd2BEAgASgCBAwBCyABLQALQf8AcQsgAmpGBEACfyABLQALQQd2BEAgASgCBAwBCyABLQALQf8AcQshAyABAn8gAS0AC0EHdgRAIAEoAgQMAQsgAS0AC0H/AHELQQF0EFAgASABLQALQQd2BH8gASgCCEH/////B3FBAWsFQQoLEFAgACADAn8gAS0AC0EHdgRAIAEoAgAMAQsgAQsiAmo2ArQBCwJ/IABB/AFqIgcoAgAiAygCDCIIIAMoAhBGBEAgAyADKAIAKAIkEQEADAELIAgtAAALwCAGIAIgAEG0AWogAEEIaiAALAD3ASAAQcQBaiAAQRBqIABBDGpBwPsDEO8BDQAgBxB3GgwBCwsCQAJ/IAAtAM8BQQd2BEAgACgCyAEMAQsgAC0AzwFB/wBxC0UNACAAKAIMIgMgAEEQamtBnwFKDQAgACADQQRqNgIMIAMgACgCCDYCAAsgBSACIAAoArQBIAQgBhCYBTYCACAAQcQBaiAAQRBqIAAoAgwgBBCDASAAQfwBaiAAQfgBahBeBEAgBCAEKAIAQQJyNgIACyAAKAL8ASEJIAEQRhogAEHEAWoQRhogAEGAAmokACAJC98BAgR/AX4jAEEQayIEJAACfwJAAkACQCAAIAFHBEACQAJAIAAtAAAiBUEtRw0AIABBAWoiACABRw0ADAELQcCuBigCACEGQcCuBkEANgIAEGAaIAAgBEEMaiADQn8QjwIhCAJAQcCuBigCACIABEAgBCgCDCABRw0BIABBxABGDQUMBAtBwK4GIAY2AgAgBCgCDCABRg0DCwsLIAJBBDYCAEEADAMLIAhC//8DWA0BCyACQQQ2AgBB//8DDAELQQAgCKciAGsgACAFQS1GGwshByAEQRBqJAAgB0H//wNxC8IBAgF+An8jAEEQayIFJAACQAJAIAAgAUcEQEHArgYoAgAhBkHArgZBADYCABBgGiAAIAVBDGogA0KAgICAgICAgIB/EI8CIQQCQEHArgYoAgAiAARAIAUoAgwgAUcNASAAQcQARg0DDAQLQcCuBiAGNgIAIAUoAgwgAUYNAwsLIAJBBDYCAEIAIQQMAQsgAkEENgIAIARCAFUEQEL///////////8AIQQMAQtCgICAgICAgICAfyEECyAFQRBqJAAgBAvQAQIDfwF+IwBBEGsiBCQAAn8CQAJAIAAgAUcEQEHArgYoAgAhBUHArgZBADYCABBgGiAAIARBDGogA0KAgICAgICAgIB/EI8CIQcCQEHArgYoAgAiAARAIAQoAgwgAUcNASAAQcQARg0EDAMLQcCuBiAFNgIAIAQoAgwgAUYNAgsLIAJBBDYCAEEADAILIAdCgICAgHhTDQAgB0L/////B1UNACAHpwwBCyACQQQ2AgBB/////wcgB0IAVQ0AGkGAgICAeAshBiAEQRBqJAAgBguQAgEDfwJAIwBBEGsiBCQAIAIgAWtBAnUiBUH3////A00EQAJAIAVBAkkEQCAAIAAtAAtBgAFxIAVB/wBxcjoACyAAIAAtAAtB/wBxOgALIAAhAwwBCyAEQQhqIAVBAk8EfyAFQQJqQX5xIgMgA0EBayIDIANBAkYbBUEBC0EBahDrASAEKAIMGiAAIAQoAggiAzYCACAAIAAoAghBgICAgHhxIAQoAgxB/////wdxcjYCCCAAIAAoAghBgICAgHhyNgIIIAAgBTYCBAsDQCABIAJHBEAgAyABKAIANgIAIANBBGohAyABQQRqIQEMAQsLIARBADYCBCADIAQoAgQ2AgAgBEEQaiQADAELEIoBAAsLtggBBX8gASgCACEEAkACQAJAAkACQAJAAkACfwJAAkACQAJAIANFDQAgAygCACIGRQ0AIABFBEAgAiEDDAMLIANBADYCACACIQMMAQsCQEHorwYoAgAoAgBFBEAgAEUNASACRQ0MIAIhBgNAIAQsAAAiAwRAIAAgA0H/vwNxNgIAIABBBGohACAEQQFqIQQgBkEBayIGDQEMDgsLIABBADYCACABQQA2AgAgAiAGaw8LIAIhAyAARQ0DDAULIAQQWA8LQQEhBQwDC0EADAELQQELIQUD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qAMhGCAEKQOgAyEZAkAgFEECayAHQf////8HcU4NACAEIBhC////////////AIM3A5gDIAQgGTcDkAMgBEGAA2ogGSAYQgBCgICAgICAgP8/EGYgBCkDkAMgBCkDmANCgICAgICAgLjAABCrBSEDIAQpA4gDIBggA0EATiICGyEYIAQpA4ADIBkgAhshGSAXIBpCAEIAENsBIQEgFCACIA5qIg5B7gBqTgRAIAggBiAJRyADQQBIcnEgAUEAR3FFDQELQcCuBkHEADYCAAsgBEHwAmogGSAYIA4QqQUgBCkD+AIhFyAEKQPwAgshGCAMIBc3AyggDCAYNwMgIARBkMYAaiQAIAwpAyghFyAMKQMgIRgMAQtCACEXCyAAIBg3AwAgACAXNwMIIAxBMGokAAvHBgIEfwR+IwBBgAFrIgUkAAJAAkACQCADIARCAEIAENsBRQ0AAn8gBEL///////8/gyEKAn8gBEIwiKdB//8BcSIHQf//AUcEQEEEIAcNARpBAkEDIAMgCoRQGwwCCyADIAqEUAsLRQ0AIAJCMIinIghB//8BcSIGQf//AUcNAQsgBUEQaiABIAIgAyAEEGYgBSAFKQMQIgIgBSkDGCIBIAIgARCoBSAFKQMIIQIgBSkDACEEDAELIAEgAkL///////////8AgyIKIAMgBEL///////////8AgyIJENsBQQBMBEAgASAKIAMgCRDbAQRAIAEhBAwCCyAFQfAAaiABIAJCAEIAEGYgBSkDeCECIAUpA3AhBAwBCyAEQjCIp0H//wFxIQcgBgR+IAEFIAVB4ABqIAEgCkIAQoCAgICAgMC7wAAQZiAFKQNoIgpCMIinQfgAayEGIAUpA2ALIQQgB0UEQCAFQdAAaiADIAlCAEKAgICAgIDAu8AAEGYgBSkDWCIJQjCIp0H4AGshByAFKQNQIQMLIAlC////////P4NCgICAgICAwACEIQsgCkL///////8/g0KAgICAgIDAAIQhCiAGIAdKBEADQAJ+IAogC30gAyAEVq19IglCAFkEQCAJIAQgA30iBIRQBEAgBUEgaiABIAJCAEIAEGYgBSkDKCECIAUpAyAhBAwFCyAJQgGGIARCP4iEDAELIApCAYYgBEI/iIQLIQogBEIBhiEEIAZBAWsiBiAHSg0ACyAHIQYLAkAgCiALfSADIARWrX0iCUIAUwRAIAohCQwBCyAJIAQgA30iBIRCAFINACAFQTBqIAEgAkIAQgAQZiAFKQM4IQIgBSkDMCEEDAELIAlC////////P1gEQANAIARCP4ghDCAGQQFrIQYgBEIBhiEEIAwgCUIBhoQiCUKAgICAgIDAAFQNAAsLIAhBgIACcSEHIAZBAEwEQCAFQUBrIAQgCUL///////8/gyAGQfgAaiAHcq1CMIaEQgBCgICAgICAwMM/EGYgBSkDSCECIAUpA0AhBAwBCyAJQv///////z+DIAYgB3KtQjCGhCECCyAAIAQ3AwAgACACNwMIIAVBgAFqJAALrQ8CBX8PfiMAQdACayIFJAAgBEL///////8/gyEKIAJC////////P4MhCyACIASFQoCAgICAgICAgH+DIQwgBEIwiKdB//8BcSEIAkACQCACQjCIp0H//wFxIglB//8Ba0GCgH5PBEAgCEH//wFrQYGAfksNAQsgAVAgAkL///////////8AgyINQoCAgICAgMD//wBUIA1CgICAgICAwP//AFEbRQRAIAJCgICAgICAIIQhDAwCCyADUCAEQv///////////wCDIgJCgICAgICAwP//AFQgAkKAgICAgIDA//8AURtFBEAgBEKAgICAgIAghCEMIAMhAQwCCyABIA1CgICAgICAwP//AIWEUARAIAMgAkKAgICAgIDA//8AhYRQBEBCACEBQoCAgICAgOD//wAhDAwDCyAMQoCAgICAgMD//wCEIQxCACEBDAILIAMgAkKAgICAgIDA//8AhYRQBEBCACEBDAILIAEgDYRQBEBCgICAgICA4P//ACAMIAIgA4RQGyEMQgAhAQwCCyACIAOEUARAIAxCgICAgICAwP//AIQhDEIAIQEMAgsgDUL///////8/WARAIAVBwAJqIAEgCyABIAsgC1AiBht5IAZBBnStfKciBkEPaxCGAUEQIAZrIQYgBSkDyAIhCyAFKQPAAiEBCyACQv///////z9WDQAgBUGwAmogAyAKIAMgCiAKUCIHG3kgB0EGdK18pyIHQQ9rEIYBIAYgB2pBEGshBiAFKQO4AiEKIAUpA7ACIQMLIAVBoAJqIApCgICAgICAwACEIhJCD4YgA0IxiIQiAkIAQoCAgICw5ryC9QAgAn0iBEIAEHwgBUGQAmpCACAFKQOoAn1CACAEQgAQfCAFQYACaiAFKQOYAkIBhiAFKQOQAkI/iIQiBEIAIAJCABB8IAVB8AFqIARCAEIAIAUpA4gCfUIAEHwgBUHgAWogBSkD+AFCAYYgBSkD8AFCP4iEIgRCACACQgAQfCAFQdABaiAEQgBCACAFKQPoAX1CABB8IAVBwAFqIAUpA9gBQgGGIAUpA9ABQj+IhCIEQgAgAkIAEHwgBUGwAWogBEIAQgAgBSkDyAF9QgAQfCAFQaABaiACQgAgBSkDuAFCAYYgBSkDsAFCP4iEQgF9IgJCABB8IAVBkAFqIANCD4ZCACACQgAQfCAFQfAAaiACQgBCACAFKQOoASAFKQOgASINIAUpA5gBfCIEIA1UrXwgBEIBVq18fUIAEHwgBUGAAWpCASAEfUIAIAJCABB8IAYgCSAIa2ohBgJ/IAUpA3AiE0IBhiIOIAUpA4gBIg9CAYYgBSkDgAFCP4iEfCIQQufsAH0iFEIgiCICIAtCgICAgICAwACEIhVCAYYiFkIgiCIEfiIRIAFCAYYiDUIgiCIKIBAgFFatIA4gEFatIAUpA3hCAYYgE0I/iIQgD0I/iHx8fEIBfSITQiCIIhB+fCIOIBFUrSAOIA4gE0L/////D4MiEyABQj+IIhcgC0IBhoRC/////w+DIgt+fCIOVq18IAQgEH58IAQgE34iESALIBB+fCIPIBFUrUIghiAPQiCIhHwgDiAOIA9CIIZ8Ig5WrXwgDiAOIBRC/////w+DIhQgC34iESACIAp+fCIPIBFUrSAPIA8gEyANQv7///8PgyIRfnwiD1atfHwiDlatfCAOIAQgFH4iGCAQIBF+fCIEIAIgC358IgsgCiATfnwiEEIgiCALIBBWrSAEIBhUrSAEIAtWrXx8QiCGhHwiBCAOVK18IAQgDyACIBF+IgIgCiAUfnwiCkIgiCACIApWrUIghoR8IgIgD1StIAIgEEIghnwgAlStfHwiAiAEVK18IgRC/////////wBYBEAgFiAXhCEVIAVB0ABqIAIgBCADIBIQfCABQjGGIAUpA1h9IAUpA1AiAUIAUq19IQpCACABfSELIAZB/v8AagwBCyAFQeAAaiAEQj+GIAJCAYiEIgIgBEIBiCIEIAMgEhB8IAFCMIYgBSkDaH0gBSkDYCINQgBSrX0hCkIAIA19IQsgASENIAZB//8AagsiBkH//wFOBEAgDEKAgICAgIDA//8AhCEMQgAhAQwBCwJ+IAZBAEoEQCAKQgGGIAtCP4iEIQEgBEL///////8/gyAGrUIwhoQhCiALQgGGDAELIAZBj39MBEBCACEBDAILIAVBQGsgAiAEQQEgBmsQ3QEgBUEwaiANIBUgBkHwAGoQhgEgBUEgaiADIBIgBSkDQCICIAUpA0giChB8IAUpAzggBSkDKEIBhiAFKQMgIgFCP4iEfSAFKQMwIgQgAUIBhiINVK19IQEgBCANfQshBCAFQRBqIAMgEkIDQgAQfCAFIAMgEkIFQgAQfCAKIAIgAiADIAQgAkIBgyIEfCIDVCABIAMgBFStfCIBIBJWIAEgElEbrXwiAlatfCIEIAIgAiAEQoCAgICAgMD//wBUIAMgBSkDEFYgASAFKQMYIgRWIAEgBFEbca18IgJWrXwiBCACIARCgICAgICAwP//AFQgAyAFKQMAViABIAUpAwgiA1YgASADURtxrXwiASACVK18IAyEIQwLIAAgATcDACAAIAw3AwggBUHQAmokAAu/AgEBfyMAQdAAayIEJAACQCADQYCAAU4EQCAEQSBqIAEgAkIAQoCAgICAgID//wAQZiAEKQMoIQIgBCkDICEBIANB//8BSQRAIANB//8AayEDDAILIARBEGogASACQgBCgICAgICAgP//ABBmQf3/AiADIANB/f8CTxtB/v8BayEDIAQpAxghAiAEKQMQIQEMAQsgA0GBgH9KDQAgBEFAayABIAJCAEKAgICAgICAORBmIAQpA0ghAiAEKQNAIQEgA0H0gH5LBEAgA0GN/wBqIQMMAQsgBEEwaiABIAJCAEKAgICAgICAORBmQeiBfSADIANB6IF9TRtBmv4BaiEDIAQpAzghAiAEKQMwIQELIAQgASACQgAgA0H//wBqrUIwhhBmIAAgBCkDCDcDCCAAIAQpAwA3AwAgBEHQAGokAAs8ACAAIAE3AwAgACACQv///////z+DIAJCgICAgICAwP//AINCMIinIANCMIinQYCAAnFyrUIwhoQ3AwgLwAECAX8CfkF/IQMCQCAAQgBSIAFC////////////AIMiBEKAgICAgIDA//8AViAEQoCAgICAgMD//wBRGw0AIAJC////////////AIMiBUKAgICAgIDA//8AViAFQoCAgICAgMD//wBS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AClFBEAgAQRAAkAgGkEITARAICogIyAEQYCAAmogCCAJIAogCygCsAERCQAMAQsgKiAjIARBgIACaiAIIAkgCiAaIAsoAsABEQgACyACKAIURQ0EIAogMW0hACAJIDNtIQEgGUEITARAICcgDiAEIAggASAAIAsoArABEQkAICYgDiArIAggASAAIAsoArABEQkADAULICcgDiAEIAggASAAIBkgCygCwAERCAAgJiAOICsgCCABIAAgGSALKALAAREIAAwECyA0QfMHQQAQUSACQQM6ALgCDAMLIAEEQCARIAUtAIQDaiEBIAUgOCwAACIHaiwAhgQgBnQhBiAFIAdBAXRqIg8sAKcFIUcgBSAHQQJ0aiIRLgGoBCEHIA8sAKYFIUYgES4BpgQhESAPLgHGAyEPIAUtAIUDIUUCQCAaQQhMBEAgKiAjIARBgIACaiAIIAkgCiAPIAYgASALKAK0AREUAAwBCyAqICMgBEGAgAJqIAggCSAKIA8gBiABIBogCygCxAEREQALIAIoAhRFDQMgCiAxbSEBIAkgM20hBSBFIBVqIQYgRiAAdCEPIEcgAHQhACAZQQhMBEAgJyAOIAQgCCAFIAEgESAPIAYgCygCtAERFAAgJiAOICsgCCAFIAEgByAAIAYgCygCtAERFAAMBAsgJyAOIAQgCCAFIAEgESAPIAYgGSALKALEARERACAmIA4gKyAIIAUgASAHIAAgBiAZIAsoAsQBEREADAMLIDRB8wdBABBRIAJBAzoAuAIMAgtB6IEBQYL1AEGQBEGAJBABAAsCQCAHQQFHDQAgD0EBRw0AIDctACpFBEAgBEGAwAJqIQACQCAaQQhMBEAgKiAjIARBgIACaiAAIAggCSAKIAsoAqwBEQgADAELICogIyAEQYCAAmogACAIIAkgCiAaIAsoArwBEQ0ACyACKAIURQ0CIAogMW0hACAJIDNtIQEgBEGAQGshBSAEQYDAAWohBiAZQQhMBEAgJyAOIAQgBSAIIAEgACALKAKsAREIACAmIA4gKyAGIAggASAAIAsoAqwBEQgADAMLICcgDiAEIAUgCCABIAAgGSALKAK8ARENACAmIA4gKyAGIAggASAAIBkgCygCvAERDQAMAgsgBSADLAADIgFBAXRqIgcsAMcFIQ0gBSABQQJ0aiIPLgHoBCEMIAcsAMYFIRAg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IAE6AAAgAEHX2AVqQQs6AAAgAEHW2AVqIAE6AAAgAEHZ2AVqQQw6AAAgAEHY2AVqIAE6AAAgAEHb2AVqQQ06AAAgAEHa2AVqIAE6AAAgAEHd2AVqQQ46AAAgAEHc2AVqIAE6AAAgAEHf2AVqQQ86AAAgAEHe2AVqIAE6AAAgAkEQaiECIAFBAWoiAUEQRw0AC0EAIQMDQEEAIQIgA0EASAR/QQAFAkAgA0UEQEEAIQEgAyEADAELIANBAWpBfnEhBkEAIQEgAyEAQQAhBQNAAkAgAEEPSg0AIAFBD0sNACAEQQF0IgdB4a0FaiAAOgAAIAdB4K0FaiABOgAAIARBAWohBAsCQCAAQRBKDQAgAUEBciIHQQ9LDQAgBEEBdCIJQeGtBWogAEEBazoAACAJQeCtBWogBzoAACAEQQFqIQQLIAFBAmohASAAQQJrIQAgBUECaiIFIAZHDQALCwJAIANBAXENACAAQQ9KDQAgAUEPSw0AIARBAXQiBUHhrQVqIAA6AAAgBUHgrQVqIAE6AAAgBEEBaiEECyADQQFqCyEDIARBgAJIDQALQQAhBANAIARBAXQiAEGRxwVqIAI6AABBACEBIABBkMcFakEAOgAAIABBk8cFaiACOgAAIABBkscFakEBOgAAIABBlccFaiACOgAAIABBlMcFakECOgAAIABBl8cFaiACOgAAIABBlscFakEDOgAAIABBmccFaiACOgAAIABBmMcFakEEOgAAIABBm8cFaiACOgAAIABBmscFakEFOgAAIABBnccFaiACOgAAIABBnMcFakEGOgAAIABBn8cFaiACOgAAIABBnscFakEHOgAAIABBoccFaiACOgAAIABBoMcFakEIOgAAIABBo8cFaiACOgAAIABBoscFakEJOgAAIABBpccFaiACOgAAIABBpMcFakEKOgAAIABBp8cFaiACOgAAIABBpscFakELOgAAIABBqccFaiACOgAAIABBqMcFakEMOgAAIABBq8cFaiACOgAAIABBqscFakENOgAAIABBrccFaiACOgAAIABBrMcFakEOOgAAIABBr8cFaiACOgAAIABBrscFakEPOgAAIABBsccFaiACOgAAIABBsMcFakEQOgAAIABBs8cFaiACOgAAIABBsscFakEROgAAIABBtccFaiACOgAAIABBtMcFakESOgAAIABBt8cFaiACOgAAIABBtscFakETOgAAIABBuccFaiACOgAAIABBuMcFakEUOgAAIABBu8cFaiACOgAAIABBuscFakEVOgAAIABBvccFaiACOgAAIABBvMcFakEWOgAAIABBv8cFaiACOgAAIABBvscFakEXOgAAIABBwccFaiACOgAAIABBwMcFakEYOgAAIABBw8cFaiACOgAAIABBwscFakEZOgAAIABBxccFaiACOgAAIABBxMcFakEaOgAAIABBx8cFaiACOgAAIABBxscFakEbOgAAIABByccFaiACOgAAIABByMcFakEcOgAAIABBy8cFaiACOgAAIABByscFakEdOgAAIABBzccFaiACOgAAIABBzMcFakEeOgAAIABBz8cFaiACOgAAIABBzscFakEfOgAAIARBIGohBCACQQFqIgJBIEcNAAtBACECA0BBACEEIAJBAXQiAEHB3AVqQQA6AAAgAEHA3AVqIAE6AAAgAEHD3AVqQQE6AAAgAEHC3AVqIAE6AAAgAEHF3AVqQQI6AAAgAEHE3AVqIAE6AAAgAEHH3AVqQQM6AAAgAEHG3AVqIAE6AAAgAEHJ3AVqQQQ6AAAgAEHI3AVqIAE6AAAgAEHL3AVqQQU6AAAgAEHK3AVqIAE6AAAgAEHN3AVqQQY6AAAgAEHM3AVqIAE6AAAgAEHP3AVqQQc6AAAgAEHO3AVqIAE6AAAgAEHR3AVqQQg6AAAgAEHQ3AVqIAE6AAAgAEHT3AVqQQk6AAAgAEHS3AVqIAE6AAAgAEHV3AVqQQo6AAAgAEHU3AVqIAE6AAAgAEHX3AVqQQs6AAAgAEHW3AVqIAE6AAAgAEHZ3AVqQQw6AAAgAEHY3AVqIAE6AAAgAEHb3AVqQQ06AAAgAEHa3AVqIAE6AAAgAEHd3AVqQQ46AAAgAEHc3AVqIAE6AAAgAEHf3AVqQQ86AAAgAEHe3AVqIAE6AAAgAEHh3AVqQRA6AAAgAEHg3AVqIAE6AAAgAEHj3AVqQRE6AAAgAEHi3AVqIAE6AAAgAEHl3AVqQRI6AAAgAEHk3AVqIAE6AAAgAEHn3AVqQRM6AAAgAEHm3AVqIAE6AAAgAEHp3AVqQRQ6AAAgAEHo3AVqIAE6AAAgAEHr3AVqQRU6AAAgAEHq3AVqIAE6AAAgAEHt3AVqQRY6AAAgAEHs3AVqIAE6AAAgAEHv3AVqQRc6AAAgAEHu3AVqIAE6AAAgAEHx3AVqQRg6AAAgAEHw3AVqIAE6AAAgAEHz3AVqQRk6AAAgAEHy3AVqIAE6AAAgAEH13AVqQRo6AAAgAEH03AVqIAE6AAAgAEH33AVqQRs6AAAgAEH23AVqIAE6AAAgAEH53AVqQRw6AAAgAEH43AVqIAE6AAAgAEH73AVqQR06AAAgAEH63AVqIAE6AAAgAEH93AVqQR46AAAgAEH83AVqIAE6AAAgAEH/3AVqQR86AAAgAEH+3AVqIAE6AAAgAkEgaiECIAFBAWoiAUEgRw0AC0EAIQMDQCADQQBIBH9BAAUCQCADRQRAQQAhASADIQAMAQsgA0EBakF+cSEFQQAhASADIQBBACECA0ACQCAAQR9KDQAgAUEfSw0AIARBAXQiBkHhsQVqIAA6AAAgBkHgsQVqIAE6AAAgBEEBaiEECwJAIABBIEoNACABQQFyIgZBH0sNACAEQQF0IgdB4bEFaiAAQQFrOgAAIAdB4LEFaiAGOgAAIARBAWohBAsgAUECaiEBIABBAmshACACQQJqIgIgBUcNAAsLAkAgA0EBcQ0AIABBH0oNACABQR9LDQAgBEEBdCICQeGxBWogADoAACACQeCxBWogAToAACAEQQFqIQQLIANBAWoLIQMgBEGACEgNAAtBAiEFA0BBASAFQQJrIgF0IAF0QQFrIQRBASAFdCEGIAVBAnQiB0GQiwNqKAIAIQogAUECdCIJQbCKA2ooAgAhC0EAIQMDQCAKIAMgBXRBAXRqIQxBACECA0AgDCACQQF0aiEIQRAhACAEIQEDQCALIAEgAEVrIgFBAXRqIg0tAAFBAnQgAEEBa0EPIAAbIgBBAXQiDkHBrAVqLQAAaiEPIA5BwKwFai0AACANLQAAQQJ0aiACRw0AIAMgD0cNAAsgCCAAOgABIAggAToAACACQQFqIgIgBkcNAAsgA0EBaiIDIAZHDQALIAlB0IoDaigCACEKIAdBqIsDaigCACELQQAhAwNAIAsgAyAFdEEBdGohDEEAIQIDQCAMIAJBAXRqIQhBECEAIAQhAQNAIAogASAARWsiAUEBdGoiDS0AAUECdCAAQQFrQQ8gABsiAEEBdCIOQfHBBWotAABqIQ8gDkHwwQVqLQAAIA0tAABBAnRqIAJHDQAgAyAPRw0ACyAIIAA6AAEgCCABOgAAIAJBAWoiAiAGRw0ACyADQQFqIgMgBkcNAAsgCUHwigNqKAIAIQkgB0HAiwNqKAIAIQhBACEDA0AgCCADIAV0QQF0aiEKQQAhAgNAIAogAkEBdGohB0EQIQAgBCEBA0AgCSABIABFayIBQQF0aiILLQABQQJ0IABBAWtBDyAAGyIAQQF0IgxBodcFai0AAGohDSAMQaDXBWotAAAgCy0AAEECdGogAkcNACADIA1HDQALIAcgADoAASAHIAE6AAAgAkEBaiICIAZHDQALIANBAWoiAyAGRw0ACyAFQQFqIgVBBkcNAAsLqQEBA38CQCAALQAuBEBBASEEIAAoAjAiBUEATA0BIAEgACgCqEFHBEAgAEGowQBqIQQDQCADQQFqIgMgBUYNAyAEIANBAnRqKAIAIAFHDQALIAMgBUghBAtBACEDIAAoAjQiAUEASgR/IABB1MEAaiEFA0AgBSADQQJ0aigCACACRiIARQRAIANBAWoiAyABRw0BCwsgAAVBAAsgBHEPCyABIAJyRQ8LQQALsgMBBX8gACgCCCIBRQRADwsgACgCBCICQQZGBEACQCABKAIYIgIgASgCHEgEQCABKAIUIQMMAQsgAkEBaiIFEFUiA0UEQA8LIAEoAhQiBARAIAMgBCACEDIaIAQQKiABKAIYIQILIAEgBTYCHCABIAM2AhQLIAIgA2pBADoAACABIAEoAhhBAWo2AhggACgCBCECCyACQQdGBH8CQCABKAIYIgNBAmoiBCABKAIcTARAIAEoAhQhAgwBCyAEEFUiAkUEQA8LIAEoAhQiBQRAIAIgBSADEDIaIAUQKiABKAIYIQMLIAEgBDYCHCABIAI2AhQLIAIgA2pBADsAACABIAEoAhhBAmo2AhggACgCBAUgAgtBBU4EQCAAKAIgIgQgACgCHGoiAyAAKAIUIgUgACgCECICa0EIdEEBa0EAIAIgBUcbRgRAIABBDGoQ6AIgACgCICIEIAAoAhxqIQMgACgCECECCyACIANBCHZB/P//B3FqKAIAIANB/wdxQQJ0aiABNgIAIAAgBEEBajYCICABKAIYIQEgAEEANgIIIAAgASAAKAIkajYCJAsgAEEANgIEC4kCAQZ/AkAgAyAEckEASA0AIAAoAnwiBSgC5AMgA0wNACAFKALoAyAETA0AIAAoAoQBIgkoArBCIgcgAyAFKAKohAEiBnZBAnRqIAUoApyEASIKIAQgBnZsQQJ0aigCACAHIAEgBnVBAnRqIAIgBnUgCmxBAnRqKAIASg0AIAAoAowBIgYgACgCmAEiByACIAUoAuyDASIAdSICbEEYbGogASAAdSIBQRhsai8BACAGIAcgBCAAdiIEbEEYbGogAyAAdiIAQRhsai8BAEcNACAJKAKkQiIDIAFBAnRqIAUoAvyDASIBIAJsQQJ0aigCACADIABBAnRqIAEgBGxBAnRqKAIARiEICyAIC+URARB/IwBBMGsiCiQAIAQoAgAhCwJAAkAgBQRAIAsNAUH6IEHB9QBB8gFB2NkAEAEACyALRQ0BCyAEKAIEIgwEQCAMIAwoAgRBAWo2AgQLIAAgCzYCfCAAKAKAASELIAAgDDYCgAEgC0UNACALIAsoAgQiDEEBazYCBCAMDQAgCyALKAIAKAIIEQAAIAsQKwsgABDUA0EBIQtBsKwFQbCsBSgCACIMQQFqNgIAIAAgBjYCcCAAQf////8HNgJsIAAgDDYCACAAIAg2AqACIAAgAjYCJCAAIAE2AiAgACACNgIcIAAgATYCGCAAIAM2AhQgACAHNwOYAgJ/AkACQAJ/AkACfwJ/AkACQAJAAkAgAw4EBgECAwALQZ2QAUHB9QBBlgJB2NkAEAEAC0ECIQsgCkECNgIIIAAgAkEBakECbSIRNgIkIAAgAUEBakECbSINNgIgQQIhCEECDAMLIApBAzYCCEEBIQhBAiELIAAgAUEBakECbSINNgIgIAIMAQsgCkEENgIIQQEhCCABIQ0gAgshEUEBCyEDIAAgCDoAMyAAIAs6ADIgBCgCACIIRQRAIApBEDYCFCAKIAI2AhAgCiABNgIMQQEhD0EADAILIAgoAtSDASALRw0CIAMgCCgC2IMBRgRAIApBEDYCFCAKIAI2AhAgCiABNgIMDAQLQa6AAUHB9QBBvgJB2NkAEAEAC0EBIQ8gCkEBNgIIIABBgQI7ATIgAEIANwMgIAQoAgAhCCAKQRA2AhQgCiACNgIQIAogATYCDCAIBEBBASEDDAMLQQEhA0EACyEIQQAMAgtBzIABQcH1AEG9AkHY2QAQAQALIAgoAvwDIRIgCCgC+AMhECAIKAL0AyETQQAhDyAIKALwAwshDkEIIQwCQCABIA4gE2oiFCALbCIVTA0AIAIgECASaiIWIANsIhdMDQAgACARIBZrNgJYIAAgDSAUazYCVCAAIAIgF2siAjYCUCAAIAEgFWsiATYCTCAKIAI2AiwgCiABNgIoIAogAyASbDYCJCAKIAMgEGwiAzYCICAKIAsgE2w2AhwgCiALIA5sIg02AhhBCCEBQQghAiAPRQRAIAgoAsiDASECIAgoAsCDASEBCyAAIAI6ADEgACABOgAwIAAgAkH/AXFBCEsiAjoAEiAAIAI6ABEgACABQf8BcUEISzoAEEEAIQEgAAJ+AkAgBkUNACAGKAKgBCEBIAlFDQAgBikCmAQMAQtBmKAFKQMACyIHNwOwAgJAIAenIgJFDQAgBiAKQQhqIAAgASACEQoAIRggACAAKAIEIA1qIAAoAiggA2xqNgJAAn8gACgCFEUEQEEAIQtBAAwBCyAAKAIsIBBsIgIgACgCDCAOamohCyAAKAIIIA5qIAJqCyECIAAgCzYCSCAAIAI2AkQgGA0AQQchDAwBCwJAIAVFDQAgACgCyAEhASAIKAKwhAEhAwJ/IAgoAriEASIFIAgoArSEASIGbCICIAAoAswBRwRAIAEQKiAAIAIQVSIBNgLIASABRQRAIABBADYCzAFBAAwCCyAAIAI2AswBCyAAIAU2AtgBIAAgBjYC1AEgACADNgLQASABQQBHCyEDIAAoAtwBIQEgCCgCsIQBIQUCfyAIKAK4hAEiBiAIKAK0hAEiCWwiAiAAKALgAUcEQCABECogACACEFUiATYC3AEgAUUEQCAAQQA2AuABQQAMAgsgACACNgLgAQsgACAGNgLsASAAIAk2AugBIAAgBTYC5AEgAUEARwsgA3EhAyAAKAKgASEBIAgoAuiDASEFAn8gCCgCgIQBIgYgCCgC+IMBIglsIgIgACgCpAFHBEAgARAqIAAgAkEDbBBVIgE2AqABIAFFBEAgAEEANgKkAUEADAILIAAgAjYCpAELIAAgBjYCsAEgACAJNgKsASAAIAU2AqgBIAFBAEcLIANxIQMgACgCtAEhAQJ/IAgoAoCEASAIKALogwFBAmsiAnQiBSAIKAL4gwEgAnQiBmwiAiAAKAK4AUcEQCABECogACACQQxsEFUiATYCtAEgAUUEQCAAQQA2ArgBQQAMAgsgACACNgK4AQsgACAFNgLEASAAIAY2AsABIABBAjYCvAEgAUEARwsgA3EhAyAAKALwASEBIAgoAqiEASEFAn8gCCgCoIQBIgYgCCgCnIQBIglsIgIgACgC9AFHBEAgARAqIAAgAhBVIgE2AvABIAFFBEAgAEEANgL0AUEADAILIAAgAjYC9AELIAAgBjYCgAIgACAJNgL8ASAAIAU2AvgBIAFBAEcLIANxIQMgACgChAIhAQJ/IAgoAugDQQNqQQRtIgUgCCgC5ANBA2pBBG0iBmwiAiAAKAKIAkcEQCABECogACACEFUiATYChAIgAUUEQCAAQQA2AogCQQAMAgsgACACNgKIAgsgACAFNgKUAiAAIAY2ApACIABBAjYCjAIgAUEARwsgA3EhAwJAIAQoAgAiCCgC/IMBIgIgACgCmAFGBEAgACgCnAEgCCgChIQBRg0BCyAAKALAAiIBBEAgAUEEayICKAIAIgUEQCABIAVBzABsaiEIA0AgCEHMAGsiCCABRw0ACyAEKAIAIQgLIAIQKiAIKAL8gwEhAgsgACgCjAEhASAIKALsgwEhBQJ/IAgoAoSEASIGIAJsIgggACgCkAFHBEAgARAqIAAgCEEYbBBVIgE2AowBIAFFBEBBACEIIABBADYCkAFBAAwCCyAAIAg2ApABCyAAIAY2ApwBIAAgAjYCmAEgACAFNgKUASABQQBHCyEZQX9BfyAIrULMAH4iB6ciAUEEaiIFIAEgBUsbIAdCIIinGxAsIgEgCDYCACABQQRqIQEgCARAIAEgCEHMAGxqIQUgASEIA0AgCEEANgIAIAhBzABqIgggBUcNAAsLIAAgATYCwAJBByEMIBkgA3ENAQwCC0EHIQwgA0UNAQtBACEMCwJAIAQoAgQiAEUNACAAIAAoAgQiAUEBazYCBCABDQAgACAAKAIAKAIIEQAAIAAQKwsgCkEwaiQAIAwLtgEAIABBADoAvAIgAEEAOwG6AiAAQQA2AjwgAEIANwI0IABB9ABqQQBBpAEQNBogAEIANwJsIABBfzYCACAAQgA3AgQgAEEANgIMIABCADcDQCAAQQA2AkggAEEANgLAAiAAQgA3AxggAEIANwOYAiAAQgA3A6ACIABCADcDqAIgAEECOgC4AiAAQQA6AGggAEEANgJkIABCfzcCXCAAQQA2AtQCIABCADcCzAIgAEIANwLEAiAAC7kCAQh/AkACQCAAKAIEIgQgACgCACIHRwRAIAQhAgwBCyAAKAIIIgMgACgCDCICSQRAIAMgAiADa0ECdUEBakECbUECdCIFaiADIARrIgZrIQIgAyAERwRAIAIgBCAGEDcaIAAoAgghAwsgACACNgIEIAAgAyAFajYCCAwBC0EBIAIgBGtBAXUgAiAERhsiAkGAgICABE8NASACQQJ0IgUQLCIGIAVqIQggBiACQQNqQXxxaiICIQUgAyAERwRAIAIgAyAEa2ohCSAEIQMDQCAFIAMoAgA2AgAgA0EEaiEDIAVBBGoiBSAJRw0ACwsgACAINgIMIAAgBTYCCCAAIAI2AgQgACAGNgIAIARFDQAgBxAqIAAoAgQhAgsgAkEEayABKAIANgIAIAAgACgCBEEEazYCBA8LEE8AC04BAX8gACAAKAI0QQFrNgI0IAAgACgCMEEBaiIBNgIwIAFBgBBPBEAgACgCJCgCABAqIAAgACgCJEEEajYCJCAAIAAoAjBBgAhrNgIwCwvTBQEKfyMAQRBrIgwkACAAKAIMIgsgACgCCCIGa0ECdSEIAkAgBiALRwRAQQEgCCAIQQFNGyEKA0ACQCAGIAdBAnRqKAIAIgktAGgNACAJKAJkDQAgCRDUAyAAKAIMIgsgACgCCGtBAnUhCAwDCyAHQQFqIgcgCkcNAAsLQXchBwsCQCAIIAAoAgRNDQAgByAIQQFrRg0AIAtBBGsoAgAiBi0AaA0AIAYoAmQNACAGENMDECogACAAKAIMQQRrIgs2AgwLAkACQAJAIAdBd0YEQCAAKAIIIQ5BoAMQLBCABiEIAkAgACgCDCIHIAAoAhAiCkkEQCAHIAg2AgAgB0EEaiEIDAELIAcgACgCCCIJa0ECdSIPQQFqIgZBgICAgARPDQJB/////wMgCiAJayIKQQF1Ig0gBiAGIA1JGyAKQfz///8HTxsiCgR/IApBgICAgARPDQQgCkECdBAsBUEACyINIA9BAnRqIgYgCDYCACAGQQRqIQggByAJRwRAA0AgBkEEayIGIAdBBGsiBygCADYCACAHIAlHDQALIAAoAhAaIAAoAgghCQsgACANIApBAnRqNgIQIAAgCDYCDCAAIAY2AgggCUUNACAJECoLIAAgCDYCDCALIA5rQQJ1IQcLAkAgB0EASARAIAEoAgQhBgwBCyABKAIAIgYoAtwDIghBBE8NAyAAKAIIIAdBAnRqKAIAIQAgBigC6AMhCSAGKALkAyELIAwgBjYCCCAMIAEoAgQiBjYCDCAGBEAgBiAGKAIEQQFqNgIECyAMIAwpAgg3AwAgACALIAkgCCAMQQEgAiADIAQgBRD/BSIBBEBBACABayEHDAELIABBADoAuAILAkAgBkUNACAGIAYoAgQiAEEBazYCBCAADQAgBiAGKAIAKAIIEQAAIAYQKwsgDEEQaiQAIAcPCxA2AAsQTwALQZ2QAUHm9QBBhwJBs9kAEAEACyUAIAAoAhQgACgCGEcEQANAIAAQhQYgACgCFCAAKAIYRw0ACwsLmQMBCn8CQAJAIAAoAhQiBSAAKAIYIgFHBEAgASAFayIEQQJ1IgJBAkkNAkEBIQEgAkEBayIDQQFxIQYgBSgCACgCYCECIARBCEYEQEEAIQMMAgsgA0F+cSEJQQAhA0EAIQQDQCAFIAFBAWoiCkECdGooAgAoAmAiByAFIAFBAnRqKAIAKAJgIgggAiACIAhKIggbIgIgAiAHSiIHGyECIAogASADIAgbIAcbIQMgAUECaiEBIARBAmoiBCAJRw0ACwwBC0HeoAFB5vUAQZMBQeEvEAEACyAGRQ0AIAEgAyAFIAFBAnRqKAIAKAJgIAJIGyEDCyAAKAI0IgQgACgCMGoiAiAAKAIoIgYgACgCJCIBa0EIdEEBa0EAIAEgBkcbRgRAIABBIGoQ6AIgACgCNCIEIAAoAjBqIQIgACgCJCEBCyABIAJBCHZB/P//B3FqKAIAIAJB/wdxQQJ0aiAFIANBAnQiAWooAgA2AgAgACAEQQFqNgI0IAAoAhQgAWogACgCGEEEaygCADYCACAAIAAoAhhBBGs2AhgLVgECfyAAKAIMIgIgACgCCCIDRwRAQQEgAiADa0ECdSIAIABBAU0bIQJBACEAA0AgASADIABBAnRqKAIAKAIARgRAIAAPCyAAQQFqIgAgAkcNAAsLQX8LwwEBBX8gACgCDCIDIAAoAggiBGtBAnUhAAJAIAMgBEcEQEEBIAAgAEEBTRshBwNAAkAgBCAFQQJ0aigCACIGKAJcIAFHDQAgBigCbCACTA0AIAYoAmRBAkYNAwsgBUEBaiIFIAdHDQALC0F/IQUgAyAERg0AQQEgACAAQQFNGyEGQQAhAANAAkAgBCAAQQJ0aigCACIDKAJcIAFHDQAgAygCbCACTA0AIAMoAmRFDQAgAA8LIABBAWoiACAGRw0ACwsgBQt9AQN/QQEhAgJAIAENACAAKAIMIgMgACgCCCIEa0ECdSIBIAAoAgBJDQAgAyAERgRAQQAPC0EBIAEgAUEBTRshAkEAIQADQAJAIAQgAEECdGooAgAiAy0AaA0AIAMoAmQNAEEBDwsgAEEBaiIAIAJHDQALIAAgAUkhAgsgAgveDgEWfyMAQYARayIOJAACQCABQQBMDQAgAUEBdiEMAkAgAUEITwRAIAFBAnYhCSABQQJxIRUgDEH+////A3EhFiAOQUBrIQYgDiEEA0ACQCABQQFGDQAgAiADIBNsQQF0aiEKQQAhBUEAIQcgDEEBRwRAA0AgBiAFQQF0IghqIAogBSAMakEBdCILaiINLwEAIAggCmoiCC8BAGo7AQAgBiALaiAILwEAIA0vAQBrOwEAIAYgBUEBciIIQQF0IgtqIAogCCAMakEBdCIIaiINLwEAIAogC2oiCy8BAGo7AQAgBiAIaiALLwEAIA0vAQBrOwEAIAVBAmohBSAHQQJqIgcgFkcNAAsLIBVFDQAgBiAFQQF0IgdqIAogBSAMakEBdCIFaiIILwEAIAcgCmoiBy8BAGo7AQAgBSAGaiAHLwEAIAgvAQBrOwEACyAJIQcgDCEKA0ACQCAGIQUgBCEGIAdFDQAgB0H+////AXEhESAHQQFxIQ9BACEIA0BBACEEQQAhCyAHQQFHBEADQCAGIAQgCGoiDUEBdCIQaiAFIAcgDWpBAXQiFGovAQAiEiAFIBBqLwEAIhBqOwEAIAYgFGogECASazsBACAGIA1BAWoiDUEBdCIQaiAFIAcgDWpBAXQiDWovAQAiFCAFIBBqLwEAIhBqOwEAIAYgDWogECAUazsBACAEQQJqIQQgC0ECaiILIBFHDQALCyAPBEAgBiAEIAhqIgRBAXQiC2ogBSAEIAdqQQF0IgRqLwEAIg0gBSALai8BACILajsBACAEIAZqIAsgDWs7AQALIAggCmoiCCABSA0ACyAKQQF2IQogB0EDSyEYIAdBAXYhByAFIQQgGA0BCwsgASATbCEHQQAhBANAIA5BgAFqIhIgBCAHakEBdGogBiAEQQFyIgpBAXRqIggvAQAgBiAEQQF0aiILLwEAajsBACAHIApqQQF0IBJqIAsvAQAgCC8BAGs7AQAgBEECaiIEIAFIDQALIAUhBCATQQFqIhMgAUcNAAsMAQsgAUEBayIEQQJxIQogBEEBdkEBakF+cSEJIAxBAXQiCCAOQUBrIgRqIQsgBCAMQQJqQQF0IhNqIQ0gBCAMQQFqQQF0IhVqIRYgAUEDSSERA0ACQCABQQFGDQAgDiACIAMgB2xBAXRqIgQgCGovAQAiBSAELwEAIgZqOwFAIAsgBiAFazsBACABQQRJDQAgDiAEIBVqLwEAIgUgBC8BAiIGajsBQiAWIAYgBWs7AQAgDEECRg0AIA4gBCATai8BACIFIAQvAQQiBGo7AUQgDSAEIAVrOwEACyABIAdsIQVBACEGQQAhBCARRQRAA0AgDkGAAWoiFyAFIAZqQQF0aiAOQUBrIhIgBkEBciIPQQF0ai8BACIQIAZBAXQgEmovAQAiFGo7AQAgBSAPakEBdCAXaiAUIBBrOwEAIAZBAnIiDyAFakEBdCAXaiAGQQNyIhBBAXQgEmovAQAiFCAPQQF0IBJqLwEAIg9qOwEAIAUgEGpBAXQgF2ogDyAUazsBACAGQQRqIQYgBEECaiIEIAlHDQALCyAKRQRAIA5BgAFqIhcgBSAGakEBdGogDkFAayISIAZBAXIiBEEBdGovAQAiDyAGQQF0IBJqLwEAIgZqOwEAIAQgBWpBAXQgF2ogBiAPazsBAAsgB0EBaiIHIAFHDQALIA4iBUFAayEGCyABQQBMDQBBASABQQF2IgIgAkEBTRshEyABQQJ2IQNBACEMIAFBCEkhDQNAQQAhBAJAIAFBAUYEQCAFIQQMAQsDQCAGIARBAXRqIA5BgAFqIgkgAiAEaiIHIAFsIAxqQQF0ai8BACIKIAEgBGwgDGpBAXQgCWoiCS8BAGo7AQAgBiAHQQF0aiAJLwEAIAprOwEAIARBAWoiBCATRw0ACyADIQcgAiEKIAUhBCANDQADQCAGIQQgBSEGIAdFDQEgB0H+////AXEhFSAHQQFxIRZBACEIA0BBACEFQQAhCyAHQQFHBEADQCAGIAUgCGoiCUEBdCIRaiAEIAcgCWpBAXQiD2ovAQAiECAEIBFqLwEAIhFqOwEAIAYgD2ogESAQazsBACAGIAlBAWoiCUEBdCIRaiAEIAcgCWpBAXQiCWovAQAiDyAEIBFqLwEAIhFqOwEAIAYgCWogESAPazsBACAFQQJqIQUgC0ECaiILIBVHDQALCyAWBEAgBiAFIAhqIgVBAXQiCWogBCAFIAdqQQF0IgVqLwEAIgsgBCAJai8BACIJajsBACAFIAZqIAkgC2s7AQALIAggCmoiCCABSA0ACyAKQQF2IQogB0EDSyEZIAdBAXYhByAEIQUgGQ0ACwsgACAMQQF0aiEHQQAhBQNAIAcgASAFbEEBdGogBiAFQQFyIgpBAXRqIgkvAQAgBiAFQQF0aiIILwEAajsBACAHIAEgCmxBAXRqIAgvAQAgCS8BAGs7AQAgBUECaiIFIAFIDQALIAQhBSAMQQFqIgwgAUcNAAsLIA5BgBFqJAAL/8ICAix/An4jAEEQayIbJAACQAJAAkACQCAAKALEBCIEBEAgAEGlBGohAgwBCwJAIAAtAKQEIg1BAXFFBEAgAC0ApQRBAUcNAQsgACgCiBkgACgCjBlHDQAgAEHcEGoQhAYgAUUNAiABIAAoApARNgIADAILIABBpQRqIQIgDUEBcQ0AIAQNACAALQClBEEBcQ0AQQ0hAiABRQ0BIAFBATYCAAwBCyAAQdwQakEAEIgGRQRAQQkhAiABRQ0BIAFBATYCAAwBCyAbQQA6AA8gAQJ/An8gACgCxAQiBARAIAQEfyAAKAK0BCIFIAAoAsAEIgJBCHZB/P//B3FqKAIAIAJB/wdxQQJ0aigCACENIAAgBEEBazYCxAQgACACQQFqIgI2AsAEIAJBgBBPBEAgBSgCABAqIAAgACgCtARBBGo2ArQEIAAgACgCwARBgAhrNgLABAsgACAAKALIBCANKAIYazYCyAQgDQVBAAsiDUUNBCMAQSBrIhkkACANKAIUIQQgDSgCGCEFIBlBCGoiAkEANgIQIAJCADcDCCACIAU2AgQgAiAENgIAQUAhBwJAIAVFDQAgAiAEQQFqNgIAIAQxAAAhLiACIAVBAWsiAzYCBCACIC5COIYiLjcDCCADRQ0AIAIgBEECajYCACAEMQABIS8gAiAFQQJrIgM2AgQgAiAuIC9CMIaEIi43AwggA0UNACACIARBA2o2AgAgBDEAAiEvIAIgBUEDayIDNgIEIAIgLiAvQiiGhCIuNwMIIANFDQAgAiAEQQRqNgIAIAQxAAMhLyACIAVBBGsiAzYCBCACIC4gL0IghoQiLjcDCCADRQ0AIAIgBEEFajYCACAEMQAEIS8gAiAFQQVrIgM2AgQgAiAuIC9CGIaEIi43AwggA0UNACACIARBBmo2AgAgBDEABSEvIAIgBUEGayIDNgIEIAIgLiAvQhCGhCIuNwMIIANFDQAgAiAEQQdqNgIAIAQxAAYhLyACIAVBB2siAzYCBCACIC4gL0IIhoQiLjcDCCADRQ0AIAIgBEEIajYCACAEMQAHIS8gAiAFQQhrNgIEIAIgLiAvhDcDCEFIIQcLIAIgB0EHIAUgBUEHTxtBA3RqQUBrNgIQIBlBADoAByAZQQA7AAUgAkEBEOABIBkgAkEGEDE6AAUgGSACQQYQMToABiAZIAJBAxAxQQFrOgAHIAAgGS0ABSIEOgCEGSAAIARB+AFxQRBGOgCGGSAAIARBE2tB/wFxQQJJOgCFGQJAIBktAAYEQCAAQaQEaiANEJABDAELIAAoAvAOIBktAAdIBEAgAEGkBGogDRCQAQwBCyAEQR9NBEACfyAAIQQgGUEIaiEAIA0hBSMAQRBrIhAkAEHUChAsIgNBADYCmAYgA0IANwKQBiADQgA3AgQgA0G8CmoiFkIANwIAIANBADYC0AogA0IANwLICiADKAIIIQIgA0IANwIEAkAgAkUNACACIAIoAgQiBkEBazYCBCAGDQAgAiACKAIAKAIIEQAAIAIQKwsgA0EAOgAoIANBADYCJCADQQA6ABQgA0EANgIQIANBADsBDCADQQA2AgAgA0IANwIYIANBADsBICADQSpqEOQCIANCADcCiAYgA0GQAWpBAEHtARA0GiADQYADakEAQeYCEDQaIANBADYA9wUgA0IANwLwBSADQgA3AugFIANCADcC/AUgA0EAOgCEBiADQgA3ApwGIANCADcCpAYgA0IANwKsBiADIAMoApAGNgKUBiADQbQGahDkAiADQZgHakEAQaQDEDQaIANBADoAxAogAyADKALICjYCzAogEAJ/IAAhDSAQQQA6AA8gAygCCCEAIANCADcCBAJAIABFDQAgACAAKAIEIgJBAWs2AgQgAg0AIAAgACgCACgCCBEAACAAECsLIANBADoAKCADQQA2AiQgA0EAOgAUIANBADYCECADQQA7AQwgA0EANgIAIANCADcCGCADQQA7ASAgA0EqaiIHEOQCIANCADcCiAYgA0GQAWpBAEHtARA0IQogA0GAA2pBAEHmAhA0IQwgA0EANgD3BSADQgA3AvAFIANCADcC6AUgA0IANwL8BSADQQA6AIQGIANCADcCnAYgA0IANwKkBiADQgA3AqwGIAMgAygCkAY2ApQGIANBtAZqIgsQ5AIgA0GYB2pBAEGkAxA0GiADQQA6AMQKIANBADoAFCADIAMoAsgKNgLMCiADIA1BARAxOgAMIAQtAIYZBEAgAyANQQEQMToADQsgAyANEEQiADYCEAJAAkACQAJAIABB4fJ5RyAAQT9McUUNACAEIABBA3RqIgAoAtgGIgZFDQAgACgC3AYiAgRAIAIgAigCBEEBajYCBAsgAyAGNgIEIAMoAgghACADIAI2AggCQCAARQ0AIAAgACgCBCICQQFrNgIEIAINACAAIAAoAgAoAggRAAAgABArCyADKAIEIgIoAgQiBi0AAEUEQCAEQQRqQfIHQQAQUQwCCwJAAkACQAJAAkAgAy0ADEUEQEEAIQAgAyACLQAOBH8gDUEBEDEFQQALOgAUIAYoAoyEASEJA0AgACICQQFqIQBBASACdCAJSA0ACyANIAIQMSEJIAMtABQiDgRAIAlFBEAgEEEAOgAPIARBBGpB/QdBABBRQQAMDAtBECAEKAKsESIARQ0LGiADIAAoAgA2AgAgACgCBCECIAAoAggiCARAIAggCCgCBEEBajYCBAsgAyACNgIEIAMoAgghAiADIAg2AggCQCACRQ0AIAIgAigCBCIIQQFrNgIEIAgNACACIAIoAgAoAggRAAAgAhArCyADQQxqIABBDGpBhAYQMhoCQCAAIANHBEAgA0GQBmogACgCkAYiAiAAKAKUBiIIIAggAmtBAnUQ1wEgA0GcBmogAEGcBmpBoAQQMhogA0G8CmogAEG8CmoQ+AEgAyAALQDECjoAxAogA0HICmogACgCyAoiAiAAKALMCiIAIAAgAmtBAnUQ1wEMAQsgA0GcBmogAEGcBmpBoAQQMhogA0G8CmogAEG8CmoQ+AEgAyAALQDECjoAxAoLIANBAToAFCADQQA6AAwLIAMgCTYCGCAJQQBIDQUgCSAGKAKMhAFIDQEMBQsgA0EANgIYIANBADoAFCAGKAKMhAFBAEwNBCADKAIEIQIMAQsgAygCBCECIA4NAQtBACEAIAIsALBAQQBKBEADQCANQQEQ4AEgAEEBaiIAIAMoAgQsALBASA0ACwsgAyANEEQiADYCHCAAQeHyeUcgAEECTHFFBEAgBEEEakHvB0EAEFEMBQsgAyADKAIELQArBH8gDUEBEDEFQQELOgAgIAYtAOADQQFGBEAgAyANQQIQMToAIQtBACEIIANBADoAKCADQQA2AiQCQAJAAkACQAJAIAQtAIQZQRNrQf8BcUECTwRAIAMgDSAGKAKIBBAxNgIkIAMgDUEBEDEiADoAKAJAIABB/wFxRQRAIARBBGogBiANIAcgBigC9EQgBigC8ERrQeQAbSAGQfDEAGpBARD5BRogAyAGKAL0RCAGKALwRGtB5ABtNgKwBgwBCyAGKAL0RCAGKALwRCIHa0HkAG0hCEEAIQIDQCACIgBBAWohAkEBIAB0IAhIDQALAkAgAEUEQEEAIQAMAQsgDSAAEDEhACAGKAL0RCAGKALwRCIHa0HkAG0hCAsgCiAANgIAIAAgCE4NAyADIAA2ArAGIAcgAEHkAGxqIQcLIAsgB0HkABAyGgJAAkAgBi0A/EQEQAJAIAYoAoBFQQBKBEAgAyANEEQiADYClAFBCCEKIABB4fJ5Rw0BDAwLIANBADYClAELIAMgDRBEIgI2ApgBQQghCiACQeHyeUYNCiAGLAACQQJ0IAZqKAKMBCADLQCVByACIAMoApQBIgBqIgIgAy0AlAdqakgNBiACQQBMDQEgBEGwEmohCSADQYwCaiELIANB/AFqIREgBkGExgBqIQ8gBkGExQBqIRMgA0GcAWohFCAEQfARaiEVIARBsBFqIQ4gA0HsAWohFyADQawBaiESQQAhCEEAIQcDQAJAIAAgB0oEQCAGKAKARSEYQQAhAANAIAAiAkEBaiEAQQEgAnQgGEgNAAsgByAUaiIAIA0gAhAxIgI6AAAgAkH/AXEiAiAGKAKARUgEQCAOIAdBAnRqIBMgAkECdGooAgA2AgAgDyAALQAAaiEADAILIARBBGpB/wdBABBRDBALIBIgB0ECdCICaiIYIA0gBigCiAQQMTYCACAHIBdqIgAgDUEBEDE6AAAgAiAOaiAYKAIANgIACyAVIAdBAnQiAmogACwAACIYNgIAIAcgEWogDUEBEDEiADoAAAJAIABB/wFxBEAgAiALaiANEEQiADYCACAAQeHyeUcNAQwNC0EAIQAgAiALakEANgIACyAYQQBHIRgCQCAHRQ0AIAcgAygClAFGDQAgAiAJakEEaygCACAAaiEACyAIIBhqIQggAiAJaiAANgIAIAdBAWoiByADKAKUASIAIAMoApgBakgNAAsMAgsgA0IANwKUAQtBACEICyAGLQCkRgRAIAMgDUEBEDE6AMwCDAILIANBADoAzAIMAQsgA0IANwKUAQsCfyAGLQDfRARAIAMgDUEBEDE6AM0CQQAgBigC0IMBRQ0BGiANQQEQMQwBCyADQQA6AM0CQQALIQAgA0IANwLQAiADIAA6AM4CIAMoAhxBAUsNAyADIA1BARAxIgA6AM8CAkAgAEH/AXEEQCADIA0QRCIANgLQAiAAQeHyeUYNCyADIABBAWoiADYC0AIgAygCHARAIAMoAtQCIQIMAgsgAyANEEQiADYC1AIgAEHh8nlGDQsgAyAAQQFqIgI2AtQCIAMoAtACIQAMAQsgAyADKAIEIgIsABEiADYC0AIgAyACLAASIgI2AtQCC0EIIQogAEEQSg0FIAJBEEoNBSADIAggAy0AlwdqIgc2ApgHAkACQAJAIAMoAgQtAKlARQ0AIAdBAkgNAEEAIQIDQCACIgBBAWohAkEBIAB0IAdIDQALIAMgDUEBEDEiAjoA2AICQCACQf8BcUUNACADKALQAkEATA0AIANB2gJqIQdBACECA0AgAiAHaiANIAAQMToAACACQQFqIgIgAygC0AJIDQALCyADKAIcRQRAIAMgDUEBEDEiAjoA2QIgAkH/AXFFDQIgAygC1AJBAEwNAiADQeoCaiEHQQAhAgNAIAIgB2ogDSAAEDE6AAAgAkEBaiICIAMoAtQCSA0ACwwCCyADQQA6ANkCDAILIANBADsB2AILIAMoAhwNACADIA1BARAxOgD6AgsgAyADKAIELQAQBH8gDUEBEDEFQQALOgD7AiADLQDMAkUNAkEBIQAgAygCHEUEQCANQQEQMSEACyADIAA6APwCAkACQAJAIABB/wFxIgIEQCADKALQAkEBSg0BCyACDQEgAygC1AJBAkgNAQsgDCANEEQiAjYCACACQeHyeUcEQCADLQD8AiEADAILDAsLQQAhAiAMQQA2AgALAkAgAEH/AXEEQCACIAMoAtACTg0BDAQLIAIgAygC1AJIDQMLDAoLIARBBGpB9wdBABBRQQgMCgsgBEEEakH6B0EAEFEMBgsCQCADKAIEIgAtAClBACADKAIcIgJBAUYbRQRAIAAtACpFDQEgAg0BCwJ/AkAgBCADKAIQQQN0aigC2AYiAARAIAQgACwADUEDdGooAtgFIgJFDQEgAyANEEQiADoAhANBACEHAkAgAEEHSw0AIAIoAtwDBEAgDRBuIAMtAIQDaiIAQQdLDQEgAyAAOgCFAwsgA0GmBWohCSADQaYEaiEMIANBhgRqIRMgA0HGA2ohCyADQaYDaiEOIANBhgNqIRFBACEAAkAgAygC0AIiCkEATA0AA0AgACARaiANQQEQMToAACAAQQFqIgAgCkcNAAsCQCACKALcA0UNACAKQQBMDQBBACEAA0AgACAOaiANQQEQMToAACAAQQFqIgAgCkcNAAsLIApBAEwNAEEAIQADQAJAIAAgEWotAAAEQEEAIA0QbiIHQYABa0GAfkkNBxogCyAAQQF0akEBIAMtAIQDdCAHajsBAEEAIQcgDRBuIghBACACKALkhAEiD2tIDQQgCCAPSA0BDAQLIAsgAEEBdGpBASADLQCEA3Q7AQBBACEICyAAIBNqIAg6AAAgCSAAQQF0agJ/AkAgACAOai0AAARAIA0QbiIHQYABa0GAfk8NAUEADAgLIAwgAEECdGoiB0EBIAMtAIUDdCIIOwEAIAkgAEEBdGpBADoAACAHIAg7AQJBAAwBCyAMIABBAnRqIg9BASADLQCFA3QgB2o7AQBBACEHIA0QbiIUQQAgAigC6IQBIghBAnQiFWtIDQMgFCAVTg0DIAkgAEEBdGpBACAIayIVIAggFGogCCAPLgEAbCADLQCFA3VrIhQgCEEBayAIIBRKGyAUIBVIGzoAACANEG4iCEGAAWtBgH5JDQMgD0EBIAMtAIUDdCAIajsBAiANEG4iFEEAIAIoAuiEASIIQQJ0IhVrSA0DIBQgFU4NA0EAIAhrIhUgCCAUaiAIIA8uAQJsIAMtAIUDdWsiByAIQf8BaiAHIAhIGyAHIBVIGws6AAEgAEEBaiIAIApHDQALC0EBIQcgAygCHA0AIAMoAtQCIgpBAEwNAEEAIQADQCAAIBFqIA1BARAxOgAQIABBAWoiACAKRw0ACwJAIAIoAtwDRQ0AIApBAEwNAEEAIQADQCAAIA5qIA1BARAxOgAQIABBAWoiACAKRw0ACwsgCkEATA0AQQAhAANAAkAgACARai0AEARAQQAgDRBuIgdBgAFrQYB+SQ0GGiALIABBAXRqQQEgAy0AhAN0IAdqOwEgQQAhByANEG4iCEEAIAIoAuSEASIPa0gNAyAIIA9IDQEMAwsgCyAAQQF0akEBIAMtAIQDdDsBIEEAIQgLIAAgE2ogCDoAEAJ/IAAgDmotABAEQEEAIA0QbiIHQYABa0GAfkkNBhogDCAAQQJ0aiIPQUBrIhVBASADLQCFA3QgB2o7AQBBACEHIA0QbiIUQQAgAigC6IQBIghBAnQiF2tIDQMgFCAXTg0DIAkgAEEBdGpBACAIayIXIAggFGogCCAVLgEAbCADLQCFA3VrIhQgCEEBayAIIBRKGyAUIBdIGzoAICANEG4iCEGAAWtBgH5JDQMgD0EBIAMtAIUDdCAIajsBQiANEG4iFEEAIAIoAuiEASIIQQJ0IhVrSA0DIBQgFU4NA0EAIAhrIhUgCCAUaiAIIA8uAUJsIAMtAIUDdWsiByAIQf8BaiAHIAhIGyAHIBVIGwwBCyAMIABBAnRqIgdBQGtBASADLQCFA3QiCDsBACAJIABBAXRqQQA6ACAgByAIOwFCQQALIQhBASEHIAkgAEEBdGogCDoAISAAQQFqIgAgCkcNAAsLIAcMAgtB/iBByvUAQZgBQdPWABABAAtB+iBByvUAQZoBQdPWABABAAsNAAwICyADIA0QRCIANgLoBSAAQeHyeUYNBiADQQUgAGs2AqwGCyADIA0QbiIANgLsBSAAQeHyeUYNBQJAIAMoAgQiAC0AKARAIAMgDRBuIgA2AvAFIABB4fJ5Rg0HIAMgDRBuIgA2AvQFIABB4fJ5RwRAIAMoAgQhAAwCCwwHCyADQgA3AvAFCyAALQC4QEEBRgRAIAMgDUEBEDE6APgFIAMoAgQhAAsCQAJAIAAtADxFBEAgA0EAOgD5BSADIAAoAkA2AvwFIAMgACgCRDYCgAYMAQsgAyANQQEQMSICOgD5BSADIAMoAgQiACgCQDYC/AUgAyAAKAJENgKABiACQf8BcUUNACADIA1BARAxIgA6APoFIABB/wFxDQEgAyANEG4iADYC/AUgAEHh8nlGDQcgAyAAQQF0NgL8BSADIA0QbiIANgKABiAAQeHyeUYNByADIABBAXQ2AoAGDAELIAMgAC0APToA+gULAkAgAygCBCICLQA6IgBFDQACQCADLQDNAg0AIAMtAM4CDQAgAy0A+gUNAQsgAyANQQEQMToAhAYgAygCBCECDAELIAMgADoAhAYLAkACQCACLQAuRQRAIAItAC1FDQELIAMgDRBEIgA2AogGIABB4fJ5Rg0GAkAgAygCBCICLQAtRQ0AIAYoAoSEASADKAIYIAYoAvyDAW0gAGpKDQAMBwsCQCACLQAuRQ0AIAAgAigCNCACKAIwbEwNAAwHCwJAIANBkAZqIgIoAgQgAigCACIHa0ECdSIGIABJBEAgAiAAIAZrEKoBDAELIAAgBkkEQCACIAcgAEECdGo2AgQLCyADKAKIBkEATA0BIAMgDRBEIgA2AowGIABB4fJ5Rg0GIAMgAEEBaiICNgKMBkEIIQogAEEfSg0CIAMoAogGQQBMDQFBASEAIA0gAhAxIQIgAygCkAYgAkEBajYCACADKAKIBkECSA0BA0AgDSADKAKMBhAxIQIgAygCkAYgAEECdGoiBiACIAZBBGsoAgBqQQFqNgIAIABBAWoiACADKAKIBkgNAAsMAQsgA0EANgKIBgsCQCADKAIELQCxQEUNACADIA0QRCICNgKcBiACQeHyeUYNBSACQegHSg0FQQAhACACQQBMDQADQCANQQgQMRogAEEBaiIAIAMoApwGSA0ACwsgAyADKALsBSADKAIEKAIUajYCoAZBACEAAkACQAJAAkAgAygCHA4DAQACAwsgAywA+wJBAWohAAwBC0ECIAMsAPsCayEACyADIAA2AqQGCyADQQUgAygC6AVrNgKsBiAQQQE6AA9BACEKCyAKDAULIARBBGpB/AdBABBRQQgMBAsgBEEEakHxB0EAEFFBAAwDCyAQQQA6AA9BAAwCCyAEQQRqQe8HQQAQUUEIDAELIARBBGpBCEEAEFFBCAs2AggCQAJ/IBAtAA9FBEAgBCgCqBEiAARAIABBAjoAuAILIARBpARqIAUQkAEgAygCyAoiAARAIAMgADYCzAogAygC0AoaIAAQKgsgFhDEARogAygCkAYiAARAIAMgADYClAYgAygCmAYaIAAQKgsCQCADKAIIIgBFDQAgACAAKAIEIgJBAWs2AgQgAg0AIAAgACgCACgCCBEAACAAECsLIAMQKiAQKAIIDAELIAQoApAEIgZBAE4EQAJAIwBB4AZrIgAkAEGUrwMhAgJAAkACQAJAAkAgBkEBaw4CAQACC0GQrwMhAgsgAigCACICQfSNAkEAEDAgBCADKAIQQQN0aigC2AYiBkUEQCACQevJAUEAEDAMAQsgBi0AAEUNASAEIAYsAA1BA3RqKALYBSIJRQRAIAJB08kBQQAQMAwBCyAJLQAARQ0CIAAgAywADDYC0AYgAkHJ8gEgAEHQBmoQMCAELQCEGUH4AXFBEEYEQCAAIAMsAA02AsAGIAJBx/cBIABBwAZqEDALIAAgAygCEDYCsAYgAkGZ/QEgAEGwBmoQMCADLQAMRQRAIAAgAywAFDYCoAYgAkGc9wEgAEGgBmoQMCAAIAMoAhg2ApAGIAJBoYMCIABBkAZqEDALIABB0ABByQAgAygCHCIHQQFGG0HCACAHGzYCgAYgAkHliAIgAEGABmoQMCAGLQArBEAgACADLAAgNgLwBSACQeGGAiAAQfAFahAwCyAJLQDgA0EBRgRAIAAgAywAITYC4AUgAkGMhwIgAEHgBWoQMAsgACADKAIkNgLQBSACQZWBAiAAQdAFahAwAkAgBC0AhBlBE2tB/wFxQQJJDQAgACADLAAoNgLABSACQbDwASAAQcAFahAwIAkoAvREIAkoAvBEayEHAkACfyADLQAoRQRAIAAgB0HkAG02AqAFIAJB08IBIABBoAVqEDAgA0EqagwBCyAHQeUASA0BIAAgAygCkAE2ArAFIAJBjPsBIABBsAVqEDAgCSgC8EQgAygCkAFB5ABsagsgAhD4BQsgCS0A/EQEQCAJKAKARUEASgRAIAAgAygClAE2ApAFIAJBkogCIABBkAVqEDALIAAgAygCmAE2AoAFIAJBt4cCIABBgAVqEDALIAktAKRGRQ0AIAAgAywAzAI2AvAEIAJBwd0BIABB8ARqEDALIAktAN9EBEAgACADLADNAjYC4AQgAkGmgAIgAEHgBGoQMCAAIAMsAM4CNgLQBCACQfP8ASAAQdAEahAwCyADKAIcQQFNBEAgACADLADPAjYCwAQgAkGc2wEgAEHABGoQMCADLQDPAiEHIAAgAygC0AI2ArAEIABB0JACQYGfASAHGzYCtAQgAkGjxgEgAEGwBGoQMCADKAIcRQRAIAMtAM8CIQcgACADKALUAjYCoAQgAEHQkAJBgZ8BIAcbNgKkBCACQfvFASAAQaAEahAwCwJAIAYtAKlARQ0AIAMoApgHQQJIDQAgACADLADYAjYCkAQgAkGy4gEgAEGQBGoQMAJAIAMtANgCRQ0AIAMoAtACQQBMDQAgA0HaAmohCEEAIQcDQCAAIAcgCGotAAA2AoQEIAAgBzYCgAQgAkGj0wEgAEGABGoQMCAHQQFqIgcgAygC0AJIDQALCyAAIAMsANkCNgLwAyACQYriASAAQfADahAwIAMtANkCRQ0AIAMoAtQCQQBMDQAgA0HqAmohCEEAIQcDQCAAIAcgCGotAAA2AuQDIAAgBzYC4AMgAkGj0wEgAEHgA2oQMCAHQQFqIgcgAygC1AJIDQALCyADKAIcRQRAIAAgAywA+gI2AtADIAJB3oICIABB0ANqEDALIAAgAywA+wI2AsADIAJB7YMCIABBwANqEDAgAy0AzAIEQCAAIAMsAPwCNgKwAyACQej1ASAAQbADahAwIAAgAygCgAM2AqADIAJB3/4BIABBoANqEDALAkAgBi0AKUEAIAMoAhwiB0EBRhtFBEAgBi0AKkUNASAHDQELIAAgAy0AhAM2ApADIAJB9/YBIABBkANqEDAgCSgC3AMEQCAAIAMtAIUDNgKAAyACQb/5ASAAQYADahAwCyADQaYFaiEJIANBpgRqIQggA0GGBGohCiADQcYDaiEMIAMoAtACIgtBAEoEQEEAIQcDQCAAIAwgB0EBdCIOai4BADYC+AIgACAHNgL0AiAAQQA2AvACIAJBzIACIABB8AJqEDAgACAHIApqLAAANgLoAiAAIAc2AuQCIABBADYC4AIgAkG6/gEgAEHgAmoQMCAAIAggB0ECdGoiES4BADYC3AIgAEEANgLYAiAAIAc2AtQCIABBADYC0AIgAkGN9gEgAEHQAmoQMCAAIAkgDmoiDiwAADYCzAIgAEEANgLIAiAAIAc2AsQCIABBADYCwAIgAkGz9gEgAEHAAmoQMCAAIBEuAQI2ArwCIABBATYCuAIgACAHNgK0AiAAQQA2ArACIAJBjfYBIABBsAJqEDAgACAOLAABNgKsAiAAQQE2AqgCIAAgBzYCpAIgAEEANgKgAiACQbP2ASAAQaACahAwIAdBAWoiByALRw0ACwsgAygCHA0AIAMoAtQCIgtBAEwNAEEAIQcDQCAAIAwgB0EBdCIOai4BIDYCmAIgACAHNgKUAiAAQQE2ApACIAJBzIACIABBkAJqEDAgACAHIApqLAAQNgKIAiAAIAc2AoQCIABBATYCgAIgAkG6/gEgAEGAAmoQMCAAIAggB0ECdGoiEUFAay4BADYC/AEgAEEANgL4ASAAIAc2AvQBIABBATYC8AEgAkGN9gEgAEHwAWoQMCAAIAkgDmoiDiwAIDYC7AEgAEEANgLoASAAIAc2AuQBIABBATYC4AEgAkGz9gEgAEHgAWoQMCAAIBEuAUI2AtwBIABBATYC2AEgACAHNgLUASAAQQE2AtABIAJBjfYBIABB0AFqEDAgACAOLAAhNgLMASAAQQE2AsgBIAAgBzYCxAEgAEEBNgLAASACQbP2ASAAQcABahAwIAdBAWoiByALRw0ACwsgACADKALoBTYCsAEgAkGP5QEgAEGwAWoQMAsgACADKALsBTYCoAEgAkHb+AEgAEGgAWoQMCAGLQAoBEAgACADKALwBTYCkAEgAkGR7AEgAEGQAWoQMCAAIAMoAvQFNgKAASACQfTrASAAQYABahAwCyAGLQA8BEAgACADLAD5BTYCcCACQfbaASAAQfAAahAwCyADLQD5BSEHIAAgAywA+gU2AmAgAEHfngFB250BIAcbNgJkIAJBzMUBIABB4ABqEDACQCADLQD5BUUNACADLQD6BQ0AIAAgAygC/AU2AlAgAkHs4wEgAEHQAGoQMCAAIAMoAoAGNgJAIAJB0+gBIABBQGsQMAsCQCAGLQA6RQ0AAkAgAy0AzQINACADLQDOAg0AIAMtAPoFDQELIAAgAywAhAY2AjAgAkGO3QEgAEEwahAwCyAGLQAuRQRAIAYtAC1FDQELIAAgAygCiAY2AiAgAkGR6QEgAEEgahAwIAMoAogGQQBMDQAgACADKAKMBjYCECACQeKEAiAAQRBqEDAgAygCiAZBAEwNAEEAIQcDQCAAIAMoApAGIAdBAnRqKAIANgIEIAAgBzYCACACQczhASAAEDAgB0EBaiIHIAMoAogGSA0ACwsgAEHgBmokAAwCC0GO8gBByvUAQYcKQbAwEAEAC0GA8gBByvUAQY4KQbAwEAEACwsgBSkDCCEuIAUoAhAhDyMAQdAAayIMJAAgEEEANgIIIARBADoAlBkCfwJAAkACQCAEIAMoAhAiAkEDdGoiBigC2AYiAARAIAAtAAANAQsgDCACNgIAIwBBEGsiAiQAAkBBoK4GKAIAQfGxf0gNAEGlrgYtAAANAEGUrwMoAgAhAEGDygEtAABBKkYiBkUEQEH+wgFBBUEBIAAQeBoLIAIgDDYCDCAAIAZBg8oBaiAMQY8KQZAKENsCGiAAEM8BGgsgAkEQaiQAIAQoAqgRKAJwIgAoAlQiAkEURgRAIABB6Qc2AlAMAgsgACACQQFqNgJUIAAgAkECdGpB8Qc2AgQMAQsgBigC3AYiAgRAIAIgAigCBEEBajYCBAsgBCAANgLoCiAEKALsCiEAIAQgAjYC7AoCQCAARQ0AIAAgACgCBCICQQFrNgIEIAINACAAIAAoAgAoAggRAAAgABArCyAEIAQoAugKLAANQQN0aiIAKALYBSEGIAAoAtwFIgIEQCACIAIoAgRBAWo2AgQLIAQgBjYC4AogBCgC5AohACAEIAI2AuQKAkAgAEUNACAAIAAoAgQiAkEBazYCBCACDQAgACAAKAIAKAIIEQAAIAAQKwsgBCAEKALgCiwAAUEDdGoiACgC2AQhBiAAKALcBCICBEAgAiACKAIEQQFqNgIECyAEIAY2AtgKIAQoAtwKIQAgBCACNgLcCgJAIABFDQAgACAAKAIEIgJBAWs2AgQgAg0AIAAgACgCACgCCBEAACAAECsLAkACQAJAAkAgBCgC4AoiAEUEQCAEKALYCiIADQFBBiEAIAQtALwQQQZHDQMMBAsgACwAAiIHQQFrIgAgBCwAvBBHDQEMAwsgBCwAvBAgACgCCCIHQQFrRg0CIAdBAWshAAsgB0EATA0BCyAEQcAQaiETIARB9A5qIQogAEEBaiELA0ACQCAAQeQAbCICQeQAaiALbSIIIAIgC20iBkgEQCAAIQIMAQsgBCgC4A4hCQJ/IAYgCGpBAXEEQCAAIQIgBgwBCyAKIAZBAXRqIgJB5ABBACAAIAlKGzoAASACIAAgCSAAIAlIGyICOgAAIAZBAWoLIQcgBiAIRg0AIAggBmshDiACIQADQCAKIAdBAXRqIhEgACAJIAAgCUgbIgI6AAAgEUHkACAHIAZrQeQAbCAObSAAIAlKGzoAASAKIAdBAWoiEUEBdGoiACARIAZrQeQAbCAObToAASAAIAI6AAAgB0ECaiEHIAIhACAIIBFHDQALCyATIAJBAnRqIAg2AgAgAkEBayEAIAJBAEoNAAsLIAQgBCAEKALkDkEBdGoiAEH0DmosAAAiAjYC6A4gBCAAQfUOaiwAADYC7A4gBCACNgLwDiADLQAMBEAgBCADKAIkNgKUESAELQCVBCECIAQoAuAKIgAtAN9EIQYgDCAANgJIIAwgBCgC5AoiADYCTCAABEAgACAAKAIEQQFqNgIECyAMIAwpAkg3AyggBEHcEGogDEEoaiAEIC4gDyACIAZFckEBcRCDBiIAQQBIBEAgEEEAIABrNgIIQQAMBAtBACECIAAgBCgC6BAgBCgC5BAiBmtBAnVJBEAgBiAAQQJ0aigCACECCyAEIAI2AqgRIAIgGS0ABzoAvAIgAiAZLwAFOwC6AiAEKAKoESEAIAwgBCgC2Ao2AkAgDCAEKALcCiICNgJEIAIEQCACIAIoAgRBAWo2AgQLIAwgBCgC4Ao2AjggDCAEKALkCiICNgI8IAIEQCACIAIoAgRBAWo2AgQLIAwgBCgC6Ao2AjAgDCAEKALsCiICNgI0IAIEQCACIAIoAgRBAWo2AgQLIAwgDCkCQDcDICAMIAwpAjg3AxggDCAMKQIwNwMQIAwoAiAhAiAMKAIkIgYEQCAGIAYoAgRBAWo2AgQLIAAgAjYCdCAAKAJ4IQIgACAGNgJ4AkAgAkUNACACIAIoAgQiBkEBazYCBCAGDQAgAiACKAIAKAIIEQAAIAIQKwsgDCgCGCECIAwoAhwiBgRAIAYgBigCBEEBajYCBAsgACACNgJ8IAAoAoABIQIgACAGNgKAAQJAIAJFDQAgAiACKAIEIgZBAWs2AgQgBg0AIAIgAigCACgCCBEAACACECsLIAwoAhAhAiAMKAIUIgYEQCAGIAYoAgRBAWo2AgQLIAAgAjYChAEgACgCiAEhAiAAIAY2AogBAkAgAkUNACACIAIoAgQiAEEBazYCBCAADQAgAiACKAIAKAIIEQAAIAIQKwsCQCAMKAIUIgBFDQAgACAAKAIEIgJBAWs2AgQgAg0AIAAgACgCACgCCBEAACAAECsLAkAgDCgCHCIARQ0AIAAgACgCBCICQQFrNgIEIAINACAAIAAoAgAoAggRAAAgABArCwJAIAwoAiQiAEUNACAAIAAoAgQiAkEBazYCBCACDQAgACAAKAIAKAIIEQAAIAAQKwsgBCgCqBEiACAENgJwQQAhB0EAIQggACgCoAEiAgRAIAJBACAAKAKkAUEDbBA0GgsgACgCjAEiAgRAIAJBACAAKAKQAUEYbBA0GgsgACgChAIiAgRAIAJBACAAKAKIAhA0GgsCQCAAKAKQASIGQQBMDQAgACgCwAIhAkEAIQAgBkEITwRAIAZB+P///wdxIQkDQCACIABBzABsakEANgIAIAIgAEEBckHMAGxqQQA2AgAgAiAAQQJyQcwAbGpBADYCACACIABBA3JBzABsakEANgIAIAIgAEEEckHMAGxqQQA2AgAgAiAAQQVyQcwAbGpBADYCACACIABBBnJBzABsakEANgIAIAIgAEEHckHMAGxqQQA2AgAgAEEIaiEAIAhBCGoiCCAJRw0ACwsgBkEHcSIGRQ0AA0AgAiAAQcwAbGpBADYCACAAQQFqIQAgB0EBaiIHIAZHDQALCwJAIAQtAIQZIgBB+AFxQRBHDQACQAJAIABBE2tB/wFxQQJJDQAgAEESRiAAQf4BcUEQRnINACAELQCYEQ0AIAQtAJsRQQFHDQELIARBADoAmxEgBEEBOgCZEQwBCyAEQQA7AJkRCwJAAkAgBC0AhBlB/gFxQQhHDQAgBC0AmRFBAUcNACAEKAKoEUEAOgBoDAELIAQoAqgRIAMtACBBAEc6AGgLQQAhBgJAAkAgBC0AhBlB+AFxQRBHDQAgBC0AmRFBAUcNACAEQQE6AJQZIARBADYCnBEgAygCJCEADAELIAQoAuAKKALkgwEhAiAEAn8CQCADKAIkIgAgBCgCoBEiBk4NACAGIABrIAJBAm1IDQAgBCgCpBEgAmoMAQsCQCAAIAZMDQAgACAGayACQQJtTA0AIAQoAqQRIAJrDAELIAQoAqQRCyIGNgKcEQsgBCgCqBEiAiAANgJcIAIgACAGajYCYAJAIAItALwCDQAgBC0AhBkiAEHxAXFFDQAgAEH+AXEiAEEIRg0AIABBBkYNACAEIAMoAiQ2AqARIAQgBCgCnBE2AqQRCyADLQAMBEAgBCgCqBFBATYCZEEAIQZBACEHQQAhCkEAIQ4jAEEgayIJJAAgCUEANgIcIAlCADcCFCAEKAKoESIAKAIAIRECQAJAAkAgBC0AhBlB+AFxQRBHDQAgBC0AmRFBAUcNACAEKALoECILIAQoAuQQIghGDQAgACgCYCEUA0ACQCAIIApBAnRqKAIAIg8oAmRFDQAgDygCYCAUTg0AIA8oAgAiEyAPKAJsTw0AAkAgByAOSQRAIAcgEzYCACAHQQRqIQcMAQsgByAGa0ECdSICQQFqIgBBgICAgARPDQxB/////wMgDiAGayIOQQF1IhUgACAAIBVJGyAOQfz///8HTxsiAAR/IABBgICAgARPDRYgAEECdBAsBUEACyIOIAJBAnRqIgIgEzYCACAOIABBAnRqIQ4gAiEAIAYgB0cEQANAIABBBGsiACAHQQRrIgcoAgA2AgAgBiAHRw0ACwsgAkEEaiEHIAkgDjYCHCAJIAA2AhQgBgRAIAYQKiAEKALoECELIAQoAuQQIQgLIAAhBgsgCSAHNgIYIA8gDygCADYCbAsgCkEBaiIKIAsgCGtBAnVJDQALCwJAIAQtAIQZQRNrQf8BcUECSQRAIARCADcC8BMgBEGAFGpBADYCACAEQfgTakIANwIADAELQQAhCkEAIQdBACEGIAMtAJQHIggEQCADQbQGaiELIARBhBVqIQ4gBEGEFGohDyADQfQGaiETIAQoAqgRIRRBACEAA0AgDyAGQQJ0aiAOIAdBAnRqIAAgE2otAAAiAhsgFCgCYCALIABBAXRqLgEAajYCACAGIAJBAEdqIQYgByACRWohByAAQQFqIgAgCEcNAAsLIAQgBjYC8BMgAy0AlQciBgRAIARBhBVqIQggBEHEFGohCyADQdQGaiEOIANBhAdqIQ8gBCgCqBEhE0EAIQADQCALIApBAnRqIAggB0ECdGogACAPai0AACICGyATKAJgIA4gAEEBdGouAQBqNgIAIAogAkEAR2ohCiAHIAJFaiEHIABBAWoiACAGRw0ACwsgBCAHNgL4EyAEIAo2AvQTAkAgAygCmAEgAygClAFqQQBMBEBBACEGQQAhCAwBCyAEQbATaiELIARBhBZqIQ4gBEHwEmohDyAEQcQVaiETIARB8BFqIRQgBEGwEmohFSADQfwBaiEXIARBsBFqIRIgBCgC4AohGCAEKAKoESEcQQAhB0EAIQhBACEGA0AgEiAHQQJ0IgJqKAIAIQAgByAXaiIKLQAABEAgHCgCYCAAaiADKAIkIBgoAuSDASACIBVqKAIAbGprIQALAkAgAiAUaigCAARAIBMgCEECdCICaiAANgIAIAIgD2ogCiwAADYCACAIQQFqIQgMAQsgDiAGQQJ0IgJqIAA2AgAgAiALaiAKLAAANgIAIAZBAWohBgsgB0EBaiIHIAMoApgBIAMoApQBakgNAAsLIAQgBjYCgBQgBCAINgL8EwsgBCgC5BAhACAEKALoECECIAlBADYCECAJQgA3AgggACACRwRAIAIgAGtBAnUiAEEASA0JIAkgABAsIgI2AgggCSAAIAJqIgY2AhAgAkEAIAAQNBogCSAGNgIMCyAEQdwQaiEAAkAgBCgC/BMiBkEATA0AIARBhBhqIQsgBEHEFWohDiAEQfASaiEPQQAhCgNAIA4gCkECdCICaiIIKAIAIQYgAiALaiITAn8gAiAPaigCAEUEQCAAIAYgERCHBgwBCyAAIAYgEUEBEJ0CCyIHNgIAAkACfyAHQQBOBEAgCSgCCCAHagwBCyAEIAQoAuAKIAgoAgBBARDuAiIHQQBIDQEgBCgC5BAhAiAEKALoECEGIAlBADoABwJAIAYgAmtBAnUiAiAJKAIMIAkoAggiCGsiBksEQCAJQQhqIAIgBmsgCUEHahDtAiAJKAIIIQgMAQsgAiAGTw0AIAkgAiAIajYCDAsgEyAHNgIAIAcgCGoLQQE6AAAgBCgC5BAgB0ECdGooAgAtALgCBEAgBCgCqBFBBDoAuAILIApBAWoiCiAEKAL8EyIGSA0BDAILC0EAIAdrIQcMAgsgBCgCgBQiC0EASgRAIARBxBhqIQ4gBEGEFmohDyAEQbATaiETQQAhCgJAA0AgDyAKQQJ0IgJqIgcoAgAhBiACIA5qIgsCfyACIBNqKAIARQRAIAAgBiAREIcGDAELIAAgBiARQQEQnQILIgI2AgACQAJ/IAJBAE4EQCAJKAIIIAJqDAELIAQgBCgC4AogBygCAEEBEO4CIgJBAEgNASAEKALkECEGIAQoAugQIQcgCUEAOgAHAkAgByAGa0ECdSIGIAkoAgwgCSgCCCIIayIHSwRAIAlBCGogBiAHayAJQQdqEO0CIAkoAgghCAwBCyAGIAdPDQAgCSAGIAhqNgIMCyALIAI2AgAgAiAIagtBAToAACAKQQFqIgogBCgCgBQiC04NAgwBCwtBACACayEHDAMLIAQoAvwTIQYLAkAgBkEATA0AIARBhBhqIQ8gBCgC5BAhAkEAIQhBACEHIAZBBE8EQCAGQfz///8HcSETQQAhDgNAIAIgDyAHQQJ0aiIKKAIAQQJ0aigCAEECNgJkIAIgCigCBEECdGooAgBBAjYCZCACIAooAghBAnRqKAIAQQI2AmQgAiAKKAIMQQJ0aigCAEECNgJkIAdBBGohByAOQQRqIg4gE0cNAAsLIAZBA3EiBkUNAANAIAIgDyAHQQJ0aigCAEECdGooAgBBAjYCZCAHQQFqIQcgCEEBaiIIIAZHDQALCwJAIAtBAEwNACALQQNxIQogBEHEGGohDiAEKALkECECQQAhCEEAIQcgC0EETwRAIAtB/P///wdxIQ9BACELA0AgAiAOIAdBAnRqIgYoAgBBAnRqKAIAQQI2AmQgAiAGKAIEQQJ0aigCAEECNgJkIAIgBigCCEECdGooAgBBAjYCZCACIAYoAgxBAnRqKAIAQQI2AmQgB0EEaiEHIAtBBGoiCyAPRw0ACwsgCkUNAANAIAIgDiAHQQJ0aigCAEECdGooAgBBAjYCZCAHQQFqIQcgCEEBaiIIIApHDQALCwJAIAQoAvATQQBMDQAgBEHEFmohCyAEQYQUaiEOQQAhCgNAAkAgCyAKQQJ0IgJqIgYgACACIA5qIgIoAgAgEUEAEJ0CIgc2AgACfyAHQQBOBEAgCSgCCCAHagwBCyAEIAQoAuAKIAIoAgBBABDuAiIHQQBIDQEgBiAHNgIAIAQoAuQQIQIgBCgC6BAhBiAJQQA6AAcCQCAGIAJrQQJ1IgIgCSgCDCAJKAIIIgZrIghLBEAgCUEIaiACIAhrIAlBB2oQ7QIgCSgCCCEGDAELIAIgCE8NACAJIAIgBmo2AgwLIAYgB2oLQQE6AAAgBCgC5BAgB0ECdGooAgAtALgCBEAgBCgCqBFBBDoAuAILIApBAWoiCiAEKALwE0gNAQwCCwtBACAHayEHDAILAkAgBCgC9BNBAEwNACAEQYQXaiELIARBxBRqIQ5BACEKA0ACQCALIApBAnQiAmoiBiAAIAIgDmoiAigCACARQQAQnQIiBzYCAAJ/IAdBAE4EQCAJKAIIIAdqDAELIAQgBCgC4AogAigCAEEAEO4CIgdBAEgNASAGIAc2AgAgBCgC5BAhAiAEKALoECEGIAlBADoABwJAIAYgAmtBAnUiAiAJKAIMIAkoAggiBmsiCEsEQCAJQQhqIAIgCGsgCUEHahDtAiAJKAIIIQYMAQsgAiAITw0AIAkgAiAGajYCDAsgBiAHagtBAToAACAEKALkECAHQQJ0aigCAC0AuAIEQCAEKAKoEUEEOgC4AgsgCkEBaiIKIAQoAvQTSA0BDAILC0EAIAdrIQcMAgsgBCgC+BNBAEoEQCAEQcQXaiEGIARBhBVqIQhBACEHA0AgBiAHQQJ0IgJqIAAgAiAIaigCACARQQAQnQIiAjYCACACQQBOBEAgCSgCCCACakEBOgAACyAHQQFqIgcgBCgC+BNIDQALC0EAIQIgBCgC6BAiBiAEKALkECIKa0EATA0AA0ACQCAJKAIMIAkoAggiAGsgAksEQCAAIAJqLQAADQELIAogAkECdGooAgAiDiAEKAKoESIARg0AIA4oAmwgACgCAE0NACAOKAJkRQ0AIA4oAgAhCwJAIAkoAhgiByAJKAIcIhFJBEAgByALNgIAIAdBBGohCwwBCyAHIAkoAhQiCGtBAnUiD0EBaiIAQYCAgIAETw0LQf////8DIBEgCGsiEUEBdSITIAAgACATSRsgEUH8////B08bIhEEfyARQYCAgIAETw0VIBFBAnQQLAVBAAsiEyAPQQJ0aiIAIAs2AgAgAEEEaiELIAcgCEcEQANAIABBBGsiACAHQQRrIgcoAgA2AgAgByAIRw0ACwsgCSATIBFBAnRqNgIcIAkgCzYCGCAJIAA2AhQgCEUNACAIECogBCgC5BAhCiAEKALoECEGCyAJIAs2AhggDiAEKAKoESgCADYCbAsgAkEBaiICIAYgCmtBAnVIDQALDAALQQAhByADQcgKaiIAIAlBFGpGDQAgACAJKAIUIgAgCSgCGCICIAIgAGtBAnUQ1wELIAkoAggiAARAIAkgADYCDCAJKAIQGiAAECoLIAkoAhQiAARAIAkgADYCGCAJKAIcGiAAECoLIAlBIGokACAQIAc2AghBACAHDQQaCyAEKAKoESIAQQE2AmRBoK4GIAAoAmA2AgAgBEEAOgCYEQwCCyAEKAKoEQ0BC0EADAELIAMoAhxBAU0EQEEAAn9BACEAIwBB4ANrIgIkACADKALQAiEHIAMoApgHIQkgAkEAQeAAEDQhAiAEQYQYaiEKIARBhBdqIQsgBEHEFmohDiAHIAkgByAJShsiBkEBayEIIAQoAvwTIhRBAWshESAEKAL0EyIVQQFrIQ8gBCgC8BMiF0EBayETIBdBAEwhFwJAAkACQAJAA0AgACAGTg0BIBdFBEAgAkGgAmogAEECdGogDiAIIABrIhIgEyASIBNJGyISQQJ0QQRqEDIaIAAgEmpBAWohAAsCQCAVQQBMDQAgACAGTg0AIAJBoAJqIABBAnRqIAsgCCAAayISIA8gDyASSxsiEkECdEEEahAyGiAAIBJqQQFqIQALAkAgFEEATA0AIAAgBk4NACAAIAJqQQEgCCAAayISIBEgESASSxsiEkEBaiIYEDQaIAJBoAJqIABBAnRqIAogEkECdEEEahAyGiAAIBhqIQALIAANAAsgBCgCVCIAQRRGBEAgBEHpBzYCUEEAIQYMAgsgBCAAQQFqNgJUIAQgAEECdGpB+Ac2AgRBACEGDAELIAdBEEoNASAHQQBKBEAgA0GcCWohDyADQZwIaiETIANBnApqIRQgA0GcB2ohFSADQdoCaiEXQQAhACADLQDYAiESA0AgACEGIBIEQCAAIBdqLQAAIQYLIBUgAEECdCIIaiIRIAJBoAJqIAZBAnRqKAIANgIAIAAgFGogAiAGai0AADoAAEEAIQYgESgCACIRIAQoAugQIAQoAuQQIhhrQQJ1Tw0CIBggEUECdGooAgAiEUUNAiAIIBNqIBEoAmA2AgAgCCAPaiARKAJkNgIAIABBAWoiACAHRw0ACwtBASEGIAMoAhwNACAEKAL8EyIUQQFrIQggBCgC8BMiFUEBayERIAQoAvQTIhdBAWshDyADKALUAiIHIAkgByAJShsiBkEBayEJIAJBMGohE0EAIQAgF0EATCEXAkADQCAAIAZODQEgF0UEQCACQeAAaiAAQQJ0aiALIAkgAGsiEiAPIA8gEksbIhJBAnRBBGoQMhogACASakEBaiEACwJAIBVBAEwNACAAIAZODQAgAkHgAGogAEECdGogDiAJIABrIhIgESARIBJLGyISQQJ0QQRqEDIaIAAgEmpBAWohAAsCQCAUQQBMDQAgACAGTg0AIAAgE2pBASAJIABrIhIgCCAIIBJLGyISQQFqIhgQNBogAkHgAGogAEECdGogCiASQQJ0QQRqEDIaIAAgGGohAAsgAA0ACyAEKAJUIgBBFEYEQCAEQekHNgJQQQAhBgwCCyAEIABBAWo2AlQgBCAAQQJ0akH4BzYCBEEAIQYMAQsgB0EQSg0CQQEhBiAHQQBMDQAgA0HcCWohCiADQdwIaiELIANBrApqIQ4gA0HcB2ohESADQeoCaiEPQQAhACADLQDZAiEUA0AgACEGIBQEQCAAIA9qLQAAIQYLIBEgAEECdCIJaiIIIAJB4ABqIAZBAnRqKAIANgIAIAAgDmogBiATai0AADoAAEEAIQYgCCgCACIIIAQoAugQIAQoAuQQIhVrQQJ1Tw0BIBUgCEECdGooAgAiCEUNASAJIAtqIAgoAmA2AgAgCSAKaiAIKAJkNgIAQQEhBiAAQQFqIgAgB0cNAAsLIAJB4ANqJAAgBgwCC0GYiQFBvPQAQYcOQeUeEAEAC0H3iAFBvPQAQbwOQeUeEAEAC0UNARoLIAMgBCgCrBFBqAZqIANBGGogAy0AFBsoAgA2AqgGIAQgAzYCrBFBAQshISAMQdAAaiQAIAQoAqgRIQAgIUUEQCAABEAgAEECOgC4AgsgBEGkBGogBRCQASADKALICiIABEAgAyAANgLMCiADKALQChogABAqCyAWEMQBGiADKAKQBiIABEAgAyAANgKUBiADKAKYBhogABAqCwJAIAMoAggiAEUNACAAIAAoAgQiAkEBazYCBCACDQAgACAAKAIAKAIIEQAAIAAQKwsgAxAqIBAoAggMAQsgAyAAKAI4IgYgACgCNCICa0ECdSIHNgIAAkAgACgCPCIIIAZLBEAgBiADNgIAIAAgBkEEajYCOAwBCwJAIAdBAWoiCUGAgICABEkEQEH/////AyAIIAJrIghBAXUiCiAJIAkgCkkbIAhB/P///wdPGyIJBH8gCUGAgICABE8NAiAJQQJ0ECwFQQALIgogB0ECdGoiByADNgIAIAdBBGohCCACIAZHBEADQCAHQQRrIgcgBkEEayIGKAIANgIAIAIgBkcNAAsgACgCPBogACgCNCECCyAAIAogCUECdGo2AjwgACAINgI4IAAgBzYCNCACBEAgAhAqCyAAIAg2AjgMAgsMAwsMCwsgDUEBEOABIA0QkwYgAygCiAZBAEoEQCANKAIAIAUoAhRrIQkgAygCkAYhBkEAIQcDQAJ/IAYgB0ECdCIIaigCACEGIAUoAiQgBSgCICIKa0ECdSEAA0BBACAAIgJBAEwNARogCiAAQQFrIgBBAnRqKAIAIAlrIAZKDQALIAILIQAgAygCkAYiBiAIaiICIAIoAgAgAGs2AgAgB0EBaiIHIAMoAogGSA0ACwsCQCADLQAMRQRAIAQoAowZIQAMAQtB4AMQLCIAQQhqEIAGGiAAQgA3A9gDIABCADcD0AMgAEIANwPIAyAAQgA3A8ADIABCADcDuAMgAEIANwOwAyAAQgA3A6gDIAAgBCgCqBE2AgACQCAEKAKMGSIHIAQoApAZIglJBEAgByAANgIAIAdBBGohAAwBCyAHIARBiBlqKAIAIgJrQQJ1IghBAWoiBkGAgICABE8NA0H/////AyAJIAJrIglBAXUiCiAGIAYgCkkbIAlB/P///wdPGyIJBH8gCUGAgICABE8NDSAJQQJ0ECwFQQALIgogCEECdGoiBiAANgIAIAZBBGohACACIAdHBEADQCAGQQRrIgYgB0EEayIHKAIANgIAIAIgB0cNAAsgBCgCkBkaIAQoAogZIQILIAQgCiAJQQJ0ajYCkBkgBCAANgKMGSAEIAY2AogZIAJFDQAgAhAqCyAEIAA2AowZCyAAIAQoAogZRwRAQZABECwiAEEAOgAkIABBADYCICAAQgA3AwAgAEEANgIsIAAgBDYCjAEgAEL/////DzcDgAEgAEKAgICAcDcDeCAAQQA2AogBIABBADYCKCAAIAM2AgQgACAFNgIAIAAgDSkDADcDCCAAIA0pAwg3AxAgACANKQMQNwMYIAAgBC0AlBk6ACQCQCAEKAKMGUEEaygCACINKAKsAyIFIA0oArADIgNJBEAgBSAANgIAIAVBBGohBgwBCyAFIA0oAqgDIgJrQQJ1IgdBAWoiBkGAgICABE8NA0H/////AyADIAJrIgNBAXUiCSAGIAYgCUkbIANB/P///wdPGyIDBH8gA0GAgICABE8NDSADQQJ0ECwFQQALIgkgB0ECdGoiByAANgIAIAdBBGohBiACIAVHBEADQCAHQQRrIgcgBUEEayIFKAIANgIAIAIgBUcNAAsgDSgCsAMaIA0oAqgDIQILIA0gCSADQQJ0ajYCsAMgDSAGNgKsAyANIAc2AqgDIAJFDQAgAhAqCyANIAY2AqwDCyAEIBBBB2oQjAYaQQALISIgEEEQaiQAICIMAQsQNgALIQYMAQsCQAJAAkACQAJAAkAgBEEgaw4JAAECBQQFBQMDBQtBnAUQLCIIQcT+AjYCACAIQgA3AgQCQAJ/IAAiBEEEaiEkIAhBDGpBAEGQBRA0IgMgGUEIaiIHQQQQMSIANgIAQQghBgJAAkACQCAAQQ9KDQAgB0ECEOABIAMgB0EGEDEiAEEBajYCBCAAQT5KDQAgAyAHQQMQMSIAQQFqNgIIIABBBkoNACADIAdBARAxNgIMIAdBEBDgASADQRBqIAcgAygCCBDoBSADIAdBARAxIgA2AuQDAkBBACADKAIIIgVBAWsgABsiAiAFSAR/IANB6ANqIQkgAiEAA0AgCSAAQQxsaiIFIAcQRDYCACAFIAcQRDYCBCAFIAcQRCIKNgIIIAUoAgBB4fJ5Rg0DIApB4fJ5Rg0DIAUoAgRB4fJ5Rg0DIABBAWoiACADKAIISA0ACyADKALkAwUgAAsNACACQQdKDQIgAkEATA0AIANB6ANqIAJBDGxqIgUoAgAhACAFKAIEIQYgAyAFKAIIIgU2AvADIAMgBjYC7AMgAyAANgLoAyACQQFGDQAgAyAFNgL8AyADIAY2AvgDIAMgADYC9AMgAkECRg0AIAMgBTYCiAQgAyAGNgKEBCADIAA2AoAEIAJBA0YNACADIAU2ApQEIAMgBjYCkAQgAyAANgKMBCACQQRGDQAgAyAFNgKgBCADIAY2ApwEIAMgADYCmAQgAkEFRg0AIAMgBTYCrAQgAyAGNgKoBCADIAA2AqQEIAJBBkYNACADIAU2ArgEIAMgBjYCtAQgAyAANgKwBAsgAyAHQQYQMToAyAQgAyAHEEQiADYCzAQgAEH/B2tB/3dNDQIgAyAAQQFqIgY2AswEAkAgAygC1AQiACICIAMoAtAEIglrQQxtIgUgBkkEQEEAIQIgBiAFayIFIAMoAtgEIgogAGtBDG1NBEAgAyAFBH8gAEEAIAVBDGxBDGsiACAAQQxwa0EMaiIAEDQgAGoFIAALNgLUBAwCCwJAIAAgAygC0AQiCWtBDG0iCyAFaiIGQdaq1aoBSQRAQdWq1aoBIAogCWtBDG0iCkEBdCIQIAYgBiAQSRsgCkGq1arVAE8bIgoEQCAKQdaq1aoBTw0CIApBDGwQLCECCyALQQxsIAJqIgZBACAFQQxsQQxrIgUgBUEMcGtBDGoiCxA0IgUgC2ohCyACIApBDGxqIQoCQCAAIAlGBEAgBSECDAELA0AgBkEEayIQQQA2AgAgBkEMayICIABBDGsiBSgCADYCACAGQQhrIABBCGsoAgA2AgAgECAAQQRrIgAoAgA2AgAgAEEANgIAIAVCADcCACACIQYgBSIAIAlHDQALIAMoAtgEGiADKALUBCEAIAMoAtAEIQkLIAMgCjYC2AQgAyALNgLUBCADIAI2AtAEIAAgCUcEQANAIABBDGsiAigCACIGBEAgAEEIayAGNgIAIABBBGsoAgAaIAYQKgsgAiIAIAlHDQALCyAJBEAgCRAqCwwDCxA2AAsMEgsgBSAGTQ0AIAkgBkEMbGoiBiACRwRAA0AgAkEMayIAKAIAIgUEQCACQQhrIAU2AgAgAkEEaygCABogBRAqCyAAIgIgBkcNAAsLIAMgBjYC1AQLIAMoAswEQQJOBEAgAy0AyAQhBkEBIQADQCAGQQFqIQICQCAGIABBDGwiCiADKALQBGoiBSgCBCAFKAIAIgtrIglPBEAgBSACIAlrEGUMAQsgAiAJTw0AIAUgAiALajYCBAtBACECA0AgB0EBEDEhBiADKALQBCAKaigCACACaiAGOgAAIAIgAy0AyAQiBkkhIyACQQFqIQIgIw0ACyAAQQFqIgAgAygCzARIDQALCyADIAdBARAxIgA6ANwEAkACQCAAQf8BcUUNACADIAdBIBAxNgLgBCADIAdBIBAxNgLkBCADIAdBARAxIgA6AOgEIABB/wFxRQ0AIAMgBxBEQQFqNgLsBCADIAcQRCICNgLwBCACQYAITw0EQQAhBQJAIAMoAvgEIgAgAygC9AQiCWtBAXUiBiACSQRAIAIgBmsiBiADKAL8BCIKIABrQQF1TQRAIAMgBgR/IABBACAGQQF0IgAQNCAAagUgAAs2AvgEDAILAkAgACADKAL0BCICa0EBdSIMIAZqIglBAE4EQEH/////ByAKIAJrIgogCSAJIApJGyAKQf7///8HTxsiCgRAIApBAEgNAiAKQQF0ECwhBQsgBSAMQQF0aiIJQQAgBkEBdCIGEDQgBmohBiAAIAJHBEADQCAJQQJrIgkgAEECayIALwEAOwEAIAAgAkcNAAsLIAMgBSAKQQF0ajYC/AQgAyAGNgL4BCADIAk2AvQEIAIEQCACECoLDAMLEDYACwwUCyACIAZJBEAgAyAJIAJBAXRqNgL4BAsLAkAgAygC8AQiACADQYAFaiICKAIEIAIoAgAiBWsiBksEQCACIAAgBmsQZQwBCyAAIAZJBEAgAiAAIAVqNgIECwsgAygC8ARBAEwNACAHEEQhACADKAL0BCAAOwEADAELIAMgB0EBEDE6AIwFC0EAIQYLIAYMAgtBoPwAQdb0AEGQAUGX8gAQAQALICRBCEEAEFFBCAsiBw0AIAQoAogEIgZBAE4EQCMAQfACayICJABBlK8DIQACQAJAAkAgBkEBaw4CAQACC0GQrwMhAAsgACgCACIFQdCMAkEAEDAgAiADKAIANgLgAiAFQbaEAiACQeACahAwIAIgAygCBDYC0AIgBUHmhwIgAkHQAmoQMCACIAMoAgg2AsACIAVBg4UCIAJBwAJqEDAgAiADKAIMNgKwAiAFQZL6ASACQbACahAwIAMoAgghACADQRBqQQEgBRDgAiAAQQJOBEAgAEECayEGIANBxABqIQlBACEAA0AgAiAANgKgAiAFQZCJAiACQaACahAwIAkgAEE0bGpBACAFEOACIAAgBkchJSAAQQFqIQAgJQ0ACwsgAiADKALkAzYCkAIgBUHD1gEgAkGQAmoQMAJAIAMoAuQDBEAgAygCCEEATA0BIANB6ANqIQlBACEAA0AgAiAJIABBDGxqIgYoAgA2AoQCIAIgADYCgAIgBUGAywEgAkGAAmoQMCACIAYoAgQ2AvABIAVBo80BIAJB8AFqEDAgAiAGKAIINgLgASAFQdDNASACQeABahAwIABBAWoiACADKAIISA0ACwwBCyACIAMoAugDNgLQASAFQarLASACQdABahAwIAIgAygC7AM2AsABIAVBn80BIAJBwAFqEDAgAiADKALwAzYCsAEgBUHMzQEgAkGwAWoQMAsgAiADLQDIBDYCoAEgBUH5zQEgAkGgAWoQMCACIAMoAswENgKQASAFQcvKASACQZABahAwIAMoAswEQQJOBEBBASEGA0BBACEAIAZBDGwhCQNAIAIgAygC0AQgCWooAgAgAGosAAA2AogBIAIgADYChAEgAiAGNgKAASAFQfrMASACQYABahAwIAAgAy0AyARJISYgAEEBaiEAICYNAAsgBkEBaiIGIAMoAswESA0ACwsgAiADLADcBDYCcCAFQdfLASACQfAAahAwAkAgAy0A3ARFDQAgAiADKALgBDYCYCAFQeTKASACQeAAahAwIAIgAygC5AQ2AlAgBUGzzgEgAkHQAGoQMCACIAMsAOgENgJAIAVBk8wBIAJBQGsQMCADLQDoBEUNACACIAMoAuwENgIwIAVBvcwBIAJBMGoQMCACIAMoAvAENgIgIAVBks4BIAJBIGoQMCADKALwBEEATA0AIAIgAygC9AQvAQA2AhQgAkEANgIQIAVB3swBIAJBEGoQMAwBCyACIAMsAIwFNgIAIAVB+ssB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5gIgBSgCzAMiAyAFKALIAyIERwRAQQAhAgNAIAQgAkECdGooAgAiCQRAIAkgCSgCACgCBBEAACAFKALIAyEEIAUoAswDIQMLIAJBAWoiAiADIARrQQJ1SQ0ACwsgBSAENgLMAwwBC0GAkAFBvPQAQesHQZb9ABABAAsgBkECNgIoQQAhAyAFKAKsAyAFKAKoAyICa0ECdUEBayIERQ0BA0AgBiACIAhBAnRqIgkoAgBHBEAgCEEBaiIIIARHDQEMAwsLIAkoAgQiAkUNASAGKAIEKAIYIgggAigCBCgCGE4NAQNAIAggBSgCACIGKAKQAU4NAiAGKALAAiAIQcwAbGoiBigCAEEATARAIAZBATYCAAsgCEEBaiIIIAIoAgQoAhhIDQALDAELIARFDQECfyAFIgkoAgAiBygCzAJBACAHKALIAmtGBEAgAigChAENByAHKAKEASEMIAcoAnwoAvyDASEPQX8gAigCBCIQKAKIBiILQQFqIgStQrCRAX4iIadBBHIgIUIgiKcbECwiCiAENgIAIApBBGohAwJAIARFBEAgAiAENgKIASACIAM2AoQBDAELIAMgBEGwkQFsaiESIAMhBQNAIAVBjJEBakIANwIAIAVB1JABakEANgIAIAVBzJABakIANwIAIAVCADcCxJABIAVCADcCmJEBIAVBoJEBakIANwIAIAVBqJEBakEANgIAIAUgBUEmakFxcUEQaiINNgK4ECANQQBBgBAQNBogBUGwkQFqIgUgEkcNAAsgAiAENgKIASACIAM2AoQBIAtBAEgNACALQf////8HRg0JIBAoAhgiDUECdCIEIAwoAqRCaigCACEFIAogEDYCpJEBIAcoAnAhEiAKIAI2AqyRASAKIAk2AqiRASAKIAc2AqCRASAKIBI2ApyRASAKIAwoAoBCIARqKAIANgIIIAMQngIgAkEMaiISIQQgCwR/IBAoApAGBSAECygCACIOIBIoAgBKBEBBESEGDAELQQEhBCAOQQBMBEBBESEGDAELIApB+JABaiACKAIIIA4QoQIgByAHKALEAkEBajYCxAIgByAHKALUAkEBajYC1AIgAiACKAJ4QQFqNgJ4IAAgA0EBIA0gDSAPbSIDIA9sayADEI0GIAtFDQAgDEHUwQBqIRMgDEGowQBqIREDQCAFQQFqIgUgDCgCMCIDIAwoAjRs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IAMQkAYQKiAAKAKIGSECIAAoAowZBSABC0EEayIBNgKMGSABIAJHDQALCyACBEAgACACNgKMGSAAKAKQGRogAhAqC0EAIQIgAEHcEGoiASgCDCIDIAEoAggiBEcEQANAIAQgAkECdGooAgAiBQRAIAUQ0wMQKiABKAIIIQQgASgCDCEDCyACQQFqIgIgAyAEa0ECdUkNAAsLIAFBIGoQ1gMgASgCFCICBEAgASACNgIYIAEoAhwaIAIQKgsgASgCCCICBEAgASACNgIMIAEoAhAaIAIQKgsgAEH0CmoQ1gMCQCAAKALsCiIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCwJAIAAoAuQKIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEAACABECsLAkAgACgC3AoiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsgAEEEaiEDQdgKIQEDQAJAIAMgAUEIayIBaigCACICRQ0AIAIgAigCBCIEQQFrNgIEIAQNACACIAIoAgAoAggRAAAgAhArCyABQdgGRw0ACwJAIAAoAtQGIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEAACABECsLAkAgACgCzAYiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsCQCAAKALEBiIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCwJAIAAoArwGIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEAACABECsLAkAgACgCtAYiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsCQCAAKAKsBiIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCwJAIAAoAqQGIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEAACABECsLAkAgACgCnAYiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsCQCAAKAKUBiIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCwJAIAAoAowGIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEAACABECsLAkAgACgChAYiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsCQCAAKAL8BSIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCwJAIAAoAvQFIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEAACABECsLAkAgACgC7AUiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsCQCAAKALkBSIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCwJAIAAoAtwFIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEAACABECsLAkAgACgC1AUiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsCQCAAKALMBSIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCwJAIAAoAsQFIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEAACABECsLAkAgACgCvAUiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsCQCAAKAK0BSIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCwJAIAAoAqwFIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEAACABECsLAkAgACgCpAUiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsCQCAAKAKcBSIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCwJAIAAoApQFIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEAACABECsLAkAgACgCjAUiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsCQCAAKAKEBSIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCwJAIAAoAvwEIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEAACABECsLAkAgACgC9AQiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsCQCAAKALsBCIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCwJAIAAoAuQEIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEAACABECsLAkAgACgC3AQiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsgAEGkBGoiASgCICICBEADQCABKAIQIgUgASgCHCIDQQh2Qfz//wdxaigCACADQf8HcUECdGooAgAhBCABIAJBAWs2AiAgASADQQFqIgI2AhwgAkGAEE8EQCAFKAIAECogASABKAIQQQRqNgIQIAEgASgCHEGACGs2AhwLIAEgASgCJCAEKAIYazYCJCABIAQQkAEgASgCICICDQALCyABKAIIIgIEQCABIAIQkAELIAEoAiwiBSABKAIoIgJHBEBBACEDA0AgAiADQQJ0aigCACIEBEAgBCgCFBAqIAQoAiAiAgRAIAQgAjYCJCAEKAIoGiACECoLIAQQKiABKAIsIQUgASgCKCECCyADQQFqIgMgBSACa0ECdUkNAAsLIAIEQCABIAI2AiwgASgCMBogAhAqCyABQQxqENYDIAALsAMBBX8gACgCrAMiASAAKAKoAyICRwRAA0AgAiADQQJ0aigCACIEBEAgBCgCjAFBpARqIAQoAgAQkAEgBCgChAEiAQRAIAFBBGsiBSgCACICBEAgASACQbCRAWxqIQIDQCACQSRrEMQBGiACQbCRAWsiAiABRw0ACwsgBRAqCyAEECogACgCqAMhAiAAKAKsAyEBCyADQQFqIgMgASACa0ECdUkNAAsLIAAoAswDIgMgACgCyAMiAUcEQEEAIQIDQCABIAJBAnRqKAIAIgQEQCAEIAQoAgAoAgQRAAAgACgCzAMhAyAAKALIAyEBCyACQQFqIgIgAyABa0ECdUkNAAsLIAAoAtQDIgMEQCAAKALYAyICIAMiAUcEQANAIAJBCGsQxAEiAiADRw0ACyAAKALUAyEBCyAAIAM2AtgDIAAoAtwDGiAB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IANBH0YNAEEBIAIgAkEBTBshCiAEIAhqQQRtIQUgBCAGakEEbSEHQQAhAwNAIAMgCGpBBG0hCSAAKAKUAiEEAkAgByAAKAKQAiICTg0AIAQgCUwNACAAKAKEAiAHaiACIAlsaiICIAItAABBwAByOgAAIAAoApQCIQQgACgCkAIhAgsCQCADIAZqQQRtIgkgAk4NACAEIAVMDQAgACgChAIgCWogAiAFbGoiAiACLQAAQYABcjoAAAsgA0EBaiIDIApHDQALCwwACyAAKAJ8IQJBASEeCyABQQFqIgEgAigC+IMBSA0ACwsgDkEBaiIOIBZHDQALCyAeDwtBiSBBtMYAQfYAQZMdEAEAC0HjH0G0xgBB9wBBkx0QAQALOAEBfyAAQgA3AwggACgCECEBIABBADYCECAAIAAoAgAgAUEDdSIBazYCACAAIAAoAgQgAWo2AgQLnQEBA38jAEEQayIBJABBrawFLQAAQQFGBEAgASAAKAIENgIEIAEgADYCAEGsjwIgARCyAQsgACgCBCICBEAgAigCACIDQQJOBEAgAiADQQFrNgIAIAAoAgAhAiAAQawBECwiAzYCACAAQQQQLCIANgIEIABBATYCACADIAJBrAEQMhoLIAFBEGokAA8LQb0aQab1AEHfAEGs0wAQAQALfgEDfyMAQRBrIgEkAEGtrAUtAABBAUYEQCABIAAoAgQ2AgQgASAANgIAQZvHASABELIBCyAAKAIEIgIEQCACIAIoAgBBAWsiAzYCAAJAIAMNACAAKAIAIgMEQCADECogACgCBCICRQ0BCyACECoLIABCADcCAAsgAUEQaiQAC2QBA38gAUEDSQRAIAAgAUECdCIDakFAaygCACEFIAIEQCACIABBLEEoIAEbaigCACAAKAJ8IANB3OwCaigCAGooAgBBB2pBCG1sNgIACyAFDwtB2YwBQe31AEGfBUGf0gAQAQALQwEBfyAAKAKQEQRAIAAoAoARIAAoAowRIgFBCHZB/P//B3FqKAIAIAFB/wdxQQJ0aigCAEEAOgBoIABB3BBqEIIGCwtVAQJ/AkAgACgCkBFBAEwNACAAKAKAESAAKAKMESIBQQh2Qfz//wdxaigCACABQf8HcUECdGooAgAiAUUNACABQQA6AGggAEHcEGoQggYgASECCyACC54IAQh/An8CQCAAQaQEaiIH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IAFBIGokACACC5QJAQR/IwBBoAFrIgMkAAJAIAIoAgQgAigCACICayIEQQdNBEAgA0EgECwiATYCECADQpmAgICAhICAgH83AhQgAUHK+QApAAA3AAAgAUEAOgAZIAFB4vkALQAAOgAYIAFB2vkAKQAANwAQIAFB0vkAKQAANwAIIABBAkH2ACADQRBqEC8aIAMsABtBAE4NASADKAIYGiADKAIQECoMAQsCQAJAAkAgAi0AACIFBEAgA0Gg0wM2AhggA0G00wM2AlAgA0HE0wMoAgAiATYCECADQRBqIgIgAUEMaygCAGpByNMDKAIANgIAIANBADYCFCACIAMoAhBBDGsoAgBqIgEgA0EcaiIEED4gAUKAgICAcDcCSCADQczTAygCACIBNgIYIANBGGoiBiABQQxrKAIAakHQ0wMoAgA2AgAgA0HA0wMoAgAiATYCECACIAFBDGsoAgBqQdTTAygCADYCACADQbTTAzYCUCADQYzTAzYCECADQaDTAzYCGCAEED8iBEHwywM2AgAgA0IANwJEIANCADcCPCADQRg2AkwgBkGKqgFBExAtIAUQQkGo5gBBERAtGgJ/IAMoAkwiAUEQcQRAIANBMGohASADKAJIIgUgAygCNCICSQR/IAMgAjYCSCACBSAFCwwBCyABQQhxRQRAQQAhAiADQQA6AA8gA0EEaiEBDAULIANBJGohASADKAIsCyABKAIAIgVrIgJB+P///wdPDQEgAkELTwRAIAJBB3JBAWoiBhAsIQEgAyAGQYCAgIB4cjYCDCADIAE2AgQgAyACNgIIDAMLIAMgAjoADyADQQRqIQEgAg0CQQAhAgwDCyACLQABIQUgASACLQACQQFqOwEAIAEgAi0AA0EBajsBAgJ/IAVBAXEEQEELIQUgBEELTQRAIANBIBAsIgE2AhAgA0KagICAgISAgIB/NwIUIAFBuc4AKQAANwAAIAFBADoAGiABQdHOAC8AADsAGCABQcnOACkAADcAECABQcHOACkAADcACCAAQQJB9gAgA0EQahAvGiADLAAbQQBODQYgAygCGBogAygCEBAqDAYLIAEgAigABCIEQRh0IARBgP4DcUEIdHIgBEEIdkGA/gNxIARBGHZycjYCBCACLQAJQRB0IAItAAhBGHRyIAItAApBCHRyDAELIAEgAi0ABSACLQAEQQh0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C8cBAQJ/IwBBIGsiAyQAIAIgASACQQAgASgCACgCLBEEACIENgIMIANBDGogASACIAIoAgQgBCACKAIAamtBACABKAIAKAIwEQcAIAIgAigCBCACKAIAazYCDCADLAAfQQBIBEAgAygCHBogAygCFBAqCyAAQZClBSkCADcCACAAQQhqIQACQEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgA0EgaiQAC5MBAQR/QX8hAwJAIAAoAhgiASAAKAIcIgBGDQADQAJAAkAgASgCACICRQ0AIAJBoL8EQZiDBRA5IgJFDQAgASgCBCIADQEgAi0AaA8LIAFBCGoiASAARw0BDAILCyAAIAAoAgQiAUEBaiIENgIEIAItAGghAyAAIAE2AgQgBA0AIAAgACgCACgCCBEAACAAECsLIAMLtwoBAn8jAEHQAGsiAyQAIANCADcDSCADQUBrQgA3AwAgA0IANwM4IANCADcDMAJAIAIoAgAiASgCIEECRwRAIANBKBAsIgE2AgwgA0KngICAgIWAgIB/NwIQIAFBqjgpAAA3AB8gAUGjOCkAADcAGCABQZs4KQAANwAQIAFBkzgpAAA3AAggAUGLOCkAADcAACABQQA6ACcgA0EYakEEQboXIANBDGoQLyEBIABCADcCGCAAQgA3AhAgAEIANwIIIABCADcCACAAIAEpAwA3AiAgAEEoaiEAAkAgASwAE0EATgRAIAAgASkCCDcCACAAIAEoAhA2AggMAQsgACABKAIIIAEoAgwQLiABLAATQQBODQAgASgCEBogASgCCBAqCyADLAAXQQBODQEgAygCFBogAygCDBAqDAELQQAhBSABQQAQQEEIRwRAIANBKBAsIgE2AgwgA0KlgICAgIWAgIB/NwIQIAFBgjgpAAA3AB0gAUH9NykAADcAGCABQfU3KQAANwAQIAFB7TcpAAA3AAggAUHlNykAADcAACABQQA6ACUgA0EYakEEQboXIANBDGoQLyEBIABCADcCGCAAQgA3AhAgAEIANwIIIABCADcCACAAIAEpAwA3AiAgAEEoaiEAAkAgASwAE0EATgRAIAAgASkCCDcCACAAIAEoAhA2AggMAQsgACABKAIIIAEoAgwQLiABLAATQQBODQAgASgCEBog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AgQgAQRAIAEgASgCBEEBajYCBAsgAEGQpQUpAgA3AgggAEEQaiEAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyACLAATQQBODQAgAigCEBogAigCCBAqCyACLAArQQBIBEAgAigCKBogAigCIBAqCyACKAIsIgAEQCACIAA2AjAgAigCNBogABAqCwJAIAIoAjwiAEUNACAAIAAoAgQiAUEBazYCBCABDQAgACAAKAIAKAIIEQAAIAAQKwsgAkFAayQAC6UBAQJ/IwBBIGsiAyQAIAEgAkEAIAEoAgAoAiwRBAAhBCACIAEtAGgQSCADQQxqIAEgAiAEEJsBIAMsAB9BAEgEQCADKAIcGiADKAIUECoLIABBkKUFKQIANwIAIABBCGohAAJAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyADQSBqJAALgwUBBH8jAEGgAWsiAyQAIANB5NUDNgJEIANB8NUDKAIAIgY2AgwgA0EMaiIEIAZBDGsoAgBqQfTVAygCADYCACAEIAMoAgxBDGsoAgBqIgYgA0EQaiIFED4gBkKAgICAcDcCSCADQeTVAzYCRCADQdDVAzYCDCAFED8iBkHwywM2AgAgA0IANwI4IANCADcCMCADQRA2AkAgA0GUAWoiBSABIAIQWSAEIAMoApQBIAUgAywAnwEiBEEASCIFGyADKAKYASAEIAUbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBlAFqIgQgAhA1IANBDGogAygClAEgBCADLACfASICQQBIIgQbIAMoApgBIAIgBBsQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgA0EMakHUuQFBEBAtIAEtAGgQQkHPkAJBARAtGgJAAn8gAygCQCIBQRBxBEAgAygCPCICIAMoAigiAUkEQCADIAE2AjwgASECCyADQSRqDAELIAFBCHFFBEBBACECIABBADoACwwCCyADKAIgIQIgA0EYagshAQJAIAIgASgCACIEayICQfj///8HSQRAIAJBC08EQCACQQdyQQFqIgUQLCEBIAAgBUGAgICAeHI2AgggACABNgIAIAAgAjYCBCABIQAMAgsgACACOgALIAINAUEAIQIMAgsQOAALIAAgBCACEDcaCyAAIAJqQQA6AAAgA0Hs1QMoAgAiADYCDCAAQQxrKAIAIANBDGpqQfjVAygCADYCACAGQfDLAzYCACADLAA7QQBIBEAgAygCOBogAygCMBAqCyAGED0aIANBxABqEDsaIANBoAFqJAALywEAIwBBIGsiAyQAIAMgASACEHsgAywAE0EASARAIAMoAhAaIAMoAggQKgsgASACEFI6AGgCQCACLQAUQQFGBEAgA0EAOgAUIANBADoAHyAAQQJB5AAgA0EUahAvGiADLAAfQQBODQEgAygCHBogAygCFBAqDAELIABBkKUFKQIANwIAIABBCGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgA0EgaiQAC5cBAQJ/IABBsIIFNgIAAkAgACgCJCIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCyAAQcjxBDYCACAAKAIQIgEEQCAAIAE2AhQgACgCGBogARAqCwJAIAAoAggiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsgABAqC5UBAQJ/IABBsIIFNgIAAkAgACgCJCIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCyAAQcjxBDYCACAAKAIQIgEEQCAAIAE2AhQgACgCGBogARAqCwJAIAAoAggiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsgAAtnACADIAEoAiAoAmwiATYCACACIAFFQQF0NgIAIABBkKUFKQIANwIAIABBCGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCA8LIABBmKUFKAIAQZylBSgCABAuC/EBAQF/IwBBEGsiASQAIAIoAhAiAwRAIAIoAggiBARAIAQgAxCcAyACKAIQIQMLIAIoAgAiBCAEIAQoAgAoAggREgAgA618IAQoAgAoAhQREAAaIAJBADYCEAsCQCACLQAUQQFGBEAgAUEAOgAEIAFBADoADyAAQQJB5AAgAUEEahAvGiABLAAPQQBODQEgASgCDBogASgCBBAqDAELIABBkKUFKQIANwIAIABBCGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgAUEQaiQACwoAIAAoAiAtAHELCgAgACgCIC0AcAvGJAENfyMAQRBrIg4kACAOQQA2AgwgDkIANwIEIA5BBGohAwJAAkAgASgCICILKAJ0IgkgCygCeCINRwRAA0AgCSgCBCAJKAIAa0EYdiECAkAgAygCBCIEIAMoAggiBUkEQCAEIAI6AAAgBEEBaiEGDAELIAQgAygCACIHayIIQQFqIgFBAEgNAyAIQf////8HIAUgB2siBUEBdCIGIAEgASAGSRsgBUH/////A08bIgYEfyAGECwFQQALIgVqIgEgAjoAACAFIAZqIQwgAUEBaiEGAkAgBCAHRgRAIAEhBQwBC0EAIQogBCECIAhBA3EiCARAA0AgAUEBayIBIAJBAWsiAi0AADoAACAKQQFqIgogCEcNAAsLIAcgBGtBfE0EQANAIAFBAWsgAkEBay0AADoAACABQQJrIAJBAmstAAA6AAAgAUEDayACQQNrLQAAOgAAIAFBBGsiASACQQRrIgItAAA6AAAgAiAHRw0ACwsgAygCCBogAygCACEHCyADIAw2AgggAyAGNgIEIAMgBTYCACAHRQ0AIAcQKgsgAyAGNgIEIAkoAgQgCSgCAGtBEHYhAgJAIAMoAggiBSAGSwRAIAYgAjoAACAGQQFqIQQMAQsgBiADKAIAIgdrIghBAWoiAUEASA0DIAhB/////wcgBSAHayIFQQF0IgQgASABIARJGyAFQf////8DTxsiBAR/IAQQLAVBAAsiBWoiASACOgAAIAQgBWohDCABQQFqIQQCQCAGIAdGBEAgASEFDAELQQAhCiAGIQIgCEEDcSIIBEADQCABQQFrIgEgAkEBayICLQAAOgAAIApBAWoiCiAIRw0ACwsgByAGa0F8TQRAA0AgAUEBayACQQFrLQAAOgAAIAFBAmsgAkECay0AADoAACABQQNrIAJBA2stAAA6AAAgAUEEayIBIAJBBGsiAi0AADoAACACIAdHDQALCyADKAIIGiADKAIAIQcLIAMgDDYCCCADIAQ2AgQgAyAFNgIAIAdFDQAgBxAqCyADIAQ2AgQgCSgCBCAJKAIAa0EIdiECAkAgAygCCCIFIARLBEAgBCACOgAAIARBAWohBgwBCyAEIAMoAgAiB2siCEEBaiIBQQBIDQMgCEH/////ByAFIAdrIgVBAXQiBiABIAEgBkkbIAVB/////wNPGyIGBH8gBhAsBUEACyIFaiIBIAI6AAAgBSAGaiEMIAFBAWohBgJAIAQgB0YEQCABIQUMAQtBACEKIAQhAiAIQQNxIggEQANAIAFBAWsiASACQQFrIgItAAA6AAAgCkEBaiIKIAhHDQALCyAHIARrQXxNBEADQCABQQFrIAJBAWstAAA6AAAgAUECayACQQJrLQAAOgAAIAFBA2sgAkEDay0AADoAACABQQRrIgEgAkEEayICLQAAOgAAIAIgB0cNAAsLIAMoAggaIAMoAgAhBwsgAyAMNgIIIAMgBjYCBCADIAU2AgAgB0UNACAHECoLIAMgBjYCBCAJKAIEIAkoAgBrIQICQCADKAIIIgUgBksEQCAGIAI6AAAgBkEBaiEEDAELIAYgAygCACIHayIIQQFqIgFBAEgNAyAIQf////8HIAUgB2siBUEBdCIEIAEgASAESRsgBUH/////A08bIgQEfyAEECwFQQALIgVqIgEgAjoAACAEIAVqIQwgAUEBaiEEAkAgBiAHRgRAIAEhBQwBC0EAIQogBiECIAhBA3EiCARAA0AgAUEBayIBIAJBAWsiAi0AADoAACAKQQFqIgogCEcNAAsLIAcgBmtBfE0EQANAIAFBAWsgAkEBay0AADoAACABQQJrIAJBAmstAAA6AAAgAUEDayACQQNrLQAAOgAAIAFBBGsiASACQQRrIgItAAA6AAAgAiAHRw0ACwsgAygCCBogAygCACEHCyADIAw2AgggAyAENgIEIAMgBTYCACAHRQ0AIAcQKgsgAyAENgIEIAMgBCAJKAIAIgEgCSgCBCICIAIgAWsQxQEgCUEMaiIJIA1HDQALCyALKAKMASIJIAsoApABIg1HBEADQCAJKAIEIAkoAgBrQRh2IQICQCADKAIEIgQgAygCCCIFSQRAIAQgAjoAACAEQQFqIQYMAQsgBCADKAIAIgdrIghBAWoiAUEASA0DIAhB/////wcgBSAHayIFQQF0IgYgASABIAZJGyAFQf////8DTxsiBgR/IAYQLAVBAAsiBWoiASACOgAAIAUgBmohDCABQQFqIQYCQCAEIAdGBEAgASEFDAELQQAhCiAEIQIgCEEDcSIIBEADQCABQQFrIgEgAkEBayICLQAAOgAAIApBAWoiCiAIRw0ACwsgByAEa0F8TQRAA0AgAUEBayACQQFrLQAAOgAAIAFBAmsgAkECay0AADoAACABQQNrIAJBA2stAAA6AAAgAUEEayIBIAJBBGsiAi0AADoAACACIAdHDQALCyADKAIIGiADKAIAIQcLIAMgDDYCCCADIAY2AgQgAyAFNgIAIAdFDQAgBxAqCyADIAY2AgQgCSgCBCAJKAIAa0EQdiECAkAgAygCCCIFIAZLBEAgBiACOgAAIAZBAWohBAwBCyAGIAMoAgAiB2siCEEBaiIBQQBIDQMgCEH/////ByAFIAdrIgVBAXQiBCABIAEgBEkbIAVB/////wNPGyIEBH8gBBAsBUEACyIFaiIBIAI6AAAgBCAFaiEMIAFBAWohBAJAIAYgB0YEQCABIQUMAQtBACEKIAYhAiAIQQNxIggEQANAIAFBAWsiASACQQFrIgItAAA6AAAgCkEBaiIKIAhHDQALCyAHIAZrQXxNBEADQCABQQFrIAJBAWstAAA6AAAgAUECayACQQJrLQAAOgAAIAFBA2sgAkEDay0AADoAACABQQRrIgEgAkEEayICLQAAOgAAIAIgB0cNAAsLIAMoAggaIAMoAgAhBwsgAyAMNgIIIAMgBDYCBCADIAU2AgAgB0UNACAHECoLIAMgBDYCBCAJKAIEIAkoAgBrQQh2IQICQCADKAIIIgUgBEsEQCAEIAI6AAAgBEEBaiEGDAELIAQgAygCACIHayIIQQFqIgFBAEgNAyAIQf////8HIAUgB2siBUEBdCIGIAEgASAGSRsgBUH/////A08bIgYEfyAGECwFQQALIgVqIgEgAjoAACAFIAZqIQwgAUEBaiEGAkAgBCAHRgRAIAEhBQwBC0EAIQogBCECIAhBA3EiCARAA0AgAUEBayIBIAJBAWsiAi0AADoAACAKQQFqIgogCEcNAAsLIAcgBGtBfE0EQANAIAFBAWsgAkEBay0AADoAACABQQJrIAJBAmstAAA6AAAgAUEDayACQQNrLQAAOgAAIAFBBGsiASACQQRrIgItAAA6AAAgAiAHRw0ACwsgAygCCBogAygCACEHCyADIAw2AgggAyAGNgIEIAMgBTYCACAHRQ0AIAcQKgsgAyAGNgIEIAkoAgQgCSgCAGshAgJAIAMoAggiBSAGSwRAIAYgAjoAACAGQQFqIQQMAQsgBiADKAIAIgdrIghBAWoiAUEASA0DIAhB/////wcgBSAHayIFQQF0IgQgASABIARJGyAFQf////8DTxsiBAR/IAQQLAVBAAsiBWoiASACOgAAIAQgBWohDCABQQFqIQQCQCAGIAdGBEAgASEFDAELQQAhCiAGIQIgCEEDcSIIBEADQCABQQFrIgEgAkEBayICLQAAOgAAIApBAWoiCiAIRw0ACwsgByAGa0F8TQRAA0AgAUEBayACQQFrLQAAOgAAIAFBAmsgAkECay0AADoAACABQQNrIAJBA2stAAA6AAAgAUEEayIBIAJBBGsiAi0AADoAACACIAdHDQALCyADKAIIGiADKAIAIQcLIAMgDDYCCCADIAQ2AgQgAyAFNgIAIAdFDQAgBxAqCyADIAQ2AgQgAyAEIAkoAgAiASAJKAIEIgIgAiABaxDFASAJQQxqIgkgDUcNAAsLIAsoAoABIgkgCygChAEiCEcEQANAIAkoAgQgCSgCAGtBGHYhAgJAIAMoAgQiBCADKAIIIgVJBEAgBCACOgAAIARBAWohBgwBCyAEIAMoAgAiB2siC0EBaiIBQQBIDQMgC0H/////ByAFIAdrIgVBAXQiBiABIAEgBkkbIAVB/////wNPGyIGBH8gBhAsBUEACyIFaiIBIAI6AAAgBSAGaiENIAFBAWohBgJAIAQgB0YEQCABIQUMAQtBACEKIAQhAiALQQNxIgsEQANAIAFBAWsiASACQQFrIgItAAA6AAAgCkEBaiIKIAtHDQALCyAHIARrQXxNBEADQCABQQFrIAJBAWstAAA6AAAgAUECayACQQJrLQAAOgAAIAFBA2sgAkEDay0AADoAACABQQRrIgEgAkEEayICLQAAOgAAIAIgB0cNAAsLIAMoAggaIAMoAgAhBwsgAyANNgIIIAMgBjYCBCADIAU2AgAgB0UNACAHECoLIAMgBjYCBCAJKAIEIAkoAgBrQRB2IQICQCADKAIIIgUgBksEQCAGIAI6AAAgBkEBaiEEDAELIAYgAygCACIHayILQQFqIgFBAEgNAyALQf////8HIAUgB2siBUEBdCIEIAEgASAESRsgBUH/////A08bIgQEfyAEECwFQQALIgVqIgEgAjoAACAEIAVqIQ0gAUEBaiEEAkAgBiAHRgRAIAEhBQwBC0EAIQogBiECIAtBA3EiCwRAA0AgAUEBayIBIAJBAWsiAi0AADoAACAKQQFqIgogC0cNAAsLIAcgBmtBfE0EQANAIAFBAWsgAkEBay0AADoAACABQQJrIAJBAmstAAA6AAAgAUEDayACQQNrLQAAOgAAIAFBBGsiASACQQRrIgItAAA6AAAgAiAHRw0ACwsgAygCCBogAygCACEHCyADIA02AgggAyAENgIEIAMgBTYCACAHRQ0AIAcQKgsgAyAENgIEIAkoAgQgCSgCAGtBCHYhAgJAIAMoAggiBSAESwRAIAQgAjoAACAEQQFqIQYMAQsgBCADKAIAIgdrIgtBAWoiAUEASA0DIAtB/////wcgBSAHayIFQQF0IgYgASABIAZJGyAFQf////8DTxsiBgR/IAYQLAVBAAsiBWoiASACOgAAIAUgBmohDSABQQFqIQYCQCAEIAdGBEAgASEFDAELQQAhCiAEIQIgC0EDcSILBEADQCABQQFrIgEgAkEBayICLQAAOgAAIApBAWoiCiALRw0ACwsgByAEa0F8TQRAA0AgAUEBayACQQFrLQAAOgAAIAFBAmsgAkECay0AADoAACABQQNrIAJBA2stAAA6AAAgAUEEayIBIAJBBGsiAi0AADoAACACIAdHDQALCyADKAIIGiADKAIAIQcLIAMgDTYCCCADIAY2AgQgAyAFNgIAIAdFDQAgBxAqCyADIAY2AgQgCSgCBCAJKAIAayECAkAgAygCCCIFIAZLBEAgBiACOgAAIAZBAWohBAwBCyAGIAMoAgAiB2siC0EBaiIBQQBIDQMgC0H/////ByAFIAdrIgVBAXQiBCABIAEgBEkbIAVB/////wNPGyIEBH8gBBAsBUEACyIFaiIBIAI6AAAgBCAFaiENIAFBAWohBAJAIAYgB0YEQCABIQUMAQtBACEKIAYhAiALQQNxIgsEQANAIAFBAWsiASACQQFrIgItAAA6AAAgCkEBaiIKIAtHDQALCyAHIAZrQXxNBEADQCABQQFrIAJBAWstAAA6AAAgAUECayACQQJrLQAAOgAAIAFBA2sgAkEDay0AADoAACABQQRrIgEgAkEEayICLQAAOgAAIAIgB0cNAAsLIAMoAggaIAMoAgAhBwsgAyANNgIIIAMgBDYCBCADIAU2AgAgB0UNACAHECoLIAMgBDYCBCADIAQgCSgCACIBIAkoAgQiAiACIAFrEMUBIAlBDGoiCSAIRw0ACwsMAQsQNgALIABBADYCCCAAQgA3AgACQCAOKAIIIgIgDigCBCIBRwRAIAIgAWsiAkEASA0BIAAgAhAsIgU2AgAgACACIAVqIgY2AgggBSABIAIQMhogACAGNgIECyAAQZClBSkCADcCDCAAQRRqIQACQEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLiAOKAIEIQELIAEEQCAOIAE2AgggDigCDBogARAqCyAOQRBqJAAPCxA2AAsJACAAEOoDECoLySMBFH8jAEGgAWsiAyQAIANB5NUDNgJEIANB8NUDKAIAIgQ2AgwgA0EMaiIHIARBDGsoAgBqQfTVAygCADYCACAHIAMoAgxBDGsoAgBqIgUgA0EQaiIEED4gBUKAgICAcDcCSCADQeTVAzYCRCADQdDVAzYCDCAEED8iEEHwywM2AgAgA0IANwI4IANCADcCMCADQRA2AkAgA0GUAWoiBCABIAIQWSAHIAMoApQBIAQgAywAnwEiBUEASCIEGyADKAKYASAFIAQbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBlAFqIgQgAhA1IANBDGogAygClAEgBCADLACfASIFQQBIIgQbIAMoApgBIAUgBBsQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgA0EMakGeuQFBFxAtIAEtAGQQQkHPkAJBARAtIQcgA0GUAWoiBCACEDUgByADKAKUASAEIAMsAJ8BIgVBAEgiBBsgAygCmAEgBSAEGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyAHQYe5AUEWEC0gAS0AZRBCQZKkAUECEC0hEwJAAn8CQAJ/AkACQAJAAkACQAJAAkACQCABLQBlIgRBwgBrDjkJBwcHBwcHBwcHBwEHBwcHBwcHBwcHAgcHBwcHBwcHBwcHAwcHBwcHBwcHBwQHBwcHBwcHBwcHBwUACyAEQfQBRg0FIARBLEcNBiADQRAQLCIENgIAIANCi4CAgICCgICAfzcCBCAEQfKKASkAADcAACAEQfmKASgAADYAByAEQQtqDAkLIANBzcKl8wY2AgAgA0EEOgALQQQMBgsgA0LF8NGr5o3ZsuQANwMAIANBCDoAC0EIDAULIANBEBAsIgQ2AgAgA0KMgICAgIKAgIB/NwIEIARBzRopAAA3AAAgBEHVGigAADYACCAEQQxqDAYLIANBBzoACyADQaGPASgAADYCACADQaSPASgAADYAA0EHDAMLIANBjYwBLwAAOwEIIANBCjoACyADQYWMASkAADcDAEEKDAILIANB74oBLwAAOwEIIANBCjoACyADQeeKASkAADcDAEEKDAELIANBBzoACyADQbczKAAANgIAIANBujMoAAA2AANBBwsiCCADakEAOgAAIAMhBAwCCyADQRgQLCIENgIAIANClICAgICDgICAfzcCBCAEQYrSACkAADcAACAEQZrSACgAADYAECAEQZLSACkAADcACCAEQRRqC0EAOgAAIAMoAgQhCAsgEyAEIAgQLUHOkAJBAhAtIQcgA0GUAWoiBCACEDUgByADKAKUASAEIAMsAJ8BIgVBAEgiBBsgAygCmAEgBSAEGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyAHQdOwAUEXEC0gAS0AZhBCQc+QAkEBEC0hByADQZQBaiIEIAIQNSAHIAMoApQBIAQgAywAnwEiBUEASCIEGyADKAKYASAFIAQbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIAdB8rgBQRQQLSABLQBnEEJBz5ACQQEQLSEHIANBlAFqIgQgAhA1IAcgAygClAEgBCADLACfASIFQQBIIgQbIAMoApgBIAUgBBsQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgB0HgswFBDxAtGiADLAALQQBIBEAgAygCCBogAygCABAqCwJAAkACQAJAAkACQCABKAJsDgQAAQIDBAsgA0EMakHaigJBBhAtGgwECyADQQxqQdOKAkEGEC0aDAMLIANBDGpBzIoCQQYQLRoMAgsgA0EMakHFigJBBhAtGgwBCyADQQxqQcbJAUEMEC0aCyADQZQBaiIEIAIQNSADQQxqIAMoApQBIAQgAywAnwEiBUEASCIEGyADKAKYASAFIAQbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBDGpBnMIBQRAQLSABLQBwEEJBz5ACQQEQLSEHIANBlAFqIgQgAhA1IAcgAygClAEgBCADLACfASIFQQBIIgQbIAMoApgBIAUgBBsQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgB0HAwgFBEhAtIAEtAHEQQkHPkAJBARAtGgJAIAEoAnQiDSABKAJ4IglHBEAgA0EYaiERA0AgA0GUAWoiBCACEDUgA0EMaiADKAKUASAEIAMsAJ8BIgVBAEgiBBsgAygCmAEgBSAEGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyADQQxqQfLCAUEFEC0aAkAgDSgCACIEIA0oAgQiEkYNAANAIAQtAAAhByADKAIMIghBDGsoAgAgA0EMamoiBigCTEF/RgRAIANBlAFqIg4gBigCHCIFNgIAIAVB7M4GRwRAIAUgBSgCBEEBajYCBAsgDkGk0AYQQyIFQSAgBSgCACgCHBEFABogDhBHIAMoAgwhCAsgBkEwNgJMIBEgCEEMayIFKAIAakECNgIAIBAgBSgCAGoiBSAFKAIAQbV/cUEIcjYCAAJAAkAgAyADQQxqIAcQQiILEHMiDi0AAEEBRw0AIAsgCygCAEEMaygCAGoiCigCBCEHIAooAhghDCAKKAJMIghBf0YEQCADQZQBaiIGIAooAhwiBTYCACAFQezOBkcEQCAFIAUoAgRBAWo2AgQLIAZBpNAGEEMiBUEgIAUoAgAoAhwRBQAhCCAGEEcgCiAINgJMCwJAIAxFDQAgCigCDCEGQerEAUHpxAEgB0GwAXFBIEYbIgdB6cQBayIFQQBKBEAgDEHpxAEgBSAMKAIAKAIwEQQAIAVHDQELIAZBAWtBACAGQQFKGyIGQQBKBEAgBkH4////B08NAwJAIAZBC08EQCAGQQdyQQFqIgUQLCEPIAMgBUGAgICAeHI2ApwBIAMgDzYClAEgAyAGNgKYAQwBCyADIAY6AJ8BIANBlAFqIQ8LIA8gCCAGEDQgBmpBADoAACAMIAMoApQBIANBlAFqIAMsAJ8BQQBIGyAGIAwoAgAoAjARBAAhFCADLACfAUEASARAIAMoApwBGiADKAKUARAqCyAUIAZHDQELQerEASAHayIFQQBKBEAgDCAHIAUgDCgCACgCMBEEACAFRw0BCyAKQQA2AgwMAQsgCyALKAIAQQxrKAIAaiIFIAUoAhBBBXIQegsgDhByIARBAWoiBCASRg0CDAELCwwDCyADQQxqQc+QAkEBEC0aIBAgAygCDEEMaygCAGoiBCAEKAIAQbV/cUECcjYCACANQQxqIg0gCUcNAAsLIAEoAowBIg0gASgCkAEiCUcEQCADQRhqIREDQCADQZQBaiIEIAIQNSADQQxqIAMoApQBIAQgAywAnwEiBUEASCIEGyADKAKYASAFIAQbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBDGpB6MIBQQkQLRoCQCANKAIAIgQgDSgCBCISRg0AA0AgBC0AACEHIAMoAgwiCEEMaygCACADQQxqaiIGKAJMQX9GBEAgA0GUAWoiDiAGKAIcIgU2AgAgBUHszgZHBEAgBSAFKAIEQQFqNgIECyAOQaTQBhBDIgVBICAFKAIAKAIcEQUAGiAOEEcgAygCDCEICyAGQTA2AkwgESAIQQxrIgUoAgBqQQI2AgAgECAFKAIAaiIFIAUoAgBBtX9xQQhyNgIAAkACQCADIANBDGogBxBCIgsQcyIOLQAAQQFHDQAgCyALKAIAQQxrKAIAaiIKKAIEIQcgCigCGCEMIAooAkwiCEF/RgRAIANBlAFqIgYgCigCHCIFNgIAIAVB7M4GRwRAIAUgBSgCBEEBajYCBAsgBkGk0AYQQyIFQSAgBSgCACgCHBEFACEIIAYQRyAKIAg2AkwLAkAgDEUNACAKKAIMIQZB6sQBQenEASAHQbABcUEgRhsiB0HpxAFrIgVBAEoEQCAMQenEASAFIAwoAgAoAjARBAAgBUcNAQsgBkEBa0EAIAZBAUobIgZBAEoEQCAGQfj///8HTw0DAkAgBkELTwRAIAZBB3JBAWoiBRAsIQ8gAyAFQYCAgIB4cjYCnAEgAyAPNgKUASADIAY2ApgBDAELIAMgBjoAnwEgA0GUAWohDwsgDyAIIAYQNCAGakEAOgAAIAwgAygClAEgA0GUAWogAywAnwFBAEgbIAYgDCgCACgCMBEEACEVIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIBUgBkcNAQtB6sQBIAdrIgVBAEoEQCAMIAcgBSAMKAIAKAIwEQQAIAVHDQELIApBADYCDAwBCyALIAsoAgBBDGsoAgBqIgUgBSgCEEEFchB6CyAOEHIgBEEBaiIEIBJGDQIMAQsLDAMLIANBDGpBz5ACQQEQLRogECADKAIMQQxrKAIAaiIEIAQoAgBBtX9xQQJyNgIAIA1BDGoiDSAJRw0ACwsgASgCgAEiDSABKAKEASIRRwRAIANBGGohEgNAIANBlAFqIgEgAhA1IANBDGogAygClAEgASADLACfASIEQQBIIgEbIAMoApgBIAQgARsQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgA0EMakH4wgFBBRAtGgJAIA0oAgAiBCANKAIEIg5GDQADQCAELQAAIQUgAygCDCIIQQxrKAIAIANBDGpqIgkoAkxBf0YEQCADQZQBaiIHIAkoAhwiATYCACABQezOBkcEQCABIAEoAgRBAWo2AgQLIAdBpNAGEEMiAUEgIAEoAgAoAhwRBQAaIAcQRyADKAIMIQgLIAlBMDYCTCASIAhBDGsiASgCAGpBAjYCACAQIAEoAgBqIgEgASgCAEG1f3FBCHI2AgACQAJAIAMgA0EMaiAFEEIiBhBzIgctAABBAUcNACAGIAYoAgBBDGsoAgBqIgsoAgQhBSALKAIYIQogCygCTCIIQX9GBEAgA0GUAWoiCSALKAIcIgE2AgAgAUHszgZHBEAgASABKAIEQQFqNgIECyAJQaTQBhBDIgFBICABKAIAKAIcEQUAIQggCRBHIAsgCDYCTAsCQCAKRQ0AIAsoAgwhCUHqxAFB6cQBIAVBsAFxQSBGGyIFQenEAWsiAUEASgRAIApB6cQBIAEgCigCACgCMBEEACABRw0BCyAJQQFrQQAgCUEBShsiCUEASgRAIAlB+P///wdPDQMCQCAJQQtPBEAgCUEHckEBaiIBECwhDyADIAFBgICAgHhyNgKcASADIA82ApQBIAMgCTYCmAEMAQsgAyAJOgCfASADQZQBaiEPCyAPIAggCRA0IAlqQQA6AAAgCiADKAKUASADQZQBaiADLACfAUEASBsgCSAKKAIAKAIwEQQAIRYgAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgFiAJRw0BC0HqxAEgBWsiAUEASgRAIAogBSABIAooAgAoAjARBAAgAUcNAQsgC0EANgIMDAELIAYgBigCAEEMaygCAGoiASABKAIQQQVyEHoLIAcQciAEQQFqIgQgDkYNAgwBCwsMAwsgA0EMakHPkAJBARAtGiAQIAMoAgxBDGsoAgBqIgEgASgCAEG1f3FBAnI2AgAgDUEMaiINIBFHDQALCwJAAkACfyADKAJAIgFBEHEEQCADQSRqIQggAygCPCIBIAMoAigiAkkEfyADIAI2AjwgAgUgAQsMAQsgAUEIcUUEQEEAIQQgAEEAOgALDAMLIANBGGohCCADKAIgCyAIKAIAIgVrIgRB+P///wdJBEAgBEELTwRAIARBB3JBAWoiAhAsIQEgACACQYCAgIB4cjYCCCAAIAE2AgAgACAENgIEIAEhAAwCCyAAIAQ6AAsgBA0BQQAhBAwCCxA4AAsgACAFIAQQNxoLIAAgBGpBADoAACADQezVAygCACIANgIMIABBDGsoAgAgA0EMampB+NUDKAIANgIAIBBB8MsDNgIAIAMsADtBAEgEQCADKAI4GiADKAIwECoLIBAQPRogA0HEAGoQOxogA0GgAWokAA8LEDgAC5YLAQV/IwBBIGsiAyQAIAEgAkEAIAEoAgAoAiwRBAAhByACIAEtAGQQSCACIAEtAGUQSCACIAEtAGYQSCACIAEtAGcQSCACIAEtAGhBAWtB/AFyQf8BcRBIAkAgASgCeCABKAJ0a0EMbSIEQSBPBEAgA0EwECwiATYCFCADQqyAgICAhoCAgH83AhggAUG8kwEpAAA3AAAgAUEAOgAsIAFB5JMBKAAANgAoIAFB3JMBKQAANwAgIAFB1JMBKQAANwAYIAFBzJMBKQAANwAQIAFBxJMBKQAANwAIIABBCUEAIANBFGoQLxogAywAH0EATg0BIAMoAhwaIAMoAhQQKgwBCyACIARB4AFyQf8BcRBIIAEoAnQiBCABKAJ4IgVHBEADQCAEKAIEIAQoAgBrIgZBgIAETwRAIANBOBAsIgE2AhQgA0K3gICAgIeAgIB/NwIYIAFBnpIBKQAANwAAIAFBADoANyABQc2SASkAADcALyABQcaSASkAADcAKCABQb6SASkAADcAICABQbaSASkAADcAGCABQa6SASkAADcAECABQaaSASkAADcACCAAQQlBACADQRRqEC8aIAMsAB9BAE4NAyADKAIcGiADKAIUECoMAwsgAiAGQf//A3EQTSACIAQQlAEgBEEMaiIEIAVHDQALCyABKAKEASABKAKAAWtBDG0iBEGAAk8EQCADQTAQLCIBNgIUIANCrYCAgICGgICAfzcCGCABQY6TASkAADcAACABQQA6AC0gAUGzkwEpAAA3ACUgAUGukwEpAAA3ACAgAUGmkwEpAAA3ABggAUGekwEpAAA3ABAgAUGWkwEpAAA3AAggAEEJQQAgA0EUahAvGiADLAAfQQBODQEgAygCHBogAygCFBAqDAELIAIgBEH/AXEQSCABKAKAASIEIAEoAoQBIgVHBEADQCAEKAIEIAQoAgBrIgZBgIAETwRAIANBOBAsIgE2AhQgA0K3gICAgIeAgIB/NwIYIAFB1pIBKQAANwAAIAFBADoANyABQYWTASkAADcALyABQf6SASkAADcAKCABQfaSASkAADcAICABQe6SASkAADcAGCABQeaSASkAADcAECABQd6SASkAADcACCAAQQlBACADQRRqEC8aIAMsAB9BAE4NAyADKAIcGiADKAIUECoMAwsgAiAGQf//A3EQTSACIAQQlAEgBEEMaiIEIAVHDQALCwJAIAEtAGVBwgBrIgRBFk1BAEEBIAR0QYGQgAJxGw0AIAIgAS0AbBBIIAIgAS0AcEEIa0H/AXEQSCACIAEtAHFBCGtB/wFxEEggASgCkAEgASgCjAFrQQxtIgRBgAJPBEAgAEEJQQAgA0EUakGwkQEQgAEiABAvGiAALAALQQBODQIgACgCCBogACgCABAqDAILIAIgBEH/AXEQSCABKAKMASIEIAEoApABIgVGDQADQCAEKAIEIAQoAgBrIgZBgIAETwRAIANBwAAQLCIBNgIUIANCu4CAgICIgICAfzcCGCABQeKRASkAADcAACABQQA6ADsgAUGZkgEoAAA2ADcgAUGSkgEpAAA3ADAgAUGKkgEpAAA3ACggAUGCkgEpAAA3ACAgAUH6kQEpAAA3ABggAUHykQEpAAA3ABAgAUHqkQEpAAA3AAggAEEJQQAgA0EUahAvGiADLAAfQQBODQMgAygCHBogAygCFBAqDAMLIAIgBkH//wNxEE0gAiAEEJQBIARBDGoiBCAFRw0ACwsgAyABIAIgBxCbASADLAATQQBIBEAgAygCEBogAygCCBAqCyAAQZClBSkCADcCACAAQQhqIQBBo6UFLAAAQQBOBEAgAEGYpQUpAgA3AgAgAEGgpQUoAgA2AggMAQsgAEGYpQUoAgBBnKUFKAIAEC4LIANBIGokAAuGCQEI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ADoAECADQQA6ABsgAEECQYMBIANBEGoQLxogAywAG0EATg0CIAMoAhgaIAMoAhAQKgwCCyACQgA3AhAgAkIANwIcIAJBADYCMCACIAU2AiwgAkEAOgAYIAJCADcCJCACQbCCBTYCDAsgASAGNgL0AiABKAL4AiEFIAEgAjYC+AICQCAFRQ0AIAUgBSgCBCICQQFrNgIEIAINACAFIAUoAgAoAggRAAAgBRArCyADQQA6ABggA0IANwIkIANCADcDECADQgA3AhwgAyABKAIUIgIoAjA2AgggAyACKAI0IgI2AgwgAgRAIAIgAigCBEEBajYCBAsgASgCJCECIAMgAykCCDcDACADQRBqIAMgAhDSASABKAL0AiEBIAMoAhQhBSADQQA2AhQgAygCECECIANBADYCECADKAIkIQYgA0EANgIkIAMoAiAhByADQQA2AiAgAygCHCEIIANBADYCHCADLQAYIQkgAygCKCEKIAEgAjYCBCABKAIIIQIgASAFNgIIAkAgAkUNACACIAIoAgQiBUEBazYCBCAFDQAgAiACKAIAKAIIEQAAIAIQKwsgASAJOgAMIAEoAhAiAgRAIAEgAjYCFCABKAIYGiACECoLIAEgCjYCHCABIAY2AhggASAHNgIUIAEgCDYCECAAQZClBSkCADcCACAAQQhqIQACQEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgAygCHCIABEAgAyAANgIgIAMoAiQaIAAQKgsCQCADKAIUIgBFDQAgACAAKAIEIgFBAWs2AgQgAQ0AIAAgACgCACgCCBEAACAAECsLIARFDQAgBCAEKAIEIgBBAWs2AgQgAA0AIAQgBCgCACgCCBEAACAEECsLIANBMGokAAsJACAAEOwDECoLmh8BEH8jAEHAAWsiAyQAIANB5NUDNgJcIANB8NUDKAIAIgU2AiQgA0EkaiILIAVBDGsoAgBqQfTVAygCADYCACALIAMoAiRBDGsoAgBqIgUgA0EoaiIEED4gBUKAgICAcDcCSCADQeTVAzYCXCADQdDVAzYCJCAEED8iDUHwywM2AgAgA0IANwJQIANCADcCSCADQRA2AlggA0G0AWoiCiEEIwBBoAFrIgYkACAGQeTVAzYCRCAGQfDVAygCACIF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ayICQfj///8HSQRAIAJBC08EQCACQQdyQQFqIgQQLCEBIAAgBEGAgICAeHI2AgggACABNgIAIAAgAjYCBCABIQAMAgsgACACOgALIAINAUEAIQIMAgsQOAALIAAgBSACEDcaCyAAIAJqQQA6AAAgA0Hs1QMoAgAiADYCJCAAQQxrKAIAIANBJGpqQfjVAygCADYCACANQfDLAzYCACADLABTQQBIBEAgAygCUBogAygCSBAqCyANED0aIANB3ABqEDsaIANBwAFqJAALswoBDH8jAEEgayIEJAAgASACQQAgASgCACgCLBEEACEKIAIgAS0AaSABLQBoQQF0QQZxckH4AXIQSCABLQBpQQFGBEAgAiABLQBuIAEtAGxBBHQgAS8BakEHdHIgAS0AbUECdHJyQf//A3EQTSACIAEtAG9BBXRBH3JB/wFxEEggAiABLQBwQT9xEEggAiABLQByIAEtAHFBAXRB/gFxchBIIAIgAS0AcxBIAkAgAS0AcEUNACACIAEoAngtAAAgAS0AdUEGdCABLQB0QQd0cnJB/wFxEEhBASEDIAEtAHBBAU0NAANAIAIgASgCeCADai0AABBIIANBAWoiAyABLQBwSQ0ACwsCQCABLQBsIgNBAU0NACADQQFrIgVBAXEhDSABKAKEASEHAkAgA0ECayIDRQRAQYABIQZBACEFDAELIAVBfnEhC0GAASEGQQAhBQNAQQAgByADQQFrIglBA3ZB/P///wFxaigCACAJdkEBcWsgBkH/AXEiCUEBdnFBACAHIANBA3ZB/P///wFxaigCACADdkEBcWsgBnEgBXJyIQUgA0ECayEDIAlBAnYhBiAMQQJqIgwgC0cNAAsLIA1FDQBBACAHIANBA3ZB/P///wFxaigCACADdkEBcWsgBnEgBXIhBQsgAiAFQf8BcRBIIAEtAGwiA0ECTwRAIANBAmshAwNAIAEoAoQBIANBA3ZB/P///wFxaigCACADdkEBcQRAIAIgASgCkAEgA2otAAAQSAsgA0EASiEOIANBAWshAyAODQALCyACIAEoAqABIAEoApwBa0ECdkH/AXEiBRBIIAUEQEEAIQMDQCACIAEoApwBIANBAnRqKAIAEEogA0EBaiIDIAVHDQALCyACIAEvAagBEE0gAiABLwGqARBNIAIgAS8BrAEQTQsCQCABKAK0ASAB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QgA3AiQgA0IANwMQIANCADcCHCADIAEoAhQiAigCMDYCCCADIAIoAjQiAjYCDCACBEAgAiACKAIEQQFqNgIECyABKAIkIQIgAyADKQIINwMAIANBEGogAyACENIBIAEoAvQCIQEgAygCFCEFIANBADYCFCADKAIQIQIgA0EANgIQIAMoAiQhBiADQQA2AiQgAygCICEHIANBADYCICADKAIcIQggA0EANgIcIAMtABghCSADKAIoIQogASACNgIEIAEoAgghAiABIAU2AggCQCACRQ0AIAIgAigCBCIFQQFrNgIEIAUNACACIAIoAgAoAggRAAAgAhArCyABIAk6AAwgASgCECICBEAgASACNgIUIAEoAhgaIAIQKgsgASAKNgIcIAEgBjYCGCABIAc2AhQgASAINgIQIABBkKUFKQIANwIAIABBCGohAAJAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyADKAIcIgAEQCADIAA2AiAgAygCJBogABAqCwJAIAMoAhQiAEUNACAAIAAoAgQiAUEBazYCBCABDQAgACAAKAIAKAIIEQAAIAAQKwsgBEUNACAEIAQoAgQiAEEBazYCBCAADQAgBCAEKAIAKAIIEQAAIAQQKwsgA0EwaiQAC8EFAQV/IwBBMGsiAiQAAkACQAJAAkACQAJAIAEoAhgiAyABKAIcIgFHBEADQAJAIAMoAgAiBEUNACAEQaC/BEHMgAUQOSIERQ0AIAMoAgQiAwRAIAMgAygCBEEBajYCBAsgAkEANgIUIAJCADcCDCAEIAJBDGoQ7QMNBSACQQA6AAAgAkEAOgALIAJBGGpBAkH1ACACEC8hASAAQQA2AgggAEIANwIAIAAgASkDADcCDCAAQRRqIQAgASwAE0EASA0DIAAgASkCCDcCACAAIAEoAhA2AggMBAsgA0EIaiIDIAFHDQALCyACQQA6AAwgAkEAOgAXIAJBGGpBAkGNASACQQxqEC8hASAAQQA2AgggAEIANwIAIAAgASkDADcCDCAAQRRqIQACQCABLAATQQBOBEAgACABKQIINwIAIAAgASgCEDYCCAwBCyAAIAEoAgggASgCDBAuIAEsABNBAE4NACABKAIQGiABKAIIECoLIAIsABdBAE4NBCACKAIUGiACKAIMECoMBAsgACABKAIIIAEoAgwQLiABLAATQQBODQAgASgCEBogASgCCBAqCyACLAALQQBODQEgAigCCBogAigCABAqDAELIABBADYCCCAAQgA3AgAgAigCECIBIAIoAgwiBUcEQCABIAVrIgFBAEgNAyAAIAEQLCIENgIEIAAgBDYCACAAIAEgBGoiBjYCCCAEIAUgARAyGiAAIAY2AgQLIABBkKUFKQIANwIMIABBFGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgAigCDCIABEAgAiAANgIQIAIoAhQaIAAQKgsgA0UNACADIAMoAgQiAEEBazYCBCAADQAgAyADKAIAKAIIEQAAIAMQKwsgAkEwaiQADwsQNgAL7wkBBn8jAEGgAWsiAyQAIANB5NUDNgJEIANB8NUDKAIAIgY2AgwgA0EMaiIFIAZBDGsoAgBqQfTVAygCADYCACAFIAMoAgxBDGsoAgBqIgYgA0EQaiIEED4gBkKAgICAcDcCSCADQeTVAzYCRCADQdDVAzYCDCAEED8iBkHwywM2AgAgA0IANwI4IANCADcCMCADQRA2AkAgA0GUAWoiBCABIAIQrAIgBSADKAKUASAEIAMsAJ8BIgVBAEgiBBsgAygCmAEgBSAEGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyADQZQBaiIFIAIQNSADQQxqIAMoApQBIAUgAywAnwEiBUEASCIEGyADKAKYASAFIAQbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBDGpB18ABQQ0QLSEIIAMgASgCZBCkASAIIAMoAgAgAyADLAALIgVBAEgiBBsgAygCBCAFIAQbEC1Bz5ACQQEQLSEFIANBlAFqIgQgAhA1IAUgAygClAEgBCADLACfASIEQQBIIgcbIAMoApgBIAQgBxsQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgBUG2uQFBDxAtGiADLAALQQBIBEAgAygCCBogAygCABAqCwJAIAEoAmgiBUH///+HBE0EQCADQQxqIAUQPBoMAQsgA0GUAWoiBCAFEKQBIANBDGogAygClAEgBCADLACfASIFQQBIIgQbIAMoApgBIAUgBBsQLRogAywAnwFBAE4NACADKAKcARogAygClAEQKgsgA0EMakHPkAJBARAtIQUgA0GUAWoiBCACEDUgBSADKAKUASAEIAMsAJ8BIgJBAEgiBBsgAygCmAEgAiAEGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyAFQYq3AUETEC0aAkAgASgCbCICIAEoAnAiBUYNACADQZQBaiIBIAIoAgAQpAEgA0EMaiADKAKUASABIAMsAJ8BIgFBAEgiBBsgAygCmAEgASAEGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyACQQRqIgEgBUYNAANAIAEoAgAhBCADQSw6AJQBIANBDGoiByADQZQBaiICQQEQLRogAiAEEKQBIAcgAygClAEgAiADLACfASICQQBIIgQbIAMoApgBIAIgBBsQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgAUEEaiIBIAVHDQALCyADQQxqQc+QAkEBEC0aAkACfyADKAJAIgFBEHEEQCADKAI8IgEgAygCKCICSQRAIAMgAjYCPCACIQELIANBJGoMAQsgAUEIcUUEQEEAIQEgAEEAOgALDAILIAMoAiAhASADQRhqCyECAkAgASACKAIAIgVrIgFB+P///wdJBEAgAUELTwRAIAFBB3JBAWoiBBAsIQIgACAEQYCAgIB4cjYCCCAAIAI2AgAgACABNgIEIAIhAAwCCyAAIAE6AAsgAQ0BQQAhAQwCCxA4AAsgACAFIAEQNxoLIAAgAWpBADoAACADQezVAygCACIANgIMIABBDGsoAgAgA0EMampB+NUDKAIANgIAIAZB8MsDNgIAIAMsADtBAEgEQCADKAI4GiADKAIwECoLIAYQPRogA0HEAGoQOxogA0GgAWokAAv+JQESfyMAQbABayIBJAAgAUIANwOoASABQgA3A6ABIAFCADcDmAEgAUIANwOQAUHQARAsIgtB4NgENgIAIAtCADcCBCALQRBqIgxCADcDCCAMQgA3AxAgDEIANwMYIAxBADYCICAMQdS9BDYCACALQgA3AjwgC0IANwI0IAtCfzcDSCALQn83A1AgC0EANgJ0IAtCADcDWCALQgA3A2AgC0IANwNoIAtBADsBcCAMQZiABTYCACALQgA3A4gBIAtBgwI7AXggC0IANwOQASALQgA3A5gBIAtCADcDoAEgC0IANwOoASALQgA3A7ABIAtBADYCyAEgC0IANwLAASALQcPG2bMHNgIgIAEgCzYCHCABIAw2AhggCyALKAIEQQFqNgIEIAEgAUGQAWogAUEYahBTNgKUAQJAIAEoAhwiBEUNACAEIAQoAgQiBkEBazYCBCAGDQAgBCAEKAIAKAIIEQAAIAQQKwsgAUEANgKMASACKAIAIQYCQCACKAIEIgRFBEAgAUEANgKMASABIAY2AogBDAELIAQgBCgCBEEBajYCBCABIAY2AogBIAEoAowBIQIgASAENgKMASACRQ0AIAIgAigCBCIEQQFrNgIEIAQNACACIAIoAgAoAggRAAAgAhArCyABQfwAaiADKAIEIAFBiAFqIAUgAygCACgCZBEGAAJAAkAgASgCfCIEBEAgASgCgAEhBSABKAKEASIGEFgiAkH4////B08NAgJAAkAgAkELTwRAIAJBB3JBAWoiCBAsIQMgASAIQYCAgIB4cjYCeCABIAM2AnAgASACNgJ0DAELIAEgAjoAeyABQfAAaiEDIAJFDQELIAMgBiACEDcaCyACIANqQQA6AAAgAUEYaiAEIAUgAUHwAGoQLyECIABCADcCGCAAQgA3AhAgAEIANwIIIABCADcCACAAIAIpAwA3AiAgAEEoaiEAAkAgAiwAE0EATgRAIAAgAikCCDcCACAAIAIoAhA2AggMAQsgACACKAIIIAIoAgwQLiACLAATQQBODQAgAigCEBogAigCCBAqCyABLAB7QQBODQEgASgCeBogASgCcBAqDAELIAFBADYCcCABQQA2AmwgAUEYaiADKAIEIAFB6ABqIAFB5ABqQQAgAygCACgCaBEHACABKAJoIgIEQANAAkACQCABKAJkIgVBAkgNAAJAAkAgAi0AAUEDdkEOaw4DAQABAgsgAUGDAjsBGCABQgA3AlAgAUIANwJIIAFCADcCQCABQgA3AjggAUIANwIwIAFCADcCKCABQQRqIRIgAiEQIAFBGGohCUEAIQZBACEEQQAhCEEAIQcjAEHQAGsiCiQAIApBADYCTCAKQgA3AkQCQAJAAkACQAJAAkACQCAFIhMEQANAAkACQCAHQQJqIgIgE08NACAHIBBqIgUtAAANACAFLQABDQAgAiAQai0AAEEDRw0AAkAgBiAISwRAIAhBADoAACAI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aiEFAkAgB0EIEEUiBCAJKAI4IAkoAjQiBmtBAnUiAksEQCAFIAQgAmsQqgEMAQsgAiAETQ0AIAkgBiAEQQJ0ajYCOAtBACECIARBAEwNAANAIAdBIBBFIQYgBSgCACACQQJ0aiAGNgIAIAJBAWoiAiAERw0ACwsgB0EBEFQgB0EBEEUEQCAHQQEQVAsgByAKQRxqEHkaIAcgCkEYahB5GiABIAooAhwiAjYCcCABIAooAhgiBDYCbAJAIARBgIAESCACQf//A0xxRQRAIApBOBAsIgI2AgwgCkK3gICAgIeAgIB/NwIQIAJBuJ8BKQAANwAAIAJBADoANyACQeefASkAADcALyACQeCfASkAADcAKCACQdifASkAADcAICACQdCfASkAADcAGCACQcifASkAADcAECACQcCfASkAADcACCASQQlB1g8gCkEMahAvGiAKLAAXQQBODQEgCigCFBogCigCDBAqDAELIAkgBDsBQiAJIAI7AUAgB0EBEEUEQCAHIApBDGoQeRogByAKQQhqEHkaIAcgCkEEahB5GiAHIAoQeRoLIAdBARBFGiAHIApBCGoQeRogCigCCCICQfgBTgRAIApBIBAsIgI2AgwgCkKbgICAgISAgIB/NwIQIAJBz5kBKQAANwAAIAJBADoAGyACQeaZASgAADYAFyACQd+ZASkAADcAECACQdeZASkAADcACCASQQlBACAKQQxqEC8aIAosABdBAE4NASAKKAIUGiAKKAIMECoMAQsgCUEBOgAFIAkgAjoAByASQZClBSkCADcCACASQQhqIQJBo6UFLAAAQQBOBEAgAkGYpQUpAgA3AgAgAkGgpQUoAgA2AggMAQsgAkGYpQUoAgBBnKUFKAIAEC4LIAooAkQiAgRAIAogAjYCSCAKKAJMGiACECoLIApB0ABqJAAMAgsgCiAINgJICyAKIAQ2AkQgCiAGNgJMEDYACyABLAAXQQBIBEAgASgCFBogASgCDBAqCyAMIAFBGGoiAikCADcDaCAMIAIoAgg2AnAgDCACLwEMOwF0AkAgAiAMQegAakYEQCAMQYQBaiACQRxqEO8DDAELIAxB+ABqIAIoAhAiBCACKAIUIgUgBSAEaxCpASAMQYQBaiACQRxqEO8DIAxBkAFqIAIoAigiBCACKAIsIgUgBSAEaxCpASAMQZwBaiACKAI0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AUKAgICAcDcCSCADQczTAygCACIBNgIIIANBCGoiBiABQQxrKAIAakHQ0wMoAgA2AgAgA0HA0wMoAgAiATYCACADIAFBDGsoAgBqQdTTAygCADYCACADQbTTAzYCQCADQYzTAzYCACADQaDTAzYCCCAEED8iAUHwywM2AgAgA0IANwI0IANCADcCLCADQRg2AjwgBkGXrgFBGRAtIAUQPEGWpgFBLBAtIAIoAhBBBW4QPEG6JEEPEC0aAn8gAygCPCICQRBxBEAgA0EgaiEEIAMoAjgiBSADKAIkIgJJBH8gAyACNgI4IAIFIAULDAELIAJBCHFFBEBBACECIANBADoAnwEgA0GUAWohBAwGCyADQRRqIQQgAygCHAsgBCgCACIFayICQfj///8HTw0BIAJBC08EQCACQQdyQQFqIgYQLCEEIAMgBkGAgICAeHI2ApwBIAMgBDYClAEgAyACNgKYAQwECyADIAI6AJ8BIANBlAFqIQQgAg0DQQAhAgwECyABQegAaiEGAkAgASgCbCABKAJoIgdrQQZtIgQgBUkEQCAGIAUgBGsQ8QMMAQsgBCAFTQ0AIAEgByAFQQZsajYCbAsgBUUNAUEAIQQDQCACLQAUDQIgAigCEEUNAiACEE4hCCACEFIhCSACEE4hCiAGKAIAIARBBmxqIgcgCjsBBCAHIAk6AAIgByAIOwEAIARBAWoiBCAFRw0ACwwBCxA4AAsCQCACLQAUQQFGBEAgA0EAOgCUASADQQA6AJ8BIANBAkHkACADQZQBahAvGiADLACfAUEATg0BIAMoApwBGiADKAKUARAqDAELIANBkKUFKQIANwMAIANBCGohBEGjpQUsAABBAE4EQCAEQZilBSkCADcCACAEQaClBSgCADYCCAwBCyAEQZilBSgCAEGcpQUoAgAQLgsgAygCACELIAMsABNBAEgEQCADKAIQGiADKAIIECoLIAsEQCABIAEoAmg2AmwLIAItABRBAUYEQCADQQA6AAAgA0EAOgALIABBAkHkACADEC8aIAMsAAtBAE4NAyADKAIIGiADKAIAECoMAwsgAEGQpQUpAgA3AgAgAEEIaiEAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAMLIABBmKUFKAIAQZylBSgCABAuDAILIAQgBSACEDcaCyACIARqQQA6AAAgAEECQeQAIANBlAFqEC8aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBvNMDKAIAIgA2AgAgAyAAQQxrKAIAakHc0wMoAgA2AgAgA0Hg0wMoAgA2AgggAUHwywM2AgAgAywAN0EASARAIAMoAjQaIAMoAiwQKgsgARA9GiADQUBrEDsaCyADQaABaiQAC5cEAQh/IwBBIGsiBCQAAkACQAJAIAEoAmggASgCZGtB/wFxRQRAIABBkKUFKQIANwIAIABBCGohAEGjpQUsAABBAEgNASAAQZilBSkCADcCACAAQaClBSgCADYCCAwDCyABIAJBACABKAIAKAIsEQQAIQggAiABKAJ0IAEoAnBrQQxtQf8BcRBNIAIgASgCaCABKAJka0H/AXEQSCABKAJkIgMgASgCaCIFRwRAA0AgAiADLQAAEEggA0EBaiIDIAVHDQALCyABKAJwIgUgASgCdCIJRg0BA0AgBEEANgIcIARCADcCFCAFKAIEIgMgBSgCACIGRiIHRQRAAkAgAyAGayIDQQBOBEAgAxAsIAYgAxAyIQYgBw0BQQEgA0EBdiIDIANBAU0bIQpBACEDA0AgBiADQQF0ai8BACEHAkAgASgCZCADai0AAEEITQRAIAIgB0H/AXEQSAwBCyACIAcQTQsgA0EBaiIDIApHDQALDAELEDYACyAGECoLIAVBDGoiBSAJRw0ACwwBCyAAQZilBSgCAEGcpQUoAgAQLgwBCyAEIAEgAiAIEJsBIAQsABNBAEgEQCAEKAIQGiAEKAIIECoLIABBkKUFKQIANwIAIABBCGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgBEEgaiQAC/EFAQR/IwBBoAFrIgMkACADQeTVAzYCRCADQfDVAygCACIGNgIMIANBDGoiBCAGQQxrKAIAakH01QMoAgA2AgAgBCADKAIMQQxrKAIAaiIGIANBEGoiBRA+IAZCgICAgHA3AkggA0Hk1QM2AkQgA0HQ1QM2AgwgBRA/IgZB8MsDNgIAIANCADcCOCADQgA3AjAgA0EQNgJAIANBlAFqIgUgASACEFkgBCADKAKUASAFIAMsAJ8BIgRBAEgiBRsgAygCmAEgBCAFGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyADQZQBaiIEIAIQNSADQQxqIAMoApQBIAQgAywAnwEiAkEASCIEGyADKAKYASACIAQbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBDGoiAkGLwwFBBBAtIAEoAnQgASgCcGtBDG0QPBogAkHhwwFBBxAtIAEoAmggASgCZGtB/wFxEEIaIAJB6cMBQQUQLRogASgCZCICIAEoAmgiAUcEQANAIANBDGogAi0AABBCQbjEAUECEC0aIAJBAWoiAiABRw0ACwsgA0EMakHPkAJBARAtGgJAAn8gAygCQCIBQRBxBEAgAygCPCICIAMoAigiAUkEQCADIAE2AjwgASECCyADQSRqDAELIAFBCHFFBEBBACECIABBADoACwwCCyADKAIgIQIgA0EYagshAQJAIAIgASgCACIEayICQfj///8HSQRAIAJBC08EQCACQQdyQQFqIgUQLCEBIAAgBUGAgICAeHI2AgggACABNgIAIAAgAjYCBCABIQAMAgsgACACOgALIAINAUEAIQIMAgsQOAALIAAgBCACEDcaCyAAIAJqQQA6AAAgA0Hs1QMoAgAiADYCDCAAQQxrKAIAIANBDGpqQfjVAygCADYCACAGQfDLAzYCACADLAA7QQBIBEAgAygCOBogAygCMBAqCyAGED0aIANBxABqEDsaIANBoAFqJAALvAgBDH8jAEEQayIEJAAgAhBOIQsCQAJAIAIQUiINRQ0AA0AgAhBSIgXAQQBIBEAgBEEoECwiATYCBCAEQqaAgICAhYCAgH83AgggAUGT5gApAAA3AAAgAUEAOgAmIAFBseYAKQAANwAeIAFBq+YAKQAANwAYIAFBo+YAKQAANwAQIAFBm+YAKQAANwAIIABBBEG6FyAEQQRqEC8aIAQsAA9BAE4NAyAEKAIMGiAEKAIEECoMAwsgBUERTwRAIARBOBAsIgE2AgQgBEKzgICAgIeAgIB/NwIIIAFB3+UAKQAANwAAIAFBADoAMyABQY7mACgAADYALyABQYfmACkAADcAKCABQf/lACkAADcAICABQfflACkAADcAGCABQe/lACkAADcAECABQeflACkAADcACCAAQQRBuhcgBEEEahAvGiAELAAPQQBODQMgBCgCDBogBCgCBBAqDAMLAkACQCABKAJo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BSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgA0EQaiQACwgAQbHWydEGC0UBAn8gAEHc+gQ2AgACQCAAKAL4AiIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCyAAEHQQKgtDAQJ/IABB3PoENgIAAkAgACgC+AIiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsgABB0C9kHAQl/IwBBMGsiAyQAAkACQAJAIAEoAhgiAiABKAIcIgRHBEADQAJAIAIoAgAiBUUNACAFQaC/BEHM/gQQOSIFRQ0AIAIoAgQiBARAIAQgBCgCBEEBajYCBAtBNBAsIgJCADcCBCACQfDyBDYCACACQQxqIQYgBEUNAyAEIAQoAgRBAWo2AgQgAkEAOgAYIAJCADcCECACQgA3AhwgAkIANwIkIAIgBDYCMCACIAU2AiwgAkHE+wQ2AgwgBCgCBEF/Rw0EIAQgBCgCACgCCBEAACAEECsMBAsgAkEIaiICIARHDQALCyADQRgQLCIBNgIQIANCkoCAgICDgICAfzcCFCABQd2aASkAADcAACABQQA6ABIgAUHtmgEvAAA7ABAgAUHlmgEpAAA3AAggAEECQQAgA0EQahAvGiADLAAbQQBODQIgAygCGBogAygCEBAqDAILIAJCADcCECACQgA3AhwgAkEANgIwIAIgBTYCLCACQQA6ABggAkIANwIkIAJBxPsENgIMCyABIAY2AvQCIAEoAvgCIQUgASACNgL4AgJAIAVFDQAgBSAFKAIEIgJBAWs2AgQgAg0AIAUgBSgCACgCCBEAACAFECsLIANBADoAGCADQgA3AiQgA0IANwMQIANCADcCHCADIAEoAhQiAigCMDYCCCADIAIoAjQiAjYCDCACBEAgAiACKAIEQQFqNgIECyABKAIkIQIgAyADKQIINwMAIANBEGogAyACENIBIAEoAvQCIQEgAygCFCEFIANBADYCFCADKAIQIQIgA0EANgIQIAMoAiQhBiADQQA2AiQgAygCICEHIANBADYCICADKAIcIQggA0EANgIcIAMtABghCSADKAIoIQogASACNgIEIAEoAgghAiABIAU2AggCQCACRQ0AIAIgAigCBCIFQQFrNgIEIAUNACAC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LSABKAJoIAEoAmRrEDxBz5ACQQEQLRoCQAJ/IAMoAkAiAUEQcQRAIAMoAjwiASADKAIoIgJJBEAgAyACNgI8IAIhAQsgA0EkagwBCyABQQhxRQRAQQAhASAAQQA6AAsMAgsgAygCICEBIANBGGoLIQICQCABIAIoAgAiBGsiAUH4////B0kEQCABQQtPBEAgAUEHckEBaiIFECwhAiAAIAVBgICAgHhyNgIIIAAgAjYCACAAIAE2AgQgAiEADAILIAAgAToACyABDQFBACEBDAILEDgACyAAIAQgARA3GgsgACABakEAOgAAIANB7NUDKAIAIgA2AgwgAEEMaygCACADQQxqakH41QMoAgA2AgAgBkHwywM2AgAgAywAO0EASARAIAMoAjgaIAMoAjAQKgsgBhA9GiADQcQAahA7GiADQaABaiQACwgAQefKwdMGC9EGAQV/IwBBoAFrIgMkACADQeTVAzYCRCADQfDVAygCACIGNgIMIANBDGoiBCAGQQxrKAIAakH01QMoAgA2AgAgBCADKAIMQQxrKAIAaiIGIANBEGoiBRA+IAZCgICAgHA3AkggA0Hk1QM2AkQgA0HQ1QM2AgwgBRA/IgZB8MsDNgIAIANCADcCOCADQgA3AjAgA0EQNgJAIANBlAFqIgUgAhA1IAQgAygClAEgBSADLACfASIEQQBIIgUbIAMoApgBIAQgBRsQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgA0EnOgCUASADQQxqIANBlAFqIgRBARAtIQcgBCABKAJkEKQBIAcgAygClAEgBCADLACfASIEQQBIIgUbIAMoApgBIAQgBRsQLUHjtwFBDxAtIAEoAnAgAUHwAGogASwAeyIEQQBIIgUbIAEoAnQgBCAFGxAtQc+QAkEBEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBlAFqIgQgAhA1IANBDGogAygClAEgBCADLACfASICQQBIIgQbIAMoApgBIAIgBBsQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgA0EMakHrsAFBChAtGgJAAkACQAJAIAEoAnwOAwABAgMLIANBDGpB38cBQQYQLRoMAgsgA0EMakGayQFBChAtGgwBCyADQQxqQebHAUEJEC0aCwJAAn8gAygCQCIBQRBxBEAg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E0EATg0AIAIoAhAaIAIoAggQKgsgASwAF0EATg0BIAEoAhQaIAEoAgwQKgwBCyABQQA2AiAgAUIANwIYIAFBDGogAygCBCABQQhqIAFBBGpBACADKAIAKAJoEQcAA0AgASgCCCIGBEACQCABKAIcIAEoAhgiAmsiBCAEIAEoAgQiBWoiB0kEQCABQRhqIAUQZSABKAIEIQUgASgCCCEGIAEoAhghAgwBCyAEIAdNDQAgASACIAdqNgIcCyACIARqIAYgBRAyGiABQQxqIAMoAgQgAUEIaiABQQRqQQAgAygCACgCaBEHAAwBCwsgASgCICECIAFBADYCICABIAI2AlQgASABKQIYNwJMIAFCADcCGCAAIAFBQGsQ5AEgASgCGCIARQ0AIAEgADYCHCABKAIgGiAAECoLAkAgASgCPCIARQ0AIAAgACgCBCICQQFrNgIEIAINACAAIAAoAgAoAggRAAAgABArCyABKAJMIgAEQCABIAA2AlAgASgCVBogABAqCyABKAJAIgAEQCABKAJEIgIgACIFRwRAA0ACQCACQQRrKAIAIgNFDQAgAyADKAIEIgRBAWs2AgQgBA0AIAMgAygCACgCCBEAACADECsLIAJBCGsiAiAARw0ACyABKAJAIQULIAEgADYCRCABKAJIGiAFECoLIAFB4ABqJAAPCxA4AAsvAEGYpgVBBjYCAEGMpgVBAToAAEGcpgVBAToAAEGQpgVChoCAgOAANwIAQYymBQsuAQF/IABBoPcENgIAIAAoAnAiAQRAIAAgATYCdCAAKAJ4GiABECoLIAAQVhAqCywBAX8gAEGg9wQ2AgAgACgCcCIBBEAgACABNgJ0IAAoAngaIAEQKgsgABBWC48CAQN/IwBBIGsiAyQAIAEgAkEAIAEoAgAoAiwRBAAhBAJAAkACQCABKAJkQf//A0sNACABKAJoQf//A0sNACACIAEoAmxB//8DSyIFEEggBQ0BIAIgAS8BZBBNIAIgAS8BaBBNIAIgAS8BbBBNDAILIAJBARBICyACIAEoAmQQSiACIAEoAmgQSiACIAEoAmwQSgsgA0EMaiABIAIgBBCbASADLAAfQQBIBEAgAygCHBogAygCFBAqCyAAQZClBSkCADcCACAAQQhqIQACQEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgA0EgaiQAC6EFAQR/IwBBoAFrIgMkACADQeTVAzYCRCADQfDVAygCACIGNgIMIANBDGoiBCAGQQxrKAIAakH01QMoAgA2AgAgBCADKAIMQQxrKAIAaiIGIANBEGoiBRA+IAZCgICAgHA3AkggA0Hk1QM2AkQgA0HQ1QM2AgwgBRA/IgZB8MsDNgIAIANCADcCOCADQgA3AjAgA0EQNgJAIANBlAFqIgUgASACEFkgBCADKAKUASAFIAMsAJ8BIgRBAEgiBRsgAygCmAEgBCAFGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyADQZQBaiIEIAIQNSADQQxqIAMoApQBIAQgAywAnwEiAkEASCIEGyADKAKYASACIAQbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBDGpBz/sAQQ4QLSABKAJkEDxBnp0BQQEQLSABKAJoEDxBnp0BQQEQLSABKAJsEDxB+IkCQQIQLRoCQAJ/IAMoAkAiAUEQcQRAIAMoAjwiASADKAIoIgJJBEAgAyACNgI8IAIhAQsgA0EkagwBCyABQQhxRQRAQQAhASAAQQA6AAsMAgsgAygCICEBIANBGGoLIQICQCABIAIoAgAiBGsiAUH4////B0kEQCABQQtPBEAgAUEHckEBaiIFECwhAiAAIAVBgICAgHhyNgIIIAAgAjYCACAAIAE2AgQgAiEADAILIAAgAToACyABDQFBACEBDAILEDgACyAAIAQgARA3GgsgACABakEAOgAAIANB7NUDKAIAIgA2AgwgAEEMaygCACADQQxqakH41QMoAgA2AgAgBkHwywM2AgAgAywAO0EASARAIAMoAjgaIAMoAjAQKgsgBhA9GiADQcQAahA7GiADQaABaiQAC+IBACMAQRBrIgMkACABAn8gAhBSQQFxBEAgASACEEk2AmQgASACEEk2AmggAhBJDAELIAEgAhBONgJkIAEgAhBONgJoIAIQTgs2AmwCQCACLQAUQQFGBEAgA0EAOgAEIANBADoADyAAQQJB5AAgA0EEahAvGiADLAAPQQBODQEgAygCDBogAygCBBAqDAELIABBkKUFKQIANwIAIABBCGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgA0EQaiQAC8UIAgR/AX4jAEGwAWsiAyQAIANB5NUDNgJUIANB8NUDKAIAIgY2AhwgA0EcaiIEIAZBDGsoAgBqQfTVAygCADYCACAEIAMoAhxBDGsoAgBqIgYgA0EgaiIFED4gBkKAgICAcDcCSCADQeTVAzYCVCADQdDVAzYCHCAFED8iBkHwywM2AgAgA0IANwJIIANCADcCQCADQRA2AlAgA0GkAWoiBSABIAIQrAIgBCADKAKkASAFIAMsAK8BIgRBAEgiBRsgAygCqAEgBCAFGxAtGiADLACvAUEASARAIAMoAqwBGiADKAKkARAqCwJ/AkACQAJAAkAgASkDCCIHIAEoAiAiBK1aBEAgASgCZCEBIANBiMIBLwAAOwEUIANBBjoAGyADQYTCASgAADYCECADQQA6ABYgA0HoxAEvAAA7AQggA0EGOgAPIANB5MQBKAAANgIEIANBADoACiADQaQBaiICIAEgB6cgBGsgA0EQaiADQQRqEKwEIANBHGogAygCpAEgAiADLACvASIBQQBIIgIbIAMoAqgBIAEgAhsQLRogAywArwFBAEgEQCADKAKsARogAygCpAEQKgsgAywAD0EASARAIAMoAgwaIAMoAgQQKgsgAywAG0EASARAIAMoAhgaIAMoAhAQKgsCfyADKAJQIgFBEHEEQCADKAJMIgEgAygCOCICSQRAIAMgAjYCTCACIQELIANBNGoMAQsgAUEIcUUEQCAAQQA6AAsgAAwHCyADKAIwIQEgA0EoagshAiABIAIoAgAiBGsiAkH4////B08NASACQQtPBEAgAkEHckEBaiIFECwhASAAIAVBgICAgHhyNgIIIAAgATYCACAAIAI2AgQgASEADAULIAAgAjoACyACDQQgAAwFCyADQaQBaiIEIAIQNSADQRxqIAMoAqQBIAQgAywArwEiAkEASCIEGyADKAKoASACIAQbEC0aIAMsAK8BQQBIBEAgAygCrAEaIAMoAqQBECoLIANBHGpBtK0BQREQLSABKQMIEIUBQZSPAkEXEC0aAn8gAygCUCIBQRBxBEAgAygCTCIBIAMoAjgiAkkEQCADIAI2AkwgAiEBCyADQTRqDAELIAFBCHFFBEBBACEBIABBADoACwwECyADKAIwIQEgA0EoagshAiABIAIoAgAiBGsiAUH4////B08NACABQQtPBEAgAUEHckEBaiIFECwhAiAAIAVBgICAgHhyNgIIIAAgAjYCACAAIAE2AgQgAiEADAILIAAgAToACyABDQFBACEBDAILEDgACyAAIAQgARA3GgsgACABagwBCyAAIAQgAhA3IAJqC0EAOgAAIANB7NUDKAIAIgA2AhwgAEEMaygCACADQRxqakH41QMoAgA2AgAgBkHwywM2AgAgAywAS0EASARAIAMoAkgaIAMoAkAQKgsgBhA9GiADQdQAahA7GiADQbABaiQAC6UBAQJ/IwBBIGsiAyQAIAEgAkEAIAEoAgAoAiwRBAAhBCACIAEtAGEQSCADQQxqIAEgAiAEEJsBIAMsAB9BAEgEQCADKAIcGiADKAIUECoLIABBkKUFKQIANwIAIABBCGohAAJAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyADQSBqJAALgwUBBH8jAEGgAWsiAyQAIANB5NUDNgJEIANB8NUDKAIAIgY2AgwgA0EMaiIEIAZBDGsoAgBqQfTVAygCADYCACAEIAMoAgxBDGsoAgBqIgYgA0EQaiIFED4gBkKAgICAcDcCSCADQeTVAzYCRCADQdDVAzYCDCAFED8iBkHwywM2AgAgA0IANwI4IANCADcCMCADQRA2AkAgA0GUAWoiBSABIAIQWSAEIAMoApQBIAUgAywAnwEiBEEASCIFGyADKAKYASAEIAUbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBlAFqIgQgAhA1IANBDGogAygClAEgBCADLACfASICQQBIIgQbIAMoApgBIAIgBBsQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgA0EMakGhsgFBChAtIAEtAGEQQkHPkAJBARAtGgJAAn8gAygCQCIBQRBxBEAgAygCPCICIAMoAigiAUkEQCADIAE2AjwgASECCyADQSRqDAELIAFBCHFFBEBBACECIABBADoACwwCCyADKAIgIQIgA0EYagshAQJAIAIgASgCACIEayICQfj///8HSQRAIAJBC08EQCACQQdyQQFqIgUQLCEBIAAgBUGAgICAeHI2AgggACABNgIAIAAgAjYCBCAB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QSBrIgMkACABIAJBACABKAIAKAIsEQQAIQQCQCABKQMIIAE1AiBaBEAgAiABQeQAahCUASACIAQ2AgwgA0EMaiABIAIgAigCBCAEIAIoAgBqa0EAIAEoAgAoAjARBwAgAiACKAIEIAIoAgBrNgIMIAMsAB9BAEgEQCADKAIcGiADKAIUECoLIABBkKUFKQIANwIAIABBCGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwCCyAAQZilBSgCAEGcpQUoAgAQLgwBCyADQQA6AAAgA0EAOgALIABBAkHlACADEC8aIAMsAAtBAE4NACADKAIIGiADKAIAECoLIANBIGokAAsZAEEMQQogACgCICIALQBmG0EIIAAtAGUbC7ICAQR/IwBBEGsiAiQAIAJBADYCDCACQgA3AgQCQAJAIAEoAiAiASACQewAa0YEQCAAQQA2AgggAEIANwIADAELIAJBBGogASgCcCIDIAEoAnQiASABIANrEKkBIAIoAgghASACKAIEIQMgAEEANgIIIABCADcCACABIANHBEAgASADayIBQQBIDQIgACABECwiBDYCBCAAIAQ2AgAgACABIARqIgU2AgggBCADIAEQMhogACAFNgIECwsgAEGQpQUpAgA3AgwgAEEUaiEAAkBBo6UFLAAAQQBOBEAgAEGYpQUpAgA3AgAgAEGgpQUoAgA2AggMAQsgAEGYpQUoAgBBnKUFKAIAEC4gAigCBCEDCyADBEAgAiADNgIIIAIoAgwaIAMQKgsgAkEQaiQADwsQNgALCABBseDYiwYLRQECfyAAQYT2BDYCAAJAIAAoAvgCIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEAACABECsLIAAQdBAqC0MBAn8gAEGE9gQ2AgACQCAAKAL4AiIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCyAAEHQLpBgCC38CfiMAQYABayIBJAAgAUIANwN4IAFCADcDcCABQgA3A2ggAUIANwNgIAFBADYAXCABQgA3AFUgAUEBOgBUIAFBQGshBiACKAIAQQAQQCEHQQFBAiACKAIAKAIkIgRBA0YbQQIgB0ELSCIIGyIJQQAgBEECTxsgCSAIGyELIAIoAgBBABCmASIIIAIoAgBB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CBEAACADECsLIAAgAUHgAGoQ5AEgAiACKAIEIgBBAWs2AgQgAA0AIAIgAigCACgCCBEAACACECsLAkAgASgCPCIARQ0AIAAgACgCBCICQQFrNgIEIAINACAAIAAoAgAoAggRAAAgABArCyABKAJsIgAEQCABIAA2AnAgASgCdBogABAqCyABKAJgIgAEQCABKAJkIgMgACICRwRAA0ACQCADQQRrKAIAIgJFDQAgAiACKAIEIgRBAWs2AgQgBA0AIAIgAigCACgCCBEAACACECsLIANBCGsiAyAARw0ACyABKAJgIQILIAEgADYCZCABKAJoGiACECoLIAFBgAFqJAAPCxA4AAuiBwEJfyMAQTBrIgMkAAJAAkACQCABKAIYIgIgASgCHCIERwRAA0ACQCACKAIAIgVFDQAgBUGgvwRB1PcEEDkiBUUNACACKAIEIgQEQCAEIAQoAgRBAWo2AgQLQTQQLCICQgA3AgQgAkGg8gQ2AgAgAkEMaiEGIARFDQMgBCAEKAIEQQFqNgIEIAJBADoAGCACQgA3AhAgAkIANwIcIAJCADcCJCACIAQ2AjAgAiAFNgIsIAJB7PYENgIMIAQoAgRBf0cNBCAEIAQoAgAoAggRAAAgBBArDAQLIAJBCGoiAiAERw0ACwsgA0EAOgAQIANBADoAGyAAQQJBgwEgA0EQahAvGiADLAAbQQBODQIgAygCGBogAygCEBAqDAILIAJCADcCECACQgA3AhwgAkEANgIwIAIgBTYCLCACQQA6ABggAkIANwIkIAJB7PYENgIMCyABIAY2AvQCIAEoAvgCIQUgASACNgL4AgJAIAVFDQAgBSAFKAIEIgJBAWs2AgQgAg0AIAUgBSgCACgCCBEAACAFECsLIANBADoAGCADQgA3AiQgA0IANwMQIANCADcCHCADIAEoAhQiAigCMDYCCCADIAIoAjQiAjYCDCACBEAgAiACKAIEQQFqNgIECyABKAIkIQIgAyADKQIINwMAIANBEGogAyACENIBIAEoAvQCIQEgAygCFCEFIANBADYCFCADKAIQIQIgA0EANgIQIAMoAiQhBiADQQA2AiQgAygCICEHIANBADYCICADKAIcIQggA0EANgIcIAMtABghCSADKAIoIQogASACNgIEIAEoAgghAiABIAU2AggCQCACRQ0AIAIgAigCBCIFQQFrNgIEIAUNACACIAIoAgAoAggRAAAgAhArCyABIAk6AAwgASgCECICBEAgASACNgIUIAEoAhgaIAIQKgsgASAKNgIcIAEgBjYCGCABIAc2AhQgASAINgIQIABBkKUFKQIANwIAIABBCGohAAJAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyADKAIcIgAEQCADIAA2AiAgAygCJBogABAqCwJAIAMoAhQiAEUNACAAIAAoAgQiAUEBazYCBCABDQAgACAAKAIAKAIIEQAAIAAQKwsgBEUNACAEIAQoAgQiAEEBazYCBCAADQAgBCAEKAIAKAIIEQAAIAQQKwsgA0EwaiQAC5cBAQJ/IABB0PUENgIAAkAgACgCJCIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCyAAQcjxBDYCACAAKAIQIgEEQCAAIAE2AhQgACgCGBogARAqCwJAIAAoAggiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsgABAqC5UBAQJ/IABB0PUENgIAAkAgACgCJCIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCyAAQcjxBDYCACAAKAIQIgEEQCAAIAE2AhQgACgCGBogARAqCwJAIAAoAggiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsgAAvEAwICfgN/IwBBEGsiAyQAAkACQAJAIAEpAwgiBEIAUgRAIAQgATUCICIFVA0BIAQgBX0iBEKAgICACFoEQCADQRgQLCIBNgIEIANCkoCAgICDgICAfzcCCCABQZ7XACkAADcAACABQQA6ABIgAUGu1wAvAAA7ABAgAUGm1wApAAA3AAggAEECQegHIANBBGoQLxogAywAD0EATg0EIAMoAgwaIAMoAgQQKgwECwJAIASnIgYgASgCaCABKAJkIgdrIghLBEAgAUHkAGogBiAIaxBlIAEoAmQhBwwBCyAGIAhPDQAgASAGIAdqNgJoCyACIAcgBhDqAQsgAi0AFEEBRw0BIANBADoABCADQQA6AA8gAEECQeQAIANBBGoQLxogAywAD0EATg0CIAMoAgwaIAMoAgQQKgwCCyADQQA6AAQgA0EAOgAPIABBAkHlACADQQRqEC8aIAMsAA9BAE4NASADKAIMGiADKAIEECoMAQsgAEGQpQUpAgA3AgAgAEEIaiEAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyADQRBqJAALZwAgAyABKAIgLQB5IgE2AgAgAiABRUEBdDYCACAAQZClBSkCADcCACAAQQhqIQBBo6UFLAAAQQBOBEAgAEGYpQUpAgA3AgAgAEGgpQUoAgA2AggPCyAAQZilBSgCAEGcpQUoAgAQLgsKACAAKAIgLQB7CwoAIAAoAiAtAHoL2RABDn8jAEEwayIDJAAgA0EANgIsIANCADcCJCABKAIgIgEoAogBIgwgASgCjAEiDUcEQANAAkAgDCgCBCILIAwoAggiDkYNAANAAkAgCygCBCALKAIAa0EYdiEBAkAgAygCKCIEIAMoAiwiBUkEQCAEIAE6AAAgBEEBaiEGDAELIAQgAygCJCIHayIIQQFqIgJBAEgNASAIQf////8HIAUgB2siBUEBdCIGIAIgAiAGSRsgBUH/////A08bIgYEfyAGECwFQQALIgVqIgIgAToAACAFIAZqIQogAkEBaiEGAkAgBCAHRgRAIAIhBQwBC0EAIQkgBCEBIAhBA3EiCARAA0AgAkEBayICIAFBAWsiAS0AADoAACAJQQFqIgkgCEcNAAsLIAcgBGtBfE0EQANAIAJBAWsgAUEBay0AADoAACACQQJrIAFBAmstAAA6AAAgAkEDayABQQNrLQAAOgAAIAJBBGsiAiABQQRrIgEtAAA6AAAgASAHRw0ACwsgAygCLBogAygCJCEHCyADIAo2AiwgAyAGNgIoIAMgBTYCJCAHRQ0AIAcQKgsgAyAGNgIoIAsoAgQgCygCAGtBEHYhAQJAIAMoAiwiBSAGSwRAIAYgAToAACAGQQFqIQQMAQsgBiADKAIkIgdrIghBAWoiAkEASA0BIAhB/////wcgBSAHayIFQQF0IgQgAiACIARJGyAFQf////8DTxsiBAR/IAQQLAVBAAsiBWoiAiABOgAAIAQgBWohCiACQQFqIQQCQCAGIAdGBEAgAiEFDAELQQAhCSAGIQEgCEEDcSIIBEADQCACQQFrIgIgAUEBayIBLQAAOgAAIAlBAWoiCSAIRw0ACwsgByAGa0F8TQRAA0AgAkEBayABQQFrLQAAOgAAIAJBAmsgAUECay0AADoAACACQQNrIAFBA2stAAA6AAAgAkEEayICIAFBBGsiAS0AADoAACABIAdHDQALCyADKAIsGiADKAIkIQcLIAMgCjYCLCADIAQ2AiggAyAFNgIkIAdFDQAgBxAqCyADIAQ2AiggCygCBCALKAIAa0EIdiEBAkAgAygCLCIFIARLBEAgBCABOgAAIARBAWohBgwBCyAEIAMoAiQiB2siCEEBaiICQQBIDQEgCEH/////ByAFIAdrIgVBAXQiBiACIAIgBkkbIAVB/////wNPGyIGBH8gBhAsBUEACyIFaiICIAE6AAAgBSAGaiEKIAJBAWohBgJAIAQgB0YEQCACIQUMAQtBACEJIAQhASAIQQNxIggEQANAIAJBAWsiAiABQQFrIgEtAAA6AAAgCUEBaiIJIAhHDQALCyAHIARrQXxNBEADQCACQQFrIAFBAWstAAA6AAAgAkECayABQQJrLQAAOgAAIAJBA2sgAUEDay0AADoAACACQQRrIgIgAUEEayIBLQAAOgAAIAEgB0cNAAsLIAMoAiwaIAMoAiQhBwsgAyAKNgIsIAMgBjYCKCADIAU2AiQgB0UNACAHECoLIAMgBjYCKCALKAIEIAsoAgBrIQECQCADKAIsIgUgBksEQCAGIAE6AAAgBkEBaiEEDAELIAYgAygCJCIHayIIQQFqIgJBAEgNASAIQf////8HIAUgB2siBUEBdCIEIAIgAiAESRsgBUH/////A08bIgQEfyAEECwFQQALIgVqIgIgAToAACAEIAVqIQogAkEBaiEEAkAgBiAHRgRAIAIhBQwBC0EAIQkgBiEBIAhBA3EiCARAA0AgAkEBayICIAFBAWsiAS0AADoAACAJQQFqIgkgCEcNAAsLIAcgBmtBfE0EQANAIAJBAWsgAUEBay0AADoAACACQQJrIAFBAmstAAA6AAAgAkEDayABQQNrLQAAOgAAIAJBBGsiAiABQQRrIgEtAAA6AAAgASAHRw0ACwsgAygCLBogAygCJCEHCyADIAo2AiwgAyAENgIoIAMgBTYCJCAHRQ0AIAcQKgsgAyAENgIoAkAgCygCBCICIAsoAgAiB2siAUEATA0AIAEgAygCLCIKIARrTARAIAIgB0cEQCAEIAcgARA3GgsgAyABIARqNgIoDAELIAQgAygCJCIFayIIIAFqIgJBAEgNAUEAIQlBACEGQf////8HIAogBWsiCkEBdCIPIAIgAiAPSRsgCkH/////A08bIgIEQCACECwhBgsgAiAGaiEKIAEgBiAIaiICIAcgARAyIgFqIQcCQCAEIAVGBEAgASEGDAELIAQhASAIQQNxIggEQANAIAJBAWsiAiABQQFrIgEtAAA6AAAgCUEBaiIJIAhHDQALCyAFIARrQXxNBEADQCACQQFrIAFBAWstAAA6AAAgAkECayABQQJrLQAAOgAAIAJBA2sgAUEDay0AADoAACACQQRrIgIgAUEEayIBLQAAOgAAIAEgBUcNAAsLIAMoAigiASAEayEJIAEgBEYNACAHIAQgCRA3GgsgAyAHIAlqNgIoIAMoAiQhASADIAY2AiQgAygCLBogAyAKNgIsIAFFDQAgARAqCyAOIAtBDGoiC0cNAQwCCwsQNgALIAxBEGoiDCANRw0ACwsCQAJAIABBADYCCCAAQgA3AgAgAygCKCIBIAMoAiQiBUcEQCABIAVrIgFBAEgNAiAAIAEQLCICNgIEIAAgAjYCACAAIAEgAmoiBjYCCCACIAUgARAyGiAAIAY2AgQLIABBkKUFKQIANwIMIABBFGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgAygCJCIABEAgAyAANgIoIAMoAiwaIAAQKgsgA0EwaiQADwsQNgALDwAgAEGY9QQ2AgAgABAqCw0AIABBmPUENgIAIAALyAEBCH8gAEHQ9AQ2AgAgACgCiAEiBARAIAAoAowBIgIgBCIBRwRAA0AgAkEMayIHKAIAIgUEQCACQQhrIggoAgAiASAFIgNHBEADQCABQQxrIgMoAgAiBgRAIAFBCGsgBjYCACABQQRrKAIAGiAGECoLIAMiASAFRw0ACyAHKAIAIQMLIAggBTYCACACQQRrKAIAGiADECoLIAJBEGsiAiAERw0ACyAAKAKIASEBCyAAIAQ2AowBIAAoApABGiABECoLIAAQVhAqC8YBAQh/IABB0PQENgIAIAAoAogBIgQEQCAAKAKMASICIAQiAUcEQANAIAJBDGsiBygCACIFBEAgAkEIayIIKAIAIgEgBSIDRwRAA0AgAUEMayIDKAIAIgYEQCABQQhrIAY2AgAgAUEEaygCABogBhAqCyADIgEgBUcNAAsgBygCACEDCyAIIAU2AgAgAkEEaygCABogAxAqCyACQRBrIgIgBEcNAAsgACgCiAEhAQsgACAENgKMASAAKAKQARogARAqCyAAEFYL1AcBBn8jAEEgayIFJAAgASACQQAgASgCACgCLBEEACEGIAIgAS0AZBBIIAIgAS0AZ0EfcSABLQBmQQV0IAEtAGVBBnRyckH/AXEQSCACIAEoAmgQSiACIAEtAGwiA0EEcSADQQJ0QQhxciADQQJ2QQJxciADQQR2IgRBAXFyQQJ0IARBAnFyIANBBnYiA0EBcXJBAnQgA3JB/gFxEEggAiABKAJsIgNBCHZBAnEgA0EKdiIEQQFxckECdCAEQQJxciADQQx2IgRBAXFyQQJ0IARBAnFyIANBDnYiA0EBcXJBAnQgA0ECcXJB/gFxEEggAiABKAJsIgNBEHZBAnEgA0ESdiIEQQFxckECdCAEQQJxciADQRR2IgRBAXFyQQJ0IARBAnFyIANBFnYiA0EBcXJBAnQgA0ECcXJB/gFxEEggAiABKAJsIgNBGHZBAnEgA0EadiIEQQFxckECdCAEQQJxciADQRx2IgRBAXFyQQJ0IARBAnFyIANBHnYiA0EBcXJBAnQgA3JB/gFxEEggAiABLQBwIgNBBHEgA0ECdEEIcXIgA0ECdkECcXIgA0EEdiIEQQFxckECdCAEQQJxciADQQZ2IgNBAXFyQQJ0IANyQf4BcRBIIAIgASgCcCIDQQh2QQJxIANBCnYiBEEBcXJBAnQgBEECcXIgA0EMdiIEQQFxckECdCAEQQJxciADQQ52IgNBAXFyQQJ0IANBAnFyQf4BcRBIIAIgAS0AdBBIIAIgAS8BdkGA4ANyEE0gAiABLQB4QfwBchBIIAIgAS0AeUH8AXIQSCACIAEtAHpB+AFyEEggAiABLQB7QfgBchBIIAIgAS8BfBBNIAIgAS0AhAFBAWtBA3EgAS0AgAFBAnRBBHEgAS0Af0EDdEE4cSABLQB+QQZ0cnJyQf8BcRBIIAIgASgCjAEgASgCiAFrQQR2Qf8BcRBIIAEoAogBIgMgASgCjAEiB0cEQANAIAIgAy0AAEEGdEHAAHEgAy0AAUE/cXIQSCACIAMoAgggAygCBGtBDG1B//8DcRBNIAMoAgQiBCADKAIIIghHBEADQCACIAQoAgQgBCgCAGtB//8DcRBNIAIgBBCUASAEQQxqIgQgCEcNAAsLIANBEGoiAyAHRw0ACwsgBUEMaiABIAIgBhCbASAFLAAfQQBIBEAgBSgCHBogBSgCFBAqCyAAQZClBSkCADcCACAAQQhqIQACQEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgBUEgaiQAC90lARF/IwBBsAFrIgMkACADQeTVAzYCQCADQfDVAygCACIFNgIIIANBCGoiBCAFQQxrKAIAakH01QMoAgA2AgAgBCADKAIIQQxrKAIAaiIFIANBDGoiBhA+IAVCgICAgHA3AkggA0Hk1QM2AkAgA0HQ1QM2AgggBhA/IgxB8MsDNgIAIANCADcCNCADQgA3AiwgA0EQNgI8IANBpAFqIgUgASACEFkgBCADKAKkASAFIAMsAK8BIgRBAEgiBRsgAygCqAEgBCAFGxAtGiADLACvAUEASARAIAMoAqwBGiADKAKkARAqCyADQaQBaiIEIAIQNSADQQhqIAMoAqQBIAQgAywArwEiBEEASCIFGyADKAKoASAEIAUbEC0aIAMsAK8BQQBIBEAgAygCrAEaIAMoAqQBECoLIANBCGpBnrkBQRcQLSABLQBkEEJBz5ACQQEQLSEEIANBpAFqIgUgAhA1IAQgAygCpAEgBSADLACvASIFQQBIIgYbIAMoAqgBIAUgBhsQLRogAywArwFBAEgEQCADKAKsARogAygCpAEQKgsgBEGnwAFBFxAtIAEtAGUQQkHPkAJBARAtIQQgA0GkAWoiBSACEDUgBCADKAKkASAFIAMsAK8BIgVBAEgiBhsgAygCqAEgBSAGGxAtGiADLACvAUEASARAIAMoAqwBGiADKAKkARAqCyAEQb27AUETEC0gAS0AZhDQAkHPkAJBARAtIQQgA0GkAWoiBSACEDUgBCADKAKkASAFIAMsAK8BIgVBAEgiBhsgAygCqAEgBSAGGxAtGiADLACvAUEASARAIAMoAqwBGiADKAKkARAqCyAEQe7BAUEVEC0gAS0AZxBCQc+QAkEBEC0aIANBpAFqIgQgAhA1IANBCGogAygCpAEgBCADLACvASIEQQBIIgUbIAMoAqgBIAQgBRsQLRogAywArwFBAEgEQCADKAKsARogAygCpAEQKgsgA0EIakHBtQFBJRAtGkEAIQQDQCADQQhqIgUgASgCaEEfIARrdkEBcRA8GgJAIARBB3FBB0YEQCADQSA6AKQBIAUgA0GkAWpBARAtGgwBCyAEQQNxQQNHDQAgA0EuOgCkASADQQhqIANBpAFqQQEQLRoLIARBAWoiBEEgRw0ACyADQQhqIgVBz5ACQQEQLRogA0GkAWoiBiACEDVBACEEIAUgAygCpAEgBiADLACvASIFQQBIIgYbIAMoAqgBIAUgBhsQLRogAywArwFBAEgEQCADKAKsARogAygCpAEQKgsgA0EIakHntQFBJBAtGiABQewAaiEFA0AgA0EIaiIGIAUgBEEDdkH8////AXFqKAIAIAR2QQFxEEIaIARBAWoiBEEHcUUEQCADQSA6AKQBIAYgA0GkAWpBARAtGgsgBEEwRw0ACyADQQhqIgRBz5ACQQEQLRogA0GkAWoiBSACEDUgBCADKAKkASAFIAMsAK8BIgRBAEgiBRsgAygCqAEgBCAFGxAtGiADLACvAUEASARAIAMoAqwBGiADKAKkARAqCyADQQhqQdrBAUETEC0gAS0AdBBCQc+QAkEBEC0hBCADQaQBaiIFIAIQNSAEIAMoAqQBIAUgAywArwEiBUEASCIGGyADKAKoASAFIAYbEC0aIAMsAK8BQQBIBEAgAygCrAEaIAMoAqQBECoLIARBu8EBQR4QLSABLwF2EDxBz5ACQQEQLSEEIANBpAFqIgUgAhA1IAQgAygCpAEgBSADLACvASIFQQBIIgYbIAMoAqgBIAUgBhsQLRogAywArwFBAEgEQCADKAKsARogAygCpAEQKgsgBEGuvgFBEhAtIAEtAHgQQkHPkAJBARAtIQQgA0GkAWoiBSACEDUgBCADKAKkASAFIAMsAK8BIgVBAEgiBhsgAygCqAEgBSAGGxAtGiADLACvAUEASARAIAMoAqwBGiADKAKkARAqCyAEQcCzAUEPEC0aAkACQAJAAkACQCABLQB5IgRBAWsOAwABAgMLIANBCGpBhI8BQQUQLRoMAwsgA0EIakGKjAFBBRAtGgwCCyADQQhqQfiKAUEFEC0aDAELIANBCGogBBBCGgsgA0EIakHPkAJBARAtIQQgA0GkAWoiBSACEDUgBCADKAKkASAFIAMsAK8BIgVBAEgiBhsgAygCqAEgBSAGGxAtGiADLACvAUEASARAIAMoAqwBGiADKAKkARAqCyAEQYvCAUEQEC0gAS0AehBCQc+QAkEBEC0hBCADQaQBaiIFIAIQNSAEIAMoAqQBIAUgAywArwEiBUEASCIGGyADKAKoASAFIAYbEC0aIAMsAK8BQQBIBEAgAygCrAEaIAMoAqQBECoLIARBrcIBQRIQLSABLQB7EEJBz5ACQQEQLSEEIANBpAFqIgUgAhA1IAQgAygCpAEgBSADLACvASIFQQBIIgYbIAMoAqgBIAUgBhsQLRogAywArwFBAEgEQCADKAKsARogAygCpAEQKgsgBEG6vQFBEBAtIAEvAXwQPEHPkAJBARAtIQQgA0GkAWoiBSACEDUgBCADKAKkASAFIAMsAK8BIgVBAEgiBhsgAygCqAEgBSAGGxAtGiADLACvAUEASARAIAMoAqwBGiADKAKkARAqCyAEQaS9AUEVEC0gAS0AfhBCQc+QAkEBEC0hBCADQaQBaiIFIAIQNSAEIAMoAqQBIAUgAywArwEiBUEASCIGGyADKAKoASAFIAYbEC0aIAMsAK8BQQBIBEAgAygCrAEaIAMoAqQBECoLIARB3LQBQRUQLSABLQB/EEJBz5ACQQEQLSEEIANBpAFqIgUgAhA1IAQgAygCpAEgBSADLACvASIFQQBIIgYbIAMoAqgBIAUgBhsQLRogAywArwFBAEgEQCADKAKsARogAygCpAEQKgsgBEGYwQFBFBAtIAEtAIABEEJBz5ACQQEQLSEEIANBpAFqIgUgAhA1IAQgAygCpAEgBSADLACvASIFQQBIIgYbIAMoAqgBIAUgBhsQLRogAywArwFBAEgEQCADKAKsARogAygCpAEQKgsgBEGvvAFBDRAtIAEtAIQBEEJBz5ACQQEQLRoCQCABKAKIASILIAEoAowBIhFHBEAgA0EUaiESA0AgA0GkAWoiASACEDUgA0EIaiADKAKkASABIAMsAK8BIgFBAEgiBBsgAygCqAEgASAEGxAtGiADLACvAUEASARAIAMoAqwBGiADKAKkARAqCyADQQhqIgFBrooCQQgQLRogAiACKAIAQQFqNgIAIANBpAFqIgQgAhA1IAEgAygCpAEgBCADLACvASIBQQBIIgQbIAMoAqgBIAEgBBsQLRogAywArwFBAEgEQCADKAKsARogAygCpAEQKgsgA0EIakGitAFBFBAtIAstAAAQQkHPkAJBARAtIQEgA0GkAWoiBCACEDUgASADKAKkASAEIAMsAK8BIgRBAEgiBRsgAygCqAEgBCAFGxAtGiADLACvAUEASARAIAMoAqwBGiADKAKkARAqCyABQYG+AUEPEC0gCy0AARBCQc+QAkEBEC0aAkAgCygCBCINIAsoAggiE0YNAANAIANBkAFqIAIQNSADLACbASEGIAMoApABIQggAygClAEhCgJAIANBnAFqIANBCGoiARBzIg4tAABBAUcNACABIAMoAghBDGsoAgBqIgcoAgQhDyAHKAIYIQQgBygCTCIFQX9GBEAgA0GkAWoiCSAHKAIcIgE2AgAgAUHszgZHBEAgASABKAIEQQFqNgIECyAJQaTQBhBDIgFBICABKAIAKAIcEQUAIQUgCRBHIAcgBTYCTAsCQCAERQ0AIAcoAgwhCSAIIANBkAFqIAZBAEgiCBsiASAKIAYgCBsiBmoiECABIA9BsAFxQSBGGyIIIAFrIgpBAEoEQCAEIAEgCiAEKAIAKAIwEQQAIApHDQELIAkgBmtBACAGIAlIGyIBQQBKBEAgAUH4////B08NBwJAIAFBC08EQCABQQdyQQFqIgkQLCEGIAMgCUGAgICAeHI2AqwBIAMgBjYCpAEgAyABNgKoAQwBCyADIAE6AK8BIANBpAFqIQYLIAYgBSABEDQgAWpBADoAACAEIAMoAqQBIANBpAFqIAMsAK8BQQBIGyABIAQoAgAoAjARBAAhBSADLACvAUEASARAIAMoAqwBGiADKAKkARAqCyABIAVHDQELIBAgCGsiAUEASgRAIAQgCCABIAQoAgAoAjARBAAgAUcNAQsgB0EANgIMDAELIAMoAghBDGsoAgAgA0EIamoiASABKAIQQQVyEHoLIA4QciADLACbAUEASARAIAMoApgBGiADKAKQARAqCyANKAIAIgQgDSgCBCIORwRAA0AgBC0AACEHIAMoAggiAUEMaygCACADQQhqaiIFKAJMQX9GBEAgA0GkAWoiBiAFKAIcIgE2AgAgAUHszgZHBEAgASABKAIEQQFqNgIECyAGQaTQBhBDIgFBICABKAIAKAIc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ADcCACAAIAEpAwA3AiAgAEEoaiEAAkAgASwAE0EATgRAIAAgASkCCDcCACAAIAEoAhA2AggMAQsgACABKAIIIAEoAgwQLiABLAATQQBODQAgASgCEBogASgCCBAqCyAELABbQQBODQEgBCgCWBogBCgCUBAqDAELIARBADYCTCAEQQA2AkggBEEgaiADKAIEIARB0ABqIARBxABqQQAgAygCACgCaBEHACAEKAJQIgYEQANAIAYtAAAiBUH+AXFBwgBGBEAgBEIANwIoIARBDGohFiAGIREgBCgCRCETIARBzABqIRQgBEHIAGohFUEAIQFBACEFQQAhBkEAIQhBACESIwBB0ABrIgokACAKQQA2AkwgCkIANwJEAkACQAJAAkACQAJAIBMEQANAAkACQCAIQQJqIgsgE08NACAIIBFqIgctAAANACAHLQABDQAgCyARai0AAEEDRw0AAkAgASAGSwRAIAZBADoAACAGQQFqIQgMAQsgBiAFayIMQQFqIgdBAEgNCCAMQf////8HIAEgBWsiAUEBdCIIIAcgByAISRsgAUH/////A08bIhAEfyAQECwFQQALIg9qIghBADoAAAJ/IAggBSAGRg0AGkEAIQ0gCCEHIAYhASAMQQNxIgwEQANAIAdBAWsiByABQQFrIgEtAAA6AAAgDUEBaiINIAxHDQALCyAPIAUgBmtBfEsNABoDQCAHQQFrIAFBAWstAAA6AAAgB0ECayABQQJrLQAAOgAAIAdBA2sgAUEDay0AADoAACAHQQRrIgcgAUEEayIBLQAAOgAAIAEgBUcNAAsgDwshFyAPIBBqIQEgCEEBaiEIIAUEQCAFECoLIBchBQsgASAISwRAIAhBADoAACAIQQFqIQYMAgsgCCAFayIMQQFqIgZBAEgNBCAMQf////8HIAEgBWsiAUEBdCIHIAYgBiAHSRsgAUH/////A08bIhAEfyAQECwFQQALIg9qIgZBADoAAAJ/IAYgBSAIRg0AGkEAIQ0gBiEHIAghASAMQQNxIgwEQANAIAdBAWsiByABQQFrIgEtAAA6AAAgDUEBaiINIAxHDQALCyAPIAUgCGtBfEsNABoDQCAHQQFrIAFBAWstAAA6AAAgB0ECayABQQJrLQAAOgAAIAdBA2sgAUEDay0AADoAACAHQQRrIgcgAUEEayIBLQAAOgAAIAEg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NwIEIAJB+PEENgIAIAJBDGohBiAERQ0DIAQgBCgCBEEBajYCBCACQQA6ABggAkIANwIQIAJCADcCHCACQgA3AiQgAiAENgIwIAIgBTYCLCACQdD1BDYCDCAEKAIEQX9HDQQgBCAEKAIAKAIIEQAAIAQQKwwECyACQQhqIgIgBEcNAAsLIANBADoAECADQQA6ABsgAEECQeoAIANBEGoQLxogAywAG0EATg0CIAMoAhgaIAMoAhAQKgwCCyACQgA3AhAgAkIANwIcIAJBADYCMCACIAU2AiwgAkEAOgAYIAJCADcCJCACQdD1BDYCDAsgASAGNgL0AiABKAL4AiEFIAEgAjYC+AICQCAFRQ0AIAUgBSgCBCICQQFrNgIEIAINACAFIAUoAgAoAggRAAAgBRArCyADQQA6ABggA0IANwIkIANCADcDECADQgA3AhwgAyABKAIUIgIoAjA2AgggAyACKAI0IgI2AgwgAgRAIAIgAigCBEEBajYCBAsgASgCJCECIAMgAykCCDcDACADQRBqIAMgAhDSASABKAL0AiEBIAMoAhQhBSADQQA2AhQgAygCECECIANBADYCECADKAIkIQYgA0EANgIkIAMoAiAhByADQQA2AiAgAygCHCEIIANBADYCHCADLQAYIQkgAygCKCEKIAEgAjYCBCABKAIIIQIgASAFNgIIAkAgAkUNACACIAIoAgQiBUEBazYCBCAFDQAgAiACKAIAKAIIEQAAIAIQKwsgASAJOgAMIAEoAhAiAgRAIAEgAjYCFCABKAIYGiACECoLIAEgCjYCHCABIAY2AhggASAHNgIUIAEgCDYCECAAQZClBSkCADcCACAAQQhqIQACQEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgAygCHCIABEAgAyAANgIgIAMoAiQaIAAQKgsCQCADKAIUIgBFDQAgACAAKAIEIgFBAWs2AgQgAQ0AIAAgACgCACgCCBEAACAAECsLIARFDQAgBCAEKAIEIgBBAWs2AgQgAA0AIAQgBCgCACgCCBEAACAEECsLIANBMGokAAsPACAAQcDzBDYCACAAECoLDQAgAEHA8wQ2AgAgAAsPACAAQZjzBDYCACAAECoLDQAgAEGY8wQ2AgAgAAsPACAAQfDyBDYCACAAECoLDQAgAEHw8gQ2AgAgAAsPACAAQcjyBDYCACAAECoLDQAgAEHI8gQ2AgAgAAsPACAAQaDyBDYCACAAECoLDQAgAEGg8gQ2AgAgAAsPACAAQfjxBDYCACAAECoLDQAgAEH48QQ2AgAgAAtbAQJ/IABByPEENgIAIAAoAhAiAQRAIAAgATYCFCAAKAIYGiABECoLAkAgACgCCCIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCyAAC70NAgd/AX4jAEHgAGsiAyQAAkACQAJAIAEgASgCACgCCBEBACACKAIYELEEIgRFBEAgA0EAOgAYIANBADoAIyADQTBqQQtB8y4gA0EYahAvIQEgAEIANwIAIAAgASkDADcCCCAAQRBqIQACQCABLAATQQBOBEAgACABKQIINwIAIAAgASgCEDYCCAwBCyAAIAEoAgggASgCDBAuIAEsABNBAE4NACABKAIQGiABKAIIECoLIAMsACNBAE4NASADKAIgGiADKAIYECoMAQsgBCgCFCIFRQRAIANBMBAsIgE2AhggA0KrgICAgIaAgIB/NwIcIAFB0ZYBKAAANgAnIAFBypYBKQAANwAgIAFBwpYBKQAANwAYIAFBupYBKQAANwAQIAFBspYBKQAANwAIIAFBqpYBKQAANwAAIAFBADoAKyADQTBqQQtB8y4gA0EYahAvIQEgAEIANwIAIAAgASkDADcCCCAAQRBqIQACQCABLAATQQBOBEAgACABKQIINwIAIAAgASgCEDYCCAwBCyAAIAEoAgggASgCDBAuIAEsABNBAE4NACABKAIQGiABKAIIECoLIAMsACNBAE4NASADKAIgGiADKAIYECoMAQsgA0HQAGogA0HcAGogBRECACADKAJQIgUEQCADKAJUIQQgAygCWCIHEFgiAkH4////B08NAgJAAkAgAkELTwRAIAJBB3JBAWoiBhAsIQEgAyAGQYCAgIB4cjYCICADIAE2AhggAyACNgIcDAELIAMgAjoAIyADQRhqIQEgAkUNAQsgASAHIAIQNxoLIAEgAmpBADoAACADQTBqIAUgBCADQRhqEC8hASAAQgA3AgAgACABKQMANwIIIABBEGohAAJAIAEsABNBAE4EQCAAIAEpAgg3AgAgACABKAIQNgIIDAELIAAgASgCCCABKAIMEC4gASwAE0EATg0AIAEoAhAaIAEoAggQKgsgAywAI0EATg0BIAMoAiAaIAMoAhgQKgwBCyAEKAIYIQcgAygCXCEFAkAgBCgCAEECSA0AIAQoAiQiBkUNACAFIAItABUgBhECAAsgA0EwaiABEKoCAkAgAygCPARAIABCADcCACAAIAMpAjw3AgggAEEQaiEAIAMsAE9BAE4EQCAAIAMpAkQ3AgAgACADKAJMNgIIDAILIAAgAygCRCADKAJIEC4MAQsgA0EYaiADKAJcIAMoAjAiASADKAI0IAFrIAQoAhwRBgAgAyADKAIgNgJYIAMgAykCGCIKNwNQIAqnIgYEQCADKAJUIQQgAygCWCIIEFgiAkH4////B08NBAJAAkAgAkELTwRAIAJBB3JBAWoiCRAsIQEgAyAJQYCAgIB4cjYCFCADIAE2AgwgAyACNgIQDAELIAMgAjoAFyADQQxqIQEgAkUNAQsgASAIIAIQNxoLIAEgAmpBADoAACADQRhqIAYgBCADQQxqEC8hASAAQgA3AgAgACABKQMANwIIIABBEGohAAJAIAEsABNBAE4EQCAAIAEpAgg3AgAgACABKAIQNgIIDAELIAAgASgCCCABKAIMEC4gASwAE0EATg0AIAEoAhAaIAEoAggQKgsgAywAF0EATg0BIAMoAhQaIAMoAgwQKgwBCyADQQA2AgggA0EYaiIBIAMoAlwgA0EIaiAEKAIgEQMAIAMgAygCIDYCWCADIAMpAhgiCjcDUCAKpyICBEAgASACIAMoAlQgA0EMaiADKAJYEIABIgIQLyEBIABCADcCACAAIAEpAwA3AgggAEEQaiEAAkAgASwAE0EATgRAIAAgASkCCDcCACAAIAEoAhA2AggMAQsgACABKAIIIAEoAgwQLiABLAATQQBODQAgASgCEBogASgCCBAqCyACLAALQQBODQEgAigCCBogAigCABAqDAELIAMoAggiAUUEQCADQRhqQQdBACADQQxqQdCQAhCAASICEC8hASAAQgA3AgAgACABKQMANwIIIABBEGohAAJAIAEsABNBAE4EQCAAIAEpAgg3AgAgACABKAIQNgIIDAELIAAgASgCCCABKAIMEC4gASwAE0EATg0AIAEoAhAaIAEoAggQKgsgAiwAC0EATg0BIAIoAggaIAIoAgAQKgwBCyAD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LAATQQBODQEgAigCEBogAigCCBAqDAELIARBDGogAkEAELYCIAQoAhQaAkAgBCgCDCICIAQoAhBHBEAgAyEFQQgQLCEDIAIoAgAoAgAhASADQQA2AgQgAyABNgIAIAUgAzYCACAAIAMQygQMAQsgA0EANgIAIARBADoAACAEQQA6AAsgBEEMakEDQQAgBBAvIQMgBCwAC0EASARAIAQoAggaIAQoAgAQKgsgACADIAEEfyABKAIABUEACxBBIAMsABNBAEgEQCADKAIQGiADKAIIECoLIAJFDQELIAIQKgsgBEEgaiQAC2IBA38jAEEQayIBJAAQtAIgAUEEaiAAQQAQtgICQAJAIAEoAggiAyABKAIEIgBHBEAgACgCACgCACECDAELIANFDQELIAEgADYCCCABKAIMGiAAECoLIAFBEGokACACQQBHCwwAIABBABCxBEEARwutAQEBfyMAQSBrIgQkAAJAIAJBACADG0UEQCAEQQA6AAAgBEEAOgALIARBDGpBBUHRDyAEEC8hAiAELAALQQBIBEAgBCgCCBogBCgCABAqCyAAIAIgAQR/IAEoAgAFQQALEEEgAiwAE0EATg0BIAIoAhAaIAIoAggQKgwBC0EIECwhASACKAIAIQIgAUEANgIEIAEgAjYCACADIAE2AgAgACABEMoECyAEQSBqJAALCgAgACgCACgCBAsXAQF/IAAoAgBBA04EfyAAKAIoBUEACwsKACAAKAIEEQ8AC8wGAQp/IwBBMGsiAyQAIANBADYCLCADQgA3AiQCQCAARQRAIANBiL8CKQIANwMYIANBgL8CKQIANwMQIANB+L4CKQIANwMIIANBJGogA0EIaiADQSBqQQYQ1wEMAQtBBBAsIgUgADYCACADIAVBBGoiADYCLCADIAU2AiQgAyAANgIoCxC0AgJAQbilBSgCACIFQbylBUYNACADKAIkIAMoAihGDQACQANAAkACQCADKAIkIgAgAygCKCIGRg0AIAUoAhAhCQNAIAAoAgAgCSgCEBEBACILRQRAIAYgAEEEaiIARw0BDAILCyAEIAhJBEAgBCALNgIEIAQgCTYCACAEQQhqIQQMAQsgBCAHa0EDdSIGQQFqIgBBgICAgAJPDQFB/////wEgCCAHayIIQQJ1IgogACAAIApJGyAIQfj///8HTxsiCAR/IAhBgICA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BBArCyADQSBqJAAL4wIBA38jAEEgayIDJAACQCACRQRAIANBADoAACADQQA6AAsgA0EMakEFQdEPIAMQLyECIAMsAAtBAEgEQCADKAIIGiADKAIAECoLIAAgAiABKAIAIgBBCGpBACAAGxBBIAIsABNBAE4NASACKAIQGiACKAIIECoMAQsgASgCACIEKAI0IQUgBCgCOCIEBEAgBCAEKAIEQQFqNgIECwJAIAUEQCACIAUoAggiAiAFKAIMIAJrEDIaIABBkKUFIAEoAgAiAEEIakEAIAAbEEEMAQsgA0EAOgAAIANBADoACyADQQxqQQpBACADEC8hAiADLAALQQBIBEAgAygCCBogAygCABAqCyAAIAIgASgCACIAQQhqQQAgABsQQSACLAATQQBODQAgAigCEBogAigCCBAqCyAERQ0AIAQgBCgCBCIAQQFrNgIEIAANACAEIAQoAgAoAggRAAAgBBArCyADQSBqJAALagEDfyAAKAIAIgAoAjQhASAAKAI4IgAEQCAAIAAoAgRBAWo2AgQLIAEEfyABKAIMIAEoAghrBUEACyEDAkAgAEUNACAAIAAoAgQiAkEBazYCBCACDQAgACAAKAIAKAIIEQAAIAAQKwsgAwvMAQEEfyAAKAIAIgEoAjQhAiABKAI4IgEEQCABIAEoAgRBAWo2AgQLAn8CQCACBEAgASEADAELIAAoAgAiACgCLCECIAAoAjAiAARAIAAgACgCBEEBajYCBAsCQCABRQ0AIAEgASgCBCIDQQFrNgIEIAMNACABIAEoAgAoAggRAAAgARArCyACDQBBAAwBCyACIAIoAgAoAggRAQALIQQCQCAARQ0AIAAgACgCBCIBQQFrNgIEIAENACAAIAAoAgAoAggRAAAgABArCyAEC+UCAQN/IwBBIGsiAyQAAkAgAkUEQCADQQA6AAAgA0EAOgALIANBDGpBBUHRDyADEC8hAiADLAALQQBIBEAgAygCCBogAygCABAqCyAAIAIgASgCACIAQQRqQQAgABsQQSACLAATQQBODQEgAigCEBogAigCCBAqDAELIAEoAgAiBCgCyAEhBSAEKALMASIEBEAgBCAEKAIEQQFqNgIECwJAIAUEQCACIAUoAggiAiAFKAIMIAJrEDIaIABBkKUFIAEoAgAiAEEEakEAIAAbEEEMAQsgA0EAOgAAIANBADoACyADQQxqQQpBACADEC8hAiADLAALQQBIBEAgAygCCBogAygCABAqCyAAIAIgASgCACIAQQRqQQAgABsQQSACLAATQQBODQAgAigCEBogAigCCBAqCyAERQ0AIAQgBCgCBCIAQQFrNgIEIAANACAEIAQoAgAoAggRAAAgBBArCyADQSBqJAAL9QIBBH8jAEEgayIDJAACQCACRQRAIANBADoAACADQQA6AAsgA0EMakEFQdEPIAMQLyECIAMsAAtBAEgEQCADKAIIGiADKAIAECoLIAAgAiABKAIAIgBBBGpBACAAGxBBIAIsABNBAE4NASACKAIQGiACKAIIECoMAQsgASgCACIEKALAASEFIAQoAsQBIgQEQCAEIAQoAgRBAWo2AgQLAkAgBUUEQCADQQA6AAAgA0EAOgALIANBDGpBCkEAIAMQLyECIAMsAAtBAEgEQCADKAIIGiADKAIAECoLIAAgAiABKAIAIgBBBGpBACAAGxBBIAIsABNBAE4NASACKAIQGiACKAIIECoMAQsgA0EMaiIGIAUgAhCvBCAAIAYgASgCACIAQQRqQQAgABsQQSADLAAfQQBODQAgAygCHBogAygCFBAqCyAERQ0AIAQgBCgCBCIAQQFrNgIEIAANACAEIAQoAgAoAggRAAAgBBArCyADQSBqJAALEABB+KUFQfylBSgCABDKAQvRAQAjAEEgayIEJAAgBEEIaiABIAIgA0EAEJYEAkAgBCgCCARAIAAgBCkDCDcCACAAIAQoAhg2AhAgACAEKQMQNwIIIARBADYCGCAEQgA3AxAMAQsgAiABKAJkIAEtAGFBGHRyEEogAEGQpQUpAgA3AgAgAEEIaiEAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyAELAAbQQBIBEAgBCgCGBogBCgCEBAqCyAEQSBqJAALEABB7KUFQfClBSgCABDKAQsQAEHgpQVB5KUFKAIAEMoBC2wBA38gACgCACIAKALIASEBIAAoAswBIgAEQCAAIAAoAgRBAWo2AgQLIAEEfyABKAIMIAEoAghrBUEACyEDAkAgAEUNACAAIAAoAgQiAkEBazYCBCACDQAgACAAKAIAKAIIEQAAIAAQKwsgAwvVAQEDfyAAKAIAIgEoAsgBIQIgASgCzAEiAQRAIAEgASgCBEEBajYCBAsCQCACBEAgAiACKAIAKAIIEQEAIQIMAQsgACgCACIAKALAASECIAAoAsQBIgAEQCAAIAAoAgRBAWo2AgQLIAIEfyACIAIoAgAoAggRAQAFQQALIQIgAEUNACAAIAAoAgQiA0EBazYCBCADDQAgACAAKAIAKAIIEQAAIAAQKwsCQCABRQ0AIAEgASgCBCIAQQFrNgIEIAANACABIAEoAgAoAggRAAAgARArCyACC9gCAQV/IwBBIGsiBCQAAkACQCABKAIAIgUoArQBIgYgBSgCuAEiCEYNAANAIAIgBigCACIHKAIARwRAIAggBkEIaiIGRw0BDAILCyAHKAIoIgIgBygCLCIGRwRAIANFBEAgBEEAOgAAIARBADoACyAEQQxqQQVB0Q8gBBAvIQIgBCwAC0EASARAIAQoAggaIAQoAgAQKgsgACACIAEoAgAiAEEEakEAIAAbEEEgAiwAE0EATg0DIAIoAhAaIAIoAggQKgwDCyADIAIgBiACaxAyGiABKAIAIQULIABBkKUFIAVBBGpBACAFGxBBDAELIARBADoAACAEQQA6AAsgBEEMakEFQdAPIAQQLyECIAQsAAtBAEgEQCAEKAIIGiAEKAIAECoLIAAgAiABKAIAIgBBBGpBACAAGxBBIAIsABNBAE4NACACKAIQGiACKAIIECoLIARBIGokAAtPAQN/AkAgACgCACICKAK0ASIAIAIoArgBIgRGDQADQCABIAAoAgAiAigCAEcEQCAEIABBCGoiAEcNAQwCCwsgAigCLCACKAIoayEDCyADC1cBA38CQCAAKAIAIgIoArQBIgAgAigCuAEiBEYNAANAIAEgACgCACICKAIARwRAIAQgAEEIaiIARw0BDAILCyACKAIcIAJBHGogAiwAJ0EASBshAwsgAwtXAQN/AkAgACgCACICKAK0ASIAIAIoArgBIgRGDQADQCABIAAoAgAiAigCAEcEQCAEIABBCGoiAEcNAQwCCwsgAigCECACQRBqIAIsABtBAEgbIQMLIAMLVwEDfwJAIAAoAgAiAigCtAEiACACKAK4ASIERg0AA0AgASAAKAIAIgIoAgBHBEAgBCAAQQhqIgBHDQEMAgsLIAIoAgQgAkEEaiACLAAPQQBIGyEDCyADCzQBAn8gASgCDCEEIAFBGEEIIAAoAhBB5NLVqwdGGyIAQQhqIAAgAhsQvwIgAUEEEL8CIAQL0AEBBX8CQCAAKAIAIgUoArQBIgAgBSgCuAEiB0YNACABBEADQAJAIAAoAgAiBSgCCCAFLAAPIgYgBkEASCIGGyIIIAEQWEcNACAFKAIEIAVBBGogBhsgASAIEF8NACADIARMDQMgAiAEQQJ0aiAFKAIANgIAIARBAWohBAsgAEEIaiIAIAdHDQAMAgsACyADQQAgA0EAShshAQNAIAEgBEYEQCABDwsgAiAEQQJ0aiAAKAIAKAIANgIAIARBAWohBCAAQQhqIgAgB0cNAAsLIAQLjgEBBX8gACgCACICKAK0ASIAIAIoArgBIgVGBEBBAA8LAkAgAUUEQCAFIABrQQhrQQN2QQFqIQIMAQsgARBYIQZBACECA0AgBiAAKAIAIgMoAgggAywADyIEIARBAEgiBBtGBEAgAiADKAIEIANBBGogBBsgASAGEF9FaiECCyAAQQhqIgAgBUcNAAsLIAIL1wMBA38jAEEQayIFJAACQAJAIAIQWEEERwRAIABB/OwEKQIANwIAIABBhO0EKAIANgIIDAELIAIoAAAhBiAFQQA2AgwgBUIANwIEIAVBBGpBACADIAMgBGogBBDFAUEgECwiAkEANgIcIAJCADcCFCACIAZBGHQgBkGA/gNxQQh0ciAGQQh2QYD+A3EgBkEYdnJyNgIQIAJBpOYENgIMIAJBvOcENgIAIAJCADcCBCAFKAIIIgMgBSgCBCIERwRAIAMgBGsiA0EASA0CIAIgAxAsIgY2AhQgAiADIAZqIgc2AhwgBiAEIAMQMhogAiAHNgIYCyABKAIAIQMgAiACKAIEQQJqNgIEIAMgAkEMajYCNCADKAI4IQEgAyACNgI4AkAgAUUNACABIAEoAgQiA0EBazYCBCADDQAgASABKAIAKAIIEQAAIAEQKwsgAiACKAIEIgFBAWs2AgQgAUUEQCACIAIoAgAoAggRAAAgAhArCyAAQeTsBCkCADcCACAAQezsBCgCADYCCCACIAIoAgQiAEEBazYCBCAARQRAIAIgAigCACgCCBEAACACECsLIAUoAgQiAEUNACAFIAA2AgggBSgCDBogABAqCyAFQRBqJAAPCxA2AAuTCgEQfyMAQSBrIgskACALQQxqIQggASgCACEKIAIhDyADIRAjAEEwayIEJAACQCAKKAI8IgMgCkFAayINRwRAIAhBCGohDgNAIA8gECADKAIQIAooAiQgBEEsaiAEQShqEIkDAkAgAygCECIGQQpGBEBB/wEhByAKKAIkQQprIgJBBk8NAUKYwMCBhIYQIAJBA3StiKchBwwBC0EAIQcgDSIFKAIAIgJFDQADQCAFIAIgAigCECAGSCIJGyEFIAIgCUECdGooAgAiAg0ACyAFIA1GDQAgBSgCECAGSg0AIAUtABhBB2ohBwsgAygCICEFIAMoAhwhDCAHQQN2QR9xIQkgBCgCKCECAkACQAJAAkACQCAEKAIsIgcgAygCJE0EQCADKAIoIAJPDQELIARBgAI7AQggBEEBNgIEIARBADYCJCAEQgA3AhwgBEIANwIUIARCADcCDCAIIARBBGogByACIAMoAhQgAy0AGAJ/QQEhAgJAAkACQAJAIAooAiQOZAMDAwMCAgICAgIAAQABAAECAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCC0EDDAMLQQQMAgtBACECCyACC0EAELkCIAgoAgANByAILAATQQBIBEAgCCgCEBogCCgCCBAqCyAEKAIcIgZFDQEgAygCIARAQQAhAiAEKAIkIQcDQCAGIAIgB2xqIAMoAiwgAygCNCACbGogAygCHCAJbBAyGiACQQFqIgIgAygCIEkNAAsLIAMgBCkCBDcCFCADIAQoAiQ2AjQgAyAEKQIcNwIsIAMgBCkCFDcCJCADIAQpAgw3AhwgAygCECEGIAQoAiwhBwtBgH9BACAGQQFrQQJJG0EAIAlBAUYbIQICQCAHIAxGDQAgBUUNACAJIAxsIQdBACEGIAVBAUcEQCAFQX5xIRJBACERA0AgAygCLCADKAI0IAZsaiAHaiACIAQoAiwgDGsgCWwQNBogAygCLCADKAI0IAZBAXJsaiAHaiACIAQoAiwgDGsgCWwQNBogBkECaiEGIBFBAmoiESASRw0ACwsgBUEBcUUNACADKAIsIAMoAjQgBmxqIAdqIAIgBCgCLCAMayAJbBA0GgsgBSAEKAIoIgZJDQEMAwsgCEGkpQUpAgA3AgBBt6UFLAAAQQBIDQEgDkGspQUpAgA3AgAgDkG0pQUoAgA2AggMBQsDQCADKAIsIAMoAjQgBWxqIAIgBCgCLCAJbBA0GiAFQQFqIgUgBCgCKCIGSQ0ACwwBCyAOQaylBSgCAEGwpQUoAgAQLgwDCyAEKAIsIQIgAyAGNgIgIAMgAjYCHAJAIAMoAgQiBQRAA0AgBSICKAIAIgUNAAwCCwALA0AgAygCCCICKAIAIANHIRMgAiEDIBMNAAsLIAIiAyANRw0ACwsgCiAQNgIcIAogDzYCGCAIQZClBSkCADcCACAIQQhqIQJBo6UFLAAAQQBOBEAgAkGYpQUpAgA3AgAgAkGgpQUoAgA2AggMAQsgAkGYpQUoAgBBnKUFKAIAEC4LIARBMGokAAJAIAsoAgwEQCAAIAggASgCACIAQQhqQQAgABsQQQwBCyAAQZzxBCkCADcCACAAQaTxBCgCADYCCAsgCywAH0EASARAIAsoAhwaIAsoAhQQKgsgC0EgaiQAC8IBAgF/AX4jAEEgayIFJAAgBUIANwIYIAVBBGoiBiABKAIAIAVBGGogAyAEQQAQjAMgACAFKAIEBH8gBgUgAkEIECwiADYCACAFKQIYIQcgBUIANwIYIAAgBzcCAEGQpQULIAEoAgAiAEEIakEAIAAbEEEgBSwAF0EASARAIAUoAhQaIAUoAgwQKgsCQCAFKAIcIgBFDQAgACAAKAIEIgFBAWs2AgQgAQ0AIAAgACgCACgCCBEAACAAECsLIAVBIGokAAuUCQEPfyMAQSBrIgokACAKQQxqIQggASgCACELIAIhDyADIRAjAEEwayIEJAACQAJAIAsoAjwiAyALQUBrIg1HBEAgCEEIaiEOA0AgDyAQIAMoAhAgCygCJCAEQSxqIARBKGoQiQMCQCADKAIQIglBCkYEQEH/ASEGIAsoAiRBCmsiAkEGTw0BQpjAwIGEhhAgAkEDdK2IpyEGDAELQQAhBiANIgUoAgAiAkUNAANAIAUgAiACKAIQIAlIIgcbIQUgAiAHQQJ0aigCACICDQALIAUgDUYNACAFKAIQIAlKDQAgBS0AGEEHaiEGCyADKAIgIQkgAygCHCEFIAZB+AFxQQN2IQwgBCgCKCECAkAgBCgCLCIHIAMoAiRNBEAgAygCKCACTw0BCyAEQYACOwEIIARBATYCBCAEQQA2AiQgBEIANwIcIARCADcCFCAEQgA3AgwgCCAEQQRqIAcgAiADKAIUIAMtABgCf0EBIQICQAJAAkACQCALKAIkDmQDAwMDAgICAgICAAEAAQABAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgtBAwwDC0EEDAILQQAhAgsgAgtBABC5AiAIKAIADQQgCCwAE0EASARAIAgoAhAaIAgoAggQKgsgBCgCHCIGRQ0DIAMoAiAEQEEAIQIgBCgCJCEHA0AgBiACIAdsaiADKAIsIAMoAjQgAmxqIAMoAhwgDGwQMhogAkEBaiICIAMoAiBJDQALCyADIAQpAgQ3AhQgAyAEKAIkNgI0IAMgBCkCHDcCLCADIAQpAhQ3AiQgAyAEKQIMNwIcIAQoAiwhBwsCQCAFIAdGDQAgCUUNACAFIAdPDQAgBUEBayAMbCERQQAhBgNAIAUiAiAHSQRAA0AgAygCLCADKAI0IAZsaiIHIAIgDGxqIAcgEWogDBAyGiACQQFqIgIgBCgCLCIHSQ0ACwsgBkEBaiIGIAlHDQALCyAEKAIoIAlLBEAgCUEBayECA0AgAygCLCIFIAMoAjQiBiAJbGogBSACIAZsaiAEKAIsIAxsEDIaIAlBAWoiCSAEKAIoSQ0ACwsCQCADKAIEIgUEQANAIAUiAigCACIFDQAMAgsACwNAIAMoAggiAigCACADRyESIAIhAyASDQALCyACIgMgDUcNAAsLIAhBkKUFKQIANwIAIAhBCGohAkGjpQUsAABBAE4EQCACQZilBSkCADcCACACQaClBSgCADYCCAwCCyACQZilBSgCAEGcpQUoAgAQLgwBCyAIQaSlBSkCADcCAEG3pQUsAABBAE4EQCAOQaylBSkCADcCACAOQbSlBSgCADYCCAwBCyAOQaylBSgCAEGwpQUoAgAQLgsgBEEwaiQAAkAgCigCDARAIAAgCCABKAIAIgBBCGpBACAAGxBBDAELIABB5OwEKQIANwIAIABB7OwEKAIANgIICyAKLAAfQQBIBEAgCigCHBogCigCFBAqCyAKQSBqJAALEwAgAEUEQEEADwsgACgCAC0AKAsUACAABEAgACgCACABQQBHOgAoCwstAQJ/IAEoAgwhBCABQRhBCCAAKAIQQeTS1asHRhsiAEEIaiAAIAIbEL8CIAQLCwAgACgCACABEEALmAEBBH8gACgCACEAAkAgAUEKRgRAQf8BIQIgACgCJEEKayIAQQZPDQFCmMDAgYSGECAAQQN0rYinIQIMAQsgACgCQCIDRQ0AIABBQGsiBCEAA0AgACADIAMoAhAgAUgiBRshACADIAVBAnRqKAIAIgMNAAsgACAERg0AIAAoAhAgAUoNACAALQAYQQdqQXhxIQILIAJB/wFxC9ECAQR/IwBBIGsiBiQAAkACQCABKAIAIgcoAhgiCEEASgRAIAcoAhwiCUEASg0BCyAAQoWAgICQEDcCACAAQf/KADYCCAwBCyAGQQRqIAcgAiAIIANBf3NqIAQgCSAFQX9zakEAEI0DAkAgBigCDARAIAAgBkEMaiABKAIAIgBBCGpBACAAGxBBDAELIAYoAgQhAiAGKAIIIgMEQCADIAMoAgRBAWo2AgQLIAEgAjYCACABKAIEIQIgASADNgIEAkAgAkUNACACIAIoAgQiAUEBazYCBCABDQAgAiACKAIAKAIIEQAAIAIQKwsgAEHk7AQpAgA3AgAgAEHs7AQoAgA2AggLIAYsAB9BAEgEQCAGKAIcGiAGKAIUECoLIAYoAggiAEUNACAAIAAoAgQiAUEBazYCBCABDQAgACAAKAIAKAIIEQAAIAAQKwsgBkEgaiQACzkBAX8gACgCACIAKAIgQQFGBEBBBEEKIAAoAiRBA0YbIQELQX8gACABEKUBIgAgAEEASBtBfyAAGws5AQF/IAAoAgAiACgCIEEBRgRAQQRBCiAAKAIkQQNGGyEBC0F/IAAgARCmASIAIABBAEgbQX8gABsLGwBBfyAAKAIAIAEQpQEiACAAQQBIG0F/IAAbCxsAQX8gACgCACABEKYBIgAgAEEASBtBfyAAGwsKACAAKAIAKAIgCxUAIAAoAgAiACACNgJMIAAgATYCSAvFAQECfwJAIAAoAgAiAygCGCIAIAMoAhwiBEcEQANAAkAgACgCACIDRQ0AIANBoL8EQcjPBBA5IgNFDQAgACgCBCIADQMgASADKAJkNgIAIAIgAygCaDYCAEEBDwsgAEEIaiIAIARHDQALCyABQQE2AgAgAkEBNgIAQQAPCyAAIAAoAgRBAWo2AgQgASADKAJkNgIAIAIgAygCaDYCACAAIAAoAgQiAUEBazYCBCABRQRAIAAgACgCACgCCBEAACAAECsLQQELGwAgASAAKAIAIgAoAkg2AgAgAiAAKAJMNgIAC5YEAQF/AkAgAUUNACACRQ0AIAJDAAAAACABLwEAIgO4RPFo44i1+PQ+orYgA0H33gFqQf//A3FB/N4BSRs4AgAgAkMAAAAAIAEvAQYiA7hE8WjjiLX49D6itiADQe+3AWpB//8DcUH0twFJGzgCDCACQwAAAAAgAS8BAiIDuETxaOOItfj0PqK2IANB994BakH//wNxQfzeAUkbOAIEIAJDAAAAACABLwEIIgO4RPFo44i1+PQ+orYgA0HvtwFqQf//A3FB9LcBSRs4AhAgAkMAAAAAIAEvAQQiA7hE8WjjiLX49D6itiADQffeAWpB//8DcUH83gFJGzgCCCACQwAAAAAgAS8BCiIDuETxaOOItfj0PqK2IANB77cBakH//wNxQfS3AUkbOAIUIAJDAAAAACABLwEMIgO4RPFo44i1+PQ+orYgA0H33gFqQf//A3FB/N4BSRs4AhggAkMAAAAAIAEvAQ4iA7hE8WjjiLX49D6itiADQe+3AWpB//8DcUH0twFJGzgCHCACRAAAAAAAAAAAIAEoAhAiA7hELUMc6+I2Gj+iIANBgcLXL2tBz8SrUEkbOQMgIAJEAAAAAAAAAAAgASgCFCIBuEQtQxzr4jYaP6IgAUHRhgNrQbD5fEkbOQMoIABB7OwEKAIANgIIIABB5OwEKQIANwIADwsgAEHw7AQpAgA3AgAgAEH47AQoAgA2AggLMQAgAQRAIAAoAgAiACABKQIANwJUIAAgASkCEDcCZCAAIAEpAgg3AlwgAEEBOgBsCwu7AQECfwJAIAAoAgAiAigCGCIAIAIoAhwiAkcEQANAAkAgACgCACIDRQ0AIANBoL8EQeTQBBA5IgNFDQAgACgCBCICBEAgAiACKAIEQQFqNgIECyABBEAgASADKQJkNwIAIAEgAykCdDcCECABIAMpAmw3AggLQQEhACACRQ0DIAIgAigCBCIBQQFrNgIEIAENAyACIAIoAgAoAggRAAAgAhArQQEPCyAAQQhqIgAgAkcNAAsLQQAhAAsgAAsvAQJ+IAAoAgAiACkCXCECIAApAlQhAyABIAApAmQ3AhAgASACNwIIIAEgAzcCAAsKACAAKAIALQBsCxQAIAEEQCAAKAIAIAEoAQA2AlALC6cBAQJ/AkAgACgCACICKAIYIgAgAigCHCICRwRAA0ACQCAAKAIAIgNFDQAgA0GgvwRB2NAEEDkiA0UNACAAKAIEIgIEQCACIAIoAgRBAWo2AgQLIAEEQCABIAMoAWI2AQALQQEhACACRQ0DIAIgAigCBCIBQQFrNgIEIAENAyACIAIoAgAoAggRAAAgAhArQQEPCyAAQQhqIgAgAkcNAAsLQQAhAAsgAAsUACABBEAgASAAKAIAKAJQNgEACwsVACAAKAIAIgAvAVAgAC8BUnJBAEcLoQEBBX8jAEEQayIFJAAgACgCACIGKAJ0IAYoAnAiB2tBFG0hBAJAIANFDQAgASAETiEIQQAhBCAIDQADQCAFQQRqIAcgASAEakEUbGogACgCACIDQQhqQQAgAxsQQSACIARBDGxqIgMgBSgCDDYCCCADIAUpAgQ3AgAgBEEBaiIEIAFqIAYoAnQgBigCcCIHa0EUbUgNAAsLIAVBEGokACAEC/ADAQJ/IwBB0ABrIggkAAJAIAFFBEAgAEHw7AQpAgA3AgAgAEH47AQoAgA2AggMAQsgASgCACgCJCEJIAhCADcDMCAIQgA3AyggCEIANwM4IAhCADcDSCAIQUBrQoKAgIAgNwMAIAhCADcCLCAIQQA7ATQgCEIANwMgIAhCADcCJCAIQQY6ACAgCEEBOgA8AkAgBUUNAAJAAkACQAJAAkACQCAFLQAAQQFrDgYFBAMCAQAGCyAIIAUoAiw2AkwLIAggBSkCHDcCPCAIIAUpAiQ3AkQLIAggBSgCGDYCOAsgCCAFLQAVOgA1CyAIIAUtABQ6ADQLIAggBS0AAToAISAIIAUoAgQ2AiQgCCAFKAIINgIoIAggBSgCDDYCLCAIIAUoAhA2AjALIAhBBGogASgCCCAJIAMgBCAIQSBqQQEgBiAHEMIEIAAgCCgCDAR/IAhBDGoFIAgoAgQhAyAIKAIIIgAEQCAAIAAoAgRBAWo2AgQLIAJBCBAsIgI2AgAgAiAANgIEIAIgAzYCAEGQpQULIAEoAgAiAEEEakEAIAAbEEEgCCwAH0EASARAIAgoAhwaIAgoAhQQKgsgCCgCCCIARQ0AIAAgACgCBCIBQQFrNgIEIAENACAAIAAoAgAoAggRAAAgABArCyAIQdAAaiQAC00BAX9BMBAsIgBBADYCGCAAQQY7AQAgAEIANwIEIABBADYCLCAAQQA6ACggAEKCgICAIDcCICAAQQE6ABwgAEIANwIMIABBADsBFCAACxsAIABBAToADCAAQoKAgIAgNwIEIABBAToAAAs+AQF/IABBpLwENgIAIAAoAjAiAQRAIAEQKgsgAEGovQQ2AgAgACwAF0EASARAIAAoAhQaIAAoAgwQKgsgAAupAwEDfyMAQSBrIgUkAAJAIANFBEAgAEKFgICAkPoBNwIAIABB0KEBNgIIDAELIAEoAgAiBCgCUCEGIAQoAlQiBARAIAQgBCgCBEEBajYCBAsCQCACIAYoAiRHBEAgA0EANgIAIAVBADoAACAFQQA6AAsgBUEMakEFQdAPIAUQLyECIAUsAAtBAEgEQCAFKAIIGiAFKAIAECoLIAAgAiABKAIAIgBBBGpBACAAGxBBIAIsABNBAE4NASACKAIQGiACKAIIECoMAQtBEBAsIgJCADcCCCADIAI2AgAgBARAIAQgBCgCBEEBajYCBAsgAiAENgIEIAIgBjYCACABKAIIIQIgAygCACEDIAEoAgwiBgRAIAYgBigCBEEBajYCBAsgAyACNgIIIAMoAgwhAiADIAY2AgwCQCACRQ0AIAIgAigCBCIDQQFrNgIEIAMNACACIAIoAgAoAggRAAAgAhArCyAAQZClBSABKAIAIgBBBGpBACAAGxBBCyAERQ0AIAQgBCgCBCIAQQFrNgIEIAANACAEIAQoAgAoAggRAAAgBBArCyAFQSBqJAALcAECfyAAKAIAIgAoAlAhAyAAKAJUIgAEQCAAIAAoAgRBAWo2AgQLAkAgAkUNACADRQ0AIAEgAygCJDYCAEEBIQQLAkAgAEUNACAAIAAoAgQiAUEBazYCBCABDQAgACAAKAIAKAIIEQAAIAAQKwsgBAs9AQJ/IAAoAgAiACgCUCECAkAgACgCVCIARQ0AIAAoAgRBf0cNACAAIAAoAgAoAggRAAAgABArCyACQQBHC+gBAQJ/IAJFBEBBAA8LAkACQCAAKAIAIgEtAExBAUYEQCAAKAIEIgANAUEAIQAMAgsgASgCVCEAIAEoAlAhASAADQBBACEADAELIAAgACgCBEEBajYCBAsgAS0AWEEBRgRAQTgQLCIDIAEpA5ABNwMwIAMgASkDiAE3AyggAyABKQOAATcDICADIAEpA3g3AxggAyABKQNwNwMQIAMgASkDaDcDCCADIAEpA2A3AwBBASEECyACIAM2AgACQCAARQ0AIAAgACgCBCIBQQFrNgIEIAENACAAIAAoAgAoAggRAAAgABArCyAECw0AIAAoAgAoAlBBAEcLFAAgACgCACIAIAAoAgAoAigRAQALFAAgACgCACIAIAAoAgAoAiQRAQALCgAgACgCAC0AQQuFBwIKfwF+IAAoAgghBCAAKAIAKAIkIQMjAEGAAWsiASQAAkAgBCgCFCICRQ0AIARBFGoiByEAA0AgACACIAIoAhAgA0kiBhshACACIAZBAnRqKAIAIgINAAsgACAHRg0AIAAoAhAgA0sNACAAKAIUIQIgACgCGCIGBEAgBiAGKAIEQQFqNgIEC0EBIQUCQCACKAJEDQAgAiACKAIAKAI4EQEADQAgAUHgAGogAiABQfwAaiABQfgAaiACKAIAKAIwEQYAQQAhBQJAIAEoAmANACABKAJ4IgBBD00EQEEBIQVBASAAdEGA0AJxDQELQQAhBSAEKAIwIAMQ5wFB5NLJuwZHDQAgAUEANgJcIAFCADcCVCABQUBrIAQoAjAgAyABQdQAaiIAEIECAkAgASgCQA0AIAFBADYCOCABQgA3AzAgAUEYaiABQTBqIAAQpQYgASABKQMYIgs3A2AgASwAc0EATgR/IAunBSABKAJwGiABKAJoECogASgCYAshCiABIAEpAyA3A2ggASABKAIoNgJwIAoNACABIAQoAjAiACgCVCICNgIQIAEgACgCWCIANgIUIAAEQCAAIAAoAgRBAWo2AgQLAkAgAkUNACABQRhqIAIgA0Hn2qWjBhC6AQJAIAEvATIgAS8BMGwgASgCHCIIIAEoAhgiA2tBAnVHDQAgAyAIRiICDQAgAyEAA0AgBCAAKAIAEMUERQ0BIABBBGoiACAIRw0ACyACDQADQAJAIAcoAgAiAEUEQEEAIQUMAQsgAygCACEEIAchAgNAIAIgACAAKAIQIARJIgkbIQIgACAJQQJ0aigCACIADQALIAIgB0YEQEEAIQUMAQsgAigCECAESwRAQQAhBQwBCyABIAIoAhQiBDYCCCABIAIoAhgiADYCDCAABEAgACAAKAIEQQFqNgIECyAFIAQoAkRBAEdyIQUgAUEIahBtIANBBGoiAyAIRw0BCwsgASgCGCEDCyADRQ0AIAEgAzYCHCABKAIgGiADECoLIAFBEGoQbQsgASwAU0EASARAIAEoAlAaIAEoAkgQKgsgASgCVCIARQ0AIAEgADYCWCABKAJcGiAAECoLIAEsAHNBAE4NACABKAJwGiABKAJoECoLIAZFDQAgBiAGKAIEIgBBAWs2AgQgAA0AIAYgBigCACgCCBEAACAGECsLIAFBgAFqJAAgBUEBcQuDAQEDfyMAQSBrIgQkACAEQQxqIgUgASgCACIGIAIgAyAGKAIAKAIwEQYAAkAgBCgCDARAIAAgBSABKAIAIgBBBGpBACAAGxBBDAELIABB5OwEKQIANwIAIABB7OwEKAIANgIICyAELAAfQQBIBEAgBCgCHBogBCgCFBAqCyAEQSBqJAALQQECfwJAAkAgAUEASgRAA0AgACACQQR0aigCCCIDBEAgAxAqCyACQQFqIgIgAUcNAAwCCwALIABFDQELIAAQKgsL0QoBEH8jAEEgayIFJAAgACgCACIAKAIwIQQgACgCNCIABEAgACAAKAIEQQFqNgIECyAEKAJsIQcgBCgCcCIIBEAgCCAIKAIEQQFqNgIECwJAIABFDQAgACAAKAIEIgRBAWs2AgQgBA0AIAAgACgCACgCCBEAACAAECsLAkAgB0UEQEEAIQcgA0EANgIADAELQQAhBCAFQQA2AhwgBUIANwIUAkACQAJAIAcoAigiBiAHKAIkIgBHBEAgBiAAayIEQQBIDQEgBSAEECwiBzYCFCAFIAQgB2o2AhwgByEEA0AgBCIKIAAoAgA2AgAgBCAAKAIEIgQ2AgQgBARAIAQgBCgCBEEBajYCBAsgCkEIaiEEIABBCGoiACAGRw0ACyAFIAQ2AhggBUEANgIQIAVCADcCCANAIAcoAgAhAAJAAkACQAJAIAEEQCAAKAIQIAFGDQEMBAsgAEUNAQsgAEGgvwRB0MsEEDkiBkUNACAFIAY2AgAgBSAHKAIEIgA2AgQgAEUNASAAIAAoAgRBAWo2AgQMAQsgBUIANwIAQQAhBgsCQAJAIAJFDQAgBigCbCIAIAYoAnAiBEYNAQNAIAAoAgAgAkYNASAEIABBBGoiAEcNAAsMAQsgBQJ/IAUoAgwiACAFKAIQSQRAIAAgBjYCACAAIAUoAgQiBDYCBCAEBEAgBCAEKAIEQQFqNgIECyAAQQhqDAELIAVBCGogBRBhCzYCDAsgBSgCBCIARQ0AIAAgACgCBCIEQQFrNgIEIAQNACAAIAAoAgAoAggRAAAgABArCyAHIApGIRMgB0EIaiEHIBNFDQALDAILIANBADYCAEEAIQcMAgsQNgALQX8gBSgCDCIKIAUoAggiAWsiAEEBdCAAQQN1IgtB/////wBLGxAsIQcCQAJAIAEgCkYiEEUEQEEBIAsgC0EBTRshEQNAIAcgDEEEdGoiBiABIAxBA3RqKAIAIgAoAmg2AgAgBiAAKAIQNgIEAn8gACgCbCICIAAoAnAiBEYEQEEAIQQgAgwBC0F/IAQgAmsiAiACQQBIGxAsIQQgACgCbCECIAAoAnALIQAgBiAENgIIIAYgACACa0ECdSIGNgIMAkAgBEUNACAAIAJGDQBBASAGIAZBAU0bIglBA3EhDkEAIQ9BACEAIAZBBE8EQCAJQXxxIRJBACEGA0AgBCAAQQJ0IglqIAIgCWooAgA2AgAgBCAJQQRyIg1qIAIgDWooAgA2AgAgBCAJQQhyIg1qIAIgDWooAgA2AgAgBCAJQQxyIglqIAIgCWooAgA2AgAgAEEEaiEAIAZBBGoiBiASRw0ACwsgDkUNAANAIAQgAEECdCIGaiACIAZqKAIANgIAIABBAWohACAPQQFqIg8gDkcNAAsLIAxBAWoiDCARRw0ACyADIAs2AgAgAUUNAiAQBEAgASEADAILA0ACQCAKQQRrKAIAIgBFDQAgACAAKAIEIgJBAWs2AgQgAg0AIAAgACgCACgCCBEAACAAECsLIApBCGsiCiABRw0ACyAFKAIIIQAMAQsgAyALNgIAIAEiAEUNAQsgBSABNgIMIAUoAhAaIAAQKgsgBSgCFCEECyAERQ0AIAQhAiAEIAUoAhgiAEcEQANAAkAgAEEEaygCACIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCyAAQQhrIgAgBEcNAAsgBSgCFCECCyAFIAQ2AhggBSgCHBogAhAqCwJAIAhFDQAgCCAIKAIEIgBBAWs2AgQgAA0AIAggCCgCACgCCBEAACAIECsLIAVBIGokACAHC9cCAQJ/IwBBIGsiBiQAIAYgBDYCGCAGIAM2AhwCQCABQQAgBRtFBEAgAEEANgIIIABChYCAgJD6ATcCAAwBCwJAIAEoAgAiB0UNACAHQfCEBUGgigUQOSIHRQ0AIAEoAgQiAQRAIAEgASgCBEEBajYCBAsCQAJAIAMgBy8B9gJJBEAgBy8B9AIgBEsNAQsgAEIFNwIAIABBzdcANgIIDAELAkAgAkUNACAGQQRqIAcgBkEcaiAGQRhqEKYGIAYsABdBAE4NACAGKAIUGiAGKAIMECoLIAUgBygCgAMgBigCGCAHLwH2AmxBAnRqIAYoAhxBAnRqKAIANgIAIABBpPEEKAIANgIIIABBnPEEKQIANwIACyABRQ0BIAEgASgCBCIAQQFrNgIEIAANASABIAEoAgAoAggRAAAgARArDAELIABCBTcCACAAQczeADYCCAsgBkEgaiQAC+gKAQ5/IwBB0ABrIg4kAAJAIAFBACADG0UEQCAAQoWAgICQ+gE3AgAgAEH8oAE2AggMAQsgDkEIaiINIAEoAgAiCCAIKAIAKAJIEQIAIAMgDUHIABAyIQcgAgRAIAEoAgAhA0EAIQIjAEEwayIFJAAgBUEQaiADEPECAkAgBSgCHARAIA0gBSkCHDcCACANQQhqIQIgBSwAL0EATgRAIAIgBSkCJDcCACACIAUoAiw2AggMAgsgAiAFKAIkIAUoAigQLgwBCwJ/QQAgBygCDCIDRQ0AGkEAIAcoAhAiCEUNABogBygCFCADcCECIAcoAhggCHALIQNBACEIIAUoAhAiCiAFKAIUIhBHBEADQCADIQkgAiELIAwhBAJAIAooAgAiBkUNACAGQaC/BEGgyAQQOSIPBEAgCigCBCIGBEAgBiAGKAIEQQFqNgIECwJAAkACQAJAIA8oAmQiAkGOAkYiA0UEQCACQbQBRg0BIAJB2gBHDQMLIAcgBykCDEIgiTcCDCAHIAcpAhRCIIk3AhQgByAHKQIEQiCJNwIEIAJB2gBGBEAgCCEDIAkhAiALIQwgBCEIDAQLIAMNASACQbQBRw0CCyAEIQMgCCECIAkhDCALIQgMAgsgCyEDIAQhAiAIIQwgCSEIDAELIAkhAyALIQIgBCEMCwJAIAZFDQAgBiAGKAIEIglBAWs2AgQgCQ0AIAYgBigCACgCCBEAACAGECsLIAooAgAiBkUNAQsCQCAGQaC/BEHoyAQQOSIGRQRAIAIhCSADIQsMAQsgCigCBCIEBEAgBCAEKAIEQQFqNgIECyADIQsgAiEJAkACQAJAIAYoAmQOAgEAAgsgCCEJIAIhCAwBCyAMIQsgAyEMCyAERQ0AIAQgBCgCBCICQQFrNgIEIAINACAEIAQoAgAoAggRAAAgBBArCwJAIAooAgAiAkUNACACQaC/BEGwyQQQOSICRQ0AIAooAgQiBARAIAQgBCgCBEEBajYCBAsgAiAHKAIUEI0CIQMgAiAHKAIUELEDIQYgAiAHKAIYEIoCIQ8gAiAHKAIYEK0DIQICQCADQQAgA0EAShsiESAGIAcoAhQiA0EBayADIAZLGyIGTARAIA9BACAPQQBKGyIPIAIgBygCGCIDQQFrIAIgA0kbIgJMDQELIAVBADoABCAFQQA6AA8gDUECQfgAIAVBBGoQLxogBSwAD0EASARAIAUoAgwaIAUoAgQQKgsgBEUNBSAEIAQoAgQiAkEBazYCBCACDQUgBCAEKAIAKAIIEQAAIAQQKwwFCyACIAtqIQMgDCAPaiEMIAYgCWohAiAIIBFqIQggBEUNASAEIAQoAgQiCUEBazYCBCAJDQEgBCAEKAIAKAIIEQAAIAQQKwwBCyAJIQIgCyEDCyAKQQhqIgogEEcNAAsLIAcgDDYCHCAHIAg2AiAgDUGQpQUpAgA3AgAgDUEIaiECQaOlBSwAAEEATgRAIAJBmKUFKQIANwIAIAJBoKUFKAIANgIIDAELIAJBmKUFKAIAQZylBSgCABAuCyAFLAAvQQBIBEAgBSgCLBogBSgCJBAqCyAFKAIQIgMEQCAFKAIUIgogAyICRwRAA0ACQCAKQQRrKAIAIgJFDQAgAiACKAIEIghBAWs2AgQgCA0AIAIgAigCACgCCBEAACACECsLIApBCGsiCiADRw0ACyAFKAIQIQILIAUgAzYCFCAFKAIYGiACECoLIAVBMGokACAOKAIIIgIEQCAAIA0gASgCCBBBCyAOLAAbQQBIBEAgDigCGBogDigCEBAqCyACDQELIABBnPEEKQIANwIAIABBpPEEKAIANgIICyAOQdAAaiQACzgBAn9BCBAsIQEgACgCCCECIAAoAgwiAARAIAAgACgCBEEBajYCBAsgASAANgIEIAEgAjYCACABCx8BAX8CQCAARQ0AIAAoAgAiAEUNACAAEOQDIQELIAELHwEBfwJAIABFDQAgACgCACIARQ0AIAAQ5QMhAQsgAQuvBgEHfyMAQTBrIgQkAAJAAkAgA0UEQCAEQQA6ABAgBEEAOgAbIAAgBEEcakEFQdEPIARBEGoQLyIAIAEoAgAiAUEEakEAIAEbEEEgACwAE0EASARAIAAoAhAaIAAoAggQKgsgBCwAG0EATg0BIAQoAhgaIAQoAhAQKgwBCyADQQA2AgAgASgCACEFIARBADYCGCAEQgA3AhACQCAFKAKsASIIIAUoAqgBIgdHBEAgCCAHayIFQQBIDQMgBCAFECwiBjYCECAEIAUgBmo2AhggBiEFA0AgBSIJIAcoAgA2AgAgBSAHKAIEIgU2AgQgBQRAIAUgBSgCBEEBajYCBAsgCUEIaiEFIAdBCGoiByAIRw0ACyAEIAU2AhQgBiEHA0AgAiAHKAIAIggoAiRGBEBBEBAsIgJCADcCACACQgA3AgggAyACNgIAAkAgBygCBCIFRQRAIAIgBTYCBCACIAg2AgAMAQsgBSAFKAIEQQFqNgIEIAIgCDYCACACKAIEIQYgAiAFNgIEIAZFDQAgBiAGKAIEIgJBAWs2AgQgAg0AIAYgBigCACgCCBEAACAGECsLIAEoAgghAiADKAIAIQMgASgCDCIGBEAgBiAGKAIEQQFqNgIECyADIAI2AgggAygCDCECIAMgBjYCDAJAIAJFDQAgAiACKAIEIgNBAWs2AgQgAw0AIAIgAigCACgCCBEAACACECsLIABBkKUFIAEoAgAiAEEEakEAIAAbEEEgBCgCECEGDAMLIAcgCUchCiAHQQhqIQcgCg0ACwsgBEEAOgAEIARBADoADyAEQRxqQQVB0A8gBEEEahAvIQIgBCwAD0EASARAIAQoAgwaIAQoAgQQKgsgACACIAEoAgAiAEEEakEAIAAbEEEgAiwAE0EATg0AIAIoAhAaIAIoAggQKgsgBkUNACAGIQAgBiAEKAIUIgdHBEADQAJAIAdBBGsoAgAiAEUNACAAIAAoAgQiAUEBazYCBCABDQAgACAAKAIAKAIIEQAAIAAQKwsgB0EIayIHIAZHDQALIAQoAhAhAAsgBCAGNgIUIAQoAhgaIAAQKgsgBEEwaiQADwsQNgALmgMBBH8jAEEgayIDJAACQCACRQRAIANBADoAACADQQA6AAsgACADQQxqQQVB0Q8gAxAvIgAgASgCACIBQQRqQQAgARsQQSAALAATQQBIBEAgACgCEBogACgCCBAqCyADLAALQQBODQEgAygCCBogAygCABAqDAELIAJBADYCACABKAIAIgQoAqABIAQsAKcBIgUgBUEASCIFG0EBahBVIgZFBEAgA0EwECwiAjYCACADQq2AgICAhoCAgH83AgQgAkHlxwApAAA3ACUgAkHgxwApAAA3ACAgAkHYxwApAAA3ABggAkHQxwApAAA3ABAgAkHIxwApAAA3AAggAkHAxwApAAA3AAAgAkEAOgAtIAAgA0EMakEGQQAgAxAvIgAgASgCACIBQQRqQQAgARsQQSAALAATQQBIBEAgACgCEBogACgCCBAqCyADLAALQQBODQEgAygCCBogAygCABAqDAELIAIgBiAEKAKcASAEQZwBaiAFGxD3ATYCACAAQezsBCgCADYCCCAAQeTsBCkCADcCAAsgA0EgaiQAC5oDAQd/IwBBEGsiBCQAAkAgAkUNACAEQQRqIAAoAgAgARCdBAJAIAQoAggiACAEKAIEIgFrQQN1IgUgAyADIAVKGyIFQQBKBEBBACEDIAVBBE8EQCAFQfz///8HcSEHA0AgAiADQQJ0aiABIANBA3RqKAIAKAIkNgIAIAIgA0EBciIGQQJ0aiABIAZBA3RqKAIAKAIkNgIAIAIgA0ECciIGQQJ0aiABIAZBA3RqKAIAKAIkNgIAIAIgA0EDciIGQQJ0aiABIAZBA3RqKAIAKAIkNgIAIANBBGohAyAIQQRqIgggB0cNAAsLIAVBA3EiB0UNAQNAIAIgA0ECdGogASADQQN0aigCACgCJDYCACADQQFqIQMgCUEBaiIJIAdHDQALDAELIAFFDQELIAAgAUYEfyABBQNAAkAgAEEEaygCACICRQ0AIAIgAigCBCIDQQFrNgIEIAMNACACIAIoAgAoAggRAAAgAhArCyAAQQhrIgAgAUcNAAsgBCgCBAshCiAEIAE2AgggBCgCDBogChAqCyAEQRBqJAAgBQulAQEEfyMAQRBrIgIkACACQQRqIAAoAgAgARCdBCACKAIIIQQgAigCBCIBBEAgASIAIARHBEAgBCEAA0ACQCAAQQRrKAIAIgNFDQAgAyADKAIEIgVBAWs2AgQgBQ0AIAMgAygCACgCCBEAACADECsLIABBCGsiACABRw0ACyACKAIEIQALIAIgATYCCCACKAIMGiAAECoLIAJBEGokACAEIAFrQQN1C6YGAQd/IwBBMGsiBCQAAkACQCADRQRAIARBADoAECAEQQA6ABsgACAEQRxqQQVB0Q8gBEEQahAvIgAgASgCACIBQQRqQQAgARsQQSAALAATQQBIBEAgACgCEBogACgCCBAqCyAELAAbQQBODQEgBCgCGBogBCgCEBAqDAELIAEoAgAhBSAEQQA2AhggBEIANwIQAkAgBSgCOCIIIAUoAjQiB0cEQCAIIAdrIgVBAEgNAyAEIAUQLCIGNgIQIAQgBSAGajYCGCAGIQUDQCAFIgkgBygCADYCACAFIAcoAgQiBTYCBCAFBEAgBSAFKAIEQQFqNgIECyAJQQhqIQUgB0EIaiIHIAhHDQALIAQgBTYCFCAGIQcDQCACIAcoAgAiCCgCJEYEQEEQECwiAkIANwIAIAJCADcCCCADIAI2AgACQCAHKAIEIgVFBEAgAiAFNgIEIAIgCDYCAAwBCyAFIAUoAgRBAWo2AgQgAiAINgIAIAIoAgQhBiACIAU2AgQgBkUNACAGIAYoAgQiAkEBazYCBCACDQAgBiAGKAIAKAIIEQAAIAYQKwsgASgCCCECIAMoAgAhAyABKAIMIgYEQCAGIAYoAgRBAWo2AgQLIAMgAjYCCCADKAIMIQIgAyAGNgIMAkAgAkUNACACIAIoAgQiA0EBazYCBCADDQAgAiACKAIAKAIIEQAAIAIQKwsgAEGQpQUgASgCACIAQQRqQQAgABsQQSAEKAIQIQYMAwsgByAJRyEKIAdBCGohByAKDQALCyAEQQA6AAQgBEEAOgAPIARBHGpBBUHQDyAEQQRqEC8hAiAELAAPQQBIBEAgBCgCDBogBCgCBBAqCyAAIAIgASgCACIAQQRqQQAgABsQQSACLAATQQBODQAgAigCEBogAigCCBAqCyAGRQ0AIAYhACAGIAQoAhQiB0cEQANAAkAgB0EEaygCACIARQ0AIAAgACgCBCIBQQFrNgIEIAENACAAIAAoAgAoAggRAAAgABArCyAHQQhrIgcgBkcNAAsgBCgCECEACyAEIAY2AhQgBCgCGBogABAqCyAEQTBqJAAPCxA2AAuaBAEIfyMAQRBrIgUkAAJAAkAgAUUEQEEAIQIMAQsgACgCACEAIAVBADYCDCAFQgA3AgQgACgCOCIGIAAoAjQiA0cEQCAGIANrIgBBAEgNAiAFIAAQLCIENgIEIAUgACAEajYCDCAEIQADQCAAIAMoAgA2AgAgACADKAIEIgc2AgQgBwRAIAcgBygCBEEBajYCBAsgAEEIaiEAIANBCGoiAyAGRw0ACyAFIAA2AggCQCAAIARrQQN1IgMgAiACIANKGyICQQBMDQBBACEHQQAhAyACQQRPBEAgAkH8////B3EhCUEAIQYDQCABIANBAnRqIAQgA0EDdGooAgAoAiQ2AgAgASADQQFyIghBAnRqIAQgCEEDdGooAgAoAiQ2AgAgASADQQJyIghBAnRqIAQgCEEDdGooAgAoAiQ2AgAgASADQQNyIghBAnRqIAQgCEEDdGooAgAoAiQ2AgAgA0EEaiEDIAZBBGoiBiAJRw0ACwsgAkEDcSIGRQ0AA0AgASADQQJ0aiAEIANBA3RqKAIAKAIkNgIAIANBAWohAyAHQQFqIgcgBkcNAAsLA0AgAEEIayEKAkAgAEEEaygCACIARQ0AIAAgACgCBCIDQQFrNgIEIAMNACAAIAAoAgAoAggRAAAgABArCyAKIgAgBEcNAAsgBSgCDBogBSgCBBAqDAELIAJBH3UgAnEhAgsgBUEQaiQAIAIPCxA2AAsVACAAKAIAIgAoAjggACgCNGtBA3ULxQEBBX8jAEEQayICJAAgAkEEaiAAKAIAEMACAkAgAigCBCIDIAIoAggiBEYiBQ0AIAMhAANAIAAoAgAoAiQgAUYiBg0BIABBCGoiACAERw0ACwsgAwRAIAMhACAFRQRAA0ACQCAEQQRrKAIAIgBFDQAgACAAKAIEIgFBAWs2AgQgAQ0AIAAgACgCACgCCBEAACAAECsLIARBCGsiBCADRw0ACyACKAIEIQALIAIgAzYCCCACKAIMGiAAECoLIAJBEGokACAGC7MCAQJ/IwBBMGsiAyQAAkAgAkUEQCADQQA6ABAgA0EAOgAbIAAgA0EcakEFQdEPIANBEGoQLyIAIAEoAgAQQSAALAATQQBIBEAgACgCEBogACgCCBAqCyADLAAbQQBODQEgAygCGBogAygCEBAqDAELIANBCGogASgCABDGBAJAIAMoAggiBEUEQCADQQA6ABAgA0EAOgAbIAAgA0EcakECQfwAIANBEGoQLyIAIAEoAgAQQSAALAATQQBIBEAgACgCEBogACgCCBAqCyADLAAbQQBODQEgAygCGBogAygCEBAqDAELIAIgBCgCJDYCACAAQZClBSABKAIAEEELIAMoAgwiAEUNACAAIAAoAgQiAUEBazYCBCABDQAgACAAKAIAKAIIEQAAIAAQKwsgA0EwaiQAC5MHAQl/IwBBEGsiBSQAAkAgAEUNACAFQQRqIgohBiAAKAIAKAIwIQAjAEGgAWsiAiQAIAJBoNMDNgIYIAJBtNMDNgJQIAJBxNMDKAIAIgM2AhAgAkEQaiIIIANBDGsoAgBqQcjTAygCADYCACACQQA2AhQgCCACKAIQQQxrKAIAaiIDIAJBHGoiBBA+IANCgICAgHA3AkggAkHM0wMoAgAiBzYCGCACQRhqIgMgB0EMaygCAGpB0NMDKAIANgIAIAJBwNMDKAIAIgc2AhAgCCAHQQxrKAIAakHU0wMoAgA2AgAgAkG00wM2AlAgAkGM0wM2AhAgAkGg0wM2AhggBBA/IghB8MsDNgIAIAJCADcCRCACQgA3AjwgAkEYNgJMAkACfwJAIAAoAhAiBCAAKAIUIgdHBEAgBCgCACIAKAIAKAIIIQkgAkEANgIMIAIgACACQQxqIAkRAwAgAyACKAIAIAIgAiwACyIAQQBIIgkbIAIoAgQgACAJGxAtGiACLAALQQBIBEAgAigCCBogAigCABAqCyAHIARBCGoiAEcEQANAIANBz5ACQQEQLRogAkEANgIMIAIgACgCACIEIAJBDGogBCgCACgCCBEDACADIAIoAgAgAiACLAALIgRBAEgiCRsgAigCBCAEIAkbEC0aIAIsAAtBAEgEQCACKAIIGiACKAIAECoLIABBCGoiACAHRw0ACwsgAigCTCIAQRBxRQ0BCyACKAJIIgAgAigCNCIDSQRAIAIgAzYCSCADIQALIAJBMGoMAQsgAEEIcUUEQEEAIQAgBkEAOgALDAILIAIoAiwhACACQSRqCyEDAkAgACADKAIAIgRrIgBB+P///wdJBEAgAEELTwRAIABBB3JBAWoiBxAsIQMgBiAHQYCAgIB4cjYCCCAGIAM2AgAgBiAANgIEIAMhBgwCCyAGIAA6AAsgAA0BQQAhAAwCCxA4AAsgBiAEIAAQNxoLIAAgBmpBADoAACACQbzTAygCACIANgIQIABBDGsoAgAgAkEQampB3NMDKAIANgIAIAJB4NMDKAIANgIYIAhB8MsDNgIAIAIsAEdBAEgEQCACKAJEGiACKAI8ECoLIAgQPRogAkHQAGoQOxogAkGgAWokACABIAUoAgQgCiAFLAAPIgBBAEgiARsgBSgCCCAAIAEbENwFGiAFLAAPQQBODQAgBSgCDBogBSgCBBAqCyAFQRBqJAAL4AMBBX8jAEEgayIEJABBLBAsIgVCADcCBCAFQbDwBDYCACAFQQxqIgZBqL0ENgIAIAVCADcCECAFQQA2AiAgBUIANwIYIAUgAzYCKCAFIAI2AiQgBUHQvAQ2AgwgASgCACECIAQgBTYCCCAEIAY2AgQgBSAFKAIEQQFqNgIEIARBDGohCCAEQQRqIQkjAEEgayIDJABBmAEQLCIHQgA3AgQgB0H84wQ2AgAgAiAHQQxqEL0CNgIwIAIoAjQhBiACIAc2AjQCQCAGRQ0AIAYgBigCBCIHQQFrNgIEIAcNACAGIAYoAgAoAggRAAAgBhArCyACKAIwIgYgAkFAazYCiAEgA0EIaiAGIAkQlAMCQCADKAIIBEAgCCADKQMINwIAIAggAykDEDcCCCAIIAMoAhg2AhAMAQsgCCACEJsDIAMsABtBAE4NACADKAIYGiADKAIQECoLIANBIGokAAJAIAQoAggiAkUNACACIAIoAgQiA0EBazYCBCADDQAgAiACKAIAKAIIEQAAIAIQKwsgACAEQQxqIAEoAgAQQSAELAAfQQBIBEAgBCgCHBogBCgCFBAqCyAFIAUoAgQiAEEBazYCBCAARQRAIAUgBSgCACgCCBEAACAFECsLIARBIGokAAtMAQF/IwBBIGsiBCQAIARBDGoiBSABKAIAIAIgA0EAEJcDIAAgBSABKAIAEEEgBCwAH0EASARAIAQoAhwaIAQoAhQQKgsgBEEgaiQAC0wBAX8jAEEgayIEJAAgBEEMaiIFIAEoAgAgAiADQQEQlwMgACAFIAEoAgAQQSAELAAfQQBIBEAgBCgCHBogBCgCFBAqCyAEQSBqJAALjw4BE38jAEEgayIDJAAgA0EMaiENIAEoAgAhCyACIQQjAEEgayIJJABBmAEQLCIFQgA3AgQgBUH84wQ2AgAgCyAFQQxqEL0CNgIwIAsoAjQhAiALIAU2AjQCQCACRQ0AIAIgAigCBCIFQQFrNgIEIAUNACACIAIoAgAoAggRAAAgAhArCyALKAIwIgcgC0FAazYCiAEjAEGgAWsiAiQAQbwBECwiBUGk1wMoAgAiBjYCACAFQZjXAzYCbCAFIAZBDGsoAgBqQajXAygCADYCACAFQQA2AgQgBSAFKAIAQQxrKAIAaiIGIAVBCGoiCBA+IAZCgICAgHA3AkggBUGY1wM2AmwgBUGE1wM2AgAgCBDCBSAEQQwQwwVFBEAgBSAFKAIAQQxrKAIAaiIEIAQoAhBBBHIQegsgCUEIaiERIAIgBTYCnAECQAJAAkACQCAFIAUoAgBBDGsoAgBqKAIQBEAgAkGg0wM2AhQgAkG00wM2AkwgAkHE0wMoAgAiBTYCDCACQQxqIgQgBUEMaygCAGpByNMDKAIANgIAIAJBADYCECAEIAIoAgxBDGsoAgBqIgUgAkEYaiIGED4gBUKAgICAcDcCSCACQczTAygCACIFNgIUIAJBFGoiByAFQQxrKAIAakHQ0wMoAgA2AgAgAkHA0wMoAgAiBTYCDCAEIAVBDGsoAgBqQdTTAygCADYCACACQbTTAzYCTCACQYzTAzYCDCACQaDTAzYCFCAGED8iEkHwywM2AgAgAkFAa0IANwIAIAJCADcCOCACQRg2AkggB0HOvwFBFBAtIRZBwK4GKAIAIgRBACAEQZkBTRtBAXRBoL4Dai8BAEGYrwNqIRMgFkHorwYoAgAoAhQiBAR/IAQoAgQhBSAEKAIAIgQoAgggBCgCAEGi2u/XBmoiBhDaASEHIAQoAgwgBhDaASEIIAQoAhAgBhDaASEKAkAgByAFQQJ2Tw0AIAggBSAHQQJ0ayIOTw0AIAogDk8NACAIIApyQQNxDQAgCkECdiEUIAQgCEF8cWohFUEAIQgDQCAVIAggB0EBdiIKaiIOQQN0aiIMKAIAIAYQ2gEhDyAFIAwoAgQgBhDaASIMTQ0BIA8gBSAMa08NASAPIAQgDGoiDGotAAANASATIAwQiAEiD0UEQCAEIBRBAnRqIA5BA3RqIggoAgAgBhDaASEHIAUgCCgCBCAGENoBIgZNDQIgByAFIAZrTw0CQQAgBCAGaiIEIAQgB2otAAAbIRAMAgsgB0EBRg0BIAogByAKayAPQQBIIgobIQcgCCAOIAobIQgMAAsACyAQBUEACyIEIBMgBBsiBCAEEFgQLUGSpAFBAhAtQcCuBigCABBCQc6QAkECEC0aAn8gAigCSCIEQRBxBEAgAigCRCIFIAIoAjAiBEkEQCACIAQ2AkQgBCEFCyACQSxqDAELIARBCHFFBEBBACEFIAJBADoACyACIQQMBQsgAigCKCEFIAJBIGoLIQQgBSAEKAIAIgZrIgVB+P///wdPDQEgBUELTwRAIAVBB3JBAWoiBxAsIQQgAiAHQYCAgIB4cjYCCCACIAQ2AgAgAiAFNgIEDAMLIAIgBToACyACIQQgBQ0CQQAhBQwDC0E4ECwiBEIANwIEIARB1OUENgIAIwBBEGsiBSQAIARBEGoiCEGovQQ2AgAgBEIANwIUIARBADYCJCAEQgA3AhwgBEH4uwQ2AhAgAigCnAEhBiACQQA2ApwBIAQgBjYCKCAGQgBBAhDEAyAFIAQoAigQywUgBCAFKQMINwMwIAQoAihCAEEAEMQDIAVBEGokACACIAQ2AhAgAiAINgIMIAQgBCgCBEEBajYCBCARIAcgAkEMahCUAwJAIAIoAhAiBUUNACAFIAUoAgQiBkEBazYCBCAGDQAgBSAFKAIAKAIIEQAAIAUQKwsgBCAEKAIEIgVBAWs2AgQgBQ0DIAQgBCgCACgCCBEAACAEECsMAwsQOAALIAQgBiAFEDcaCyAEIAVqQQA6AAAgEUEBQQAgAhAvGiACLAALQQBIBEAgAigCCBogAigCABAqCyACQbzTAygCACIENgIMIARBDGsoAgAgAkEMampB3NMDKAIANgIAIAJB4NMDKAIANgIUIBJB8MsDNgIAIAIsAENBAEgEQCACKAJAGiACKAI4ECoLIBIQPRogAkHMAGoQOxoLIAIoApwBIQQgAkEANgKcASAEBEAgBCAEKAIAKAIEEQAACyACQaABaiQAAkAgCSgCCARAIA0gCSkDCDcCACANIAkpAxA3AgggDSAJKAIYNgIQDAELIA0gCxCbAyAJLAAbQQBODQAgCSgCGBogCSgCEBAqCyAJQSBqJAAgACANIAEoAgAQQSADLAAfQQBIBEAgAygCHBogAygCFBAqCyADQSBqJAALqgEAIAFBACACG0UEQCAAQQA2AgggAEKFgICAkPoBNwIADwsgASgCACIBQQE6AEAgASACKQMINwNIIAEgAikDEDcDUCABIAIoAhg2AlggASACKAIcNgJcIAEgAigCIDYCYCABIAIpAyg3A2ggASACKAIwNgJwIAEgAigCNDYCdCABIAIoAjg2AnggASACKAI8NgJ8IABBpPEEKAIANgIIIABBnPEEKQIANwIACxMAIABFBEBBAA8LIAAoAgBBQGsLBgBBoOgEC6gDAQF/AkAgAUEMSA0AIABBCGoQpQQiAkEbcUEBa0ECSQRAQdfzAA8LIAJBA2siAkEQTw0AQfOHAyACdkEBcUUNACACQQJ0QdzwBGooAgAPCwJ/QQIgAUEMSA0AGgJAIAAtAABB/wFHDQAgAC0AAUHYAUcNAAJAIAAtAAJB/wFHDQAgAC0AA0HgAUcNACAALQAEDQAgAC0ABUEQRw0AIAAtAAZBygBHDQAgAC0AB0HGAEcNACAALQAIQckARw0AIAAtAAlBxgBHDQAgAC0ACg0AQQEgAC0AC0EBRg0CGgsgAC0AAkH/AUcNACAALQADQeEBRw0AIAAtAAZBxQBHDQAgAC0AB0H4AEcNACAALQAIQekARw0AIAAtAAlB5gBHDQAgAC0ACg0AIAAtAAsNAEEBDAELQQALQQFGBEBBr8gADwsCQCABQQhIDQAgAC0AAEGJAUcNACAALQABQdAARw0AIAAtAAJBzgBHDQAgAC0AA0HHAEcNACAALQAEQQ1HDQAgAC0ABUEKRw0AIAAtAAZBGkcNACAALQAHQQpHDQBB5MYADwtB0JACCwYAQeDnBAuOBAEEfyMAQdAAayIDJABBfyEFAkAgAEUNACABQQBMDQAgAkUNACACLQAARQ0AIAItAAFFDQAgAi0AAkUNACACLQADRQ0AQcgAECwiBEIANwIEIARB/OUENgIAIARBEGogACABQQAQiAMhACADIAQ2AjQgAyAANgIwIAQgBCgCBEEBajYCBCADIAMpAjA3AwggA0E4aiADQQhqIAFBABDvAiEGIANCADcCKCADQRRqIAYgA0EoakHg5wQQ+wECQCADKAIUBEBBf0F+IAMoAhhB5ABGGyEFDAELQX4hBSADKAIoIgBFDQAgAEGgvwRBzMEEEDkiAUUNACADKAIsIgAEQCAAIAAoAgRBAWo2AgQLIAEgAigAACIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZychDRASEFIABFDQAgACAAKAIEIgFBAWs2AgQgAQ0AIAAgACgCACgCCBEAACAAECsLIAMsACdBAEgEQCADKAIkGiADKAIcECoLAkAgAygCLCIARQ0AIAAgACgCBCIBQQFrNgIEIAENACAAIAAoAgAoAggRAAAgABArCwJAIAYoAgQiAEUNACAAIAAoAgQiAUEBazYCBCABDQAgACAAKAIAKAIIEQAAIAAQKwsgBCAEKAIEIgBBAWs2AgQgAA0AIAQgBCgCACgCCBEAACAEECsLIANB0ABqJAAgBQstACABBEAgASAAQRh0IABBgP4DcUEIdHIgAEEIdkGA/gNxIABBGHZycjYAAAsLBABCfwtOAQN/AkAgAUEQSA0AIAAtAAwiAUUNACAALQANIgNFDQAgAC0ADiIERQ0AIAAtAA8iAEUNACADQRB0IAFBGHRyIARBCHRyIAByIQILIAILTAEEfwJAIABFDQAgAC0AACICRQ0AIAAtAAEiA0UNACAALQACIgRFDQAgAC0AAyIARQ0AIANBEHQgAkEYdHIgBEEIdHIgAHIhAQsgAQsXAQF/IAFBDE4EfyAAQQhqEKUEBUEACwtNAQF/QX8hAgJAIABFDQAgAUEESA0AQQAhAiAALQAAQf8BRw0AIAAtAAFB2AFHDQAgAC0AAkH/AUcNACAALQADQfABcUHgAUYhAgsgAgvLBAEKfyMAQUBqIgMkACADQQA2AjwgA0EANgI4IANBLGogASACIANBPGogA0E4ahCmBAJAIAMoAiwEQCAAIAMpAiw3AgAgACADKAI0NgIIDAELAkAgAkEMSA0AIAEtAAgiAkUNACABLQAJIgVFDQAgAS0ACiIHRQ0AIAEtAAsiAUUNACAFQRB0IAJBGHRyIAdBCHRyIAFyIQQLIANBxL0CKQIANwMYIANBvL0CKQIANwMQIANBtL0CKQIANwMIIANCADcCJCADIANBJGoiBTYCICADQay9AikCADcDACADQSBqIgEgAyABEK8CAkACQCADKAIkIgcEQCAFIQIgByEBA0AgAiIIIAEiCSABKAIQIARJIgYbIQIgASAGQQJ0aigCACIBDQALAkAgAiAFRwRAIAQgCCAJIAYbKAIQTw0BCyADKAI8IQQgAygCOCIMQQBMDQIgB0UNAkEAIQYDQCAEIAZBAnRqKAIAIQogBSECIAchAQNAIAIiCCABIgkgASgCECAKSSILGyECIAEgC0ECdGooAgAiAQ0ACwJAIAIgBUYNACAKIAggCSALGygCEEkNACAEBEAgBBAqCyAAQZzxBCkCADcCACAAQaTxBCgCADYCCAwFCyAGQQFqIgYgDEcNAAsMAgsgAygCPCIBBEAgARAqCyAAQZzxBCkCADcCACAAQaTxBCgCADYCCAwCCyADKAI8IQQLIAQEQCAEECoLIABCgoCAgJD3AjcCACAAQfCaATYCCAsgA0EgaiADKAIkEMoBCyADQUBrJAALuQEBAX8gAUEISARAQQMPCwJAAkAgAC0ABEHmAEcNACAALQAFQfQARw0AIAAtAAZB+QBHDQAgAC0AB0HwAEcNACABQQxJBEBBAw8LQQEhAgJAIAAgARCGAyIAQejWydEGTARAIABB5tLZiwZGDQIgAEHj0pXDBkYNAiAAQfjSlcMGRw0BDAILAkAgAEGxzKXrBmsOAgMDAAsgAEHp1snRBkYNASAAQefKwdMGRg0BC0ECIQILIAIPC0EDCwQAQQgLBABBEwsEAEEBCwYAQeKIAQsPACAAQcTsBDYCACAAECoLDQAgAEHE7AQ2AgAgAAsPACAAQZzsBDYCACAAECoLDQAgAEGc7AQ2AgAgAAsHACAAKQMgCw8AIABB9OsENgIAIAAQKgsNACAAQfTrBDYCACAACw8AIABBzOsENgIAIAAQKgsNACAAQczrBDYCACAACw8AIABBpOsENgIAIAAQKgsNACAAQaTrBDYCACAACw8AIABB/OoENgIAIAAQKgsNACAAQfzqBDYCACAACywBAX8gAEHQ6gQ2AgAgACgCFCIBBEAgACABNgIYIAAoAhwaIAEQKgsgABAqCyoBAX8gAEHQ6gQ2AgAgACgCFCIBBEAgACABNgIYIAAoAhwaIAEQKgsgAAsMAEEDQQYgAC0ABBsLLAEBfyAAQfjpBDYCACAAKAIIIgEEQCAAIAE2AgwgACgCEBogARAqCyAAECoLKgEBfyAAQfjpBDYCACAAKAIIIgEEQCAAIAE2AgwgACgCEBogARAqCyAAC0QAIAFBBRBIIAEgAiAANAIEEGggASACIAA0AggQaCABIAIgADUCDBBoIAEgAiAANQIQEGggAUEAEEggASAAQRRqEJQBC4YJAQd/IwBBEGsiByQAAkAgAigCBCAEKAIAIgUgAigCAGoiBmsgA0EIbUECdE0EQCAHQTgQLCIBNgIEIAdCsoCAgICHgICAfzcCCCABQbM4KQAANwAAIAFBADoAMiABQeM4LwAAOwAwIAFB2zgpAAA3ACggAUHTOCkAADcAICABQcs4KQAANwAYIAFBwzgpAAA3ABAgAUG7OCkAADcACCAAQQJBiAEgB0EEahAvGiAHLAAPQQBODQEgBygCDBogBygCBBAqDAELIAYtAAAhCCAGLQABIQkgBAJ/IANBIEYEQCAGLQADIAlBEHQgCEEYdHIgBi0AAkEIdHJyIQYgBUEEagwBCyAJQRB0IAhBGHRyQRB1IQYgBUECags2AgAgASAGNgIEIAQoAgAiBSACKAIAaiIGLQAAIQggBi0AASEJIAQCfyADQSBGBEAgBi0AAyAJQRB0IAhBGHRyIAYtAAJBCHRyciEGIAVBBGoMAQsgCUEQdCAIQRh0ckEQdSEGIAVBAmoLNgIAIAEgBjYCCCACKAIAIgYgBCgCACIKaiIFLQAAIQggBS0AASEJIAQCfyADQSBGBEAgBS0AAyAJQRB0IAhBGHRyIAUtAAJBCHRyciEFQQQMAQsgCEEIdCAJciEFQQILIApqNgIAIAEgBTYCDCAGIAQoAgAiCmoiBS0AACEIIAUtAAEhCSAEAn8gA0EgRgRAIAUtAAMgCUEQdCAIQRh0ciAFLQACQQh0cnIhA0EEDAELIAhBCHQgCXIhA0ECCyAKajYCACABIAM2AhAgBiAEKAIAIgVqLQAAIQsgBCAFQQFqNgIAIAsEQCAHQTgQLCIBNgIEIAdCs4CAgICHgICAfzcCCCABQY7oACkAADcAACABQQA6ADMgAUG96AAoAAA2AC8gAUG26AApAAA3ACggAUGu6AApAAA3ACAgAUGm6AApAAA3ABggAUGe6AApAAA3ABAgAUGW6AApAAA3AAggAEECQYgBIAdBBGoQLxogBywAD0EATg0BIAcoAgwaIAcoAgQQKgwBCyABKAIQIAEoAgxsIghBA3YiAyACKAIEIAVBf3MgBmtqSwRAIAdBwAAQLCIBNgIEIAdCuYCAgICIgICAfzcCCCABQY37ACkAADcAACABQQA6ADkgAUHF+wAtAAA6ADggAUG9+wApAAA3ADAgAUG1+wApAAA3ACggAUGt+wApAAA3ACAgAUGl+wApAAA3ABggAUGd+wApAAA3ABAgAUGV+wApAAA3AAggAEECQYgBIAdBBGoQLxogBywAD0EATg0BIAcoAgwaIAcoAgQQKgwBCyABQRRqIQYCQCABKAIYIAEoAhQiCWsiBSADSQRAIAYgAyAFaxBlDAELIAMgBU8NACABIAMgCWo2AhgLIAhBCE8EQCAGKAIAIAIoAgAgBCgCAGogAxA3GgsgAEGQpQUpAgA3AgAgAEEIaiEAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyAHQRBqJAALEQAgACkDICIBIAIgASACVBsLXgEBfyABQQNBBiAALQAEGxBIIAEgAiAAKAIMIAAoAghrQQN1rRBoIAAoAggiAyAAKAIMIgBHBEADQCABIAIgAzQCABBoIAEgAiADNAIEEGggA0EIaiIDIABHDQALCwteAQF/AkAgACgCDCIBIAAoAggiAGtB+P8fSw0AIAAgAUYEQEEADwsDQCAAKAIAQYCAAmtBgIB8SQ0BIAAoAgRBgIACa0H//3tNDQEgAEEIaiIAIAFHDQALQQAPC0EBCzQAIAFBBBBIIAEgAiAANAIEEGggASACIAA0AggQaCABIAIgADUCDBBoIAEgAiAANQIQEGgLqwUBBX8jAEEQayIIJAACQCACKAIEIAQoAgAiBiACKAIAaiIFayADQQhtQQJ0SQRAIAhBOBAsIgE2AgQgCEK2gICAgIeAgIB/NwIIIAFB5jgpAAA3AAAgAUEAOgA2IAFBlDkpAAA3AC4gAUGOOSkAADcAKCABQYY5KQAANwAgIAFB/jgpAAA3ABggAUH2OCkAADcAECABQe44KQAANwAIIABBAkGIASAIQQRqEC8aIAgsAA9BAE4NASAIKAIMGiAIKAIEECoMAQsgBS0AACEJIAUtAAEhBwJ/IANBIEYEQCAGQQRqIQYgBS0AAyAHQRB0IAlBGHRyIAUtAAJBCHRycgwBCyAGQQJqIQYgB0EQdCAJQRh0ckEQdQshBSAEIAY2AgAgASAFNgIEIAQoAgAiBiACKAIAaiIFLQAAIQkgBS0AASEHAn8gA0EgRgRAIAZBBGohBiAFLQADIAdBEHQgCUEYdHIgBS0AAkEIdHJyDAELIAZBAmohBiAHQRB0IAlBGHRyQRB1CyEFIAQgBjYCACABIAU2AgggAigCACIJIAQoAgAiB2oiAi0AACEGIAItAAEhBSAEAn8gA0EgRgRAIAItAAMgBUEQdCAGQRh0ciACLQACQQh0cnIhAkEEDAELIAZBCHQgBXIhAkECCyAHajYCACABIAI2AgwgCSAEKAIAIgdqIgItAAAhBiACLQABIQUgBAJ/IANBIEYEQCACLQADIAVBEHQgBkEYdHIgAi0AAkEIdHJyIQNBBAwBCyAGQQh0IAVyIQNBAgsgB2o2AgAgASADNgIQIABBkKUFKQIANwIAIABBCGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgCEEQaiQAC+wHAQx/IwBBEGsiByQAAkAgA0EIbSIKIAIoAgQgAigCACIFayIJIAQoAgAiBmtLBEAgB0EoECwiATYCBCAHQqeAgICAhYCAgH83AgggAUH9OSkAADcAACABQQA6ACcgAUGcOikAADcAHyABQZU6KQAANwAYIAFBjTopAAA3ABAgAUGFOikAADcACCAAQQJBiAEgB0EEahAvGiAHLAAPQQBODQEgBygCDBogBygCBBAqDAELIAUgBmoiBS0AACELIAUtAAEhCCAEAn8gA0EgRgRAIAUtAAMgCEEQdCALQRh0ciAFLQACQQh0cnIhC0EEDAELIAtBCHQgCHIhC0ECCyAGaiIFNgIAIAkgBWutIAqsIAutfkIBhloEQAJAIAtFDQAgA0EgRyEOAkADQCAEKAIAIgMgAigCAGoiBS0AACEGIAUtAAEhCCAEAn8gDkUEQCAFLQADIRAgBS0AAiEMIAQgA0EEaiIFNgIAIAIoAgAgBWooAAAiBUEYdCAFQYD+A3FBCHRyIAVBCHZBgP4DcSAFQRh2cnIhCiAQIAhBEHQgBkEYdHIgDEEIdHJyIQUgA0EIagwBCyAEIANBAmoiCjYCACAIQRB0IAZBGHRyQRB1IQUgAigCACAKaiIGLQABQRB0IAYtAABBGHRyQRB1IQogA0EEags2AgACQAJAIAEoAgwiAyABKAIQIglJBEAgAyAFrSAKrUIghoQ3AgAgA0EIaiEFDAELIAMgASgCCCIGa0EDdSIMQQFqIghBgICAgAJPDQFB/////wEgCSAGayIJQQJ1Ig0gCCAIIA1JGyAJQfj///8HTxsiCQR/IAlBgICAgAJPDQQgCUEDdBAsBUEACyINIAxBA3RqIgggBa0gCq1CIIaENwIAIAhBCGohBSADIAZHBEADQCAIQQhrIgggA0EIayIDKQIANwIAIAMgBkcNAAsgASgCEBogASgCCCEGCyABIA0gCUEDdGo2AhAgASAFNgIMIAEgCDYCCCAGRQ0AIAYQKgsgASAFNgIMIA9BAWoiDyALRw0BDAMLCxA2AAsQTwALIABBkKUFKQIANwIAIABBCGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwCCyAAQZilBSgCAEGcpQUoAgAQLgwBCyAHQSgQLCIBNgIEIAdCp4CAgICFgICAfzcCCCABQf05KQAANwAAIAFBADoAJyABQZw6KQAANwAfIAFBlTopAAA3ABggAUGNOikAADcAECABQYU6KQAANwAIIABBAkGIASAHQQRqEC8aIAcsAA9BAE4NACAHKAIMGiAHKAIEECoLIAdBEGokAAs0ACABQQIQSCABIAIgADQCBBBoIAEgAiAANAIIEGggASACIAA1AgwQaCABIAIgADUCEBBoC6AFAQV/IwBBEGsiCCQAAkAgAigCBCAEKAIAIgYgAigCAGoiBWsgA0EIbUECdEkEQCAIQTAQLCIBNgIEIAhCroCAgICGgICAfzcCCCABQZ05KQAANwAAIAFBADoALiABQcM5KQAANwAmIAFBvTkpAAA3ACAgAUG1OSkAADcAGCABQa05KQAANwAQIAFBpTkpAAA3AAggAEECQYgBIAhBBGoQLxogCCwAD0EATg0BIAgoAgwaIAgoAgQQKgwBCyAFLQAAIQkgBS0AASEHAn8gA0EgRgRAIAZBBGohBiAFLQADIAdBEHQgCUEYdHIgBS0AAkEIdHJyDAELIAZBAmohBiAHQRB0IAlBGHRyQRB1CyEFIAQgBjYCACABIAU2AgQgBCgCACIGIAIoAgBqIgUtAAAhCSAFLQABIQcCfyADQSBGBEAgBkEEaiEGIAUtAAMgB0EQdCAJQRh0ciAFLQACQQh0cnIMAQsgBkECaiEGIAdBEHQgCUEYdHJBEHULIQUgBCAGNgIAIAEgBTYCCCACKAIAIgkgBCgCACIHaiICLQAAIQYgAi0AASEFIAQCfyADQSBGBEAgAi0AAyAFQRB0IAZBGHRyIAItAAJBCHRyciECQQQMAQsgBkEIdCAFciECQQILIAdqNgIAIAEgAjYCDCAJIAQoAgAiB2oiAi0AACEGIAItAAEhBSAEAn8gA0EgRgRAIAItAAMgBUEQdCAGQRh0ciACLQACQQh0cnIhA0EEDAELIAZBCHQgBXIhA0ECCyAHajYCACABIAM2AhAgAEGQpQUpAgA3AgAgAEEIaiEAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyAIQRBqJAALNAAgAUEBEEggASACIAA0AgQQaCABIAIgADQCCBBoIAEgAiAANQIMEGggASACIAA1AhAQaAugBQEFfyMAQRBrIggkAAJAIAIoAgQgBCgCACIGIAIoAgBqIgVrIANBCG1BAnRJBEAgCEE4ECwiATYCBCAIQrCAgICAh4CAgH83AgggAUHMOSkAADcAACABQQA6ADAgAUH0OSkAADcAKCABQew5KQAANwAgIAFB5DkpAAA3ABggAUHcOSkAADcAECABQdQ5KQAANwAIIABBAkGIASAIQQRqEC8aIAgsAA9BAE4NASAIKAIMGiAIKAIEECoMAQsgBS0AACEJIAUtAAEhBwJ/IANBIEYEQCAGQQRqIQYgBS0AAyAHQRB0IAlBGHRyIAUtAAJBCHRycgwBCyAGQQJqIQYgB0EQdCAJQRh0ckEQdQshBSAEIAY2AgAgASAFNgIEIAQoAgAiBiACKAIAaiIFLQAAIQkgBS0AASEHAn8gA0EgRgRAIAZBBGohBiAFLQADIAdBEHQgCUEYdHIgBS0AAkEIdHJyDAELIAZBAmohBiAHQRB0IAlBGHRyQRB1CyEFIAQgBjYCACABIAU2AgggAigCACIJIAQoAgAiB2oiAi0AACEGIAItAAEhBSAEAn8gA0EgRgRAIAItAAMgBUEQdCAGQRh0ciACLQACQQh0cnIhAkEEDAELIAZBCHQgBXIhAkECCyAHajYCACABIAI2AgwgCSAEKAIAIgdqIgItAAAhBiACLQABIQUgBAJ/IANBIEYEQCACLQADIAVBEHQgBkEYdHIgAi0AAkEIdHJyIQNBBAwBCyAGQQh0IAVyIQNBAgsgB2o2AgAgASADNgIQIABBkKUFKQIANwIAIABBCGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgCEEQaiQAC1IBAX8gACgCGCEBIABBADYCGCAAQfi7BDYCACABBEAgASABKAIAKAIEEQAACyAAQai9BDYCACAALAAXQQBIBEAgACgCFBogACgCDBAqCyAAECoLHgAgAUEAEEggASACIAA0AgQQaCABIAIgADQCCBBoCyEAIAAoAgRBgIACa0GAgHxJIAAoAghBgIACa0GAgHxJcgvfAwEFfyMAQRBrIgckAAJAIAIoAgQgBCgCACIGIAIoAgBqIgVrIANBCG1BAXRJBEAgB0EwECwiATYCBCAHQqyAgICAhoCAgH83AgggAUG4NykAADcAACABQQA6ACwgAUHgNygAADYAKCABQdg3KQAANwAgIAFB0DcpAAA3ABggAUHINykAADcAECABQcA3KQAANwAIIABBAkGIASAHQQRqEC8aIAcsAA9BAE4NASAHKAIMGiAHKAIEECoMAQsgBS0AACEIIAUtAAEhCQJ/IANBIEYEQCAGQQRqIQYgBS0AAyAJQRB0IAhBGHRyIAUtAAJBCHRycgwBCyAGQQJqIQYgCUEQdCAIQRh0ckEQdQshBSAEIAY2AgAgASAFNgIEIAQoAgAiBSACKAIAaiICLQAAIQYgAi0AASEIAn8gA0EgRgRAIAVBBGohAyACLQADIAhBEHQgBkEYdHIgAi0AAkEIdHJyDAELIAVBAmohAyAIQRB0IAZBGHRyQRB1CyECIAQgAzYCACABIAI2AgggAEGQpQUpAgA3AgAgAEEIaiEAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyAHQRBqJAALLQECfyAAKAIAIgEEQANAIAEQKiAAIAJBAWoiAkECdGooAgAiAQ0ACwsgABAqC1ABAX8gACgCGCEBIABBADYCGCAAQfi7BDYCACABBEAgASABKAIAKAIEEQAACyAAQai9BDYCACAALAAXQQBIBEAgACgCFBogACgCDBAqCyAACxEBAX9BBBAsIgBBADYCACAACyYAIAMEQCADQQA2AgALIABB4OgEKQIANwIAIABB6OgEKAIANgIICxoAIABB4OgEKQIANwIAIABB6OgEKAIANgIICxoAIABB4OgEKQIANwIAIABB6OgEKAIANgIIC6ADAQR/AkACQAJAQdClBSgCACIADgICAAELQbilBSgCACIAQbylBUcEQANAIAAoAhAoAgwiAQRAIAERDgALAkAgACgCBCIBBEADQCABIgAoAgAiAQ0ADAILAAsDQCAAIAAoAggiACgCAEcNAAsLIABBvKUFRw0ACwtB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BCADKAIMQQxrKAIAaiIGIANBEGoiBRA+IAZCgICAgHA3AkggA0Hk1QM2AkQgA0HQ1QM2AgwgBRA/IgZB8MsDNgIAIANCADcCOCADQgA3AjAgA0EQNgJAIANBlAFqIgUgASACEFkgBCADKAKUASAFIAMsAJ8BIgRBAEgiBRsgAygCmAEgBCAFGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCwJAIAEoAmQEQCADQZQBaiIEIAIQNSADQQxqIAMoApQBIAQgAywAnwEiBEEASCIFGyADKAKYASAEIAUbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBDGpBkb4BQQ0QLSEIIANBlAFqIgUgASgCZCIHIAcoAgAoAggRAQAQpAEgCCADKAKUASAFIAMsAJ8BIgRBAEgiBRsgAygCmAEgBCAFGxAtQc+QAkEBEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBlAFqIgQgASgCZCIBIAIgASgCACgCDBEDACADQQxqIAMoApQBIAQgAywAnwEiAUEASCICGyADKAKYASABIAIbEC0aIAMsAJ8BQQBODQEgAygCnAEaIAMoApQBECoMAQsgA0GUAWoiASACEDUgA0EMaiADKAKUASABIAMsAJ8BIgFBAEgiAhsgAygCmAEgASACGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyADQQxqIgFB0o4CQREQLRogAUGIyQFBERAtGgsCQAJ/IAMoAkAiAUEQcQRAIAMoAjwiASADKAIoIgJJBEAgAyACNgI8IAIhAQsgA0EkagwBCyABQQhxRQRAQQAhASAAQQA6AAsMAgsgAygCICEBIANBGGoLIQICQCABIAIoAgAiBGsiAUH4////B0kEQCABQQtPBEAgAUEHckEBaiIFECwhAiAAIAVBgICAgHhyNgIIIAAgAjYCACAAIAE2AgQgAiEADAILIAAgAToACyABDQFBACEBDAILEDgACyAAIAQgARA3GgsgACABakEAOgAAIANB7NUDKAIAIgA2AgwgAEEMaygCACADQQxqakH41QMoAgA2AgAgBkHwywM2AgAgAywAO0EASARAIAMoAjgaIAMoAjAQKgsgBhA9GiADQcQAahA7GiADQaABaiQAC9MLAgZ/An4jAEEQayIEJAACQAJAAkACQAJAAkACQCACEEkiCUHDhqWSB0YNACAJQebeyYMHRg0AIAlB+NiN8wZHDQFBGBAsIgVBAToAFiAFQQY7ARQgBUGBgDQ2AhAgBUIBNwIEIAVBzOYENgIMIAVB1OMENgIAIAEgBUEMaiIDNgJkIAEoAmghBiABIAU2AmgCQCAGRQ0AIAYgBigCBCIBQQFrNgIEIAENACAGIAYoAgAoAggRAAAgBhArCyMAQRBrIgYkACACKAIAIgEgASgCACgCCBESACEKAkAgAigCACIBIApCB3wgASgCACgCDBEQAARAIAZBADoABCAGQQA6AA8gAEECQeQAIAZBBGoQLxogBiwAD0EATg0BIAYoAgwaIAYoAgQQKgwBCyADIAIQTjsBBCADIAIQTjsBBiADIAIQTjsBCCADIAIQUkEHdjoACiAAQZClBSkCADcCACAAQQhqIQFBo6UFLAAAQQBOBEAgAUGYpQUpAgA3AgAgAUGgpQUoAgA2AggMAQsgAUGYpQUoAgBBnKUFKAIAEC4LIAZBEGokACAAKAIADQIgACwAE0EASARAIAAoAhAaIAAoAggQKgsgBSAFKAIEIgFBAWs2AgQgAQ0FIAUgBSgCACgCCBEAACAFECsMBQsgASkDCCIKUARAIARBOBAsIgE2AgQgBEK0gICAgIeAgIB/NwIIIAFBl+cAKQAANwAAIAFBADoANCABQcfnACgAADYAMCABQb/nACkAADcAKCABQbfnACkAADcAICABQa/nACkAADcAGCABQafnACkAADcAECABQZ/nACkAADcACCAAQQRBACAEQQRqEC8aIAQsAA9BAE4NBiAEKAIMGiAEKAIEECoMBgsgCiABNQIgfUIEfSELAkAgAzUCICIKUA0AIAogC1oNACAEQTAQLCIBNgIEIARCrICAgICGgICAfzcCCCABQanLACkAADcAACABQQA6ACwgAUHRywAoAAA2ACggAUHJywApAAA3ACAgAUHBywApAAA3ABggAUG5ywApAAA3ABAgAUGxywApAAA3AAggAEECQegHIARBBGoQLxogBCwAD0EATg0GIAQoAgwaIAQoAgQQKgwGCyACKAIAIgMgAygCACgCCBESACEKIAIoAgAiAyAKIAunIgetfCADKAIAKAIMERAABEAgBEEAOgAEIARBADoADyAAQQJB5AAgBEEEahAvGiAELAAPQQBODQYgBCgCDBogBCgCBBAqDAYLIARBADYCDCAEQgA3AgQgBwRAIAdBAEgNAyAEIAcQLCIINgIEIAQgByAIaiIFNgIMQQAhAyAIQQAgBxA0IQYgBCAFNgIIA0AgAyAGaiACEFI6AAAgA0EBaiIDIAdHDQALC0EgECwiB0EANgIcIAdCADcCFCAHIAk2AhAgB0IANwIEIAdBpOYENgIMIAdBvOcENgIAIAUgCEcEQCAFIAhrIgVBAEgNBCAHIAUQLCIGNgIUIAcgBSAGaiIDNgIcIAYgCCAFEDIaIAcgAzYCGAsgASAHQQxqNgJkIAEoAmghAyABIAc2AmgCQCADRQ0AIAMgAygCBCIBQQFrNgIEIAENACADIAMoAgAoAggRAAAgAxArCyAEKAIEIgFFDQQgBCgCDBogARAqDAQLIARBADoABCAEQQA6AA8gAEECQf4AIARBBGoQLxogBCwAD0EATg0EIAQoAgwaIAQoAgQQKgwECyAFIAUoAgQiAEEBazYCBCAADQMgBSAFKAIAKAIIEQAAIAUQKwwDCxA2AAsQNgALIAItABRBAUYEQCAEQQA6AAQgBEEAOgAPIABBAkHkACAEQQRqEC8aIAQsAA9BAE4NASAEKAIMGiAEKAIEECoMAQsgAEGQpQUpAgA3AgAgAEEIaiEAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyAEQRBqJAALEABBxKUFQcilBSgCABC3AgsQAEG4pQVBvKUFKAIAELgCC4oRAgd/AX4jAEHgAWsiAyQAQn8hCiAAKAIYIgQoAgBBAk4EQCADQcgBaiABIAIgACgCHCAEKAIUERwAIANBADYCwAEgA0IANwO4AQJAAkACQAJAAkACQAJAAkACQAJAIAMoAtwBIgdFDQAgBxBYIgVB+P///wdPDQECQAJAIAVBC08EQCAFQQdyQQFqIgYQLCEEIAMgBkGAgICAeHI2AjAgAyAENgIoIAMgBTYCLAwBCyADIAU6ADMgA0EoaiEEIAVFDQELIAQgByAFEDcaCyAEIAVqQQA6AAAgAywAwwFBAEgEQCADKALAARogAygCuAEQKgsgAyADKAIwNgLAASADIAMpAig3A7gBIAAoAhgoAiAiBEUNACADKALcASAEEQAACwJAAkACQCADKALIAQ4ECwoAAQILIANBGBAsIgQ2AhAgA0KVgICAgIOAgIB/NwIUIARB48oAKQAANwANIARB3soAKQAANwAIIARB1soAKQAANwAAIARBADoAFSAAIANBKGpBAkHkACADQRBqEC8iBCkDADcCBCAALAAXQQBIBEAgACgCFBogACgCDBAqCyAAIAQpAgg3AgwgACAEKAIQNgIUIARBADoAEyAEQQA6AAggAywAG0EASARAIAMoAhgaIAMoAhAQKgsgAykD0AEhAgwKCyADKALcAQRAIANBoNMDNgIwIANBtNMDNgJoIANBxNMDKAIAIgQ2AiggBEEMaygCACADQShqakHI0wMoAgA2AgAgAygCKCEJIANBADYCLCAJQQxrKAIAIANBKGpqIgQgA0E0aiIFED4gBEKAgICAcDcCSCADQczTAygCACIENgIwIANBMGoiBiAEQQxrKAIAakHQ0wMoAgA2AgAgA0HA0wMoAgAiBDYCKCAEQQxrKAIAIANBKGpqQdTTAygCADYCACADQbTTAzYCaCADQYzTAzYCKCADQaDTAzYCMCAFED8iB0HwywM2AgAgA0IANwJcIANCADcCVCADQRg2AmQgBkHEowFBDRAtIAMoAtgBEEJBssQBQQQQLSADKAK4ASADQbgBaiADLADDASIEQQBIIgUbIAMoArwBIAQgBRsQLRoCfyADKAJkIgRBEHEEQCADQcgAaiEEIAMoAmAiBiADKAJMIgVJBH8gAyAFNgJgIAUFIAYLDAELIARBCHFFBEBBACEFIANBADoADyADQQRqIQQMCgsgA0E8aiEEIAMoAkQLIAQoAgAiBmsiBUH4////B08NAyAFQQtPBEAgBUEHckEBaiIIECwhBCADIAhBgICAgHhyNgIMIAMgBDYCBCADIAU2AggMCAsgAyAFOgAPIANBBGohBCAFDQdBACEFDAgLIANBoNMDNgIwIANBtNMDNgJoIANBxNMDKAIAIgQ2AiggA0EoaiIFIARBDGsoAgBqQcjTAygCADYCACADQQA2AiwgBSADKAIoQQxrKAIAaiIEIANBNGoiBxA+IARCgICAgHA3AkggA0HM0wMoAgAiBDYCMCADQTBqIgYgBEEMaygCAGpB0NMDKAIANgIAIANBwNMDKAIAIgQ2AiggBSAEQQxrKAIAakHU0wMoAgA2AgAgA0G00wM2AmggA0GM0wM2AiggA0Gg0wM2AjAgBxA/IgdB8MsDNgIAIANCADcCXCADQgA3AlQgA0EYNgJkIAZBxKMBQQ0QLSADKALYARBCQcSiAUEBEC0aAn8gAygCZCIEQRBxBEAgA0HIAGohBCADKAJgIgYgAygCTCIFSQR/IAMgBTYCYCAFBSAGCwwBCyAEQQhxRQRAQQAhBSADQQA6AA8gA0EEaiEEDAcLIANBPGohBCADKAJECyAEKAIAIgZrIgVB+P///wdPDQMgBUELTwRAIAVBB3JBAWoiCBAsIQQgAyAIQYCAgIB4cjYCDCADIAQ2AgQgAyAFNgIIDAULIAMgBToADyADQQRqIQQgBQ0EQQAhBQwFCyADQSgQLCIENgIQIANCoYCAgICFgICAfzcCFCAEQdTNAC0AADoAICAEQczNACkAADcAGCAEQcTNACkAADcAECAEQbzNACkAADcACCAEQbTNACkAADcAACAEQQA6ACEgACADQShqQQJBACADQRBqEC8iBCkDADcCBCAALAAXQQBIBEAgACgCFBogACgCDBAqCyAAIAQpAgg3AgwgACAEKAIQNgIUIARBADoAEyAEQQA6AAggAywAG0EATg0HIAMoAhgaIAMoAhAQKgwHCxA4AAsQOAALEDgACyAEIAYgBRA3GgsgBCAFakEAOgAAIAAgA0EQakECQQAgA0EEahAvIgQpAwA3AgQgACwAF0EASARAIAAoAhQaIAAoAgwQKgsgACAEKQIINwIMIAAgBCgCEDYCFCAEQQA6ABMgBEEAOgAIIAMsAA9BAEgEQCADKAIMGiADKAIEECoLIANBvNMDKAIAIgA2AiggAEEMaygCACADQShqakHc0wMoAgA2AgAgA0Hg0wMoAgA2AjAgB0HwywM2AgAgAywAX0EASARAIAMoAlwaIAMoAlQQKgsgBxA9GiADQegAahA7GgwCCyAEIAYgBRA3GgsgBCAFakEAOgAAIAAgA0EQakECQQAgA0EEahAvIgQpAwA3AgQgACwAF0EASARAIAAoAhQaIAAoAgwQKgsgACAEKQIINwIMIAAgBCgCEDYCFCAEQQA6ABMgBEEAOgAIIAMsAA9BAEgEQCADKAIMGiADKAIEECoLIANBvNMDKAIAIgA2AiggAEEMaygCACADQShqakHc0wMoAgA2AgAgA0Hg0wMoAgA2AjAgB0HwywM2AgAgAywAX0EASARAIAMoAlwaIAMoAlQQKgsgBxA9GiADQegAahA7GgtCACECCyADLADDAUEASARAIAMoAsABGiADKAK4ARAqCyACIQoLIANB4AFqJAAgCgsPACAAQfzlBDYCACAAECoLDQAgAEH85QQ2AgAgAAsPACAAQdTlBDYCACAAECoLDQAgAEHU5QQ2AgAgAAu+AgEEfwJAIAAoAlQiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsCQCAAKAJMIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEAACABECsLAkAgACgCOCIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCwJAIAAoAjAiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsgACgCICIBBEAgASECIAEgACgCJCIDRwRAA0ACQCADQQRrKAIAIgJFDQAgAiACKAIEIgRBAWs2AgQgBA0AIAIgAigCACgCCBEAACACECsLIANBCGsiAyABRw0ACyAAKAIgIQILIAAgATYCJCAAKAIoGiACECoLCxUAIAEgACgCHCAAKAIYKAIMESEARQsPACAAQazlBDYCACAAECoLDQAgAEGs5QQ2AgAgAAsXACABIAIgACgCHCAAKAIYKAIIEQQARQsSACAAKAIcIAAoAhgoAgQREgALJwAgAEGovQQ2AgAgACwAF0EASARAIAAoAhQaIAAoAgwQKgsgABAqCyIBAX4gASAAKQMgIgJYBEAgACgCGCABQQAQxAMLIAEgAlgLZwEBfyAAKAI0IgEEQCAAIAE2AjggACgCPBogARAqCyAALAAzQQBIBEAgACgCMBogACgCKBAqCyAALAAnQQBIBEAgACgCJBogACgCHBAqCyAALAAbQQBIBEAgACgCGBogACgCEBAqCwsPACAAQfzkBDYCACAAECoLDQAgAEH85AQ2AgAgAAt4AQR/IAAoAhgiAgRAIAAoAhwiAyACIgFHBEADQAJAIANBBGsoAgAiAUUNACABIAEoAgQiBEEBazYCBCAEDQAgASABKAIAKAIIEQAAIAEQKwsgA0EIayIDIAJHDQALIAAoAhghAQsgACACNgIcIAAoAiAaIAEQKgsLDwAgAEGk5AQ2AgAgABAqCw0AIABBpOQENgIAIAALuAYBBH8gAEGIAWogACgCjAEQvAICQCAAKAKEASIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCwJAIAAoAnwiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsCQCAAKAJ0IgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEAACABECsLAkAgACgCbCIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCwJAIAAoAmQiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsCQCAAKAJcIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEAACABECsLAkAgACgCVCIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCwJAIAAoAkwiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsCQCAAKAJEIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEAACABECsLAkAgACgCPCIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCwJAIAAoAjQiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsCQCAAKAIsIgFFDQAgASABKAIEIgJBAWs2AgQgAg0AIAEgASgCACgCCBEAACABECsLIAAoAhwiAQRAIAEhAiABIAAoAiAiA0cEQANAAkAgA0EEaygCACICRQ0AIAIgAigCBCIEQQFrNgIEIAQNACACIAIoAgAoAggRAAAgAhArCyADQQhrIgMgAUcNAAsgACgCHCECCyAAIAE2AiAgACgCJBogAhAqCwJAIAAoAhgiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsCQCAAKAIQIgBFDQAgACAAKAIEIgFBAWs2AgQgAQ0AIAAgACgCACgCCBEAACAAECsLCw8AIABB/OMENgIAIAAQKgsNACAAQfzjBDYCACAACyUAIABBqL0ENgIA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AiADRw0ACyAAKAJoIQELIAAgAzYCbCAAKAJwGiABECoLIAAQVgt6ACAAQYDEBDYCACAALACjAUEASARAIAAoAqABGiAAKAKYARAqCyAALACXAUEASARAIAAoApQBGiAAKAKMARAqCyAALACLAUEASARAIAAoAogBGiAAKAKAARAqCyAALAB/QQBIBEAgACgCfBogACgCdBAqCyAAEFYQKgt4ACAAQYDEBDYCACAALACjAUEASARAIAAoAqABGiAAKAKYARAqCyAALACXAUEASARAIAAoApQBGiAAKAKMARAqCyAALACLAUEASARAIAAoAogBGiAAKAKAARAqCyAALAB/QQBIBEAgACgCfBogACgCdBAqCyAAEFYLKwAgAEHwwgQ2AgAgACwAhwFBAEgEQCAAKAKEARogACgCfBAqCyAAEFYQKgspACAAQfDCBDYCACAALACHAUEASARAIAAoAoQBGiAAKAJ8ECoLIAAQVgsuAQF/IABBmMEENgIAIAAoAmwiAQRAIAAgATYCcCAAKAJ0GiABECoLIAAQVhAqCywBAX8gAEGYwQQ2AgAgACgCbCIBBEAgACABNgJwIAAoAnQaIAEQKgsgABBWC00AIABBkKUFKQIANwIAIABBCGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCA8LIABBmKUFKAIAQZylBSgCABAuC4oBACMAQRBrIgEkACABQSAQLCICNgIEIAFCnYCAgICEgICAfzcCCCACQfOQASkAADcAACACQQA6AB0gAkGIkQEpAAA3ABUgAkGDkQEpAAA3ABAgAkH7kAEpAAA3AAggAEEFQQAgAUEEahAvGiABLAAPQQBIBEAgASgCDBogASgCBBAqCyABQRBqJAALKQAgAEHQwAQ2AgAgACwAe0EASARAIAAoAngaIAAoAnAQKgsgABBWECoLJwAgAEHQwAQ2AgAgACwAe0EASARAIAAoAngaIAAoAnAQKgsgABBWCy4BAX8gAEGIwAQ2AgAgACgCZCIBBEAgACABNgJoIAAoAmwaIAEQKgsgABBWECoLLAEBfyAAQYjABDYCACAAKAJkIgEEQCAAIAE2AmggACgCbBogARAqCyAAEFYLCQAgAEEAOgBhCywBAX8gAEHUvQQ2AgAgACgCFCIBBEAgACABNgIYIAAoAhwaIAEQ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aiIEIAIQNSADQQxqIAMoApQBIAQgAywAnwEiBEEASCIFGyADKAKYASAEIAUbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBDGoiBEHaugFBDhAtIAErA2gQngFBz5ACQQEQLRogA0GUAWoiASACEDUgBCADKAKUASABIAMsAJ8BIgFBAEgiAhsgAygCmAEgASACGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyADQQxqQevEAUEIEC0aCwJAAn8gAygCQCIBQRBxBEAgAygCPCIBIAMoAigiAkkEQCADIAI2AjwgAiEBCyADQSRqDAELIAFBCHFFBEBBACEBIABBADoACwwCCyADKAIgIQEgA0EYagshAgJAIAEgAigCACIEayIBQfj///8HSQRAIAFBC08EQCABQQdyQQFqIgUQLCECIAAgBUGAgICAeHI2AgggACACNgIAIAAgATYCBCACIQAMAgsgACABOgALIAENAUEAIQEMAgsQOAALIAAgBCABEDcaCyAAIAFqQQA6AAAgA0Hs1QMoAgAiADYCDCAAQQxrKAIAIANBDGpqQfjVAygCADYCACAGQfDLAzYCACADLAA7QQBIBEAgAygCOBogAygCMBAqCyAGED0aIANBxABqEDsaIANBoAFqJAAL9QEBAn8jAEEgayIDJAAgASACQQAgASgCACgCLBEEACEEIAIgAUHoAGoQoAEgAiABQfQAahCgASACIAFBgAFqEKABIAIgAUGMAWoQoAEgAiAENgIMIANBDGogASACIAIoAgQgBCACKAIAamtBACABKAIAKAIwEQcAIAIgAigCBCACKAIAazYCDCADLAAfQQBIBEAgAygCHBogAygCFBAqCyAAQZClBSkCADcCACAAQQhqIQACQEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgA0EgaiQAC7wIAQZ/IwBBoAFrIgMkACADQeTVAzYCRCADQfDVAygCACIHNgIMIANBDGoiBCAHQQxrKAIAakH01QMoAgA2AgAgBCADKAIMQQxrKAIAaiIHIANBEGoiBhA+IAdCgICAgHA3AkggA0Hk1QM2AkQgA0HQ1QM2AgwgBhA/IgdB8MsDNgIAIANCADcCOCADQgA3AjAgA0EQNgJAIANBlAFqIgYgASACEFkgBCADKAKUASAGIAMsAJ8BIgRBAEgiBhsgAygCmAEgBCAGGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyADQZQBaiIEIAIQNSADQQxqIAMoApQBIAQgAywAnwEiBEEASCIGGyADKAKYASAEIAYbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBDGoiBEG2uwFBBhAtIAEoAmggAUHoAGoiBiABLABzIgVBAEgiCBsgASgCbCAFIAgbEC1Bz5ACQQEQLRogA0GUAWoiBSACEDUgBCADKAKUASAFIAMsAJ8BIgRBAEgiBRsgAygCmAEgBCAFGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyADQQxqIgRBp78BQQYQLSABKAJ0IAFB9ABqIAEsAH8iBUEASCIIGyABKAJ4IAUgCBsQLUHPkAJBARAtGiADQZQBaiIFIAIQNSAEIAMoApQBIAUgAywAnwEiBEEASCIFGyADKAKYASAEIAUbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBDGoiBEHztwFBDRAtIAEoAoABIAFBgAFqIAEsAIsBIgVBAEgiCBsgASgChAEgBSAIGxAtQc+QAkEBEC0aIANBlAFqIgUgAhA1IAQgAygClAEgBSADLACfASICQQBIIgQbIAMoApgBIAIgBBsQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgA0EMakGXtQFBBhAtIAEoAmggBiABLABzIgJBAEgiBBsgASgCbCACIAQbEC1Bz5ACQQEQLRoCQAJ/IAMoAkAiAUEQcQRAIAMoAjwiASADKAIoIgJJBEAgAyACNgI8IAIhAQsgA0EkagwBCyABQQhxRQRAQQAhASAAQQA6AAsMAgsgAygCICEBIANBGGoLIQICQCABIAIoAgAiBGsiAUH4////B0kEQCABQQtPBEAgAUEHckEBaiIGECwhAiAAIAZBgICAgHhyNgIIIAAgAjYCACAAIAE2AgQgAiEADAILIAAgAToACyABDQFBACEBDAILEDgACyAAIAQgARA3GgsgACABakEAOgAAIANB7NUDKAIAIgA2AgwgAEEMaygCACADQQxqakH41QMoAgA2AgAgB0HwywM2AgAgAywAO0EASARAIAMoAjgaIAMoAjAQKgsgBxA9GiADQcQAahA7GiADQaABaiQAC7gDACMAQSBrIgMkACADIAEgAhB7IAMsABNBAEgEQCADKAIQGiADKAIIECoLAkAgAS0AYQRAIAAgAUG+JhCRAQwBCyADQRRqIAIQlgEgASwAc0EASARAIAEoAnAaIAEoAmgQKgsgASADKQIUNwJoIAEgAygCHDYCcCADQRRqIAIQlgEgASwAf0EASARAIAEoAnwaIAEoAnQQKgsgASADKQIUNwJ0IAEgAygCHDYCfCADQRRqIAIQlgEgASwAiwFBAEgEQCABKAKIARogASgCgAEQKgsgASADKQIUNwKAASABIAMoAhw2AogBIANBFGogAhCWASABLACXAUEASARAIAEoApQBGiABKAKMARAqCyABIAMpAhQ3AowBIAEgAygCHDYClAEgAi0AFEEBRgRAIANBADoAFCADQQA6AB8gAEECQeQAIANBFGoQLxogAywAH0EATg0BIAMoAhwaIAMoAhQQKgwBCyAAQZClBSkCADcCACAAQQhqIQBBo6UFLAAAQQBOBEAgAEGYpQUpAgA3AgAgAEGgpQUoAgA2AggMAQsgAEGYpQUoAgBBnKUFKAIAEC4LIANBIGokAAugBQEEfyMAQaABayIDJAAgA0Hk1QM2AkQgA0Hw1QMoAgAiBjYCDCADQQxqIgQgBkEMaygCAGpB9NUDKAIANgIAIAQgAygCDEEMaygCAGoiBiADQRBqIgUQPiAGQoCAgIBwNwJIIANB5NUDNgJEIANB0NUDNgIMIAUQPyIGQfDLAzYCACADQgA3AjggA0IANwIwIANBEDYCQCADQZQBaiIFIAEgAhBZIAQgAygClAEgBSADLACfASIEQQBIIgUbIAMoApgBIAQgBRsQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgA0GUAWoiBCACEDUgA0EMaiADKAKUASAEIAMsAJ8BIgJBAEgiBBsgAygCmAEgAiAEGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyADQQxqQee4AUEKEC0gASgCaCABQegAaiABLABzIgJBAEgiBBsgASgCbCACIAQbEC1Bz5ACQQEQLRoCQAJ/IAMoAkAiAUEQcQRAIAMoAjwiASADKAIoIgJJBEAgAyACNgI8IAIhAQsgA0EkagwBCyABQQhxRQRAQQAhASAAQQA6AAsMAgsgAygCICEBIANBGGoLIQICQCABIAIoAgAiBGsiAUH4////B0kEQCABQQtPBEAgAUEHckEBaiIFECwhAiAAIAVBgICAgHhyNgIIIAAgAjYCACAAIAE2AgQgAiEADAILIAAgAToACyABDQFBACEBDAILEDgACyAAIAQgARA3GgsgACABakEAOgAAIANB7NUDKAIAIgA2AgwgAEEMaygCACADQQxqakH41QMoAgA2AgAgBkHwywM2AgAgAywAO0EASARAIAMoAjgaIAMoAjAQKgsgBhA9GiADQcQAahA7GiADQaABaiQAC8gCACMAQSBrIgMkACADIAEgAhB7IAMsABNBAEgEQCADKAIQGiADKAIIECoLAkAgAS0AYQRAIAAgAUG9PhCRAQwBCwJAIAEtAGRBAXEEQCABLABzQQBIBEAgASgCaEEAOgAAIAFBADYCbAwCCyABQQA6AHMgAUEAOgBoDAELIANBFGogAhCWASABLABzQQBIBEAgASgCcBogASgCaBAqCyABIAMpAhQ3AmggASADKAIcNgJwCyACLQAUQQFGBEAgA0EAOgAUIANBADoAHyAAQQJB5AAgA0EUahAvGiADLAAfQQBODQEgAygCHBogAygCFBAqDAELIABBkKUFKQIANwIAIABBCGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgA0EgaiQACyUAIAEgAiADIAQgBSAGrSAHrUIghoQgCK0gCa1CIIaEIAARJAALIwAgASACIAMgBCAFrSAGrUIghoQgB60gCK1CIIaEIAARJQALGQAgASACIAMgBCAFrSAGrUIghoQgABEaAAsZACABIAIgA60gBK1CIIaEIAUgBiAAERgACxYAIAEgAq0gA61CIIaEIAQgABEXAKcLHQAgASACrSADrUIghoQgBK0gBa1CIIaEIAARHQALHgAgASACrSADrUIghoQgBK0gBa1CIIaEIAARFgCnCxMAIAEgAq0gA61CIIaEIAAREAALCgAgASAAERIApwvfAQECfyMAQSBrIgQkACAEQQxqIAEgAhB7IAQsAB9BAEgEQCAEKAIcGiAEKAIUECoLAkAgAS0AYQRAIAAgAUGayQAQkQEMAQsgAhBJIgVBAEgEQCAEQSAQLCIBNgIAIARCnoCAgICEgICAfzcCBCABQZGRASkAADcAACABQQA6AB4gAUGnkQEpAAA3ABYgAUGhkQEpAAA3ABAgAUGZkQEpAAA3AAggAEEGQegHIAQQLxogBCwAC0EATg0BIAQoAggaIAQoAgAQKgwBCyAAIAEgAiAFIAMQqQILIARBIGokAAsXACAAIAEgAiADrSAErUIghoQgBRCZBgsGAEHtxQALBgBB6fIACwUAQcczCxoAIABFBEBBAA8LIABB7LIEQfyzBBA5QQBHC40IAQd/IwBBoAFrIgMkACADQeTVAzYCRCADQfDVAygCACIHNgIMIANBDGoiBCAHQQxrKAIAakH01QMoAgA2AgAgBCADKAIMQQxrKAIAaiIHIANBEGoiBRA+IAdCgICAgHA3AkggA0Hk1QM2AkQgA0HQ1QM2AgwgBRA/IgdB8MsDNgIAIANCADcCOCADQgA3AjAgA0EQNgJAIANBlAFqIgUgASACEOIEIAQgAygClAEgBSADLACfASIEQQBIIgUbIAMoApgBIAQgBRsQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgA0GUAWoiBCACEDUgA0EMaiADKAKUASAEIAMsAJ8BIgRBAEgiBRsgAygCmAEgBCAFGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyADQQxqQeG8AUELEC0gAS8BeBA8QbUVQQEQLSABLwF6EDxBz5ACQQEQLRogASgCfCIEIAEoAoABIglHBEBBACEBA0AgA0GUAWoiBSACEDUgA0EMaiADKAKUASAFIAMsAJ8BIgVBAEgiBhsgAygCmAEgBSAGGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyADQQxqQcioAUEGEC0gARBCQcKKAkECEC0hBSADQZQBaiIGIAIQNSAFIAMoApQBIAYgAywAnwEiBkEASCIIGyADKAKYASAGIAgbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIAVBgbsBQQsQLSAELwEAEDxBz5ACQQEQLSEFIANBlAFqIgYgAhA1IAUgAygClAEgBiADLACfASIGQQBIIggbIAMoApgBIAYgCBsQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgBUG+tgFBCRAtIAQv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AjAgA0EQNgJAIANBlAFqIgUgASACEFkgBCADKAKUASAFIAMsAJ8BIgRBAEgiBRsgAygCmAEgBCAFGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCwJAIAEpAwggATUCIFoEQCADQZQBaiIEIAIQNSADQQxqIAMoApQBIAQgAywAnwEiAkEASCIEGyADKAKYASACIAQbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBDGpBmLYBQRYQLSABKQMIIAE1AiB9EIUBQc+QAkEBEC0aDAELIANBlAFqIgEgAhA1IANBDGogAygClAEgASADLACfASIBQQBIIgIbIAMoApgBIAEgAhsQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgA0EMakGlyQFBIBAtGgsCQAJ/IAMoAkAiAUEQcQRAIAMoAjwiASADKAIoIgJJBEAgAyACNgI8IAIhAQsgA0EkagwBCyABQQhxRQRAQQAhASAAQQA6AAsMAgsgAygCICEBIANBGGoLIQICQCABIAIoAgAiBGsiAUH4////B0kEQCABQQtPBEAgAUEHckEBaiIFECwhAiAAIAVBgICAgHhyNgIIIAAgAjYCACAAIAE2AgQgAiEADAILIAAgAToACyABDQFBACEBDAILEDgACyAAIAQgARA3GgsgACABakEAOgAAIANB7NUDKAIAIgA2AgwgAEEMaygCACADQQxqakH41QMoAgA2AgAgBkHwywM2AgAgAywAO0EASARAIAMoAjgaIAMoAjAQKgsgBhA9GiADQcQAahA7GiADQaABaiQACwkAIAAQ5QQQKgsVACAAKAIIIgBFBEBBAQ8LIAAQ7AQL1AEBAn8jAEEgayIDJAAgASACQQAgASgCACgCLBEEACEEIAIgAUH4AGoQlAEgAiAENgIMIANBDGogASACIAIoAgQgBCACKAIAamtBACABKAIAKAIwEQcAIAIgAigCBCACKAIAazYCDCADLAAfQQBIBEAgAygCHBogAygCFBAqCyAAQZClBSkCADcCACAAQQhqIQACQEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgA0EgaiQAC7gBAQd/A0ACQCAEIAlNDQAgAiADRg0AQQEhCCAAKAII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aiIFIApHDQALCyADQThqIgMgCEcNAAsLIAIgBjYCDCAEQQxqIAEgAiACKAIEIAYgAigCAGprQQAgASgCACgCMBEHACACIAIoAgQgAigCAGs2AgwgBCwAH0EASARAIAQoAhwaIAQoAhQQKgsgAEGQpQUpAgA3AgAgAEEIaiEAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyAEQSBqJAALygQBBH8jAEHwBGsiACQAIAAgAjYC6AQgACABNgLsBCAAQYYLNgIQIABByAFqIABB0AFqIABBEGoiARBrIQggAEHAAWoiCSAEKAIcIgc2AgAgB0HszgZHBEAgByAHKAIEQQFqNgIECyAJQZzQBhBDIQcgAEEAOgC/AQJAIABB7ARqIAIgAyAJIAQoAgQgBSAAQb8BaiAHIAggAEHEAWogAEHgBGoQ/wRFDQAgAEHeiAEoAAA2ALcBIABB14gBKQAANwOwASAHIABBsAFqIABBugFqIABBgAFqIAcoAgAoAjARCgAaIABBhQs2AhAgAEEIakEAIAEQayEDIAEhBAJAIAAoAsQBIAgoAgBrIgFBiQNOBEAgAUECdUECahBVIQIgAygCACEBIAMgAjYCACABBEAgASADKAIEEQAACyADKAIAIgRFDQELIAAtAL8BQQFGBEAgBEEtOgAAIARBAWohBAsgCCgCACECA0AgACgCxAEgAk0EQAJAIARBADoAACAAIAY2AgAgAEEQaiAAEKAFQQFHDQAgAygCACEBIANBADYCACABBEAgASADKAIEEQAACwwECwUgBCAAQbABaiAAQYABaiIBIAFBKGogAhCuAyABa0ECdWotAAA6AAAgBEEBaiEEIAJBBGohAgwBCwsQbAALEGwACyAAQewEaiAAQegEahBdBEAgBSAFKAIAQQJyNgIACyAAKALsBCEKIABBwAFqEEcgCCgCACEBIAhBADYCACABBEAgASAIKAIEEQAACyAAQfAEaiQAIAoLqAgBBn8jAEGQAWsiACQAIAAgAjYCiAEgACABNgKMASAAQYYLNgIUIABBGGogAEEgaiAAQRRqIggQayEJIABBEGoiByAEKAIcIgE2AgAgAUHszgZHBEAgASABKAIEQQFqNgIECyAHQaTQBhBDIQEgAEEAOgAPIABB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AghB/////wdxQQFrBUEKCxBQIAACfyABLQALQQd2BEAgASgCAAwBCyABCyICNgK0ASAAIABBEGo2AgwgAEEANgIIA0ACQCAAQcwCaiAAQcgCahBdDQAgACgCtAECfyABLQALQQd2BEAgASgCBAwBCyABLQALQf8AcQsgAmpGBEACfyABLQALQQd2BEAgASgCBAwBCyABLQALQf8AcQshAyABAn8gAS0AC0EHdgRAIAEoAgQMAQsgAS0AC0H/AHELQQF0EFAgASABLQALQQd2BH8gASgCCEH/////B3FBAWsFQQoLEFAgACADAn8gAS0AC0EHdgRAIAEoAgAMAQsgAQsiAmo2ArQBCwJ/IABBzAJqIggoAgAiAygCDCIJIAMoAhBGBEAgAyADKAIAKAIkEQEADAELIAkoAgALIAYgAiAAQbQBaiAAQQhqIAAoAsQCIABBxAFqIABBEGogAEEMaiAHEO4BDQAgCBB2GgwBCwsCQAJ/IAAtAM8BQQd2BEAgACgCyAEMAQsgAC0AzwFB/wBxC0UNACAAKAIMIgMgAEEQamtBnwFKDQAgACADQQRqNgIMIAMgACgCCDYCAAsgBSACIAAoArQBIAQgBhCbBTcDACAAQcQBaiAAQRBqIAAoAgwgBBCDASAAQcwCaiAAQcgCahBdBEAgBCAEKAIAQQJyNgIACyAAKALMAiEKIAEQRhogAEHEAWoQRhogAEHQAmokACAKC5sFAQV/IwBB0AJrIgAkACAAIAI2AsgCIAAgATYCzAIgAxCvASEGIAMgAEHQAWoQjAIhByAAQcQBaiADIABBxAJqEIsCIwBBEGsiAiQAIABBuAFqIgFCADcCACABQQA2AgggAkEQaiQAIAEgAS0AC0EHdgR/IAEoAghB/////wdxQQFrBUEKCxBQIAACfyABLQALQQd2BEAgASgCAAwBCyABCyICNgK0ASAAIABBEGo2AgwgAEEANgIIA0ACQCAAQcwCaiAAQcgCahBdDQAgACgCtAECfyABLQALQQd2BEAgASgCBAwBCyABLQALQf8AcQsgAmpGBEACfyABLQALQQd2BEAgASgCBAwBCyABLQALQf8AcQshAyABAn8gAS0AC0EHdgRAIAEoAgQMAQsgAS0AC0H/AHELQQF0EFAgASABLQALQQd2BH8gASgCCEH/////B3FBAWsFQQoLEFAg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IABB+AFqEF4EQCAEIAQoAgBBAnI2AgALIAAoAvwBIQggARBGGiAAQcABahBGGiAAQYACaiQAIAgLvQUBA38jAEGAAmsiACQAIAAgAjYC+AEgACABNgL8ASAAQcABaiADIABB0AFqIABBzwFqIABBzgFqELQDIwBBEGsiAiQAIABBtAFqIgFCADcCACABQQA2AgggAkEQaiQAIAEgAS0AC0EHdgR/IAEoAghB/////wdxQQFrBUEKCxBQIAACfyABLQALQQd2BEAgASgCAAwBCyABCyICNgKwASAAIABBEGo2AgwgAEEANgIIIABBAToAByAAQcUAOgAGA0ACQCAAQfwBaiAAQfgBahBeDQAgACgCsAECfyABLQALQQd2BEAgASgCBAwBCyABLQALQf8AcQsgAmpGBEACfyABLQALQQd2BEAgASgCBAwBCyABLQALQf8AcQshAyABAn8gAS0AC0EHdgRAIAEoAgQMAQsgAS0AC0H/AHELQQF0EFAgASABLQALQQd2BH8gASgCCEH/////B3FBAWsFQQoLEFAgACADAn8gAS0AC0EHdgRAIAEoAgAMAQsgAQsiAmo2ArABCwJ/IABB/AFqIgYoAgAiAygCDCIHIAMoAhBGBEAgAyADKAIAKAIkEQEADAELIActAAALwCAAQQdqIABBBmogAiAAQbABaiAALADPASAALADOASAAQcABaiAAQRBqIABBDGogAEEIaiAAQdABahCzAw0AIAYQdxoMAQsLAkACfyAALQDLAUEHdgRAIAAoAsQBDAELIAAtAMsBQf8AcQtFDQAgAC0AB0EBRw0AIAAoAgwiAyAAQRBqa0GfAUoNACAAIANBBGo2AgwgAyAAKAIINgIACyAFIAIgACgCsAEgBBCWBTgCACAAQcABaiAAQRBqIAAoAgwgBBCDASAAQfwBaiAAQfgBahBeBEAgBCAEKAIAQQJyNgIACyAAKAL8ASEIIAEQRhogAEHAAWoQRhogAEGAAmokACAIC8oGAQR/IwBBoAFrIgMkACADQeTVAzYCRCADQfDVAygCACIGNgIMIANBDGoiBCAGQQxrKAIAakH01QMoAgA2AgAgBCADKAIMQQxrKAIAaiIGIANBEGoiBRA+IAZCgICAgHA3AkggA0Hk1QM2AkQgA0HQ1QM2AgwgBRA/IgZB8MsDNgIAIANCADcCOCAD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IANBDGpB08cBQQsQLRoMAQsgA0EMakG9yQFBCBAtGgsCQAJ/IAMoAkAiAUEQcQRAIAMoAjwiAiADKAIoIgFJBEAgAyABNgI8IAEhAgsgA0EkagwBCyABQQhxRQRAQQAhAiAAQQA6AAsMAgsgAygCICECIANBGGoLIQECQCACIAEoAgAiBGsiAkH4////B0kEQCACQQtPBEAgAkEHckEBaiIFECwhASAAIAVBgICAgHhyNgIIIAAgATYCACAAIAI2AgQgASEADAILIAAgAjoACyACDQFBACECDAILEDgACyAAIAQgAhA3GgsgACACakEAOgAAIANB7NUDKAIAIgA2AgwgAEEMaygCACADQQxqakH41QMoAgA2AgAgBkHwywM2AgAgAywAO0EASARAIAMoAjgaIAMoAjAQKgsgBhA9GiADQcQAahA7GiADQaABaiQAC1QBAn8gASAAKAJUIgEgAUEAIAJBgAJqIgMQzAMiBCABayADIAQbIgMgAiACIANLGyICEDIaIAAgASADaiIDNgJUIAAgAzYCCCAAIAEgAmo2AgQgAgvSAQECfyMAQSBrIgMkACABIAJBACABKAIAKAIsEQQAIQQgAiABLQBkEEggAiAENgIMIANBDGogASACIAIoAgQgBCACKAIAamtBACABKAIAKAIwEQcAIAIgAigCBCACKAIAazYCDCADLAAfQQBIBEAgAygCHBogAygCFBAqCyAAQZClBSkCADcCACAAQQhqIQACQEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgA0EgaiQAC64BACMAQRBrIgMkACABIAIQUkEBcTYCZAJAIAItABRBAUYEQCADQQA6AAQgA0EAOgAPIABBAkHkACADQQRqEC8aIAMsAA9BAE4NASADKAIMGiADKAIEECoMAQsgAEGQpQUpAgA3AgAgAEEIaiEAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyADQRBqJAALlwIBBn8jAEEgayICJAACfwJAAkAgAUF/Rg0AIAIgATYCFCAALQAsQQFGBEACfyAAKAIgIgAoAkxBAEgEQCABIAAQtQUMAQsgASAAELUFC0F/Rg0CDAELIAIgAkEYaiIFNgIQIAJBIGohBiACQRRqIQMDQCAAKAIkIgQgACgCKCADIAUgAkEMaiACQRhqIAYgAkEQaiAEKAIAKAIMERMAIQQgAigCDCADRg0CIARBA0YEQCADQQFBASAAKAIgEHhBAUYNAgwDCyAEQQFLDQIgAkEYaiIDQQEgAigCECADayIDIAAoAiAQeCADRw0CIAIoAgwhAyAEQQFGDQALCyABQQAgAUF/RxsMAQtBfwshByACQSBqJAAgBwtlAQF/AkAgAC0ALEUEQCACQQAgAkEAShshAgNAIAIgA0YNAiAAIAEoAgAgACgCACgCNBEFAEF/RgRAIAMPBSABQQRqIQEgA0EBaiEDDAELAAsACyABQQQgAiAAKAIgEHghAgsgAgsxACAAIAAoAgAoAhgRAQAaIAAgAUG00AYQQyIBNgIkIAAgASABKAIAKAIcEQEAOgAsC6QCAQN/IwBBIGsiAiQAAkAgAUF/RgRAIAAtADQNASAAIAAoAjAiAUF/RzoANAwBCyAALQA0IQMCQAJAAkAgAC0ANUUEQCADQQFxDQEMAwsgA0EBcSIDBEAgACgCMCAAKAIgEKwFDQMMAgsgA0UNAgsgAiAAKAIwNgIQAkACQCAAKAIkIgMgACgCKCACQRBqIAJBFGoiBCACQQxqIAJBGGogAkEgaiAEIAMoAgAoAgwREwBBAWsOAwICAAELIAAoAjAhAyACIAJBGWo2AhQgAiADOgAYCwNAIAIoAhQiAyACQRhqTQ0CIAIgA0EBayIDNgIUIAMsAAAgACgCIBDxAUF/Rw0ACwtBfyEBDAELIABBAToANCAAIAE2AjALIAJBIGokACABCwkAIABBARCtBQsJACAAQQAQrQULgwUBBH8jAEGgAWsiAyQAIANB5NUDNgJEIANB8NUDKAIAIgY2AgwgA0EMaiIEIAZBDGsoAgBqQfTVAygCADYCACAEIAMoAgxBDGsoAgBqIgYgA0EQaiIFED4gBkKAgICAcDcCSCADQeTVAzYCRCADQdDVAzYCDCAFED8iBkHwywM2AgAgA0IANwI4IANCADcCMCADQRA2AkAgA0GUAWoiBSABIAIQWSAEIAMoApQBIAUgAywAnwEiBEEASCIFGyADKAKYASAEIAUbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBlAFqIgQgAhA1IANBDGogAygClAEgBCADLACfASICQQBIIgQbIAMoApgBIAIgBBsQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgA0EMakGtuAFBChAtIAEoAmQQQkHBkAJBDxAtGgJAAn8gAygCQCIBQRBxBEAgAygCPCICIAMoAigiAUkEQCADIAE2AjwgASECCyADQSRqDAELIAFBCHFFBEBBACECIABBADoACwwCCyADKAIgIQIgA0EYagshAQJAIAIgASgCACIEayICQfj///8HSQRAIAJBC08EQCACQQdyQQFqIgUQLCEBIAAgBUGAgICAeHI2AgggACABNgIAIAAgAjYCBCABIQAMAgsgACACOgALIAINAUEAIQIMAgsQOAALIAAgBCACEDcaCyAAIAJqQQA6AAAgA0Hs1QMoAgAiADYCDCAAQQxrKAIAIANBDGpqQfjVAygCADYCACAGQfDLAzYCACADLAA7QQBIBEAgAygCOBogAygCMBAqCyAGED0aIANBxABqEDsaIANBoAFqJAALSAAgACABQbTQBhBDIgE2AiQgACABIAEoAgAoAhgRAQA2AiwgACAAKAIkIgEgASgCACgCHBEBADoANSAAKAIsQQlOBEAQbAALC6YCAQd/IwBBIGsiAiQAAn8CQAJAIAFBf0YNACACIAHAIgM6ABcgAC0ALEEBRgRAIAAoAiAhBCMAQRBrIgAkACAAIAM6AA8gAEEPakEBQQEgBBB4IQcgAEEQaiQAIAdBAUcNAgwBCyACIAJBGGoiBTYCECACQSBqIQYgAkEXaiEDA0AgACgCJCIEIAAoAiggAyAFIAJBDGogAkEYaiAGIAJBEGogBCgCACgCDBETACEEIAIoAgwgA0YNAiAEQQNGBEAgA0EBQQEgACgCIBB4QQFGDQIMAwsgBEEBSw0CIAJBGGoiA0EBIAIoAhAgA2siAyAAKAIgEHggA0cNAiACKAIMIQMgBEEBRg0ACwsgAUEAIAFBf0cbDAELQX8LIQggAkEgaiQAIAgLZQEBfwJAIAAtACxFBEAgAkEAIAJBAEobIQIDQCACIANGDQIgACABLQAAIAAoAgAoAjQRBQBBf0YEQCADDwUgAUEBaiEBIANBAWohAwwBCwALAAsgAUEBIAIgACgCIBB4IQILIAILMQAgACAAKAIAKAIYEQEAGiAAIAFBrNAGEEMiATYCJCAAIAEgASgCACgCHBEBADoALAulAgEDfyMAQSBrIgIkAAJAIAFBf0YEQCAALQA0DQEgACAAKAIwIgFBf0c6ADQMAQsgAC0ANCEDAkACQAJAIAAtADVFBEAgA0EBcQ0BDAMLIANBAXEiAwRAIAAoAjAgACgCIBCwBQ0DDAILIANFDQILIAIgACgCMMA6ABMCQAJAIAAoAiQiAyAAKAIoIAJBE2ogAkEUaiIEIAJBDGogAkEYaiACQSBqIAQgAygCACgCDBETAEEBaw4DAgIAAQsgACgCMCEDIAIgAkEZajYCFCACIAM6ABgLA0AgAigCFCIDIAJBGGpNDQIgAiADQQFrIgM2AhQgAywAACAAKAIgEPEBQX9HDQALC0F/IQEMAQsgAEEBOgA0IAAgATYCMAsgAkEgaiQAIAELCQAgAEEBELEFC9oBAQJ/IwBBIGsiAyQAIAEgAkEAIAEoAgAoAiwRBAAhBCACIAEoAmRB2gBtQf8BcRBIIAIgBDYCDCADQQxqIAEgAiACKAIEIAQgAigCAGprQQAgASgCACgCMBEHACACIAIoAgQgAigCAGs2AgwgAywAH0EASARAIAMoAhwaIAMoAhQQKgsgAEGQpQUpAgA3AgAgAEEIaiEAAkBBo6UFLAAAQQBOBEAgAEGYpQUpAgA3AgAgAEGgpQUoAgA2AggMAQsgAEGYpQUoAgBBnKUFKAIAEC4LIANBIGokAAsJACAAQQAQsQULSAAgACABQazQBhBDIgE2AiQgACABIAEoAgAoAhgRAQA2AiwgACAAKAIkIgEgASgCACgCHBEBADoANSAAKAIsQQlOBEAQbAALCx4AQdzFBhCVAkGsyAYQlQJBsMYGEL8DQYDJBhC/AwuyAQAjAEEQayIDJAAgASACEFJBA3FB2gBsNgJkAkAgAi0AFEEBRgRAIANBADoABCADQQA6AA8gAEECQeQAIANBBGoQLxogAywAD0EATg0BIAMoAgwaIAMoAgQQKgwBCyAAQZClBSkCADcCACAAQQhqIQBBo6UFLAAAQQBOBEAgAEGYpQUpAgA3AgAgAEGgpQUoAgA2AggMAQsgAEGYpQUoAgBBnKUFKAIAEC4LIANBEGokAAsIACAAEDsQKgvQBwEHfyMAQaABayIDJAAgA0Hk1QM2AkQgA0Hw1QMoAgAiBjYCDCADQQxqIgUgBkEMaygCAGpB9NUDKAIANgIAIAUgAygCDEEMaygCAGoiBiADQRBqIgQQPiAGQoCAgIBwNwJIIANB5NUDNgJEIANB0NUDNgIMIAQQPyIGQfDLAzYCACADQgA3AjggA0IANwIwIANBEDYCQCADQZQBaiIEIAEgAhBZIAUgAygClAEgBCADLACfASIFQQBIIgQbIAMoApgBIAUgBBsQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgA0GUAWoiBSACEDUgA0EMaiADKAKUASAFIAMsAJ8BIgVBAEgiBBsgAygCmAEgBSAEGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyADQQxqQe++AUEKEC0gASgCaCABQegAaiABLABzIgVBAEgiBBsgASgCbCAFIAQbEC1Bz5ACQQEQLSEFIANBlAFqIgQgAhA1IAUgAygClAEgBCADLACfASICQQBIIgQbIAMoApgBIAIgBBsQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgBUGvtgFBDhAtGiADQRhqIQUgASgCdCICIAEoAngiCEcEQANAIAItAAAhCSAGIAMoAgxBDGsiASgCAGoiBCAEKAIAQbV/cUEIcjYCACAFIAEoAgBqQQI2AgAgASgCACADQQxqaiIEKAJMQX9GBEAgA0GUAWoiByAEKAIcIgE2AgAgAUHszgZHBEAgASABKAIEQQFqNgIECyAHQaTQBhBDIgFBICABKAIAKAIcEQUAGiAHEEcLIARBMDYCTCADQQxqIAkQQkHpxAFBARAtGiACQQFqIgIgCEcNAAsLIANBDGpBz5ACQQEQLRoCQAJAAn8gAygCQCIBQRBxBEAgA0EkaiEFIAMoAjwiAiADKAIoIgFJBH8gAyABNgI8IAEFIAILDAELIAFBCHFFBEBBACECIABBADoACwwDCyADKAIgCyAFKAIAIgVrIgJB+P///wdJBEAgAkELTwRAIAJBB3JBAWoiBBAsIQEgACAEQYCAgIB4cjYCCCAAIAE2AgAgACACNgIEIAEhAAwCCyAAIAI6AAsgAg0BQQAhAgwCCxA4AAsgACAFIAIQNxoLIAAgAmpBADoAACADQezVAygCACIANgIMIABBDGsoAgAgA0EMampB+NUDKAIANgIAIAZB8MsDNgIAIAMsADtBAEgEQCADKAI4GiADKAIwECoLIAYQPRogA0HEAGoQOxogA0GgAWokAAv+AQEEfyMAQSBrIgMkACABIAJBACABKAIAKAIsEQQAIQUgAiABQegAahCgASABKAJ0IgQgASgCeCIGRwRAA0AgAiAELQAAEEggBEEBaiIEIAZHDQALCyACIAU2AgwgA0EMaiABIAIgAigCBCAFIAIoAgBqa0EAIAEoAgAoAjARBwAgAiACKAIEIAIoAgBrNgIMIAMsAB9BAEgEQCADKAIcGiADKAIUECoLIABBkKUFKQIANwIAIABBCGohAAJAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyADQSBqJAALEwAgACAAKAIAQQxrKAIAahC/BQsTACAAIAAoAgBBDGsoAgBqELoDCxMAIAAgACgCAEEMaygCAGoQwAULEwAgACAAKAIAQQxrKAIAahC7AwuEBQEJfyMAQSBrIgQkACAEIAEgAhB7IAQsABNBAEgEQCAEKAIQGiAEKAIIECoLAkACQCABLQBhBEAgACABQamAARCRAQwBCyAEQRRqIAIQlgEgASwAc0EASARAIAEoAnAaIAEoAmgQKgsgASAEKQIUNwJoIAEgBCgCHDYCcCACKAIQBEADQCACEFIhAwJAIAEoAngiCSABKAJ8IgdJBEAgCSADOgAAIAlBAWohBgwBCyAJIAEoAnQiCGsiCkEBaiIFQQBIDQQgCkH/////ByAHIAhrIgdBAXQiBiAFIAUgBkkbIAdB/////wNPGyIGBH8gBhAsBUEACyIHaiIFIAM6AAAgBiAHaiEMIAVBAWohBgJAIAggCUYEQCAFIQcMAQtBACELIAkhAyAKQQNxIgoEQANAIAVBAWsiBSADQQFrIgMtAAA6AAAgC0EBaiILIApHDQALCyAIIAlrQXxNBEADQCAFQQFrIANBAWstAAA6AAAgBUECayADQQJrLQAAOgAAIAVBA2sgA0EDay0AADoAACAFQQRrIgUgA0EEayIDLQAAOgAAIAMgCEcNAAsLIAEoAnwaIAEoAnQhCAsgASAMNgJ8IAEgBjYCeCABIAc2AnQgCEUNACAIECoLIAEgBjYCeCACKAIQDQALCyACLQAUQQFGBEAgBEEAOgAUIARBADoAHyAAQQJB5AAgBEEUahAvGiAELAAfQQBODQEgBCgCHBogBCgCFBAqDAELIABBkKUFKQIANwIAIABBCGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgBEEgaiQADwsQNgALEwAgACAAKAIAQQxrKAIAahDBBQsTACAAIAAoAgBBDGsoAgBqELwDCxMAIAAgACgCAEEMaygCAGoQvQMLEwAgACAAKAIAQQxrKAIAahDpAQsKACAAQQhrEL0DCwoAIABBCGsQ6QELrgMBCH8jAEEgayIFJAAgASACQQAgASgCACgCLBEEACEGIAIgASgCbCABKAJoa0EEdRBKIAEoAmgiAyABKAJsIglHBEADQCADKAIAIQQCQCABLQBhRQRAIAIgBEH//wNxEE0MAQsgAiAEEEoLIAIgAygCCCADKAIEa0ECdkH/AXEQSCADKAIEIgQgAygCCCIKRwRAA0AgBC8BAiEHIAQtAAAhCAJAIAEtAGRBAXEEQCACIAdB//8BcUGAgH5BACAIQQFxG3JB//8DcRBNDAELIAIgB0H/AHFBgH9BACAIQQFxG3JB/wFxEEgLIARBBGoiBCAKRw0ACwsgA0EQaiIDIAlHDQALCyACIAY2AgwgBUEMaiABIAIgAigCBCAGIAIoAgBqa0EAIAEoAgAoAjARBwAgAiACKAIEIAIoAgBrNgIMIAUsAB9BAEgEQCAFKAIcGiAFKAIUECoLIABBkKUFKQIANwIAIABBCGohAAJAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyAFQSBqJAALGgAgACABIAIpAwhBACADIAEoAgAoAhARGAALCQAgABC+AxAqC7ICAQF/IAAgACgCACgCGBEBABogACABQazQBhBDIgE2AkQgAC0AYiECIAAgASABKAIAKAIcEQEAIgE6AGIgASACRwRAIABBADYCECAAQQA2AgwgAEEANgIIIABBADYCHCAAQQA2AhQgAEEANgIYIAAtAGAhASAALQBiQQFGBEACQCABQQFxRQ0AIAAoAiAiAUUNACABECoLIAAgAC0AYToAYCAAIAAoAjw2AjQgACgCOCEBIABCADcCOCAAIAE2AiAgAEEAOgBhDwsCQCABQQFxDQAgACgCICIB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ASACIAQbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBDGpB/7kBQR0QLSABLwFkEDxBz5ACQQEQLRoCQAJ/IAMoAkAiAUEQcQRAIAMoAjwiAiADKAIoIgFJBEAgAyABNgI8IAEhAgsgA0EkagwBCyABQQhxRQRAQQAhAiAAQQA6AAsMAgsgAygCICECIANBGGoLIQECQCACIAEoAgAiBGsiAkH4////B0kEQCACQQtPBEAgAkEHckEBaiIFECwhASAAIAVBgICAgHhyNgIIIAAgATYCACAAIAI2AgQgASEADAILIAAgAjoACyACDQFBACECDAILEDgACyAAIAQgAhA3GgsgACACakEAOgAAIANB7NUDKAIAIgA2AgwgAEEMaygCACADQQxqakH41QMoAgA2AgAgBkHwywM2AgAgAywAO0EASARAIAMoAjgaIAMoAjAQKgsgBhA9GiADQcQAahA7GiADQaABaiQAC6QBAQN/IwBBgAFrIgMkACADIAEoAgg2AgAgA0EQaiIBQbvyACADENwCIAEQWCICQfj///8HSQRAAkACQCACQQtPBEAgAkEHckEBaiIEECwhASAAIARBgICAgHhyNgIIIAAgATYCACAAIAI2AgQgASEADAELIAAgAjoACyACRQ0BCyAAIANBEGogAhAyGgsgACACakEAOgAAIANBgAFqJAAPCxA4AAv4CQEMfyAAQQE2AgQgACgCDCIBIAEoAsQCQQFrNgLEAiABIAEoAsgCQQFqNgLIAiAAKAIMIgEoAnwiCigC7IMBIQkgASAAIAooAvyDASIMQQFrIgMgACgCCCAAKAIYELUBIAAoAggiAkEASgRAIAAoAgwgACADIAJBAWsgACgCGBC1ASAAKAIIIQILIAJBAWoiASAKKAKEhAFIBEAgACgCDCAAIAMgASAAKAIYELUBIAAoAggiAkEBaiEBCyAAKAIUIQUgACgCECEDIAEgCXQhAQJAAkACQCACIAl0IgJBAXFFBEAgAygCHCIHIAEgASAHShsiBEEBcQ0BIAUoAnwiASgCyIMBQQdqQQhtIQcgASgCwIMBQQdqQQhtIQYgAygCKCIBIAUoAihGDQIgAiAETg0DIAIhAQNAIAUoAgQgASAGbCIIIAUoAihsaiADKAIEIAggAygCKGxqIAMoAhggBmwQMhogAUEBaiIB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BUH8////B3EhCyAFQQNxIQlBACEDIAVBBEkhDANAIAAgA0EBdGohAiAGIAMgBWxBAXRqIQdBACEKIAxFBEADQCACIAcvAQA7AQAgAiABQQF0IghqIgIgBy8BAjsBACACIAhqIgIgBy8BBDsBACACIAhqIgIgBy8BBjsBACACIAhqIQIgB0EIaiEHIApBBGoiCiALRw0ACwtBACEIIAkEQANAIAIgBy8BADsBACAHQQJqIQcgAiABQQF0aiECIAhBAWoiCCAJRw0ACwsgA0EBaiIDIARHDQALCwurAQAjAEEQayIDJAAgASACEE47AWICQCACLQAUQQFGBEAgA0EAOgAEIANBADoADyAAQQJB5AAgA0EEahAvGiADLAAPQQBODQEgAygCDBogAygCBBAqDAELIABBkKUFKQIANwIAIABBCGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgA0EQaiQACxkAIAAgASACIAMgBCAFIAZBAkEDIAcQwgELGQAgACABIAIgAyAEIAUgBkECQQIgBxDCAQsZACAAIAEgAiADIAQgBSAGQQJBASAHEMIBC5ADAQV/AkAgBUEATA0AIARBAEwNACAHQQhrIQogAkEGayELA0AgBiAJQQF0aiECIAsgAyAJbEEBdGohB0EAIQgDQCACIAcvAQJBAnQgBy8BAGsgBy8BCCAHLwEGakEobGogBy8BDEECdGogBy8BDmsgBy8BCiAHLwEEakF1bGogCnU7AQAgB0ECaiEHIAIgBUEBdGohAiAIQQFqIgggBEcNAAsgCUEBaiIJIAVHDQALIAVBAEwNACAFQfz///8HcSELIAVBA3EhCUEAIQMgBUEESSEMA0AgACADQQF0aiECIAYgAyAFbEEBdGohB0EAIQogDEUEQANAIAIgBy8BADsBACACIAFBAXQiCGoiAiAHLwECOwEAIAIgCGoiAiAHLwEEOwEAIAIgCGoiAiAHLwEGOwEAIAIgCGohAiAHQQhqIQcgCkEEaiIKIAtHDQALC0EAIQggCQRAA0AgAiAHLwEAOwEAIAdBAmohByACIAFBAXRqIQIgCEEBaiIIIAlHDQALCyADQQFqIgMgBEcNAAsLCxkAIAAgASACIAMgBCAFIAZBAUEDIAcQwgELGQAgACABIAIgAyAEIAUgBkEBQQIgBxDCAQsZACAAIAEgAiADIAQgBSAGQQFBASAHEMIBC40DAQV/AkAgBUEATA0AIARBAEwNACAHQQhrIQogAkEGayELA0AgBiAJQQF0aiECIAsgAyAJbEEBdGohB0EAIQgDQCACIAcvAQwgBy8BAkECdCAHLwEAayAHLwEEQXZsaiAHLwEGQTpsaiAHLwEIQRFsaiAHLwEKQXtsamogCnU7AQAgB0ECaiEHIAIgBUEBdGohAiAIQQFqIgggBEcNAAsgCUEBaiIJIAVHDQALIAVBAEwNACAFQfz///8HcSELIAVBA3EhCUEAIQMgBUEESSEMA0AgACADQQF0aiECIAYgAyAFbEEBdGohB0EAIQogDEUEQANAIAIgBy8BADsBACACIAFBAXQiCGoiAiAHLwECOwEAIAIgCGoiAiAHLwEEOwEAIAIgCGoiAiAHLwEGOwEAIAIgCGohAiAHQQhqIQcgCkEEaiIKIAtHDQALC0EAIQggCQRAA0AgAiAHLwEAOwEAIAdBAmohByACIAFBAXRqIQIgCEEBaiIIIAlHDQALCyADQQFqIgMgBEcNAAsLC6kDAQt/IAVBBmohDAJAIAVBBGoiD0F/TgRAIARBAEwNASAGQQRqIRAgBEH8////B3EhESAEQQNxIQ1BfiELIARBBEkhEgNAIBAgC0EBdGohCSACIAMgC2xBAXRqIQhBACEOIBJFBEADQCAJIAgvAQA7AQAgCSAMQQF0IgpqIgkgCC8BAjsBACAJIApqIgkgCC8BBDsBACAJIApqIgkgCC8BBjsBACAJIApqIQkgCEEIaiEIIA5BBGoiDiARRw0ACwtBACEKIA0EQANAIAkgCC8BADsBACAIQQJqIQggCSAMQQF0aiEJIApBAWoiCiANRw0ACwsgC0EBaiILIA9HDQALCyAEQQBMDQAgBUEATA0AIAdBCGshA0EAIQIgAUEBdCEBA0AgACACQQF0aiEJIAYgAiAMbEEBdGohCEEAIQoDQCAJIAguAQAgCC4BAkF7bGogCC4BBEERbGogCC4BBkE6bGogCC4BCEF2bGogCC4BCkECdGogCC4BDGsgA3U7AQAgCEECaiEIIAEgCWohCSAKQQFqIgogBUcNAAsgAkEBaiICIARHDQALCwusAwELfyAFQQdqIQwCQCAFQQRqIg9Bfk4EQCAEQQBMDQEgBkEGaiEQIARB/P///wdxIREgBEEDcSENQX0hCyAEQQRJIRIDQCAQIAtBAXRqIQkgAiADIAtsQQF0aiEIQQAhDiASRQRAA0AgCSAILwEAOwEAIAkgDEEBdCIKaiIJIAgvAQI7AQAgCSAKaiIJIAgvAQQ7AQAgCSAKaiIJIAgvAQY7AQAgCSAKaiEJIAhBCGohCCAOQQRqIg4gEUcNAAsLQQAhCiANBEADQCAJIAgvAQA7AQAgCEECaiEIIAkgDEEBdGohCSAKQQFqIgogDUcNAAsLIAtBAWoiCyAPRw0ACwsgBEEATA0AIAVBAEwNACAHQQhrIQNBACECIAFBAXQhAQNAIAAgAkEBdGohCSAGIAIgDGxBAXRqIQhBACEKA0AgCSAILgECQQJ0IAguAQBrIAguAQggCC4BBmpBKGxqIAguAQxBAnRqIAguAQ5rIAguAQogCC4BBGpBdWxqIAN1OwEAIAhBAmohCCABIAlqIQkgCkEBaiIKIAVHDQALIAJBAWoiAiAERw0ACwsL2wEBAn8jAEEgayIDJAAgASACQQAgASgCACgCLBEEACEEIAIgASgCZBBKIAIgASgCaBBKIAIgBDYCDCADQQxqIAEgAiACKAIEIAQgAigCAGprQQAgASgCACgCMBEHACACIAIoAgQgAigCAGs2AgwgAywAH0EASARAIAMoAhwaIAMoAhQQKgsgAEGQpQUpAgA3AgAgAEEIaiEAAkBBo6UFLAAAQQBOBEAgAEGYpQUpAgA3AgAgAEGgpQUoAgA2AggMAQsgAEGYpQUoAgBBnKUFKAIAEC4LIANBIGokAAupAwELfyAFQQZqIQwCQCAFQQNqIg9Bfk4EQCAEQQBMDQEgBkEGaiEQIARB/P///wdxIREgBEEDcSENQX0hCyAEQQRJIRIDQCAQIAtBAXRqIQkgAiADIAtsQQF0aiEIQQAhDiASRQRAA0AgCSAILwEAOwEAIAkgDEEBdCIKaiIJIAgvAQI7AQAgCSAKaiIJIAgvAQQ7AQAgCSAKaiIJIAgvAQY7AQAgCSAKaiEJIAhBCGohCCAOQQRqIg4gEUcNAAsLQQAhCiANBEADQCAJIAgvAQA7AQAgCEECaiEIIAkgDEEBdGohCSAKQQFqIgogDUcNAAsLIAtBAWoiCyAPRw0ACwsgBEEATA0AIAVBAEwNACAHQQhrIQNBACECIAFBAXQhAQNAIAAgAkEBdGohCSAGIAIgDGxBAXRqIQhBACEKA0AgCSAILgEMIAguAQJBAnQgCC4BAGsgCC4BBEF2bGogCC4BBkE6bGogCC4BCEERbGogCC4BCkF7bGpqIAN1OwEAIAhBAmohCCABIAlqIQkgCkEBaiIKIAVHDQALIAJBAWoiAiAERw0ACwsLFwAgACABIAIgAyAEIAUgBkEDQQMQwwELFwAgACABIAIgAyAEIAUgBkEDQQIQwwELFwAgACABIAIgAyAEIAUgBkEDQQEQwwELgAMBBn8CQCAFQQBMDQAgBEEATA0AIAJBAmshCgNAIAYgCUEBdGohByAKIAMgCWxqIQJBACEIA0AgByACLQAAIAItAAFBe2xqIAItAAJBEWxqIAItAANBOmxqIAItAARBdmxqIAItAAVBAnRqIAItAAZrOwEAIAJBAWohAiAHIAVBAXRqIQcgCEEBaiIIIARHDQALIAlBAWoiCSAFRw0ACyAFQQBMDQAgBUH8////B3EhCyAFQQNxIQpBACEDIAVBBEkhDANAIAAgA0EBdGohByAGIAMgBWxBAXRqIQJBACEJIAxFBEADQCAHIAIvAQA7AQAgByABQQF0IghqIgcgAi8BAjsBACAHIAhqIgcgAi8BBDsBACAHIAhqIgcgAi8BBjsBACAHIAhqIQcgAkEIaiECIAlBBGoiCSALRw0ACwtBACEIIAoEQANAIAcgAi8BADsBACACQQJqIQIgByABQQF0aiEHIAhBAWoiCCAKRw0ACwsgA0EBaiIDIARHDQALCwsXACAAIAEgAiADIAQgBSAGQQJBAxDDAQsXACAAIAEgAiADIAQgBSAGQQJBAhDDAQsXACAAIAEgAiADIAQgBSAGQQJBARDDAQuDAwEGfwJAIAVBAEwNACAEQQBMDQAgAkEDayEKA0AgBiAJQQF0aiEHIAogAyAJbGohAkEAIQgDQCAHIAItAAFBAnQgAi0AAGsgAi0ABCACLQADakEobGogAi0ABkECdGogAi0AB2sgAi0ABSACLQACakF1bGo7AQAgAkEBaiECIAcgBUEBdGohByAIQQFqIgggBEcNAAsgCUEBaiIJIAVHDQALIAVBAEwNACAFQfz///8HcSELIAVBA3EhCkEAIQMgBUEESSEMA0AgACADQQF0aiEHIAYgAyAFbEEBdGohAkEAIQkgDEUEQANAIAcgAi8BADsBACAHIAFBAXQiCGoiByACLwECOwEAIAcgCGoiByACLwEEOwEAIAcgCGoiByACLwEGOwEAIAcgCGohByACQQhqIQIgCUEEaiIJIAtHDQALC0EAIQggCgRAA0AgByACLwEAOwEAIAJBAmohAiAHIAFBAXRqIQcgCEEBaiIIIApHDQALCyADQQFqIgMgBEcNAAsLC+8FAQR/IwBBoAFrIgMkACADQeTVAzYCRCADQfDVAygCACIGNgIMIANBDGoiBCAGQQxrKAIAakH01QMoAgA2AgAgBCADKAIMQQxrKAIAaiIGIANBEGoiBRA+IAZCgICAgHA3AkggA0Hk1QM2AkQgA0HQ1QM2AgwgBRA/IgZB8MsDNgIAIANCADcCOCADQgA3AjAgA0EQNgJAIANBlAFqIgUgASACEFkgBCADKAKUASAFIAMsAJ8BIgRBAEgiBRsgAygCmAEgBCAFGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyADQZQBaiIEIAIQNSADQQxqIAMoApQBIAQgAywAnwEiBEEASCIFGyADKAKYASAEIAUbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBDGoiBEGruwFBChAtIAEoAmQQPEHPkAJBARAtGiADQZQBaiIFIAIQNSAEIAMoApQBIAUgAywAnwEiAkEASCIEGyADKAKYASACIAQbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBDGpBoLsBQQoQLSABKAJoEDxBz5ACQQEQLRoCQAJ/IAMoAkAiAUEQcQRAIAMoAjwiAiADKAIoIgFJBEAgAyABNgI8IAEhAgsgA0EkagwBCyABQQhxRQRAQQAhAiAAQQA6AAsMAgsgAygCICECIANBGGoLIQECQCACIAEoAgAiBGsiAkH4////B0kEQCACQQtPBEAgAkEHckEBaiIFECwhASAAIAVBgICAgHhyNgIIIAAgATYCACAAIAI2AgQgASEADAILIAAgAjoACyACDQFBACECDAILEDgACyAAIAQgAhA3GgsgACACakEAOgAAIANB7NUDKAIAIgA2AgwgAEEMaygCACADQQxqakH41QMoAgA2AgAgBkHwywM2AgAgAywAO0EASARAIAMoAjgaIAMoAjAQ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A0EkagwBCyABQQhxRQRAQQAhASAAQQA6AAsMAgsgAygCICEBIANBGGoLIQICQCABIAIoAgAiBGsiAUH4////B0kEQCABQQtPBEAgAUEHckEBaiIFECwhAiAAIAVBgICAgHhyNgIIIAAgAjYCACAAIAE2AgQgAiEADAILIAAgAToACyABDQFBACEBDAILEDgACyAAIAQgARA3GgsgACABakEAOgAAIANB7NUDKAIAIgA2AgwgAEEMaygCACADQQxqakH41QMoAgA2AgAgBkHwywM2AgAgAywAO0EASARAIAMoAjgaIAMoAjAQKgsgBhA9GiADQcQAahA7GiADQaABaiQACw0AIABBBCABIAIQ6QILDwAgACACQSAgASADEOoCCw8AIAAgAkEQIAEgAxDqAgsPACAAIAJBCCABIAMQ6gILDwAgACACQQQgASADEOoCCw0AIAAgAkEgIAEQ6wILDQAgACACQRAgARDrAgsNACAAIAJBCCABEOsCC60DAgR/AX4jAEEgayIDJAAgAyABIAIQeyADLAATQQBIBEAgAygCEBogAygCCBAqCwJAIAEtAGEEQCAAIAFBhsQAEJEBDAELIAIQUiEEIAIoAgAiBSAFKAIAKAIIERIAIQggAigCACIFIAggBK18IAUoAgAoAgwREAAEQCADQQA6ABQgA0EAOgAfIABBAkHkACADQRRqEC8aIAMsAB9BAE4NASADKAIcGiADKAIUECoMAQsgAUHoAGohBQJAIAEoAmwgASgCaCIHayIGIARJBEAgBSAEIAZrEGUMAQsgBCAGTw0AIAEgBCAHajYCbAsgBARAQQAhAQNAIAIQUiEGIAUoAgAgAWogBjoAACABQQFqIgEgBEcNAAsLIAItABRBAUYEQCADQQA6ABQgA0EAOgAfIABBAkHkACADQRRqEC8aIAMsAB9BAE4NASADKAIcGiADKAIUECoMAQsgAEGQpQUpAgA3AgAgAEEIaiEAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyADQSBqJAALDQAgACACQQQgARDrAgsPACAAQSAgASACIAMQ7AILDwAgAEEQIAEgAiADEOwCCw8AIABBCCABIAIgAxDsAgsPACAAQQQgASACIAMQ7AILowsBGX8gAS4BCiEc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LRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgA0GUAWoiBCACEDUgA0EMaiADKAKUASAEIAMsAJ8BIgRBAEgiBRsgAygCmAEgBCAFGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyADQQxqQZDDAUEJEC0gASgCaBA8Qc+QAkEBEC0hBCADQZQBaiIFIAIQNSAEIAMoApQBIAUgAywAnwEiBUEASCIGGyADKAKYASAFIAYbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIARB1LEBQRcQLSABLwFsEDxBz5ACQQEQLSEEIANBlAFqIgUgAhA1IAQgAygClAEgBSADLACfASIFQQBIIgYbIAMoApgBIAUgBhsQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgBEHBvgFBCxAtIQggAyABKAJwEKQBIAggAygCACADIAMsAAsiBEEASCIFGyADKAIEIAQgBRsQLUHPkAJBARAtIQQgA0GUAWoiBSACEDUgBCADKAKUASAFIAMsAJ8BIgVBAEgiBhsgAygCmAEgBSAGGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyAEQaK/AUELEC0gASgCdCABQfQAaiABLAB/IgRBAEgiBRsgASgCeCAEIAUbEC1Bz5ACQQEQLRogAywAC0EASARAIAMoAggaIAMoAgAQKgsgASgCcCIEQeXapesGRgR/IANBlAFqIgQgAhA1IANBDGogAygClAEgBCADLACfASIEQQBIIgUbIAMoApgBIAQgBRsQLRogAywAnwFBAEgEQCADKAKcARogAygClAEQKgsgA0EMakHyvQFBDhAtIAEoAoABIAFBgAFqIAEsAIsBIgRBAEgiBRsgASgChAEgBCAFGxAtQc+QAkEBEC0hBCADQZQBaiIFIAIQNSAEIAMoApQBIAUgAywAnwEiBUEASCIGGyADKAKYASAFIAYbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIARBjbsBQRIQLSABKAKMASABQYwBaiABLACXASIEQQBIIgUbIAEoApABIAQgBRsQLUHPkAJBARAtGiABKAJwBSAEC0Gg0smrB0YEQCADQZQBaiIEIAIQNSADQQxqIAMoApQBIAQgAywAnwEiBEEASCIFGyADKAKYASAEIAUbEC0aIAMsAJ8BQQBIBEAgAygCnAEaIAMoApQBECoLIANBDGpB+r4BQQ8QLSABKAKYASABQZgBaiABLACjASIEQQBIIgUbIAEoApwBIAQgBRsQLUHPkAJBARAtGgsgA0GUAWoiBCACEDUgA0EMaiADKAKUASAEIAMsAJ8BIgJBAEgiBBsgAygCmAEgAiAEGxAtGiADLACfAUEASARAIAMoApwBGiADKAKUARAqCyADQQxqQca5AUENEC0iAiACKAIAQQxrKAIAaiIEIAQoAgRBAXI2AgQgAiABLQCkARDQAkHPkAJBARAtGgJAAn8gAygCQCIBQRBxBEAgAygCPCIBIAMoAigiAkkEQCADIAI2AjwgAiEBCyADQSRqDAELIAFBCHFFBEBBACEBIABBADoACwwCCyADKAIgIQEgA0EYagshAgJAIAEgAigCACIEayIBQfj///8HSQRAIAFBC08EQCABQQdyQQFqIgUQLCECIAAgBUGAgICAeHI2AgggACACNgIAIAAgATYCBCACIQAMAgsgACABOgALIAENAUEAIQEMAgsQOAALIAAgBCABEDcaCyAAIAFqQQA6AAAgA0Hs1QMoAgAiADYCDCAAQQxrKAIAIANBDGpqQfjVAygCADYCACAHQfDLAzYCACADLAA7QQBIBEAgAygCOBogAygCMBAqCyAHED0aIANBxABqEDsaIANBoAFqJAALBwAgACgCFAslAQF/IAFBAk0EfyAAKAJ8IAFBAnRB3OwCaigCAGooAgAFQQALCyIBAX8gAUECTQR/IAAgAUECdEHQ7AJqKAIAaigCAAVBAAsLIgEBfyABQQJNBH8gACABQQJ0QcTsAmooAgBqKAIABUEACwsJACAAIAEQigYLkgMBA38jAEEgayIDJAAgASACQQAgASgCACgCLBEEACEFAkAgAS0AYSIEQQFNBEAgAiABLwFoEE0gAiABLwFsEE0gAiABQfQAahCgASACIAFBgAFqEKABIAIgAUGMAWoQoAEgAS0AYSIEQQJJDQELAkACQAJAIARBAmsOAgABAgsgAiABLwFoEE0MAQsgAiABKAJoEEoLIAIgAS8BbBBNIAIgASgCcBBKIAIgAUH0AGoQoAEgAiABKAJwIgRBoNLJqwdGBH9BmAEFIARB5dql6wZHDQEgAiABQYABahCgAUGMAQsgAWoQoAEL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CBEAACAIECsLIA9FDQAgDyAPKAIEIgBBAWs2AgQgAA0AIA8gDygCACgCCBEAACAPECsLIAdBgAFqJAAL/wEBAn8jAEEgayIFJAACQCACKAIABEAgAEEANgIIIABCADcCAAwBCyACKAIEQQNHBEAgAEEANgIIIABCADcCAAwBCyAEKAIEQQJHBEAgAEEANgIIIABCADcCAAwBCyACKAIMQQhMBEAgAEEANgIIIABCADcCAAwBCyACLwEYRQRAIABBADYCCCAAQgA3AgAMAQsgAygCBCEGIABBADYCCCAAQgA3AgAgBkECRw0AIAVBBGoQxgEiAUKAgICAIDcCACABIAItAAg6AAggASACKAIMNgIMIAEgAigCFDYCFCABIAIoABc2ABcgBUELNgIAIAAgASAFEGILIAVBIGokAAu1AQIDfwF+IABBADYAeUECIAAtAHgiASABQQJNGyABIAAoAmwiAyAAKAJoIgFrQeD//wBLGyECIAEgA0YEf0EEBQNAQQFBAiACIAJBAkwbIAIgASgCAEH//wNLGyICIAJBAUwbIAIgAS0ABBshAiABKAIQKQMQIAR8IQQgAUEgaiIBIANHDQALQQhBBCAEQoCAgIAPfUKAgICAcFQbCyEBIABBhAg7AHkgACABOgB7IAAgAjoAYQuxFQEdfyMAQYABayIHJAAgAigCAEEAEEAhASACKAIAQQEQQCEEIAIoAgBBAhBAIQUgAigCAEEGEGQiFARAIAIoAgBBBhBAIRULAkACQAJAIAFBCEsNACAEQQhLDQAgBUEJSQ0BCyAAQgA3AgAgAEGkpQUpAgA3AgggAEEQaiEAQbelBSwAAEEATgRAIABBrKUFKQIANwIAIABBtKUFKAIANgIIDAILIABBrKUFKAIAQbClBSgCABAuDAELIAEgBEYgASAFRnFFBEAgAEIANwIAIABBpKUFKQIANwIIIABBEGohAEG3pQUsAABBAE4EQCAAQaylBSkCADcCACAAQbSlBSgCADYCCAwCCyAAQaylBSgCAEGwpQUoAgAQLgwBCyACKAIAIgMoAjAiDgRAIA4gDigCBEEBajYCBCACKAIAIQMLIAMoAhwhCiADKAIYIQtBiAEQLCIIQazjBDYCACAIQgA3AgQgCEEUakEAQegAEDQaIAggCCgCBCIJQQFqIg82AgQgCEIANwI4IAhC44CA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LQAAOgAAIAEgCSANbGogAyANIBJsai0AADoAACACQQJqIQIgFkECaiIWIBFHDQALCyAQQQFxRQ0AIAQgAiATbGogBiACIA9sai0AADoAACABIAIgCWxqIAMgAiASbGotAAA6AAALIApFDQELIAtBAWsiAwRAQQAhAQNAIAEgEmwhBCABIA9sIQYgGiABIAlsaiENIBkgASATbGohEEEAIQIDQCAYIAIgBGpqIhEtAAAhFiARLQABIREgECACQQF2IiJqIBcgAiAGamoiIy0AACAjLQABakEBakEBdjoAACANICJqIBEgFmpBAWpBAXY6AAAgAkECaiICIANJDQALIAFBAWoiASAKRw0ACwsgCyAVQQhLdCEBQQAhAgNAIB0gAiAebGogGyACIBxsaiALEDIaIBQEQCAhIAIgBWxqIB8gAiAgbGogARAyGgsgAkEBaiICIApHDQALCyAAIAg2AgQgACAMNgIAIAggCCgCBEEBajYCBCAAQZClBSkCADcCCCAAQRBqIQBBo6UFLAAAQQBOBEAgAEGYpQUpAgA3AgAgAEGgpQUoAgA2AggMAQsgAEGYpQUoAgBBnKUFKAIAEC4LIAggCCgCBCIAQQFrNgIEIABFBEAgCCAIKAIAKAIIEQAAIAgQKwsgDkUNACAOIA4oAgQiAEEBazYCBCAADQAgDiAOKAIAKAIIEQAAIA4QKwsgB0GAAWokAAv/AQECfyMAQSBrIgUkAAJAIAIoAgAEQCAAQQA2AgggAEIANwIADAELIAIoAgRBA0cEQCAAQQA2AgggAEIANwIADAELIAQoAgRBAkcEQCAAQQA2AgggAEIANwIADAELIAIoAgxBCU4EQCAAQQA2AgggAEIANwIADAELIAIvARhFBEAgAEEANgIIIABCADcCAAwBCyADKAIEIQYgAEEANgIIIABCADcCACAGQQJHDQAgBUEEahDGASIBQoCAgIAgNwIAIAEgAi0ACDoACCABIAIoAgw2AgwgASACKAIUNgIUIAEgAigAFzYAFyAFQQs2AgAgACABIAUQYgsgBUEgaiQAC5cYASJ/IwBBgAFrIgckACACKAIAQQAQQCEDIAIoAgBBARBAIQUgAigCAEECEEAhCSACKAIAQQYQZCIaBEAgAigCAEEGEEAhGwsCQAJAAkAgA0EJSQ0AIAVBCUkNACAJQQhLDQELIABC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QQAMAQtBACABKAIQQQZKDQAaIAEoAjQhGSABKAIsCyEFAn9BACADKAIAIgFFDQAaIAMhAgNAIAIgASABKAIQQQpIIgYbIQIgASAGQQJ0aigCACIBDQALQQAgAiADRg0AGkEAIAIoAhBBCkoNABogAigCNCETIAIoAiwLIQMgEQRAIA1BfnEhFCANQQFxIRUgDUEBayEWQQAhAgNAAkAgBC0ACEUEQCANRQ0BIAMgAiATbGohCyAPIAIgEmxqIQxBACEBQQAhBiAWBEADQCALIAFBA2xqIgggASAMai0AACIJOgAAIAggCToAAiAIIAk6AAEgCyABQQFyIglBA2xqIgggCSAMai0AACIJOgACIAggCToAASAIIAk6AAAgAUECaiEBIAZBAmoiBiAURw0ACwsgFUUNASALIAFBA2xqIgYgASAMai0AACIBOgAAIAYgAToAAiAGIAE6AAEMAQsgF0UEQCANRQ0BIAMgAiATbGohCyAPIAIgEmxqIQxBACEBQQAhBiAWBEADQCALIAFBAnRqIgggASAMai0AACIJOgAAIAhB/wE6AAMgCCAJOgACIAggCToAASAMIAFBAXIiCWotAAAhCCALIAlBAnRqIglB/wE6AAMgCSAIOgACIAkgCDoAASAJIAg6AAAgAUECaiEBIAZBAmoiBiAURw0ACwsgFUUNASALIAFBAnRqIgYgASAMai0AACIBOgAAIAZB/wE6AAMgBiABOgACIAYgAToAAQwBCyANRQ0AIAIgGWwhBiADIAIgE2xqIQsgDyACIBJsaiEMQQAhAUEAIQkgFgRAA0AgCyABQQJ0aiIIIAEgDGotAAAiEDoAACAIIBA6AAIgCCAQOgABIAggBSABIAZqai0AADoAAyALIAFBAXIiEEECdGoiCCAMIBBqLQAAIhg6AAIgCCAYOgABIAggGDoAACAIIAUgBiAQamotAAA6AAMgAUECaiEBIAlBAmoiCSAURw0ACwsgFUUNACALIAFBAnRqIgsgASAMai0AACIMOgAAIAsgDDoAAiALIAw6AAEgCyAFIAEgBmpqLQAAOgADCyACQQFqIgIgEUcNAAsLIAAgBzYCBCAAIA42AgAgByAHKAIEQQFqNgIEIABBkKUFKQIANwIIIABBEGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwB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IARCADcCXCAEQgA3AmQgBEIANwJsIARCADcAcSAEIARBDGoiCzYCDCAEIAQoAghBAWo2AgggBCABNgIEIAQgBDYCECAIRQRAIAQgBCgCACgCCBEAACAEECsLAkAgAigCACIBKAIkQQxrIgpBBE8EQCAAQgA3AgAgAEGkpQUpAgA3AgggAEEQaiEAQbelBSwAAEEATgRAIABBrKUFKQIANwIAIABBtKUFKAIANgIIDAILIABBrKUFKAIAQbClBSgCABAuDAELIAEoAhghCCABKAIcIgwhASALIApBAnRBmOsCaigCADYCJCALQQE2AiAgCyABNgIcIAsgCDYCGCAFQQhqIAtBCiAIIAwgAigCAEEKEEAgBhA6IAUoAggEQCAAQgA3AgAgACAFKQMINwIIIABBEGohACAFLAAbQQBOBEAgACAFKQIQNwIAIAAgBSgCGDYCCAwCCyAAIAUoAhAgBSgCFBAuIAUsABtBAE4NASAFKAIYGiAFKAIQECoMAQsgBSwAG0EASARAIAUoAhgaIAUoAhAQKgtBACEGAn8CQCACKAIAIgEoAkAiAkUNACABQUBrIgghAQNAIAEgAiACKAIQQQpIIgobIQEgAiAKQQJ0aigCACICDQALIAEgCEYNAEEAIAEoAhBBCkoNARogASgCLCEPIAEoAjQMAQtBAAshCgJ/QQAgAygCACICRQ0AGiADIQEDQCABIAIgAigCEEEKSCIGGyEBIAIgBkECdGooAgAiAg0ACyABIANGBEBBACEGQQAMAQtBACEGQQAgASgCEEEKSg0AGiABKAI0IQYgASgCLAshEAJAIAxFDQAgBiAKIAYgCkkbIgFFDQAgAUEBayIBQQF2QQFqIgJBfHEhESACQQNxIQ4gAUEGSSESA0AgECAGIA1saiEBIA8gCiANbGohA0EAIQJBACEIIBJFBEADQCABIAJqIgcgAiADaiIJLQABOgAAIAcgCS0AADoAASABIAJBAnIiB2oiCSADIAdqIgctAAE6AAAgCSAHLQAAOgABIAEgAkEEciIHaiIJIAMgB2oiBy0AAToAACAJIActAAA6AAEgASACQQZyIgdqIgkgAyAHaiIHLQABOgAAIAkgBy0AADoAASACQQhqIQIgCEEEaiIIIBFHDQALC0EAIQggDgRAA0AgASACaiIHIAIgA2oiCS0AAToAACAHIAktAAA6AAEgAkECaiECIAhBAWoiCCAORw0ACwsgDUEBaiINIAxHDQALCyAAIAQ2AgQgACALNgIAIAQgBCgCBEEBajYCBCAAQZClBSkCADcCCCAAQRBqIQBBo6UFLAAAQQBOBEAgAEGYpQUpAgA3AgAgAEGgpQUoAgA2AggMAQsgAEGYpQUoAgBBnKUFKAIAEC4LIAQgBCgCBCIAQQFrNgIEIABFBEAgBCAEKAIAKAIIEQAAIAQQKwsgBUEgaiQAC7wCACMAQSBrIgEkAAJAAkAgAigCAEEBRgRAIAIoAgRBfHFBDEYNAQsgAEEANgIIIABCADcCAAwBCyAAQQA2AgggAEIANwIAIAFBAToAHiABQYKACDYCGCABQQA6AAwgAULjgICAsAw3AgQgAUEINgIQIAFBzOYENgIUIAFBAjsBHCABQQE6AB4gAUEGOwEcIAFBgYA0NgIYAkACQCACKAIEIgNBDGsOAwABAAELIAFBADoADCABQQE2AgQgAUEMQQ4gA0EORhs2AgggASACKAIMNgIQIAFBCzYCACAAIAFBBGogARBiIAIoAgQhAwsCQCADQQ1rDgMAAQABCyABQQE6AAwgAUEBNgIEIAFBDUEPIANBD0YbNgIIIAEgAigCDDYCECABQQs2AgAgACABQQRqIAEQYgsgAUEgaiQAC/oQARN/IwBBgAFrIgMkACAELQAIIQkgAigCACgCJCEMQYgBECwiBUGs4wQ2AgAgBUIANwIEIAVBFGpBAEHoABA0GiAFIAUoAgQiBEEBaiIINgIEIAVCADcCOCAFQuOAgICwDDcCLCAFQa4gNgIgIAVBQGtCADcCACAFQQA2AoQBIAVCADcCfCAFQoGAgIAQNwJUIAUgBUHMAGoiATYCSCAFQgA3AlwgBUIANwJkIAVCADcCbCAFQgA3AHEgBSAFQQxqIgo2AgwgBSAFKAIIQQFqNgIIIAUgBDYCBCAFIAU2AhAgCEUEQCAFIAUoAgAoAggRAAAgBRArCyACKAIAIgQoAhghCCAEKAIcIg0hBCAKQQM2AiQgCkEBNgIgIAogBDYCHCAKIAg2AhggA0E4aiAKQQMgCCANQQggBhA6IANBIGogCkEEIAggDUEIIAYQOiADQdgAaiEEAkAgAygCOARAIAMgAykDODcDUCADLABLQQBOBEAgBCADQUBrIgcpAwA3AwAgBCAHKAIINgIIDAILIAQgAygCQCADKAJEEC4MAQsgAyADKQMgNwNQIAMsADNBAE4EQCAEIAMpAyg3AwAgBCADKAIwNgIIDAELIAQgAygCKCADKAIsEC4LIANBCGogCkEFIAggDUEIIAYQOiADQfAAaiEHAkAgAygCUARAIAMgAykDUDcDaCADLABjQQBOBEAgByAEKQMANwMAIAcgBCgCCDYCCAwCCyAHIAMoAlggAygCXBAuDAELIAMgAykDCDcDaCADLAAbQQBOBEAgByADKQMQNwMAIAcgAygCGDYCCAwBCyAHIAMoAhAgAygCFBAuCyADLAAbQQBIBEAgAygCGBogAygCEBAqCyADLABjQQBIBEAgAygCYBogAygCWBAqCyADLAAzQQBIBEAgAygCMBogAygCKBAqCyADLABLQQBIBEAgAygCSBogAygCQBAqCwJAIAMoAmgEQCAAQgA3AgAgACADKQNoNwIIIABBEGohACADLAB7QQBOBEAgACAHKQIANwIAIAAgBygCCDYCCAwCCyAAIAMoAnAgAygCdBAuIAMsAHtBAE4NASADKAJ4GiADKAJwECoMAQsgAywAe0EASARAIAMoAngaIAMoAnAQKgsCQCAJQQFxRQ0AIANB6ABqIApBBiAIIA1BCCAGEDogAygCaARAIABCADcCACAAIAMpA2g3AgggAEEQaiEAIAMsAHtBAE4EQCAAIAMpAnA3AgAgACADKAJ4NgIIDAMLIAAgAygCcCADKAJ0EC4gAywAe0EATg0CIAMoAngaIAMoAnAQKgwCCyADLAB7QQBODQAgAygCeBogAygCcBAqCwJ/AkAgAigCACICKAJAIgZFDQAgAkFAayIEIQIDQCACIAYgBigCEEEKSCIHGyECIAYgB0ECdGooAgAiBg0ACyACIARGDQBBACACKAIQQQpKDQEaIAIoAiwhEiACKAI0DAELQQALIRMCfwJAIAEoAgAiAgRAIAEhBCACIQYDQCAEIAYgBigCEEEDSCIHGyEEIAYgB0ECdGooAgAiBg0ACwJ/QQAgASAERg0AGkEAIAQoAhBBA0oNABogBCgCNCEUIAQoAiwLIRUgASEEIAIhBgNAIAQgBiAGKAIQQQRIIgcbIQQgBiAHQQJ0aigCACIGDQALAn9BACABIARGDQAaQQAgBCgCEEEESg0AGiAEKAIsIRYgBCgC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QQJ0aigCACICDQALAn9BACABIAZGDQAaQQAgBigCEEEESg0AGiAGKAI0IRUgBigCLAshESABIQYgBCECA0AgBiACIAIoAhBBBUgiEhshBiACIBJBAnRqKAIAIgINAAsgASAGRw0BC0EADAELQQAgBigCEEEFSg0AGiAGKAI0IRYgBigCLAshEgJ/QQAgAygCACICRQ0AGiADIQYDQCAGIAIgAigCEEEKSCIMGyEGIAIgDEECdGooAgAiAg0ACyADIAZGBEBBACEMQQAMAQtBACEMQQAgBigCEEEKSg0AGiAGKAI0IQwgBigCLAshF0EAIQYCf0EAIARFIAlBAXNyDQAaIAEhAgNAIAIgBCAEKAIQQQZIIgMbIQIgBCADQQJ0aigCACIEDQALQQAgASACRg0AGkEAIAIoAhBBBkoNABogAigCNCEGIAIoAiwLIQMCQCAPRQ0AIAkEQCAORQ0BQQAhAQNAIAEgBmwhCSASIAEgFmxqIQogESABIBVsaiELIBQgASAQbGohCCAXIAEgDGxqIRhBACEEA0AgGCAEQQN0aiICQQA6AAAgBCAIai0AACETIAJBADoAAiACIBM6AAEgBCALai0AACETIAJBADoABCACIBM6AAMgBCAKai0AACETIAJBADoABiACIBM6AAUgAiADIAQgCWpqLQAAOgAHIARBAWoiBCAORw0ACyABQQFqIgEgD0cNAAsMAQsgDkUNAEEIQQYgC0EBcRshBkEAIQMgCkEBcQRAA0AgEiADIBZsaiECIBEgAyAVbGohCSAUIAMgEGxqIQogFyADIAxsaiELQQAhBANAIAsgBCAGbGoiAUEAOgAAIAQgCmotAAAhCCABQQA6AAIgASAIOgABIAQgCWotAAAhCCABQQA6AAQgASAIOgADIAIgBGotAAAhCCABQYD+AzsABiABIAg6AAUgBEEBaiIEIA5HDQALIANBAWoiAyAPRw0ADAILAAsDQCASIAMgFmxqIQQgESADIBVsaiEJIBQgAyAQbGohCiAXIAMgDGxqIQtBACECA0AgCyACIAZsaiIBQQA6AAAgAiAKai0AACEIIAFBADoAAiABIAg6AAEgAiAJai0AACEIIAFBADoABCABIAg6AAMgASACIARqLQAAOgAFIAJBAWoiAiAORw0ACyADQQFqIgMgD0cNAAsLIAAgBTYCBCAAIA02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CEEBajYCCCAFIAc2AgQgBSAFNgIQIAhFBEAgBSAFKAIAKAIIEQAAIAUQKwsgDUEDNgIkIA1BADYCICANIA42AhwgDSAKNgIYIAQtAAghCCACKAIAKAIkIQ8gA0E4aiANQQAgCiAOQQggBhA6IANBIGogDUEBIAogDkEIIAYQOiADQdgAaiEEAkAgAygCOARAIAMgAykDODcDUCADLABLQQBOBEAgBCADQUBrIgcpAwA3AwAgBCAHKAIINgIIDAILIAQgAygCQCADKAJEEC4MAQsgAyADKQMgNwNQIAMsADNBAE4EQCAEIAMpAyg3AwAgBCADKAIwNgIIDAELIAQgAygCKCADKAIsEC4LIANBCGogDUECIAogDkEIIAYQOiADQfAAaiEHAkAgAygCUARAIAMgAykDUDcDaCADLABjQQBOBEAgByAEKQMANwMAIAcgBCgCCDYCCAwCCyAHIAMoAlggAygCXBAuDAELIAMgAykDCDcDaCADLAAbQQBOBEAgByADKQMQNwMAIAcgAygCGDYCCAwBCyAHIAMoAhAgAygCFBAuCyADLAAbQQBIBEAgAygCGBogAygCEBAqCyADLABjQQBIBEAgAygCYBogAygCWBAqCyADLAAzQQBIBEAgAygCMBogAygCKBAqCyADLABLQQBIBEAgAygCSBogAygCQBAqCwJAIAMoAmgEQCAAQgA3AgAgACADKQNoNwIIIABBEGohACADLAB7QQBOBEAgACAHKQIANwIAIAAgBygCCDYCCAwCCyAAIAMoAnAgAygCdBAuIAMsAHtBAE4NASADKAJ4GiADKAJwECoMAQsgAywAe0EASARAIAMoAngaIAMoAnAQKgsCQCAIQQFxRQ0AIANB6ABqIA1BBiAKIA5BCCAGEDogAygCaARAIABCADcCACAAIAMpA2g3AgggAEEQaiEAIAMsAHtBAE4EQCAAIAMpAnA3AgAgACADKAJ4NgIIDAMLIAAgAygCcCADKAJ0EC4gAywAe0EATg0CIAMoAngaIAMoAnAQKgwCCyADLAB7QQBODQAgAygCeBogAygCcBAqCwJ/AkAgAigCACICKAJAIgZFDQAgAkFAayICIQQDQCAEIAYgBigCEEEKSCIHGyEEIAYgB0ECdGooAgAiBg0ACyACIARGDQBBACAEKAIQQQpKDQEaIAQoAjQhFiAEKAIs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GSALQQNxIRYgEUEBcSEPIAtBBEkhIUEAIQUDQCAUIAUgGGxqIQMgHSAFIBxsaiEEAkAgIwRAIB8gBSAebGohDCAXIAUgG2xqIRJBACEBA0AgASADakH/AQJ/IAEgDGotAACzIAcqAjyUIAEgEmotAACzIAcqAjSUIAcqAjggASAEai0AALOUkpIiKSApQwAAW0OUQwAAgDuUQwAAgEGSIA8bQwAAAD+SIimLQwAAAE9dBEAgKagMAQtBgICAgHgLIgYgBkH/AU8bQQAgBkEAThs6AAAgAUEBaiIBIAtHDQALDAELQQAhAQJAIA8EQEEAIQZBACEMICENAQNAIAEgA2ogASAEai0AADoAACADIAFBAXIiEmogBCASai0AADoAACADIAFBAnIiEmogBCASai0AADoAACADIAFBA3IiEmogBCASai0AADoAACABQQRqIQEgDEEEaiIMIBlHDQALDAELA0AgASADakH/AQJ/IAEgBGotAACzQwAAW0OUQwAAgDuUQwAAgEGSQwAAAD+SIimLQwAAAE9dBEAgKagMAQtBgICAgHgLIgYgBkH/AU8bQQAgBkEAThs6AAAgCyABQQFqIgFHDQALDAELIBZFDQADQCABIANqIAEgBGotAAA6AAAgAUEBaiEBIAZBAWoiBiAWRw0ACwsgBUEBaiIFIA1HDQALIBNBAkYhFiAOIBNyQQJJISFBACEDA0AgHyADIB5sIgFqIQUgJSADIBNuIgQgJGwiD2ohBgJAICMEQCAfIANBAWoiASADIAEgDUkbIAMgFhsiASAebGohDyAdIAEgHGxqIQwgFyABIBtsaiEUIB0gAyAcbGohGCAXIAMgG2xqIRkgIiAEICZsaiESQQAhAQNAIAEgBWotAACzISkgASAYai0AALMhKiABIBlqLQAAsyErICFFBEAgKSAFIAFBAWoiBCABIAQgC0kbIAEgDkECRhsgASAWGyIEai0AALOSIAEgD2otAACzkiAEIA9qLQAAs5JDAACAPpQhKSArIAQgGWotAACzkiABIBRqLQAAs5IgBCAUai0AALOSQwAAgD6UISsgKiAEIBhqLQAAs5IgASAMai0AALOSIAQgDGotAACzkkMAAIA+lCEqCyAHKgJUIS0gByoCTCEuIAcqAlAhLyAGIAEgDm4iJ2pB/wECfyApIAcqAkiUICsgByoCQJQgKiAHKgJElJKSIiwgLEMAAGBDlEMAAIA7lCARQQFxIigbQwAAAEOSQwAAAD+SIiyLQwAAAE9dBEAgLKgMAQtBgICAgHgLIgQgBEH/AU8bQQAgBEEAThs6AAAgEiAnakH/AQJ/ICkgLZQgKyAulCAqIC+UkpIiKSApQwAAYEOUQwAAgDuUICgbQwAAAEOSQwAAAD+SIimLQwAAAE9dBEAgKagMAQtBgICAgHgLIgQgBEH/AU8bQQAgBEEAThs6AAAgASAOaiIBIAtJDQALDAELIAEgF2ohBCAPICJqIQ9BACEBIBFBAXFFBEADQCAGIAEgDm4iFGpB/wECfyABIAVqLQAAs0MAAGBDlEMAAIA7lEMAAIBBkkMAAAA/kiIpi0MAAABPXQRAICmoDAELQYCAgIB4CyIMIAxB/wFPG0EAIAxBAE4bOgAAIA8gFGpB/wECfyABIARqLQAAs0MAAGBDlEMAAIA7lEMAAIBBkkMAAAA/kiIpi0MAAABPXQRAICmoDAELQYCAgIB4CyIMIAxB/wFPG0EAIAxBAE4bOgAAIAsgASAOaiIBSw0ADAILAAsDQCAGIAEgDm4iDGogASAFai0AADoAACAMIA9qIAEgBGotAAA6AAAgASAOaiIBIAtJDQALCyADIBNqIgMgDUkNAAsLAkAgGkUNACACKAIAQQYQQCEBIA1FDQAgCyABQQhLdCECQQAhASANQQFHBEAgDUF+cSEEQQAhAwNAIAogASAJbGogICABIBVsaiACEDIaIAogAUEBciIFIAlsaiAgIAUgFWxqIAIQMhogAUECaiEBIANBAmoiAyAERw0ACwsgDUEBcUUNACAKIAEgCWxqICAgASAVbGogAhAyGgsgACAINgIEIAAgEDYCACAIIAgoAgRBAWo2AgQgAEGQpQUpAgA3AgggAEEQaiEAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyAIIAgoAgQiAEEBazYCBCAADQAgCCAIKAIAKAIIEQAAIAgQKwsgB0GgAWokAAsJACAAEJ8GECoLrwMBAX8jAEEgayIBJAACQCACKAIMIgVBCU4EQCAAQQA2AgggAEIANwIADAELIAVBCEcEQCAAQQA2AgggAEIANwIADAELAkAgAigCAEEBRgRAIAIoAgRBA0YNAQsgAEEANgIIIABCADcCAAwBCwJAIAMvARgiBUEOSw0AQQEgBXRBgJIBcUUNACAAQQA2AgggAEIANwIADAELIABBADYCCCAAQgA3AgAgAUEBOgAeIAFBAjsBHCABQYKACDYCGCABQQA6AAwgAULjgICAsAw3AgQgAUEINgIQIAFBzOYENgIUIAFBAToAHiABQQY7ARwgAUGBgDQ2AhgCQCADKAIEIgVBA0YNACAEKAIEQQFHBEAgBC0ADA0BCyABIAU2AgggAUEANgIEIAEgAi0ACDoADCABIAIoAgw2AhAgASADKAAXNgAbIAEgAygCFDYCGCABQQs2AgAgACABQQRqIAEQYgwBCyABQoCAgIAwNwIEIAEgAi0ACDoADCABIAIoAgw2AhAgASADKAAXNgAbIAEgAygCFDYCGCABQQs2AgAgACABQQRqIAEQYgsgAUEgaiQACw8AIABBuJkFNgIAIAAQKgsNACAAQbiZBTYCACAACw8AIABB7JgFNgIAIAAQKgsNACAAQeyYBTYCACAACw8AIABBoJgFNgIAIAAQKgsNACAAQaCYBTYCACAACw8AIABB1JcFNgIAIAAQKgsNACAAQdSXBTYCACAACw8AIABBiJcFNgIAIAAQKgsNACAAQYiXBTYCACAACw8AIABBvJYFNgIAIAAQKgsNACAAQbyWBTYCACAACw8AIABB8JUFNgIAIAAQKgsNACAAQfCVBTYCACAACw8AIABBpJUFNgIAIAAQKgsNACAAQaSVBTYCACAACw8AIABB2JQFNgIAIAAQKgsNACAAQdiUBTYCACAACw8AIABBsJQFNgIAIAAQKgsNACAAQbCUBTYCACAACw8AIABBiJQFNgIAIAAQKgsNACAAQYiUBTYCACAACw8AIABB4JMFNgIAIAAQKgsNACAAQeCTBTYCACAACw8AIABBuJMFNgIAIAAQKgsNACAAQbiTBTYCACAACw8AIABBkJMFNgIAIAAQKgsNACAAQZCTBTYCACAACw8AIABBxJIFNgIAIAAQKgsNACAAQcSSBTYCACAACw8AIABB+JEFNgIAIAAQKgsNACAAQfiRBTYCACAACw8AIABB0JEFNgIAIAAQKgsNACAAQdCRBTYCACAACw8AIABBqJEFNgIAIAAQKgsNACAAQaiRBTYCACAACw8AIABBgJEFNgIAIAAQ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CBEAACABECsLIAAoArQDIgEEQCAAIAE2ArgDIAAoArwDGiABECoLIAAQdBAqC5MBAQJ/IABBhIwFNgIAAkAgACgC5AMiAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsCQCAAKALcAyIBRQ0AIAEgASgCBCICQQFrNgIEIAINACABIAEoAgAoAggRAAAgARArCyAAKAK0AyIBBEAgACABNgK4AyAAKAK8AxogARAqCyAAEHQLkgMBCn8jAEFAaiIBJAAgAUEAOgAoIAFCADcCNCABQgA3AyAgAUIANwIsIAFBDGogACABQSxqQQBBABDjAyABLAAfQQBIBEAgASgCHBogASgCFBAqCyAAKALgAyECIAEoAjQhBSABQQA2AjQgASgCJCEEIAFBADYCJCABKAIgIQMgAUEANgIgIAEoAiwhBiABKAIwIQcgAUIANwIsIAEoAjghCCABLQAoIQkgAiADNgIEIAIoAgghAyACIAQ2AggCQCADRQ0AIAMgAygCBCIEQQFrNgIEIAQNACADIAMoAgAoAggRAAAgAxArCyACIAk6AAwgAigCECIDBEAgAiADNgIUIAIoAhgaIAMQKgsgAiAINgIcIAIgBTYCGCACIAc2AhQgAiAGNgIQIAAoAuADIgAgACgCACgCEBEBACEKIAEoAiwiAARAIAEgADYCMCABKAI0GiAAECoLAkAgASgCJCIARQ0AIAAgACgCBCIDQQFrNgIEIAMNACAAIAAoAgAoAggRAAAgABArCyABQUBrJAAgCgsRACAAIAAoAmhB//8DSzoAYQuSAwEKfyMAQUBqIgEkACABQQA6ACggAUIANwI0IAFCADcDICABQgA3AiwgAUEMaiAAIAFBLGpBAEEAEOMDIAEsAB9BAEgEQCABKAIcGiABKAIUECoLIAAoAuADIQIgASgCNCEFIAFBADYCNCABKAIkIQQgAUEANgIkIAEoAiAhAyABQQA2AiAgASgCLCEGIAEoAjAhByABQgA3AiwgASgCOCEIIAEtACghCSACIAM2AgQgAigCCCEDIAIgBDYCCAJAIANFDQAgAyADKAIEIgRBAWs2AgQgBA0AIAMgAygCACgCCBEAACADECsLIAIgCToADCACKAIQIgMEQCACIAM2AhQgAigCGBogAxAqCyACIAg2AhwgAiAFNgIYIAIgBzYCFCACIAY2AhAgACgC4AMiACAAKAIAKAIMEQEAIQogASgCLCIABEAgASAANgIwIAEoAjQaIAAQKgsCQCABKAIkIgBFDQAgACAAKAIEIgNBAWs2AgQgAw0AIAAgACgCACgCCBEAACAAECsLIAFBQGskACAKC78GAQl/IwBB4ABrIgQkACAEQTBqIAFBAEEAEKEGAkAgBCgCTARAIAAgBCkCTDcCACAAQQhqIQAgBCwAX0EATgRAIAAgBCkCVDcCACAAIAQoAlw2AggMAgsgACAEKAJUIAQoAlgQLgwBCyABKALgAyEFIAQoAkQhCCAEQQA2AkQgBCgCNCEHIARBADYCNCAEKAIwIQYgBEEANgIwIAQoAjwhCSAEKAJAIQogBEIANwI8IAQoAkghCyAELQA4IQwgBSAGNgIEIAUoAgghBiAFIAc2AggCQCAGRQ0AIAYgBigCBCIHQQFrNgIEIAcNACAGIAYoAgAoAggRAAAgBhArCyAFIAw6AAwgBSgCECIGBEAgBSAGNgIUIAUoAhgaIAYQKgsgBSALNgIcIAUgCDYCGCAFIAo2AhQgBSAJNgIQIARBGGogASgC4AMiBSACIAMgBSgCACgCFBEGAAJAIAQoAhgEQCAAIAQpAxg3AgAgACAEKAIoNgIQIAAgBCkDIDcCCCAEQQA2AiggBEIANwMgDAELIARBBGohBQJAIAIoAgANACABKALAASEGIAEoAsQBIgEEQCABIAEoAgRBAWo2AgQLAkAgBkUNACAGLwEIDQAgAkEBNgIAIANBAzYCAAsgAUUNACABIAEoAgQiAkEBazYCBCACDQAgASABKAIAKAIIEQAAIAEQKwsgBUGQpQUpAgA3AgAgBUEIaiEBAkBBo6UFLAAAQQBOBEAgAUGYpQUpAgA3AgAgAUGgpQUoAgA2AggMAQsgAUGYpQUoAgBBnKUFKAIAEC4LIAQsABdBAEgEQCAEKAIUGiAEKAIMECoLIABBkKUFKQIANwIAIABBCGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgBCwAK0EATg0AIAQoAigaIAQoAiAQKgsgBCwAX0EASARAIAQoAlwaIAQoAlQQKgsgBCgCPCIABEAgBCAANgJAIAQoAkQaIAAQKgsCQCAEKAI0IgBFDQAgACAAKAIEIgFBAWs2AgQgAQ0AIAAgACgCACgCCBEAACAAECsLIARB4ABqJAALGAAgASAAKAKAAzYCACACIAAoAoQDNgIAC5ABAQR/IABBAEHIABA0IgAgASgC+AIiBCABKAKAAyIDakEBayADbjYCBCABKAKEAyECIAAgASgC/AIiBTYCGCAAIAQ2AhQgACACNgIQIAAgAzYCDCAAIAIgBWpBAWsgAm42AgggACABLQCOAyICOgAkIAIEQCAAQShqIAFBkANqQQggAiACQQhPG0ECdBAyGgsL0AUBB38jAEEwayIGJAACQCADBEAjAEEwayIDJAAgAyABIAQgBRChBgJAIAMoAhwEQCAAQgA3AgAgACADKQIcNwIIIABBEGohACADLAAvQQBOBEAgACADKQIkNwIAIAAgAygCLDYCCAwCCyAAIAMoAiQgAygCKBAuDAELIAEoAuADIQQgAygCFCEIIANBADYCFCADKAIEIQcgA0EANgIEIAMoAgAhBSADQQA2AgAgAygCDCEJIAMoAhAhCiADQgA3AgwgAygCGCELIAMtAAghDCAEIAU2AgQgBCgCCCEFIAQgBzYCCAJAIAVFDQAgBSAFKAIEIgdBAWs2AgQgBw0AIAUgBSgCACgCCBEAACAFECsLIAQgDDoADCAEKAIQIgUEQCAEIAU2AhQgBCgCGBogBRAqCyAEIAs2AhwgBCAINgIYIAQgCjYCFCAEIAk2AhAgACABKALgAyIAIAIgACgCACgCHBEDAAsgAywAL0EASARAIAMoAiwaIAMoAiQQKgsgAygCDCIABEAgAyAANgIQIAMoAhQaIAAQKgsCQCADKAIEIgBFDQAgACAAKAIEIgFBAWs2AgQgAQ0AIAAgACgCACgCCBEAACAAECsLIANBMGokAAwBCyAGQTAQLCIBNgIMIAZCqYCAgICGgICAfzcCECABQd3TAC0AADoAKCABQdXTACkAADcAICABQc3TACkAADcAGCABQcXTACkAADcAECABQb3TACkAADcACCABQbXTACkAADcAACABQQA6ACkgBkEYakEEQQAgBkEMahAvIQEgAEIANwIAIAAgASkDADcCCCAAQRBqIQACQCABLAATQQBOBEAgACABKQIINwIAIAAgASgCEDYCCAwBCyAAIAEoAgggASgCDBAuIAEsABNBAE4NACABKAIQGiABKAIIECoLIAYsABdBAE4NACAGKAIUGiAGKAIMECoLIAZBMGokAAuJCgIPfwZ+IwBBIGsiBiQAIAZBFGohBQJ/IAAoAoQDIgEgACgC/AJqQQFrIAFuIAAoAoADIgEgACgC+AJqQQFrIAFubCIBIAAtAI4DIgJFDQAaIAAoApADIAFsIgMgAkEBayIBRQ0AGiAAKAKUAyADbCICIAFBAUYNABogACgCmAMgAmwiAiABQQJGDQAaIAAoApwDIAJsIgIgAUEDRg0AGiAAKAKgAyACbCICIAFBBEYNABogACgCpAMgAmwiAiABQQVGDQAaIAAoAqgDIAJsIgIgAUEGRg0AGiAAKAKsAyACbAshASAALQCNAyEPIAAtAIwDIQ4gBUEANgIIIAVCADcCACAPIA5qQQN2IAFsIgEEQCAFIAEQZQsgACgCtAMiCCAAKAK4AyIMRwRAA0AgAC0AjAMiAkEDdiEBAkAgAkEISQ0AIAgpAwAhESABrSISQgGDIRUgBSgCACAEaiECQgAhECABQQFHBEAgEkIegyEUQgAhEgNAIAIgEKciA2oiByARIANB/v///wFzIAFqQQN0rYg8AAEgByARIANBf3MgAWpBA3StiDwAACAQQgJ8IRAgEkICfCISIBRSDQALCyAVUA0AIAIgEKciA2ogESADQX9zIAFqQQN0rYg8AAALIAEgBGohBCAALQCNAyIBBEAgAUEDdiECAkAgAUEISQ0AIAgoAgghAyAFKAIAIARqIQlBACEKQQAhASACQQFrQQNPBEAgAkEccSENQQAhCwNAIAEgCWoiByADIAFB/v///wFzIAJqQQN0djoAASAHIAMgAUF/cyACakEDdHY6AAAgByADIAFB/f///wFzIAJqQQN0djoAAiAHIAMgAUH8////AXMgAmpBA3R2OgADIAFBBGohASALQQRqIgsgDUcNAAsLIAJBA3EiB0UNAANAIAEgCWogAyABQX9zIAJqQQN0djoAACABQQFqIQEgCkEBaiIKIAdHDQALCyACIARqIQQLIAhBEGoiCCAMRw0ACwsgACAFKAIEIAUoAgBrNgLAAyAGIAAoAhQiASgCMDYCDCAGIAEoAjQiATYCECABBEAgASABKAIEQQFqNgIECyAGKAIMIQEgACgCJCEIQgAhEEIAIREjAEEgayICJAAgAkEMaiEDAkAgASgCRCIAKAJsIgEgACgCaCIERgRAQQAhAAwBC0EBIAEgBGtBBXUiACAAQQFNGyEBQQAhAANAIAQgAEEFdGooAgAgCEYNASAAQQFqIgAgAUcNAAsgASEACwJAIAQgAEEFdGoiASgCECIAIAEoAhQiAUYNAANAAn4gACgCHCAAKAIYIgRrrSISIBBYBEAgECASfQwBCyAEIBCnaiAFKAIAIgQgEadqIAUoAgQgBGutIBF9IhMgEiAQfSIQIBAgE1YbIhCnEDIaIBAgEXwhEUIACyEQIBEgBSgCBCAFKAIAa61RDQEgAEEoaiIAIAFHDQALCyADQZClBSkCADcCACADQQhqIQACQEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgCADYCCAwBCyAAQZilBSgCAEGcpQUoAgAQLgsgAiwAH0EASARAIAIoAhwaIAIoAhQQKgsgAkEgaiQAAkAgBigCECIARQ0AIAAgACgCBCIFQQFrNgIEIAUNACAAIAAoAgAoAggRAAAgABArCyAGKAIUIgAEQCAGIAA2AhggBigCHBogABAqCyAGQSBqJAAL3jQCE38CfiMAQZABayIEJAAgBCABKAIUIgIoAjA2AogBIAQgAigCNCICNgKMASACBEAgAiACKAIEQQFqNgIECwJAIAEoAhgiAiABKAIcIgNHBEAgAiEFA0ACQCAFKAIAIghFDQAgCEGgvwRB2IwFEDkiDEUNACAFKAIEIg4EQCAOIA4oAgRBAWo2AgQgASgCHCEDIAEoAhghAgsCQAJAAkACQAJAIAIgA0cEQANAAkAgAigCACIFRQ0AIAVBoL8EQbi/BBA5IgVFDQAgAigCBCIPBEAgDyAPKAIEQQFqNgIECyAEIAwpAqABNwOAASAEIAwpApgBNwN4IAQgDCkCkAE3A3AgBCAMKQKIATcDaCAEIAwpAoABNwNgIAQgDCkCeDcDWCAEIAwpAnA3A1AgBCAMKQJoNwNIIAQgBSgCaCIDNgJMIAQgBSgCbCICNgJQIANBACACGw0DIARBKBAsIgE2AiggBEKngICAgIWAgIB/NwIsIAFBlZUBKQAANwAAIAFBADoAJyABQbSVASkAADcAHyABQa2VASkAADcAGCABQaWVASkAADcAECABQZ2VASkAADcACCAAQQJBACAEQShqEC8aIAQsADNBAE4NBCAEKAIwGiAEKAIoECoMBAsgAkEIaiICIANHDQALCyAEQTAQLCIBNgJIIARCqICAgICGgICAfzcCTCABQaGQASkAADcAACABQQA6ACggAUHBkAEpAAA3ACAgAUG5kAEpAAA3ABggAUGxkAEpAAA3ABAgAUGpkAEpAAA3AAggAEECQQAgBEHIAGoQLxogBCwAU0EATg0CIAQoAlAaIAQoAkgQKgwCCyAAIQgjAEEQayIKJAAgAUH0AmoiByAEKQJINwIAIAcgBCkCgAE3AjggByAEKQJ4NwIwIAcgBCkCcDcCKCAHIAQpAmg3AiAgByAEKQJgNwIYIAcgBCkCWDcCECAHIAQpAlA3AgggBCgCVCEDIAQoAkwhAgJAAkBB8OcEKQMAIhVQBEAgAiADakEBayADbiELIAQoAlgiACAEKAJQakEBayAAbiEFIAQtAGIhAgwBCyAEKAJYIgAgBCgCUGpBAWsgAG4iBa0gAiADakEBayADbiILrX4hFgJAIAQtAGIiAkUNACAWIAQ1AmR+IRYgAkEBayIARQ0AIBYgBDUCaH4hFiAAQQFGDQAgFiAENQJsfiEWIABBAkYNACAWIAQ1AnB+IRYgAEEDRg0AIBYgBDUCdH4hFiAAQQRGDQAgFiAENQJ4fiEWIABBBUYNACAWIAQ1Anx+IRYgAEEGRg0AIBYgBDUCgAF+IRYLIBUgFloNACAKQSgQLCIANgIEIApCpoCAgICFgICAfzcCCCAAQZkbKQAANwAAIABBADoAJiAAQbcbKQAANwAeIABBsRspAAA3ABggAEGpGykAADcAECAAQaEbKQAANwAIIAhBA0HoByAKQQRqEC8aIAosAA9BAE4NASAKKAIMGiAKKAIEECoMAQsCQAJ/IAUgC2wiACACQf8BcSICRQ0AGiAEKAJkIABsIgAgAkEBayICRQ0AGiAEKAJoIABsIgAgAkEBRg0AGiAEKAJsIABsIgAgAkECRg0AGiAEKAJwIABsIgAgAkEDRg0AGiAEKAJ0IABsIgAgAkEERg0AGiAEKAJ4IABsIgAgAkEFRg0AGiAEKAJ8IABsIgAgAkEGRg0AGiAEKAKAASAAbAsiBSAHKAJEIgIgBygCQCIAa0EEdSIDSwRAQQAhCwJAIAUgA2siECAHQUBrIg0oAggiBSANKAIEIgJrQQR1TQRAIBBFBEAgDSACNgIEDAILIBBBAWtB/////wBxIRICQCAQQQdxIgNFBEAgAiEADAELIAIhAANAIABCCjcDACAAQgA3AwggAEEQaiEAIAtBAWoiCyADRw0ACwsgEkEHTwRAIAIgEEEEdGohAgNAIABCADcDGCAAQgo3AwAgAEIANwMIIABCADcDKCAAQgo3AxAgAEIANwM4IABCCjcDICAAQgA3A0ggAEIKNwMwIABCADcDWCAAQgo3A0AgAEIANwNoIABCCjcDUCAAQgA3A3ggAEIKNwNgIABCCjcDcCAAQYABaiIAIAJHDQALCyANIAA2AgQMAQsCQCACIA0oAgAiAGtBBHUiAyAQaiIGQYCAgIABSQRAQf////8AIAUgAGsiAkEDdSIAIAYgACAGSxsgAkHw////B08bIgYEQCAGQYCAgIABTw0CIAZBBHQQLCEJCyAJIANBBHRqIQIgEEEBa0H/////AHEhEwJAIBBBB3EiA0UEQCACIQAMAQsgAiEAA0AgAEIKNwMAIABCADcDCCAAQRBqIQAgC0EBaiILIANHDQALCyATQQdPBEAgAiAQQQR0aiEDA0AgAEIANwMYIABCCjcDACAAQgA3AwggAEIANwMoIABCCjcDECAAQgA3AzggAEIKNwMgIABCADcDSCAAQgo3AzAgAEIANwNYIABCCjcDQCAAQgA3A2ggAEIKNwNQIABCADcDeCAAQgo3A2AgAEIKNwNwIABBgAFqIgAgA0cNAAsLIA0oAgQiCyANKAIAIgVHBEADQCACQRBrIgIgC0EQayILKQMANwMAIAIgCygCCDYCCCAFIAtHDQALIA0oAgAhBQsgDSAANgIEIA0gAjYCACANKAIIGiANIAkgBkEEdGo2AgggBQRAIAUQKgsMAgsQNgALEE8ACyAHKAJEIQIgBygCQCEADAELIAMgBU0NACAHIAAgBUEEdGoiAjYCRAsgACACRwRAA0AgAEIKNwMAIABBEGoiACACRw0ACwsgCEGQpQUpAgA3AgAgCEEIaiEAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyAKQRBqJAAgCCgCAA0AIAgsABNBAEgEQCAIKAIQGiAIKAIIECoLIAEoAogDEOgDIQAgBEEoaiABKAIUIAAQ9AIgBCkCKCEVIARCADcCKCABKALcAyECIAEgFTcD2AMCQCACRQ0AIAIgAigCBCIAQQFrNgIEIAANACACIAIoAgAoAggRAAAgAhArCwJAIAQoAiwiAkUNACACIAIoAgQiAEEBazYCBCAADQAgAiACKAIAKAIIEQAAIAIQKwsCQCAMLQBhQQFGBEAgBEEoaiABEPECAkAgBCgCNCIRBEAgCCAEKQI0NwIAIAhBCGohACAELABHQQBOBEAgACAEKQI8NwIAIAAgBCgCRDYCCAwCCyAAIAQoAjwgBCgCQBAuDAELIAEoAtgDIQkCfyAEQRxqIgZBADYCCCAGQgA3AgACQCAEKAIsIgUgBCgCKCIARwRAIAUgAGsiAkEASA0BIAYgAhAsIgM2AgQgBiADNgIAIAYgAiADajYCCANAIAMgACgCADYCACADIAAoAgQiAjYCBCACBEAgAiACKAIEQQFqNgIECyADQQhqIQMgAEEIaiIAIAVHDQALIAYgAzYCBAsgBgwBCxA2AAshBSAJKAIYIgAEQCAJKAIcIgYgACICRwRAA0ACQCAGQQRrKAIAIgNFDQAgAyADKAIEIgJBAWs2AgQgAg0AIAMgAygCACgCCBEAACADECsLIAZBCGsiBiAARw0ACyAJKAIYIQILIAkgADYCHCAJKAIgGiACECogCUEANgIgIAlCADcDGAsgCSAFKAIANgIYIAkgBSgCBDYCHCAJIAUoAgg2AiAgBUEANgIIIAVCADcCACAFELwECyAELABHQQBIBEAgBCgCRBogBCgCPBAqCyAEKAIoIgAEQCAEKAIsIgUgACICRwRAA0ACQCAFQQRrKAIAIgNFDQAgAyADKAIEIgJBAWs2AgQgAg0AIAMgAygCACgCCBEAACADECsLIAVBCGsiBSAARw0ACyAEKAIoIQILIAQgADYCLCAEKAIwGiACECoLIBFFDQEMAgsgBEEANgIwIARCADcCKAJAIAwoAigiBiAMKAIkIgVHBEAgBiAFayIAQQBIDQUgBCAAECwiAzYCLCAEIAM2AiggBCAAIANqNgIwIAMhAANAIAAiAiAFKAIANgIAIAIgBSgCBCIANgIEIAAEQCAAIAAoAgRBAWo2AgQLIAJBCGohACAFQQhqIgUgBkcNAAsgBCAANgIsIAMhBQNAIAUoAgAoAhBB5eDNywZGDQIgAiAFRiEUIAVBCGohBSAURQ0ACwsgBEEUaiIDEIgEIAQoAhQgBCkCVDcDaCAEQShqIgICfyACKAIEIgAgAigCCEkEQCAAIAMoAgA2AgAgACADKAIENgIEIANCADcCACAAQQhqDAELIAIgAxBTCzYCBCADEG0gBCgCLCEAIAQoAighAwsgASgC2AMhCiAEQQA2AhAgBEIANwIIQQAhBUEAIQYgACADRwRAIAAgA2siAkEASA0FIAQgAhAsIgY2AgggBCACIAZqIhE2AhAgAyECIAYhBQNAIAUgAigCADYCACAFIAIoAgQiCTYCBCAJBEAgCSAJKAIEQQFqNgIECyAFQQhqIQUgAkEIaiICIABHDQALIAQgBTYCDAsgCigCGCIABEAgCigCHCICIAAiA0cEQANAAkAgAkEEaygCACIFRQ0AIAUgBSgCBCIDQQFrNgIEIAMNACAFIAUoAgAoAggRAAAgBRArCyACQQhrIgIgAEcNAAsgBCgCECERIAQoAgwhBSAEKAIIIQYgCigCGCEDCyAKIAA2AhwgCigCIBogAxAqIAQoAighAwsgCiARNgIgIAogBTYCHCAKIAY2AhggBEEANgIQIARCADcCCCADRQ0AIAQoAiwiBSADIgJHBEADQAJAIAVBBGsoAgAiAkUNACACIAIoAgQiAEEBazYCBCAADQAgAiACKAIAKAIIEQAAIAIQKwsgBUEIayIFIANHDQALIAQoAighAgsgBCADNgIsIAQoAjAaIAIQKgsCQAJAAkACQAJAIAEoAtgDIgIgAigCACgCCBEBACIAQbDWydEGTARAAkACQAJAAkAgAEGx4NiLBkcEQCAAQbHG2YsGRg0BIABBscbZwwZHDQYCQAJAIAIoAhgiAyACKAIcIgJHBEADQAJAIAMoAgAiAEUNACAAQaC/BEGE9QQQOSIFRQ0AIAMoAgQiA0UNAyADIAMoAgRBAWo2AgQMBAsgA0EIaiIDIAJHDQALC0EAIQULQQAhAwtBNBAsIgJCADcCBCACQfjxBDYCACACQQxqIQAgA0UNAiADIAMoAgRBAWo2AgQgAkEAOgAYIAJCADcCECACQgA3AhwgAkIANwIkIAIgAzYCMCACIAU2AiwgAkHQ9QQ2AgwgAygCBEF/RgRAIAMgAygCACgCCBEAACADECsLDAgLAkACQCACKAIYIgMgAigCHCICRwRAA0ACQCADKAIAIgBFDQAgAEGgvwRB1PcEEDkiBUUNACADKAIEIgNFDQMgAyADKAIEQQFqNgIEDAQLIANBCGoiAyACRw0ACwtBACEFC0EAIQMLQTQQLCICQgA3AgQgAkGg8gQ2AgAgAkEMaiEAIANFDQIgAyADKAIEQQFqNgIEIAJBADoAGCACQgA3AhAgAkIANwIcIAJCADcCJCACIAM2AjAgAiAFNgIsIAJB7PYENgIMIAMoAgRBf0YEQCADIAMoAgAoAggRAAAgAxArCwwHCwJAAkAgAigCGCIDIAIoAhwiAkcEQANAAkAgAygCACIARQ0AIABBoL8EQZyCBRA5IgVFDQAgAygCBCIDRQ0DIAMgAygCBEEBajYCBAwECyADQQhqIgMgAkcNAAsLQQAhBQtBACEDC0E0ECwiAkIANwIEIAJByPIENgIAIAJBDGohACADRQ0CIAMgAygCBEEBajYCBCACQQA6ABggAkIANwIQIAJCADcCHCACQgA3AiQgAiADNgIwIAIgBTYCLCACQbCCBTYCDCADKAIEQX9GBEAgAyADKAIAKAIIEQAAIAMQKwsMBgsgAkIANwIQIAJCADcCHCACQQA2AjAgAiAFNgIsIAJBADoAGCACQgA3AiQgAkHQ9QQ2AgwMBgsgAkIANwIQIAJCADcCHCACQQA2AjAgAiAFNgIsIAJBADoAGCACQgA3AiQgAkHs9gQ2AgwMBQsgAkIANwIQIAJCADcCHCACQQA2AjAgAiAFNgIsIAJBADoAGCACQgA3AiQgAkGwggU2AgwMBAsgAEHo1s3rBkwEQCAAQbHWydEGRwRAIABB58rB0wZHDQICQCACKAIYIgMgAigCHCICRwRAA0ACQCADKAIAIgBFDQAgAEGgvwRBlPoEEDkiBUUNACADKAIEIgNFBEBBACEDDAQLIAMgAygCBEEBajYCBAwDCyADQQhqIgMgAkcNAAsLQQAhA0EAIQULQcgAECwiAkIANwIEIAJBwPMENgIAIAJBDGohACADBEAgAyADKAIEQQFqNgIEIAJBADoAGCACQgA3AhAgAkIANwIcIAJCADcCJCACIAM2AjAgAiAFNgIsIAJBqPoENgIMIAMgAygCBEEBajYCBCACQQA6AEQgAkEAOgA0IAMgAygCBCIFQQFrNgIEIAVFBEAgAyADKAIAKAIIEQAAIAMQKwsMBQsgAkIANwIQIAJCADcCHCACQQA6AEQgAkEAOgA0IAJBADYCMCACIAU2AiwgAkEAOgAYIAJCADcCJCACQaj6BDYCDAwFCwJAIAIoAhgiAyACKAIcIgJHBEADQAJAIAMoAgAiAEUNACAAQaC/BEHM/gQQOSIFRQ0AIAMoAgQiA0UEQEEAIQMMBAsgAyADKAIEQQFqNgIEDAMLIANBCGoiAyACRw0ACwtBACEDQQAhBQtBNBAsIgJCADcCBCACQfDyBDYCACACQQxqIQAgAwRAIAMgAygCBEEBajYCBCACQQA6ABggAkIANwIQIAJCADcCHCACQgA3AiQgAiADNgIwIAIgBTYCLCACQcT7BDYCDCADKAIEQX9GBEAgAyADKAIAKAIIEQAAIAMQKwsMBAsgAkIANwIQIAJCADcCHCACQQA2AjAgAiAFNgIsIAJBADoAGCACQgA3AiQgAkHE+wQ2AgwMBAsgAEHp1s3rBkcEQCAAQbHG2bMHRw0BAkAgAigCGCIDIAIoAhwiAkcEQANAAkAgAygCACIARQ0AIABBoL8EQcyABRA5IgVFDQAgAygCBCIDRQRAQQAhAwwECyADIAMoAgRBAWo2AgQMAwsgA0EIaiIDIAJHDQALC0EAIQNBACEFC0E0ECwiAkIANwIEIAJBmPMENgIAIAJBDGohACADRQ0CIAMgAygCBEEBajYCBCACQQA6ABggAkIANwIQIAJCADcCHCACQgA3AiQgAiADNgIwIAIgBTYCLCACQcj/BDYCDCADKAIEQX9GBEAgAyADKAIAKAIIEQAAIAMQKwsMAwsgBEIANwIoDAQLIARCADcCKAwDCyACQgA3AhAgAkIANwIcIAJBADYCMCACIAU2AiwgAkEAOgAYIAJCADcCJCACQcj/BDYCDCAEIAI2AiwgBCAANgIoDAILIAQgAjYCLCAEIAA2AiggAyADKAIEIgBBAWs2AgQgAA0BIAMgAygCACgCCBEAACADECsMAQsgBCACNgIsIAQgADYCKAsgBCkCKCEVIARCADcCKCABKALkAyECIAEgFTcD4AMCQCACRQ0AIAIgAigCBCIAQQFrNgIEIAANACACIAIoAgAoAggRAAAgAhArCwJAIAQoAiwiAkUNACACIAIoAgQiAEEBazYCBCAADQAgAiACKAIAKAIIEQAAIAIQKwsgASgC4ANFBEAgBEE4ECwiADYCKCAEQrGAgICAh4CAgH83AiwgAEG9lQEpAAA3AAAgAEEAOgAxIABB7ZUBLQAAOgAwIABB5ZUBKQAANwAoIABB3ZUBKQAANwAgIABB1ZUBKQAANwAYIABBzZUBKQAANwAQIABBxZUBKQAANwAIIAhBBEG4FyAEQShqEC8aIAQsADNBAE4NASAEKAIwGiAEKAIoECoMAQsCQCABLQDUA0EBRw0AIARBiAFqIQIgASgCJCEBIwBBEGsiAyQAQfDnBCkDACEWAn4gBygCECIAIAcoAghqQQFrIABurSAHKAIMIgAgBygCBGpBAWsgAG6tfiIVIActABoiAEUNABogFSAHNQIcfiIVIABBAWsiAEUNABogFSAHNQIgfiIVIABBAUYNABogFSAHNQIkfiIVIABBAkYNABogFSAHNQIofiIVIABBA0YNABogFSAHNQIsfiIVIABBBEYNABogFSAHNQIwfiIVIABBBUYNABogFSAHNQI0fiIVIABBBkYNABogFSAHNQI4fgshFQJAAkAgFlANACAVIBZYDQAgA0EoECwiADYCBCADQqeAgICAhYCAgH83AgggAEHElAEpAAA3AAAgAEEAOgAnIABB45QBKQAANwAfIABB3JQBKQAANwAYIABB1JQBKQAANwAQIABBzJQBKQAANwAIIAhBAkHoByADQQRqEC8aIAMsAA9BAE4NASADKAIMGiADKAIEECoMAQsgCCAHIAIgAUIAIBUQogYLIANBEGokACAIKAIADQEgCCwAE0EATg0AIAgoAhAaIAgoAggQKgsgCBDoAQsgD0UNACAPIA8oAgQiAEEBazYCBCAADQAgDyAPKAIAKAIIEQAAIA8QKwsgDkUNBSAOIA4oAgQiAEEBazYCBCAADQUgDiAOKAIAKAIIEQAAIA4QKwwFCxA2AAsQNgALIAVBCGoiBSADRw0ACwsgBEEwECwiATYCSCAEQqiAgICAhoCAgH83AkwgAUHKkAEpAAA3AAAgAUEAOgAoIAFB6pABKQAANwAgIAFB4pABKQAANwAYIAFB2pABKQAANwAQIAFB0pABKQAANwAIIABBAkEAIARByABqEC8aIAQsAFNBAE4NACAEKAJQGiAEKAJIECoLAkAgBCgCjAEiAUUNACABIAEoAgQiAEEBazYCBCAADQAgASABKAIAKAIIEQAAIAEQKwsgBEGQAWokAAsLACAAKAKIAxDo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AhAgBigCDCIIa0EERwRAIAZBMBAsIgE2AgAgBkKvgICAgIaAgIB/NwIEIAFBkt4AKQAANwAnIAFBi94AKQAANwAgIAFBg94AKQAANwAYIAFB+90AKQAANwAQIAFB890AKQAANwAIIAFB690AKQAANwAAIAFBADoALyAGQRhqQQJBACAGEC8hASAAQgA3AgAgACABKQMANwIIIABBEGohAAJAIAEsABNBAE4EQCAAIAEpAgg3AgAgACABKAIQNgIIDAELIAAgASgCCCABKAIMEC4gASwAE0EATg0AIAEoAhAaIAEoAggQKgsgBiwAC0EATg0BIAYoAggaIAYoAgAQKgwBCyAIKAIAIgggASgCJEYEQCAGQSgQLCIBNgIAIAZCoICAgICFgICAfzcCBCABQfLIACkAADcAGCABQerIACkAADcAECABQeLIACkAADcACCABQdrIACkAADcAACABQQA6ACAgBkEYakECQQAgBhAvIQEgAEIANwIAIAAgASkDADcCCCAAQRBqIQACQCABLAATQQBOBEAgACABKQIINwIAIAAgASgCEDYCCAwBCyAAIAEoAgggASgCDBAuIAEsABNBAE4NACABKAIQGiABKAIIECoLIAYsAAtBAE4NASAGKAIIGiAGKAIAECoMAQsgBkEYaiIJIAEoAhQgCEEBEI0BIAYoAhwhCAJAIAYoAhgiAUUEQCAGQTAQLCIBNgIAIAZCqYCAgICGgICAfzcCBCABQendAC0AADoAKCABQeHdACkAADcAICABQdndACkAADcAGCABQdHdACkAADcAECABQcndACkAADcACCABQcHdACkAADcAACABQQA6ACkgCUECQQAgBhAvIQEgAEIANwIAIAAgASkDADcCCCAAQRBqIQACQCABLAATQQBOBEAgACABKQIINwIAIAAgASgCEDYCCAwBCyAAIAEoAgggASgCDBAuIAEsABNBAE4NACABKAIQGiABKAIIECoLIAYsAAtBAE4NASAGKAIIGiAGKAIAECoMAQsgBkEYaiABIAEoAgAoAhQRAgAgBigCGARAIABCADcCACAAIAYpAxg3AgggAEEQaiEAIAYsACtBAE4EQCAAIAYpAiA3AgAgACAGKAIoNgIIDAILIAAgBigCICAGKAIkEC4gBiwAK0EATg0BIAYoAigaIAYoAiAQKgwBCyAGLAArQQBIBEAgBigCKBogBigCIBAqCyAAIAEgAiADIAQgBRCnAgsgCEUNACAIIAgoAgQiAEEBazYCBCAADQAgCCAIKAIAKAIIEQAAIAgQKwsgBigCDCIARQ0AIAYgADYCECAGKAIUGiAAECoLAkAgB0UNACAHIAcoAgQiAEEBazYCBCAADQAgByAHKAIAKAIIEQAAIAcQKwsgBkEwaiQAC4QCACMAQTBrIgEkACABQSAQLCICNgIMIAFCnYCAgICEgICAfzcCECACQcikASkAADcAFSACQcOkASkAADcAECACQbukASkAADcACCACQbOkASkAADcAACACQQA6AB0gAUEYakEEQQAgAUEMahAvIQIgAEIANwIYIABCADcCECAAQgA3AgggAEIANwIAIAAgAikDADcCICAAQShqIQACQCACLAATQQBOBEAgACACKQIINwIAIAAgAigCEDYCCAwBCyAAIAIoAgggAigCDBAuIAIsABNBAE4NACACKAIQGiACKAIIECoLIAEsABdBAEgEQCABKAIUGiABKAIMECoLIAFBMGokAAsIAEHs7L3LBgtPAQF/IABBtIoFNgIAIAAoApQDIgEEQCAAIAE2ApgDIAAoApwDGiABECoLIAAoAogDIgEEQCAAIAE2AowDIAAoApADGiABECoLIAAQdBAqC00BAX8gAEG0igU2AgAgACgClAMiAQRAIAAgATYCmAMgACgCnAMaIAEQKgsgACgCiAMiAQRAIAAgATYCjAMgACgCkAMaIAEQKgsgABB0C/UBAQF/IwBBIGsiAyQAIAMgASACEHsgAywAE0EASARAIAMoAhAaIAMoAggQKgsCQCABLQBhIgRBAk8EQCAAIAFBrTsQkQEMAQsgAQJ/IARFBEAgAhBODAELIAIQSQs2AmggAi0AFEEBRgRAIANBADoAFCADQQA6AB8gAEECQeQAIANBFGoQLxogAywAH0EATg0BIAMoAhwaIAMoAhQQKgwBCyAAQZClBSkCADcCACAAQQhqIQBBo6UFLAAAQQBOBEAgAEGYpQUpAgA3AgAgAEGgpQUoAgA2AggMAQsgAEGYpQUoAgBBnKUFKAIAEC4LIANBIGokAAtbACACQQE2AgAgA0EDNgIAIABBkKUFKQIANwIAIABBCGohAEGjpQUsAABBAE4EQCAAQZilBSkCADcCACAAQaClBSgC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ahAvGiAKLAAPQQBODQEgCigCDBogCigCBBAqDAELIApBADoABCAKQQA6AA8gDEEFQdIPIApBBGoQLxogCiwAD0EATg0AIAooAgwaIAooAgQQKgsgCkEQaiQAIAMgAykDOCIpNwNYIAMsAGtBAE4EfyAppwUgAygCaBogAygCYBAqIAMoAlgLIQUgAyADKQNANwNgIAMgAygCSDYCaAJAAkAgBUUEQCABKAKUAyIFIAEoApgDRg0CIAJBHGohISAAQRBqIQ0gA0FAayEZDAELIABCADcCACAAIAMpA1g3AgggAEEQaiEAIAMsAGtBAE4EQCAAIAMpAmA3AgAgACADKAJoNgIIDAMLIAAgAygCYCADKAJkEC4MAgsDQCAFIBtBAnRqKAIAIgUgASgCJEYEQCADQThqQQJBACADQRBqQZ+YARCAASICEC8hASAAQgA3AgAgACABKQMANwIIAkAgASwAE0EATgRAIA0gASkCCDcCACANIAEoAhA2AggMAQsgDSABKAIIIAEoAgwQLiABLAATQQBODQAgASgCEBogASgCCBAqCyACLAALQQBODQMgAigCCBogAigCABAqDAMLIANBOGoiBiABKAIUIAVBARCNASADKAI8IRcCQCADKAI4IgVFBEAgA0EwECwiBTYCECADQqyAgICAhoCAgH83AhQgBUGamAEoAAA2ACggBUGSmAEpAAA3ACAgBUGKmAEpAAA3ABggBUGCmAEpAAA3ABAgBUH6lwEpAAA3AAggBUHylwEpAAA3AAAgBUEAOgAsIAZBAkHQDyADQRBqEC8hBSAAQgA3AgAgACAFKQMANwIIAkAgAywAS0EATgRAIA0gGSkCADcCACANIBkoAgg2AggMAQsgDSADKAJAIAMoAkQQLiADLABLQQBODQAgAygCSBogAygCQBAqCyADLAAbQQBIBEAgAygCGBogAygCEBAqC0EBIQUMAQsgA0E4aiAFIAUoAgAoAhQRAgAgAygCOARAIABCADcCACAAIAMpAzg3AgggAywAS0EATgRAIA0gGSkCADcCACANIBkoAgg2AghBASEFDAILIA0gAygCQCADKAJEEC4gAywAS0EASARAIAMoAkgaIAMoAkAQKgtBASEFDAELIAMsAEtBAEgEQCADKAJIGiADKAJAECoLIANBOGogBSACQQBBAEEAEKcCAkACQCAD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QCABQZilBSkCADcCACABQaClBSgCADYCCAwBCyABQZilBSgCAEGcpQUoAgAQLgsgDSwAG0EASARAIA0oAhgaIA0oAhAQKgsgDUEgaiQAC4QCACMAQTBrIgEkACABQSAQLCICNgIMIAFCnYCAgICEgICAfzcCECACQYSlASkAADcAFSACQf+kASkAADcAECACQfekASkAADcACCACQe+kASkAADcAACACQQA6AB0gAUEYakEEQQAgAUEMahAvIQIgAEIANwIYIABCADcCECAAQgA3AgggAEIANwIAIAAgAikDADcCICAAQShqIQACQCACLAATQQBOBEAgACACKQIINwIAIAAgAigCEDYCCAwBCyAAIAIoAgggAigCDBAuIAIsABNBAE4NACACKAIQGiACKAIIECoLIAEsABdBAEgEQCABKAIUGiABKAIMECoLIAFBMGokAAsIAEHk0sm7BgsxAQF/IABBzIkFNgIAIAAoAoADIgEEQCAAIAE2AoQDIAAoAogDGiABECoLIAAQdBAqCy8BAX8gAEHMiQU2AgAgACgCgAMiAQRAIAAgATYChAMgACgCiAMaIAEQKgsgABB0C6QEAQN/IwBBQGoiAiQAIAJBKGogASgCFCABKAIkIAJBPGoQ1QECQCACKAIoBEAgAEIANwIAIAAgAikDKDcCCCAAQRBqIQAgAiwAO0EATgRAIAAgAikCMDcCACAAIAIoAjg2AggMAgsgACACKAIwIAIoAjQQLgwBCyACQRBqIgQgASgCFCACKAI8QQEQjQEgAigCFCEDAkAgAigCECIBRQRAIAJBADoABCACQQA6AA8gBEECQdAPIAJBBGoQLyEBIABCADcCACAAIAEpAwA3AgggAEEQaiEAAkAgASwAE0EATgRAIAAgASkCCDcCACAAIAEoAhA2AggMAQsgACABKAIIIAEoAgwQLiABLAATQQBODQAgASgCEBogASgCCBAqCyACLAAPQQBODQEgAigCDBogAigCBBAqDAELIAJBEGogASABKAIAKAIUEQIAIAIoAhAEQCAAQgA3AgAgACACKQMQNwIIIABBEGohACACLAAjQQBOBEAgACACKQIYNwIAIAAgAigCIDYCCAwCCyAAIAIoAhggAigCHBAuIAIsACNBAE4NASACKAIgGiACKAIYECoMAQsgAiwAI0EASARAIAIoAiAaIAIoAhgQKgsgACABIAEoAgAoAkwRAgALIANFDQAgAyADKAIEIgBBAWs2AgQgAA0AIAMgAygCACgCCBEAACADECsLIAIsADtBAEgEQCACKAI4GiACKAIwECoLIAJBQGskAAuBAgECfyMAQSBrIgMkACABIAJBACABKAIAKAIsEQQAIQQgAiABKAJoEEogAiABKAJsEEogAiABKAJwEEogAiABKAJ0EEogAiABKAJ4EEogAiABQfwAahCgASACIAQ2AgwgA0EMaiABIAIgAigCBCAEIAIoAgBqa0EAIAEoAgAoAjARBwAgAiACKAIEIAIoAgBrNgIMIAMsAB9BAEgEQCADKAIcGiADKAIUECoLIABBkKUFKQIANwIAIABBCGohAAJAQaOlBSwAAEEATgRAIABBmKUFKQIANwIAIABBoKUFKAIANgIIDAELIABBmKUFKAIAQZylBSgCABAuCyADQSBqJAALuwEBBH8jAEEgayIDJAAgA0EMaiIEIAAoAhQgACgCgAMoAgBBARCNASADKAIQIQAgBCADKAIMIgQgBCgCACgCFBECACADKAIMIQYgAywAH0EASARAIAMoAhwaIAMoAhQQKgsgBgRAIAJBADYCACABQQA2AgALIAEgBCgCKDYCACACIAQoAiw2AgACQCAARQ0AIAAgACgCBCIBQQFrNgIEIAENACAAIAAoAgAoAggRAAAgABArCyADQSBqJAAL6wIBCH8jAEEgayICJAAgAEEAQcgAEDQiACABLwH2AjYCBCAAIAEvAfQCNgIIIAAgASgC+AI2AhQgACABKAL8AjYCGCACQQA2AhwgAkIANwIUAkACQAJAAkAgASgChAMiAyABKAKAAyIERiIGDQAgAyAEayIDQQBIDQMgAiADECwiBTYCFCACIAMgBWoiBzYCHCAFIAQgAxAyIQggAiAHNgIYIAYNACAIKAIAIgNFDQAgAiABKAIUIANBARCNASACKAIEIQEgAigCACIDRQ0BIAIgAyADKAIAKAIUEQIAIAIoAgAhCSACLAATQQBIBEAgAigCEBogAigCCBAqCyAJDQEgACADKAIoNgIMIAAgAygCLDYCEAwBCyAAQgA3AgwMAQsgAUUNACABIAEoAgQiAEEBazYCBCAADQAgASABKAIAKAIIEQAAIAEQKwsgAigCFCIABEAgAigCHBogABAqCyAC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Tg0AIAEoAhAaIAEoAggQKgsgBiwAD0EASARAIAYoAgwaIAYoAgQQKgsgBkG80wMoAgAiADYCKCAAQQxrKAIAIAZBKGpqQdzTAygCADYCACAGQeDTAygCADYCMCACQfDLAzYCACAGLABfQQBIBEAgBigCXBogBigCVBAqCyACED0aIAZB6ABqEDsaCwJAIAYoArwBIgBFDQAgACAAKAIEIgFBAWs2AgQgAQ0AIAAgACgCACgCCBEAACAAECsLIAZBwAFqJAALnw0CCn8BfiMAQSBrIgYkACMAQcABayICJAAgASgCFCIFKAIwIQMgBSgCNCIIBEAgCCAIKAIEQQFqNgIECyAGQQhqIQUgAkEANgK8ASACQgA3ArQBIAJBoAFqIAMgASgCJCACQbQBahCBAgJAIAIoAqABBEAgBSACKQOgATcCACAFIAIoArABNgIQIAUgAikDqAE3AgggAkEANgKwASACQgA3A6gBDAELIAJBEGogAUH0AmogAkG0AWoQpQYgAiACKQMQIgw3A6ABIAIsALMBQQBOBH8gDKcFIAIoArABGiACKAKoARAqIAIoAqABCyELIAIgAikDGDcDqAEgAiACKAIgNgKwASALBEAgBSACKQOgATcCACAFIAIoArABNgIQIAUgAikCqAE3AgggAkIANwOoASACQQA2ArABDAELIAMoAlQhBCADKAJYIgcEQCAHIAcoAgRBAWo2AgQLAkAgBEUEQCACQTgQLCIBNgIQIAJCsICAgICHgICAfzcCFCABQZveACkAADcAACABQQA6ADAgAUHD3gApAAA3ACggAUG73gApAAA3ACAgAUGz3gApAAA3ABggAUGr3gApAAA3ABAgAUGj3gApAAA3AAggBUECQfEAIAJBEGoQLxogAiwAG0EATg0BIAIoAhgaIAIoAhAQKgwBCyACQRBqIAQgASgCJEHn2qWjBhC6ASABKAKAAyIDBEAgASADNgKEAyABKAKIAxogAxAqCyABIAIoAhAiAzYCgAMgASACKAIUIgQ2AoQDIAEgAigCGDYCiAMCQAJAAkAgAS8B9gIgAS8B9AJsIAQgA2tBAnVHBEAgAkGg0wM2AhggAkG00wM2AlAgAkHE0wMoAgAiBDYCECACQRBqIgMgBEEMaygCAGpByNMDKAIANgIAIAJBADYCFCADIAIoAhBBDGsoAgBqIgQg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AUH4////B0kEQCABQQtPBEAgAUEHckEBaiIFECwhAiAAIAVBgICAgHhyNgIIIAAgAjYCACAAIAE2AgQgAiEADAILIAAgAToACyABDQFBACEBDAILEDgACyAAIAQgARA3GgsgACABakEAOgAAIANB7NUDKAIAIgA2AgwgAEEMaygCACADQQxqakH41QMoAgA2AgAgBkHwywM2AgAgAywAO0EASARAIAMoAjgaIAMoAjAQKgsgBhA9GiADQcQAahA7GiADQaABaiQACw8AIABB1IgFNgIAIAAQKgsNACAAQdSIBTYCACAACw8AIABBrIgFNgIAIAAQKgsNACAAQayIBTYCACAACw8AIABBhIgFNgIAIAAQKgsNACAAQYSIBTYCACAACw8AIABB3IcFNgIAIAAQKgsNACAAQdyHBTYCACAAC0sAIAAgASkD+AI3AgAgAEEIaiEAIAEsAIsDQQBOBEAgACABQYADaiIBKQIANwIAIAAgASgCCDYCCA8LIAAgASgCgAMgASgChAMQLgu8AgAjAEEgayIDJAAgAyABIAIQeyADLAATQQBIBEAgAygCEBogAygCCBAqCwJAIAEtAGEEQCAAIAFB2y0QkQEMAQsgASACEEk2AmggASACEEk2AmwgASACEEk2AnAgASACEEk2AnQgASACEEk2AnggA0EUaiACEJYBIAEsAIcBQQBIBEAgASgChAEaIAEoAnwQKgsgASADKQIUNwJ8IAEgAygCHDYChAEgAi0AFEEBRgRAIANBADoAFCADQQA6AB8gAEECQeQAIANBFGoQLxogAywAH0EATg0BIAMoAhwaIAMoAhQQKgwBCyAAQZClBSkCADcCACAAQQhqIQBBo6UFLAAAQQBOBEAgAEGYpQUpAgA3AgAgAEGgpQUoAgA2AggMAQsgAEGYpQUoAgBBnKUFKAIAEC4LIANBIGokAAsIACAAKAL0AgssACAAQYCHBTYCACAALACLA0EASARAIAAoAogDGiAAKAKAAxAqCyAAEHQQKgsqACAAQYCHBTYCACAALACLA0EASARAIAAoAogDGiAAKAKAAxAqCyAAEHQLDwAgAEHYhgU2AgAgABAqCw0AIABB2IYFNgIAIAALDwAgAEGwhgU2AgAgABAqCw0AIABBsIYFNgIAIAALDwAgAEGIhgU2AgAgABAqCw0AIABBiIYFNgIAIAALDwAgAEHghQU2AgAgABAqCw0AIABB4IUFNgIAIAALDwAgAEG4hQU2AgAgABAqCw0AIABBuIUFNgIAIAALDwAgAEGQhQU2AgAgABAqCw0AIABBkIUFNgIAIAALcgEBfyAAQQE2AgggAEKBgICAEDcCACAAQQA2AiQgACABKAIoIgI2AgwgASgCLCEBIABCADcCKCAAIAE2AhggACACNgIUIAAgATYCECAAQgA3AjAgAEIANwI4IABBQGtCADcCACAAQgA3AhwgAEEAOgAkC5QFAQZ/IwBB0ABrIgMkACADQQA6ADggA0IANwJEIANCADcDMCADQgA3AjwgAyABKAIUIgQoAjA2AiggAyAEKAI0IgQ2AiwgBARAIAQgBCgCBEEBajYCBAsgASgCJCEEIAMgAykCKDcDACADQTBqIAMgBBDSASADQQxqIAEgASgCACgCTBECAAJAIAMoAhQEQCAAQgA3AgAgACADKQIUNwIIIABBEGohACADLAAnQQBOBEAgACADKQIcNwIAIAAgAygCJDYCCAwCCyAAIAMoAhwgAygCIBAuDAELIAMoAgwhASADKAIQIgQEQCAEIAQoAgRBAWo2AgQLIAMoAkQhByADQQA2AkQgAygCNCEGIAMoAjAhBSADQgA3AzAgAygCPCEIIAMoAkAhCSADQgA3AjwgAygCSCEKIAMtADghCyABIAU2AgQgASgCCCEFIAEgBjYCCAJAIAVFDQAgBSAFKAIEIgZBAWs2AgQgBg0AIAUgBSgCACgCCBEAACAFECsLIAEgCzoADCABKAIQIgUEQCABIAU2AhQgASgCGBogBRAqCyABIAo2AhwgASAHNgIYIAEgCTYCFCABIAg2AhAgACABIAIgASgCACgCHBEDACAERQ0AIAQgBCgCBCIAQQFrNgIEIAANACAEIAQoAgAoAggRAAAgBBArCyADLAAnQQBIBEAgAygCJBogAygCHBAqCwJAIAMoAhAiAEUNACAAIAAoAgQiAUEBazYCBCABDQAgACAAKAIAKAIIEQAAIAAQKwsgAygCPCIABEAgAyAANgJAIAMoAkQaIAAQKgsCQCADKAI0IgBFDQAgACAAKAIEIgFBAWs2AgQgAQ0AIAAgACgCACgCCBEAACAAECsLIANB0ABqJAALtQUBBX8jAEFAaiICJAAgAkEgaiABIAEoAgAoAiAR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C1wBAX8jAEEgayIEJAAgBEEMaiABIAIQeyAELAAfQQBIBEAgBCgCHBogBCgCFBAqCwJAIAEtAGEEQCAAIAFBsfYAEJEBDAELIAAgASACQX8gAxCpAgsgBEEgaiQACx0BAX4gASAAKQMgIgJYBEAgACABNwMoCyABIAJYCykCAX8CfiMAQRBrIgEkACABIAAoAhgQywUgASkDCCEDIAFBEGokACADCwuPgAVgAEGACAuIqwIxN1N0cmVhbVJlYWRlcl9DQXBpADEyU3RyZWFtUmVhZGVyADIwU3RyZWFtUmVhZGVyX2lzdHJlYW0AMTlTdHJlYW1SZWFkZXJfbWVtb3J5AGhlaWZfc3ViZXJyb3JfVW5zdXBwb3J0ZWRfZXNzZW50aWFsX3Byb3BlcnR5AGhlaWZfc3ViZXJyb3JfSXBtYV9ib3hfcmVmZXJlbmNlc19ub25leGlzdGluZ19wcm9wZXJ0eQBoZWlmX3N1YmVycm9yX05vX2lzcGVfcHJvcGVydHkAaGVpZl9zdWJlcnJvcl9JbnZhbGlkX3Byb3BlcnR5AFVuc3VwcG9ydGVkIGVzc2VudGlhbCBpdGVtIHByb3BlcnR5ACdpcG1hJyBib3ggcmVmZXJlbmNlcyBhIG5vbi1leGlzdGluZyBwcm9wZXJ0eQBJbnZhbGlkIHByb3BlcnR5AEltYWdlIGhhcyBubyAnaXNwZScgcHJvcGVydHkAaGVpZl9jaGFubmVsX2Rpc3Bhcml0eQBpbmZpbml0eQBoZWlmX3N1YmVycm9yX0Nhbm5vdF9yZWFkX3BsdWdpbl9kaXJlY3RvcnkAaGVpZl9jb250ZXh0X3JlYWRfZnJvbV9tZW1vcnkARmVicnVhcnkASmFudWFyeQBKdWx5AFRtcCBkYXRhIGNvdWxkIG5vdCBiZSByZWFkIGNvbXBsZXRlbHkAaGVpZl9jaGFubmVsX2ZpbHRlcl9hcnJheQBUaHVyc2RheQBUdWVzZGF5AFdlZG5lc2RheQBTYXR1cmRheQBTdW5kYXkATW9uZGF5AEZyaWRheQBNYXkAaGV2eABoZWlmX3N1YmVycm9yX05vX2lkYXRfYm94AGhlaWZfc3ViZXJyb3JfTm9faGRscl9ib3gAaGVpZl9zdWJlcnJvcl9Ob19pY2JyX2JveABoZWlmX3N1YmVycm9yX05vX2Z0eXBfYm94AGhlaWZfc3ViZXJyb3JfTm9faXBycF9ib3gAaGVpZl9zdWJlcnJvcl9Ob19pcGNvX2JveABoZWlmX3N1YmVycm9yX05vX3BpdG1fYm94AGhlaWZfc3ViZXJyb3JfSW52YWxpZF9waXhpX2JveABoZWlmX3N1YmVycm9yX0ludmFsaWRfbWluaV9ib3gAaGVpZl9zdWJlcnJvcl9Ob19paW5mX2JveABoZWlmX3N1YmVycm9yX05vX2lyZWZfYm94AGhlaWZfc3ViZXJyb3JfTm9faW5mZV9ib3gAaGVpZl9zdWJlcnJvcl9Ob19pbG9jX2JveABoZWlmX3N1YmVycm9yX05vX21ldGFfYm94AGhlaWZfc3ViZXJyb3JfTm9faXBtYV9ib3gAaGVpZl9zdWJlcnJvcl9Ob192dmNDX2JveABoZWlmX3N1YmVycm9yX05vX2h2Y0NfYm94AGhlaWZfc3ViZXJyb3JfTm9fYXZjQ19ib3gAaGVpZl9zdWJlcnJvcl9Ob19hdjFDX2JveAB0aGlzIHByb3BlcnR5IGlzIG5vdCByZWFkIGFzIGEgcmF3IGJveABlcnJvciByZWFkaW5nIGZ0eXAgYm94AGlucHV0IGlzIG5vdCBhIGZ0eXAgYm94AEludmFsaWQgcGl4aSBib3gAQ2Fubm90IHJlYWQgZnVsbCBtZXRhIGJveAApIGhhcyBubyBwcm9wZXJ0aWVzIGFzc2lnbmVkIHRvIGl0IGluIGlwbWEgYm94ACByZWZlcmVuY2VkIGluIGlwbWEgYm94AGVycm9yIHdoaWxlIHJlYWRpbmcgaHZjQyBib3gATm8gJ2lkYXQnIGJveABObyAnaGRscicgYm94AE5vICdpY2JyJyBib3gATm8gJ2Z0eXAnIGJveABObyAnaXBycCcgYm94AE5vICdpcGNvJyBib3gATm8gJ3BpdG0nIGJveABVbnN1cHBvcnRlZCBvciBpbnZhbGlkICdtaW5pJyBib3gATm8gJ2lpbmYnIGJveABObyAnaXJlZicgYm94AE5vICdpbmZlJyBib3gATm8gJ2lsb2MnIGJveABObyAnbWV0YScgYm94AE5vICdpcG1hJyBib3gATm8gJ3Z2Y0MnIGJveABObyAnaHZjQycgYm94AE5vICdhdmNDJyBib3gATm8gJ2F2MUMnIGJveABJbnZhbGlkIHF1YXRlcm5pb24gaW4gZXh0cmluc2ljIHJvdGF0aW9uIG1hdHJpeABoZWl4AGNtZXgALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweABfX25leHRfcHJpbWUgb3ZlcmZsb3cAaGVpZl9jaHJvbWFfZG93bnNhbXBsaW5nX3NoYXJwX3l1dgBOb3YAVGh1AGhlaWZfY29udGV4dABnZXRfdGhyZWFkX2NvbnRleHQAaGVpZl93cml0ZXIgY2FsbGJhY2sgcmV0dXJuZWQgYSBudWxsIGVycm9yIHRleHQAaGVpZl9lcnJvcl9JbnZhbGlkX2lucHV0AGludmFsaWQgZGlzcGFyaXR5X3JlZmVyZW5jZV92aWV3IGluIGlucHV0AGludmFsaWQgZGVwdGggcmVwcmVzZW50YXRpb24gdHlwZSBpbiBpbnB1dAB1bnN1cHBvcnRlZCBsb2NhbGUgZm9yIHN0YW5kYXJkIGlucHV0AEludmFsaWQgaW5wdXQAQXVndXN0AGhlaWZfZXJyb3JfSW5wdXRfZG9lc19ub3RfZXhpc3QAaGVpZl9lcnJvcl9Db2xvcl9wcm9maWxlX2RvZXNfbm90X2V4aXN0AFJlZ2lvbiBpdGVtIGRvZXMgbm90IGV4aXN0AEl0ZW0gZG9lcyBub3QgZXhpc3QAQ29sb3IgcHJvZmlsZSBkb2VzIG5vdCBleGlzdABJbnB1dCBmaWxlIGRvZXMgbm90IGV4aXN0AHJlYWRfc2NhbGluZ19saXN0AE1hc2sgaW1hZ2UgZGF0YSBpcyB0b28gc2hvcnQASEVWQyBTRUkgTkFMIHRvbyBzaG9ydAB1bnNpZ25lZCBzaG9ydAB1bnNpZ25lZCBpbnQAY29tcG9uZW50AGhlaWZfc3ViZXJyb3JfTnVsbF9wb2ludGVyX2FyZ3VtZW50AE5VTEwgYXJndW1lbnQAcmVmY250AGNvbnN0YW50AEhpZ2ggdmFyaWFudABoZWlmX2ZpbGV0eXBlX3Jlc3VsdAByZWFkX3RyYW5zZm9ybV91bml0AHJlYWRfY29kaW5nX3VuaXQAaW5pdABOdW1iZXIgb2YgdGlsZXMgZXhjZWVkcyBzZWN1cml0eSBsaW1pdABoZWlmX2Nocm9tYV9pbnRlcmxlYXZlZF8yNGJpdABoZWlmX2Nocm9tYV9pbnRlcmxlYXZlZF8zMmJpdABoZWlmX2ltYWdlX2hhbmRsZV9nZXRfaGVpZ2h0AHplcm8gd2lkdGggb3IgaGVpZ2h0AExheWVyZWQgSEVWQyBpbWFnZXMgKGxodjEpIGFyZSBub3Qgc3VwcG9ydGVkIHlldAAgaXMgbm90IGltcGxlbWVudGVkIHlldAByZWFkX3Nob3J0X3Rlcm1fcmVmX3BpY19zZXQAZ2V0AE9jdABmbG9hdABoZWlmX2NvbXByZXNzaW9uX2Zvcm1hdABoZWlmX3N1YmVycm9yX1dyb25nX3RpbGVfaW1hZ2VfY2hyb21hX2Zvcm1hdABObyBkZWNvZGVyIGZvciB0aGlzIGltYWdlIGZvcm1hdABXcm9uZyB0aWxlIGltYWdlIGNocm9tYSBmb3JtYXQAU2F0AHVpbnQ2NF90AGhldnMAYWxsb2NhdGVfdGhyZWFkX2NvbnRleHRzAG4gPCBuVGhyZWFkQ29udGV4dHMAY29uc3RydWN0X3JlZmVyZW5jZV9waWN0dXJlX2xpc3RzACBjb21wb25lbnRzAGhlaWZfc3ViZXJyb3JfVW5rbm93bl9OQ0xYX21hdHJpeF9jb2VmZmljaWVudHMAVW5rbm93biBOQ0xYIG1hdHJpeCBjb2VmZmljaWVudHMAdW5pdFkgPj0gMCAmJiB1bml0WSA8IGhlaWdodF9pbl91bml0cwB1bml0WCA+PSAwICYmIHVuaXRYIDwgd2lkdGhfaW5fdW5pdHMAU3VjY2VzcwBmaWxsX2x1bWFfbW90aW9uX3ZlY3Rvcl9wcmVkaWN0b3JzAGRlcml2ZV9jb2xsb2NhdGVkX21vdGlvbl92ZWN0b3JzAHNwcwBwcHMARm9ybWF0UmFuZ2VFeHRlbnNpb25zAGhlaWZfc3ViZXJyb3JfVG9vX21hbnlfcmVnaW9ucwBFcnJvciB3aGlsZSBzY2FubmluZyB0aGUgZGlyZWN0b3J5IGZvciBwbHVnaW5zAERlcml2ZWQgaW1hZ2UgZG9lcyBub3QgcmVmZXJlbmNlIGFueSBvdGhlciBpbWFnZSBpdGVtcwBjaGFubmVscwBpbml0aWFsaXplX0NBQkFDX21vZGVscwBhdmlzAGhlaXMAaW1hZ2UvajJpcwBHcmlkIHRpbGVzIGhhdmUgZGlmZmVyZW50IHNpemVzAHNldF9kZXJpdmVkX3ZhbHVlcwAgYnl0ZXMAZGVyaXZlX2NvbWJpbmVkX2JpcHJlZGljdGl2ZV9tZXJnaW5nX2NhbmRpZGF0ZXMAWUNiQ3IgaW1hZ2Ugd2l0aG91dCBZLENiLENyIHBsYW5lcwBSR0IgaW5wdXQgd2l0aG91dCBSLEcsQiwgcGxhbmVzAGdlbmVyYXRlX2ludGVyX3ByZWRpY3Rpb25fc2FtcGxlcwBkZWNvZGVfc2xpY2VfdW5pdF90aWxlcwAgbGF5ZXJzIGVudHJpZXMAaGVpZl9zdWJlcnJvcl9Vbmtub3duX05DTFhfY29sb3JfcHJpbWFyaWVzAFVua25vd24gTkNMWCBjb2xvciBwcmltYXJpZXMAdGhyZWFkX2ZpbmlzaGVzAGhlaWZfY29udGV4dF9nZXRfbnVtYmVyX29mX3RvcF9sZXZlbF9pbWFnZXMAaGVpZl9zdWJlcnJvcl9NaXNzaW5nX2dyaWRfaW1hZ2VzACdzdGVyJyBlbnRpdHkgZ3JvdXAgZG9lcyBub3QgZXhpc3RzIG9mIGV4YWN0bHkgdHdvIGltYWdlcwBNaXNzaW5nIGdyaWQgaW1hZ2VzAHVkZXMAJ2lyZWYnIGhhcyBkb3VibGUgcmVmZXJlbmNlcwBOdW1iZXIgb2YgaW1hZ2Ugb2Zmc2V0cyBkb2VzIG5vdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGltYWdlIHJlZmVyZW5jZXMAaGVpZl9zdWJlcnJvcl9Vbmtub3duX05DTFhfdHJhbnNmZXJfY2hhcmFjdGVyaXN0aWNzAFVua25vd24gTkNMWCB0cmFuc2ZlciBjaGFyYWN0ZXJpc3RpY3MAaGVpZl9zdWJlcnJvcl9PdmVybGF5X2ltYWdlX291dHNpZGVfb2ZfY2FudmFzAHk8c3BzLT5QaWNIZWlnaHRJbk1pblBVcwB4PHNwcy0+UGljV2lkdGhJbk1pblBVcwBoZWlmX2pzX2NvbnRleHRfZ2V0X2xpc3Rfb2ZfdG9wX2xldmVsX2ltYWdlX0lEcwBiYWRfd2Vha19wdHIAQXByAHZlY3RvcgBmaWxsX3NjYWxpbmdfZmFjdG9yAGhlaWZfc3ViZXJyb3JfQ29tcHJlc3Npb25faW5pdGlhbGlzYXRpb25fZXJyb3IAaGVpZl9lcnJvcl9NZW1vcnlfYWxsb2NhdGlvbl9lcnJvcgBoZWlmX2Vycm9yX0VuY29kZXJfcGx1Z2luX2Vycm9yAGhlaWZfZXJyb3JfRGVjb2Rlcl9wbHVnaW5fZXJyb3IAaGVpZl9lcnJvcl9FbmNvZGluZ19lcnJvcgBoZWlmX3N1YmVycm9yX1BsdWdpbl9sb2FkaW5nX2Vycm9yAGhlaWZfZXJyb3JfUGx1Z2luX2xvYWRpbmdfZXJyb3IAaGVpZl9lcnJvcgBoZWlmX2Vycm9yX1VzYWdlX2Vycm9yAG1vbmV5X2dldCBlcnJvcgBVbmtub3duIGVycm9yAE1lbW9yeSBhbGxvY2F0aW9uIGVycm9yAEVuY29kZXIgcGx1Z2luIGdlbmVyYXRlZCBhbiBlcnJvcgBEZWNvZGVyIHBsdWdpbiBnZW5lcmF0ZWQgYW4gZXJyb3IASW50ZXJuYWwgZXJyb3IAVXNhZ2UgZXJyb3IAQ29tcHJlc3Npb24gaW5pdGlhbGlzYXRpb24gbWV0aG9kIGVycm9yAGhlaWZfY2hyb21hX3Vwc2FtcGxpbmdfbmVhcmVzdF9uZWlnaGJvcgBoZWlmX2Nocm9tYV9kb3duc2FtcGxpbmdfbmVhcmVzdF9uZWlnaGJvcgBoZGxyAHN1Yl9sYXllcgBtdWx0aS1sYXllcgBoZWlmX3N1YmVycm9yX1Vuc3VwcG9ydGVkX3BhcmFtZXRlcgBVbnN1cHBvcnRlZCBlbmNvZGVyIHBhcmFtZXRlcgBVbnN1cHBvcnRlZCBwYXJhbWV0ZXIAQ2FuY2VsZWQgYnkgdXNlcgBoZWlmX3N1YmVycm9yX05vX3BpY3RfaGFuZGxlcgBOb3QgYSAncGljdCcgaGFuZGxlcgBNaXNzaW5nIHJlcXVpcmVkIFNJWiBNYXJrZXIATWlzc2luZyByZXF1aXJlZCBTT0MgTWFya2VyAGRlMjY1X2ltYWdlX2dldF9idWZmZXIAb3V0cHV0X25leHRfcGljdHVyZV9pbl9yZW9yZGVyX2J1ZmZlcgBpbml0X0NBQkFDX2RlY29kZXIAbGliZGUyNjUgSEVWQyBkZWNvZGVyAGR1bXBfc2xpY2Vfc2VnbWVudF9oZWFkZXIASW52YWxpZCBKUEVHIFNPRiBoZWFkZXIAT2N0b2JlcgBoZWlmX2dldF92ZXJzaW9uX251bWJlcgBoZWlmX3N1YmVycm9yX0ludmFsaWRfZnJhY3Rpb25hbF9udW1iZXIASW52YWxpZCBmcmFjdGlvbmFsIG51bWJlcgBOb3ZlbWJlcgBTZXB0ZW1iZXIARGVjZW1iZXIAYnIAcGxhbmFyAGludHJhX3ByZWRpY3Rpb25fYW5ndWxhcgB1bnNpZ25lZCBjaGFyAGhlaWZfY2hyb21hX3Vwc2FtcGxpbmdfYmlsaW5lYXIAaW9zX2Jhc2U6OmNsZWFyAE1hcgBoZWlmX2NvbG9yc3BhY2VfWUNiQ3IAaGVpZl9jaGFubmVsX0NyAGhlaWZfc3ViZXJyb3JfRW5jb2Rlcl9jbGVhbnVwAFNlcAAlSTolTTolUyAlcABtb25vAGhlaWZfZmlsZXR5cGVfbm8AdW5rbm93bgBVbmtub3duAFN1bgBKdW4Ac3RkOjpleGNlcHRpb24ARXJyb3Igc2V0dGluZyBpbnB1dCBmaWxlIHBvc2l0aW9uAGRlcml2ZV9zcGF0aWFsX2x1bWFfdmVjdG9yX3ByZWRpY3Rpb24AaGVpZl9zdWJlcnJvcl9FbmNvZGVyX2luaXRpYWxpemF0aW9uAHVua25vd24gY29sb3IgY29uZmlndXJhdGlvbgBJbnZhbGlkIGRhdGEgaW4gZ2VuZXJpYyBjb21wcmVzc2lvbiBpbmZsYXRpb24ASW52YWxpZCBjbGVhbi1hcGVydHVyZSBzcGVjaWZpY2F0aW9uAGhlaWZfc3ViZXJyb3JfVW5zdXBwb3J0ZWRfY29sb3JfY29udmVyc2lvbgBVbnN1cHBvcnRlZCBjb2xvciBjb252ZXJzaW9uAGhlaWZfZ2V0X3ZlcnNpb24AaGVpZl9zdWJlcnJvcl9VbnN1cHBvcnRlZF93cml0ZXJfdmVyc2lvbgBoZWlmX3N1YmVycm9yX1Vuc3VwcG9ydGVkX3BsdWdpbl92ZXJzaW9uAGhlaWZfc3ViZXJyb3JfVW5zdXBwb3J0ZWRfZGF0YV92ZXJzaW9uAFVuc3VwcG9ydGVkIHBsdWdpbiB2ZXJzaW9uAFVuc3VwcG9ydGVkIGRhdGEgdmVyc2lvbgBJbnN1ZmZpY2llbnQgZGF0YSByZW1haW5pbmcgZm9yIHBvaW50IHJlZ2lvbgBVbnN1cHBvcnRlZCBiaXQgZGVwdGggZm9yIG1hc2sgcmVnaW9uAFVuc3VwcG9ydGVkIGNvbG91cnNwYWNlIGZvciBtYXNrIHJlZ2lvbgBJbnN1ZmZpY2llbnQgZGF0YSByZW1haW5pbmcgZm9yIGlubGluZSBtYXNrIHJlZ2lvbgBJbnN1ZmZpY2llbnQgZGF0YSByZW1haW5pbmcgZm9yIHJlZmVyZW5jZWQgbWFzayByZWdpb24ASW5zdWZmaWNpZW50IGRhdGEgcmVtYWluaW5nIGZvciBlbGxpcHNlIHJlZ2lvbgBJbnN1ZmZpY2llbnQgZGF0YSByZW1haW5pbmcgZm9yIHJlY3RhbmdsZSByZWdpb24ASW5zdWZmaWNpZW50IGRhdGEgcmVtYWluaW5nIGZvciBwb2x5Z29uAE1vbgBjbWluAEVycm9yIHdoaWxlIGxvYWRpbmcgcGx1Z2luAE1haW4AU3VwcG9ydCBmb3IgdGhpcyBjb21wcmVzc2lvbiBmb3JtYXQgaGFzIG5vdCBiZWVuIGJ1aWx0IGluAE5VTEwgYXJndW1lbnQgcGFzc2VkIGluAG5hbgBKYW4AaGV2bQBwaXRtAGNvcHlfbGluZXNfZnJvbQBoZWltAGhlaWZfY2hyb21hX3Vwc2FtcGxpbmdfYWxnb3JpdGhtAGhlaWZfY2hyb21hX2Rvd25zYW1wbGluZ19hbGdvcml0aG0AaGVpZl9zdWJlcnJvcl9Ob19vcl9pbnZhbGlkX3ByaW1hcnlfaXRlbQBoZWlmX3N1YmVycm9yX05vX3Byb3BlcnRpZXNfYXNzaWduZWRfdG9faXRlbQBObyBvciBpbnZhbGlkIHByaW1hcnkgaXRlbQBObyBwcm9wZXJ0aWVzIGFzc2lnbmVkIHRvIGl0ZW0AVW5zdXBwb3J0ZWQgYml0IGRlcHRoIGZvciBtYXNrIGl0ZW0AQ2xlYW51cCBwcm9ibGVtAEluaXRpYWxpemF0aW9uIHByb2JsZW0ARW5jb2RpbmcgcHJvYmxlbQBoZWlmX3N1YmVycm9yX0ludmFsaWRfSjJLX2NvZGVzdHJlYW0ASW52YWxpZCBKUEVHIDIwMDAgY29kZXN0cmVhbQBKdWwAdXJsAGRlMjY1X3NldF9wYXJhbWV0ZXJfYm9vbABhcHBsaWNhdGlvbi9yZGYreG1sAGxsAEFwcmlsAFRodW1ibmFpbCByZWZlcmVuY2VzIGFub3RoZXIgdGh1bWJuYWlsAGJpdHNfcGVyX3BpeGVsAENhbiBjdXJyZW50bHkgb25seSBjcm9wIGltYWdlcyB3aXRoIDggYml0cyBwZXIgcGl4ZWwAQ2FuIGN1cnJlbnRseSBvbmx5IGZpbGwgaW1hZ2VzIHdpdGggOCBiaXRzIHBlciBwaXhlbABoZWlmX2NoYW5uZWwASW5saW5lIG1hc2sgaW1hZ2UgbXVzdCBoYXZlIGEgWSBjaGFubmVsAGRlY29kZV9zbGljZV91bml0X3BhcmFsbGVsAGhlaWZfY29sb3JzcGFjZV9ub252aXN1YWwAZ2VuZXJhbABzY2FsZV9jb2VmZmljaWVudHNfaW50ZXJuYWwAaGVpZl9jb21wcmVzc2lvbl9tYXNrAHRyYW5zZm9ybV9za2lwXzhfZmFsbGJhY2sAcHV0X3dlaWdodGVkX3ByZWRfYXZnXzhfZmFsbGJhY2sAcHV0X3dlaWdodGVkX2JpcHJlZF84X2ZhbGxiYWNrAHB1dF91bndlaWdodGVkX3ByZWRfOF9mYWxsYmFjawBwdXRfd2VpZ2h0ZWRfcHJlZF84X2ZhbGxiYWNrAHRyYW5zZm9ybV9za2lwXzE2X2ZhbGxiYWNrAHB1dF93ZWlnaHRlZF9wcmVkX2F2Z18xNl9mYWxsYmFjawBwdXRfd2VpZ2h0ZWRfYmlwcmVkXzE2X2ZhbGxiYWNrAHB1dF91bndlaWdodGVkX3ByZWRfMTZfZmFsbGJhY2sAcHV0X3dlaWdodGVkX3ByZWRfMTZfZmFsbGJhY2sAaGVpZl9lcnJvcl9PawBpbWFnZS9oZWoyawBwaXhpAEZyaQBqMmtpAGhlaWZfc3ViZXJyb3JfVW5zdXBwb3J0ZWRfYml0X2RlcHRoAGhlaWZfc3ViZXJyb3JfV3JvbmdfdGlsZV9pbWFnZV9waXhlbF9kZXB0aABoZWlmX2NoYW5uZWxfZGVwdGgAdXJuOm1wZWc6bXBlZ0I6Y2ljcDpzeXN0ZW1zOmF1eGlsaWFyeTpkZXB0aABVbnN1cHBvcnRlZCBiaXQgZGVwdGgAV3JvbmcgdGlsZSBpbWFnZSBwaXhlbCBkZXB0aABkZXJpdmVfYm91bmRhcnlTdHJlbmd0aABiYWRfYXJyYXlfbmV3X2xlbmd0aABoZWlmX2ltYWdlX2hhbmRsZV9nZXRfd2lkdGgAcHVzaABNYXJjaAAuL2RlY2N0eC5oAC4uL2xpYmRlMjY1L2ltYWdlLmgALi9pbWFnZS5oAC4vaW50cmFwcmVkLmgAQXVnAGltYWdlL3BuZwB1bnNpZ25lZCBsb25nAHN0ZDo6d3N0cmluZwBiYXNpY19zdHJpbmcAc3RkOjpzdHJpbmcAc3RkOjp1MTZzdHJpbmcAc3RkOjp1MzJzdHJpbmcARmFpbGVkIHRvIGFsbG9jYXRlIG1lbW9yeSBmb3IgdGhlIHR5cGUgc3RyaW5nAGludHJhX3ByZWRpY3Rpb25fc2FtcGxlX2ZpbHRlcmluZwBoZWlmX3N1YmVycm9yX0VuY29kZXJfZW5jb2RpbmcAaW1hZ2UvanBlZwBkZWNvZGVfc3BsaXRfdHJhbnNmb3JtX2ZsYWcAaW5mACdpZGVuJyBpbWFnZSByZWZlcnJpbmcgdG8gaXRzZWxmAGltYWdlL2F2aWYAaW1hZ2UvaGVpZgBvZmYAaXJlZgBkcmVmACUuMExmACVMZgBoZWlmX3N1YmVycm9yX0ludmFsaWRfYm94X3NpemUAaGVpZl9zdWJlcnJvcl9JbnZhbGlkX2ltYWdlX3NpemUAaWR4PGludHJhUHJlZE1vZGVDLmRhdGFfc2l6ZQBJbnZhbGlkIGJveCBzaXplAGF2MUMgd2l0aCB1bnNwZWNpZmllZCBib3ggc2l6ZQBqcGdDIGJsb2NrIGV4Y2VlZHMgbWF4aW11bSBzaXplAFJlYWQgYmV5b25kIGZpbGUgc2l6ZQBJbnZhbGlkIGltYWdlIHNpemUASW1hZ2Ugc2l6ZSBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUAQ29sb3IgcHJvZmlsZSBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUAQ2Fubm90IHJlYWQgbWV0YSBib3ggd2l0aCB1bnNwZWNpZmllZCBzaXplAGRhdGEgbGVuZ3RoIG11c3QgYmUgcG9zaXRpdmUAaW50ZXJsZWF2ZQB0cnVlAGhlaWZfc3ViZXJyb3JfSW52YWxpZF9wYXJhbWV0ZXJfdmFsdWUAT3V0IG9mIHJhbmdlIExzaXogdmFsdWUAT3V0IG9mIHJhbmdlIENzaXogdmFsdWUASW52YWxpZCBwYXJhbWV0ZXIgdmFsdWUAT3V0IG9mIHJhbmdlIExjYXAgdmFsdWUASW52YWxpZCBpbnB1dCByZWFkZXIgcmV0dXJuIHZhbHVlAHNldF9pbml0VmFsdWUAVHVlAFRpbGkgaGVhZGVyIGRhdGEgaW5jb21wbGV0ZQBSZWdpb24gZGF0YSBpbmNvbXBsZXRlAE92ZXJsYXkgaW1hZ2UgZGF0YSBpbmNvbXBsZXRlAEdyaWQgaW1hZ2UgZGF0YSBpbmNvbXBsZXRlAGRlZmxhdGUAZmFsc2UAaGVpZl9pbWFnZV9oYW5kbGVfcmVsZWFzZQBoZWlmX2ltYWdlX3JlbGVhc2UAaGVpZl9zdWJlcnJvcl9JbnZhbGlkX2NsZWFuX2FwZXJ0dXJlAGdlbmVyYXRlX3VuYXZhaWxhYmxlX3JlZmVyZW5jZV9waWN0dXJlAE1haW5TdGlsbFBpY3R1cmUAaGVpZl9lcnJvcl9VbnN1cHBvcnRlZF9mZWF0dXJlAFVuc3VwcG9ydGVkIGZlYXR1cmUAaGVpZl9qc19jaGVja19maWxldHlwZQBoZWlmX2Vycm9yX1Vuc3VwcG9ydGVkX2ZpbGV0eXBlAGhlaWZfc3ViZXJyb3JfVW5rbm93bl9jb2xvcl9wcm9maWxlX3R5cGUAaGVpZl9zdWJlcnJvcl9VbnN1cHBvcnRlZF9pbWFnZV90eXBlAFVuc3VwcG9ydGVkIGZpbGUtdHlwZQB3cm9uZyBwcm9wZXJ0eSB0eXBlAFVua25vd24gY29sb3IgcHJvZmlsZSB0eXBlAFVuc3VwcG9ydGVkIGltYWdlIHR5cGUAaXNwZQBKdW5lAENvbnN0cmFpbmVkIEJhc2VsaW5lAGRlMjY1X2dldF9pbWFnZV9wbGFuZQBzY2FsaW5nIGlucHV0IGhhcyBleHRyYSBjb2xvciBwbGFuZQBtb25vY2hyb21lIGlucHV0IHdpdGggbm8gWSBwbGFuZQBoZWlmX2NvbG9yc3BhY2VfbW9ub2Nocm9tZQBoZWlmX2Nocm9tYV9tb25vY2hyb21lAGRlY291cGxlACd0aWxpJyBpbWFnZXMgY2FuIG9ubHkgYmUgYWNjZXNzIHBlciB0aWxlAEVycm9yIGR1cmluZyBlbmNvZGluZyBvciB3cml0aW5nIG91dHB1dCBmaWxlAEVycm9yIHJlYWRpbmcgaW5wdXQgZmlsZQBpZGF0IGJveCByZWZlcmVuY2VkIGluIGlyZWYgYm94IGlzIG5vdCBwcmVzZW50IGluIGZpbGUAIHRpbGUgaW1hZ2VzIGluIGZpbGUAVW5leHBlY3RlZCBlbmQgb2YgZmlsZQBmdHlwIGJveCBzaGFsbCBub3QgYmUgdGhlIG9ubHkgYm94IGluIHRoZSBmaWxlAGhlaWZfanNfY29udGV4dF9nZXRfcHJpbWFyeV9pbWFnZV9oYW5kbGUAaGVpZl9qc19jb250ZXh0X2dldF9pbWFnZV9oYW5kbGUAaGVpZl9pbWFnZV9oYW5kbGUAaGVpZl9zdWJlcnJvcl9JdGVtX3JlZmVyZW5jZV9jeWNsZQBJbWFnZSByZWZlcmVuY2UgY3ljbGUAZG91YmxlAHJlYWRfcHJlZF93ZWlnaHRfdGFibGUAYWxsb2NfYW5kX2luaXRfc2lnbmlmaWNhbnRfY29lZmZfY3R4SWR4X2xvb2t1cFRhYmxlAEJveCBzaXplIHRvbyBsYXJnZQBwcm9wZXJ0eSBpbmRleCBvdXQgb2YgcmFuZ2UAR3JpZCB0aWxlIGluZGV4IG91dCBvZiByYW5nZQBpbnB1dCBkZXB0aCByZXByZXNlbnRhdGlvbiB0eXBlIG91dCBvZiByYW5nZQBpbG9jIGRhdGEgcG9pbnRlcnMgb3V0IG9mIGFsbG93ZWQgcmFuZ2UAZnR5cCBib3ggbGFyZ2VyIHRoYW4gaW5pdGlhbCByZWFkIHJhbmdlAG1lc3NhZ2UAaGVpZl9jaHJvbWFfZG93bnNhbXBsaW5nX2F2ZXJhZ2UAaGVpZl9pbWFnZV9oYW5kbGVfaXNfcHJpbWFyeV9pbWFnZQBuZXdfaW1hZ2UAZmlsbF9mcm9tX2ltYWdlAGhlaWZfaW1hZ2UAYWxsb2NfaW1hZ2UATm8gaXJlZiBib3ggYXZhaWxhYmxlLCBidXQgbmVlZGVkIGZvciBpZGVuIGltYWdlAFJlZ2lvbiBtYXNrIHJlZmVyZW5jZWQgaXRlbSBpcyBub3QgYW4gaW1hZ2UATm8gaXJlZiBib3ggYXZhaWxhYmxlLCBidXQgbmVlZGVkIGZvciBpb3ZsIGltYWdlACdwaXRtJyBib3ggcmVmZXJlbmNlcyBhbiB1bnN1cHBvcnRlZCBvciBub24tZXhpc3RpbmcgaW1hZ2UAUmVnaW9uIGl0ZW0gYXNzaWduZWQgdG8gbm9uLWV4aXN0aW5nIGltYWdlAGBwcmVtYCBsaW5rIGFzc2lnbmVkIHRvIG5vbi1leGlzdGluZyBpbWFnZQBNZXRhZGF0YSBhc3NpZ25lZCB0byBub24tZXhpc3RpbmcgaW1hZ2UAVGh1bWJuYWlsIHJlZmVyZW5jZXMgYSBub24tZXhpc3RpbmcgaW1hZ2UATm8gdnZjQyBwcm9wZXJ0eSBpbiB2dmMxIHR5cGUgaW1hZ2UATm8gaHZjQyBwcm9wZXJ0eSBpbiBodmMxIHR5cGUgaW1hZ2UAR3JpZCB0aWxlcyBkbyBub3QgY292ZXIgd2hvbGUgaW1hZ2UAJ2lkZW4nIGltYWdlIHJlZmVyZW5jZXMgdW5hdmFpbGFibGUgaW1hZ2UAJ2lkZW4nIGltYWdlIHdpdGggbW9yZSB0aGFuIG9uZSByZWZlcmVuY2UgaW1hZ2UATm8gaXJlZiBib3ggYXZhaWxhYmxlLCBidXQgbmVlZGVkIGZvciBncmlkIGltYWdlAEltYWdlIGlzIG5vIGdyaWQgaW1hZ2UASW1hZ2UgdGlsZSBoYXMgZGlmZmVyZW50IGNocm9tYSBmb3JtYXQgdGhhbiBjb21iaW5lZCBpbWFnZQBDYW5ub3QgYWRkIHRpbGUgdG8gYSBub24tdGlsZWQgaW1hZ2UAaW5mZQByZWFkX3RyYW5zZm9ybV90cmVlAGhlaWZfY29udGV4dF9mcmVlAGRlY29kZV9wYXJ0X21vZGUAZGVjb2RlAHN1YmNvZGUAaGVpZl9zdWJlcnJvcl9jb2RlAGhlaWZfZXJyb3JfY29kZQBQcmVkTW9kZSA9PSBjdVByZWRNb2RlAHN0cmlkZQBpbWFnZS9hdmlmLXNlcXVlbmNlAGltYWdlL2hlaWYtc2VxdWVuY2UAaW1hZ2UvaGVpYy1zZXF1ZW5jZQBSZWdpb24gbWFzayByZWZlcmVuY2Ugd2l0aCBub24tZXhpc3RpbmcgbWFzayBpbWFnZSByZWZlcmVuY2UAaGVpZl9jb2xvcnNwYWNlAGhlaWZfZmlsZXR5cGVfbWF5YmUAaGVpZl9zdWJlcnJvcl9VbnN1cHBvcnRlZF9pdGVtX2NvbnN0cnVjdGlvbl9tZXRob2QAaGVpZl9zdWJlcnJvcl9VbnN1cHBvcnRlZF9oZWFkZXJfY29tcHJlc3Npb25fbWV0aG9kAGhlaWZfc3ViZXJyb3JfVW5zdXBwb3J0ZWRfZ2VuZXJpY19jb21wcmVzc2lvbl9tZXRob2QAVW5zdXBwb3J0ZWQgaXRlbSBjb25zdHJ1Y3Rpb24gbWV0aG9kAFVuc3VwcG9ydGVkIGhlYWRlciBjb21wcmVzc2lvbiBtZXRob2QAVW5zdXBwb3J0ZWQgZ2VuZXJpYyBjb21wcmVzc2lvbiBtZXRob2QATm8gbWV0YSBib3ggZm91bmQAdm9pZABOVUxMIGFyZ3VtZW50IHJlY2VpdmVkAGhlaWZfY2hhbm5lbF9pbnRlcmxlYXZlZABoZWlmX2ZpbGV0eXBlX3llc191bnN1cHBvcnRlZABoZWlmX2ZpbGV0eXBlX3llc19zdXBwb3J0ZWQAVGhlIHZlcnNpb24gb2YgdGhlIHBhc3NlZCB3cml0ZXIgaXMgbm90IHN1cHBvcnRlZABUaGUgdmVyc2lvbiBvZiB0aGUgcGFzc2VkIHBsdWdpbiBpcyBub3Qgc3VwcG9ydGVkAHBjbHIgbW9yZSB0aGFuIDE2IGJpdHMgcGVyIGNoYW5uZWwgaXMgbm90IHN1cHBvcnRlZABwY2xyIHdpdGggc2lnbmVkIGRhdGEgaXMgbm90IHN1cHBvcnRlZABQbHVnaW5zIGFyZSBub3Qgc3VwcG9ydGVkAENoYW5uZWxzIHdpdGggZGlmZmVyZW50IG51bWJlciBvZiBiaXRzIHBlciBwaXhlbCBhcmUgbm90IHN1cHBvcnRlZABjb2xyIGJveGVzIHdpdGggdW5kZWZpbmVkIGJveCBzaXplIGFyZSBub3Qgc3VwcG9ydGVkAGpwZ0Mgd2l0aCB1bnNwZWNpZmllZCBzaXplIGFyZSBub3Qgc3VwcG9ydGVkAGxvY2FsZSBub3Qgc3VwcG9ydGVkAERlZmxhdGUgY29tcHJlc3NlZCBpbmxpbmUgbWFzayBpcyBub3QgeWV0IHN1cHBvcnRlZABzY2FsaW5nIGxpc3QgbG9nZ2luZyBvdXRwdXQgbm90IGltcGxlbWVudGVkAFJlY3Vyc2l2ZSBhdXggaW1hZ2UgZGV0ZWN0ZWQAUmVjdXJzaXZlIHRodW1ibmFpbCBpbWFnZSBkZXRlY3RlZABSZWN1cnNpdmUgZGVwdGggaW1hZ2UgZGV0ZWN0ZWQAUmVjdXJzaXZlIGFscGhhIGltYWdlIGRldGVjdGVkAGhlaWZfY29tcHJlc3Npb25fdW5jb21wcmVzc2VkAE5VTEwgcGFzc2VkAGhlaWZfc3ViZXJyb3JfQ2FtZXJhX2V4dHJpbnNpY19tYXRyaXhfdW5kZWZpbmVkAGhlaWZfc3ViZXJyb3JfQ2FtZXJhX2ludHJpbnNpY19tYXRyaXhfdW5kZWZpbmVkAGhlaWZfY29tcHJlc3Npb25fdW5kZWZpbmVkAGhlaWZfY29sb3JzcGFjZV91bmRlZmluZWQAaGVpZl9jaHJvbWFfdW5kZWZpbmVkAENhbWVyYSBleHRyaW5zaWMgbWF0cml4IHVuZGVmaW5lZABDYW1lcmEgaW50cmluc2ljIG1hdHJpeCB1bmRlZmluZWQAaGVpZl9zdWJlcnJvcl9Ob19tYXRjaGluZ19kZWNvZGVyX2luc3RhbGxlZABtdXRleCBsb2NrIGZhaWxlZABEZWNvZGluZyB0aGUgaW1hZ2Ugd2FzIGNhbmNlbGVkAGhlaWZfZXJyb3JfQ2FuY2VsZWQAaGVpZl9zdWJlcnJvcl9BdXhpbGlhcnlfaW1hZ2VfdHlwZV91bnNwZWNpZmllZABUeXBlIG9mIGF1eGlsaWFyeSBpbWFnZSB1bnNwZWNpZmllZABoZWlmX3N1YmVycm9yX1Vuc3BlY2lmaWVkAGhlaWZfc3ViZXJyb3JfU2VjdXJpdHlfbGltaXRfZXhjZWVkZWQAU2VjdXJpdHkgbGltaXQgZXhjZWVkZWQAU2VjdXJpdHkgbGltaXQgZm9yIG1heGltdW0gbmVzdGluZyBvZiBib3hlcyBoYXMgYmVlbiBleGNlZWRlZABoZWlmX3N1YmVycm9yX1BsdWdpbl9pc19ub3RfbG9hZGVkAFRyeWluZyB0byByZW1vdmUgYSBwbHVnaW4gdGhhdCBpcyBub3QgbG9hZGVkAFBsdWdpbiBmaWxlIGNhbm5vdCBiZSBsb2FkZWQAaGVpZl9zdWJlcnJvcl9Ob25leGlzdGluZ19pdGVtX3JlZmVyZW5jZWQAaGVpZl9zdWJlcnJvcl9Ob25leGlzdGluZ19pbWFnZV9jaGFubmVsX3JlZmVyZW5jZWQATm9uLWV4aXN0aW5nIGltYWdlIGNoYW5uZWwgcmVmZXJlbmNlZABOb24tZXhpc3RpbmcgYXV4IGltYWdlIHJlZmVyZW5jZWQATm9uLWV4aXN0aW5nIGRlcHRoIGltYWdlIHJlZmVyZW5jZWQATm9uZXhpc3RlbnQgZ3JpZCBpbWFnZSByZWZlcmVuY2VkAE5vbi1leGlzdGluZyBhbHBoYSBpbWFnZSByZWZlcmVuY2VkAE5vbi1leGlzdGluZyBpdGVtIElEIHJlZmVyZW5jZWQAV2VkAHNwcy0+c3BzX3JlYWQAcHBzLT5wcHNfcmVhZABzbGljZS1zZWdtZW50LSVkOyVkAGN0Yi1yb3ctJWQAc2FvLSVkAGRlYmxvY2stJWQAKiVkAGhldmMAaGVpZl9jb250ZXh0X2FsbG9jAHN0ZDo6YmFkX2FsbG9jAGlsb2MAY3R4SWR4TG9va3VwW2xvZzJ3LTJdW2NJZHhdW3NjYW5JZHhdW3ByZXZDc2JmXVt4QysoeUM8PGxvZzJ3KV0gPT0gY3R4SWR4SW5jAGdldF91dmxjAHZ2aWMAaW1hZ2UvaGVpYwBoZWlmX3N1YmVycm9yX1Vuc3VwcG9ydGVkX2NvZGVjAE1pc3NpbmcgcmVxdWlyZWQgYm94IGZvciBtYXNrIGNvZGVjAFVuc3VwcG9ydGVkIGNvZGVjAERlYwBkZWNjdHguY2MAZmFsbGJhY2stZGN0LmNjAHZwcy5jYwBzcHMuY2MAcHBzLmNjAG5hbC1wYXJzZXIuY2MAZmFsbGJhY2stbW90aW9uLmNjAHRyYW5zZm9ybS5jYwBiaXRzdHJlYW0uY2MAY29udGV4dG1vZGVsLmNjAGRlYmxvY2suY2MAaW1hZ2UuY2MAc2xpY2UuY2MAcmVmcGljLmNjAGNhYmFjLmNjAGRwYi5jYwBkZTI2NS5jYwB3YgByYgBjb21wcmVzc196bGliAEZlYgBhYgBoZWlmX2NoYW5uZWxfQ2IAdytiAHIrYgBhK2IAcndhAG1ldGEAZGVjb3VwbGVfb3JfYWxsb2Nfd2l0aF9lbXB0eV9kYXRhAGhlaWZfc3ViZXJyb3JfSW52YWxpZF9vdmVybGF5X2RhdGEAaGVpZl9zdWJlcnJvcl9DYW5ub3Rfd3JpdGVfb3V0cHV0X2RhdGEAaGVpZl9zdWJlcnJvcl9JbnZhbGlkX3JlZ2lvbl9kYXRhAGhlaWZfc3ViZXJyb3JfTm9faXRlbV9kYXRhAGhlaWZfc3ViZXJyb3JfRW5kX29mX2RhdGEAaGVpZl9zdWJlcnJvcl9JbnZhbGlkX2dyaWRfZGF0YQBoZWlmX3N1YmVycm9yX0RlY29tcHJlc3Npb25faW52YWxpZF9kYXRhAEludmFsaWQgb3ZlcmxheSBkYXRhAENhbm5vdCB3cml0ZSBvdXRwdXQgZGF0YQBpbnN1ZmZpY2llbnQgaW5wdXQgZGF0YQBJbnN1ZmZpY2llbnQgaW5wdXQgZGF0YQBJdGVtIGhhcyBubyBkYXRhAEludmFsaWQgcmVnaW9uIGl0ZW0gZGF0YQBMZXNzIHRoYW4gOCBieXRlcyBvZiBkYXRhAEludmFsaWQgZ3JpZCBkYXRhACBoYXMgbm8gY29tcHJlc3NlZCBkYXRhAGlwbWEAaGVpZl9jaHJvbWEAbWNfY2hyb21hAHVybjptcGVnOm1wZWdCOmNpY3A6c3lzdGVtczphdXhpbGlhcnk6YWxwaGEAaGVpZl9jaGFubmVsX0FscGhhAE92ZXJsYXkgaW1hZ2Ugb3V0c2lkZSBvZiBjYW52YXMgYXJlYQBJbnN1ZmZpY2llbnQgZGF0YSByZW1haW5pbmcgZm9yIGlubGluZSBtYXNrIHJlZ2lvbiBkYXRhW10AICBxID0gWwBsYXllci1zaXplczogWwBoZWlmX2NoYW5uZWxfWQAlYSAlYiAlZCAlSDolTTolUyAlWQBQT1NJWABMSUJIRUlGX1NFQ1VSSVRZX0xJTUlUUwBmaXJzdExheWVyUmVhZCA8IE1BWF9URU1QT1JBTF9TVUJMQVlFUlMAVlBTAFNQUwBQUFMAU1VGRklYX0FQUwBQUkVGSVhfQVBTAGo+PTAgJiYgaiA8IE1BWF9OVU1fUkVGX1BJQ1MAaGVpZl9jaGFubmVsX1IAZGVjb2RlX3NsaWNlX3VuaXRfV1BQAE5BTgBQTQBTRUNBTQB0aHJlYWRfY29udGV4dHM9PU5VTEwAY2Fubm90IHJldHVybiBkYXRhIHdpdGggb3V0X2RhdGFfc2l6ZT09TlVMTABwZW5kaW5nX2lucHV0X05BTCA9PSBOVUxMAExDX0FMTABQQUwAcHVzaF9OQUwAaGVpZl9jb21wcmVzc2lvbl9IVEoySwBPUEkARENJAFBIAGhlaWZfY2hhbm5lbF9HAExBTkcAaGVpZl9jb21wcmVzc2lvbl9KUEVHAElORgBPRkYAblQgPD0gTUFYX0lOVFJBX1BSRURfQkxPQ0tfU0laRQBoZWlmX2Nocm9tYV9pbnRlcmxlYXZlZF9SUkdHQkJfTEUAaGVpZl9jaHJvbWFfaW50ZXJsZWF2ZWRfUlJHR0JCQUFfTEUAaGVpZl9jaHJvbWFfaW50ZXJsZWF2ZWRfUlJHR0JCX0JFAGhlaWZfY2hyb21hX2ludGVybGVhdmVkX1JSR0dCQkFBX0JFAGF1eEMAc3BzLT5TdWJIZWlnaHRDID09IFN1YkhlaWdodEMAc3BzLT5TdWJXaWR0aEMgPT0gU3ViV2lkdGhDAHNldF9JbnRyYVByZWRNb2RlQwBoZWlmX2NvbXByZXNzaW9uX1ZWQwBoZWlmX2NvbXByZXNzaW9uX0VWQwBoZWlmX2NvbXByZXNzaW9uX0hFVkMAaGVpZl9jb21wcmVzc2lvbl9BVkMATlRTQwBNQUMAaGVpZl9jaGFubmVsX0IAc2hkci0+c2xpY2VfdHlwZSA9PSBTTElDRV9UWVBFX0IAaGVpZl9jb2xvcnNwYWNlX1JHQgBoZWlmX2Nocm9tYV9pbnRlcmxlYXZlZF9SR0IAaGVpZl9jaHJvbWFfaW50ZXJsZWF2ZWRfUkdCQQA/AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50NjRfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50NjRfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+ADtpbmRleD0ATm9uZXhpc3RpbmcgcHJvcGVydHkgKGluZGV4PQBJdGVtIChJRD0AVGlsZSBpbWFnZSBJRD0AOwBjb25maWcgT0JVczoAZ2VuZXJhbCBsZXZlbDoAMDEyMzQ1Njc4OQAxLjE5LjgAQy5VVEYtOAByZWY8NwBoZHItPm51bV9yZWZfaWR4X2wxX2FjdGl2ZSA8PSAxNgBoZHItPm51bV9yZWZfaWR4X2wwX2FjdGl2ZSA8PSAxNgBpbWctPkJpdERlcHRoX1kgPj0gOCAmJiBpbWctPkJpdERlcHRoX1kgPD0gMTYAaW1nLT5CaXREZXB0aF9DID49IDggJiYgaW1nLT5CaXREZXB0aF9DIDw9IDE2AGxpYmRlMjY1AGludHJhUHJlZE1vZGU8MzUATnVtYmVyIG9mIHRpbGUgcm93cy9jb2x1bW5zIG1heSBub3QgZXhjZWVkIDY1NTM1ADEuMC4xNQBIaWdoIDQ6NDo0AENBTFZDIDQ6NDo0AGhlaWZfY2hyb21hXzQ0NABzY2FsaW5nX2xpc3RfcHJlZF9tYXRyaXhfaWRfZGVsdGE9PTMAaGVpZl9qc19kZWNvZGVfaW1hZ2UyAGludHJhUHJlZE1vZGU+PTIAbnVtTVZQQ2FuZExYPT0yAHVybjptcGVnOmhldmM6MjAxNTphdXhpZDoyAEhpZ2ggNDoyOjIAbW9kZWxbaV0uc3RhdGUgPD0gNjIAblQ8PTMyAGhlaWZfY2hyb21hXzQyMgBjb250ZXh0ID49IDAgJiYgY29udGV4dCA8PSAyAGNoYW5uZWw+PTAgJiYgY2hhbm5lbCA8PSAyAGluaXRUeXBlID49IDAgJiYgaW5pdFR5cGUgPD0gMgBtc2YxAG1pZjEAaGVpZl9jb21wcmVzc2lvbl9BVjEAcmVmUGljUTA9PXJlZlBpY1ExACpyZWZjbnQ+MQBsb2cyV0Q+PTEAdXJuOm1wZWc6aGV2YzoyMDE1OmF1eGlkOjEAdXJuOm1wZWc6YXZjOjIwMTU6YXV4aWQ6MQBjYmZfY3IgIT0gLTEAY2JmX2NiICE9IC0xAGNiZl9sdW1hICE9IC0xAHZhbHVlPjAAUklkeD49MAByZWZQaWNMaXN0Pj0wAHRpbGVYPj0wICYmIHRpbGVZPj0wAHJkcGNtTW9kZT09MAAod2lkdGgmMSk9PTAANDoyOjAAaGVpZl9jaHJvbWFfNDIwAE1haW4xMABIaWdoIDEwAGhlaWZfY29tcHJlc3Npb25fSlBFRzIwMDAAbGVuZ3RoID49IDAAblRocmVhZHNSdW5uaW5nID49IDAAZmlyc3QgJSAyID09IDAAZW5kICUgMiA9PSAwAGltZy0+bnVtX3RocmVhZHNfYWN0aXZlKCkgPT0gMAAvAFRpbGVkIGltYWdlIHdpdGhvdXQgJ2lzcGUnIHByb3BlcnR5IGJveC4AVGlsZWQgaW1hZ2Ugd2l0aG91dCAndGlsQycgcHJvcGVydHkgYm94LgBDYW5ub3Qgd3JpdGUgZHVtbXkgZXJyb3IgYm94LgBUb28gbWFueSBlbnRpdGllcyBpbiBkcmVmIGJveC4AQ2Fubm90IHdyaXRlIG1vcmUgdGhhbiAyNTUgU1BTLUV4dCBpbnRvIGF2Y0MgYm94LgBDYW5ub3Qgd3JpdGUgU1BTLUV4dCBsYXJnZXIgdGhhbiA2NTUzNSBieXRlcyBpbnRvIGF2Y0MgYm94LgBDYW5ub3Qgd3JpdGUgU1BTIGxhcmdlciB0aGFuIDY1NTM1IGJ5dGVzIGludG8gYXZjQyBib3guAENhbm5vdCB3cml0ZSBQUFMgbGFyZ2VyIHRoYW4gNjU1MzUgYnl0ZXMgaW50byBhdmNDIGJveC4AQ2Fubm90IHdyaXRlIG1vcmUgdGhhbiAyNTUgUFBTIGludG8gYXZjQyBib3guAENhbm5vdCB3cml0ZSBtb3JlIHRoYW4gMzEgUFBTIGludG8gYXZjQyBib3guAEZpbGUgZG9lcyBub3Qgc3RhcnQgd2l0aCAnZnR5cCcgYm94LgBOb3QgZW5vdWdoIGRhdGEgcHJlc2VudCBpbiAnaWxvYycgdG8gc2F0aXNmeSByZXF1ZXN0LgBOdW1iZXIgb2YgdGlsZXMgZXhjZWVkcyBzZWN1cml0eSBsaW1pdC4AT3ZlcmxheSBpbWFnZSB3aXRoIHplcm8gd2lkdGggb3IgaGVpZ2h0LgAndGlsaScgaW1hZ2Ugd2l0aCB6ZXJvIHdpZHRoIG9yIGhlaWdodC4AJ3RpbGknIGltYWdlIHdpdGggdW5zdXBwb3J0ZWQgY29tcHJlc3Npb24gZm9ybWF0LgBUb28gbWFueSBWVkMgTkFMIGFycmF5cy4AIGV4dGVudHMuAFRvbyBtYW55IFZWQyBOQUwgdW5pdHMuAENhbm5vdCBkZWNvZGUgd2l0aCBhIGR1bW15IGRlY29kZXIgcGx1Z2lucy4AIGl0ZW1zLgAgZW50aXRpZXMuAElucHV0IGZpbGUgaGFzIGFuICdpcmVmJyBib3ggd2l0aCBubyByZWZlcmVuY2VzLgBoZWlmX2ltYWdlX2NyZWF0ZTogTlVMTCBwYXNzZWQgYXMgaW1hZ2UgcG9pbnRlci4ASW52YWxpZCBjb2xvcnNwYWNlL2Nocm9tYSBjb21iaW5hdGlvbi4AJ2lvdmwnIGltYWdlIHJlZmVyZW5jZXMgYSBub24tZXhpc3RpbmcgaXRlbS4AU2VsZi1yZWZlcmVuY2UgaW4gJ2lvdmwnIGltYWdlIGl0ZW0uAFRvbyBtYW55IHJlZ2lvbnMgKD4yNTUpIGluIGFuICdyZ2FuJyBpdGVtLgBGaWxlIHNpemUgdG9vIHNtYWxsLgBUaWxlIGltYWdlIHNpemUgZG9lcyBub3QgbWF0Y2ggdGhlIHNwZWNpZmllZCB0aWxlIHNpemUuAFZWQyBOQUwgdG9vIGxhcmdlLgBWQ0MgYml0IGRlcHRoIG91dCBvZiByYW5nZS4ARXhjZWVkZWQgc3VwcG9ydGVkIHZhbHVlIHJhbmdlLgAgaXMgbm90IGEgcHJvcGVyIGltYWdlLgBUaHVtYm5haWwgaW1hZ2VzIG11c3QgYmUgc21hbGxlciB0aGFuIHRoZSBvcmlnaW5hbCBpbWFnZS4ATm8gajJrSCBib3ggZm91bmQuAE5vIHN1cHBvcnRlZCBicmFuZHMgZm91bmQuAHZ2Y0Mgd2l0aCBudW1fYnl0ZXNfY29uc3RyYWludF9pbmZvPT0wIGlzIG5vdCBhbGxvd2VkLgAnIGlzIG5vdCBzdXBwb3J0ZWQuACcgYm94IGV4Y2VlZGVkLgBDb3VsZCBub3QgZmluZCBsb2NhdGlvbiBvZiBUSUZGIGhlYWRlciBpbiBFeGlmIG1ldGFkYXRhLgBjYWxsZWQgaGVpZl9jb250ZXh0X2FkZF9pdGVtKCkgd2l0aCBpbnZhbGlkICdpdGVtX3R5cGUnLgBjYWxsZWQgaGVpZl9jb250ZXh0X2FkZF9nZW5lcmljX21ldGFkYXRhKCkgd2l0aCBpbnZhbGlkICdpdGVtX3R5cGUnLgAqLAB3KwByKwBhKwBJbnZhbGlkIGNvbG9yX3Byb2ZpbGVfdHlwZSAobXVzdCBiZSA0IGNoYXJhY3RlcnMpAChmcm9tIHBwcykAZnR5cCBib3ggdG9vIHNtYWxsIChsZXNzIHRoYW4gOCBieXRlcykATWlzc2luZyByZXF1aXJlZCBoZWFkZXIgbWFya2VyKHMpACh1bmtub3duKQAobnVsbCkAZHBiLmhhc19mcmVlX2RwYl9waWN0dXJlKHRydWUpAChvdmVycmlkZSkAY3R4LT5oYXNfaW1hZ2UoY29sUGljKQAoZnJvbSBQUFMpAENvdWxkIG5vdCB3cml0ZSB0byB0bXAgZmlsZSAoc3RvcmFnZSBmdWxsPykAU1BTIG1heCBwaWN0dXJlIHdpZHRoIG9yIGhlaWdodCBleGNlZWRzIG1heGltdW0gKDY1NTM1KQBUb28gbWFueSB0aWxlcyAobWF4aW11bTogNjU1MzUpAFRvbyBtYW55IG92ZXJsYXkgaW1hZ2VzIChtYXhpbXVtOiA2NTUzNSkAISh0cmFmb0RlcHRoPT0wICYmIGxvZzJUcmFmb1NpemU9PTIpACFyZW9yZGVyX291dHB1dF9xdWV1ZS5lbXB0eSgpAE5VTEwgcGFzc2VkIHRvIGhlaWZfaW1hZ2VfaGFuZGxlX2dldF9pbWFnZV90aWxpbmcoKQBSSWR4ID49IDAgJiYgUklkeCA8IHNldHMuc2l6ZSgpAE5VTEwgb3V0X2RlcHRoX2hhbmRsZSBwYXNzZWQgdG8gaGVpZl9pbWFnZV9oYW5kbGVfZ2V0X2RlcHRoX2ltYWdlX2hhbmRsZSgpAE5VTEwgb3V0X2ltZyBwYXNzZWQgdG8gaGVpZl9kZWNvZGVfaW1hZ2UoKQBOdW1iZXIgb2YgcmVmZXJlbmNlcyBpbiBpcmVmIGJveCAoAE51bWJlciBvZiBleHRlbnRzIGluIGlsb2MgYm94ICgAKSBleGNlZWRzIHNlY3VyaXR5IGxpbWl0ICgATWF4aW11bSBudW1iZXIgb2YgY2hpbGQgYm94ZXMgKABJbnB1dCBlcnJvciAoAEJveCBzaXplICgAIGJ5dGVzKSBzbWFsbGVyIHRoYW4gaGVhZGVyIHNpemUgKAB3aGl0ZSBwb2ludCAoeCx5KTogKABDYW5ub3QgZW5jb2RlIGltYWdlIHRvICdpZGVuJwBDYW5ub3QgZW5jb2RlIGltYWdlIHRvICdpb3ZsJwBDYW5ub3QgZW5jb2RlIGltYWdlIHRvICd0aWxkJwBDYW5ub3QgZW5jb2RlIGltYWdlIHRvICdncmlkJwBjb3VsZCBub3QgcGFyc2UgaXRlbSBwcm9wZXJ0eSAnACkgaW4gJwByZWZlcmVuY2Ugd2l0aCB0eXBlICcASW1hZ2UgaXRlbSBvZiB0eXBlICcAUHVyZSB2aXJ0dWFsIGZ1bmN0aW9uIGNhbGxlZCEAfCAAIHRpbGVzLCBidXQgb25seSAAIHggAEpQRUctMjAwMCBsYXllcnMsIGJ1dCB0aGUgYm94IG9ubHkgY29udGFpbnMgACBKUEVHLTIwMDAgY2hhbm5lbHMsIGJ1dCBmaWxlIG9ubHkgY29udGFpbnMgAGVudGl0eSBncm91cCBib3ggY29udGFpbnMgAGlsb2MgYm94IGNvbnRhaW5zIABFeHRlbnQgaW4gaWxvYyBib3ggcmVmZXJlbmNlcyBkYXRhIG91dHNpZGUgb2YgZmlsZSBib3VuZHMgAENvdWxkIG5vdCB3cml0ZSB0byB0bXAgZmlsZTogZXJyb3IgAENhbm5vdCByZWFkIHRtcCBkYXRhIGZpbGUsIGVycm9yIABpcG1hIGJveCB3YW50cyB0byBkZWZpbmUgcHJvcGVydGllcyBmb3IgAGxheWVyIAAgSlBFRy0yMDAwIGNoYW5uZWxzLCBidXQgdGhlIHNlY3VyaXR5IGxpbWl0IGlzIHNldCB0byAAIGVudGl0aWVzLCBidXQgdGhlIHNlY3VyaXR5IGxpbWl0IGlzIHNldCB0byAAIGl0ZW1zLCBidXQgdGhlIHNlY3VyaXR5IGxpbWl0IGhhcyBiZWVuIHNldCB0byAAKHBvaW50cyB0byBmaWxlIHBvc2l0aW9uIABvcmllbnRhdGlvbiAAR3JpZCBpbWFnZSB2ZXJzaW9uIAAgYm94IGRhdGEgdmVyc2lvbiAAT3ZlcmxheSBpbWFnZSBkYXRhIHZlcnNpb24gACwgdmVyc2lvbiAAZW50aXR5IGdyb3VwIGJveCBzaG91bGQgY29udGFpbiAAaXJlZiBib3ggc2hvdWxkIGNvbnRhaW4gAGlsb2MgYm94IHNob3VsZCBjb250YWluIABpbG9jIGl0ZW0gc2hvdWxkIGNvbnRhaW4gACkgZm9yIGl0ZW0gAEltYWdlIGl0ZW0gAENhbm5vdCBtaXJyb3IgaW1hZ2VzIHdpdGggAFRpbGVkIGltYWdlIHdpdGggAEFsbG9jYXRpbmcgACBieXRlcyBleGNlZWRzIHRoZSBzZWN1cml0eSBsaW1pdCBvZiAAIGl0ZW1zLCB3aGljaCBleGNlZWRzIHRoZSBzZWN1cml0eSBsaW1pdCBvZiAAIGJ5dGVzLCBleGNlZWRpbmcgdGhlIHNlY3VyaXR5IGxpbWl0IG9mIAApIGV4Y2VlZHMgdGhlIHNlY3VyaXR5IGxpbWl0cyBvZiAAaW52YWxpZCBib3ggc2l6ZSAAQm94IHNpemUgACBleGNlZWRzIHRoZSBtYXhpbXVtIGltYWdlIHNpemUgAEltYWdlIHNpemUgAGNkZWYgYm94IHdhbnRzIHRvIGRlZmluZSAAajJrTCBib3ggd2FudHMgdG8gZGVmaW5lIABObyBhdXhDIHByb3BlcnR5IGZvciBpbWFnZSAAIGJ5dGVzLCB0b3RhbCBtZW1vcnkgc2l6ZSB3b3VsZCBiZSAASXRlbSBjb25zdHJ1Y3Rpb24gbWV0aG9kIABpZGF0IGJveCBjb250YWluZWQgAGlsb2MgYm94IGNvbnRhaW5lZCAAIGV4dGVudHMsIGJ1dCB3ZSBjYW4gb25seSByZWFkIAAgaXRlbXMsIGJ1dCB3ZSBjYW4gb25seSByZWFkIAAgZW50aXRpZXMsIGJ1dCB3ZSBjYW4gb25seSByZWFkIAAgcmVmZXJlbmNlcywgYnV0IHdlIGNhbiBvbmx5IHJlYWQgAColZCAAKiVkJWMgAEl0ZW0gd2l0aCBJRCAAIDsgAHByb2ZpbGVfY29tcGF0aWJpbGl0eTogAGZhdGFsaXR5OiAAaW5pdGlhbF9wcmVzZW50YXRpb25fZGVsYXk6IABhbWJpZW50X2xpZ2h0X3k6IABjaHJvbWFfc3Vic2FtcGxpbmdfeTogAEJveDogAGNvbXBvbmVudF9pbmRleDogAGl0ZW1fcHJvdGVjdGlvbl9pbmRleDogAGNoYW5uZWxfaW5kZXg6IAAgIGRhdGFfcmVmZXJlbmNlX2luZGV4OiAAb2xzLWluZGV4OiAAb3AtaW5kZXg6IABwcm9wZXJ0eSBpbmRleDogAGFtYmllbnRfbGlnaHRfeDogAGNocm9tYV9zdWJzYW1wbGluZ194OiAAc2tldzogAHByaW5jaXBhbC1wb2ludDogAHR3ZWx2ZV9iaXQ6IABtYXggcGljdHVyZSBoZWlnaHQ6IABpbWFnZSBoZWlnaHQ6IAAgIGJhc2Vfb2Zmc2V0OiAAY2hyb21hX2Zvcm1hdDogAGNocm9tYS1mb3JtYXQ6IABDaHJvbWEgZm9ybWF0OiAAbnVtIG9mIGFycmF5czogACAgZXh0ZW50czogAG1hdHJpeF9jb2VmZmljaWVudHM6IABhcnJheV9jb21wbGV0ZW5lc3M6IABhcnJheSBjb21wbGV0ZW5lc3M6IABudW0gc3VibGF5ZXJzOiAAbnVtX3RlbXBvcmFsX2xheWVyczogACwgZGVjb2RlX2xheWVyczogACwgZGlzY2FyZF9sZXZlbHM6IAB0YWdzOiAAICAlc19wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3M6IABnZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnczogAGdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3M6IABudW0gYnl0ZXM6IABudW1iZXIgb2YgZGF0YSBieXRlczogAGF1eCBzdWJ0eXBlczogAHwgdGlsZXM6IABjb2xvdXJfcHJpbWFyaWVzOiAAdGlsZSByb3cgYm91bmRhcmllczogAHRpbGUgY29sdW1uIGJvdW5kYXJpZXM6IABjb21wYXRpYmxlIGJyYW5kczogAHRyYW5zZmVyX2NoYXJhY3RlcmlzdGljczogAGVudGl0eSBJRHM6IAAgdG8gSURzOiAALCBwYWxldHRlX2NvbG91cjogACcgcGFyc2UgZXJyb3I6IABkZXNjcmlwdGlvbjogAGNocm9tYV9zYW1wbGVfcG9zaXRpb246IABtaXJyb3IgZGlyZWN0aW9uOiAAcm90YXRpb246IABhbWJpZW50X2lsbHVtaW5hdGlvbjogACwgY2hhbm5lbF9hc3NvY2lhdGlvbjogAGxvY2F0aW9uOiAAQVZDTGV2ZWxJbmRpY2F0aW9uOiAAQVZDUHJvZmlsZUluZGljYXRpb246IABjb25maWd1cmF0aW9uX3ZlcnNpb246IABtaW5vciB2ZXJzaW9uOiAAaGlkZGVuIGl0ZW06IABiaXRzX3Blcl9waXhlbDogAG1heF9jb250ZW50X2xpZ2h0X2xldmVsOiAAbWF4X3BpY19hdmVyYWdlX2xpZ2h0X2xldmVsOiAAYml0c19wZXJfY2hhbm5lbDogACAoZXNzZW50aWFsOiAAaGlnaF9iaXRkZXB0aDogAGJpdC1kZXB0aDogAGZvY2FsLWxlbmd0aDogAGltYWdlIHdpZHRoOiAAICBwaXRjaDogAHwgYmlubmluZzogAGNvbnRlbnRfZW5jb2Rpbmc6IAB2U3BhY2luZzogAGhTcGFjaW5nOiAAbGFuZzogAGdlbmVyYWxfdGllcl9mbGFnOiAAZnVsbF9yYW5nZV9mbGFnOiAAcHRsIGZyYW1lIG9ubHkgY29uc3RyYWludCBmbGFnOiAAdGllciBmbGFnOiAAcHRsIG11bHRpIGxheWVyIGVuYWJsZWQgZmxhZzogAGxlbmd0aF9zaXplOiAAICAgKGhlYWRlciBzaXplOiAATkFMIGxlbmd0aCBzaXplOiAAdGlsZSBzaXplOiAAcHJvZmlsZSBzaXplOiAAdW5oYW5kbGVkIGV4dGVuZGVkIGNhcGFiaWxpdGllcyB2YWx1ZTogAGNvbnN0YW50X2ZyYW1lX3JhdGU6IABhdmdfZnJhbWVfcmF0ZTogAGNvbnN0YW50IGZyYW1lIHJhdGU6IABjbGVhbl9hcGVydHVyZTogAGNvbnRlbnRfdHlwZTogAE5BTF91bml0X3R5cGU6IABjb2xvdXJfdHlwZTogAGhhbmRsZXJfdHlwZTogAHBhcmFsbGVsaXNtX3R5cGU6IABpdGVtX3R5cGU6IAAsIGNoYW5uZWxfdHlwZTogACwgbWFwcGluZ190eXBlOiAAYXV4IHR5cGU6IABpdGVtIHVyaSB0eXBlOiAATkFMIHR5cGU6IABtb25vY2hyb21lOiAAaXRlbV9uYW1lOiAAc2VxX3Byb2ZpbGU6IABnZW5lcmFsIHByb2ZpbGU6IABFcnJvciBvcGVuaW5nIGZpbGU6IABtYXggZGlzcGxheSBtYXN0ZXJpbmcgbHVtaW5hbmNlOiAAbWluIGRpc3BsYXkgbWFzdGVyaW5nIGx1bWluYW5jZTogAGdlbmVyYWxfcHJvZmlsZV9zcGFjZTogACAgY29uc3RydWN0aW9uIG1ldGhvZDogAG1ham9yIGJyYW5kOiAAbGF5ZXJfaWQ6IABncm91cCBpZDogAHdvcmxkIGNvb3JkaW5hdGUgc3lzdGVtIGlkOiAAdGVtcG9yYWxfaWRfbmVzdGVkOiAAcHJlX2RlZmluZWQ6IABtaW5fc3BhdGlhbF9zZWdtZW50YXRpb25faWRjOiAAZ2VuZXJhbF9sZXZlbF9pZGM6IABnZW5lcmFsX3Byb2ZpbGVfaWRjOiAAZGF0YTogAGJpdF9kZXB0aF9sdW1hOiAAQml0IGRlcHRoIGx1bWE6IABiaXRfZGVwdGhfY2hyb21hOiAAQml0IGRlcHRoIGNocm9tYTogAHJlZl9waWNfc2V0WyAlMmQgXTogAFNQUy1FWFQ6IABTUFM6IABQUFM6IABFUlI6IABJTkZPOiAATkU6IABpdGVtX0lEOiAAIGZyb20gSUQ6IABhc3NvY2lhdGlvbnMgZm9yIGl0ZW0gSUQ6IAByaWdodCBpbWFnZSBJRDogAGxlZnQgaW1hZ2UgSUQ6IAAsIE5QQzogACwgQjogAHNlcV9sZXZlbF9pZHhfMDogAGRpc3BsYXlfcHJpbWFyaWVzICh4LHkpOiAAY2FtZXJhIHBvc2l0aW9uICh1bSk6IAApIDogACksIAAgIHJvbGw6ICAAbWF4IHBpY3R1cmUgd2lkdGg6ICAAICB5YXc6ICAgACAgICAgIABubyBza2V3CgAgcmVmZXJlbmNlZCwgYnV0IGl0IGRvZXMgbm90IGV4aXN0CgBub3QgcHJlc2VudAoAU1BTIGVycm9yOiBDQiBhbGlnbm1lbnQKACVwIGluaXQKAColcwoAc2xpY2VfZGVibG9ja2luZ19maWx0ZXJfZGlzYWJsZWRfZmxhZyA6ICVkICVzCgBudW1fcmVmX2lkeF9sMV9hY3RpdmUgICAgICAgICAgOiAlZCAlcwoAbnVtX3JlZl9pZHhfbDBfYWN0aXZlICAgICAgICAgIDogJWQgJXMKACAgJXNfcHJvZmlsZV9pZGMgICAgICAgOiAlcwoAICB2aWRlb19mb3JtYXQgICAgICAgICAgICAgICAgOiAlcwoAJXAgZGVzdHJ1Y3RvcgoAJXAgcmVsZWFzZSAlcAoAbWZyZWUgJXAKACVwIGMndG9yID0gJXAKACVwIGFzc2lnbiA9ICVwCgBob3Jpem9udGFsCgBmYXRhbAoAb3B0aW9uYWwKAHZlcnRpY2FsCgBTUFMgZXJyb3I6IHRyYW5zZm9ybSBoaWVyYXJjaHkgZGVwdGggKGludGVyKSA+IENUQiBzaXplIC0gbWluIFRCIHNpemUKAFNQUyBlcnJvcjogdHJhbnNmb3JtIGhpZXJhcmNoeSBkZXB0aCAoaW50cmEpID4gQ1RCIHNpemUgLSBtaW4gVEIgc2l6ZQoAbm8gY29sb3IgcHJvZmlsZQoAaWdub3JhYmxlCgBudW1iZXIgb2YgZGF0YSBieXRlcyBpcyBpbnZhbGlkCgB1bnN1cHBvcnRlZAoAaW52YWxpZCBTUFMgcmVmZXJlbmNlZAoAaW52YWxpZCBQUFMgcmVmZXJlbmNlZAoAUFBTICVkIGhhcyBub3QgYmVlbiByZWFkCgBzYW1wbGUgYXNwZWN0IHJhdGlvICAgICAgICA6ICVkOiVkCgBMYXllciAlZAoAdnBzX251bV9sYXllcl9zZXRzID0gJWQKAHZwc19udW1fdW5pdHNfaW5fdGljayA9ICVkCgBsYXllciAlZDogdnBzX21heF9kZWNfcGljX2J1ZmZlcmluZyA9ICVkCgBsYXllciAoYWxsKTogdnBzX21heF9kZWNfcGljX2J1ZmZlcmluZyA9ICVkCgB2cHNfdGltaW5nX2luZm9fcHJlc2VudF9mbGFnID0gJWQKAHZwc19leHRlbnNpb25fZmxhZyA9ICVkCgB2cHNfcG9jX3Byb3BvcnRpb25hbF90b190aW1pbmdfZmxhZyA9ICVkCgB2cHNfbnVtX3RpY2tzX3BvY19kaWZmX29uZSA9ICVkCgBocmRfbGF5ZXJfc2V0X2lkeFslZF0gPSAlZAoAbGF5ZXJfaWRfaW5jbHVkZWRfZmxhZ1slZF1bJWRdID0gJWQKACAgICAgICAgICAgICB2cHNfbWF4X251bV9yZW9yZGVyX3BpY3MgID0gJWQKACAgICAgICAgICAgICB2cHNfbWF4X2xhdGVuY3lfaW5jcmVhc2UgID0gJWQKAHZwc19tYXhfbGF5ZXJfaWQgICA9ICVkCgB2cHNfbnVtX2hyZF9wYXJhbWV0ZXJzICAgICA9ICVkCgB2cHNfdGltZV9zY2FsZSAgICAgICAgPSAlZAoAY29uZl93aW5fYm90dG9tX29mZnNldDogJWQKAGNocm9tYV9sb2NfaW5mb19wcmVzZW50X2ZsYWc6ICVkCgBsaXN0c19tb2RpZmljYXRpb25fcHJlc2VudF9mbGFnOiAlZAoAZGVibG9ja2luZ19maWx0ZXJfY29udHJvbF9wcmVzZW50X2ZsYWc6ICVkCgB2aWRlb19zaWduYWxfdHlwZV9wcmVzZW50X2ZsYWc6ICVkCgBwaWNfc2NhbGluZ19saXN0X2RhdGFfcHJlc2VudF9mbGFnOiAlZAoAcGljX2Rpc2FibGVfZGVibG9ja2luZ19maWx0ZXJfZmxhZzogJWQKAG5ldXRyYWxfY2hyb21hX2luZGljYXRpb25fZmxhZzogJWQKAHVuaWZvcm1fc3BhY2luZ19mbGFnOiAlZAoAdHJhbnNxdWFudF9ieXBhc3NfZW5hYmxlX2ZsYWc6ICVkCgBjb25zdHJhaW5lZF9pbnRyYV9wcmVkX2ZsYWc6ICVkCgBwcHNfbG9vcF9maWx0ZXJfYWNyb3NzX3NsaWNlc19lbmFibGVkX2ZsYWc6ICVkCgB0cmFuc2Zvcm1fc2tpcF9lbmFibGVkX2ZsYWc6ICVkCgBkZWJsb2NraW5nX2ZpbHRlcl9vdmVycmlkZV9lbmFibGVkX2ZsYWc6ICVkCgBlbnRyb3B5X2NvZGluZ19zeW5jX2VuYWJsZWRfZmxhZzogJWQKACAgY2hyb21hX3NhbXBsZV9sb2NfdHlwZV9ib3R0b21fZmllbGQ6ICVkCgAgICVkOiAlZAoAY29uZl93aW5fcmlnaHRfb2Zmc2V0IDogJWQKAG51bV9zaG9ydF90ZXJtX3JlZl9waWNfc2V0cyA6ICVkCgBudW1fbG9uZ190ZXJtX3JlZl9waWNzX3NwcyA6ICVkCgBwaWNfaGVpZ2h0X2luX2x1bWFfc2FtcGxlcyA6ICVkCgBtYXhfdHJhbnNmb3JtX2hpZXJhcmNoeV9kZXB0aF9pbnRlciA6ICVkCgAgICAgJXNfZnJhbWVfb25seV9jb25zdHJhaW50X2ZsYWcgOiAlZAoAICAgICVzX25vbl9wYWNrZWRfY29uc3RyYWludF9mbGFnIDogJWQKAHBwc19zbGljZV9jaHJvbWFfcXBfb2Zmc2V0c19wcmVzZW50X2ZsYWcgOiAlZAoAdnVpX2hyZF9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZyA6ICVkCgBsb25nX3Rlcm1fcmVmX3BpY3NfcHJlc2VudF9mbGFnIDogJWQKAG92ZXJzY2FuX2luZm9fcHJlc2VudF9mbGFnIDogJWQKAHZwc19zdWJfbGF5ZXJfb3JkZXJpbmdfaW5mb19wcmVzZW50X2ZsYWcgOiAlZAoAc3BzX3N1Yl9sYXllcl9vcmRlcmluZ19pbmZvX3ByZXNlbnRfZmxhZyA6ICVkCgBmcmFtZV9maWVsZF9pbmZvX3ByZXNlbnRfZmxhZyA6ICVkCgAgIGNvbG91cl9kZXNjcmlwdGlvbl9wcmVzZW50X2ZsYWcgOiAlZAoAc2xpY2Vfc2VnbWVudF9oZWFkZXJfZXh0ZW5zaW9uX3ByZXNlbnRfZmxhZyA6ICVkCgBzcHNfc2NhbGluZ19saXN0X2RhdGFfcHJlc2VudF9mbGFnIDogJWQKACAgbW90aW9uX3ZlY3RvcnNfb3Zlcl9waWNfYm91bmRhcmllc19mbGFnIDogJWQKAHNwc19tdWx0aWxheWVyX2V4dGVuc2lvbl9mbGFnIDogJWQKAHBwc19tdWx0aWxheWVyX2V4dGVuc2lvbl9mbGFnIDogJWQKAHNwc190ZW1wb3JhbF9pZF9uZXN0aW5nX2ZsYWcgOiAlZAoAdnVpX3BvY19wcm9wb3J0aW9uYWxfdG9fdGltaW5nX2ZsYWcgOiAlZAoAc2VwYXJhdGVfY29sb3VyX3BsYW5lX2ZsYWcgOiAlZAoAc2NhbGluZ19saXN0X2VuYWJsZV9mbGFnIDogJWQKAHN0cm9uZ19pbnRyYV9zbW9vdGhpbmdfZW5hYmxlX2ZsYWcgOiAlZAoAZGVibG9ja2luZ19maWx0ZXJfb3ZlcnJpZGVfZmxhZyA6ICVkCgBudW1fcmVmX2lkeF9hY3RpdmVfb3ZlcnJpZGVfZmxhZyA6ICVkCgAgICAgJXNfcHJvZ3Jlc3NpdmVfc291cmNlX2ZsYWcgOiAlZAoAICAgICVzX2ludGVybGFjZWRfc291cmNlX2ZsYWcgOiAlZAoAc2FtcGxlX2FkYXB0aXZlX29mZnNldF9lbmFibGVkX2ZsYWcgOiAlZAoAZGVwZW5kZW50X3NsaWNlX3NlZ21lbnRzX2VuYWJsZWRfZmxhZyA6ICVkCgBsb29wX2ZpbHRlcl9hY3Jvc3NfdGlsZXNfZW5hYmxlZF9mbGFnIDogJWQKAHNsaWNlX2xvb3BfZmlsdGVyX2Fjcm9zc19zbGljZXNfZW5hYmxlZF9mbGFnIDogJWQKAHNsaWNlX3RlbXBvcmFsX212cF9lbmFibGVkX2ZsYWcgOiAlZAoAY3Jvc3NfY29tcG9uZW50X3ByZWRpY3Rpb25fZW5hYmxlZF9mbGFnIDogJWQKAHBlcnNpc3RlbnRfcmljZV9hZGFwdGF0aW9uX2VuYWJsZWRfZmxhZyA6ICVkCgBsb2cyX2RpZmZfbWF4X21pbl90cmFuc2Zvcm1fYmxvY2tfc2l6ZSA6ICVkCgBsb2cyX2RpZmZfbWF4X21pbl9sdW1hX2NvZGluZ19ibG9ja19zaXplIDogJWQKAGxvZzJfbWluX2x1bWFfY29kaW5nX2Jsb2NrX3NpemUgOiAlZAoAbG9nMl9kaWZmX21heF9taW5fcGNtX2x1bWFfY29kaW5nX2Jsb2NrX3NpemUgOiAlZAoAbG9nMl9taW5fcGNtX2x1bWFfY29kaW5nX2Jsb2NrX3NpemUgOiAlZAoAbnVtX3JlZl9pZHhfbDFfZGVmYXVsdF9hY3RpdmUgOiAlZAoAbnVtX3JlZl9pZHhfbDBfZGVmYXVsdF9hY3RpdmUgOiAlZAoAbG9nMl9tYXhfcGljX29yZGVyX2NudF9sc2IgOiAlZAoAbWF4X3RyYW5zZm9ybV9oaWVyYXJjaHlfZGVwdGhfaW50cmEgOiAlZAoAYml0X2RlcHRoX2Nocm9tYSA6ICVkCgBlbnRyeSBwb2ludCBbJWldIDogJWQKACAgc3BzX21heF9sYXRlbmN5X2luY3JlYXNlX3BsdXMxIDogJWQKAHJlZl9waWNfbGlzdF9tb2RpZmljYXRpb25fZmxhZ19sMSA6ICVkCgByZWZfcGljX2xpc3RfbW9kaWZpY2F0aW9uX2ZsYWdfbDAgOiAlZAoATG9nMk1pbkN1Q2hyb21hUXBPZmZzZXRTaXplIChSRXh0KSA6ICVkCgBMb2cyTWF4VHJhbnNmb3JtU2tpcFNpemUgICAgKFJFeHQpIDogJWQKAGNvbmZfd2luX2xlZnRfb2Zmc2V0ICA6ICVkCgAgIGRlZl9kaXNwX3dpbl9ib3R0b21fb2Zmc2V0ICA6ICVkCgBzbGljZV9iZXRhX29mZnNldCAgOiAlZAoAcGljX3dpZHRoX2luX2x1bWFfc2FtcGxlcyAgOiAlZAoAdnVpX3RpbWluZ19pbmZvX3ByZXNlbnRfZmxhZyAgOiAlZAoAb3ZlcnNjYW5fYXBwcm9wcmlhdGVfZmxhZyAgOiAlZAoAcGNtX2xvb3BfZmlsdGVyX2Rpc2FibGVfZmxhZyAgOiAlZAoAZml2ZV9taW51c19tYXhfbnVtX21lcmdlX2NhbmQgIDogJWQKAHZpZGVvX3BhcmFtZXRlcl9zZXRfaWQgIDogJWQKACAgZGVmX2Rpc3Bfd2luX3JpZ2h0X29mZnNldCAgIDogJWQKAGNvbmZfd2luX3RvcF9vZmZzZXQgICA6ICVkCgBkZWZhdWx0X2Rpc3BsYXlfd2luZG93X2ZsYWcgICA6ICVkCgBjdV9xcF9kZWx0YV9lbmFibGVkX2ZsYWcgICA6ICVkCgBsb2cyX21pbl90cmFuc2Zvcm1fYmxvY2tfc2l6ZSAgIDogJWQKACAgY2hyb21hX3NhbXBsZV9sb2NfdHlwZV90b3BfZmllbGQgICA6ICVkCgBiaXRfZGVwdGhfbHVtYSAgIDogJWQKAHBjbV9zYW1wbGVfYml0X2RlcHRoX2Nocm9tYSAgIDogJWQKAE1heENiU2l6ZVkgICA6ICVkCgBNaW5DYlNpemVZICAgOiAlZAoATWF4VEJTaXplWSAgIDogJWQKAE1pblRCU2l6ZVkgICA6ICVkCgAgIGRlZl9kaXNwX3dpbl9sZWZ0X29mZnNldCAgICA6ICVkCgBzbGljZV90Y19vZmZzZXQgICAgOiAlZAoAbnVtX2V4dHJhX3NsaWNlX2hlYWRlcl9iaXRzICAgIDogJWQKAG51bV9lbnRyeV9wb2ludF9vZmZzZXRzICAgIDogJWQKAG51bV90aWxlX2NvbHVtbnMgICAgOiAlZAoAICB0cmFuc2Zlcl9jaGFyYWN0ZXJpc3RpY3MgICAgOiAlZAoAICBsb2cyX21heF9tdl9sZW5ndGhfaG9yaXpvbnRhbCAgICA6ICVkCgBjb25mb3JtYW5jZV93aW5kb3dfZmxhZyAgICA6ICVkCgBjYWJhY19pbml0X3ByZXNlbnRfZmxhZyAgICA6ICVkCgBzcHNfZXh0ZW5zaW9uX3ByZXNlbnRfZmxhZyAgICA6ICVkCgAgIHJlc3RyaWN0ZWRfcmVmX3BpY19saXN0c19mbGFnICAgIDogJWQKAHRyYW5zZm9ybV9za2lwX3JvdGF0aW9uX2VuYWJsZWRfZmxhZyAgICA6ICVkCgBzZXFfcGFyYW1ldGVyX3NldF9pZCAgICA6ICVkCgBzbGljZV9jcl9xcF9vZmZzZXQgICAgIDogJWQKAHNsaWNlX2NiX3FwX29mZnNldCAgICAgOiAlZAoAICBkZWZfZGlzcF93aW5fdG9wX29mZnNldCAgICAgOiAlZAoAZGlmZl9jdV9xcF9kZWx0YV9kZXB0aCAgICAgOiAlZAoAb3V0cHV0X2ZsYWdfcHJlc2VudF9mbGFnICAgICA6ICVkCgB0cmFuc2Zvcm1fc2tpcF9jb250ZXh0X2VuYWJsZWRfZmxhZyAgICAgOiAlZAoAY2FiYWNfYnlwYXNzX2FsaWdubWVudF9lbmFibGVkX2ZsYWcgICAgIDogJWQKAGhpZ2hfcHJlY2lzaW9uX29mZnNldHNfZW5hYmxlZF9mbGFnICAgICA6ICVkCgAgICVzX3Byb2ZpbGVfc3BhY2UgICAgIDogJWQKACAgbWluX3NwYXRpYWxfc2VnbWVudGF0aW9uX2lkYyAgICAgOiAlZAoAcGNtX3NhbXBsZV9iaXRfZGVwdGhfbHVtYSAgICAgOiAlZAoAQ3RiU2l6ZVkgICAgIDogJWQKAHNwc19tYXhfc3ViX2xheWVycyAgICAgIDogJWQKAGxvZzJfcGFyYWxsZWxfbWVyZ2VfbGV2ZWwgICAgICA6ICVkCgAgIGxvZzJfbWF4X212X2xlbmd0aF92ZXJ0aWNhbCAgICAgIDogJWQKACAgc3BzX21heF9kZWNfcGljX2J1ZmZlcmluZyAgICAgIDogJWQKAHNob3J0X3Rlcm1fcmVmX3BpY19zZXRfc3BzX2ZsYWcgICAgICA6ICVkCgBzcHNfcmFuZ2VfZXh0ZW5zaW9uX2ZsYWcgICAgICA6ICVkCgBwcHNfcmFuZ2VfZXh0ZW5zaW9uX2ZsYWcgICAgICA6ICVkCgBleHRlbmRlZF9wcmVjaXNpb25fcHJvY2Vzc2luZ19mbGFnICAgICAgOiAlZAoAc2lnbl9kYXRhX2hpZGluZ19mbGFnICAgICAgOiAlZAoAY2hyb21hX3FwX29mZnNldF9saXN0X2VuYWJsZWRfZmxhZyAgICAgIDogJWQKAHNwc190ZW1wb3JhbF9tdnBfZW5hYmxlZF9mbGFnICAgICAgOiAlZAoAZmlyc3Rfc2xpY2Vfc2VnbWVudF9pbl9waWNfZmxhZyAgICAgIDogJWQKAGxvZzJfbWF4X3RyYW5zZm9ybV9za2lwX2Jsb2NrX3NpemUgICAgICA6ICVkCgBudW1fdGlsZV9yb3dzICAgICAgIDogJWQKACAgc3BzX21heF9udW1fcmVvcmRlcl9waWNzICAgICAgIDogJWQKACAgdnVpX251bV91bml0c19pbl90aWNrICAgICAgIDogJWQKACAgdGlsZXNfZml4ZWRfc3RydWN0dXJlX2ZsYWcgICAgICAgOiAlZAoAICB2aWRlb19mdWxsX3JhbmdlX2ZsYWcgICAgICAgOiAlZAoAc2VxX3BhcmFtZXRlcl9zZXRfaWQgICAgICAgOiAlZAoAcGljX3BhcmFtZXRlcl9zZXRfaWQgICAgICAgOiAlZAoAICBtYXhfYml0c19wZXJfbWluX2N1X2Rlbm9tICAgICAgICA6ICVkCgB2dWlfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWcgICAgICAgIDogJWQKAGNvbGxvY2F0ZWRfZnJvbV9sMF9mbGFnICAgICAgICA6ICVkCgBDaHJvbWFXZWlnaHRfTCVkWyVkXVslZF0gICAgICAgIDogJWQKAENocm9tYU9mZnNldF9MJWRbJWRdWyVkXSAgICAgICAgOiAlZAoAUGljSGVpZ2h0SW5DdGJzWSAgICAgICAgOiAlZAoAbHVtYV9sb2cyX3dlaWdodF9kZW5vbSAgICAgICAgIDogJWQKAGRlcGVuZGVudF9zbGljZV9zZWdtZW50X2ZsYWcgICAgICAgICA6ICVkCgBub19vdXRwdXRfb2ZfcHJpb3JfcGljc19mbGFnICAgICAgICAgOiAlZAoAICAlc190aWVyX2ZsYWcgICAgICAgICA6ICVkCgBiaXRzdHJlYW1fcmVzdHJpY3Rpb25fZmxhZyAgICAgICAgIDogJWQKAHdlaWdodGVkX2JpcHJlZF9mbGFnICAgICAgICAgOiAlZAoAc2xpY2VfcXBfZGVsdGEgICAgICAgICA6ICVkCgBQaWNXaWR0aEluQ3Ric1kgICAgICAgICA6ICVkCgAgIG1heF9ieXRlc19wZXJfcGljX2Rlbm9tICAgICAgICAgIDogJWQKAENocm9tYUxvZzJXZWlnaHREZW5vbSAgICAgICAgICA6ICVkCgBkaWZmX2N1X2Nocm9tYV9xcF9vZmZzZXRfZGVwdGggICAgICAgICAgOiAlZAoAdnBzX3RlbXBvcmFsX2lkX25lc3RpbmdfZmxhZyAgICAgICAgICA6ICVkCgBMb2cyTWluQ3VRcERlbHRhU2l6ZSAgICAgICAgICA6ICVkCgB2dWlfbnVtX3RpY2tzX3BvY19kaWZmX29uZSAgICAgICAgICA6ICVkCgBzaG9ydF90ZXJtX3JlZl9waWNfc2V0X2lkeCAgICAgICAgICAgOiAlZAoAc3BzX2V4dGVuc2lvbl82Yml0cyAgICAgICAgICAgOiAlZAoAcHBzX2V4dGVuc2lvbl82Yml0cyAgICAgICAgICAgOiAlZAoAd2VpZ2h0ZWRfcHJlZF9mbGFnICAgICAgICAgICA6ICVkCgBpbnRyYV9zbW9vdGhpbmdfZGlzYWJsZWRfZmxhZyAgICAgICAgICAgOiAlZAoAdGlsZXNfZW5hYmxlZF9mbGFnICAgICAgICAgICA6ICVkCgBzbGljZV9zYW9fY2hyb21hX2ZsYWcgICAgICAgICAgIDogJWQKAHNsaWNlX3BpY19wYXJhbWV0ZXJfc2V0X2lkICAgICAgICAgICA6ICVkCgAgIGNvbG91cl9wcmltYXJpZXMgICAgICAgICAgICA6ICVkCgBwcHNfZXh0ZW5zaW9uX2ZsYWcgICAgICAgICAgICA6ICVkCgBsb2cyX3Nhb19vZmZzZXRfc2NhbGVfY2hyb21hICAgICAgICAgICAgOiAlZAoAbHVtYV9vZmZzZXRfbCVkWyVkXSAgICAgICAgICAgIDogJWQKAGNvbGxvY2F0ZWRfcmVmX2lkeCAgICAgICAgICAgICA6ICVkCgBwaWNfY3JfcXBfb2Zmc2V0ICAgICAgICAgICAgIDogJWQKAHBpY19jYl9xcF9vZmZzZXQgICAgICAgICAgICAgOiAlZAoAZXhwbGljaXRfcmRwY21fZW5hYmxlZF9mbGFnICAgICAgICAgICAgIDogJWQKAGltcGxpY2l0X3JkcGNtX2VuYWJsZWRfZmxhZyAgICAgICAgICAgICA6ICVkCgBzbGljZV9zYW9fbHVtYV9mbGFnICAgICAgICAgICAgIDogJWQKAEx1bWFXZWlnaHRfTCVkWyVkXSAgICAgICAgICAgICA6ICVkCgAgIHZ1aV90aW1lX3NjYWxlICAgICAgICAgICAgICA6ICVkCgBzbGljZV9waWNfb3JkZXJfY250X2xzYiAgICAgICAgICAgICAgOiAlZAoAbG9nMl9zYW9fb2Zmc2V0X3NjYWxlX2x1bWEgICAgICAgICAgICAgIDogJWQKAFN1YkhlaWdodEMgICAgICAgICAgICAgIDogJWQKACAgbWF0cml4X2NvZWZmcyAgICAgICAgICAgICAgIDogJWQKAGNocm9tYV9xcF9vZmZzZXRfbGlzdF9sZW4gICAgICAgICAgICAgICA6ICVkCgBtdmRfbDFfemVyb19mbGFnICAgICAgICAgICAgICAgOiAlZAoAU3ViV2lkdGhDICAgICAgICAgICAgICAgOiAlZAoAc2xpY2Vfc2VnbWVudF9hZGRyZXNzICAgICAgICAgICAgICAgIDogJWQKAHBpY19pbml0X3FwICAgICAgICAgICAgICAgIDogJWQKAGNhYmFjX2luaXRfZmxhZyAgICAgICAgICAgICAgICA6ICVkCgBmaWVsZF9zZXFfZmxhZyAgICAgICAgICAgICAgICA6ICVkCgB2aWRlb19wYXJhbWV0ZXJfc2V0X2lkICAgICAgICAgICAgICAgIDogJWQKAG9mZnNldF9sZW4gICAgICAgICAgICAgICAgIDogJWQKAHZwc19tYXhfc3ViX2xheWVycyAgICAgICAgICAgICAgICAgICAgOiAlZAoAYW1wX2VuYWJsZWRfZmxhZyAgICAgICAgICAgICAgICAgICAgOiAlZAoAcGNtX2VuYWJsZWRfZmxhZyAgICAgICAgICAgICAgICAgICAgOiAlZAoAY3JfcXBfb2Zmc2V0X2xpc3RbJWRdICAgICAgICAgICAgICAgICAgICA6ICVkCgBjYl9xcF9vZmZzZXRfbGlzdFslZF0gICAgICAgICAgICAgICAgICAgIDogJWQKAHBpY19vdXRwdXRfZmxhZyAgICAgICAgICAgICAgICAgICAgICA6ICVkCgBjb2xvdXJfcGxhbmVfaWQgICAgICAgICAgICAgICAgICAgICAgOiAlZAoAbnVtX2xvbmdfdGVybV9waWNzICAgICAgICAgICAgICAgICAgICAgICA6ICVkCgB2cHNfbWF4X2xheWVycyAgICAgICAgICAgICAgICAgICAgICAgIDogJWQKAG51bV9sb25nX3Rlcm1fc3BzICAgICAgICAgICAgICAgICAgICAgICAgOiAlZAoAYmV0YV9vZmZzZXQ6ICAlZAoAdGNfb2Zmc2V0OiAgICAlZAoAc2xpY2VfdHlwZSAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJWMKACAgUHJvZmlsZS9UaWVyL0xldmVsIFtMYXllciAlZF0KAFNQUyBlcnJvcjogYml0ZGVwdGggWSBub3QgaW4gWzg7MTZdCgBTUFMgZXJyb3I6IGJpdGRlcHRoIEMgbm90IGluIFs4OzE2XQoAU1BTIGVycm9yOiBUQl9tYXggPiAzMiBvciBDVEIKAFNQUyBlcnJvcjogVEIgPiBDQgoAPGFycmF5PgoAY29uZmlnIE5BTHM6CgA0OjQ6NAoANDoyOjIKADQ6MjowCgA0OjA6MAoARmlsZSBkb2VzIG5vdCBpbmNsdWRlIGFueSBzdXBwb3J0ZWQgYnJhbmRzLgoAbGliaGVpZiB3YXJuaW5nOiBoZWlmX2ltYWdlX2NyZWF0ZSgpIHVzZWQgd2l0aCBhbiBpbGxlZ2FsIGNvbG9yc3BhY2UvY2hyb21hIGNvbWJpbmF0aW9uLiBUaGlzIHdpbGwgcmV0dXJuIGFuIGVycm9yIGluIGEgZnV0dXJlIHZlcnNpb24uCgAtLS0tLS0tLS0tLS0tLS0tLSBTUFMtcmFuZ2UtZXh0ZW5zaW9uIC0tLS0tLS0tLS0tLS0tLS0tCgAtLS0tLS0tLS0tLS0tLS0tLSBWUFMgLS0tLS0tLS0tLS0tLS0tLS0KAC0tLS0tLS0tLS0tLS0tLS0tIFNQUyAtLS0tLS0tLS0tLS0tLS0tLQoALS0tLS0tLS0tLS0tLS0tLS0gUFBTIC0tLS0tLS0tLS0tLS0tLS0tCgAtLS0tLS0tLS0tLS0tLS0tLSBWVUkgLS0tLS0tLS0tLS0tLS0tLS0KAC0tLS0tLS0tLS0tLS0tLS0tIFNMSUNFIC0tLS0tLS0tLS0tLS0tLS0tCgAtLS0tLS0tLS0tIFBQUyByYW5nZS1leHRlbnNpb24gLS0tLS0tLS0tLQoAIC0tLS0tCgBjb2xvdXJfdHlwZTogLS0tCgAqCgAoYW5nbGVzKQoAY2hyb21hX2Zvcm1hdF9pZGMgICAgICAgOiAlZCAoJXMpCgAgKHNtYWxsZXIgdGhhbiBoZWFkZXIpCgAlcCBkZWNvdXBsZSAoJXApCgAocXVhdGVyaW9uKQoAICAlc19sZXZlbF9pZGMgICAgICAgICA6ICVkICglNC4yZikKAGx0X3JlZl9waWNfcG9jX2xzYl9zcHNbJWRdIDogJWQgICAodXNlZF9ieV9jdXJyX3BpY19sdF9zcHNfZmxhZz0lZCkKACVwIChhbGxvYykKACBkZWdyZWVzIChDQ1cpCgAzQm94ADlCb3hIZWFkZXIAOEJveF9pc3BlADdGdWxsQm94ADlCb3hfb3RoZXIAOUJveF9FcnJvcgA4Qm94X2Z0eXAAOEJveF9mcmVlADhCb3hfbWV0YQA4Qm94X2hkbHIAOEJveF9waXRtADhCb3hfaW5mZQA4Qm94X2lpbmYAOEJveF9pcHJwADhCb3hfaXBjbwA4Qm94X2lwbWEAOEJveF9hdXhDADhCb3hfaXJvdAA4Qm94X2ltaXIAOEJveF9jbGFwADhCb3hfaXJlZgA4Qm94X2lkYXQAOEJveF9ncnBsADE3Qm94X0VudGl0eVRvR3JvdXAAOEJveF9zdGVyADhCb3hfcHltZAA4Qm94X2RpbmYAOEJveF9kcmVmADdCb3hfdXJsADhCb3hfcGl4aQA4Qm94X3Bhc3AAOEJveF9sc2VsADhCb3hfY2xsaQA4Qm94X21kY3YAOEJveF9hbXZlADhCb3hfY21pbgA4Qm94X2NtZXgAOEJveF91ZGVzADhCb3hfaWxvYwBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUk4Qm94X21ldGFOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJOEJveF9mdHlwTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSThCb3hfZnJlZU5TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUk4Qm94X2hkbHJOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJOEJveF9waXRtTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSThCb3hfaWxvY05TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUk4Qm94X2lpbmZOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJOEJveF9pbmZlTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSThCb3hfaXBycE5TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUk4Qm94X2lwY29OU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJOEJveF9pcG1hTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSThCb3hfaXNwZU5TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUk4Qm94X2F1eENOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJOEJveF9pcm90TlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSThCb3hfaW1pck5TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUk4Qm94X2NsYXBOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJOEJveF9pcmVmTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSThCb3hfaHZjQ05TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUk4Qm94X2F2MUNOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJOEJveF92dmNDTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSThCb3hfaWRhdE5TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUk4Qm94X2dycGxOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJOEJveF9weW1kTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTE3Qm94X0VudGl0eVRvR3JvdXBOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJOEJveF9zdGVyTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSThCb3hfZGluZk5TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUk4Qm94X2RyZWZOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJN0JveF91cmxOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJOEJveF9jb2xyTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSThCb3hfcGl4aU5TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUk4Qm94X3Bhc3BOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJOEJveF9sc2VsTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSThCb3hfYTFvcE5TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUk4Qm94X2ExbHhOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJOEJveF9jbGxpTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSThCb3hfbWRjdk5TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUk4Qm94X2FtdmVOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJOEJveF9jbWluTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSThCb3hfY21leE5TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUk4Qm94X3VkZXNOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJOEJveF9qcGdDTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSThCb3hfajJrSE5TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUk4Qm94X2NkZWZOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJOEJveF9jbWFwTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSThCb3hfcGNsck5TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUk4Qm94X2oya0xOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJOEJveF9tc2tDTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSThCb3hfYXZjQ05TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUkzQm94TlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTlCb3hfb3RoZXJOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJOUJveF9FcnJvck5TXzlhbGxvY2F0b3JJUzFfRUVFRQBTdWNjZXNzADEzY29sb3JfcHJvZmlsZQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUkxNEhlaWZQaXhlbEltYWdlTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTE4Y29sb3JfcHJvZmlsZV9uY2x4TlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSThIZWlmRmlsZU5TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUkxMFJlZ2lvbkl0ZW1OU185YWxsb2NhdG9ySVMxX0VFRUUAMTBTRUlNZXNzYWdlADM2U0VJTWVzc2FnZV9kZXB0aF9yZXByZXNlbnRhdGlvbl9pbmZvADMwaGVpZl9kZXB0aF9yZXByZXNlbnRhdGlvbl9pbmZvAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTEzSW1hZ2VNZXRhZGF0YU5TXzlhbGxvY2F0b3JJUzFfRUVFRQAxNFJlZ2lvbkdlb21ldHJ5AE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTEwRmlsZUxheW91dE5TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUkyMFN0cmVhbVJlYWRlcl9pc3RyZWFtTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTE5U3RyZWFtUmVhZGVyX21lbW9yeU5TXzlhbGxvY2F0b3JJUzFfRUVFRQAAAwAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAMAAAAEAAAABgAAAAgAAAAGAAAACAAAADE3Y29sb3JfcHJvZmlsZV9yYXcAMThjb2xvcl9wcm9maWxlX25jbHgAOEJveF9jb2xyAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTE3Y29sb3JfcHJvZmlsZV9yYXdOU185YWxsb2NhdG9ySVMxX0VFRUUAAACamZk+AAAAAAAAAAA9Clc+4XqUPlK4nj5SuJ4+/tR4PnsULj4AAAAAFK6HPhSuhz4AQayzAgs0PQqXPpqZGT8AAAAAAAAAAI/CNT+amRk/7FEYP+xRGD/pJjE/MQhMPwAAgD/XozA/16MwPwBBhLQCCzRI4Ro/mpkZPgAAAAAAAAAAKVwPPpqZGT5SuB4+UrgePuF6FD7dJAY+AAAAAJqZGT6amRk+AEHctAILNFK4Hj6PwnU9AAAAAAAAAAAK16M9j8J1PSlcjz0pXI89ObRIPX9qPD0AAAAAj8J1PY/CdT0AQbS1Ags0LbKdPQrXIz8AAAAAAAAAAB+FKz8K1yM/rkchP65HIT8EVi4/fT81PwAAgD97FC4/exQuPwBBjLYCCzSuRyE/w/WoPgAAAAAAAAAAw/WoPsP1qD57FK4+exSuPvhToz4GgZU+AAAAAArXoz4K16M+AEHktgILNHsUrj43GqA+AAAAAAAAAABSuJ4+NxqgPjcaoD43GqA+UriePjcaoD6fqqo+nMSgPjcaoD4AQby3Ags0NxqgPrByqD4AAAAAAAAAAMHKoT6wcqg+sHKoPrByqD7ByqE+sHKoPjuqqj5GtrM+sHKoPgBBlLgCC8IRsHKoPgEAAAACAAAAAgAAAAEAAAABAAAAAgAAAAEAAAABAAAAMjBSZWdpb25HZW9tZXRyeV9Qb2ludAAyNFJlZ2lvbkdlb21ldHJ5X1JlY3RhbmdsZQAyMlJlZ2lvbkdlb21ldHJ5X0VsbGlwc2UAMjJSZWdpb25HZW9tZXRyeV9Qb2x5Z29uADI5UmVnaW9uR2VvbWV0cnlfUmVmZXJlbmNlZE1hc2sAMjVSZWdpb25HZW9tZXRyeV9JbmxpbmVNYXNrAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTIwUmVnaW9uR2VvbWV0cnlfUG9pbnROU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMjRSZWdpb25HZW9tZXRyeV9SZWN0YW5nbGVOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMjJSZWdpb25HZW9tZXRyeV9FbGxpcHNlTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTIyUmVnaW9uR2VvbWV0cnlfUG9seWdvbk5TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUkyOVJlZ2lvbkdlb21ldHJ5X1JlZmVyZW5jZWRNYXNrTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTI1UmVnaW9uR2VvbWV0cnlfSW5saW5lTWFza05TXzlhbGxvY2F0b3JJUzFfRUVFRQAAAGZpdmFjaWVoeGllaGlrMmpnZXBqZmFpbTFmaW0yZmltAQAAAAIAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAAWAAAAAQAAAAIAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAAAAAAAAQAAAAIAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAAEAAAAEAAAAAwAAAAcAAAAKAAAABQAAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0ljTlNfMTFjaGFyX3RyYWl0c0ljRUVOU185YWxsb2NhdG9ySWNFRUVFAHBwAGlwAFAxMmhlaWZfY29udGV4dAAxMmhlaWZfY29udGV4dAB2cHAAMTBoZWlmX2Vycm9yAHBwcHAAMjBoZWlmX2ZpbGV0eXBlX3Jlc3VsdABpcHAATjEwZW1zY3JpcHRlbjN2YWxFAHBwcABwcHBpAFAxN2hlaWZfaW1hZ2VfaGFuZGxlADE3aGVpZl9pbWFnZV9oYW5kbGUAMTVoZWlmX2NvbG9yc3BhY2UAMTFoZWlmX2Nocm9tYQBwcHBpaQAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAACgAAAFAxMGhlaWZfaW1hZ2UAMTBoZWlmX2ltYWdlADEyaGVpZl9jaGFubmVsAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWhFRQBQSzE3aGVpZl9pbWFnZV9oYW5kbGUAUEsxMGhlaWZfaW1hZ2UAMTVoZWlmX2Vycm9yX2NvZGUAMThoZWlmX3N1YmVycm9yX2NvZGUAMjNoZWlmX2NvbXByZXNzaW9uX2Zvcm1hdAAzNGhlaWZfY2hyb21hX2Rvd25zYW1wbGluZ19hbGdvcml0aG0AMzJoZWlmX2Nocm9tYV91cHNhbXBsaW5nX2FsZ29yaXRobQBQSzEyaGVpZl9jb250ZXh0AHYAdnAAcAB2cHBpAHZwcHAATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMTFIZWlmQ29udGV4dE5TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUkxN1N0cmVhbVJlYWRlcl9DQXBpTlNfOWFsbG9jYXRvcklTMV9FRUVFADE1SW1hZ2VJdGVtX0Vycm9yADdEZWNvZGVyAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTEyRGVjb2Rlcl9IRVZDTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTEyRGVjb2Rlcl9BVklGTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTExRGVjb2Rlcl9BVkNOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMTZEZWNvZGVyX0pQRUcyMDAwTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTExRGVjb2Rlcl9WVkNOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMTJEZWNvZGVyX0pQRUdOU185YWxsb2NhdG9ySVMxX0VFRUUAMTRJbWFnZUl0ZW1fSEVWQwA4Qm94X2h2Y0MATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMzZTRUlNZXNzYWdlX2RlcHRoX3JlcHJlc2VudGF0aW9uX2luZm9OU185YWxsb2NhdG9ySVMxX0VFRUUAMTJEZWNvZGVyX0hFVkMAMTRJbWFnZUl0ZW1fQVZJRgAxMkRlY29kZXJfQVZJRgA4Qm94X2F2MUMAOEJveF9hMW9wADhCb3hfYTFseAAxNEltYWdlSXRlbV9KUEVHADhCb3hfanBnQwBB4MkCC9MiAQEBAQABAQEAAQEBAAEBATEyRGVjb2Rlcl9KUEVHADE4SW1hZ2VJdGVtX0pQRUcyMDAwADE2RGVjb2Rlcl9KUEVHMjAwMAA4Qm94X2NkZWYAOEJveF9jbWFwADhCb3hfcGNscgA4Qm94X2oya0wAOEJveF9qMmtIADEzSW1hZ2VJdGVtX1ZWQwAxMURlY29kZXJfVlZDADhCb3hfdnZjQwAxM0ltYWdlSXRlbV9BVkMAOEJveF9hdmNDADExRGVjb2Rlcl9BVkMAOEJveF9tc2tDADE0SW1hZ2VJdGVtX21hc2sAOUltYWdlSXRlbQAxMUVycm9yQnVmZmVyAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTE0SW1hZ2VJdGVtX0pQRUdOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMTRJbWFnZUl0ZW1fSEVWQ05TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUkxNEltYWdlSXRlbV9BVklGTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTEzSW1hZ2VJdGVtX1ZWQ05TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUkxM0ltYWdlSXRlbV9BVkNOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMTVJbWFnZUl0ZW1fRXJyb3JOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMThJbWFnZUl0ZW1fSlBFRzIwMDBOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMTRJbWFnZUl0ZW1fbWFza05TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUkxNEltYWdlSXRlbV9HcmlkTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTE3SW1hZ2VJdGVtX092ZXJsYXlOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMTRJbWFnZUl0ZW1faWRlbk5TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUkxNUltYWdlSXRlbV9UaWxlZE5TXzlhbGxvY2F0b3JJUzFfRUVFRQAAAAAAAwAAAAAAAAAxNEltYWdlSXRlbV9HcmlkADE3SW1hZ2VJdGVtX092ZXJsYXkAMTRJbWFnZUl0ZW1faWRlbgA4Qm94X3RpbEMAMTVJbWFnZUl0ZW1fVGlsZWQATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMThPcF9SR0JfdG9fUkdCMjRfMzJOU185YWxsb2NhdG9ySVMxX0VFRUUAMjRDb2xvckNvbnZlcnNpb25PcGVyYXRpb24ATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMThPcF9SR0IyNF8zMl90b19SR0JOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMTVPcF9ZQ2JDcl90b19SR0JJdEVOU185YWxsb2NhdG9ySVMyX0VFRUUAMTVPcF9ZQ2JDcl90b19SR0JJdEUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMTVPcF9ZQ2JDcl90b19SR0JJaEVOU185YWxsb2NhdG9ySVMyX0VFRUUAMTVPcF9ZQ2JDcl90b19SR0JJaEUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMjBPcF9ZQ2JDcjQyMF90b19SR0IyNE5TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUkyME9wX1lDYkNyNDIwX3RvX1JHQjMyTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTIzT3BfWUNiQ3I0MjBfdG9fUlJHR0JCYWFOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMjVPcF9SR0JfSERSX3RvX1JSR0dCQmFhX0JFTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTIxT3BfUkdCX3RvX1JSR0dCQmFhX0JFTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTE5T3BfbW9ub190b19ZQ2JDcjQyME5TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUkxOU9wX21vbm9fdG9fUkdCMjRfMzJOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMjdPcF9SUkdHQkJhYV9zd2FwX2VuZGlhbm5lc3NOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMjVPcF9SUkdHQkJhYV9CRV90b19SR0JfSERSTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTIwT3BfUkdCMjRfMzJfdG9fWUNiQ3JOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMTVPcF9SR0JfdG9fWUNiQ3JJaEVOU185YWxsb2NhdG9ySVMyX0VFRUUAMTVPcF9SR0JfdG9fWUNiQ3JJaEUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMTVPcF9SR0JfdG9fWUNiQ3JJdEVOU185YWxsb2NhdG9ySVMyX0VFRUUAMTVPcF9SR0JfdG9fWUNiQ3JJdEUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMjdPcF9SUkdHQkJ4eF9IRFJfdG9fWUNiQ3I0MjBOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMjdPcF9SR0IyNF8zMl90b19ZQ2JDcjQ0NF9HQlJOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMTlPcF9kcm9wX2FscGhhX3BsYW5lTlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTE2T3BfdG9faGRyX3BsYW5lc05TXzlhbGxvY2F0b3JJUzFfRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUkxNk9wX3RvX3Nkcl9wbGFuZXNOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMzJPcF9ZQ2JDcjQyMF9iaWxpbmVhcl90b19ZQ2JDcjQ0NEloRU5TXzlhbGxvY2F0b3JJUzJfRUVFRQAzMk9wX1lDYkNyNDIwX2JpbGluZWFyX3RvX1lDYkNyNDQ0SWhFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTMyT3BfWUNiQ3I0MjBfYmlsaW5lYXJfdG9fWUNiQ3I0NDRJdEVOU185YWxsb2NhdG9ySVMyX0VFRUUAMzJPcF9ZQ2JDcjQyMF9iaWxpbmVhcl90b19ZQ2JDcjQ0NEl0RQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUkzMk9wX1lDYkNyNDIyX2JpbGluZWFyX3RvX1lDYkNyNDQ0SWhFTlNfOWFsbG9jYXRvcklTMl9FRUVFADMyT3BfWUNiQ3I0MjJfYmlsaW5lYXJfdG9fWUNiQ3I0NDRJaEUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMzJPcF9ZQ2JDcjQyMl9iaWxpbmVhcl90b19ZQ2JDcjQ0NEl0RU5TXzlhbGxvY2F0b3JJUzJfRUVFRQAzMk9wX1lDYkNyNDIyX2JpbGluZWFyX3RvX1lDYkNyNDQ0SXRFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTMxT3BfWUNiQ3I0NDRfdG9fWUNiQ3I0MjBfYXZlcmFnZUloRU5TXzlhbGxvY2F0b3JJUzJfRUVFRQAzMU9wX1lDYkNyNDQ0X3RvX1lDYkNyNDIwX2F2ZXJhZ2VJaEUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMzFPcF9ZQ2JDcjQ0NF90b19ZQ2JDcjQyMF9hdmVyYWdlSXRFTlNfOWFsbG9jYXRvcklTMl9FRUVFADMxT3BfWUNiQ3I0NDRfdG9fWUNiQ3I0MjBfYXZlcmFnZUl0RQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUkzMU9wX1lDYkNyNDQ0X3RvX1lDYkNyNDIyX2F2ZXJhZ2VJaEVOU185YWxsb2NhdG9ySVMyX0VFRUUAMzFPcF9ZQ2JDcjQ0NF90b19ZQ2JDcjQyMl9hdmVyYWdlSWhFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9lbXBsYWNlSTMxT3BfWUNiQ3I0NDRfdG9fWUNiQ3I0MjJfYXZlcmFnZUl0RU5TXzlhbGxvY2F0b3JJUzJfRUVFRQAzMU9wX1lDYkNyNDQ0X3RvX1lDYkNyNDIyX2F2ZXJhZ2VJdEUATlN0M19fMjIwX19zaGFyZWRfcHRyX2VtcGxhY2VJMjlPcF9BbnlfUkdCX3RvX1lDYkNyXzQyMF9TaGFycE5TXzlhbGxvY2F0b3JJUzFfRUVFRQAyN09wX1JSR0dCQnh4X0hEUl90b19ZQ2JDcjQyMAAyME9wX1JHQjI0XzMyX3RvX1lDYkNyADI3T3BfUkdCMjRfMzJfdG9fWUNiQ3I0NDRfR0JSADI5T3BfQW55X1JHQl90b19ZQ2JDcl80MjBfU2hhcnAAMjBPcF9ZQ2JDcjQyMF90b19SR0IyNAAyME9wX1lDYkNyNDIwX3RvX1JHQjMyADIzT3BfWUNiQ3I0MjBfdG9fUlJHR0JCYWEAMThPcF9SR0JfdG9fUkdCMjRfMzIAMjVPcF9SR0JfSERSX3RvX1JSR0dCQmFhX0JFADIxT3BfUkdCX3RvX1JSR0dCQmFhX0JFADI1T3BfUlJHR0JCYWFfQkVfdG9fUkdCX0hEUgAxOE9wX1JHQjI0XzMyX3RvX1JHQgAyN09wX1JSR0dCQmFhX3N3YXBfZW5kaWFubmVzcwAAAAAOAAAADwAAAAwAAAANAAAAMTlPcF9tb25vX3RvX1lDYkNyNDIwADE5T3BfbW9ub190b19SR0IyNF8zMgAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAAMTZPcF90b19oZHJfcGxhbmVzADE2T3BfdG9fc2RyX3BsYW5lcwAxOU9wX2Ryb3BfYWxwaGFfcGxhbmUAU3VjY2VzcwBBvOwCCyoBAAAAAgAAAEwAAABUAAAAVAAAAFAAAABYAAAAWAAAAMBBAADIQQAAyEEAQfDsAgthxQAAALkAAADJAAAAxQAAALkAAADJAAAAlQAAAIYAAABuAAAAmgAAAHoAAACJAAAAjAAAAMYAAACpAAAAxgAAAIsAAACNAAAAnQAAAGsAAACLAAAAfgAAAGsAAACLAAAAfgBB4O0CC6EBuAAAAJoAAACLAAAAmgAAAJoAAACaAAAAiwAAAJoAAACaAAAAuAAAAJoAAAC3AAAAPwAAAJgAAACYAAAAAAAAAG8AAACNAAAAmQAAAG8AAABeAAAAigAAALYAAACaAAAAlQAAAGsAAACnAAAAmgAAAJUAAABcAAAApwAAAJoAAACZAAAAigAAAIoAAAB8AAAAigAAAF4AAADgAAAApwAAAHoAQZDvAgvVAW4AAABu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AyAAAAAaAAAAFQAAABEAAAANAAAACQAAAAUAAAACAAAAAAAAAP7////7////9/////P////v////6////+b////g////5v///+v////v////8/////f////7/////v///wAAAAACAAAABQAAAAkAAAANAAAAEQAAABUAAAAaAAAAIAAAAAAAAAAA8P//mvn//3L8//+K/f//Hv7//3r+///F/v//AP///8X+//96/v//Hv7//4r9//9y/P//mvn//wDw//8AAAAAAAAAAAEAAAAAAAAAAgAAAAEAAAACAAAAAAAAAAMAAAABAAAAAwAAAAIAAAADAAAAAQAAAAAAAAACAAAAAAAAAAIAAAABAAAAAwAAAAAAAAADAAAAAQAAAAMAAAACAAAAAAAAAHDHAAABBQAAAgUAADMwTW90aW9uVmVjdG9yQWNjZXNzX2RlMjY1X2ltYWdlADE4TW90aW9uVmVjdG9yQWNjZXNzAAAA3BsBAFHHAAAEHAEAMMcAAGjHAEGEjwMLvQIDAAAAAwAAAAIAAAAAAAAAAwAAAAQAAAAEAAAAAAEEBQIDBAUGBggIBwcIYwAAAAAaAAAACgAAAAEAAAAAAQICAgIDBQcICgwNDxESExQVFhcXGBgZGRobGxwcHR0eHwAAAAAAGMgAAJUEAAADBQAABAUAAAUFAAAyNXRocmVhZF90YXNrX3NsaWNlX3NlZ21lbnQABBwBAPzHAAB4vAAAAAAAAFTIAACVBAAABgUAAAcFAAAIBQAAMTl0aHJlYWRfdGFza19jdGJfcm93AAAABBwBADzIAAB4vAAAAQAAAAIAAAACAAAAAQAAAAEAAAACAAAAAQAAAAEAAAChKQAAhEcAAApGAAAAAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAhAAAAIgAAACIAAAAjAAAAIwAAACQAAAAkAAAAJQBB0JEDCyYoAAAALQAAADMAAAA5AAAAQAAAAEgAAABJHQAAmkcAANsnAACCEABBhJIDC94GAQABAAwACwAKAAsAEAALACgAIQAYAAsAFAALACAACwBQACEAEgALAA8ACwBAACEAoABjAAQAAwADAAIAAgABAAAAAAABDQAAHD8AANBAAACzPgAA1UAAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0loTlNfMTFjaGFyX3RyYWl0c0loRUVOU185YWxsb2NhdG9ySWhFRUVFAADcGwEAXMkAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0l3TlNfMTFjaGFyX3RyYWl0c0l3RUVOU185YWxsb2NhdG9ySXdFRUVFAADcGwEApMkAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEc05TXzExY2hhcl90cmFpdHNJRHNFRU5TXzlhbGxvY2F0b3JJRHNFRUVFAAAA3BsBAOzJAABOU3QzX18yMTJiYXNpY19zdHJpbmdJRGlOU18xMWNoYXJfdHJhaXRzSURpRUVOU185YWxsb2NhdG9ySURpRUVFRQAAANwbAQA4ygAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJY0VFAADcGwEAhMoAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQAA3BsBAKzKAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lzRUUAANwbAQDUygAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJdEVFAADcGwEA/MoAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWlFRQAA3BsBACTLAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lqRUUAANwbAQBMywAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbEVFAADcGwEAdMsAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SW1FRQAA3BsBAJzLAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l4RUUAANwbAQDEywAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJeUVFAADcGwEA7MsAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWZFRQAA3BsBABTMAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lkRUUAANwbAQA8zABB8JgDC9cVAwAAAAQAAAAEAAAABgAAAIP5ogBETm4A/CkVANFXJwDdNPUAYtvAADyZlQBBkEMAY1H+ALveqwC3YcUAOm4kANJNQgBJBuAACeouAByS0QDrHf4AKbEcAOg+pwD1NYIARLsuAJzphAC0JnAAQX5fANaROQBTgzkAnPQ5AItfhAAo+b0A+B87AN7/lwAPmAUAES/vAApaiwBtH20Az342AAnLJwBG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cm1hdGlvbgBJbGxlZ2FsIGJ5dGUgc2VxdWVuY2UARG9tYWluIGVycm9yAFJlc3VsdCBub3QgcmVwcmVzZW50YWJsZQBOb3QgYSB0dHkAUGVybWlzc2lvbiBkZW5pZWQAT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQATm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeQBObyBzdWNoIHByb2Nlc3MARmlsZSBleGlzdHMAVmFsdWUgdG9vIGxhcmdlIGZvciBkYXRhIHR5cGUATm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UAT3V0IG9mIG1lbW9yeQBSZXNvdXJjZSBidXN5AEludGVycnVwdGVkIHN5c3RlbSBjYWxsAFJlc291cmNlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlAEludmFsaWQgc2VlawBDcm9zcy1kZXZpY2UgbGluawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0ARGlyZWN0b3J5IG5vdCBlbXB0eQBDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXIAT3BlcmF0aW9uIHRpbWVkIG91dABDb25uZWN0aW9uIHJlZnVzZWQASG9zdCBpcyBkb3duAEhvc3QgaXMgdW5yZWFjaGFibGUAQWRkcmVzcyBpbiB1c2UAQnJva2VuIHBpcGUASS9PIGVycm9yAE5vIHN1Y2ggZGV2aWNlIG9yIGFkZHJlc3MAQmxvY2sgZGV2aWNlIHJlcXVpcmVkAE5vIHN1Y2ggZGV2aWNlAE5vdCBhIGRpcmVjdG9yeQBJcyBhIGRpcmVjdG9yeQBUZXh0IGZpbGUgYnVzeQBFeGVjIGZvcm1hdCBlcnJvcgBJbnZhbGlkIGFyZ3VtZW50AEFyZ3VtZW50IGxpc3QgdG9vIGxvbmcAU3ltYm9saWMgbGluayBsb29wAEZpbGVuYW1lIHRvbyBsb25nAFRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtAE5vIGZpbGUgZGVzY3JpcHRvcnMgYXZhaWxhYmxlAEJhZCBmaWxlIGRlc2NyaXB0b3IATm8gY2hpbGQgcHJvY2VzcwBCYWQgYWRkcmVzcwBGaWxlIHRvbyBsYXJnZQBUb28gbWFueSBsaW5rcwBObyBsb2NrcyBhdmFpbGFibGUAUmVzb3VyY2UgZGVhZGxvY2sgd291bGQgb2NjdXIAU3RhdGUgbm90IHJlY292ZXJhYmxlAFByZXZpb3VzIG93bmVyIGRpZWQAT3BlcmF0aW9uIGNhbmNlbGVkAEZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZABObyBtZXNzYWdlIG9mIGRlc2lyZWQgdHlwZQBJZGVudGlmaWVyIHJlbW92ZWQARGV2aWNlIG5vdCBhIHN0cmVhbQBObyBkYXRhIGF2YWlsYWJsZQBEZXZpY2UgdGltZW91dABPdXQgb2Ygc3RyZWFtcyByZXNvdXJjZXMATGluayBoYXMgYmVlbiBzZXZlcmVkAFByb3RvY29sIGVycm9yAEJhZCBtZXNzYWdlAEZpbGUgZGVzY3JpcHRvciBpbiBiYWQgc3RhdGUATm90IGEgc29ja2V0AERlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWQATWVzc2FnZSB0b28gbGFyZ2UAUHJvdG9jb2wgd3JvbmcgdHlwZSBmb3Igc29ja2V0AFByb3RvY29sIG5vdCBhdmFpbGFibGUAUHJvdG9jb2wgbm90IHN1cHBvcnRlZABTb2NrZXQgdHlwZSBub3Qgc3VwcG9ydGVkAE5vdCBzdXBwb3J0ZWQAUHJvdG9jb2wgZmFtaWx5IG5vdCBzdXBwb3J0ZWQAQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbABBZGRyZXNzIG5vdCBhdmFpbGFibGUATmV0d29yayBpcyBkb3duAE5ldHdvcmsgdW5yZWFjaGFibGUAQ29ubmVjdGlvbiByZXNldCBieSBuZXR3b3JrAENvbm5lY3Rpb24gYWJvcnRlZABObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlAFNvY2tldCBpcyBjb25uZWN0ZWQAU29ja2V0IG5vdCBjb25uZWN0ZWQAQ2Fubm90IHNlbmQgYWZ0ZXIgc29ja2V0IHNodXRkb3duAE9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzAE9wZXJhdGlvbiBpbiBwcm9ncmVzcwBTdGFsZSBmaWxlIGhhbmRsZQBSZW1vdGUgSS9PIGVycm9yAFF1b3RhIGV4Y2VlZGVkAE5vIG1lZGl1bSBmb3VuZABXcm9uZyBtZWRpdW0gdHlwZQBNdWx0aWhvcCBhdHRlbXB0ZWQAUmVxdWlyZWQga2V5IG5vdCBhdmFpbGFibGUAS2V5IGhhcyBleHBpcmVkAEtleSBoYXMgYmVlbiByZXZva2VkAEtleSB3YXMgcmVqZWN0ZWQgYnkgc2VydmljZQBBor4DC5YBpQJbAPABtQWMBSUBgwYdA5QE/wDHAzEDCwa8AY8BfwPKBCsA2gavAEIDTgPcAQ4EFQChBg0BlAILAjgGZAK8Av8CXQPnBAsHzwLLBe8F2wXhAh4GRQKFAIICbANvBPEA8wMYBdkA2gNMBlQCewGdA70EAABRABUCuwCzA20A/wGFBC8F+QQ4AGUBRgGfALcGqAFzAlMBAEHovwMLDCEEAAAAAAAAAAAvAgBBiMADCwY1BEcEVgQAQZ7AAwsCoAQAQbLAAwsiRgVgBW4FYQYAAM8BAAAAAAAAAADJBukG+QYeBzkHSQdeBwBB4MADC0EZAAsAGRkZAAAAAAUAAAAAAAAJAAAAAAsAAAAAAAAAABkACgoZGRkDCgcAAQAJCxgAAAkGCwAACwAGGQAAABkZGQBBscEDCyEOAAAAAAAAAAAZAAsNGRkZAA0AAAIACQ4AAAAJAA4AAA4AQevBAwsBDABB98EDCxUTAAAAABMAAAAACQwAAAAAAAwAAAwAQaXCAwsBEABBscIDCxUPAAAABA8AAAAACRAAAAAAABAAABAAQd/CAwsBEgBB68IDCx4RAAAAABEAAAAACRIAAAAAABIAABIAABoAAAAaGhoAQaLDAwsOGgAAABoaGgAAAAAAAAkAQdPDAwsBFABB38MDCxUXAAAAABcAAAAACRQAAAAAABQAABQAQY3EAwsBFgBBmcQDCycVAAAAABUAAAAACRYAAAAAABYAABYAADAxMjM0NTY3ODlBQkNERUYAQeTEAwsCEQUAQYzFAwsI//////////8AQdTFAwvvFAIAAAADAAAABQAAAAcAAAALAAAADQAAABEAAAATAAAAFwAAAB0AAAAfAAAAJQAAACkAAAArAAAALwAAADUAAAA7AAAAPQAAAEMAAABHAAAASQAAAE8AAABTAAAAWQAAAGEAAABlAAAAZwAAAGsAAABtAAAAcQAAAH8AAACDAAAAiQAAAIsAAACVAAAAlwAAAJ0AAACjAAAApwAAAK0AAACzAAAAtQAAAL8AAADBAAAAxQAAAMcAAADTAAAAAQAAAAsAAAANAAAAEQAAABMAAAAXAAAAHQAAAB8AAAAlAAAAKQAAACsAAAAvAAAANQAAADsAAAA9AAAAQwAAAEcAAABJAAAATwAAAFMAAABZAAAAYQAAAGUAAABnAAAAawAAAG0AAABxAAAAeQAAAH8AAACDAAAAiQAAAIsAAACPAAAAlQAAAJcAAACdAAAAowAAAKcAAACpAAAArQAAALMAAAC1AAAAuwAAAL8AAADBAAAAxQAAAMcAAADRAAAAAAAAAOTmAAAUBQAAFQUAABYFAAAXBQAAGAUAABkFAAAaBQAAGwUAABwFAAAdBQAAHgUAAB8FAAAgBQAAIQUAAAgAAAAAAAAAHOcAACIFAAAjBQAA+P////j///8c5wAAJAUAACUFAACc5AAAsOQAAAQAAAAAAAAAZOcAACYFAAAnBQAA/P////z///9k5wAAKAUAACkFAADM5AAA4OQAAAwAAAAAAAAA/OcAACoFAAArBQAABAAAAPj////85wAALAUAAC0FAAD0////9P////znAAAuBQAALwUAAPzkAACI5wAAnOcAALDnAADE5wAAJOUAABDlAAAAAAAAmOgAADAFAAAxBQAAMgUAADMFAAA0BQAANQUAADYFAAA3BQAAOAUAADkFAAA6BQAAOwUAADwFAAA9BQAACAAAAAAAAADQ6AAAPgUAAD8FAAD4////+P///9DoAABABQAAQQUAAJTlAACo5QAABAAAAAAAAAAY6QAAQgUAAEMFAAD8/////P///xjpAABEBQAARQUAAMTlAADY5QAAAAAAAHTpAABGBQAARwUAABYFAAAXBQAASAUAAEkFAAAaBQAAGwUAABwFAABKBQAAHgUAAEsFAAAgBQAATAUAAAAAAADg7AAATQUAAE4FAABPBQAAUAUAAFEFAABSBQAAUwUAABsFAAAcBQAAVAUAAB4FAABVBQAAIAUAAFYFAAAAAAAApOYAAFcFAABYBQAATlN0M19fMjliYXNpY19pb3NJY05TXzExY2hhcl90cmFpdHNJY0VFRUUAAAAEHAEAeOYAABDtAABOU3QzX18yMTViYXNpY19zdHJlYW1idWZJY05TXzExY2hhcl90cmFpdHNJY0VFRUUAAAAA3BsBALDmAABOU3QzX18yMTNiYXNpY19pc3RyZWFtSWNOU18xMWNoYXJfdHJhaXRzSWNFRUVFAABgHAEA7OYAAAAAAAABAAAApOYAAAP0//9OU3QzX18yMTNiYXNpY19vc3RyZWFtSWNOU18xMWNoYXJfdHJhaXRzSWNFRUVFAABgHAEANOcAAAAAAAABAAAApOYAAAP0//8MAAAAAAAAABznAAAiBQAAIwUAAPT////0////HOcAACQFAAAlBQAABAAAAAAAAABk5wAAJgUAACcFAAD8/////P///2TnAAAoBQAAKQUAAE5TdDNfXzIxNGJhc2ljX2lvc3RyZWFtSWNOU18xMWNoYXJfdHJhaXRzSWNFRUVFAGAcAQDM5wAAAwAAAAIAAAAc5wAAAgAAAGTnAAACCAAAAAAAAFjoAABZBQAAWgUAAE5TdDNfXzI5YmFzaWNfaW9zSXdOU18xMWNoYXJfdHJhaXRzSXdFRUVFAAAABBwBACzoAAAQ7QAATlN0M19fMjE1YmFzaWNfc3RyZWFtYnVmSXdOU18xMWNoYXJfdHJhaXRzSXdFRUVFAAAAANwbAQBk6AAATlN0M19fMjEzYmFzaWNfaXN0cmVhbUl3TlNfMTFjaGFyX3RyYWl0c0l3RUVFRQAAYBwBAKDoAAAAAAAAAQAAAFjoAAAD9P//TlN0M19fMjEzYmFzaWNfb3N0cmVhbUl3TlNfMTFjaGFyX3RyYWl0c0l3RUVFRQAAYBwBAOjoAAAAAAAAAQAAAFjoAAAD9P//TlN0M19fMjE1YmFzaWNfc3RyaW5nYnVmSWNOU18xMWNoYXJfdHJhaXRzSWNFRU5TXzlhbGxvY2F0b3JJY0VFRUUAAAAEHAEAMOkAAOTmAABAAAAAAAAAALjqAABbBQAAXAUAADgAAAD4////uOoAAF0FAABeBQAAwP///8D///+46gAAXwUAAGAFAACM6QAA8OkAACzqAABA6gAAVOoAAGjqAAAY6gAABOoAALTpAACg6QAAQAAAAAAAAAD85wAAKgUAACsFAAA4AAAA+P////znAAAsBQAALQUAAMD////A/////OcAAC4FAAAvBQAAQAAAAAAAAAAc5wAAIgUAACMFAADA////wP///xznAAAkBQAAJQUAADgAAAAAAAAAZOcAACYFAAAnBQAAyP///8j///9k5wAAKAUAACkFAABOU3QzX18yMThiYXNpY19zdHJpbmdzdHJlYW1JY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQAAAAAEHAEAcOoAAPznAAA4AAAAAAAAAGzrAABhBQAAYgUAAMj////I////bOsAAGMFAABkBQAA0OoAAAjrAAAc6wAA5OoAADgAAAAAAAAAZOcAACYFAAAnBQAAyP///8j///9k5wAAKAUAACkFAABOU3QzX18yMTliYXNpY19vc3RyaW5nc3RyZWFtSWNOU18xMWNoYXJfdHJhaXRzSWNFRU5TXzlhbGxvY2F0b3JJY0VFRUUAAAAEHAEAJOsAAGTnAABsAAAAAAAAAAjsAABlBQAAZgUAAJT///+U////COwAAGcFAABoBQAAhOsAALzrAADQ6wAAmOsAAGwAAAAAAAAAHOcAACIFAAAjBQAAlP///5T///8c5wAAJAUAACUFAABOU3QzX18yMTRiYXNpY19pZnN0cmVhbUljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRQAEHAEA2OsAABznAABoAAAAAAAAAKTsAABpBQAAagUAAJj///+Y////pOwAAGsFAABsBQAAIOwAAFjsAABs7AAANOwAAGgAAAAAAAAAZOcAACYFAAAnBQAAmP///5j///9k5wAAKAUAACkFAABOU3QzX18yMTRiYXNpY19vZnN0cmVhbUljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRQAEHAEAdOwAAGTnAABOU3QzX18yMTNiYXNpY19maWxlYnVmSWNOU18xMWNoYXJfdHJhaXRzSWNFRUVFAAAEHAEAsOwAAOTmAAAAAAAAEO0AAG0FAABuBQAATlN0M19fMjhpb3NfYmFzZUUAAADcGwEA/OwAAOBRAQAAAAAA3hIElQAAAAD///////////////8g7QAAFAAAAEMuVVRGLTgAQfDaAwsCNO0AQZDbAwviBAIAAMADAADABAAAwAUAAMAGAADABwAAwAgAAMAJAADACgAAwAsAAMAMAADADQAAwA4AAMAPAADAEAAAwBEAAMASAADAEwAAwBQAAMAVAADAFgAAwBcAAMAYAADAGQAAwBoAAMAbAADAHAAAwB0AAMAeAADAHwAAwAAAALMBAADDAgAAwwMAAMMEAADDBQAAwwYAAMMHAADDCAAAwwkAAMMKAADDCwAAwwwAAMMNAADTDgAAww8AAMMAAAy7AQAMwwIADMMDAAzDBAAM2wAAAAC07gAAFAUAAHAFAABxBQAAFwUAABgFAAAZBQAAGgUAABsFAAAcBQAAcgUAAHMFAAB0BQAAIAUAACEFAABOU3QzX18yMTBfX3N0ZGluYnVmSWNFRQAEHAEAnO4AAOTmAAAAAAAAHO8AABQFAAB1BQAAdgUAABcFAAAYBQAAGQUAAHcFAAAbBQAAHAUAAB0FAAAeBQAAHwUAAHgFAAB5BQAATlN0M19fMjExX19zdGRvdXRidWZJY0VFAAAAAAQcAQAA7wAA5OYAAAAAAACA7wAAMAUAAHoFAAB7BQAAMwUAADQFAAA1BQAANgUAADcFAAA4BQAAfAUAAH0FAAB+BQAAPAUAAD0FAABOU3QzX18yMTBfX3N0ZGluYnVmSXdFRQAEHAEAaO8AAJjoAAAAAAAA6O8AADAFAAB/BQAAgAUAADMFAAA0BQAANQUAAIEFAAA3BQAAOAUAADkFAAA6BQAAOwUAAIIFAACDBQAATlN0M19fMjExX19zdGRvdXRidWZJd0VFAAAAAAQcAQDM7wAAmOgAQYDgAwuqA9F0ngBXnb0qgHBSD///PicKAAAAZAAAAOgDAAAQJwAAoIYBAEBCDwCAlpgAAOH1BRgAAAA1AAAAcQAAAGv////O+///kr///wAAAAAAAAAA/////////////////////////////////////////////////////////////////wABAgMEBQYHCAn/////////CgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiP///////8KCwwNDg8QERITFBUWFxgZGhscHR4fICEiI/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AAQIEBwMGBQAAAAAAAABMQ19DVFlQRQAAAABMQ19OVU1FUklDAABMQ19USU1FAAAAAABMQ19DT0xMQVRFAABMQ19NT05FVEFSWQBMQ19NRVNTQUdFUwCw8wBBtOcDC/kDAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAA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");
      var Pe = (f = {}) => (0, _6.default)({ ...f, wasmBinary: B6 });
      return Ce(Me);
    })();
    libheif = libheif.default;
    {
      module.exports = libheif;
    }
  })(libheifBundle);
  return libheifBundle.exports;
}
var wasmBundle;
var hasRequiredWasmBundle;
function requireWasmBundle() {
  if (hasRequiredWasmBundle) return wasmBundle;
  hasRequiredWasmBundle = 1;
  wasmBundle = requireLibheifBundle()();
  return wasmBundle;
}
var lib$1;
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$1;
  hasRequiredLib$1 = 1;
  const uint8ArrayUtf8ByteString = (array, start, end) => {
    return String.fromCharCode(...array.slice(start, end));
  };
  const isHeic = (buffer2) => {
    const brandMajor = uint8ArrayUtf8ByteString(buffer2, 8, 12).replace("\0", " ").trim();
    switch (brandMajor) {
      case "mif1":
        return true;
      // {ext: 'heic', mime: 'image/heif'};
      case "msf1":
        return true;
      // {ext: 'heic', mime: 'image/heif-sequence'};
      case "heic":
      case "heix":
        return true;
      // {ext: 'heic', mime: 'image/heic'};
      case "hevc":
      case "hevx":
        return true;
    }
    return false;
  };
  const decodeImage = async (image) => {
    const width = image.get_width();
    const height = image.get_height();
    const { data: data2 } = await new Promise((resolve, reject) => {
      image.display({ data: new Uint8ClampedArray(width * height * 4), width, height }, (displayData) => {
        if (!displayData) {
          return reject(new Error("HEIF processing error"));
        }
        resolve(displayData);
      });
    });
    return { width, height, data: data2 };
  };
  lib$1 = (libheif) => {
    const decodeBuffer = async ({ buffer: buffer2, all: all3 }) => {
      if (!isHeic(buffer2)) {
        throw new TypeError("input buffer is not a HEIC image");
      }
      await libheif.ready;
      const decoder2 = new libheif.HeifDecoder();
      const data2 = decoder2.decode(buffer2);
      const dispose = () => {
        for (const image of data2) {
          image.free();
        }
        decoder2.decoder.delete();
      };
      if (!data2.length) {
        throw new Error("HEIF image not found");
      }
      if (!all3) {
        try {
          return await decodeImage(data2[0]);
        } finally {
          dispose();
        }
      }
      return Object.defineProperty(data2.map((image) => {
        return {
          width: image.get_width(),
          height: image.get_height(),
          decode: async () => await decodeImage(image)
        };
      }), "dispose", {
        enumerable: false,
        configurable: false,
        writable: false,
        value: dispose
      });
    };
    return {
      one: async ({ buffer: buffer2 }) => await decodeBuffer({ buffer: buffer2, all: false }),
      all: async ({ buffer: buffer2 }) => await decodeBuffer({ buffer: buffer2, all: true })
    };
  };
  return lib$1;
}
var hasRequiredHeicDecode;
function requireHeicDecode() {
  if (hasRequiredHeicDecode) return heicDecode.exports;
  hasRequiredHeicDecode = 1;
  const libheif = requireWasmBundle();
  const { one, all: all3 } = requireLib$1()(libheif);
  heicDecode.exports = one;
  heicDecode.exports.all = all3;
  return heicDecode.exports;
}
var formatsNode = { exports: {} };
var encoder = { exports: {} };
var hasRequiredEncoder;
function requireEncoder() {
  if (hasRequiredEncoder) return encoder.exports;
  hasRequiredEncoder = 1;
  (function(module) {
    function JPEGEncoder(quality) {
      var ffloor = Math.floor;
      var YTable = new Array(64);
      var UVTable = new Array(64);
      var fdtbl_Y = new Array(64);
      var fdtbl_UV = new Array(64);
      var YDC_HT;
      var UVDC_HT;
      var YAC_HT;
      var UVAC_HT;
      var bitcode = new Array(65535);
      var category = new Array(65535);
      var outputfDCTQuant = new Array(64);
      var DU = new Array(64);
      var byteout = [];
      var bytenew = 0;
      var bytepos = 7;
      var YDU = new Array(64);
      var UDU = new Array(64);
      var VDU = new Array(64);
      var clt = new Array(256);
      var RGB_YUV_TABLE = new Array(2048);
      var currentQuality;
      var ZigZag = [
        0,
        1,
        5,
        6,
        14,
        15,
        27,
        28,
        2,
        4,
        7,
        13,
        16,
        26,
        29,
        42,
        3,
        8,
        12,
        17,
        25,
        30,
        41,
        43,
        9,
        11,
        18,
        24,
        31,
        40,
        44,
        53,
        10,
        19,
        23,
        32,
        39,
        45,
        52,
        54,
        20,
        22,
        33,
        38,
        46,
        51,
        55,
        60,
        21,
        34,
        37,
        47,
        50,
        56,
        59,
        61,
        35,
        36,
        48,
        49,
        57,
        58,
        62,
        63
      ];
      var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
      var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
      var std_ac_luminance_values = [
        1,
        2,
        3,
        0,
        4,
        17,
        5,
        18,
        33,
        49,
        65,
        6,
        19,
        81,
        97,
        7,
        34,
        113,
        20,
        50,
        129,
        145,
        161,
        8,
        35,
        66,
        177,
        193,
        21,
        82,
        209,
        240,
        36,
        51,
        98,
        114,
        130,
        9,
        10,
        22,
        23,
        24,
        25,
        26,
        37,
        38,
        39,
        40,
        41,
        42,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
      var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
      var std_ac_chrominance_values = [
        0,
        1,
        2,
        3,
        17,
        4,
        5,
        33,
        49,
        6,
        18,
        65,
        81,
        7,
        97,
        113,
        19,
        34,
        50,
        129,
        8,
        20,
        66,
        145,
        161,
        177,
        193,
        9,
        35,
        51,
        82,
        240,
        21,
        98,
        114,
        209,
        10,
        22,
        36,
        52,
        225,
        37,
        241,
        23,
        24,
        25,
        26,
        38,
        39,
        40,
        41,
        42,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      function initQuantTables(sf) {
        var YQT = [
          16,
          11,
          10,
          16,
          24,
          40,
          51,
          61,
          12,
          12,
          14,
          19,
          26,
          58,
          60,
          55,
          14,
          13,
          16,
          24,
          40,
          57,
          69,
          56,
          14,
          17,
          22,
          29,
          51,
          87,
          80,
          62,
          18,
          22,
          37,
          56,
          68,
          109,
          103,
          77,
          24,
          35,
          55,
          64,
          81,
          104,
          113,
          92,
          49,
          64,
          78,
          87,
          103,
          121,
          120,
          101,
          72,
          92,
          95,
          98,
          112,
          100,
          103,
          99
        ];
        for (var i = 0; i < 64; i++) {
          var t = ffloor((YQT[i] * sf + 50) / 100);
          if (t < 1) {
            t = 1;
          } else if (t > 255) {
            t = 255;
          }
          YTable[ZigZag[i]] = t;
        }
        var UVQT = [
          17,
          18,
          24,
          47,
          99,
          99,
          99,
          99,
          18,
          21,
          26,
          66,
          99,
          99,
          99,
          99,
          24,
          26,
          56,
          99,
          99,
          99,
          99,
          99,
          47,
          66,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99
        ];
        for (var j = 0; j < 64; j++) {
          var u = ffloor((UVQT[j] * sf + 50) / 100);
          if (u < 1) {
            u = 1;
          } else if (u > 255) {
            u = 255;
          }
          UVTable[ZigZag[j]] = u;
        }
        var aasf = [
          1,
          1.387039845,
          1.306562965,
          1.175875602,
          1,
          0.785694958,
          0.5411961,
          0.275899379
        ];
        var k = 0;
        for (var row = 0; row < 8; row++) {
          for (var col = 0; col < 8; col++) {
            fdtbl_Y[k] = 1 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            fdtbl_UV[k] = 1 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            k++;
          }
        }
      }
      function computeHuffmanTbl(nrcodes, std_table) {
        var codevalue = 0;
        var pos_in_table = 0;
        var HT = new Array();
        for (var k = 1; k <= 16; k++) {
          for (var j = 1; j <= nrcodes[k]; j++) {
            HT[std_table[pos_in_table]] = [];
            HT[std_table[pos_in_table]][0] = codevalue;
            HT[std_table[pos_in_table]][1] = k;
            pos_in_table++;
            codevalue++;
          }
          codevalue *= 2;
        }
        return HT;
      }
      function initHuffmanTbl() {
        YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
        UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
        YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
        UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
      }
      function initCategoryNumber() {
        var nrlower = 1;
        var nrupper = 2;
        for (var cat = 1; cat <= 15; cat++) {
          for (var nr = nrlower; nr < nrupper; nr++) {
            category[32767 + nr] = cat;
            bitcode[32767 + nr] = [];
            bitcode[32767 + nr][1] = cat;
            bitcode[32767 + nr][0] = nr;
          }
          for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
            category[32767 + nrneg] = cat;
            bitcode[32767 + nrneg] = [];
            bitcode[32767 + nrneg][1] = cat;
            bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
          }
          nrlower <<= 1;
          nrupper <<= 1;
        }
      }
      function initRGBYUVTable() {
        for (var i = 0; i < 256; i++) {
          RGB_YUV_TABLE[i] = 19595 * i;
          RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i;
          RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 32768;
          RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i;
          RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i;
          RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 8421375;
          RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i;
          RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;
        }
      }
      function writeBits(bs) {
        var value = bs[0];
        var posval = bs[1] - 1;
        while (posval >= 0) {
          if (value & 1 << posval) {
            bytenew |= 1 << bytepos;
          }
          posval--;
          bytepos--;
          if (bytepos < 0) {
            if (bytenew == 255) {
              writeByte(255);
              writeByte(0);
            } else {
              writeByte(bytenew);
            }
            bytepos = 7;
            bytenew = 0;
          }
        }
      }
      function writeByte(value) {
        byteout.push(value);
      }
      function writeWord(value) {
        writeByte(value >> 8 & 255);
        writeByte(value & 255);
      }
      function fDCTQuant(data2, fdtbl) {
        var d0, d1, d2, d3, d4, d5, d6, d7;
        var dataOff = 0;
        var i;
        var I8 = 8;
        var I64 = 64;
        for (i = 0; i < I8; ++i) {
          d0 = data2[dataOff];
          d1 = data2[dataOff + 1];
          d2 = data2[dataOff + 2];
          d3 = data2[dataOff + 3];
          d4 = data2[dataOff + 4];
          d5 = data2[dataOff + 5];
          d6 = data2[dataOff + 6];
          d7 = data2[dataOff + 7];
          var tmp0 = d0 + d7;
          var tmp7 = d0 - d7;
          var tmp1 = d1 + d6;
          var tmp6 = d1 - d6;
          var tmp2 = d2 + d5;
          var tmp5 = d2 - d5;
          var tmp3 = d3 + d4;
          var tmp4 = d3 - d4;
          var tmp10 = tmp0 + tmp3;
          var tmp13 = tmp0 - tmp3;
          var tmp11 = tmp1 + tmp2;
          var tmp12 = tmp1 - tmp2;
          data2[dataOff] = tmp10 + tmp11;
          data2[dataOff + 4] = tmp10 - tmp11;
          var z1 = (tmp12 + tmp13) * 0.707106781;
          data2[dataOff + 2] = tmp13 + z1;
          data2[dataOff + 6] = tmp13 - z1;
          tmp10 = tmp4 + tmp5;
          tmp11 = tmp5 + tmp6;
          tmp12 = tmp6 + tmp7;
          var z5 = (tmp10 - tmp12) * 0.382683433;
          var z2 = 0.5411961 * tmp10 + z5;
          var z4 = 1.306562965 * tmp12 + z5;
          var z3 = tmp11 * 0.707106781;
          var z11 = tmp7 + z3;
          var z13 = tmp7 - z3;
          data2[dataOff + 5] = z13 + z2;
          data2[dataOff + 3] = z13 - z2;
          data2[dataOff + 1] = z11 + z4;
          data2[dataOff + 7] = z11 - z4;
          dataOff += 8;
        }
        dataOff = 0;
        for (i = 0; i < I8; ++i) {
          d0 = data2[dataOff];
          d1 = data2[dataOff + 8];
          d2 = data2[dataOff + 16];
          d3 = data2[dataOff + 24];
          d4 = data2[dataOff + 32];
          d5 = data2[dataOff + 40];
          d6 = data2[dataOff + 48];
          d7 = data2[dataOff + 56];
          var tmp0p2 = d0 + d7;
          var tmp7p2 = d0 - d7;
          var tmp1p2 = d1 + d6;
          var tmp6p2 = d1 - d6;
          var tmp2p2 = d2 + d5;
          var tmp5p2 = d2 - d5;
          var tmp3p2 = d3 + d4;
          var tmp4p2 = d3 - d4;
          var tmp10p2 = tmp0p2 + tmp3p2;
          var tmp13p2 = tmp0p2 - tmp3p2;
          var tmp11p2 = tmp1p2 + tmp2p2;
          var tmp12p2 = tmp1p2 - tmp2p2;
          data2[dataOff] = tmp10p2 + tmp11p2;
          data2[dataOff + 32] = tmp10p2 - tmp11p2;
          var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
          data2[dataOff + 16] = tmp13p2 + z1p2;
          data2[dataOff + 48] = tmp13p2 - z1p2;
          tmp10p2 = tmp4p2 + tmp5p2;
          tmp11p2 = tmp5p2 + tmp6p2;
          tmp12p2 = tmp6p2 + tmp7p2;
          var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
          var z2p2 = 0.5411961 * tmp10p2 + z5p2;
          var z4p2 = 1.306562965 * tmp12p2 + z5p2;
          var z3p2 = tmp11p2 * 0.707106781;
          var z11p2 = tmp7p2 + z3p2;
          var z13p2 = tmp7p2 - z3p2;
          data2[dataOff + 40] = z13p2 + z2p2;
          data2[dataOff + 24] = z13p2 - z2p2;
          data2[dataOff + 8] = z11p2 + z4p2;
          data2[dataOff + 56] = z11p2 - z4p2;
          dataOff++;
        }
        var fDCTQuant2;
        for (i = 0; i < I64; ++i) {
          fDCTQuant2 = data2[i] * fdtbl[i];
          outputfDCTQuant[i] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
        }
        return outputfDCTQuant;
      }
      function writeAPP0() {
        writeWord(65504);
        writeWord(16);
        writeByte(74);
        writeByte(70);
        writeByte(73);
        writeByte(70);
        writeByte(0);
        writeByte(1);
        writeByte(1);
        writeByte(0);
        writeWord(1);
        writeWord(1);
        writeByte(0);
        writeByte(0);
      }
      function writeAPP1(exifBuffer) {
        if (!exifBuffer) return;
        writeWord(65505);
        if (exifBuffer[0] === 69 && exifBuffer[1] === 120 && exifBuffer[2] === 105 && exifBuffer[3] === 102) {
          writeWord(exifBuffer.length + 2);
        } else {
          writeWord(exifBuffer.length + 5 + 2);
          writeByte(69);
          writeByte(120);
          writeByte(105);
          writeByte(102);
          writeByte(0);
        }
        for (var i = 0; i < exifBuffer.length; i++) {
          writeByte(exifBuffer[i]);
        }
      }
      function writeSOF0(width, height) {
        writeWord(65472);
        writeWord(17);
        writeByte(8);
        writeWord(height);
        writeWord(width);
        writeByte(3);
        writeByte(1);
        writeByte(17);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(1);
        writeByte(3);
        writeByte(17);
        writeByte(1);
      }
      function writeDQT() {
        writeWord(65499);
        writeWord(132);
        writeByte(0);
        for (var i = 0; i < 64; i++) {
          writeByte(YTable[i]);
        }
        writeByte(1);
        for (var j = 0; j < 64; j++) {
          writeByte(UVTable[j]);
        }
      }
      function writeDHT() {
        writeWord(65476);
        writeWord(418);
        writeByte(0);
        for (var i = 0; i < 16; i++) {
          writeByte(std_dc_luminance_nrcodes[i + 1]);
        }
        for (var j = 0; j <= 11; j++) {
          writeByte(std_dc_luminance_values[j]);
        }
        writeByte(16);
        for (var k = 0; k < 16; k++) {
          writeByte(std_ac_luminance_nrcodes[k + 1]);
        }
        for (var l = 0; l <= 161; l++) {
          writeByte(std_ac_luminance_values[l]);
        }
        writeByte(1);
        for (var m = 0; m < 16; m++) {
          writeByte(std_dc_chrominance_nrcodes[m + 1]);
        }
        for (var n = 0; n <= 11; n++) {
          writeByte(std_dc_chrominance_values[n]);
        }
        writeByte(17);
        for (var o = 0; o < 16; o++) {
          writeByte(std_ac_chrominance_nrcodes[o + 1]);
        }
        for (var p = 0; p <= 161; p++) {
          writeByte(std_ac_chrominance_values[p]);
        }
      }
      function writeCOM(comments) {
        if (typeof comments === "undefined" || comments.constructor !== Array) return;
        comments.forEach((e) => {
          if (typeof e !== "string") return;
          writeWord(65534);
          var l = e.length;
          writeWord(l + 2);
          var i;
          for (i = 0; i < l; i++)
            writeByte(e.charCodeAt(i));
        });
      }
      function writeSOS() {
        writeWord(65498);
        writeWord(12);
        writeByte(3);
        writeByte(1);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(3);
        writeByte(17);
        writeByte(0);
        writeByte(63);
        writeByte(0);
      }
      function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
        var EOB = HTAC[0];
        var M16zeroes = HTAC[240];
        var pos;
        var I16 = 16;
        var I63 = 63;
        var I64 = 64;
        var DU_DCT = fDCTQuant(CDU, fdtbl);
        for (var j = 0; j < I64; ++j) {
          DU[ZigZag[j]] = DU_DCT[j];
        }
        var Diff = DU[0] - DC;
        DC = DU[0];
        if (Diff == 0) {
          writeBits(HTDC[0]);
        } else {
          pos = 32767 + Diff;
          writeBits(HTDC[category[pos]]);
          writeBits(bitcode[pos]);
        }
        var end0pos = 63;
        for (; end0pos > 0 && DU[end0pos] == 0; end0pos--) {
        }
        if (end0pos == 0) {
          writeBits(EOB);
          return DC;
        }
        var i = 1;
        var lng;
        while (i <= end0pos) {
          var startpos = i;
          for (; DU[i] == 0 && i <= end0pos; ++i) {
          }
          var nrzeroes = i - startpos;
          if (nrzeroes >= I16) {
            lng = nrzeroes >> 4;
            for (var nrmarker = 1; nrmarker <= lng; ++nrmarker)
              writeBits(M16zeroes);
            nrzeroes = nrzeroes & 15;
          }
          pos = 32767 + DU[i];
          writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
          writeBits(bitcode[pos]);
          i++;
        }
        if (end0pos != I63) {
          writeBits(EOB);
        }
        return DC;
      }
      function initCharLookupTable() {
        var sfcc = String.fromCharCode;
        for (var i = 0; i < 256; i++) {
          clt[i] = sfcc(i);
        }
      }
      this.encode = function(image, quality2) {
        (/* @__PURE__ */ new Date()).getTime();
        if (quality2) setQuality(quality2);
        byteout = new Array();
        bytenew = 0;
        bytepos = 7;
        writeWord(65496);
        writeAPP0();
        writeCOM(image.comments);
        writeAPP1(image.exifBuffer);
        writeDQT();
        writeSOF0(image.width, image.height);
        writeDHT();
        writeSOS();
        var DCY = 0;
        var DCU = 0;
        var DCV = 0;
        bytenew = 0;
        bytepos = 7;
        this.encode.displayName = "_encode_";
        var imageData = image.data;
        var width = image.width;
        var height = image.height;
        var quadWidth = width * 4;
        var x, y = 0;
        var r, g, b;
        var start, p, col, row, pos;
        while (y < height) {
          x = 0;
          while (x < quadWidth) {
            start = quadWidth * y + x;
            p = start;
            col = -1;
            row = 0;
            for (pos = 0; pos < 64; pos++) {
              row = pos >> 3;
              col = (pos & 7) * 4;
              p = start + row * quadWidth + col;
              if (y + row >= height) {
                p -= quadWidth * (y + 1 + row - height);
              }
              if (x + col >= quadWidth) {
                p -= x + col - quadWidth + 4;
              }
              r = imageData[p++];
              g = imageData[p++];
              b = imageData[p++];
              YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
              UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
              VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
            }
            DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
            DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
            DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
            x += 32;
          }
          y += 8;
        }
        if (bytepos >= 0) {
          var fillbits = [];
          fillbits[1] = bytepos + 1;
          fillbits[0] = (1 << bytepos + 1) - 1;
          writeBits(fillbits);
        }
        writeWord(65497);
        return Buffer.from(byteout);
      };
      function setQuality(quality2) {
        if (quality2 <= 0) {
          quality2 = 1;
        }
        if (quality2 > 100) {
          quality2 = 100;
        }
        if (currentQuality == quality2) return;
        var sf = 0;
        if (quality2 < 50) {
          sf = Math.floor(5e3 / quality2);
        } else {
          sf = Math.floor(200 - quality2 * 2);
        }
        initQuantTables(sf);
        currentQuality = quality2;
      }
      function init() {
        var time_start = (/* @__PURE__ */ new Date()).getTime();
        if (!quality) quality = 50;
        initCharLookupTable();
        initHuffmanTbl();
        initCategoryNumber();
        initRGBYUVTable();
        setQuality(quality);
        (/* @__PURE__ */ new Date()).getTime() - time_start;
      }
      init();
    }
    {
      module.exports = encode2;
    }
    function encode2(imgData, qu) {
      if (typeof qu === "undefined") qu = 50;
      var encoder2 = new JPEGEncoder(qu);
      var data2 = encoder2.encode(imgData, qu);
      return {
        data: data2,
        width: imgData.width,
        height: imgData.height
      };
    }
  })(encoder);
  return encoder.exports;
}
var decoder = { exports: {} };
var hasRequiredDecoder;
function requireDecoder() {
  if (hasRequiredDecoder) return decoder.exports;
  hasRequiredDecoder = 1;
  (function(module) {
    var JpegImage = function jpegImage() {
      var dctZigZag = new Int32Array([
        0,
        1,
        8,
        16,
        9,
        2,
        3,
        10,
        17,
        24,
        32,
        25,
        18,
        11,
        4,
        5,
        12,
        19,
        26,
        33,
        40,
        48,
        41,
        34,
        27,
        20,
        13,
        6,
        7,
        14,
        21,
        28,
        35,
        42,
        49,
        56,
        57,
        50,
        43,
        36,
        29,
        22,
        15,
        23,
        30,
        37,
        44,
        51,
        58,
        59,
        52,
        45,
        38,
        31,
        39,
        46,
        53,
        60,
        61,
        54,
        47,
        55,
        62,
        63
      ]);
      var dctCos1 = 4017;
      var dctSin1 = 799;
      var dctCos3 = 3406;
      var dctSin3 = 2276;
      var dctCos6 = 1567;
      var dctSin6 = 3784;
      var dctSqrt2 = 5793;
      var dctSqrt1d2 = 2896;
      function constructor() {
      }
      function buildHuffmanTable(codeLengths, values) {
        var k = 0, code = [], i, j, length = 16;
        while (length > 0 && !codeLengths[length - 1])
          length--;
        code.push({ children: [], index: 0 });
        var p = code[0], q;
        for (i = 0; i < length; i++) {
          for (j = 0; j < codeLengths[i]; j++) {
            p = code.pop();
            p.children[p.index] = values[k];
            while (p.index > 0) {
              if (code.length === 0)
                throw new Error("Could not recreate Huffman Table");
              p = code.pop();
            }
            p.index++;
            code.push(p);
            while (code.length <= i) {
              code.push(q = { children: [], index: 0 });
              p.children[p.index] = q.children;
              p = q;
            }
            k++;
          }
          if (i + 1 < length) {
            code.push(q = { children: [], index: 0 });
            p.children[p.index] = q.children;
            p = q;
          }
        }
        return code[0].children;
      }
      function decodeScan(data2, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, opts) {
        frame.precision;
        frame.samplesPerLine;
        frame.scanLines;
        var mcusPerLine = frame.mcusPerLine;
        var progressive = frame.progressive;
        frame.maxH;
        frame.maxV;
        var startOffset = offset, bitsData = 0, bitsCount = 0;
        function readBit() {
          if (bitsCount > 0) {
            bitsCount--;
            return bitsData >> bitsCount & 1;
          }
          bitsData = data2[offset++];
          if (bitsData == 255) {
            var nextByte = data2[offset++];
            if (nextByte) {
              throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
            }
          }
          bitsCount = 7;
          return bitsData >>> 7;
        }
        function decodeHuffman(tree) {
          var node = tree, bit;
          while ((bit = readBit()) !== null) {
            node = node[bit];
            if (typeof node === "number")
              return node;
            if (typeof node !== "object")
              throw new Error("invalid huffman sequence");
          }
          return null;
        }
        function receive(length) {
          var n2 = 0;
          while (length > 0) {
            var bit = readBit();
            if (bit === null) return;
            n2 = n2 << 1 | bit;
            length--;
          }
          return n2;
        }
        function receiveAndExtend(length) {
          var n2 = receive(length);
          if (n2 >= 1 << length - 1)
            return n2;
          return n2 + (-1 << length) + 1;
        }
        function decodeBaseline(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t);
          zz[0] = component2.pred += diff;
          var k2 = 1;
          while (k2 < 64) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15)
                break;
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s);
            k2++;
          }
        }
        function decodeDCFirst(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
          zz[0] = component2.pred += diff;
        }
        function decodeDCSuccessive(component2, zz) {
          zz[0] |= readBit() << successive;
        }
        var eobrun = 0;
        function decodeACFirst(component2, zz) {
          if (eobrun > 0) {
            eobrun--;
            return;
          }
          var k2 = spectralStart, e = spectralEnd;
          while (k2 <= e) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r) - 1;
                break;
              }
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s) * (1 << successive);
            k2++;
          }
        }
        var successiveACState = 0, successiveACNextValue;
        function decodeACSuccessive(component2, zz) {
          var k2 = spectralStart, e = spectralEnd, r = 0;
          while (k2 <= e) {
            var z = dctZigZag[k2];
            var direction = zz[z] < 0 ? -1 : 1;
            switch (successiveACState) {
              case 0:
                var rs = decodeHuffman(component2.huffmanTableAC);
                var s = rs & 15, r = rs >> 4;
                if (s === 0) {
                  if (r < 15) {
                    eobrun = receive(r) + (1 << r);
                    successiveACState = 4;
                  } else {
                    r = 16;
                    successiveACState = 1;
                  }
                } else {
                  if (s !== 1)
                    throw new Error("invalid ACn encoding");
                  successiveACNextValue = receiveAndExtend(s);
                  successiveACState = r ? 2 : 3;
                }
                continue;
              case 1:
              // skipping r zero items
              case 2:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  r--;
                  if (r === 0)
                    successiveACState = successiveACState == 2 ? 3 : 0;
                }
                break;
              case 3:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  zz[z] = successiveACNextValue << successive;
                  successiveACState = 0;
                }
                break;
              case 4:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                break;
            }
            k2++;
          }
          if (successiveACState === 4) {
            eobrun--;
            if (eobrun === 0)
              successiveACState = 0;
          }
        }
        function decodeMcu(component2, decode2, mcu2, row, col) {
          var mcuRow = mcu2 / mcusPerLine | 0;
          var mcuCol = mcu2 % mcusPerLine;
          var blockRow = mcuRow * component2.v + row;
          var blockCol = mcuCol * component2.h + col;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        function decodeBlock(component2, decode2, mcu2) {
          var blockRow = mcu2 / component2.blocksPerLine | 0;
          var blockCol = mcu2 % component2.blocksPerLine;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        var componentsLength = components.length;
        var component, i, j, k, n;
        var decodeFn;
        if (progressive) {
          if (spectralStart === 0)
            decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
          else
            decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
        } else {
          decodeFn = decodeBaseline;
        }
        var mcu = 0, marker;
        var mcuExpected;
        if (componentsLength == 1) {
          mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
        } else {
          mcuExpected = mcusPerLine * frame.mcusPerColumn;
        }
        if (!resetInterval) resetInterval = mcuExpected;
        var h, v;
        while (mcu < mcuExpected) {
          for (i = 0; i < componentsLength; i++)
            components[i].pred = 0;
          eobrun = 0;
          if (componentsLength == 1) {
            component = components[0];
            for (n = 0; n < resetInterval; n++) {
              decodeBlock(component, decodeFn, mcu);
              mcu++;
            }
          } else {
            for (n = 0; n < resetInterval; n++) {
              for (i = 0; i < componentsLength; i++) {
                component = components[i];
                h = component.h;
                v = component.v;
                for (j = 0; j < v; j++) {
                  for (k = 0; k < h; k++) {
                    decodeMcu(component, decodeFn, mcu, j, k);
                  }
                }
              }
              mcu++;
              if (mcu === mcuExpected) break;
            }
          }
          if (mcu === mcuExpected) {
            do {
              if (data2[offset] === 255) {
                if (data2[offset + 1] !== 0) {
                  break;
                }
              }
              offset += 1;
            } while (offset < data2.length - 2);
          }
          bitsCount = 0;
          marker = data2[offset] << 8 | data2[offset + 1];
          if (marker < 65280) {
            throw new Error("marker was not found");
          }
          if (marker >= 65488 && marker <= 65495) {
            offset += 2;
          } else
            break;
        }
        return offset - startOffset;
      }
      function buildComponentData(frame, component) {
        var lines = [];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;
        var R = new Int32Array(64), r = new Uint8Array(64);
        function quantizeAndInverse(zz, dataOut, dataIn) {
          var qt = component.quantizationTable;
          var v0, v1, v2, v3, v4, v5, v6, v7, t;
          var p = dataIn;
          var i2;
          for (i2 = 0; i2 < 64; i2++)
            p[i2] = zz[i2] * qt[i2];
          for (i2 = 0; i2 < 8; ++i2) {
            var row = 8 * i2;
            if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {
              t = dctSqrt2 * p[0 + row] + 512 >> 10;
              p[0 + row] = t;
              p[1 + row] = t;
              p[2 + row] = t;
              p[3 + row] = t;
              p[4 + row] = t;
              p[5 + row] = t;
              p[6 + row] = t;
              p[7 + row] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 + row] + 128 >> 8;
            v1 = dctSqrt2 * p[4 + row] + 128 >> 8;
            v2 = p[2 + row];
            v3 = p[6 + row];
            v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;
            v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;
            v5 = p[3 + row] << 4;
            v6 = p[5 + row] << 4;
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 + row] = v0 + v7;
            p[7 + row] = v0 - v7;
            p[1 + row] = v1 + v6;
            p[6 + row] = v1 - v6;
            p[2 + row] = v2 + v5;
            p[5 + row] = v2 - v5;
            p[3 + row] = v3 + v4;
            p[4 + row] = v3 - v4;
          }
          for (i2 = 0; i2 < 8; ++i2) {
            var col = i2;
            if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {
              t = dctSqrt2 * dataIn[i2 + 0] + 8192 >> 14;
              p[0 * 8 + col] = t;
              p[1 * 8 + col] = t;
              p[2 * 8 + col] = t;
              p[3 * 8 + col] = t;
              p[4 * 8 + col] = t;
              p[5 * 8 + col] = t;
              p[6 * 8 + col] = t;
              p[7 * 8 + col] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;
            v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;
            v2 = p[2 * 8 + col];
            v3 = p[6 * 8 + col];
            v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;
            v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;
            v5 = p[3 * 8 + col];
            v6 = p[5 * 8 + col];
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 * 8 + col] = v0 + v7;
            p[7 * 8 + col] = v0 - v7;
            p[1 * 8 + col] = v1 + v6;
            p[6 * 8 + col] = v1 - v6;
            p[2 * 8 + col] = v2 + v5;
            p[5 * 8 + col] = v2 - v5;
            p[3 * 8 + col] = v3 + v4;
            p[4 * 8 + col] = v3 - v4;
          }
          for (i2 = 0; i2 < 64; ++i2) {
            var sample2 = 128 + (p[i2] + 8 >> 4);
            dataOut[i2] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
          }
        }
        requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);
        var i, j;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (i = 0; i < 8; i++)
            lines.push(new Uint8Array(samplesPerLine));
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var line = lines[scanLine + j];
              for (i = 0; i < 8; i++)
                line[sample + i] = r[offset++];
            }
          }
        }
        return lines;
      }
      function clampTo8bit(a) {
        return a < 0 ? 0 : a > 255 ? 255 : a;
      }
      constructor.prototype = {
        load: function load(path2) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", path2, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = function() {
            var data2 = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
            this.parse(data2);
            if (this.onload)
              this.onload();
          }.bind(this);
          xhr.send(null);
        },
        parse: function parse2(data2) {
          var maxResolutionInPixels = this.opts.maxResolutionInMP * 1e3 * 1e3;
          var offset = 0;
          data2.length;
          function readUint16() {
            var value = data2[offset] << 8 | data2[offset + 1];
            offset += 2;
            return value;
          }
          function readDataBlock() {
            var length = readUint16();
            var array = data2.subarray(offset, offset + length - 2);
            offset += array.length;
            return array;
          }
          function prepareComponents(frame2) {
            var maxH = 1, maxV = 1;
            var component2, componentId2;
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                if (maxH < component2.h) maxH = component2.h;
                if (maxV < component2.v) maxV = component2.v;
              }
            }
            var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH);
            var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV);
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH);
                var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV);
                var blocksPerLineForMcu = mcusPerLine * component2.h;
                var blocksPerColumnForMcu = mcusPerColumn * component2.v;
                var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
                var blocks = [];
                requestMemoryAllocation(blocksToAllocate * 256);
                for (var i2 = 0; i2 < blocksPerColumnForMcu; i2++) {
                  var row = [];
                  for (var j2 = 0; j2 < blocksPerLineForMcu; j2++)
                    row.push(new Int32Array(64));
                  blocks.push(row);
                }
                component2.blocksPerLine = blocksPerLine;
                component2.blocksPerColumn = blocksPerColumn;
                component2.blocks = blocks;
              }
            }
            frame2.maxH = maxH;
            frame2.maxV = maxV;
            frame2.mcusPerLine = mcusPerLine;
            frame2.mcusPerColumn = mcusPerColumn;
          }
          var jfif = null;
          var adobe = null;
          var frame, resetInterval;
          var quantizationTables = [], frames = [];
          var huffmanTablesAC = [], huffmanTablesDC = [];
          var fileMarker = readUint16();
          var malformedDataOffset = -1;
          this.comments = [];
          if (fileMarker != 65496) {
            throw new Error("SOI not found");
          }
          fileMarker = readUint16();
          while (fileMarker != 65497) {
            var i, j;
            switch (fileMarker) {
              case 65280:
                break;
              case 65504:
              // APP0 (Application Specific)
              case 65505:
              // APP1
              case 65506:
              // APP2
              case 65507:
              // APP3
              case 65508:
              // APP4
              case 65509:
              // APP5
              case 65510:
              // APP6
              case 65511:
              // APP7
              case 65512:
              // APP8
              case 65513:
              // APP9
              case 65514:
              // APP10
              case 65515:
              // APP11
              case 65516:
              // APP12
              case 65517:
              // APP13
              case 65518:
              // APP14
              case 65519:
              // APP15
              case 65534:
                var appData = readDataBlock();
                if (fileMarker === 65534) {
                  var comment = String.fromCharCode.apply(null, appData);
                  this.comments.push(comment);
                }
                if (fileMarker === 65504) {
                  if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                    jfif = {
                      version: { major: appData[5], minor: appData[6] },
                      densityUnits: appData[7],
                      xDensity: appData[8] << 8 | appData[9],
                      yDensity: appData[10] << 8 | appData[11],
                      thumbWidth: appData[12],
                      thumbHeight: appData[13],
                      thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                    };
                  }
                }
                if (fileMarker === 65505) {
                  if (appData[0] === 69 && appData[1] === 120 && appData[2] === 105 && appData[3] === 102 && appData[4] === 0) {
                    this.exifBuffer = appData.subarray(5, appData.length);
                  }
                }
                if (fileMarker === 65518) {
                  if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                    adobe = {
                      version: appData[6],
                      flags0: appData[7] << 8 | appData[8],
                      flags1: appData[9] << 8 | appData[10],
                      transformCode: appData[11]
                    };
                  }
                }
                break;
              case 65499:
                var quantizationTablesLength = readUint16();
                var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                while (offset < quantizationTablesEnd) {
                  var quantizationTableSpec = data2[offset++];
                  requestMemoryAllocation(64 * 4);
                  var tableData = new Int32Array(64);
                  if (quantizationTableSpec >> 4 === 0) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = data2[offset++];
                    }
                  } else if (quantizationTableSpec >> 4 === 1) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = readUint16();
                    }
                  } else
                    throw new Error("DQT: invalid table spec");
                  quantizationTables[quantizationTableSpec & 15] = tableData;
                }
                break;
              case 65472:
              // SOF0 (Start of Frame, Baseline DCT)
              case 65473:
              // SOF1 (Start of Frame, Extended DCT)
              case 65474:
                readUint16();
                frame = {};
                frame.extended = fileMarker === 65473;
                frame.progressive = fileMarker === 65474;
                frame.precision = data2[offset++];
                frame.scanLines = readUint16();
                frame.samplesPerLine = readUint16();
                frame.components = {};
                frame.componentsOrder = [];
                var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
                if (pixelsInFrame > maxResolutionInPixels) {
                  var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
                  throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
                }
                var componentsCount = data2[offset++], componentId;
                for (i = 0; i < componentsCount; i++) {
                  componentId = data2[offset];
                  var h = data2[offset + 1] >> 4;
                  var v = data2[offset + 1] & 15;
                  var qId = data2[offset + 2];
                  if (h <= 0 || v <= 0) {
                    throw new Error("Invalid sampling factor, expected values above 0");
                  }
                  frame.componentsOrder.push(componentId);
                  frame.components[componentId] = {
                    h,
                    v,
                    quantizationIdx: qId
                  };
                  offset += 3;
                }
                prepareComponents(frame);
                frames.push(frame);
                break;
              case 65476:
                var huffmanLength = readUint16();
                for (i = 2; i < huffmanLength; ) {
                  var huffmanTableSpec = data2[offset++];
                  var codeLengths = new Uint8Array(16);
                  var codeLengthSum = 0;
                  for (j = 0; j < 16; j++, offset++) {
                    codeLengthSum += codeLengths[j] = data2[offset];
                  }
                  requestMemoryAllocation(16 + codeLengthSum);
                  var huffmanValues = new Uint8Array(codeLengthSum);
                  for (j = 0; j < codeLengthSum; j++, offset++)
                    huffmanValues[j] = data2[offset];
                  i += 17 + codeLengthSum;
                  (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                }
                break;
              case 65501:
                readUint16();
                resetInterval = readUint16();
                break;
              case 65500:
                readUint16();
                readUint16();
                break;
              case 65498:
                readUint16();
                var selectorsCount = data2[offset++];
                var components = [], component;
                for (i = 0; i < selectorsCount; i++) {
                  component = frame.components[data2[offset++]];
                  var tableSpec = data2[offset++];
                  component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                  component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                  components.push(component);
                }
                var spectralStart = data2[offset++];
                var spectralEnd = data2[offset++];
                var successiveApproximation = data2[offset++];
                var processed = decodeScan(
                  data2,
                  offset,
                  frame,
                  components,
                  resetInterval,
                  spectralStart,
                  spectralEnd,
                  successiveApproximation >> 4,
                  successiveApproximation & 15,
                  this.opts
                );
                offset += processed;
                break;
              case 65535:
                if (data2[offset] !== 255) {
                  offset--;
                }
                break;
              default:
                if (data2[offset - 3] == 255 && data2[offset - 2] >= 192 && data2[offset - 2] <= 254) {
                  offset -= 3;
                  break;
                } else if (fileMarker === 224 || fileMarker == 225) {
                  if (malformedDataOffset !== -1) {
                    throw new Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset - 1).toString(16)}`);
                  }
                  malformedDataOffset = offset - 1;
                  const nextOffset = readUint16();
                  if (data2[offset + nextOffset - 2] === 255) {
                    offset += nextOffset - 2;
                    break;
                  }
                }
                throw new Error("unknown JPEG marker " + fileMarker.toString(16));
            }
            fileMarker = readUint16();
          }
          if (frames.length != 1)
            throw new Error("only single frame JPEGs supported");
          for (var i = 0; i < frames.length; i++) {
            var cp = frames[i].components;
            for (var j in cp) {
              cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
              delete cp[j].quantizationIdx;
            }
          }
          this.width = frame.samplesPerLine;
          this.height = frame.scanLines;
          this.jfif = jfif;
          this.adobe = adobe;
          this.components = [];
          for (var i = 0; i < frame.componentsOrder.length; i++) {
            var component = frame.components[frame.componentsOrder[i]];
            this.components.push({
              lines: buildComponentData(frame, component),
              scaleX: component.h / frame.maxH,
              scaleY: component.v / frame.maxV
            });
          }
        },
        getData: function getData(width, height) {
          var scaleX = this.width / width, scaleY = this.height / height;
          var component1, component2, component3, component4;
          var component1Line, component2Line, component3Line, component4Line;
          var x, y;
          var offset = 0;
          var Y, Cb, Cr, K, C, M, Ye, R, G, B;
          var colorTransform;
          var dataLength = width * height * this.components.length;
          requestMemoryAllocation(dataLength);
          var data2 = new Uint8Array(dataLength);
          switch (this.components.length) {
            case 1:
              component1 = this.components[0];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data2[offset++] = Y;
                }
              }
              break;
            case 2:
              component1 = this.components[0];
              component2 = this.components[1];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data2[offset++] = Y;
                  Y = component2Line[0 | x * component2.scaleX * scaleX];
                  data2[offset++] = Y;
                }
              }
              break;
            case 3:
              colorTransform = true;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    R = component1Line[0 | x * component1.scaleX * scaleX];
                    G = component2Line[0 | x * component2.scaleX * scaleX];
                    B = component3Line[0 | x * component3.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    R = clampTo8bit(Y + 1.402 * (Cr - 128));
                    G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    B = clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data2[offset++] = R;
                  data2[offset++] = G;
                  data2[offset++] = B;
                }
              }
              break;
            case 4:
              if (!this.adobe)
                throw new Error("Unsupported color mode (4 components)");
              colorTransform = false;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              component4 = this.components[3];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                component4Line = component4.lines[0 | y * component4.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    C = component1Line[0 | x * component1.scaleX * scaleX];
                    M = component2Line[0 | x * component2.scaleX * scaleX];
                    Ye = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                    C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                    M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data2[offset++] = 255 - C;
                  data2[offset++] = 255 - M;
                  data2[offset++] = 255 - Ye;
                  data2[offset++] = 255 - K;
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
          return data2;
        },
        copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
          var width = imageData.width, height = imageData.height;
          var imageDataArray = imageData.data;
          var data2 = this.getData(width, height);
          var i = 0, j = 0, x, y;
          var Y, K, C, M, R, G, B;
          switch (this.components.length) {
            case 1:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  Y = data2[i++];
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 3:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  R = data2[i++];
                  G = data2[i++];
                  B = data2[i++];
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 4:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  C = data2[i++];
                  M = data2[i++];
                  Y = data2[i++];
                  K = data2[i++];
                  R = 255 - clampTo8bit(C * (1 - K / 255) + K);
                  G = 255 - clampTo8bit(M * (1 - K / 255) + K);
                  B = 255 - clampTo8bit(Y * (1 - K / 255) + K);
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
        }
      };
      var totalBytesAllocated = 0;
      var maxMemoryUsageBytes = 0;
      function requestMemoryAllocation(increaseAmount = 0) {
        var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
        if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
          var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
          throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
        }
        totalBytesAllocated = totalMemoryImpactBytes;
      }
      constructor.resetMaxMemoryUsage = function(maxMemoryUsageBytes_) {
        totalBytesAllocated = 0;
        maxMemoryUsageBytes = maxMemoryUsageBytes_;
      };
      constructor.getBytesAllocated = function() {
        return totalBytesAllocated;
      };
      constructor.requestMemoryAllocation = requestMemoryAllocation;
      return constructor;
    }();
    {
      module.exports = decode;
    }
    function decode(jpegData, userOpts = {}) {
      var defaultOpts = {
        // "undefined" means "Choose whether to transform colors based on the images color model."
        colorTransform: void 0,
        useTArray: false,
        formatAsRGBA: true,
        tolerantDecoding: true,
        maxResolutionInMP: 100,
        // Don't decode more than 100 megapixels
        maxMemoryUsageInMB: 512
        // Don't decode if memory footprint is more than 512MB
      };
      var opts = { ...defaultOpts, ...userOpts };
      var arr = new Uint8Array(jpegData);
      var decoder2 = new JpegImage();
      decoder2.opts = opts;
      JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
      decoder2.parse(arr);
      var channels = opts.formatAsRGBA ? 4 : 3;
      var bytesNeeded = decoder2.width * decoder2.height * channels;
      try {
        JpegImage.requestMemoryAllocation(bytesNeeded);
        var image = {
          width: decoder2.width,
          height: decoder2.height,
          exifBuffer: decoder2.exifBuffer,
          data: opts.useTArray ? new Uint8Array(bytesNeeded) : Buffer.alloc(bytesNeeded)
        };
        if (decoder2.comments.length > 0) {
          image["comments"] = decoder2.comments;
        }
      } catch (err) {
        if (err instanceof RangeError) {
          throw new Error("Could not allocate enough memory for the image. Required: " + bytesNeeded);
        }
        if (err instanceof ReferenceError) {
          if (err.message === "Buffer is not defined") {
            throw new Error("Buffer is not globally defined in this environment. Consider setting useTArray to true");
          }
        }
        throw err;
      }
      decoder2.copyToImageData(image, opts.formatAsRGBA);
      return image;
    }
  })(decoder);
  return decoder.exports;
}
var jpegJs;
var hasRequiredJpegJs;
function requireJpegJs() {
  if (hasRequiredJpegJs) return jpegJs;
  hasRequiredJpegJs = 1;
  var encode2 = requireEncoder(), decode = requireDecoder();
  jpegJs = {
    encode: encode2,
    decode
  };
  return jpegJs;
}
var png = {};
var parserAsync = { exports: {} };
var chunkstream = { exports: {} };
var hasRequiredChunkstream;
function requireChunkstream() {
  if (hasRequiredChunkstream) return chunkstream.exports;
  hasRequiredChunkstream = 1;
  let util2 = require$$0$5;
  let Stream = stream;
  let ChunkStream = chunkstream.exports = function() {
    Stream.call(this);
    this._buffers = [];
    this._buffered = 0;
    this._reads = [];
    this._paused = false;
    this._encoding = "utf8";
    this.writable = true;
  };
  util2.inherits(ChunkStream, Stream);
  ChunkStream.prototype.read = function(length, callback) {
    this._reads.push({
      length: Math.abs(length),
      // if length < 0 then at most this length
      allowLess: length < 0,
      func: callback
    });
    process.nextTick(
      function() {
        this._process();
        if (this._paused && this._reads && this._reads.length > 0) {
          this._paused = false;
          this.emit("drain");
        }
      }.bind(this)
    );
  };
  ChunkStream.prototype.write = function(data2, encoding2) {
    if (!this.writable) {
      this.emit("error", new Error("Stream not writable"));
      return false;
    }
    let dataBuffer;
    if (Buffer.isBuffer(data2)) {
      dataBuffer = data2;
    } else {
      dataBuffer = Buffer.from(data2, encoding2 || this._encoding);
    }
    this._buffers.push(dataBuffer);
    this._buffered += dataBuffer.length;
    this._process();
    if (this._reads && this._reads.length === 0) {
      this._paused = true;
    }
    return this.writable && !this._paused;
  };
  ChunkStream.prototype.end = function(data2, encoding2) {
    if (data2) {
      this.write(data2, encoding2);
    }
    this.writable = false;
    if (!this._buffers) {
      return;
    }
    if (this._buffers.length === 0) {
      this._end();
    } else {
      this._buffers.push(null);
      this._process();
    }
  };
  ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
  ChunkStream.prototype._end = function() {
    if (this._reads.length > 0) {
      this.emit("error", new Error("Unexpected end of input"));
    }
    this.destroy();
  };
  ChunkStream.prototype.destroy = function() {
    if (!this._buffers) {
      return;
    }
    this.writable = false;
    this._reads = null;
    this._buffers = null;
    this.emit("close");
  };
  ChunkStream.prototype._processReadAllowingLess = function(read) {
    this._reads.shift();
    let smallerBuf = this._buffers[0];
    if (smallerBuf.length > read.length) {
      this._buffered -= read.length;
      this._buffers[0] = smallerBuf.slice(read.length);
      read.func.call(this, smallerBuf.slice(0, read.length));
    } else {
      this._buffered -= smallerBuf.length;
      this._buffers.shift();
      read.func.call(this, smallerBuf);
    }
  };
  ChunkStream.prototype._processRead = function(read) {
    this._reads.shift();
    let pos = 0;
    let count = 0;
    let data2 = Buffer.alloc(read.length);
    while (pos < read.length) {
      let buf = this._buffers[count++];
      let len = Math.min(buf.length, read.length - pos);
      buf.copy(data2, pos, 0, len);
      pos += len;
      if (len !== buf.length) {
        this._buffers[--count] = buf.slice(len);
      }
    }
    if (count > 0) {
      this._buffers.splice(0, count);
    }
    this._buffered -= read.length;
    read.func.call(this, data2);
  };
  ChunkStream.prototype._process = function() {
    try {
      while (this._buffered > 0 && this._reads && this._reads.length > 0) {
        let read = this._reads[0];
        if (read.allowLess) {
          this._processReadAllowingLess(read);
        } else if (this._buffered >= read.length) {
          this._processRead(read);
        } else {
          break;
        }
      }
      if (this._buffers && !this.writable) {
        this._end();
      }
    } catch (ex) {
      this.emit("error", ex);
    }
  };
  return chunkstream.exports;
}
var filterParseAsync = { exports: {} };
var filterParse = { exports: {} };
var interlace = {};
var hasRequiredInterlace;
function requireInterlace() {
  if (hasRequiredInterlace) return interlace;
  hasRequiredInterlace = 1;
  let imagePasses = [
    {
      // pass 1 - 1px
      x: [0],
      y: [0]
    },
    {
      // pass 2 - 1px
      x: [4],
      y: [0]
    },
    {
      // pass 3 - 2px
      x: [0, 4],
      y: [4]
    },
    {
      // pass 4 - 4px
      x: [2, 6],
      y: [0, 4]
    },
    {
      // pass 5 - 8px
      x: [0, 2, 4, 6],
      y: [2, 6]
    },
    {
      // pass 6 - 16px
      x: [1, 3, 5, 7],
      y: [0, 2, 4, 6]
    },
    {
      // pass 7 - 32px
      x: [0, 1, 2, 3, 4, 5, 6, 7],
      y: [1, 3, 5, 7]
    }
  ];
  interlace.getImagePasses = function(width, height) {
    let images = [];
    let xLeftOver = width % 8;
    let yLeftOver = height % 8;
    let xRepeats = (width - xLeftOver) / 8;
    let yRepeats = (height - yLeftOver) / 8;
    for (let i = 0; i < imagePasses.length; i++) {
      let pass = imagePasses[i];
      let passWidth = xRepeats * pass.x.length;
      let passHeight = yRepeats * pass.y.length;
      for (let j = 0; j < pass.x.length; j++) {
        if (pass.x[j] < xLeftOver) {
          passWidth++;
        } else {
          break;
        }
      }
      for (let j = 0; j < pass.y.length; j++) {
        if (pass.y[j] < yLeftOver) {
          passHeight++;
        } else {
          break;
        }
      }
      if (passWidth > 0 && passHeight > 0) {
        images.push({ width: passWidth, height: passHeight, index: i });
      }
    }
    return images;
  };
  interlace.getInterlaceIterator = function(width) {
    return function(x, y, pass) {
      let outerXLeftOver = x % imagePasses[pass].x.length;
      let outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
      let outerYLeftOver = y % imagePasses[pass].y.length;
      let outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
      return outerX * 4 + outerY * width * 4;
    };
  };
  return interlace;
}
var paethPredictor;
var hasRequiredPaethPredictor;
function requirePaethPredictor() {
  if (hasRequiredPaethPredictor) return paethPredictor;
  hasRequiredPaethPredictor = 1;
  paethPredictor = function paethPredictor2(left, above, upLeft) {
    let paeth = left + above - upLeft;
    let pLeft = Math.abs(paeth - left);
    let pAbove = Math.abs(paeth - above);
    let pUpLeft = Math.abs(paeth - upLeft);
    if (pLeft <= pAbove && pLeft <= pUpLeft) {
      return left;
    }
    if (pAbove <= pUpLeft) {
      return above;
    }
    return upLeft;
  };
  return paethPredictor;
}
var hasRequiredFilterParse;
function requireFilterParse() {
  if (hasRequiredFilterParse) return filterParse.exports;
  hasRequiredFilterParse = 1;
  let interlaceUtils = requireInterlace();
  let paethPredictor2 = requirePaethPredictor();
  function getByteWidth(width, bpp, depth) {
    let byteWidth = width * bpp;
    if (depth !== 8) {
      byteWidth = Math.ceil(byteWidth / (8 / depth));
    }
    return byteWidth;
  }
  let Filter = filterParse.exports = function(bitmapInfo, dependencies) {
    let width = bitmapInfo.width;
    let height = bitmapInfo.height;
    let interlace2 = bitmapInfo.interlace;
    let bpp = bitmapInfo.bpp;
    let depth = bitmapInfo.depth;
    this.read = dependencies.read;
    this.write = dependencies.write;
    this.complete = dependencies.complete;
    this._imageIndex = 0;
    this._images = [];
    if (interlace2) {
      let passes = interlaceUtils.getImagePasses(width, height);
      for (let i = 0; i < passes.length; i++) {
        this._images.push({
          byteWidth: getByteWidth(passes[i].width, bpp, depth),
          height: passes[i].height,
          lineIndex: 0
        });
      }
    } else {
      this._images.push({
        byteWidth: getByteWidth(width, bpp, depth),
        height,
        lineIndex: 0
      });
    }
    if (depth === 8) {
      this._xComparison = bpp;
    } else if (depth === 16) {
      this._xComparison = bpp * 2;
    } else {
      this._xComparison = 1;
    }
  };
  Filter.prototype.start = function() {
    this.read(
      this._images[this._imageIndex].byteWidth + 1,
      this._reverseFilterLine.bind(this)
    );
  };
  Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
    let xComparison = this._xComparison;
    let xBiggerThan = xComparison - 1;
    for (let x = 0; x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      unfilteredLine[x] = rawByte + f1Left;
    }
  };
  Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
    let lastLine = this._lastLine;
    for (let x = 0; x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f2Up = lastLine ? lastLine[x] : 0;
      unfilteredLine[x] = rawByte + f2Up;
    }
  };
  Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
    let xComparison = this._xComparison;
    let xBiggerThan = xComparison - 1;
    let lastLine = this._lastLine;
    for (let x = 0; x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f3Up = lastLine ? lastLine[x] : 0;
      let f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      let f3Add = Math.floor((f3Left + f3Up) / 2);
      unfilteredLine[x] = rawByte + f3Add;
    }
  };
  Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
    let xComparison = this._xComparison;
    let xBiggerThan = xComparison - 1;
    let lastLine = this._lastLine;
    for (let x = 0; x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f4Up = lastLine ? lastLine[x] : 0;
      let f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      let f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
      let f4Add = paethPredictor2(f4Left, f4Up, f4UpLeft);
      unfilteredLine[x] = rawByte + f4Add;
    }
  };
  Filter.prototype._reverseFilterLine = function(rawData) {
    let filter2 = rawData[0];
    let unfilteredLine;
    let currentImage = this._images[this._imageIndex];
    let byteWidth = currentImage.byteWidth;
    if (filter2 === 0) {
      unfilteredLine = rawData.slice(1, byteWidth + 1);
    } else {
      unfilteredLine = Buffer.alloc(byteWidth);
      switch (filter2) {
        case 1:
          this._unFilterType1(rawData, unfilteredLine, byteWidth);
          break;
        case 2:
          this._unFilterType2(rawData, unfilteredLine, byteWidth);
          break;
        case 3:
          this._unFilterType3(rawData, unfilteredLine, byteWidth);
          break;
        case 4:
          this._unFilterType4(rawData, unfilteredLine, byteWidth);
          break;
        default:
          throw new Error("Unrecognised filter type - " + filter2);
      }
    }
    this.write(unfilteredLine);
    currentImage.lineIndex++;
    if (currentImage.lineIndex >= currentImage.height) {
      this._lastLine = null;
      this._imageIndex++;
      currentImage = this._images[this._imageIndex];
    } else {
      this._lastLine = unfilteredLine;
    }
    if (currentImage) {
      this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
    } else {
      this._lastLine = null;
      this.complete();
    }
  };
  return filterParse.exports;
}
var hasRequiredFilterParseAsync;
function requireFilterParseAsync() {
  if (hasRequiredFilterParseAsync) return filterParseAsync.exports;
  hasRequiredFilterParseAsync = 1;
  let util2 = require$$0$5;
  let ChunkStream = requireChunkstream();
  let Filter = requireFilterParse();
  let FilterAsync = filterParseAsync.exports = function(bitmapInfo) {
    ChunkStream.call(this);
    let buffers = [];
    let that = this;
    this._filter = new Filter(bitmapInfo, {
      read: this.read.bind(this),
      write: function(buffer2) {
        buffers.push(buffer2);
      },
      complete: function() {
        that.emit("complete", Buffer.concat(buffers));
      }
    });
    this._filter.start();
  };
  util2.inherits(FilterAsync, ChunkStream);
  return filterParseAsync.exports;
}
var parser = { exports: {} };
var constants;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  constants = {
    PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
    TYPE_IHDR: 1229472850,
    TYPE_IEND: 1229278788,
    TYPE_IDAT: 1229209940,
    TYPE_PLTE: 1347179589,
    TYPE_tRNS: 1951551059,
    // eslint-disable-line camelcase
    TYPE_gAMA: 1732332865,
    // eslint-disable-line camelcase
    // color-type bits
    COLORTYPE_GRAYSCALE: 0,
    COLORTYPE_PALETTE: 1,
    COLORTYPE_COLOR: 2,
    COLORTYPE_ALPHA: 4,
    // e.g. grayscale and alpha
    // color-type combinations
    COLORTYPE_PALETTE_COLOR: 3,
    COLORTYPE_COLOR_ALPHA: 6,
    COLORTYPE_TO_BPP_MAP: {
      0: 1,
      2: 3,
      3: 1,
      4: 2,
      6: 4
    },
    GAMMA_DIVISION: 1e5
  };
  return constants;
}
var crc = { exports: {} };
var hasRequiredCrc;
function requireCrc() {
  if (hasRequiredCrc) return crc.exports;
  hasRequiredCrc = 1;
  let crcTable = [];
  (function() {
    for (let i = 0; i < 256; i++) {
      let currentCrc = i;
      for (let j = 0; j < 8; j++) {
        if (currentCrc & 1) {
          currentCrc = 3988292384 ^ currentCrc >>> 1;
        } else {
          currentCrc = currentCrc >>> 1;
        }
      }
      crcTable[i] = currentCrc;
    }
  })();
  let CrcCalculator = crc.exports = function() {
    this._crc = -1;
  };
  CrcCalculator.prototype.write = function(data2) {
    for (let i = 0; i < data2.length; i++) {
      this._crc = crcTable[(this._crc ^ data2[i]) & 255] ^ this._crc >>> 8;
    }
    return true;
  };
  CrcCalculator.prototype.crc32 = function() {
    return this._crc ^ -1;
  };
  CrcCalculator.crc32 = function(buf) {
    let crc2 = -1;
    for (let i = 0; i < buf.length; i++) {
      crc2 = crcTable[(crc2 ^ buf[i]) & 255] ^ crc2 >>> 8;
    }
    return crc2 ^ -1;
  };
  return crc.exports;
}
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser.exports;
  hasRequiredParser = 1;
  let constants2 = requireConstants();
  let CrcCalculator = requireCrc();
  let Parser = parser.exports = function(options, dependencies) {
    this._options = options;
    options.checkCRC = options.checkCRC !== false;
    this._hasIHDR = false;
    this._hasIEND = false;
    this._emittedHeadersFinished = false;
    this._palette = [];
    this._colorType = 0;
    this._chunks = {};
    this._chunks[constants2.TYPE_IHDR] = this._handleIHDR.bind(this);
    this._chunks[constants2.TYPE_IEND] = this._handleIEND.bind(this);
    this._chunks[constants2.TYPE_IDAT] = this._handleIDAT.bind(this);
    this._chunks[constants2.TYPE_PLTE] = this._handlePLTE.bind(this);
    this._chunks[constants2.TYPE_tRNS] = this._handleTRNS.bind(this);
    this._chunks[constants2.TYPE_gAMA] = this._handleGAMA.bind(this);
    this.read = dependencies.read;
    this.error = dependencies.error;
    this.metadata = dependencies.metadata;
    this.gamma = dependencies.gamma;
    this.transColor = dependencies.transColor;
    this.palette = dependencies.palette;
    this.parsed = dependencies.parsed;
    this.inflateData = dependencies.inflateData;
    this.finished = dependencies.finished;
    this.simpleTransparency = dependencies.simpleTransparency;
    this.headersFinished = dependencies.headersFinished || function() {
    };
  };
  Parser.prototype.start = function() {
    this.read(constants2.PNG_SIGNATURE.length, this._parseSignature.bind(this));
  };
  Parser.prototype._parseSignature = function(data2) {
    let signature = constants2.PNG_SIGNATURE;
    for (let i = 0; i < signature.length; i++) {
      if (data2[i] !== signature[i]) {
        this.error(new Error("Invalid file signature"));
        return;
      }
    }
    this.read(8, this._parseChunkBegin.bind(this));
  };
  Parser.prototype._parseChunkBegin = function(data2) {
    let length = data2.readUInt32BE(0);
    let type2 = data2.readUInt32BE(4);
    let name = "";
    for (let i = 4; i < 8; i++) {
      name += String.fromCharCode(data2[i]);
    }
    let ancillary = Boolean(data2[4] & 32);
    if (!this._hasIHDR && type2 !== constants2.TYPE_IHDR) {
      this.error(new Error("Expected IHDR on beggining"));
      return;
    }
    this._crc = new CrcCalculator();
    this._crc.write(Buffer.from(name));
    if (this._chunks[type2]) {
      return this._chunks[type2](length);
    }
    if (!ancillary) {
      this.error(new Error("Unsupported critical chunk type " + name));
      return;
    }
    this.read(length + 4, this._skipChunk.bind(this));
  };
  Parser.prototype._skipChunk = function() {
    this.read(8, this._parseChunkBegin.bind(this));
  };
  Parser.prototype._handleChunkEnd = function() {
    this.read(4, this._parseChunkEnd.bind(this));
  };
  Parser.prototype._parseChunkEnd = function(data2) {
    let fileCrc = data2.readInt32BE(0);
    let calcCrc = this._crc.crc32();
    if (this._options.checkCRC && calcCrc !== fileCrc) {
      this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
      return;
    }
    if (!this._hasIEND) {
      this.read(8, this._parseChunkBegin.bind(this));
    }
  };
  Parser.prototype._handleIHDR = function(length) {
    this.read(length, this._parseIHDR.bind(this));
  };
  Parser.prototype._parseIHDR = function(data2) {
    this._crc.write(data2);
    let width = data2.readUInt32BE(0);
    let height = data2.readUInt32BE(4);
    let depth = data2[8];
    let colorType = data2[9];
    let compr = data2[10];
    let filter2 = data2[11];
    let interlace2 = data2[12];
    if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
      this.error(new Error("Unsupported bit depth " + depth));
      return;
    }
    if (!(colorType in constants2.COLORTYPE_TO_BPP_MAP)) {
      this.error(new Error("Unsupported color type"));
      return;
    }
    if (compr !== 0) {
      this.error(new Error("Unsupported compression method"));
      return;
    }
    if (filter2 !== 0) {
      this.error(new Error("Unsupported filter method"));
      return;
    }
    if (interlace2 !== 0 && interlace2 !== 1) {
      this.error(new Error("Unsupported interlace method"));
      return;
    }
    this._colorType = colorType;
    let bpp = constants2.COLORTYPE_TO_BPP_MAP[this._colorType];
    this._hasIHDR = true;
    this.metadata({
      width,
      height,
      depth,
      interlace: Boolean(interlace2),
      palette: Boolean(colorType & constants2.COLORTYPE_PALETTE),
      color: Boolean(colorType & constants2.COLORTYPE_COLOR),
      alpha: Boolean(colorType & constants2.COLORTYPE_ALPHA),
      bpp,
      colorType
    });
    this._handleChunkEnd();
  };
  Parser.prototype._handlePLTE = function(length) {
    this.read(length, this._parsePLTE.bind(this));
  };
  Parser.prototype._parsePLTE = function(data2) {
    this._crc.write(data2);
    let entries = Math.floor(data2.length / 3);
    for (let i = 0; i < entries; i++) {
      this._palette.push([data2[i * 3], data2[i * 3 + 1], data2[i * 3 + 2], 255]);
    }
    this.palette(this._palette);
    this._handleChunkEnd();
  };
  Parser.prototype._handleTRNS = function(length) {
    this.simpleTransparency();
    this.read(length, this._parseTRNS.bind(this));
  };
  Parser.prototype._parseTRNS = function(data2) {
    this._crc.write(data2);
    if (this._colorType === constants2.COLORTYPE_PALETTE_COLOR) {
      if (this._palette.length === 0) {
        this.error(new Error("Transparency chunk must be after palette"));
        return;
      }
      if (data2.length > this._palette.length) {
        this.error(new Error("More transparent colors than palette size"));
        return;
      }
      for (let i = 0; i < data2.length; i++) {
        this._palette[i][3] = data2[i];
      }
      this.palette(this._palette);
    }
    if (this._colorType === constants2.COLORTYPE_GRAYSCALE) {
      this.transColor([data2.readUInt16BE(0)]);
    }
    if (this._colorType === constants2.COLORTYPE_COLOR) {
      this.transColor([
        data2.readUInt16BE(0),
        data2.readUInt16BE(2),
        data2.readUInt16BE(4)
      ]);
    }
    this._handleChunkEnd();
  };
  Parser.prototype._handleGAMA = function(length) {
    this.read(length, this._parseGAMA.bind(this));
  };
  Parser.prototype._parseGAMA = function(data2) {
    this._crc.write(data2);
    this.gamma(data2.readUInt32BE(0) / constants2.GAMMA_DIVISION);
    this._handleChunkEnd();
  };
  Parser.prototype._handleIDAT = function(length) {
    if (!this._emittedHeadersFinished) {
      this._emittedHeadersFinished = true;
      this.headersFinished();
    }
    this.read(-length, this._parseIDAT.bind(this, length));
  };
  Parser.prototype._parseIDAT = function(length, data2) {
    this._crc.write(data2);
    if (this._colorType === constants2.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
      throw new Error("Expected palette not found");
    }
    this.inflateData(data2);
    let leftOverLength = length - data2.length;
    if (leftOverLength > 0) {
      this._handleIDAT(leftOverLength);
    } else {
      this._handleChunkEnd();
    }
  };
  Parser.prototype._handleIEND = function(length) {
    this.read(length, this._parseIEND.bind(this));
  };
  Parser.prototype._parseIEND = function(data2) {
    this._crc.write(data2);
    this._hasIEND = true;
    this._handleChunkEnd();
    if (this.finished) {
      this.finished();
    }
  };
  return parser.exports;
}
var bitmapper = {};
var hasRequiredBitmapper;
function requireBitmapper() {
  if (hasRequiredBitmapper) return bitmapper;
  hasRequiredBitmapper = 1;
  let interlaceUtils = requireInterlace();
  let pixelBppMapper = [
    // 0 - dummy entry
    function() {
    },
    // 1 - L
    // 0: 0, 1: 0, 2: 0, 3: 0xff
    function(pxData, data2, pxPos, rawPos) {
      if (rawPos === data2.length) {
        throw new Error("Ran out of data");
      }
      let pixel = data2[rawPos];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = 255;
    },
    // 2 - LA
    // 0: 0, 1: 0, 2: 0, 3: 1
    function(pxData, data2, pxPos, rawPos) {
      if (rawPos + 1 >= data2.length) {
        throw new Error("Ran out of data");
      }
      let pixel = data2[rawPos];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = data2[rawPos + 1];
    },
    // 3 - RGB
    // 0: 0, 1: 1, 2: 2, 3: 0xff
    function(pxData, data2, pxPos, rawPos) {
      if (rawPos + 2 >= data2.length) {
        throw new Error("Ran out of data");
      }
      pxData[pxPos] = data2[rawPos];
      pxData[pxPos + 1] = data2[rawPos + 1];
      pxData[pxPos + 2] = data2[rawPos + 2];
      pxData[pxPos + 3] = 255;
    },
    // 4 - RGBA
    // 0: 0, 1: 1, 2: 2, 3: 3
    function(pxData, data2, pxPos, rawPos) {
      if (rawPos + 3 >= data2.length) {
        throw new Error("Ran out of data");
      }
      pxData[pxPos] = data2[rawPos];
      pxData[pxPos + 1] = data2[rawPos + 1];
      pxData[pxPos + 2] = data2[rawPos + 2];
      pxData[pxPos + 3] = data2[rawPos + 3];
    }
  ];
  let pixelBppCustomMapper = [
    // 0 - dummy entry
    function() {
    },
    // 1 - L
    // 0: 0, 1: 0, 2: 0, 3: 0xff
    function(pxData, pixelData, pxPos, maxBit) {
      let pixel = pixelData[0];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = maxBit;
    },
    // 2 - LA
    // 0: 0, 1: 0, 2: 0, 3: 1
    function(pxData, pixelData, pxPos) {
      let pixel = pixelData[0];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = pixelData[1];
    },
    // 3 - RGB
    // 0: 0, 1: 1, 2: 2, 3: 0xff
    function(pxData, pixelData, pxPos, maxBit) {
      pxData[pxPos] = pixelData[0];
      pxData[pxPos + 1] = pixelData[1];
      pxData[pxPos + 2] = pixelData[2];
      pxData[pxPos + 3] = maxBit;
    },
    // 4 - RGBA
    // 0: 0, 1: 1, 2: 2, 3: 3
    function(pxData, pixelData, pxPos) {
      pxData[pxPos] = pixelData[0];
      pxData[pxPos + 1] = pixelData[1];
      pxData[pxPos + 2] = pixelData[2];
      pxData[pxPos + 3] = pixelData[3];
    }
  ];
  function bitRetriever(data2, depth) {
    let leftOver = [];
    let i = 0;
    function split() {
      if (i === data2.length) {
        throw new Error("Ran out of data");
      }
      let byte = data2[i];
      i++;
      let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
      switch (depth) {
        default:
          throw new Error("unrecognised depth");
        case 16:
          byte2 = data2[i];
          i++;
          leftOver.push((byte << 8) + byte2);
          break;
        case 4:
          byte2 = byte & 15;
          byte1 = byte >> 4;
          leftOver.push(byte1, byte2);
          break;
        case 2:
          byte4 = byte & 3;
          byte3 = byte >> 2 & 3;
          byte2 = byte >> 4 & 3;
          byte1 = byte >> 6 & 3;
          leftOver.push(byte1, byte2, byte3, byte4);
          break;
        case 1:
          byte8 = byte & 1;
          byte7 = byte >> 1 & 1;
          byte6 = byte >> 2 & 1;
          byte5 = byte >> 3 & 1;
          byte4 = byte >> 4 & 1;
          byte3 = byte >> 5 & 1;
          byte2 = byte >> 6 & 1;
          byte1 = byte >> 7 & 1;
          leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
          break;
      }
    }
    return {
      get: function(count) {
        while (leftOver.length < count) {
          split();
        }
        let returner = leftOver.slice(0, count);
        leftOver = leftOver.slice(count);
        return returner;
      },
      resetAfterLine: function() {
        leftOver.length = 0;
      },
      end: function() {
        if (i !== data2.length) {
          throw new Error("extra data found");
        }
      }
    };
  }
  function mapImage8Bit(image, pxData, getPxPos, bpp, data2, rawPos) {
    let imageWidth = image.width;
    let imageHeight = image.height;
    let imagePass = image.index;
    for (let y = 0; y < imageHeight; y++) {
      for (let x = 0; x < imageWidth; x++) {
        let pxPos = getPxPos(x, y, imagePass);
        pixelBppMapper[bpp](pxData, data2, pxPos, rawPos);
        rawPos += bpp;
      }
    }
    return rawPos;
  }
  function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
    let imageWidth = image.width;
    let imageHeight = image.height;
    let imagePass = image.index;
    for (let y = 0; y < imageHeight; y++) {
      for (let x = 0; x < imageWidth; x++) {
        let pixelData = bits.get(bpp);
        let pxPos = getPxPos(x, y, imagePass);
        pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
      }
      bits.resetAfterLine();
    }
  }
  bitmapper.dataToBitMap = function(data2, bitmapInfo) {
    let width = bitmapInfo.width;
    let height = bitmapInfo.height;
    let depth = bitmapInfo.depth;
    let bpp = bitmapInfo.bpp;
    let interlace2 = bitmapInfo.interlace;
    let bits;
    if (depth !== 8) {
      bits = bitRetriever(data2, depth);
    }
    let pxData;
    if (depth <= 8) {
      pxData = Buffer.alloc(width * height * 4);
    } else {
      pxData = new Uint16Array(width * height * 4);
    }
    let maxBit = Math.pow(2, depth) - 1;
    let rawPos = 0;
    let images;
    let getPxPos;
    if (interlace2) {
      images = interlaceUtils.getImagePasses(width, height);
      getPxPos = interlaceUtils.getInterlaceIterator(width, height);
    } else {
      let nonInterlacedPxPos = 0;
      getPxPos = function() {
        let returner = nonInterlacedPxPos;
        nonInterlacedPxPos += 4;
        return returner;
      };
      images = [{ width, height }];
    }
    for (let imageIndex = 0; imageIndex < images.length; imageIndex++) {
      if (depth === 8) {
        rawPos = mapImage8Bit(
          images[imageIndex],
          pxData,
          getPxPos,
          bpp,
          data2,
          rawPos
        );
      } else {
        mapImageCustomBit(
          images[imageIndex],
          pxData,
          getPxPos,
          bpp,
          bits,
          maxBit
        );
      }
    }
    if (depth === 8) {
      if (rawPos !== data2.length) {
        throw new Error("extra data found");
      }
    } else {
      bits.end();
    }
    return pxData;
  };
  return bitmapper;
}
var formatNormaliser;
var hasRequiredFormatNormaliser;
function requireFormatNormaliser() {
  if (hasRequiredFormatNormaliser) return formatNormaliser;
  hasRequiredFormatNormaliser = 1;
  function dePalette(indata, outdata, width, height, palette) {
    let pxPos = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let color = palette[indata[pxPos]];
        if (!color) {
          throw new Error("index " + indata[pxPos] + " not in palette");
        }
        for (let i = 0; i < 4; i++) {
          outdata[pxPos + i] = color[i];
        }
        pxPos += 4;
      }
    }
  }
  function replaceTransparentColor(indata, outdata, width, height, transColor) {
    let pxPos = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let makeTrans = false;
        if (transColor.length === 1) {
          if (transColor[0] === indata[pxPos]) {
            makeTrans = true;
          }
        } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
          makeTrans = true;
        }
        if (makeTrans) {
          for (let i = 0; i < 4; i++) {
            outdata[pxPos + i] = 0;
          }
        }
        pxPos += 4;
      }
    }
  }
  function scaleDepth(indata, outdata, width, height, depth) {
    let maxOutSample = 255;
    let maxInSample = Math.pow(2, depth) - 1;
    let pxPos = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        for (let i = 0; i < 4; i++) {
          outdata[pxPos + i] = Math.floor(
            indata[pxPos + i] * maxOutSample / maxInSample + 0.5
          );
        }
        pxPos += 4;
      }
    }
  }
  formatNormaliser = function(indata, imageData, skipRescale = false) {
    let depth = imageData.depth;
    let width = imageData.width;
    let height = imageData.height;
    let colorType = imageData.colorType;
    let transColor = imageData.transColor;
    let palette = imageData.palette;
    let outdata = indata;
    if (colorType === 3) {
      dePalette(indata, outdata, width, height, palette);
    } else {
      if (transColor) {
        replaceTransparentColor(indata, outdata, width, height, transColor);
      }
      if (depth !== 8 && !skipRescale) {
        if (depth === 16) {
          outdata = Buffer.alloc(width * height * 4);
        }
        scaleDepth(indata, outdata, width, height, depth);
      }
    }
    return outdata;
  };
  return formatNormaliser;
}
var hasRequiredParserAsync;
function requireParserAsync() {
  if (hasRequiredParserAsync) return parserAsync.exports;
  hasRequiredParserAsync = 1;
  let util2 = require$$0$5;
  let zlib$1 = zlib;
  let ChunkStream = requireChunkstream();
  let FilterAsync = requireFilterParseAsync();
  let Parser = requireParser();
  let bitmapper2 = requireBitmapper();
  let formatNormaliser2 = requireFormatNormaliser();
  let ParserAsync = parserAsync.exports = function(options) {
    ChunkStream.call(this);
    this._parser = new Parser(options, {
      read: this.read.bind(this),
      error: this._handleError.bind(this),
      metadata: this._handleMetaData.bind(this),
      gamma: this.emit.bind(this, "gamma"),
      palette: this._handlePalette.bind(this),
      transColor: this._handleTransColor.bind(this),
      finished: this._finished.bind(this),
      inflateData: this._inflateData.bind(this),
      simpleTransparency: this._simpleTransparency.bind(this),
      headersFinished: this._headersFinished.bind(this)
    });
    this._options = options;
    this.writable = true;
    this._parser.start();
  };
  util2.inherits(ParserAsync, ChunkStream);
  ParserAsync.prototype._handleError = function(err) {
    this.emit("error", err);
    this.writable = false;
    this.destroy();
    if (this._inflate && this._inflate.destroy) {
      this._inflate.destroy();
    }
    if (this._filter) {
      this._filter.destroy();
      this._filter.on("error", function() {
      });
    }
    this.errord = true;
  };
  ParserAsync.prototype._inflateData = function(data2) {
    if (!this._inflate) {
      if (this._bitmapInfo.interlace) {
        this._inflate = zlib$1.createInflate();
        this._inflate.on("error", this.emit.bind(this, "error"));
        this._filter.on("complete", this._complete.bind(this));
        this._inflate.pipe(this._filter);
      } else {
        let rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
        let imageSize = rowSize * this._bitmapInfo.height;
        let chunkSize = Math.max(imageSize, zlib$1.Z_MIN_CHUNK);
        this._inflate = zlib$1.createInflate({ chunkSize });
        let leftToInflate = imageSize;
        let emitError = this.emit.bind(this, "error");
        this._inflate.on("error", function(err) {
          if (!leftToInflate) {
            return;
          }
          emitError(err);
        });
        this._filter.on("complete", this._complete.bind(this));
        let filterWrite = this._filter.write.bind(this._filter);
        this._inflate.on("data", function(chunk) {
          if (!leftToInflate) {
            return;
          }
          if (chunk.length > leftToInflate) {
            chunk = chunk.slice(0, leftToInflate);
          }
          leftToInflate -= chunk.length;
          filterWrite(chunk);
        });
        this._inflate.on("end", this._filter.end.bind(this._filter));
      }
    }
    this._inflate.write(data2);
  };
  ParserAsync.prototype._handleMetaData = function(metaData) {
    this._metaData = metaData;
    this._bitmapInfo = Object.create(metaData);
    this._filter = new FilterAsync(this._bitmapInfo);
  };
  ParserAsync.prototype._handleTransColor = function(transColor) {
    this._bitmapInfo.transColor = transColor;
  };
  ParserAsync.prototype._handlePalette = function(palette) {
    this._bitmapInfo.palette = palette;
  };
  ParserAsync.prototype._simpleTransparency = function() {
    this._metaData.alpha = true;
  };
  ParserAsync.prototype._headersFinished = function() {
    this.emit("metadata", this._metaData);
  };
  ParserAsync.prototype._finished = function() {
    if (this.errord) {
      return;
    }
    if (!this._inflate) {
      this.emit("error", "No Inflate block");
    } else {
      this._inflate.end();
    }
  };
  ParserAsync.prototype._complete = function(filteredData) {
    if (this.errord) {
      return;
    }
    let normalisedBitmapData;
    try {
      let bitmapData = bitmapper2.dataToBitMap(filteredData, this._bitmapInfo);
      normalisedBitmapData = formatNormaliser2(
        bitmapData,
        this._bitmapInfo,
        this._options.skipRescale
      );
      bitmapData = null;
    } catch (ex) {
      this._handleError(ex);
      return;
    }
    this.emit("parsed", normalisedBitmapData);
  };
  return parserAsync.exports;
}
var packerAsync = { exports: {} };
var packer = { exports: {} };
var bitpacker;
var hasRequiredBitpacker;
function requireBitpacker() {
  if (hasRequiredBitpacker) return bitpacker;
  hasRequiredBitpacker = 1;
  let constants2 = requireConstants();
  bitpacker = function(dataIn, width, height, options) {
    let outHasAlpha = [constants2.COLORTYPE_COLOR_ALPHA, constants2.COLORTYPE_ALPHA].indexOf(
      options.colorType
    ) !== -1;
    if (options.colorType === options.inputColorType) {
      let bigEndian = function() {
        let buffer2 = new ArrayBuffer(2);
        new DataView(buffer2).setInt16(
          0,
          256,
          true
          /* littleEndian */
        );
        return new Int16Array(buffer2)[0] !== 256;
      }();
      if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {
        return dataIn;
      }
    }
    let data2 = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
    let maxValue = 255;
    let inBpp = constants2.COLORTYPE_TO_BPP_MAP[options.inputColorType];
    if (inBpp === 4 && !options.inputHasAlpha) {
      inBpp = 3;
    }
    let outBpp = constants2.COLORTYPE_TO_BPP_MAP[options.colorType];
    if (options.bitDepth === 16) {
      maxValue = 65535;
      outBpp *= 2;
    }
    let outData = Buffer.alloc(width * height * outBpp);
    let inIndex = 0;
    let outIndex = 0;
    let bgColor = options.bgColor || {};
    if (bgColor.red === void 0) {
      bgColor.red = maxValue;
    }
    if (bgColor.green === void 0) {
      bgColor.green = maxValue;
    }
    if (bgColor.blue === void 0) {
      bgColor.blue = maxValue;
    }
    function getRGBA() {
      let red;
      let green;
      let blue;
      let alpha = maxValue;
      switch (options.inputColorType) {
        case constants2.COLORTYPE_COLOR_ALPHA:
          alpha = data2[inIndex + 3];
          red = data2[inIndex];
          green = data2[inIndex + 1];
          blue = data2[inIndex + 2];
          break;
        case constants2.COLORTYPE_COLOR:
          red = data2[inIndex];
          green = data2[inIndex + 1];
          blue = data2[inIndex + 2];
          break;
        case constants2.COLORTYPE_ALPHA:
          alpha = data2[inIndex + 1];
          red = data2[inIndex];
          green = red;
          blue = red;
          break;
        case constants2.COLORTYPE_GRAYSCALE:
          red = data2[inIndex];
          green = red;
          blue = red;
          break;
        default:
          throw new Error(
            "input color type:" + options.inputColorType + " is not supported at present"
          );
      }
      if (options.inputHasAlpha) {
        if (!outHasAlpha) {
          alpha /= maxValue;
          red = Math.min(
            Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0),
            maxValue
          );
          green = Math.min(
            Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0),
            maxValue
          );
          blue = Math.min(
            Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0),
            maxValue
          );
        }
      }
      return { red, green, blue, alpha };
    }
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let rgba = getRGBA();
        switch (options.colorType) {
          case constants2.COLORTYPE_COLOR_ALPHA:
          case constants2.COLORTYPE_COLOR:
            if (options.bitDepth === 8) {
              outData[outIndex] = rgba.red;
              outData[outIndex + 1] = rgba.green;
              outData[outIndex + 2] = rgba.blue;
              if (outHasAlpha) {
                outData[outIndex + 3] = rgba.alpha;
              }
            } else {
              outData.writeUInt16BE(rgba.red, outIndex);
              outData.writeUInt16BE(rgba.green, outIndex + 2);
              outData.writeUInt16BE(rgba.blue, outIndex + 4);
              if (outHasAlpha) {
                outData.writeUInt16BE(rgba.alpha, outIndex + 6);
              }
            }
            break;
          case constants2.COLORTYPE_ALPHA:
          case constants2.COLORTYPE_GRAYSCALE: {
            let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
            if (options.bitDepth === 8) {
              outData[outIndex] = grayscale;
              if (outHasAlpha) {
                outData[outIndex + 1] = rgba.alpha;
              }
            } else {
              outData.writeUInt16BE(grayscale, outIndex);
              if (outHasAlpha) {
                outData.writeUInt16BE(rgba.alpha, outIndex + 2);
              }
            }
            break;
          }
          default:
            throw new Error("unrecognised color Type " + options.colorType);
        }
        inIndex += inBpp;
        outIndex += outBpp;
      }
    }
    return outData;
  };
  return bitpacker;
}
var filterPack;
var hasRequiredFilterPack;
function requireFilterPack() {
  if (hasRequiredFilterPack) return filterPack;
  hasRequiredFilterPack = 1;
  let paethPredictor2 = requirePaethPredictor();
  function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
    for (let x = 0; x < byteWidth; x++) {
      rawData[rawPos + x] = pxData[pxPos + x];
    }
  }
  function filterSumNone(pxData, pxPos, byteWidth) {
    let sum = 0;
    let length = pxPos + byteWidth;
    for (let i = pxPos; i < length; i++) {
      sum += Math.abs(pxData[i]);
    }
    return sum;
  }
  function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (let x = 0; x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let val = pxData[pxPos + x] - left;
      rawData[rawPos + x] = val;
    }
  }
  function filterSumSub(pxData, pxPos, byteWidth, bpp) {
    let sum = 0;
    for (let x = 0; x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let val = pxData[pxPos + x] - left;
      sum += Math.abs(val);
    }
    return sum;
  }
  function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
    for (let x = 0; x < byteWidth; x++) {
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let val = pxData[pxPos + x] - up;
      rawData[rawPos + x] = val;
    }
  }
  function filterSumUp(pxData, pxPos, byteWidth) {
    let sum = 0;
    let length = pxPos + byteWidth;
    for (let x = pxPos; x < length; x++) {
      let up = pxPos > 0 ? pxData[x - byteWidth] : 0;
      let val = pxData[x] - up;
      sum += Math.abs(val);
    }
    return sum;
  }
  function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (let x = 0; x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let val = pxData[pxPos + x] - (left + up >> 1);
      rawData[rawPos + x] = val;
    }
  }
  function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
    let sum = 0;
    for (let x = 0; x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let val = pxData[pxPos + x] - (left + up >> 1);
      sum += Math.abs(val);
    }
    return sum;
  }
  function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (let x = 0; x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
      let val = pxData[pxPos + x] - paethPredictor2(left, up, upleft);
      rawData[rawPos + x] = val;
    }
  }
  function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
    let sum = 0;
    for (let x = 0; x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
      let val = pxData[pxPos + x] - paethPredictor2(left, up, upleft);
      sum += Math.abs(val);
    }
    return sum;
  }
  let filters = {
    0: filterNone,
    1: filterSub,
    2: filterUp,
    3: filterAvg,
    4: filterPaeth
  };
  let filterSums = {
    0: filterSumNone,
    1: filterSumSub,
    2: filterSumUp,
    3: filterSumAvg,
    4: filterSumPaeth
  };
  filterPack = function(pxData, width, height, options, bpp) {
    let filterTypes;
    if (!("filterType" in options) || options.filterType === -1) {
      filterTypes = [0, 1, 2, 3, 4];
    } else if (typeof options.filterType === "number") {
      filterTypes = [options.filterType];
    } else {
      throw new Error("unrecognised filter types");
    }
    if (options.bitDepth === 16) {
      bpp *= 2;
    }
    let byteWidth = width * bpp;
    let rawPos = 0;
    let pxPos = 0;
    let rawData = Buffer.alloc((byteWidth + 1) * height);
    let sel = filterTypes[0];
    for (let y = 0; y < height; y++) {
      if (filterTypes.length > 1) {
        let min2 = Infinity;
        for (let i = 0; i < filterTypes.length; i++) {
          let sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
          if (sum < min2) {
            sel = filterTypes[i];
            min2 = sum;
          }
        }
      }
      rawData[rawPos] = sel;
      rawPos++;
      filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
      rawPos += byteWidth;
      pxPos += byteWidth;
    }
    return rawData;
  };
  return filterPack;
}
var hasRequiredPacker;
function requirePacker() {
  if (hasRequiredPacker) return packer.exports;
  hasRequiredPacker = 1;
  let constants2 = requireConstants();
  let CrcStream = requireCrc();
  let bitPacker = requireBitpacker();
  let filter2 = requireFilterPack();
  let zlib$1 = zlib;
  let Packer = packer.exports = function(options) {
    this._options = options;
    options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
    options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
    options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
    options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
    options.deflateFactory = options.deflateFactory || zlib$1.createDeflate;
    options.bitDepth = options.bitDepth || 8;
    options.colorType = typeof options.colorType === "number" ? options.colorType : constants2.COLORTYPE_COLOR_ALPHA;
    options.inputColorType = typeof options.inputColorType === "number" ? options.inputColorType : constants2.COLORTYPE_COLOR_ALPHA;
    if ([
      constants2.COLORTYPE_GRAYSCALE,
      constants2.COLORTYPE_COLOR,
      constants2.COLORTYPE_COLOR_ALPHA,
      constants2.COLORTYPE_ALPHA
    ].indexOf(options.colorType) === -1) {
      throw new Error(
        "option color type:" + options.colorType + " is not supported at present"
      );
    }
    if ([
      constants2.COLORTYPE_GRAYSCALE,
      constants2.COLORTYPE_COLOR,
      constants2.COLORTYPE_COLOR_ALPHA,
      constants2.COLORTYPE_ALPHA
    ].indexOf(options.inputColorType) === -1) {
      throw new Error(
        "option input color type:" + options.inputColorType + " is not supported at present"
      );
    }
    if (options.bitDepth !== 8 && options.bitDepth !== 16) {
      throw new Error(
        "option bit depth:" + options.bitDepth + " is not supported at present"
      );
    }
  };
  Packer.prototype.getDeflateOptions = function() {
    return {
      chunkSize: this._options.deflateChunkSize,
      level: this._options.deflateLevel,
      strategy: this._options.deflateStrategy
    };
  };
  Packer.prototype.createDeflate = function() {
    return this._options.deflateFactory(this.getDeflateOptions());
  };
  Packer.prototype.filterData = function(data2, width, height) {
    let packedData = bitPacker(data2, width, height, this._options);
    let bpp = constants2.COLORTYPE_TO_BPP_MAP[this._options.colorType];
    let filteredData = filter2(packedData, width, height, this._options, bpp);
    return filteredData;
  };
  Packer.prototype._packChunk = function(type2, data2) {
    let len = data2 ? data2.length : 0;
    let buf = Buffer.alloc(len + 12);
    buf.writeUInt32BE(len, 0);
    buf.writeUInt32BE(type2, 4);
    if (data2) {
      data2.copy(buf, 8);
    }
    buf.writeInt32BE(
      CrcStream.crc32(buf.slice(4, buf.length - 4)),
      buf.length - 4
    );
    return buf;
  };
  Packer.prototype.packGAMA = function(gamma) {
    let buf = Buffer.alloc(4);
    buf.writeUInt32BE(Math.floor(gamma * constants2.GAMMA_DIVISION), 0);
    return this._packChunk(constants2.TYPE_gAMA, buf);
  };
  Packer.prototype.packIHDR = function(width, height) {
    let buf = Buffer.alloc(13);
    buf.writeUInt32BE(width, 0);
    buf.writeUInt32BE(height, 4);
    buf[8] = this._options.bitDepth;
    buf[9] = this._options.colorType;
    buf[10] = 0;
    buf[11] = 0;
    buf[12] = 0;
    return this._packChunk(constants2.TYPE_IHDR, buf);
  };
  Packer.prototype.packIDAT = function(data2) {
    return this._packChunk(constants2.TYPE_IDAT, data2);
  };
  Packer.prototype.packIEND = function() {
    return this._packChunk(constants2.TYPE_IEND, null);
  };
  return packer.exports;
}
var hasRequiredPackerAsync;
function requirePackerAsync() {
  if (hasRequiredPackerAsync) return packerAsync.exports;
  hasRequiredPackerAsync = 1;
  let util2 = require$$0$5;
  let Stream = stream;
  let constants2 = requireConstants();
  let Packer = requirePacker();
  let PackerAsync = packerAsync.exports = function(opt) {
    Stream.call(this);
    let options = opt || {};
    this._packer = new Packer(options);
    this._deflate = this._packer.createDeflate();
    this.readable = true;
  };
  util2.inherits(PackerAsync, Stream);
  PackerAsync.prototype.pack = function(data2, width, height, gamma) {
    this.emit("data", Buffer.from(constants2.PNG_SIGNATURE));
    this.emit("data", this._packer.packIHDR(width, height));
    if (gamma) {
      this.emit("data", this._packer.packGAMA(gamma));
    }
    let filteredData = this._packer.filterData(data2, width, height);
    this._deflate.on("error", this.emit.bind(this, "error"));
    this._deflate.on(
      "data",
      function(compressedData) {
        this.emit("data", this._packer.packIDAT(compressedData));
      }.bind(this)
    );
    this._deflate.on(
      "end",
      function() {
        this.emit("data", this._packer.packIEND());
        this.emit("end");
      }.bind(this)
    );
    this._deflate.end(filteredData);
  };
  return packerAsync.exports;
}
var pngSync = {};
var syncInflate = { exports: {} };
var hasRequiredSyncInflate;
function requireSyncInflate() {
  if (hasRequiredSyncInflate) return syncInflate.exports;
  hasRequiredSyncInflate = 1;
  (function(module, exports) {
    let assert = require$$5$1.ok;
    let zlib$1 = zlib;
    let util2 = require$$0$5;
    let kMaxLength = require$$0$4$1.kMaxLength;
    function Inflate(opts) {
      if (!(this instanceof Inflate)) {
        return new Inflate(opts);
      }
      if (opts && opts.chunkSize < zlib$1.Z_MIN_CHUNK) {
        opts.chunkSize = zlib$1.Z_MIN_CHUNK;
      }
      zlib$1.Inflate.call(this, opts);
      this._offset = this._offset === void 0 ? this._outOffset : this._offset;
      this._buffer = this._buffer || this._outBuffer;
      if (opts && opts.maxLength != null) {
        this._maxLength = opts.maxLength;
      }
    }
    function createInflate(opts) {
      return new Inflate(opts);
    }
    function _close(engine, callback) {
      if (!engine._handle) {
        return;
      }
      engine._handle.close();
      engine._handle = null;
    }
    Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
      if (typeof asyncCb === "function") {
        return zlib$1.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
      }
      let self2 = this;
      let availInBefore = chunk && chunk.length;
      let availOutBefore = this._chunkSize - this._offset;
      let leftToInflate = this._maxLength;
      let inOff = 0;
      let buffers = [];
      let nread = 0;
      let error;
      this.on("error", function(err) {
        error = err;
      });
      function handleChunk(availInAfter, availOutAfter) {
        if (self2._hadError) {
          return;
        }
        let have = availOutBefore - availOutAfter;
        assert(have >= 0, "have should not go down");
        if (have > 0) {
          let out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (out.length > leftToInflate) {
            out = out.slice(0, leftToInflate);
          }
          buffers.push(out);
          nread += out.length;
          leftToInflate -= out.length;
          if (leftToInflate === 0) {
            return false;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          return true;
        }
        return false;
      }
      assert(this._handle, "zlib binding closed");
      let res;
      do {
        res = this._handle.writeSync(
          flushFlag,
          chunk,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
        res = res || this._writeState;
      } while (!this._hadError && handleChunk(res[0], res[1]));
      if (this._hadError) {
        throw error;
      }
      if (nread >= kMaxLength) {
        _close(this);
        throw new RangeError(
          "Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes"
        );
      }
      let buf = Buffer.concat(buffers, nread);
      _close(this);
      return buf;
    };
    util2.inherits(Inflate, zlib$1.Inflate);
    function zlibBufferSync(engine, buffer2) {
      if (typeof buffer2 === "string") {
        buffer2 = Buffer.from(buffer2);
      }
      if (!(buffer2 instanceof Buffer)) {
        throw new TypeError("Not a string or buffer");
      }
      let flushFlag = engine._finishFlushFlag;
      if (flushFlag == null) {
        flushFlag = zlib$1.Z_FINISH;
      }
      return engine._processChunk(buffer2, flushFlag);
    }
    function inflateSync(buffer2, opts) {
      return zlibBufferSync(new Inflate(opts), buffer2);
    }
    module.exports = exports = inflateSync;
    exports.Inflate = Inflate;
    exports.createInflate = createInflate;
    exports.inflateSync = inflateSync;
  })(syncInflate, syncInflate.exports);
  return syncInflate.exports;
}
var syncReader = { exports: {} };
var hasRequiredSyncReader;
function requireSyncReader() {
  if (hasRequiredSyncReader) return syncReader.exports;
  hasRequiredSyncReader = 1;
  let SyncReader = syncReader.exports = function(buffer2) {
    this._buffer = buffer2;
    this._reads = [];
  };
  SyncReader.prototype.read = function(length, callback) {
    this._reads.push({
      length: Math.abs(length),
      // if length < 0 then at most this length
      allowLess: length < 0,
      func: callback
    });
  };
  SyncReader.prototype.process = function() {
    while (this._reads.length > 0 && this._buffer.length) {
      let read = this._reads[0];
      if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {
        this._reads.shift();
        let buf = this._buffer;
        this._buffer = buf.slice(read.length);
        read.func.call(this, buf.slice(0, read.length));
      } else {
        break;
      }
    }
    if (this._reads.length > 0) {
      throw new Error("There are some read requests waitng on finished stream");
    }
    if (this._buffer.length > 0) {
      throw new Error("unrecognised content at end of stream");
    }
  };
  return syncReader.exports;
}
var filterParseSync = {};
var hasRequiredFilterParseSync;
function requireFilterParseSync() {
  if (hasRequiredFilterParseSync) return filterParseSync;
  hasRequiredFilterParseSync = 1;
  let SyncReader = requireSyncReader();
  let Filter = requireFilterParse();
  filterParseSync.process = function(inBuffer, bitmapInfo) {
    let outBuffers = [];
    let reader = new SyncReader(inBuffer);
    let filter2 = new Filter(bitmapInfo, {
      read: reader.read.bind(reader),
      write: function(bufferPart) {
        outBuffers.push(bufferPart);
      },
      complete: function() {
      }
    });
    filter2.start();
    reader.process();
    return Buffer.concat(outBuffers);
  };
  return filterParseSync;
}
var parserSync;
var hasRequiredParserSync;
function requireParserSync() {
  if (hasRequiredParserSync) return parserSync;
  hasRequiredParserSync = 1;
  let hasSyncZlib = true;
  let zlib$1 = zlib;
  let inflateSync = requireSyncInflate();
  if (!zlib$1.deflateSync) {
    hasSyncZlib = false;
  }
  let SyncReader = requireSyncReader();
  let FilterSync = requireFilterParseSync();
  let Parser = requireParser();
  let bitmapper2 = requireBitmapper();
  let formatNormaliser2 = requireFormatNormaliser();
  parserSync = function(buffer2, options) {
    if (!hasSyncZlib) {
      throw new Error(
        "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
      );
    }
    let err;
    function handleError2(_err_) {
      err = _err_;
    }
    let metaData;
    function handleMetaData(_metaData_) {
      metaData = _metaData_;
    }
    function handleTransColor(transColor) {
      metaData.transColor = transColor;
    }
    function handlePalette(palette) {
      metaData.palette = palette;
    }
    function handleSimpleTransparency() {
      metaData.alpha = true;
    }
    let gamma;
    function handleGamma(_gamma_) {
      gamma = _gamma_;
    }
    let inflateDataList = [];
    function handleInflateData(inflatedData2) {
      inflateDataList.push(inflatedData2);
    }
    let reader = new SyncReader(buffer2);
    let parser2 = new Parser(options, {
      read: reader.read.bind(reader),
      error: handleError2,
      metadata: handleMetaData,
      gamma: handleGamma,
      palette: handlePalette,
      transColor: handleTransColor,
      inflateData: handleInflateData,
      simpleTransparency: handleSimpleTransparency
    });
    parser2.start();
    reader.process();
    if (err) {
      throw err;
    }
    let inflateData = Buffer.concat(inflateDataList);
    inflateDataList.length = 0;
    let inflatedData;
    if (metaData.interlace) {
      inflatedData = zlib$1.inflateSync(inflateData);
    } else {
      let rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
      let imageSize = rowSize * metaData.height;
      inflatedData = inflateSync(inflateData, {
        chunkSize: imageSize,
        maxLength: imageSize
      });
    }
    inflateData = null;
    if (!inflatedData || !inflatedData.length) {
      throw new Error("bad png - invalid inflate data response");
    }
    let unfilteredData = FilterSync.process(inflatedData, metaData);
    inflateData = null;
    let bitmapData = bitmapper2.dataToBitMap(unfilteredData, metaData);
    unfilteredData = null;
    let normalisedBitmapData = formatNormaliser2(
      bitmapData,
      metaData,
      options.skipRescale
    );
    metaData.data = normalisedBitmapData;
    metaData.gamma = gamma || 0;
    return metaData;
  };
  return parserSync;
}
var packerSync;
var hasRequiredPackerSync;
function requirePackerSync() {
  if (hasRequiredPackerSync) return packerSync;
  hasRequiredPackerSync = 1;
  let hasSyncZlib = true;
  let zlib$1 = zlib;
  if (!zlib$1.deflateSync) {
    hasSyncZlib = false;
  }
  let constants2 = requireConstants();
  let Packer = requirePacker();
  packerSync = function(metaData, opt) {
    if (!hasSyncZlib) {
      throw new Error(
        "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
      );
    }
    let options = opt || {};
    let packer2 = new Packer(options);
    let chunks = [];
    chunks.push(Buffer.from(constants2.PNG_SIGNATURE));
    chunks.push(packer2.packIHDR(metaData.width, metaData.height));
    if (metaData.gamma) {
      chunks.push(packer2.packGAMA(metaData.gamma));
    }
    let filteredData = packer2.filterData(
      metaData.data,
      metaData.width,
      metaData.height
    );
    let compressedData = zlib$1.deflateSync(
      filteredData,
      packer2.getDeflateOptions()
    );
    filteredData = null;
    if (!compressedData || !compressedData.length) {
      throw new Error("bad png - invalid compressed data response");
    }
    chunks.push(packer2.packIDAT(compressedData));
    chunks.push(packer2.packIEND());
    return Buffer.concat(chunks);
  };
  return packerSync;
}
var hasRequiredPngSync;
function requirePngSync() {
  if (hasRequiredPngSync) return pngSync;
  hasRequiredPngSync = 1;
  let parse2 = requireParserSync();
  let pack = requirePackerSync();
  pngSync.read = function(buffer2, options) {
    return parse2(buffer2, options || {});
  };
  pngSync.write = function(png2, options) {
    return pack(png2, options);
  };
  return pngSync;
}
var hasRequiredPng;
function requirePng() {
  if (hasRequiredPng) return png;
  hasRequiredPng = 1;
  let util2 = require$$0$5;
  let Stream = stream;
  let Parser = requireParserAsync();
  let Packer = requirePackerAsync();
  let PNGSync = requirePngSync();
  let PNG = png.PNG = function(options) {
    Stream.call(this);
    options = options || {};
    this.width = options.width | 0;
    this.height = options.height | 0;
    this.data = this.width > 0 && this.height > 0 ? Buffer.alloc(4 * this.width * this.height) : null;
    if (options.fill && this.data) {
      this.data.fill(0);
    }
    this.gamma = 0;
    this.readable = this.writable = true;
    this._parser = new Parser(options);
    this._parser.on("error", this.emit.bind(this, "error"));
    this._parser.on("close", this._handleClose.bind(this));
    this._parser.on("metadata", this._metadata.bind(this));
    this._parser.on("gamma", this._gamma.bind(this));
    this._parser.on(
      "parsed",
      function(data2) {
        this.data = data2;
        this.emit("parsed", data2);
      }.bind(this)
    );
    this._packer = new Packer(options);
    this._packer.on("data", this.emit.bind(this, "data"));
    this._packer.on("end", this.emit.bind(this, "end"));
    this._parser.on("close", this._handleClose.bind(this));
    this._packer.on("error", this.emit.bind(this, "error"));
  };
  util2.inherits(PNG, Stream);
  PNG.sync = PNGSync;
  PNG.prototype.pack = function() {
    if (!this.data || !this.data.length) {
      this.emit("error", "No data provided");
      return this;
    }
    process.nextTick(
      function() {
        this._packer.pack(this.data, this.width, this.height, this.gamma);
      }.bind(this)
    );
    return this;
  };
  PNG.prototype.parse = function(data2, callback) {
    if (callback) {
      let onParsed, onError;
      onParsed = function(parsedData) {
        this.removeListener("error", onError);
        this.data = parsedData;
        callback(null, this);
      }.bind(this);
      onError = function(err) {
        this.removeListener("parsed", onParsed);
        callback(err, null);
      }.bind(this);
      this.once("parsed", onParsed);
      this.once("error", onError);
    }
    this.end(data2);
    return this;
  };
  PNG.prototype.write = function(data2) {
    this._parser.write(data2);
    return true;
  };
  PNG.prototype.end = function(data2) {
    this._parser.end(data2);
  };
  PNG.prototype._metadata = function(metadata) {
    this.width = metadata.width;
    this.height = metadata.height;
    this.emit("metadata", metadata);
  };
  PNG.prototype._gamma = function(gamma) {
    this.gamma = gamma;
  };
  PNG.prototype._handleClose = function() {
    if (!this._parser.writable && !this._packer.readable) {
      this.emit("close");
    }
  };
  PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
    srcX |= 0;
    srcY |= 0;
    width |= 0;
    height |= 0;
    deltaX |= 0;
    deltaY |= 0;
    if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
      throw new Error("bitblt reading outside image");
    }
    if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
      throw new Error("bitblt writing outside image");
    }
    for (let y = 0; y < height; y++) {
      src.data.copy(
        dst.data,
        (deltaY + y) * dst.width + deltaX << 2,
        (srcY + y) * src.width + srcX << 2,
        (srcY + y) * src.width + srcX + width << 2
      );
    }
  };
  PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
    PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
    return this;
  };
  PNG.adjustGamma = function(src) {
    if (src.gamma) {
      for (let y = 0; y < src.height; y++) {
        for (let x = 0; x < src.width; x++) {
          let idx = src.width * y + x << 2;
          for (let i = 0; i < 3; i++) {
            let sample = src.data[idx + i] / 255;
            sample = Math.pow(sample, 1 / 2.2 / src.gamma);
            src.data[idx + i] = Math.round(sample * 255);
          }
        }
      }
      src.gamma = 0;
    }
  };
  PNG.prototype.adjustGamma = function() {
    PNG.adjustGamma(this);
  };
  return png;
}
var hasRequiredFormatsNode;
function requireFormatsNode() {
  if (hasRequiredFormatsNode) return formatsNode.exports;
  hasRequiredFormatsNode = 1;
  const jpegJs2 = requireJpegJs();
  const { PNG } = requirePng();
  formatsNode.exports = {};
  formatsNode.exports.JPEG = ({ data: data2, width, height, quality }) => jpegJs2.encode({ data: data2, width, height }, Math.floor(quality * 100)).data;
  formatsNode.exports.PNG = ({ data: data2, width, height }) => {
    const png2 = new PNG({ width, height });
    png2.data = data2;
    return PNG.sync.write(png2, {
      width,
      height,
      deflateLevel: 9,
      deflateStrategy: 3,
      filterType: -1,
      colorType: 6,
      inputHasAlpha: true
    });
  };
  return formatsNode.exports;
}
var lib;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  lib = (decode, encode2) => {
    const convertImage = async ({ image, format, quality }) => {
      return await encode2[format]({
        width: image.width,
        height: image.height,
        data: image.data,
        quality
      });
    };
    const convert = async ({ buffer: buffer2, format, quality, all: all3 }) => {
      if (!encode2[format]) {
        throw new Error(`output format needs to be one of [${Object.keys(encode2)}]`);
      }
      if (!all3) {
        const image = await decode({ buffer: buffer2 });
        return await convertImage({ image, format, quality });
      }
      const images = await decode.all({ buffer: buffer2 });
      return images.map((image) => {
        return {
          convert: async () => await convertImage({
            image: await image.decode(),
            format,
            quality
          })
        };
      });
    };
    return {
      one: async ({ buffer: buffer2, format, quality = 0.92 }) => await convert({ buffer: buffer2, format, quality, all: false }),
      all: async ({ buffer: buffer2, format, quality = 0.92 }) => await convert({ buffer: buffer2, format, quality, all: true })
    };
  };
  return lib;
}
var hasRequiredHeicConvert;
function requireHeicConvert() {
  if (hasRequiredHeicConvert) return heicConvert.exports;
  hasRequiredHeicConvert = 1;
  const decode = requireHeicDecode();
  const formats2 = requireFormatsNode();
  const { one, all: all3 } = requireLib()(decode, formats2);
  heicConvert.exports = one;
  heicConvert.exports.all = all3;
  return heicConvert.exports;
}
var heicConvertExports = requireHeicConvert();
export {
  bilibiliApiUrls as a,
  bilibiliErrorCodeMap as b,
  getDouyinData as c,
  browserExports as d,
  distExports as e,
  logMiddleware as f,
  getBilibiliData as g,
  heicConvertExports as h,
  createBilibiliRoutes as i,
  createDouyinRoutes as j,
  createKuaishouRoutes as k,
  libExports as l,
  logger$1 as m,
  v5_default as v,
  wbi_sign as w
};
