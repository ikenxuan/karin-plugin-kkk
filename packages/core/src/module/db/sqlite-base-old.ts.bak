import { existsSync, mkdirSync } from 'node:fs'
import { dirname, join } from 'node:path'

import { logger } from 'node-karin'
import { karinPathBase } from 'node-karin/root'
import { Database } from 'sqlite3'

import { Root } from '@/module/utils'

/**
 * SQLite3 数据库基础操作类
 */
export class SQLiteBase {
  protected db!: Database
  protected dbPath: string

  constructor (dbName: string) {
    this.dbPath = join(`${karinPathBase}/${Root.pluginName}/data`, dbName)

    // 确保数据目录存在
    const dataDir = dirname(this.dbPath)
    if (!existsSync(dataDir)) {
      mkdirSync(dataDir, { recursive: true })
    }
  }

  /**
   * 初始化数据库连接
   */
  async init (): Promise<void> {
    return new Promise((resolve, reject) => {
      this.db = new Database(this.dbPath, (err) => {
        if (err) {
          logger.error(`[SQLiteBase] 数据库连接失败: ${err.message}`)
          reject(err)
        } else {
          logger.debug(`[SQLiteBase] 数据库连接成功: ${this.dbPath}`)
          resolve()
        }
      })
    })
  }

  /**
   * 执行 SQL 查询（返回单行）
   * @param sql SQL 语句
   * @param params 参数
   */
  async get<T = any>(sql: string, params: any[] = []): Promise<T | undefined> {
    return new Promise((resolve, reject) => {
      this.db.get(sql, params, (err, row) => {
        if (err) {
          logger.error(`[SQLiteBase] SQL 查询失败: ${err.message}`)
          logger.error(`[SQLiteBase] SQL: ${sql}`)
          logger.error(`[SQLiteBase] Params: ${JSON.stringify(params)}`)
          reject(err)
        } else {
          resolve(row as T)
        }
      })
    })
  }

  /**
   * 执行 SQL 查询（返回多行）
   * @param sql SQL 语句
   * @param params 参数
   */
  async all<T = any>(sql: string, params: any[] = []): Promise<T[]> {
    return new Promise((resolve, reject) => {
      this.db.all(sql, params, (err, rows) => {
        if (err) {
          logger.error(`[SQLiteBase] SQL 查询失败: ${err.message}`)
          logger.error(`[SQLiteBase] SQL: ${sql}`)
          logger.error(`[SQLiteBase] Params: ${JSON.stringify(params)}`)
          reject(err)
        } else {
          resolve(rows as T[])
        }
      })
    })
  }

  /**
   * 执行 SQL 语句（插入、更新、删除）
   * @param sql SQL 语句
   * @param params 参数
   */
  async run (sql: string, params: any[] = []): Promise<{ lastID: number; changes: number }> {
    return new Promise((resolve, reject) => {
      this.db.run(sql, params, function (err) {
        if (err) {
          logger.error(`[SQLiteBase] SQL 执行失败: ${err.message}`)
          logger.error(`[SQLiteBase] SQL: ${sql}`)
          logger.error(`[SQLiteBase] Params: ${JSON.stringify(params)}`)
          reject(err)
        } else {
          resolve({ lastID: this.lastID, changes: this.changes })
        }
      })
    })
  }

  /**
   * 执行事务
   * @param operations 事务操作数组
   */
  async transaction (operations: Array<{ sql: string; params?: any[] }>): Promise<void> {
    return new Promise((resolve, reject) => {
      this.db.serialize(() => {
        this.db.run('BEGIN TRANSACTION', (err) => {
          if (err) {
            reject(err)
            return
          }

          let completed = 0
          const total = operations.length
          let hasError = false

          if (total === 0) {
            this.db.run('COMMIT', (commitErr) => {
              if (commitErr) reject(commitErr)
              else resolve()
            })
            return
          }

          operations.forEach(({ sql, params = [] }) => {
            this.db.run(sql, params, (opErr) => {
              if (opErr && !hasError) {
                hasError = true
                this.db.run('ROLLBACK', () => {
                  reject(opErr)
                })
                return
              }

              completed++
              if (completed === total && !hasError) {
                this.db.run('COMMIT', (commitErr) => {
                  if (commitErr) reject(commitErr)
                  else resolve()
                })
              }
            })
          })
        })
      })
    })
  }

  /**
   * 检查表是否存在
   * @param tableName 表名
   */
  async tableExists (tableName: string): Promise<boolean> {
    const row = await this.get<{ count: number }>(
      "SELECT COUNT(*) as count FROM sqlite_master WHERE type='table' AND name=?",
      [tableName]
    )
    return (row?.count || 0) > 0
  }

  /**
   * 创建表（如果不存在）
   * @param createTableSQL 创建表的 SQL 语句
   */
  async createTableIfNotExists (createTableSQL: string): Promise<void> {
    await this.run(createTableSQL)
  }

  /**
   * 关闭数据库连接
   */
  async close (): Promise<void> {
    return new Promise((resolve, reject) => {
      this.db.close((err) => {
        if (err) {
          logger.error(`[SQLiteBase] 关闭数据库连接失败: ${err.message}`)
          reject(err)
        } else {
          logger.debug('[SQLiteBase] 数据库连接已关闭')
          resolve()
        }
      })
    })
  }

  /**
   * 获取当前时间戳字符串
   */
  protected now (): string {
    return new Date().toISOString()
  }
}
